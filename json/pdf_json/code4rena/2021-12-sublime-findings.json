[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IStrategyRegistry.sol';\n\n/**\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n **/\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     **/\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /**\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId => Strategy => collateralShares\n     **/\n    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;\n\n    /**\n     * @notice stores the variables to maintain a credit line\n     **/\n    mapping(uint256 => CreditLineVariables) public creditLineVariables;\n\n    /**\n     * @notice stores the constants related to a credit line\n     **/\n    mapping(uint256 => CreditLineConstants) public creditLineConstants;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address public savingsAccount;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    address public priceOracle;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    address public strategyRegistry;\n\n    /**\n     * @notice stores the address of default strategy\n     **/\n    address public defaultStrategy;\n\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    /**\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public liquidatorRewardFraction;\n    /**\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     **/\n    modifier ifCreditLineExists(uint256 _id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineLender(uint256 _id) {\n        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');\n        _;\n    }\n\n    /**\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /**\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     */\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /**\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /**\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /**\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     */\n    event CreditLineAccepted(uint256 indexed id);\n\n    /**\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /**\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /**\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     */\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /**\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /**\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /**\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /**\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), 'cant be 0 address');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'CL::I zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /**\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /**\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(\n            10**_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible > _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible > _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');\n    }\n\n    /**\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /**\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),\n            \"Only Borrower or Lender who hasn't requested can accept\"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /**\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, \"CreditLine::_depositCollateral - value to transfer doesn't match argument\");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, 'insufficient balance');\n    }\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\n            require(feeSuccess, 'Transfer fail');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\n            require(success, 'Transfer fail');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /**\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount >= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount > _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /**\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     */\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            'CreditLine: Permission denied while closing Line of credit'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 10**30 to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(\n            10**_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10**_decimals)\n            .div(10**30);\n\n        if (_collateralNeeded >= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert('insufficient collateral');\n    }\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,\n            'CreditLine: Collateral ratio is higher than ideal value'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}('');\n                    require(success, 'Transfer fail');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /**\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ncontract Migrations {\n    address public owner = msg.sender;\n    uint256 public last_completed_migration;\n\n    modifier restricted() {\n        require(msg.sender == owner, \"This function is restricted to the contract's owner\");\n        _;\n    }\n\n    function setCompleted(uint256 completed) public restricted {\n        last_completed_migration = completed;\n    }\n}\n\n\n",
        "CodeNames": [
            "CreditLine.sol",
            "Migrations.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "liquidate",
                    "(uint"
                ],
                "Type": " In  CreditLine#_borrowTokensToLiquidate , oracle is used wrong way",
                "Description": "\nCurrent implementation to get the price is as follows:\n\n(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050\n\nBut it should not consult borrowToken / collateralToken, rather it should consult the inverse of this result. As a consequence, in liquidate the liquidator/lender can lose/gain funds as a result of this miscalculation.\n\n\nReplace it with\n\n(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_collateralAsset, _borrowAsset);\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/155)\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IStrategyRegistry.sol';\n\n/**\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n **/\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     **/\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /**\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId => Strategy => collateralShares\n     **/\n    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;\n\n    /**\n     * @notice stores the variables to maintain a credit line\n     **/\n    mapping(uint256 => CreditLineVariables) public creditLineVariables;\n\n    /**\n     * @notice stores the constants related to a credit line\n     **/\n    mapping(uint256 => CreditLineConstants) public creditLineConstants;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address public savingsAccount;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    address public priceOracle;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    address public strategyRegistry;\n\n    /**\n     * @notice stores the address of default strategy\n     **/\n    address public defaultStrategy;\n\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    /**\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public liquidatorRewardFraction;\n    /**\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     **/\n    modifier ifCreditLineExists(uint256 _id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineLender(uint256 _id) {\n        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');\n        _;\n    }\n\n    /**\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /**\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     */\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /**\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /**\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /**\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     */\n    event CreditLineAccepted(uint256 indexed id);\n\n    /**\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /**\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /**\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     */\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /**\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /**\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /**\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /**\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), 'cant be 0 address');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'CL::I zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /**\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /**\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(\n            10**_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible > _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible > _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');\n    }\n\n    /**\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /**\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),\n            \"Only Borrower or Lender who hasn't requested can accept\"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /**\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, \"CreditLine::_depositCollateral - value to transfer doesn't match argument\");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, 'insufficient balance');\n    }\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\n            require(feeSuccess, 'Transfer fail');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\n            require(success, 'Transfer fail');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /**\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount >= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount > _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /**\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     */\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            'CreditLine: Permission denied while closing Line of credit'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 10**30 to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(\n            10**_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10**_decimals)\n            .div(10**30);\n\n        if (_collateralNeeded >= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert('insufficient collateral');\n    }\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,\n            'CreditLine: Collateral ratio is higher than ideal value'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}('');\n                    require(success, 'Transfer fail');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /**\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '../interfaces/ISavingsAccount.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nlibrary SavingsAccountUtil {\n    using SafeERC20 for IERC20;\n\n    function depositFromSavingsAccount(\n        ISavingsAccount _savingsAccount,\n        address _from,\n        address _to,\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        bool _withdrawShares,\n        bool _toSavingsAccount\n    ) internal returns (uint256) {\n        if (_toSavingsAccount) {\n            return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);\n        } else {\n            return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);\n        }\n    }\n\n    function directDeposit(\n        ISavingsAccount _savingsAccount,\n        address _from,\n        address _to,\n        uint256 _amount,\n        address _token,\n        bool _toSavingsAccount,\n        address _strategy\n    ) internal returns (uint256) {\n        if (_toSavingsAccount) {\n            return directSavingsAccountDeposit(_savingsAccount, _from, _to, _amount, _token, _strategy);\n        } else {\n            return transferTokens(_token, _amount, _from, _to);\n        }\n    }\n\n    function directSavingsAccountDeposit(\n        ISavingsAccount _savingsAccount,\n        address _from,\n        address _to,\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256 _sharesReceived) {\n        transferTokens(_token, _amount, _from, address(this));\n        uint256 _ethValue;\n        if (_token == address(0)) {\n            _ethValue = _amount;\n        } else {\n            address _approveTo = _strategy;\n            if (_strategy == address(0)) {\n                _approveTo = address(_savingsAccount);\n            }\n            IERC20(_token).safeApprove(_approveTo, _amount);\n        }\n        _sharesReceived = _savingsAccount.deposit{value: _ethValue}(_amount, _token, _strategy, _to);\n    }\n\n    function savingsAccountTransfer(\n        ISavingsAccount _savingsAccount,\n        address _from,\n        address _to,\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256) {\n        if (_from == address(this)) {\n            _savingsAccount.transfer(_amount, _token, _strategy, _to);\n        } else {\n            _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);\n        }\n        return _amount;\n    }\n\n    function withdrawFromSavingsAccount(\n        ISavingsAccount _savingsAccount,\n        address _from,\n        address _to,\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        bool _withdrawShares\n    ) internal returns (uint256 _amountReceived) {\n        if (_from == address(this)) {\n            _amountReceived = _savingsAccount.withdraw(_amount, _token, _strategy, payable(_to), _withdrawShares);\n        } else {\n            _amountReceived = _savingsAccount.withdrawFrom(_amount, _token, _strategy, _from, payable(_to), _withdrawShares);\n        }\n    }\n\n    function transferTokens(\n        address _token,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal returns (uint256) {\n        if (_amount == 0) {\n            return 0;\n        }\n        if (_token == address(0)) {\n            require(msg.value >= _amount, 'ethers provided should be greater than _amount');\n\n            if (_to != address(this)) {\n                (bool success, ) = payable(_to).call{value: _amount}('');\n                require(success, 'Transfer failed');\n            }\n            if (msg.value > _amount) {\n                (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}('');\n                require(success, 'Transfer failed');\n            }\n            return _amount;\n        }\n        if (_from == address(this)) {\n            IERC20(_token).safeTransfer(_to, _amount);\n        } else {\n            //pool\n            IERC20(_token).safeTransferFrom(_from, _to, _amount);\n        }\n        return _amount;\n    }\n}\n\n\n/**\n *Submitted for verification at Etherscan.io on 2020-08-11\n */\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\ninterface IStrategy {\n    function want() external view returns (address);\n\n    function deposit() external;\n\n    function withdraw(address) external;\n\n    function withdraw(uint256) external;\n\n    function withdrawAll() external returns (uint256);\n\n    function balanceOf() external view returns (uint256);\n}\n\ninterface Converter {\n    function convert(address) external returns (uint256);\n}\n\ninterface OneSplitAudit {\n    function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution,\n        uint256 flags\n    ) external payable returns (uint256 returnAmount);\n\n    function getExpectedReturn(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags // See constants in IOneSplit.sol\n    ) external view returns (uint256 returnAmount, uint256[] memory distribution);\n}\n\ncontract Controller {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public governance;\n    address public strategist;\n\n    address public onesplit;\n    address public rewards;\n    mapping(address => address) public vaults;\n    mapping(address => address) public strategies;\n    mapping(address => mapping(address => address)) public converters;\n\n    mapping(address => mapping(address => bool)) public approvedStrategies;\n\n    uint256 public split = 500;\n    uint256 public constant max = 10000;\n\n    constructor(address _rewards) {\n        governance = msg.sender;\n        strategist = msg.sender;\n        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);\n        rewards = _rewards;\n    }\n\n    function setRewards(address _rewards) public {\n        require(msg.sender == governance, '!governance');\n        rewards = _rewards;\n    }\n\n    function setStrategist(address _strategist) public {\n        require(msg.sender == governance, '!governance');\n        strategist = _strategist;\n    }\n\n    function setSplit(uint256 _split) public {\n        require(msg.sender == governance, '!governance');\n        split = _split;\n    }\n\n    function setOneSplit(address _onesplit) public {\n        require(msg.sender == governance, '!governance');\n        onesplit = _onesplit;\n    }\n\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, '!governance');\n        governance = _governance;\n    }\n\n    function setVault(address _token, address _vault) public {\n        require(msg.sender == strategist || msg.sender == governance, '!strategist');\n        require(vaults[_token] == address(0), 'vault');\n        vaults[_token] = _vault;\n    }\n\n    function approveStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, '!governance');\n        approvedStrategies[_token][_strategy] = true;\n    }\n\n    function revokeStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, '!governance');\n        approvedStrategies[_token][_strategy] = false;\n    }\n\n    function setConverter(\n        address _input,\n        address _output,\n        address _converter\n    ) public {\n        require(msg.sender == strategist || msg.sender == governance, '!strategist');\n        converters[_input][_output] = _converter;\n    }\n\n    function setStrategy(address _token, address _strategy) public {\n        require(msg.sender == strategist || msg.sender == governance, '!strategist');\n        require(approvedStrategies[_token][_strategy], '!approved');\n\n        address _current = strategies[_token];\n        if (_current != address(0)) {\n            IStrategy(_current).withdrawAll();\n        }\n        strategies[_token] = _strategy;\n    }\n\n    function earn(address _token, uint256 _amount) public {\n        address _strategy = strategies[_token];\n        address _want = IStrategy(_strategy).want();\n        if (_want != _token) {\n            address converter = converters[_token][_want];\n            IERC20(_token).safeTransfer(converter, _amount);\n            _amount = Converter(converter).convert(_strategy);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        IStrategy(_strategy).deposit();\n    }\n\n    function balanceOf(address _token) external view returns (uint256) {\n        return IStrategy(strategies[_token]).balanceOf();\n    }\n\n    function withdrawAll(address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, '!strategist');\n        IStrategy(strategies[_token]).withdrawAll();\n    }\n\n    function inCaseTokensGetStuck(address _token, uint256 _amount) public {\n        require(msg.sender == strategist || msg.sender == governance, '!governance');\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    function inCaseStrategyTokenGetStuck(address _strategy, address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, '!governance');\n        IStrategy(_strategy).withdraw(_token);\n    }\n\n    function getExpectedReturn(\n        address _strategy,\n        address _token,\n        uint256 parts\n    ) public view returns (uint256 expected) {\n        uint256 _balance = IERC20(_token).balanceOf(_strategy);\n        address _want = IStrategy(_strategy).want();\n        (expected, ) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _balance, parts, 0);\n    }\n\n    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield\n    function yearn(\n        address _strategy,\n        address _token,\n        uint256 parts\n    ) public {\n        require(msg.sender == strategist || msg.sender == governance, '!governance');\n        // This contract should never have value in it, but just incase since this is a public call\n        uint256 _before = IERC20(_token).balanceOf(address(this));\n        IStrategy(_strategy).withdraw(_token);\n        uint256 _after = IERC20(_token).balanceOf(address(this));\n        if (_after > _before) {\n            uint256 _amount = _after.sub(_before);\n            address _want = IStrategy(_strategy).want();\n            uint256[] memory _distribution;\n            uint256 _expected;\n            _before = IERC20(_want).balanceOf(address(this));\n            IERC20(_token).safeApprove(onesplit, 0);\n            IERC20(_token).safeApprove(onesplit, _amount);\n            (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0);\n            OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0);\n            _after = IERC20(_want).balanceOf(address(this));\n            if (_after > _before) {\n                _amount = _after.sub(_before);\n                uint256 _reward = _amount.mul(split).div(max);\n                earn(_want, _amount.sub(_reward));\n                IERC20(_want).safeTransfer(rewards, _reward);\n            }\n        }\n    }\n\n    function withdraw(address _token, uint256 _amount) public {\n        require(msg.sender == vaults[_token], '!vault');\n        IStrategy(strategies[_token]).withdraw(_amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IExtension.sol';\nimport '../interfaces/IVerification.sol';\n\n/**\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n\n    address poolFactory;\n\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n\n    /**\n     * @notice used to keep track of lenders' details\n     */\n    mapping(address => LendingDetails) public lenders;\n\n    /**\n     * @notice object of type PoolConstants\n     */\n    PoolConstants public poolConstants;\n\n    /**\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n\n    /**\n     * @notice checks if the _user is pool's valid borrower\n     * @param _user address of the borrower\n     */\n    modifier onlyBorrower(address _user) {\n        require(_user == poolConstants.borrower, 'OB1');\n        _;\n    }\n\n    /**\n     * @notice checks if the _lender is pool's valid lender\n     * @param _lender address of the lender\n     */\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, 'IL1');\n        _;\n    }\n\n    /**\n     * @notice checks if the msg.sender is pool's valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');\n        _;\n    }\n\n    /**\n     * @notice checks if the msg.sender is pool's latest repayment implementation\n     */\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');\n        _;\n    }\n\n    /**\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     */\n    function initialize(\n        uint256 _borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init('Pool Tokens', 'PT');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n\n    /**\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, 'DC1');\n        require(balanceOf(msg.sender) == 0, 'DC2');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n\n    /**\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n\n    /**\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     */\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n\n    /**\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n\n    /**\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet\n     */\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');\n        require(balanceOf(msg.sender) == 0, 'ACMC2');\n        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');\n\n        require(_amount != 0, 'ACMC4');\n\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n\n        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n\n    /**\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     */\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &&\n                poolConstants.loanStartTime < block.timestamp &&\n                block.timestamp < poolConstants.loanWithdrawalDeadline,\n            'WBA1'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');\n\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');\n\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);\n        delete poolConstants.loanWithdrawalDeadline;\n\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n\n    /**\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n\n    /**\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     */\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower && _borrower != msg.sender, 'L1');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n\n    /**\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), 'TT1');\n        }\n        require(_to != poolConstants.borrower, 'TT2');\n\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');\n        }\n        require(getMarginCallEndTime(_from) == 0, 'TT3');\n        require(getMarginCallEndTime(_to) == 0, 'TT4');\n\n        //Withdraw repayments for user\n\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp > _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp > _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n\n    /**\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n\n        if (\n            _loanStartTime < block.timestamp &&\n            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)\n        ) {\n            return _cancelPool(0);\n        }\n\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n\n        if (_loanWithdrawalDeadline > block.timestamp) {\n            require(msg.sender == poolConstants.borrower, 'CP2');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(10**30)\n            .mul(_collateralLiquidityShare)\n            .div(10**30)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n\n    /**\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n\n    /**\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     */\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');\n        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n\n    /**\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     */\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n\n    /**\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');\n\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n\n        emit PoolClosed();\n    }\n\n    /**\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     */\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            'WL1'\n        );\n\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n\n    /**\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     */\n\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');\n        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');\n\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n\n        emit MarginCalled(msg.sender);\n    }\n\n    /**\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(10**30);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));\n        if (_loanDurationTillNow <= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);\n\n        return _interestAccrued;\n    }\n\n    /**\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));\n    }\n\n    /**\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n\n    /**\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     */\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n\n    /**\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     */\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        uint256 _collateralTokens = _collateralLiquidityShare;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);\n\n        uint256 _poolBorrowTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        delete poolVariables.extraLiquidityShares;\n        delete poolVariables.baseLiquidityShares;\n\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));\n        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);\n        emit PoolLiquidated(msg.sender);\n    }\n\n    /**\n     * @notice internal function used to withdraw tokens\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     * @param _asset address of the asset to be withdrawn\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _amountInTokens amount of tokens to be withdrawn from the pool\n     * @return amount of equivalent shares from given asset\n     */\n    function _withdraw(\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare,\n        address _asset,\n        address _poolSavingsStrategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n        return\n            SavingsAccountUtil.depositFromSavingsAccount(\n                _savingsAccount,\n                address(this),\n                msg.sender,\n                _amountInTokens,\n                _asset,\n                _poolSavingsStrategy,\n                _recieveLiquidityShare,\n                _toSavingsAccount\n            );\n    }\n\n    /**\n     * @notice used to ensure if a lender can be liquidated\n     * @param _lender address of the lender to be liquidated\n     */\n    function _canLenderBeLiquidated(address _lender) internal {\n        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');\n        require(_marginCallEndTime < block.timestamp, 'CLBL3');\n\n        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');\n        require(balanceOf(_lender) != 0, 'CLBL5');\n    }\n\n    /**\n     * @notice used to add extra liquidity shares to lender's share\n     * @param _lender address of the lender to be liquidated\n     * @return _lenderCollateralLPShare share of the lender in collateral tokens\n     * @return _lenderBalance balance of lender in pool tokens\n     */\n    function _updateLenderSharesDuringLiquidation(address _lender)\n        internal\n        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)\n    {\n        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;\n        _lenderBalance = balanceOf(_lender);\n\n        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());\n        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;\n        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);\n\n        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);\n    }\n\n    /**\n     * @notice internal function to liquidate lender of the borrow pool\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _lender address of the lender to be liquidated\n     * @param _lenderCollateralTokens share of the lender in collateral tokens\n     */\n    function _liquidateForLender(\n        bool _fromSavingsAccount,\n        address _lender,\n        uint256 _lenderCollateralTokens\n    ) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(\n            _lenderCollateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);\n        _withdrawRepayment(_lender);\n    }\n\n    /**\n     * @notice used to liquidate lender and burn lender's shares\n     * @param _lender address of the lender to be liquidated\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     */\n    function liquidateForLender(\n        address _lender,\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        _canLenderBeLiquidated(_lender);\n\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);\n\n        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;\n        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);\n\n        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);\n\n        uint256 _amountReceived = _withdraw(\n            _toSavingsAccount,\n            _recieveLiquidityShare,\n            poolConstants.collateralAsset,\n            _poolSavingsStrategy,\n            _lenderCollateralTokens\n        );\n        _burn(_lender, _lenderBalance);\n        delete lenders[_lender];\n        emit LenderLiquidated(msg.sender, _lender, _amountReceived);\n    }\n\n    /**\n     * @notice used to get corresponding borrow tokens for given collateral tokens\n     * @param _totalCollateralTokens amount of collateral tokens\n     * @param _priceOracle address of the pool\n     * @param _fraction Incentivizing fraction for the liquidator\n     * @return corresponding borrow tokens for collateral tokens\n     */\n    function correspondingBorrowTokens(\n        uint256 _totalCollateralTokens,\n        address _priceOracle,\n        uint256 _fraction\n    ) public view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(\n            poolConstants.collateralAsset,\n            poolConstants.borrowAsset\n        );\n        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);\n    }\n\n    /**\n     * @notice used to get the interest per second on the principal amount\n     * @param _principal amount of principal lent\n     * @return interest accrued on the principal in a second\n     */\n    function interestPerSecond(uint256 _principal) public view returns (uint256) {\n        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);\n        return _interest;\n    }\n\n    /**\n     * @notice used to get the interest per period on the principal amount\n     * @param _balance amount of principal lent\n     * @return interest accrued on the principal in a period\n     */\n    function interestPerPeriod(uint256 _balance) external view returns (uint256) {\n        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));\n    }\n\n    /**\n     * @notice used to get the current repayment period for the borrow pool\n     * @return current repayment period\n     */\n    function calculateCurrentPeriod() external view returns (uint256) {\n        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);\n        return _currentPeriod;\n    }\n\n    /**\n     * @notice internal function used to get the withdrawable amount for a _lender\n     * @param _lender address of the _lender\n     * @return amount of withdrawable token from the borrow pool\n     */\n    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n\n        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(\n            lenders[_lender].effectiveInterestWithdrawn\n        );\n\n        return _amountWithdrawable;\n    }\n\n    /**\n     * @notice used to get the withdrawable amount of borrow token for a lender\n     */\n    function withdrawRepayment() external isLender(msg.sender) nonReentrant {\n        _withdrawRepayment(msg.sender);\n    }\n\n    /**\n     * @notice internal function used to withdraw borrow asset from the pool by _lender\n     * @param _lender address of the _lender\n     */\n    function _withdrawRepayment(address _lender) internal {\n        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);\n\n        if (_amountToWithdraw == 0) {\n            return;\n        }\n        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);\n\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);\n    }\n\n    /**\n     * @notice used to get the end time for a margin call\n     * @param _lender address of the lender who has requested a margin call\n     * @return the time at which the margin call ends\n     */\n    function getMarginCallEndTime(address _lender) public view override returns (uint256) {\n        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n\n        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {\n            _marginCallEndTime = 0;\n        }\n        return _marginCallEndTime;\n    }\n\n    /**\n     * @notice used to get the balance details of a _lender\n     * @param _lender address of the _lender\n     * @return amount of pool tokens available with the _lender\n     * @return amount of pool tokens available in the pool\n     */\n    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {\n        return (balanceOf(_lender), totalSupply());\n    }\n\n    /**\n     * @notice used to get the loan status of the borrow pool\n     * @return integer respresenting loan status\n     */\n    function getLoanStatus() external view override returns (uint256) {\n        return uint256(poolVariables.loanStatus);\n    }\n\n    /**\n     * @notice used to receive ethers from savings accounts\n     */\n    receive() external payable {}\n\n    /**\n     * @notice used to get the equivalent amount of tokens from source to target tokens\n     * @param _source address of the tokens to be converted\n     * @param _target address of target conversion token\n     * @param _amount amount of tokens to be converted\n     * @return the equivalent amount of target tokens for given source tokens\n     */\n    function getEquivalentTokens(\n        address _source,\n        address _target,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);\n        return _amount.mul(_price).div(10**_decimals);\n    }\n\n    /**\n     * @notice used to get the address of the borrower of the pool\n     * @return address of the borrower\n     */\n    function borrower() external view override returns (address) {\n        return poolConstants.borrower;\n    }\n\n    /**\n     * @notice used to total supply of pool tokens for the pool\n     * @return total supply of pool tokens\n     */\n    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {\n        return ERC20Upgradeable.totalSupply();\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\ninterface IPool {\n    /**\n     * @notice Emitted when pool is cancelled either on borrower request or insufficient funds collected\n     */\n    event PoolCancelled();\n\n    /**\n     * @notice Emitted when pool is terminated by admin\n     */\n    event PoolTerminated();\n\n    /**\n     * @notice Emitted when pool is closed after repayments are complete\n     */\n    event PoolClosed();\n\n    /**\n     * @notice emitted when borrower posts collateral\n     * @param borrower address of the borrower\n     * @param amount amount denominated in collateral asset\n     * @param sharesReceived shares received after transferring collaterla to pool savings strategy\n     */\n    event CollateralAdded(address indexed borrower, uint256 amount, uint256 sharesReceived);\n\n    /**\n     * @notice emitted when borrower posts collateral after a margin call\n     * @param borrower address of the borrower\n     * @param lender lender who margin called\n     * @param amount amount denominated in collateral asset\n     * @param sharesReceived shares received after transferring collaterla to pool savings strategy\n     */\n    event MarginCallCollateralAdded(address indexed borrower, address indexed lender, uint256 amount, uint256 sharesReceived);\n\n    /**\n     * @notice emitted when borrower withdraws excess collateral\n     * @param borrower address of borrower\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(address indexed borrower, uint256 amount);\n\n    /**\n     * @notice emitted when lender supplies liquidity to a pool\n     * @param amountSupplied amount that was supplied\n     * @param lenderAddress address of the lender. allows for delegation of lending\n     */\n    event LiquiditySupplied(uint256 amountSupplied, address indexed lenderAddress);\n\n    /**\n     * @notice emitted when borrower withdraws loan\n     * @param amount tokens the borrower withdrew, taking into account the deducted protocol fee\n     * @param protocolFee protocol fee deducted when borrower withdrew the amount \n     */\n    event AmountBorrowed(uint256 amount, uint256 protocolFee);\n\n    /**\n     * @notice emitted when lender withdraws from borrow pool\n     * @param amount amount that lender withdraws from borrow pool\n     * @param lenderAddress address to which amount is withdrawn\n     */\n    event LiquidityWithdrawn(uint256 amount, address indexed lenderAddress);\n\n    /**\n     * @notice emitted when lender exercises a margin/collateral call\n     * @param lenderAddress address of the lender who exercises margin calls\n     */\n    event MarginCalled(address indexed lenderAddress);\n\n    /**\n     * @notice emitted when collateral backing lender is liquidated because of a margin call\n     * @param liquidator address that calls the liquidateForLender() function\n     * @param lender lender who initially exercised the margin call\n     * @param _tokenReceived amount received by liquidator denominated in collateral asset\n     */\n    event LenderLiquidated(address indexed liquidator, address indexed lender, uint256 _tokenReceived);\n\n    /**\n     * @notice emitted when a pool is liquidated for missing repayment\n     * @param liquidator address of the liquidator\n     */\n    event PoolLiquidated(address indexed liquidator);\n\n    function getLoanStatus() external view returns (uint256);\n\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable;\n\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _isDirect\n    ) external payable;\n\n    function withdrawBorrowedAmount() external;\n\n    function borrower() external returns (address);\n\n    function getMarginCallEndTime(address _lender) external returns (uint256);\n\n    function getBalanceDetails(address _lender) external view returns (uint256, uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function closeLoan() external payable;\n}\n\n\n",
        "CodeNames": [
            "CreditLine.sol",
            "SavingsAccountUtil.sol",
            "Controller.sol",
            "Pool.sol",
            "IPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n/\n * @notice internal function used to get amount of collateral deposited to the pool\n * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n * @param _asset address of the asset to be deposited\n * @param _amount amount of tokens to be deposited in the pool\n * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n * @param _depositFrom address which makes the deposit\n * @param _depositTo address to which the tokens are deposited\n * @return _sharesReceived number of equivalent shares for given _asset\n */\nfunction _deposit(\n    bool _fromSavingsAccount,\n    bool _toSavingsAccount,\n    address _asset,\n    uint256 _amount,\n    address _poolSavingsStrategy,\n    address _depositFrom,\n    address _depositTo\n) internal returns (uint256 _sharesReceived) {\n    if (_fromSavingsAccount) {\n        _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n            ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n            _depositFrom,\n            _depositTo,\n            _amount,\n            _asset,\n            _poolSavingsStrategy,\n            true,\n            _toSavingsAccount\n        );\n    } else {\n        _sharesReceived = SavingsAccountUtil.directDeposit(\n            ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n            _depositFrom,\n            _depositTo,\n            _amount,\n            _asset,\n            _toSavingsAccount,\n            _poolSavingsStrategy\n        );\n    }\n}\n",
                    "//solidity\nfunction depositFromSavingsAccount(\n    ISavingsAccount _savingsAccount,\n    address _from,\n    address _to,\n    uint256 _amount,\n    address _token,\n    address _strategy,\n    bool _withdrawShares,\n    bool _toSavingsAccount\n) internal returns (uint256) {\n    if (_toSavingsAccount) {\n        return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);\n    } else {\n        return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);\n    }\n}\n",
                    "//solidity\nfunction savingsAccountTransfer(\n    ISavingsAccount _savingsAccount,\n    address _from,\n    address _to,\n    uint256 _amount,\n    address _token,\n    address _strategy\n) internal returns (uint256) {\n    if (_from == address(this)) {\n        _savingsAccount.transfer(_amount, _token, _strategy, _to);\n    } else {\n        _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);\n    }\n    return _amount;\n}\n",
                    "//solidity\nfunction _depositCollateral(\n    address _depositor,\n    uint256 _amount,\n    bool _transferFromSavingsAccount\n) internal nonReentrant {\n    uint256 _sharesReceived = _deposit(\n        _transferFromSavingsAccount,\n        true,\n        poolConstants.collateralAsset,\n        _amount,\n        poolConstants.poolSavingsStrategy,\n        _depositor,\n        address(this)\n    );\n    poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n    emit CollateralAdded(_depositor, _amount, _sharesReceived);\n}\n"
                ],
                "Type": " Wrong returns of  SavingsAccountUtil.depositFromSavingsAccount()  can cause fund loss",
                "Description": "\nThe function SavingsAccountUtil.depositFromSavingsAccount() is expected to return the number of equivalent shares for given _asset.\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L225-L267\n\nsolidity\n/\n * @notice internal function used to get amount of collateral deposited to the pool\n * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n * @param _asset address of the asset to be deposited\n * @param _amount amount of tokens to be deposited in the pool\n * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n * @param _depositFrom address which makes the deposit\n * @param _depositTo address to which the tokens are deposited\n * @return _sharesReceived number of equivalent shares for given _asset\n */\nfunction _deposit(\n    bool _fromSavingsAccount,\n    bool _toSavingsAccount,\n    address _asset,\n    uint256 _amount,\n    address _poolSavingsStrategy,\n    address _depositFrom,\n    address _depositTo\n) internal returns (uint256 _sharesReceived) {\n    if (_fromSavingsAccount) {\n        _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n            ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n            _depositFrom,\n            _depositTo,\n            _amount,\n            _asset,\n            _poolSavingsStrategy,\n            true,\n            _toSavingsAccount\n        );\n    } else {\n        _sharesReceived = SavingsAccountUtil.directDeposit(\n            ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n            _depositFrom,\n            _depositTo,\n            _amount,\n            _asset,\n            _toSavingsAccount,\n            _poolSavingsStrategy\n        );\n    }\n}\n\n\nHowever, since savingsAccountTransfer() does not return the result of _savingsAccount.transfer(), but returned _amount instead, which means that SavingsAccountUtil.depositFromSavingsAccount() may not return the actual shares (when pps is not 1).\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L11-L26\n\nsolidity\nfunction depositFromSavingsAccount(\n    ISavingsAccount _savingsAccount,\n    address _from,\n    address _to,\n    uint256 _amount,\n    address _token,\n    address _strategy,\n    bool _withdrawShares,\n    bool _toSavingsAccount\n) internal returns (uint256) {\n    if (_toSavingsAccount) {\n        return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);\n    } else {\n        return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);\n    }\n}\n\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L66-L80\n\nsolidity\nfunction savingsAccountTransfer(\n    ISavingsAccount _savingsAccount,\n    address _from,\n    address _to,\n    uint256 _amount,\n    address _token,\n    address _strategy\n) internal returns (uint256) {\n    if (_from == address(this)) {\n        _savingsAccount.transfer(_amount, _token, _strategy, _to);\n    } else {\n        _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);\n    }\n    return _amount;\n}\n\n\nAs a result, the recorded _sharesReceived can be wrong.\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207-L223\n\nsolidity\nfunction _depositCollateral(\n    address _depositor,\n    uint256 _amount,\n    bool _transferFromSavingsAccount\n) internal nonReentrant {\n    uint256 _sharesReceived = _deposit(\n        _transferFromSavingsAccount,\n        true,\n        poolConstants.collateralAsset,\n        _amount,\n        poolConstants.poolSavingsStrategy,\n        _depositor,\n        address(this)\n    );\n    poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n    emit CollateralAdded(_depositor, _amount, _sharesReceived);\n}\n\n\n\nGiven:\n\n*   the price per share of yearn USDC vault is 1.2\n\n1.  Alice deposited 12,000 USDC to yearn strategy, received 10,000 share tokens;\n2.  Alice created a pool, and added all the 12,000 USDC from the saving account as collateral; The recorded CollateralAdded got the wrong number: 12000 which should be 10000;\n3.  Alice failed to borrow money with the pool and tries to cancelPool(), it fails as the recorded collateral shares are more than the actual collateral.\n\nAs a result, Alice has lost all the 12,000 USDC.\n\nIf Alice managed to borrow with the pool, when the loan defaults, the liquidation will also fail, and cause fund loss to the lenders.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction savingsAccountTransfer(\n    ISavingsAccount _savingsAccount,\n    address _from,\n    address _to,\n    uint256 _amount,\n    address _token,\n    address _strategy\n) internal returns (uint256) {\n    if (_from == address(this)) {\n        return _savingsAccount.transfer(_amount, _token, _strategy, _to);\n    } else {\n        return _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);\n    }\n}\n\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/132)\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IyVault {\n    function earn() external;\n\n    function depositAll() external;\n\n    function deposit(uint256 _amount) external;\n\n    function depositETH() external payable;\n\n    function withdrawAll() external;\n\n    function withdrawAllETH() external;\n\n    function harvest(address reserve, uint256 amount) external;\n\n    function withdraw(uint256 _shares) external;\n\n    function withdrawETH(uint256 _shares) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function setMin(uint256) external;\n\n    function min() external returns (uint256);\n}\n\n\n",
        "CodeNames": [
            "IyVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "getPricePerFullShare"
                ],
                "Type": " Yearn token <> shares conversion decimal issue",
                "Description": "\nThe yearn strategy YearnYield converts shares to tokens by doing pricePerFullShare * shares / 1e18:\n\n    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n        if (shares == 0) return 0;\n        // @audit should divided by vaultDecimals \n        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);\n    }\n\nBut Yearn's getPricePerFullShare seems to be in vault.decimals() precision(https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L1147), i.e., it should convert it as pricePerFullShare * shares / (10  vault.decimals()).\nThe vault decimals are the same as the underlying token decimals(https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L295-L296)\n\n\nThe token and shares conversions do not work correctly for underlying tokens that do not have 18 decimals.\nToo much or too little might be paid out leading to a loss for either the protocol or user.\n\n",
                "Repair": "\nDivide by 10vault.decimals() instead of 1e18 in getTokensForShares.\nApply a similar fix in getSharesForTokens.\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/134) \n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../interfaces/IStrategyRegistry.sol';\nimport '../interfaces/IYield.sol';\n\n/**\n * @title Savings account contract with Methods related to savings account\n * @notice Implements the functions related to savings account\n * @author Sublime\n **/\ncontract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice address of the strategy registry used to whitelist strategies\n     */\n    address public strategyRegistry;\n\n    /**\n     * @notice address of the credit lines contract\n     */\n    address public creditLine;\n\n    /**\n     * @notice mapping from user to token to strategy to balance of shares\n     * @dev user -> token -> strategy (underlying address) -> amount (shares)\n     */\n    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;\n\n    /**\n     * @notice mapping from user to token to toAddress for approval to amount approved\n     * @dev user => token => to => amount\n     */\n    mapping(address => mapping(address => mapping(address => uint256))) public allowance;\n\n    /**\n     * @notice modifier to check if address is the credit line\n     * @param _caller address to check if credit line\n     */\n    modifier onlyCreditLine(address _caller) {\n        require(_caller == creditLine, 'Invalid caller');\n        _;\n    }\n\n    /**\n     * @dev initialize the contract\n     * @param _owner address of the owner of the savings account contract\n     * @param _strategyRegistry address of the strategy registry\n     * @param _creditLine address of the credit line contract\n     **/\n    function initialize(\n        address _owner,\n        address _strategyRegistry,\n        address _creditLine\n    ) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateCreditLine(_creditLine);\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update credit line contract address\n     * @dev only owner can update\n     * @param _creditLine updated address of credit lines\n     */\n    function updateCreditLine(address _creditLine) external onlyOwner {\n        _updateCreditLine(_creditLine);\n    }\n\n    function _updateCreditLine(address _creditLine) internal {\n        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');\n        creditLine = _creditLine;\n        emit CreditLineUpdated(_creditLine);\n    }\n\n    /**\n     * @notice used to update strategy registry address\n     * @dev only owner can update\n     * @param _strategyRegistry updated address of strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to deposit tokens into strategy via savings account\n     * @dev if token is address(0), then it is Ether\n     * @param _amount amount of tokens deposited\n     * @param _token address of token contract\n     * @param _strategy address of the strategy into which tokens are to be deposited\n     * @param _to address to deposit to\n     */\n    function deposit(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _to\n    ) external payable override nonReentrant returns (uint256) {\n        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');\n        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);\n        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);\n        emit Deposited(_to, _sharesReceived, _token, _strategy);\n        return _sharesReceived;\n    }\n\n    function _deposit(\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256 _sharesReceived) {\n        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');\n        _sharesReceived = _depositToYield(_amount, _token, _strategy);\n    }\n\n    function _depositToYield(\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256 _sharesReceived) {\n        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');\n        uint256 _ethValue;\n\n        if (_token == address(0)) {\n            _ethValue = _amount;\n            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');\n        }\n        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);\n    }\n\n    /**\n     * @dev Used to switch saving strategy of an _token\n     * @param _currentStrategy initial strategy of token\n     * @param _newStrategy new strategy to invest\n     * @param _token address of the token\n     * @param _amount amount of tokens to be reinvested\n     */\n    function switchStrategy(\n        uint256 _amount,\n        address _token,\n        address _currentStrategy,\n        address _newStrategy\n    ) external override nonReentrant {\n        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');\n        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');\n        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');\n\n        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(\n            _amount,\n            'SavingsAccount::switchStrategy Insufficient balance'\n        );\n\n        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);\n\n        uint256 _ethValue;\n        if (_token != address(0)) {\n            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);\n        } else {\n            _ethValue = _tokensReceived;\n        }\n        _amount = _tokensReceived;\n        \n        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);\n\n        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);\n        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);\n    }\n\n    /**\n     * @dev Used to withdraw token from Saving Account\n     * @param _to address to which token should be sent\n     * @param _amount amount of tokens to withdraw\n     * @param _token address of the token to be withdrawn\n     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)\n     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token\n     */\n    function withdraw(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address payable _to,\n        bool _withdrawShares\n    ) external override nonReentrant returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');\n\n        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::withdraw Insufficient amount'\n        );\n\n        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);\n\n        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);\n        return _amountReceived;\n    }\n\n    /**\n     * @dev Used to withdraw token from allowance of Saving Account\n     * @param _from address from which tokens will be withdrawn\n     * @param _to address to which token should be withdrawn\n     * @param _amount amount of tokens to withdraw\n     * @param _token address of the token to be withdrawn\n     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)\n     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token\n     */\n\n    function withdrawFrom(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _from,\n        address payable _to,\n        bool _withdrawShares\n    ) external override nonReentrant returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');\n\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(\n            _amount,\n            'SavingsAccount::withdrawFrom allowance limit exceeding'\n        );\n\n        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::withdrawFrom insufficient balance'\n        );\n        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);\n        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);\n        return _amountReceived;\n    }\n\n    function _withdraw(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address payable _to,\n        bool _withdrawShares\n    ) internal returns (address _tokenReceived, uint256 _amountReceived) {\n        if (_withdrawShares) {\n            _tokenReceived = IYield(_strategy).liquidityToken(_token);\n            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');\n            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);\n        } else {\n            _tokenReceived = _token;\n            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);\n        }\n        _transfer(_amountReceived, _tokenReceived, _to);\n    }\n\n    function _transfer(\n        uint256 _amount,\n        address _token,\n        address payable _to\n    ) internal {\n        if (_token == address(0)) {\n            (bool _success, ) = _to.call{value: _amount}('');\n            require(_success, 'Transfer failed');\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /**\n     * @notice used to withdraw a token from all strategies\n     * @param _token address of token which is to be withdrawn\n     */\n    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n\n        for (uint256 i = 0; i < _strategyList.length; i++) {\n            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {\n                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];\n                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);\n                _tokenReceived = _tokenReceived.add(_amount);\n                delete balanceInShares[msg.sender][_token][_strategyList[i]];\n            }\n        }\n\n        if (_tokenReceived == 0) return 0;\n\n        _transfer(_tokenReceived, _token, payable(msg.sender));\n\n        emit WithdrawnAll(msg.sender, _tokenReceived, _token);\n    }\n\n    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {\n        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];\n\n        if(_sharesBalance == 0) return 0;\n\n        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);\n\n        delete balanceInShares[msg.sender][_token][_strategy];\n\n        _transfer(_amount, _token, payable(msg.sender));\n\n        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);\n    }\n\n    /**\n     * @notice used to approve allowance to an address\n     * @dev this is prone to race condition, hence increaseAllowance is recommended\n     * @param _amount amount of tokens approved\n     * @param _token address of token approved\n     * @param _to address of the user approved to\n     */\n    function approve(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        allowance[msg.sender][_token][_to] = _amount;\n\n        emit Approved(_token, msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice used to increase allowance to an address\n     * @param _amount amount of tokens allowance is increased by\n     * @param _token address of token approved\n     * @param _to address of the address approved to\n     */\n    function increaseAllowance(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);\n        allowance[msg.sender][_token][_to] = _updatedAllowance;\n\n        emit Approved(_token, msg.sender, _to, _updatedAllowance);\n    }\n\n    /**\n     * @notice used to decrease allowance to an address\n     * @param _amount amount of tokens allowance is decreased by\n     * @param _token address of token approved\n     * @param _to address of the user approved to\n     */\n    function decreaseAllowance(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);\n        allowance[msg.sender][_token][_to] = _updatedAllowance;\n\n        emit Approved(_token, msg.sender, _to, _updatedAllowance);\n    }\n\n    /**\n     * @notice used by credit lines to replenish the allowance once the credit line pricinpal is repaid\n     * @param _amount amount of tokens allowance is increased by\n     * @param _token address of token approved\n     * @param _from address of the lender of the credit line which is being replenished\n     */\n    function increaseAllowanceToCreditLine(\n        uint256 _amount,\n        address _token,\n        address _from\n    ) external override onlyCreditLine(msg.sender) {\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);\n\n        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);\n    }\n\n    /**\n     * @notice used to transfer tokens\n     * @param _amount amount of tokens transferred\n     * @param _token address of token transferred\n     * @param _strategy address of the strategy from which tokens are transferred\n     * @param _to address of the user tokens are transferred to\n     */\n    function transfer(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _to\n    ) external override returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::transfer zero amount');\n\n        if (_strategy != address(0)) {\n            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n        }\n\n        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::transfer insufficient funds'\n        );\n\n        //update receiver's balance\n        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);\n\n        emit Transfer(_token, _strategy, msg.sender, _to, _amount);\n\n        return _amount;\n    }\n\n    /**\n     * @notice used to transfer tokens from allowance by another address\n     * @param _amount amount of tokens transferred\n     * @param _token address of token transferred\n     * @param _strategy address of the strategy from which tokens are transferred\n     * @param _from address from whose allowance tokens are transferred\n     * @param _to address of the user tokens are transferred to\n     */\n    function transferFrom(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _from,\n        address _to\n    ) external override returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');\n        //update allowance\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(\n            _amount,\n            'SavingsAccount::transferFrom allowance limit exceeding'\n        );\n\n        if (_strategy != address(0)) {\n            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n        }\n\n        //reduce sender's balance\n        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::transferFrom insufficient allowance'\n        );\n\n        //update receiver's balance\n        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);\n\n        emit Transfer(_token, _strategy, _from, _to, _amount);\n\n        return _amount;\n    }\n\n    /**\n     * @notice used to query total tokens of a token with a user\n     * @param _user address of the user\n     * @param _token address of token\n     * @return _totalTokens total number of tokens of the token with the user\n     */\n    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n\n        for (uint256 i = 0; i < _strategyList.length; i++) {\n            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];\n\n            if (_liquidityShares != 0) {\n                uint256 _tokenInStrategy = _liquidityShares;\n                if (_strategyList[i] != address(0)) {\n                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);\n                }\n\n                _totalTokens = _totalTokens.add(_tokenInStrategy);\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IStrategyRegistry.sol';\n\n/**\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n **/\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     **/\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /**\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId => Strategy => collateralShares\n     **/\n    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;\n\n    /**\n     * @notice stores the variables to maintain a credit line\n     **/\n    mapping(uint256 => CreditLineVariables) public creditLineVariables;\n\n    /**\n     * @notice stores the constants related to a credit line\n     **/\n    mapping(uint256 => CreditLineConstants) public creditLineConstants;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address public savingsAccount;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    address public priceOracle;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    address public strategyRegistry;\n\n    /**\n     * @notice stores the address of default strategy\n     **/\n    address public defaultStrategy;\n\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    /**\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public liquidatorRewardFraction;\n    /**\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     **/\n    modifier ifCreditLineExists(uint256 _id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineLender(uint256 _id) {\n        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');\n        _;\n    }\n\n    /**\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /**\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     */\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /**\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /**\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /**\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     */\n    event CreditLineAccepted(uint256 indexed id);\n\n    /**\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /**\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /**\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     */\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /**\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /**\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /**\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /**\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), 'cant be 0 address');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'CL::I zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /**\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /**\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(\n            10**_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible > _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible > _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');\n    }\n\n    /**\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /**\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),\n            \"Only Borrower or Lender who hasn't requested can accept\"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /**\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, \"CreditLine::_depositCollateral - value to transfer doesn't match argument\");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, 'insufficient balance');\n    }\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\n            require(feeSuccess, 'Transfer fail');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\n            require(success, 'Transfer fail');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /**\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount >= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount > _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /**\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     */\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            'CreditLine: Permission denied while closing Line of credit'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 10**30 to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(\n            10**_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10**_decimals)\n            .div(10**30);\n\n        if (_collateralNeeded >= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert('insufficient collateral');\n    }\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,\n            'CreditLine: Collateral ratio is higher than ideal value'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}('');\n                    require(success, 'Transfer fail');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /**\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IYield.sol';\nimport '../interfaces/Invest/IWETHGateway.sol';\nimport '../interfaces/Invest/AaveLendingPool.sol';\nimport '../interfaces/Invest/IScaledBalanceToken.sol';\nimport '../interfaces/Invest/IProtocolDataProvider.sol';\n\n/**\n * @title Yield contract\n * @notice Implements the functions to lock/unlock tokens into Aave protocol\n * @author Sublime\n **/\ncontract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice address of wethGateway used to deposit ETH to aave\n     */\n    address public wethGateway;\n\n    /**\n     * @notice address of protocolDataProvider which provides info about aTokens related to any token\n     */\n    address public protocolDataProvider;\n\n    /**\n     * @notice address of lendingPoolAddressesProvider used to get the pool related to any token\n     */\n    address public lendingPoolAddressesProvider;\n\n    /**\n     * @notice address of savings account contract\n     */\n    address payable public savingsAccount;\n\n    /**\n     * @notice aave referral code to represent sublime\n     */\n    uint16 public referralCode;\n\n    /**\n     * @notice emitted when aave protocol related addresses are updated\n     * @param wethGateway address of wethGateway\n     * @param protocolDataProvider address of protocol data provider\n     * @param lendingPoolAddressesProvider address of lending pool addresses provider\n     */\n    event AaveAddressesUpdated(\n        address indexed wethGateway,\n        address indexed protocolDataProvider,\n        address indexed lendingPoolAddressesProvider\n    );\n\n    /**\n     * @notice emitted when aave referral code is updated\n     * @param referralCode updated referral code\n     */\n    event ReferralCodeUpdated(uint16 referralCode);\n\n    /**\n     * @notice verifies if savings account invoked the contract\n     */\n    modifier onlySavingsAccount() {\n        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');\n        _;\n    }\n\n    /**\n     * @notice To initialize the contract addresses interacting with this contract\n     * @dev can only be initialized once\n     * @param _owner address of owner\n     * @param _savingsAccount address of the savings account contract\n     * @param _wethGateway address of wethGateway\n     * @param _protocolDataProvider the address of ProtocolDataProvider\n     * @param _lendingPoolAddressesProvider the address of LendingPoolAddressesProvider\n     **/\n    function initialize(\n        address _owner,\n        address payable _savingsAccount,\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateSavingsAccount(_savingsAccount);\n        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    /**\n     * @notice Used to get liquidity token address from asset address\n     * @param asset the address of underlying token\n     * @return aToken address of liquidity token\n     **/\n    function liquidityToken(address asset) public view override returns (address aToken) {\n        if (asset == address(0)) {\n            aToken = IWETHGateway(wethGateway).getAWETHAddress();\n        } else {\n            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);\n        }\n    }\n\n    /**\n     * @notice used to update savings account address\n     * @dev only owner can update\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address payable _savingsAccount) internal {\n        require(_savingsAccount != address(0), 'Invest: zero address');\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update aave protocol related addresses\n     * @dev only owner can update\n     * @param _wethGateway address of wethGateway\n     * @param _protocolDataProvider address of protocol data provider\n     * @param _lendingPoolAddressesProvider address of lending pool addresses provider\n     */\n    function updateAaveAddresses(\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) external onlyOwner {\n        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    function _updateAaveAddresses(\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) internal {\n        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');\n        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');\n        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');\n        wethGateway = _wethGateway;\n        protocolDataProvider = _protocolDataProvider;\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    /**\n     * @notice used to update referral code\n     * @dev only owner can update\n     * @param _referralCode updated referral code\n     */\n    function updateReferralCode(uint16 _referralCode) external onlyOwner {\n        referralCode = _referralCode;\n        emit ReferralCodeUpdated(_referralCode);\n    }\n\n    /**\n     * @notice used to withdraw all tokens of a type in case of emergencies\n     * @dev only owner can withdraw\n     * @param _asset address of the token being withdrawn\n     * @param _wallet address to which tokens are withdrawn\n     */\n    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n        require(_wallet != address(0), 'cant burn');\n        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));\n\n        if (_asset == address(0)) {\n            received = _withdrawETH(amount);\n            (bool success, ) = _wallet.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            received = _withdrawERC(_asset, amount);\n            IERC20(_asset).safeTransfer(_wallet, received);\n        }\n    }\n\n    /**\n     * @notice Used to lock tokens in protocol\n     * @dev Asset Tokens to be locked must be approved to this contract by user\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n        require(amount != 0, 'Invest: amount');\n\n        address investedTo;\n        if (asset == address(0)) {\n            require(msg.value == amount, 'Invest: ETH amount');\n            (investedTo, sharesReceived) = _depositETH(amount);\n        } else {\n            IERC20(asset).safeTransferFrom(user, address(this), amount);\n            (investedTo, sharesReceived) = _depositERC20(asset, amount);\n        }\n\n        emit LockedTokens(user, investedTo, sharesReceived);\n    }\n\n    /**\n     * @notice Used to unlock tokens from available protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of asset\n     * @return received amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {\n        require(amount != 0, 'Invest: amount');\n\n        if (asset == address(0)) {\n            received = _withdrawETH(amount);\n            (bool success, ) = savingsAccount.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            received = _withdrawERC(asset, amount);\n            IERC20(asset).safeTransfer(savingsAccount, received);\n        }\n\n        emit UnlockedTokens(asset, received);\n    }\n\n    /**\n     * @notice Used to unlock shares\n     * @param asset the address of underlying token\n     * @param amount the amount of shares to unlock\n     * @return received amount of shares received\n     **/\n    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n\n        require(asset != address(0), 'Asset address cannot be address(0)');\n        IERC20(asset).safeTransfer(savingsAccount, amount);\n\n        emit UnlockedShares(asset, amount);\n        return amount;\n    }\n\n    /**\n     * @notice Used to get amount of underlying tokens for current number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n        if (shares == 0) return 0;\n        address aToken = liquidityToken(asset);\n\n        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);\n\n        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(\n            IERC20(aToken).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Used to get number of shares from an amount of underlying tokens\n     * @param amount the amount of tokens\n     * @param asset the address of token\n     * @return shares amount of shares for given tokens\n     **/\n    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {\n        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));\n    }\n\n    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {\n        aToken = IWETHGateway(wethGateway).getAWETHAddress();\n\n        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        //lock collateral\n        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);\n\n        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);\n    }\n\n    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {\n        aToken = liquidityToken(asset);\n        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        //approve collateral to vault\n        IERC20(asset).approve(lendingPool, 0);\n        IERC20(asset).approve(lendingPool, amount);\n\n        //lock collateral in vault\n        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);\n\n        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);\n    }\n\n    function _withdrawETH(uint256 amount) internal returns (uint256 received) {\n        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);\n\n        uint256 ethBalance = address(this).balance;\n\n        //lock collateral\n        IWETHGateway(wethGateway).withdrawETH(amount, address(this));\n\n        received = address(this).balance.sub(ethBalance);\n    }\n\n    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {\n        address aToken = liquidityToken(asset);\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));\n\n        IERC20(aToken).approve(lendingPool, amount);\n\n        //withdraw collateral from vault\n        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));\n\n        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);\n    }\n\n    receive() external payable {}\n}\n\n\n// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.6;\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n}\n\n\n",
        "CodeNames": [
            "SavingsAccount.sol",
            "CreditLine.sol",
            "AaveYield.sol",
            "DataTypes.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\nfunction deposit(\n    uint256 _amount,\n    address _token,\n    address _strategy,\n    address _to\n) external payable override nonReentrant returns (uint256) {\n    require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');\n    uint256 _sharesReceived = _deposit(_amount, _token, _strategy);\n    balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);\n    emit Deposited(_to, _sharesReceived, _token, _strategy);\n    return _sharesReceived;\n}\n\nfunction getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n    if (shares == 0) return 0;\n    address aToken = liquidityToken(asset);\n\n    (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);\n\n    // @audit-info tries to do (user shares / total shares) * underlying amount where underlying amount = scaledBalance * liquidityIndex\n    amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(\n        IERC20(aToken).balanceOf(address(this))\n    );\n}\n"
                ],
                "Type": " Aave's share tokens are rebasing breaking current strategy code",
                "Description": "\nWhen depositing into Aave through the AaveYield.lockTokens contract strategy, one receives the sharesReceived amount corresponding to the diff of aToken balance, which is just always the deposited amount as aave is a rebasing token and 1.0 aToken = 1.0 underlying at each deposit / withdrawal.\n\nNote that this sharesReceived (the underlying deposit amount) is cached in a balanceInShares map in SavingsAccount.deposit which makes this share *static* and not dynamically rebasing anymore:\n\nsolidity\nfunction deposit(\n    uint256 _amount,\n    address _token,\n    address _strategy,\n    address _to\n) external payable override nonReentrant returns (uint256) {\n    require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');\n    uint256 _sharesReceived = _deposit(_amount, _token, _strategy);\n    balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);\n    emit Deposited(_to, _sharesReceived, _token, _strategy);\n    return _sharesReceived;\n}\n\nfunction getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n    if (shares == 0) return 0;\n    address aToken = liquidityToken(asset);\n\n    (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);\n\n    // @audit-info tries to do (user shares / total shares) * underlying amount where underlying amount = scaledBalance * liquidityIndex\n    amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(\n        IERC20(aToken).balanceOf(address(this))\n    );\n}\n\n\nHowever, the getTokensForShares function uses a rebasing total share supply of IERC20(aToken).balanceOf(this).\n\n\n*   SavingsAccount deposits 1000 DAI for user and user receives 1000 aDAI as shares. These shares are cached in balanceInShares[user][dai][aave].\n*   Time passes, Aave accrues interest for lenders, and the initial 1000 aTokens balance has rebased to 1200 aTokens\n*   SavingsAccount withdraws 1000 aDAI shares for user which calls AaveYield.unlockTokens. The user receives only 1000 DAI. The interest owed to the user is not paid out.\n*   Note that getTokensForShares also returns the wrong amount as 1200 * 1000 / 1200 = 1000\n\n\nInterest is not paid out to users.\nPool collateral is measured without the interest accrued as it uses getTokensForShares which will lead to early liquidations and further loss.\n\n",
                "Repair": "\nIf the user shares are not rebasing, you cannot have the \"total shares supply\" (the shares in the contract) be rebasing as in getTokensForShares. Also withdrawing the share amount directly from Aave as in _withdrawERC does not withdraw the yield.\nA fix could be to create a *non-rebasing* wrapper LP token that is paid out to the user proportional to the current strategy TVL at time of user deposit.\n\nritik99 (Sublime) acknowledged(https://github.com/code-423n4/2021-12-sublime-findings/issues/137#issuecomment-1001476854):\n  We've been aware of this issue for some time.. ended up including the AaveYield file in the scope by mistake! We do not plan to include the Aave strategy in our launch (we maintain a strategy registry that allows us to add/drop yield strategies), and as noted in #128, we will be utilizing wrapper contracts(https://github.com/aave/protocol-v2/blob/feat-atoken-wrapper-liquidity-mining/contracts/protocol/tokenization/StaticATokenLM.sol) that mimics behaviour of non-rebasing LP tokens\n\n0xean (judge) commented(https://github.com/code-423n4/2021-12-sublime-findings/issues/137#issuecomment-1018051683):\n  going to side with the warden since they believed the contract to be in scope and it's a valid concern.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.6;\n\nimport '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './interfaces/IPriceOracle.sol';\n\ncontract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {\n    using SafeMath for uint256;\n\n    uint32 uniswapPriceAveragingPeriod;\n    struct PriceData {\n        address oracle;\n        uint256 decimals;\n    }\n    /**\n     * @notice stores the price oracle and its decimals for chainlink feeds\n     **/\n    mapping(address => PriceData) public chainlinkFeedAddresses;\n    mapping(address => uint256) decimals;\n\n    /**\n     * @notice stores the addresses of price feeds for uniswap token pairs\n     **/\n    mapping(bytes32 => address) public uniswapPools;\n\n    /**\n     * @notice Used to initialize the price oracle contract\n     * @dev can only be invoked once\n     * @param _admin owner of the price oracle\n     **/\n    function initialize(address _admin) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_admin);\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from chainlink\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        PriceData memory _feedData1 = chainlinkFeedAddresses[num];\n        PriceData memory _feedData2 = chainlinkFeedAddresses[den];\n        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {\n            return (0, 0);\n        }\n        int256 price1;\n        int256 price2;\n        {\n            uint80 roundID1;\n            uint256 timeStamp1;\n            uint80 answeredInRound1;\n            (\n                roundID1,\n                price1,\n                ,\n                timeStamp1,\n                answeredInRound1\n            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();\n            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {\n                return (0, 0);\n            }\n        }\n        {\n            uint80 roundID2;\n            uint256 timeStamp2;\n            uint80 answeredInRound2;\n            (\n                roundID2,\n                price2,\n                ,\n                timeStamp2,\n                answeredInRound2\n            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();\n            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {\n                return (0, 0);\n            }\n        }\n        uint256 price = uint256(price1)\n            .mul(10**_feedData2.decimals)\n            .mul(10**30)\n            .div(uint256(price2))\n            .div(10**_feedData1.decimals)\n            .mul(10**decimals[den])\n            .div(10**decimals[num]);\n        return (price, 30);\n    }\n\n    /**\n     * @notice Used to get decimals for a token\n     * @param _token address of the token\n     * @return number of decimals for the token\n     **/\n    function getDecimals(address _token) internal view returns (uint8) {\n        if (_token == address(0)) {\n            return 18;\n        }\n\n        try ERC20(_token).decimals() returns (uint8 v) {\n            return v;\n        } catch Error(string memory) {\n            return 0;\n        } catch (bytes memory) {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from uniswap\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);\n        address _pool = uniswapPools[_poolTokensId];\n        if (_pool == address(0)) {\n            return (0, 0);\n        }\n\n        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);\n        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);\n        return (_numTokens, 30);\n    }\n\n    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {\n        if (uint256(num) < uint256(den)) {\n            return keccak256(abi.encodePacked(num, den));\n        } else {\n            return keccak256(abi.encodePacked(den, num));\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n        uint256 _price;\n        uint256 _decimals;\n        (_price, _decimals) = getChainlinkLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        (_price, _decimals) = getUniswapLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        revert(\"PriceOracle::getLatestPrice - Price Feed doesn't exist\");\n    }\n\n    /**\n     * @notice used to check if price feed exists between 2 tokens\n     * @param token1 one of the token for which price feed is to be checked\n     * @param token2 other token for which price feed is to be checked\n     * @return if price feed exists for the token pair\n     **/\n    function doesFeedExist(address token1, address token2) external view override returns (bool) {\n        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {\n            return true;\n        }\n\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n\n        if (uniswapPools[_poolTokensId] != address(0)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token in chainlink\n     * @dev only owner can set\n     * @param token address of token for which price feed is added\n     * @param priceOracle addrewss of the price feed for the token\n     **/\n    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {\n        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();\n        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);\n        decimals[token] = getDecimals(token);\n        emit ChainlinkFeedUpdated(token, priceOracle);\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token pair in uniswap\n     * @dev only owner can set\n     * @param token1 address of one of the tokens for which price feed is added\n     * @param token2 address of other token for which price feed is added\n     * @param pool addrewss of the price feed for the token pair\n     **/\n    function setUniswapFeedAddress(\n        address token1,\n        address token2,\n        address pool\n    ) external onlyOwner {\n        require(token1 != token2, 'token1 and token2 should be different addresses');\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n        uniswapPools[_poolTokensId] = pool;\n        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);\n    }\n\n    /**\n     * @notice Used to set the period in which uniswap price is averaged\n     * @dev only owner can set. This is used to prevent attacks to control price feed\n     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging\n     **/\n    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {\n        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;\n        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IStrategyRegistry.sol';\n\n/**\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n **/\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     **/\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /**\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId => Strategy => collateralShares\n     **/\n    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;\n\n    /**\n     * @notice stores the variables to maintain a credit line\n     **/\n    mapping(uint256 => CreditLineVariables) public creditLineVariables;\n\n    /**\n     * @notice stores the constants related to a credit line\n     **/\n    mapping(uint256 => CreditLineConstants) public creditLineConstants;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address public savingsAccount;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    address public priceOracle;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    address public strategyRegistry;\n\n    /**\n     * @notice stores the address of default strategy\n     **/\n    address public defaultStrategy;\n\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    /**\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public liquidatorRewardFraction;\n    /**\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     **/\n    modifier ifCreditLineExists(uint256 _id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineLender(uint256 _id) {\n        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');\n        _;\n    }\n\n    /**\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /**\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     */\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /**\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /**\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /**\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     */\n    event CreditLineAccepted(uint256 indexed id);\n\n    /**\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /**\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /**\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     */\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /**\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /**\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /**\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /**\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), 'cant be 0 address');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'CL::I zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /**\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /**\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(\n            10**_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible > _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible > _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');\n    }\n\n    /**\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /**\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),\n            \"Only Borrower or Lender who hasn't requested can accept\"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /**\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, \"CreditLine::_depositCollateral - value to transfer doesn't match argument\");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, 'insufficient balance');\n    }\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\n            require(feeSuccess, 'Transfer fail');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\n            require(success, 'Transfer fail');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /**\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount >= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount > _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /**\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     */\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            'CreditLine: Permission denied while closing Line of credit'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 10**30 to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(\n            10**_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10**_decimals)\n            .div(10**30);\n\n        if (_collateralNeeded >= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert('insufficient collateral');\n    }\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,\n            'CreditLine: Collateral ratio is higher than ideal value'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}('');\n                    require(success, 'Transfer fail');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /**\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');\n    }\n}\n\n\n",
        "CodeNames": [
            "PriceOracle.sol",
            "CreditLine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\n...\n    if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n        uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n        if (_borrowAsset == address(0)) {\n            uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n            if (_returnETH != 0) {\n                (bool success, ) = msg.sender.call{value: _returnETH}('');\n                require(success, 'Transfer fail');\n            }\n        } else {\n        IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n        }\n    }\n    \n    _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount); \n    emit  CreditLineLiquidated(_id, msg.sender);\n}\n"
                ],
                "Type": " Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens",
                "Description": "\n\nIt is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here: <https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.\n\nEven worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by _borrowTokensToLiquidate) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.\n\n\nThe current implementation of liquidate is here: <https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L996.\n\nNotice that the autoLiquidation value is only used in one place within this function, which is in this segment of the code:\nsolidity\n...\n    if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n        uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n        if (_borrowAsset == address(0)) {\n            uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n            if (_returnETH != 0) {\n                (bool success, ) = msg.sender.call{value: _returnETH}('');\n                require(success, 'Transfer fail');\n            }\n        } else {\n        IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n        }\n    }\n    \n    _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount); \n    emit  CreditLineLiquidated(_id, msg.sender);\n}\n\n\nSo, if autoLiquidation is false, the code inside of the if statement will simply not be executed, and there are no further checks that the sender HAS to be the lender if autoLiquidation is false. This means that anyone can liquidate a non-autoLiquidation credit line, and receive all of the collateral without first transferring the necessary borrow tokens.\n\nFor a further proof of concept, consider the test file here: <https://github.com/code-423n4/2021-12-sublime/blob/main/test/CreditLines/2.spec.ts. If the code on line 238 is changed from let  _autoLiquidation: boolean  =  true; to let  _autoLiquidation: boolean  =  false;, all the test cases will still pass. This confirms the issue, as the final test case \"Liquidate credit line\" has the admin as the liquidator, which should not work in non-autoLiquidations since they are not the lender.\n\n\nInspection and confirmed with Hardhat.\n\n",
                "Repair": "\nAdd the following require statement somewhere in the liquidate function:\nsolidity\nrequire(\n    creditLineConstants[_id].autoLiquidation || \n    msg.sender == creditLineConstants[_id].lender,\n    \"not autoLiquidation and not lender\");\n\n\n##\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IStrategyRegistry.sol';\n\n/**\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n **/\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     **/\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /**\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId => Strategy => collateralShares\n     **/\n    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;\n\n    /**\n     * @notice stores the variables to maintain a credit line\n     **/\n    mapping(uint256 => CreditLineVariables) public creditLineVariables;\n\n    /**\n     * @notice stores the constants related to a credit line\n     **/\n    mapping(uint256 => CreditLineConstants) public creditLineConstants;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address public savingsAccount;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    address public priceOracle;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    address public strategyRegistry;\n\n    /**\n     * @notice stores the address of default strategy\n     **/\n    address public defaultStrategy;\n\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    /**\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public liquidatorRewardFraction;\n    /**\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     **/\n    modifier ifCreditLineExists(uint256 _id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineLender(uint256 _id) {\n        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');\n        _;\n    }\n\n    /**\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /**\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     */\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /**\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /**\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /**\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     */\n    event CreditLineAccepted(uint256 indexed id);\n\n    /**\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /**\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /**\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     */\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /**\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /**\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /**\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /**\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), 'cant be 0 address');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'CL::I zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /**\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /**\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(\n            10**_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible > _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible > _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');\n    }\n\n    /**\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /**\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),\n            \"Only Borrower or Lender who hasn't requested can accept\"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /**\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, \"CreditLine::_depositCollateral - value to transfer doesn't match argument\");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, 'insufficient balance');\n    }\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\n            require(feeSuccess, 'Transfer fail');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\n            require(success, 'Transfer fail');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /**\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount >= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount > _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /**\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     */\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            'CreditLine: Permission denied while closing Line of credit'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 10**30 to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(\n            10**_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10**_decimals)\n            .div(10**30);\n\n        if (_collateralNeeded >= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert('insufficient collateral');\n    }\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,\n            'CreditLine: Collateral ratio is higher than ideal value'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}('');\n                    require(success, 'Transfer fail');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /**\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface ISavingsAccount {\n    /**\n     * @notice emitted when tokens are deposited into savings account\n     * @param user address of user depositing the tokens\n     * @param sharesReceived amount of shares received for deposit\n     * @param token address of token that is deposited\n     * @param strategy strategy into which tokens are deposited\n     */\n    event Deposited(address indexed user, uint256 sharesReceived, address indexed token, address indexed strategy);\n\n    /**\n     * @notice emitted when tokens are switched from one strategy to another\n     * @param user address of user switching strategies\n     * @param token address of token for which strategies are switched\n     * @param sharesDecreasedInCurrentStrategy shares decreased in current strategy\n     * @param sharesIncreasedInNewStrategy shares increased in new strategy\n     * @param currentStrategy address of the strategy from which tokens are switched\n     * @param newStrategy address of the strategy to which tokens are switched\n     */\n    event StrategySwitched(\n        address indexed user,\n        address indexed token,\n        uint256 sharesDecreasedInCurrentStrategy,\n        uint256 sharesIncreasedInNewStrategy,\n        address currentStrategy,\n        address indexed newStrategy\n    );\n\n    /**\n     * @notice emitted when tokens are withdrawn from savings account\n     * @param from address of user from which tokens are withdrawn\n     * @param to address of user to which tokens are withdrawn\n     * @param sharesWithdrawn amount of shares withdrawn\n     * @param token address of token that is withdrawn\n     * @param strategy strategy into which tokens are withdrawn\n     * @param withdrawShares flag to represent if shares are directly wirthdrawn\n     */\n    event Withdrawn(address indexed from, address indexed to, uint256 sharesWithdrawn, address indexed token, address strategy, bool withdrawShares);\n\n    /**\n     * @notice emitted when all tokens are withdrawn\n     * @param user address of user withdrawing tokens\n     * @param tokenReceived amount of tokens withdrawn\n     * @param token address of the token withdrawn\n     */\n    event WithdrawnAll(address indexed user, uint256 tokenReceived, address indexed token);\n\n    /**\n     * @notice emitted when tokens are approved\n     * @param token address of token approved\n     * @param from address of user from who tokens are approved\n     * @param to address of user to whom tokens are approved\n     * @param amount amount of tokens approved\n     */\n    event Approved(address indexed token, address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @notice emitted when tokens are transferred\n     * @param token address of token transferred\n     * @param strategy address of strategy from which tokens are transferred\n     * @param from address of user from whom tokens are transferred\n     * @param to address of user to whom tokens are transferred\n     * @param amount amount of tokens transferred\n     */\n    event Transfer(address indexed token, address strategy, address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @notice emitted when credit line address is updated\n     * @param updatedCreditLine updated credit line contract address\n     */\n    event CreditLineUpdated(address indexed updatedCreditLine);\n\n    /**\n     * @notice emitted when strategy registry is updated\n     * @param updatedStrategyRegistry updated strategy registry address\n     */\n    event StrategyRegistryUpdated(address indexed updatedStrategyRegistry);\n\n    /**\n     * @notice emitted when credit line allowance is refreshed\n     * @param token token for which allowance is increased\n     * @param from address of user from whcih allowance is increased\n     * @param amount amount of tokens by which allowance is increased\n     */\n    event CreditLineAllowanceRefreshed(address indexed token, address indexed from, address indexed to, uint256 amount);\n\n    function deposit(\n        uint256 amount,\n        address token,\n        address strategy,\n        address to\n    ) external payable returns (uint256 sharesReceived);\n\n    /**\n     * @dev Used to switch saving strategy of an token\n     * @param currentStrategy initial strategy of token\n     * @param newStrategy new strategy to invest\n     * @param token address of the token\n     * @param amount amount of tokens to be reinvested\n     */\n    function switchStrategy(\n        uint256 amount,\n        address token,\n        address currentStrategy,\n        address newStrategy\n    ) external;\n\n    /**\n     * @dev Used to withdraw token from Saving Account\n     * @param withdrawTo address to which token should be sent\n     * @param amount amount of tokens to withdraw\n     * @param token address of the token to be withdrawn\n     * @param strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)\n     * @param withdrawShares boolean indicating to withdraw in liquidity share or underlying token\n     */\n    function withdraw(\n        uint256 amount,\n        address token,\n        address strategy,\n        address payable withdrawTo,\n        bool withdrawShares\n    ) external returns (uint256);\n\n    function withdrawAll(address token) external returns (uint256 tokenReceived);\n\n    function withdrawAll(address token, address strategy) external returns (uint256 tokenReceived);\n\n    function approve(\n        uint256 amount,\n        address token,\n        address to\n    ) external;\n\n    function increaseAllowance(\n        uint256 amount,\n        address token,\n        address to\n    ) external;\n\n    function decreaseAllowance(\n        uint256 amount,\n        address token,\n        address to\n    ) external;\n\n    function transfer(\n        uint256 amount,\n        address token,\n        address poolSavingsStrategy,\n        address to\n    ) external returns (uint256);\n\n    function transferFrom(\n        uint256 amount,\n        address token,\n        address poolSavingsStrategy,\n        address from,\n        address to\n    ) external returns (uint256);\n\n    function balanceInShares(\n        address user,\n        address token,\n        address strategy\n    ) external view returns (uint256);\n\n    function increaseAllowanceToCreditLine(\n        uint256 amount,\n        address token,\n        address from\n    ) external;\n\n    function withdrawFrom(\n        uint256 amount,\n        address token,\n        address strategy,\n        address from,\n        address payable to,\n        bool withdrawShares\n    ) external returns (uint256 amountReceived);\n\n    function getTotalTokens(address _user, address _token) external returns (uint256 _totalTokens);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../interfaces/IStrategyRegistry.sol';\nimport '../interfaces/IYield.sol';\n\n/**\n * @title Savings account contract with Methods related to savings account\n * @notice Implements the functions related to savings account\n * @author Sublime\n **/\ncontract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice address of the strategy registry used to whitelist strategies\n     */\n    address public strategyRegistry;\n\n    /**\n     * @notice address of the credit lines contract\n     */\n    address public creditLine;\n\n    /**\n     * @notice mapping from user to token to strategy to balance of shares\n     * @dev user -> token -> strategy (underlying address) -> amount (shares)\n     */\n    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;\n\n    /**\n     * @notice mapping from user to token to toAddress for approval to amount approved\n     * @dev user => token => to => amount\n     */\n    mapping(address => mapping(address => mapping(address => uint256))) public allowance;\n\n    /**\n     * @notice modifier to check if address is the credit line\n     * @param _caller address to check if credit line\n     */\n    modifier onlyCreditLine(address _caller) {\n        require(_caller == creditLine, 'Invalid caller');\n        _;\n    }\n\n    /**\n     * @dev initialize the contract\n     * @param _owner address of the owner of the savings account contract\n     * @param _strategyRegistry address of the strategy registry\n     * @param _creditLine address of the credit line contract\n     **/\n    function initialize(\n        address _owner,\n        address _strategyRegistry,\n        address _creditLine\n    ) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateCreditLine(_creditLine);\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update credit line contract address\n     * @dev only owner can update\n     * @param _creditLine updated address of credit lines\n     */\n    function updateCreditLine(address _creditLine) external onlyOwner {\n        _updateCreditLine(_creditLine);\n    }\n\n    function _updateCreditLine(address _creditLine) internal {\n        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');\n        creditLine = _creditLine;\n        emit CreditLineUpdated(_creditLine);\n    }\n\n    /**\n     * @notice used to update strategy registry address\n     * @dev only owner can update\n     * @param _strategyRegistry updated address of strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to deposit tokens into strategy via savings account\n     * @dev if token is address(0), then it is Ether\n     * @param _amount amount of tokens deposited\n     * @param _token address of token contract\n     * @param _strategy address of the strategy into which tokens are to be deposited\n     * @param _to address to deposit to\n     */\n    function deposit(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _to\n    ) external payable override nonReentrant returns (uint256) {\n        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');\n        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);\n        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);\n        emit Deposited(_to, _sharesReceived, _token, _strategy);\n        return _sharesReceived;\n    }\n\n    function _deposit(\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256 _sharesReceived) {\n        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');\n        _sharesReceived = _depositToYield(_amount, _token, _strategy);\n    }\n\n    function _depositToYield(\n        uint256 _amount,\n        address _token,\n        address _strategy\n    ) internal returns (uint256 _sharesReceived) {\n        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');\n        uint256 _ethValue;\n\n        if (_token == address(0)) {\n            _ethValue = _amount;\n            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');\n        }\n        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);\n    }\n\n    /**\n     * @dev Used to switch saving strategy of an _token\n     * @param _currentStrategy initial strategy of token\n     * @param _newStrategy new strategy to invest\n     * @param _token address of the token\n     * @param _amount amount of tokens to be reinvested\n     */\n    function switchStrategy(\n        uint256 _amount,\n        address _token,\n        address _currentStrategy,\n        address _newStrategy\n    ) external override nonReentrant {\n        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');\n        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');\n        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');\n\n        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(\n            _amount,\n            'SavingsAccount::switchStrategy Insufficient balance'\n        );\n\n        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);\n\n        uint256 _ethValue;\n        if (_token != address(0)) {\n            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);\n        } else {\n            _ethValue = _tokensReceived;\n        }\n        _amount = _tokensReceived;\n        \n        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);\n\n        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);\n        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);\n    }\n\n    /**\n     * @dev Used to withdraw token from Saving Account\n     * @param _to address to which token should be sent\n     * @param _amount amount of tokens to withdraw\n     * @param _token address of the token to be withdrawn\n     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)\n     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token\n     */\n    function withdraw(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address payable _to,\n        bool _withdrawShares\n    ) external override nonReentrant returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');\n\n        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::withdraw Insufficient amount'\n        );\n\n        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);\n\n        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);\n        return _amountReceived;\n    }\n\n    /**\n     * @dev Used to withdraw token from allowance of Saving Account\n     * @param _from address from which tokens will be withdrawn\n     * @param _to address to which token should be withdrawn\n     * @param _amount amount of tokens to withdraw\n     * @param _token address of the token to be withdrawn\n     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)\n     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token\n     */\n\n    function withdrawFrom(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _from,\n        address payable _to,\n        bool _withdrawShares\n    ) external override nonReentrant returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');\n\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(\n            _amount,\n            'SavingsAccount::withdrawFrom allowance limit exceeding'\n        );\n\n        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n\n        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::withdrawFrom insufficient balance'\n        );\n        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);\n        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);\n        return _amountReceived;\n    }\n\n    function _withdraw(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address payable _to,\n        bool _withdrawShares\n    ) internal returns (address _tokenReceived, uint256 _amountReceived) {\n        if (_withdrawShares) {\n            _tokenReceived = IYield(_strategy).liquidityToken(_token);\n            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');\n            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);\n        } else {\n            _tokenReceived = _token;\n            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);\n        }\n        _transfer(_amountReceived, _tokenReceived, _to);\n    }\n\n    function _transfer(\n        uint256 _amount,\n        address _token,\n        address payable _to\n    ) internal {\n        if (_token == address(0)) {\n            (bool _success, ) = _to.call{value: _amount}('');\n            require(_success, 'Transfer failed');\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /**\n     * @notice used to withdraw a token from all strategies\n     * @param _token address of token which is to be withdrawn\n     */\n    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n\n        for (uint256 i = 0; i < _strategyList.length; i++) {\n            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {\n                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];\n                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);\n                _tokenReceived = _tokenReceived.add(_amount);\n                delete balanceInShares[msg.sender][_token][_strategyList[i]];\n            }\n        }\n\n        if (_tokenReceived == 0) return 0;\n\n        _transfer(_tokenReceived, _token, payable(msg.sender));\n\n        emit WithdrawnAll(msg.sender, _tokenReceived, _token);\n    }\n\n    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {\n        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];\n\n        if(_sharesBalance == 0) return 0;\n\n        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);\n\n        delete balanceInShares[msg.sender][_token][_strategy];\n\n        _transfer(_amount, _token, payable(msg.sender));\n\n        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);\n    }\n\n    /**\n     * @notice used to approve allowance to an address\n     * @dev this is prone to race condition, hence increaseAllowance is recommended\n     * @param _amount amount of tokens approved\n     * @param _token address of token approved\n     * @param _to address of the user approved to\n     */\n    function approve(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        allowance[msg.sender][_token][_to] = _amount;\n\n        emit Approved(_token, msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice used to increase allowance to an address\n     * @param _amount amount of tokens allowance is increased by\n     * @param _token address of token approved\n     * @param _to address of the address approved to\n     */\n    function increaseAllowance(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);\n        allowance[msg.sender][_token][_to] = _updatedAllowance;\n\n        emit Approved(_token, msg.sender, _to, _updatedAllowance);\n    }\n\n    /**\n     * @notice used to decrease allowance to an address\n     * @param _amount amount of tokens allowance is decreased by\n     * @param _token address of token approved\n     * @param _to address of the user approved to\n     */\n    function decreaseAllowance(\n        uint256 _amount,\n        address _token,\n        address _to\n    ) external override {\n        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);\n        allowance[msg.sender][_token][_to] = _updatedAllowance;\n\n        emit Approved(_token, msg.sender, _to, _updatedAllowance);\n    }\n\n    /**\n     * @notice used by credit lines to replenish the allowance once the credit line pricinpal is repaid\n     * @param _amount amount of tokens allowance is increased by\n     * @param _token address of token approved\n     * @param _from address of the lender of the credit line which is being replenished\n     */\n    function increaseAllowanceToCreditLine(\n        uint256 _amount,\n        address _token,\n        address _from\n    ) external override onlyCreditLine(msg.sender) {\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);\n\n        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);\n    }\n\n    /**\n     * @notice used to transfer tokens\n     * @param _amount amount of tokens transferred\n     * @param _token address of token transferred\n     * @param _strategy address of the strategy from which tokens are transferred\n     * @param _to address of the user tokens are transferred to\n     */\n    function transfer(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _to\n    ) external override returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::transfer zero amount');\n\n        if (_strategy != address(0)) {\n            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n        }\n\n        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::transfer insufficient funds'\n        );\n\n        //update receiver's balance\n        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);\n\n        emit Transfer(_token, _strategy, msg.sender, _to, _amount);\n\n        return _amount;\n    }\n\n    /**\n     * @notice used to transfer tokens from allowance by another address\n     * @param _amount amount of tokens transferred\n     * @param _token address of token transferred\n     * @param _strategy address of the strategy from which tokens are transferred\n     * @param _from address from whose allowance tokens are transferred\n     * @param _to address of the user tokens are transferred to\n     */\n    function transferFrom(\n        uint256 _amount,\n        address _token,\n        address _strategy,\n        address _from,\n        address _to\n    ) external override returns (uint256) {\n        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');\n        //update allowance\n        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(\n            _amount,\n            'SavingsAccount::transferFrom allowance limit exceeding'\n        );\n\n        if (_strategy != address(0)) {\n            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);\n        }\n\n        //reduce sender's balance\n        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(\n            _amount,\n            'SavingsAccount::transferFrom insufficient allowance'\n        );\n\n        //update receiver's balance\n        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);\n\n        emit Transfer(_token, _strategy, _from, _to, _amount);\n\n        return _amount;\n    }\n\n    /**\n     * @notice used to query total tokens of a token with a user\n     * @param _user address of the user\n     * @param _token address of token\n     * @return _totalTokens total number of tokens of the token with the user\n     */\n    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n\n        for (uint256 i = 0; i < _strategyList.length; i++) {\n            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];\n\n            if (_liquidityShares != 0) {\n                uint256 _tokenInStrategy = _liquidityShares;\n                if (_strategyList[i] != address(0)) {\n                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);\n                }\n\n                _totalTokens = _totalTokens.add(_tokenInStrategy);\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IYield {\n    /**\n     * @dev emitted when tokens are locked\n     * @param user the address of user, tokens locked for\n     * @param investedTo the address of contract to invest in\n     * @param lpTokensReceived the amount of shares received\n     **/\n    event LockedTokens(address indexed user, address indexed investedTo, uint256 lpTokensReceived);\n\n    /**\n     * @dev emitted when tokens are unlocked/redeemed\n     * @param investedTo the address of contract invested in\n     * @param collateralReceived the amount of underlying asset received\n     **/\n    event UnlockedTokens(address indexed investedTo, uint256 collateralReceived);\n\n    /**\n     * @notice emitted when a shares are unlocked from yield\n     * @param asset address of the base token for which shares are being withdrawn\n     * @param sharesReleased amount of shares unlocked\n     */\n    event UnlockedShares(address indexed asset, uint256 sharesReleased);\n\n    /**\n     * @notice emitted when savings account address is updated\n     * @param savingsAccount updated address of the savings account contract\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @dev Used to get liquidity token address from asset address\n     * @param asset the address of underlying token\n     * @return tokenAddress address of liquidity token\n     **/\n    function liquidityToken(address asset) external view returns (address tokenAddress);\n\n    /**\n     * @dev Used to lock tokens in available protocol\n     * @param user the address of user locking tokens\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable returns (uint256 sharesReceived);\n\n    /**\n     * @dev Used to unlock tokens from available protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of liquidity shares to unlock\n     * @return tokensReceived amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount) external returns (uint256 tokensReceived);\n\n    function unlockShares(address asset, uint256 amount) external returns (uint256 received);\n\n    /**\n     * @dev Used to get amount of underlying tokens for current number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) external returns (uint256 amount);\n\n    function getSharesForTokens(uint256 amount, address asset) external returns (uint256 shares);\n}\n\n\n",
        "CodeNames": [
            "CreditLine.sol",
            "ISavingsAccount.sol",
            "SavingsAccount.sol",
            "IYield.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "unlockTokens",
                    "switchStrategy",
                    "_tokensReceived",
                    "withdrawAll",
                    "_amount"
                ],
                "Type": " SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues",
                "Description": "\n\nFull withdrawal and moving funds between strategies can lead to wrong accounting if the corresponding market has tight liquidity, which can be the case at least for AaveYield. That is, as the whole amount is required to be moved at once from Aave, both withdrawAll and switchStrategy will incorrectly account for partial withdrawal as if it was full whenever the corresponding underlying yield pool had liquidity issues.\n\nwithdrawAll will delete user entry, locking the user funds in the strategy: user will get partial withdrawal and have the corresponding accounting entry removed, while the remaining actual funds will be frozen within the system.\n\nswitchStrategy will subtract full number of shares for the _amount requested from the old strategy, while adding lesser partial number of shares for _tokensReceived to the new one with the same effect of freezing user's funds within the system.\n\n\nSavingsAccount.withdrawAll\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L286\n\nSavingsAccount.switchStrategy:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L152\n\nWhen full withdrawal or strategy switch is performed it is one withdraw via unlockTokens without checking the amount received.\n\nIn the same time the withdraw can fail for example for the strategy switch if old strategy is having liquidity issues at the moment, i.e. Aave market is currently have utilization rate too high to withdraw the amount requested given current size of the lending pool.\n\nAave unlockTokens return is correctly not matched with amount requested:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/AaveYield.sol#L217\n\nBut, for example, withdrawAll ignores the fact that some funds can remain in the strategy and deletes the use entry after one withdraw attempt:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L294\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L312\n\nswitchStrategy removes the old entry completely:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L181\n\n",
                "Repair": "\nFor both withdrawAll and switchStrategy the immediate fix is to account for tokens received in both cases, which are _amount after unlockTokens for withdrawAll and _tokensReceived for switchStrategy.\n\nMore general handling of the liquidity issues ideally to be addressed architecturally, given the potential issues with liquidity availability any strategy withdrawals can be done as follows:\n\n1.  Withdraw what is possible on demand, leave the amount due as is, i.e. do not commit to completing the action in one go and notify the user the action was partial (return actual amount)\n2.  Save to query and repeat for the remainder funds on the next similar action (this can be separate flag triggered mode)\n\nritik99 (Sublime) disagreed with severity(https://github.com/code-423n4/2021-12-sublime-findings/issues/80#issuecomment-1000184590):\n  The above issue requires making a few assumptions (i) the underlying yield protocol does not have sufficient reserves to facilitate the withdrawal of a single user, (ii) the user attempts to withdraw all their assets during such times of insufficient reserves.\n \n We agree that the above could be a possibility, but would be unlikely. The underlying yield protocols undergo an interest rate spike during high utilization ratios to bring reserves back to normal levels, and some revert if they cannot withdraw the necessary amount (for eg, Compound(https://github.com/compound-finance/compound-protocol/blob/4a8648ec0364d24c4ecfc7d6cae254f55030d65f/contracts/CToken.sol#L679)). During live deployment, only those strategies that work expectedly would be onboarded, while others wouldn't (for eg, Aave as a strategy wouldn't be integrated until their wrappers for aTokens(https://github.com/aave/protocol-v2/blob/feat-atoken-wrapper-liquidity-mining/contracts/protocol/tokenization/StaticATokenLM.sol) are ready for use). Hence we suggest reducing severity to (2) medium-risk\n \n also similar to #144 \n\n0xean (judge) commented(https://github.com/code-423n4/2021-12-sublime-findings/issues/80#issuecomment-1018054859):\n  While I understand the argument regarding this being an unlikely scenario, I don't believe that is a sufficient reason to downgrade the issue give the impact to a user and the lost funds.  \n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n In this scenario Assets are at a direct risk. \n\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "//solidity\nrequire(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');\n",
                    "//solidity\n_amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);\n",
                    "//solidity\nbalanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(\n_amount,\n'SavingsAccount::switchStrategy Insufficient balance'\n);\n",
                    "//solidity\nuint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);\n",
                    "//solidity\nuint256 _ethValue;\nif (_token != address(0)) {\n    IERC20(_token).safeApprove(_newStrategy, _tokensReceived);\n} else {\n    _ethValue = _tokensReceived;\n}\n_amount = _tokensReceived;\n",
                    "//solidity\n\nuint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);\n\nbalanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);\n",
                    "//solidity\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Attacker{\n    function getSharesForTokens(uint256 amount, address token) external payable  returns(uint256){\n        return 0;\n    }\n    function unlockTokens(address token, uint256 amount) external payable returns(uint256){\n        uint256 bal;\n        if(token == address(0))\n            bal = msg.sender.balance;\n        else\n            bal = IERC20(token).balanceOf(msg.sender);\n        return bal;\n    }\n}\n"
                ],
                "Type": " Possibility to drain SavingsAccount contract assets",
                "Description": "\n\nA malicious actor can manipulate switchStrategy() function in a way to withdraw tokens that are locked in SavingsAccount contract\n(the risk severity should be reviewed)\n\n\nFirstly an attacker need to deploy a rogue strategy contract implementing IYield.getSharesForTokens() and IYield.unlockTokens() functions\nand calling switchStrategy() with _currentStrategy = ROGUE_CONTRACT_ADDRESS (_newStrategy can be any valid strategy e.g. NoYield)\n\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L160\nsolidity\nrequire(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');\n\nBypass this check by setting _amount  0, since it will be overwritten in line\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L162\nsolidity\n_amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);\n\ngetSharesForTokens() should be implemented to always return 0, hence to bypass the overflow in lines\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L164-L167\nsolidity\nbalanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(\n_amount,\n'SavingsAccount::switchStrategy Insufficient balance'\n);\n\nsince balanceInShares[msg.sender][_token][_currentStrategy] == 0 and 0-0 will not overflow\n\nThe actual amount to be locked is saved in line\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L169\nsolidity\nuint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);\n\nthe rouge unlockTokens() can check asset balance of the contract and return the full amount\n\nAfter that some adjustment are made to set approval for the token or to handle native assets case\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L171-L177\nsolidity\nuint256 _ethValue;\nif (_token != address(0)) {\n    IERC20(_token).safeApprove(_newStrategy, _tokensReceived);\n} else {\n    _ethValue = _tokensReceived;\n}\n_amount = _tokensReceived;\n\nFinally the assets are locked in the locked strategy and shares are allocated on attackers acount\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L179-L181\nsolidity\n\nuint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);\n\nbalanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);\n\n\nProof of Concept\n\nsolidity\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Attacker{\n    function getSharesForTokens(uint256 amount, address token) external payable  returns(uint256){\n        return 0;\n    }\n    function unlockTokens(address token, uint256 amount) external payable returns(uint256){\n        uint256 bal;\n        if(token == address(0))\n            bal = msg.sender.balance;\n        else\n            bal = IERC20(token).balanceOf(msg.sender);\n        return bal;\n    }\n}\n\n",
                "Repair": "\nAdd a check for _currentStrategy to be from strategy list like the one in line\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L159\n\n    require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');\n\nritik99 (Sublime) disputed(https://github.com/code-423n4/2021-12-sublime-findings/issues/41#issuecomment-1001380202):\n  The savings account contract doesn't hold any tokens, so it is not possible to lock tokens in a new strategy, hence this attack will not work. Nevertheless it is something we will explore further to limit unexpected state changes\n\n0xean (judge) commented(https://github.com/code-423n4/2021-12-sublime-findings/issues/41#issuecomment-1018063038):\n  Based on the review of the warden I believe this is a valid attack path.  This line would need to change to the amount of tokens that are to be \"stolen\" but otherwise this does seem accurate. \n \nsolidity\nbal = IERC20(token).balanceOf(msg.sender);\n\n\n\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\n    function unlinkAddress(address _linkedAddress) external {\n        address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;\n        require(_linkedTo != address(0), 'V:UA-Address not linked');\n        require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');\n        delete linkedAddresses[_linkedAddress]; \n       ...\n}\n    function linkAddress(address _masterAddress) external {\n        require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');   // == true (after unlinkAddress)\n        require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');                 // == true (after unlinkAddress)\n        _linkAddress(msg.sender, _masterAddress);                                                                                           // // pendingLinkAddresses not reset\n    }\n\nfunction cancelAddressLinkingRequest(address _linkedAddress) external {\n        ... \n        delete pendingLinkAddresses[_linkedAddress][msg.sender]; // only location where pendingLinkAddresses is reset\n"
                ],
                "Type": " Unlinked address can link immediately again",
                "Description": "\n\nAfter a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission.\nThe address that is just unlinked can call linkAddress(masterAddress) which will execute because pendingLinkAddresses is still set.\nAssuming the master has unlinked for a good reason it is unwanted to be able to be linked again without any permission from the master.\n\nNote: a master can prevent this by calling cancelAddressLinkingRequest(), but this doesn't seem logical to do\n\n\n<https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Verification/Verification.sol#L129-L154\n\nsolidity\n    function unlinkAddress(address _linkedAddress) external {\n        address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;\n        require(_linkedTo != address(0), 'V:UA-Address not linked');\n        require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');\n        delete linkedAddresses[_linkedAddress]; \n       ...\n}\n    function linkAddress(address _masterAddress) external {\n        require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');   // == true (after unlinkAddress)\n        require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');                 // == true (after unlinkAddress)\n        _linkAddress(msg.sender, _masterAddress);                                                                                           // // pendingLinkAddresses not reset\n    }\n\nfunction cancelAddressLinkingRequest(address _linkedAddress) external {\n        ... \n        delete pendingLinkAddresses[_linkedAddress][msg.sender]; // only location where pendingLinkAddresses is reset\n\n\n",
                "Repair": "\nAdd something like to following at the end of linkAddress:\n\nsolidity\ndelete pendingLinkAddresses[msg.sender][_masterAddress]; \n\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/54)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.6;\n\nimport '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './interfaces/IPriceOracle.sol';\n\ncontract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {\n    using SafeMath for uint256;\n\n    uint32 uniswapPriceAveragingPeriod;\n    struct PriceData {\n        address oracle;\n        uint256 decimals;\n    }\n    /**\n     * @notice stores the price oracle and its decimals for chainlink feeds\n     **/\n    mapping(address => PriceData) public chainlinkFeedAddresses;\n    mapping(address => uint256) decimals;\n\n    /**\n     * @notice stores the addresses of price feeds for uniswap token pairs\n     **/\n    mapping(bytes32 => address) public uniswapPools;\n\n    /**\n     * @notice Used to initialize the price oracle contract\n     * @dev can only be invoked once\n     * @param _admin owner of the price oracle\n     **/\n    function initialize(address _admin) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_admin);\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from chainlink\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        PriceData memory _feedData1 = chainlinkFeedAddresses[num];\n        PriceData memory _feedData2 = chainlinkFeedAddresses[den];\n        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {\n            return (0, 0);\n        }\n        int256 price1;\n        int256 price2;\n        {\n            uint80 roundID1;\n            uint256 timeStamp1;\n            uint80 answeredInRound1;\n            (\n                roundID1,\n                price1,\n                ,\n                timeStamp1,\n                answeredInRound1\n            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();\n            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {\n                return (0, 0);\n            }\n        }\n        {\n            uint80 roundID2;\n            uint256 timeStamp2;\n            uint80 answeredInRound2;\n            (\n                roundID2,\n                price2,\n                ,\n                timeStamp2,\n                answeredInRound2\n            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();\n            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {\n                return (0, 0);\n            }\n        }\n        uint256 price = uint256(price1)\n            .mul(10**_feedData2.decimals)\n            .mul(10**30)\n            .div(uint256(price2))\n            .div(10**_feedData1.decimals)\n            .mul(10**decimals[den])\n            .div(10**decimals[num]);\n        return (price, 30);\n    }\n\n    /**\n     * @notice Used to get decimals for a token\n     * @param _token address of the token\n     * @return number of decimals for the token\n     **/\n    function getDecimals(address _token) internal view returns (uint8) {\n        if (_token == address(0)) {\n            return 18;\n        }\n\n        try ERC20(_token).decimals() returns (uint8 v) {\n            return v;\n        } catch Error(string memory) {\n            return 0;\n        } catch (bytes memory) {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from uniswap\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);\n        address _pool = uniswapPools[_poolTokensId];\n        if (_pool == address(0)) {\n            return (0, 0);\n        }\n\n        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);\n        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);\n        return (_numTokens, 30);\n    }\n\n    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {\n        if (uint256(num) < uint256(den)) {\n            return keccak256(abi.encodePacked(num, den));\n        } else {\n            return keccak256(abi.encodePacked(den, num));\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n        uint256 _price;\n        uint256 _decimals;\n        (_price, _decimals) = getChainlinkLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        (_price, _decimals) = getUniswapLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        revert(\"PriceOracle::getLatestPrice - Price Feed doesn't exist\");\n    }\n\n    /**\n     * @notice used to check if price feed exists between 2 tokens\n     * @param token1 one of the token for which price feed is to be checked\n     * @param token2 other token for which price feed is to be checked\n     * @return if price feed exists for the token pair\n     **/\n    function doesFeedExist(address token1, address token2) external view override returns (bool) {\n        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {\n            return true;\n        }\n\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n\n        if (uniswapPools[_poolTokensId] != address(0)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token in chainlink\n     * @dev only owner can set\n     * @param token address of token for which price feed is added\n     * @param priceOracle addrewss of the price feed for the token\n     **/\n    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {\n        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();\n        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);\n        decimals[token] = getDecimals(token);\n        emit ChainlinkFeedUpdated(token, priceOracle);\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token pair in uniswap\n     * @dev only owner can set\n     * @param token1 address of one of the tokens for which price feed is added\n     * @param token2 address of other token for which price feed is added\n     * @param pool addrewss of the price feed for the token pair\n     **/\n    function setUniswapFeedAddress(\n        address token1,\n        address token2,\n        address pool\n    ) external onlyOwner {\n        require(token1 != token2, 'token1 and token2 should be different addresses');\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n        uniswapPools[_poolTokensId] = pool;\n        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);\n    }\n\n    /**\n     * @notice Used to set the period in which uniswap price is averaged\n     * @dev only owner can set. This is used to prevent attacks to control price feed\n     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging\n     **/\n    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {\n        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;\n        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);\n    }\n}\n\n\n",
        "CodeNames": [
            "PriceOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "//solidity\nfunction getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n    uint256 _price;\n    uint256 _decimals;\n    (_price, _decimals) = getChainlinkLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    (_price, _decimals) = getUniswapLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    revert(\"PriceOracle::getLatestPrice Price Feed doesn't exist\");\n}\n"
                ],
                "Type": "  PriceOracle  Does Not Filter Price Feed Outliers",
                "Description": "\n\nIf for whatever reason the Chainlink oracle returns a malformed price due to oracle manipulation or a malfunctioned price, the result will be passed onto users, causing unintended consequences as a result.\n\nIn the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.\n\n\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L149-L161\nsolidity\nfunction getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n    uint256 _price;\n    uint256 _decimals;\n    (_price, _decimals) = getChainlinkLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    (_price, _decimals) = getUniswapLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    revert(\"PriceOracle::getLatestPrice Price Feed doesn't exist\");\n}\n\nThe above code outlines how prices are utilised regardless of their actual value (assuming it is always a non-zero value).\n\n",
                "Repair": "\nConsider querying both the Chainlink oracle and Uniswap pool for latest prices, ensuring that these two values are within some upper/lower bounds of each other. It may also be useful to track historic values and ensure that there are no sharp changes in price. However, the first option provides a level of simplicity as UniswapV3's TWAP implementation is incredibly resistant to flash loan attacks. Hence, the main issue to address is a malfunctioning Chainlink oracle.\n\nritik99 (Sublime) disputed(https://github.com/code-423n4/2021-12-sublime-findings/issues/51#issuecomment-1007996594):\n  The described suggestion is fairly complex besides the increase in code complexity, we'd also have to decide the bounds within which the Uniswap and Chainlink oracles should report prices that won't be trivial. We've also noted in the assumptions(https://github.com/code-423n4/2021-12-sublime#assumptions--design-choices) section of our contest repo that oracles are assumed to be accurate\n\n0xean (judge) commented(https://github.com/code-423n4/2021-12-sublime-findings/issues/51#issuecomment-1018064762):\n  \" We expect these feeds to be fairly reliable.\" Based on this quote, I am going to leave this open at the current risk level.  These are valid changes that could significantly reduce the risk of the implementation and unintended liquidations. \n \n Fairly reliable != 100% reliable\n \n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\ninterface IPool {\n    /**\n     * @notice Emitted when pool is cancelled either on borrower request or insufficient funds collected\n     */\n    event PoolCancelled();\n\n    /**\n     * @notice Emitted when pool is terminated by admin\n     */\n    event PoolTerminated();\n\n    /**\n     * @notice Emitted when pool is closed after repayments are complete\n     */\n    event PoolClosed();\n\n    /**\n     * @notice emitted when borrower posts collateral\n     * @param borrower address of the borrower\n     * @param amount amount denominated in collateral asset\n     * @param sharesReceived shares received after transferring collaterla to pool savings strategy\n     */\n    event CollateralAdded(address indexed borrower, uint256 amount, uint256 sharesReceived);\n\n    /**\n     * @notice emitted when borrower posts collateral after a margin call\n     * @param borrower address of the borrower\n     * @param lender lender who margin called\n     * @param amount amount denominated in collateral asset\n     * @param sharesReceived shares received after transferring collaterla to pool savings strategy\n     */\n    event MarginCallCollateralAdded(address indexed borrower, address indexed lender, uint256 amount, uint256 sharesReceived);\n\n    /**\n     * @notice emitted when borrower withdraws excess collateral\n     * @param borrower address of borrower\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(address indexed borrower, uint256 amount);\n\n    /**\n     * @notice emitted when lender supplies liquidity to a pool\n     * @param amountSupplied amount that was supplied\n     * @param lenderAddress address of the lender. allows for delegation of lending\n     */\n    event LiquiditySupplied(uint256 amountSupplied, address indexed lenderAddress);\n\n    /**\n     * @notice emitted when borrower withdraws loan\n     * @param amount tokens the borrower withdrew, taking into account the deducted protocol fee\n     * @param protocolFee protocol fee deducted when borrower withdrew the amount \n     */\n    event AmountBorrowed(uint256 amount, uint256 protocolFee);\n\n    /**\n     * @notice emitted when lender withdraws from borrow pool\n     * @param amount amount that lender withdraws from borrow pool\n     * @param lenderAddress address to which amount is withdrawn\n     */\n    event LiquidityWithdrawn(uint256 amount, address indexed lenderAddress);\n\n    /**\n     * @notice emitted when lender exercises a margin/collateral call\n     * @param lenderAddress address of the lender who exercises margin calls\n     */\n    event MarginCalled(address indexed lenderAddress);\n\n    /**\n     * @notice emitted when collateral backing lender is liquidated because of a margin call\n     * @param liquidator address that calls the liquidateForLender() function\n     * @param lender lender who initially exercised the margin call\n     * @param _tokenReceived amount received by liquidator denominated in collateral asset\n     */\n    event LenderLiquidated(address indexed liquidator, address indexed lender, uint256 _tokenReceived);\n\n    /**\n     * @notice emitted when a pool is liquidated for missing repayment\n     * @param liquidator address of the liquidator\n     */\n    event PoolLiquidated(address indexed liquidator);\n\n    function getLoanStatus() external view returns (uint256);\n\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable;\n\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _isDirect\n    ) external payable;\n\n    function withdrawBorrowedAmount() external;\n\n    function borrower() external returns (address);\n\n    function getMarginCallEndTime(address _lender) external returns (uint256);\n\n    function getBalanceDetails(address _lender) external view returns (uint256, uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function closeLoan() external payable;\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IYield.sol';\nimport '../interfaces/Invest/ICEther.sol';\nimport '../interfaces/Invest/ICToken.sol';\n\n/**\n * @title Yield contract\n * @notice Implements the functions to lock/unlock tokens into available exchanges\n * @author Sublime\n **/\ncontract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address payable public savingsAccount;\n\n    /**\n     * @notice checks if contract is invoked by savings account\n     **/\n    modifier onlySavingsAccount() {\n        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');\n        _;\n    }\n\n    /**\n     * @notice used to initialize the variables in the contract\n     * @dev can only be called once\n     * @param _owner address of the owner\n     * @param _savingsAccount address of the savings account contract\n     **/\n    function initialize(address _owner, address payable _savingsAccount) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    /**\n     * @notice used to query liquidity token for a given asset\n     * @param _asset address of the asset\n     * @return _tokenAddress address of the lqiudity token for the asset\n     **/\n    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {\n        _tokenAddress = _asset;\n    }\n\n    /**\n     * @notice used to update savings account contract address\n     * @dev can only be called by owner\n     * @param _savingsAccount address of updated savings account contract\n     **/\n    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address payable _savingsAccount) internal {\n        require(_savingsAccount != address(0), 'Invest: zero address');\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to withdraw all tokens of a type in case of emergencies\n     * @dev only owner can withdraw\n     * @param _asset address of the token being withdrawn\n     * @param _wallet address to which tokens are withdrawn\n     */\n    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n        require(_wallet != address(0), 'cant burn');\n        uint256 amount = IERC20(_asset).balanceOf(address(this));\n        IERC20(_asset).safeTransfer(_wallet, received);\n        received = amount;\n    }\n\n    /**\n     * @notice Used to lock tokens in the protocol\n     * @dev Asset Tokens to be locked must be approved to this contract by user\n     * @param user the address of user\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n        require(amount != 0, 'Invest: amount');\n        if (asset != address(0)) {\n            IERC20(asset).safeTransferFrom(user, address(this), amount);\n        } else {\n            require(msg.value == amount, 'Invest: ETH amount');\n        }\n        sharesReceived = amount;\n        emit LockedTokens(user, asset, sharesReceived);\n    }\n\n    /**\n     * @notice Used to unlock tokens from the protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of asset\n     * @return tokensReceived received amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount)\n        external\n        override\n        onlySavingsAccount\n        nonReentrant\n        returns (uint256 tokensReceived)\n    {\n        tokensReceived = _unlockTokens(asset, amount);\n    }\n\n    /**\n     * @notice Used to unlock shares\n     * @param asset the address of underlying token\n     * @param amount the amount of shares to unlock\n     * @return received amount of shares received\n     **/\n    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {\n        received = _unlockTokens(asset, amount);\n    }\n\n    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {\n        require(amount != 0, 'Invest: amount');\n        received = amount;\n        if (asset == address(0)) {\n            (bool success, ) = savingsAccount.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            IERC20(asset).safeTransfer(savingsAccount, received);\n        }\n        emit UnlockedTokens(asset, received);\n    }\n\n    /**\n     * @dev Used to get amount of underlying tokens for given number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {\n        amount = shares;\n    }\n\n    /**\n     * @notice Used to get number of shares from an amount of underlying tokens\n     * @param amount the amount of tokens\n     * @param asset the address of token\n     * @return shares amount of shares for given tokens\n     **/\n    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {\n        shares = amount;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IYield.sol';\nimport '../interfaces/Invest/IWETHGateway.sol';\nimport '../interfaces/Invest/AaveLendingPool.sol';\nimport '../interfaces/Invest/IScaledBalanceToken.sol';\nimport '../interfaces/Invest/IProtocolDataProvider.sol';\n\n/**\n * @title Yield contract\n * @notice Implements the functions to lock/unlock tokens into Aave protocol\n * @author Sublime\n **/\ncontract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice address of wethGateway used to deposit ETH to aave\n     */\n    address public wethGateway;\n\n    /**\n     * @notice address of protocolDataProvider which provides info about aTokens related to any token\n     */\n    address public protocolDataProvider;\n\n    /**\n     * @notice address of lendingPoolAddressesProvider used to get the pool related to any token\n     */\n    address public lendingPoolAddressesProvider;\n\n    /**\n     * @notice address of savings account contract\n     */\n    address payable public savingsAccount;\n\n    /**\n     * @notice aave referral code to represent sublime\n     */\n    uint16 public referralCode;\n\n    /**\n     * @notice emitted when aave protocol related addresses are updated\n     * @param wethGateway address of wethGateway\n     * @param protocolDataProvider address of protocol data provider\n     * @param lendingPoolAddressesProvider address of lending pool addresses provider\n     */\n    event AaveAddressesUpdated(\n        address indexed wethGateway,\n        address indexed protocolDataProvider,\n        address indexed lendingPoolAddressesProvider\n    );\n\n    /**\n     * @notice emitted when aave referral code is updated\n     * @param referralCode updated referral code\n     */\n    event ReferralCodeUpdated(uint16 referralCode);\n\n    /**\n     * @notice verifies if savings account invoked the contract\n     */\n    modifier onlySavingsAccount() {\n        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');\n        _;\n    }\n\n    /**\n     * @notice To initialize the contract addresses interacting with this contract\n     * @dev can only be initialized once\n     * @param _owner address of owner\n     * @param _savingsAccount address of the savings account contract\n     * @param _wethGateway address of wethGateway\n     * @param _protocolDataProvider the address of ProtocolDataProvider\n     * @param _lendingPoolAddressesProvider the address of LendingPoolAddressesProvider\n     **/\n    function initialize(\n        address _owner,\n        address payable _savingsAccount,\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateSavingsAccount(_savingsAccount);\n        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    /**\n     * @notice Used to get liquidity token address from asset address\n     * @param asset the address of underlying token\n     * @return aToken address of liquidity token\n     **/\n    function liquidityToken(address asset) public view override returns (address aToken) {\n        if (asset == address(0)) {\n            aToken = IWETHGateway(wethGateway).getAWETHAddress();\n        } else {\n            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);\n        }\n    }\n\n    /**\n     * @notice used to update savings account address\n     * @dev only owner can update\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address payable _savingsAccount) internal {\n        require(_savingsAccount != address(0), 'Invest: zero address');\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update aave protocol related addresses\n     * @dev only owner can update\n     * @param _wethGateway address of wethGateway\n     * @param _protocolDataProvider address of protocol data provider\n     * @param _lendingPoolAddressesProvider address of lending pool addresses provider\n     */\n    function updateAaveAddresses(\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) external onlyOwner {\n        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    function _updateAaveAddresses(\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) internal {\n        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');\n        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');\n        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');\n        wethGateway = _wethGateway;\n        protocolDataProvider = _protocolDataProvider;\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    /**\n     * @notice used to update referral code\n     * @dev only owner can update\n     * @param _referralCode updated referral code\n     */\n    function updateReferralCode(uint16 _referralCode) external onlyOwner {\n        referralCode = _referralCode;\n        emit ReferralCodeUpdated(_referralCode);\n    }\n\n    /**\n     * @notice used to withdraw all tokens of a type in case of emergencies\n     * @dev only owner can withdraw\n     * @param _asset address of the token being withdrawn\n     * @param _wallet address to which tokens are withdrawn\n     */\n    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n        require(_wallet != address(0), 'cant burn');\n        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));\n\n        if (_asset == address(0)) {\n            received = _withdrawETH(amount);\n            (bool success, ) = _wallet.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            received = _withdrawERC(_asset, amount);\n            IERC20(_asset).safeTransfer(_wallet, received);\n        }\n    }\n\n    /**\n     * @notice Used to lock tokens in protocol\n     * @dev Asset Tokens to be locked must be approved to this contract by user\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n        require(amount != 0, 'Invest: amount');\n\n        address investedTo;\n        if (asset == address(0)) {\n            require(msg.value == amount, 'Invest: ETH amount');\n            (investedTo, sharesReceived) = _depositETH(amount);\n        } else {\n            IERC20(asset).safeTransferFrom(user, address(this), amount);\n            (investedTo, sharesReceived) = _depositERC20(asset, amount);\n        }\n\n        emit LockedTokens(user, investedTo, sharesReceived);\n    }\n\n    /**\n     * @notice Used to unlock tokens from available protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of asset\n     * @return received amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {\n        require(amount != 0, 'Invest: amount');\n\n        if (asset == address(0)) {\n            received = _withdrawETH(amount);\n            (bool success, ) = savingsAccount.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            received = _withdrawERC(asset, amount);\n            IERC20(asset).safeTransfer(savingsAccount, received);\n        }\n\n        emit UnlockedTokens(asset, received);\n    }\n\n    /**\n     * @notice Used to unlock shares\n     * @param asset the address of underlying token\n     * @param amount the amount of shares to unlock\n     * @return received amount of shares received\n     **/\n    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n\n        require(asset != address(0), 'Asset address cannot be address(0)');\n        IERC20(asset).safeTransfer(savingsAccount, amount);\n\n        emit UnlockedShares(asset, amount);\n        return amount;\n    }\n\n    /**\n     * @notice Used to get amount of underlying tokens for current number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n        if (shares == 0) return 0;\n        address aToken = liquidityToken(asset);\n\n        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);\n\n        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(\n            IERC20(aToken).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Used to get number of shares from an amount of underlying tokens\n     * @param amount the amount of tokens\n     * @param asset the address of token\n     * @return shares amount of shares for given tokens\n     **/\n    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {\n        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));\n    }\n\n    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {\n        aToken = IWETHGateway(wethGateway).getAWETHAddress();\n\n        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        //lock collateral\n        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);\n\n        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);\n    }\n\n    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {\n        aToken = liquidityToken(asset);\n        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        //approve collateral to vault\n        IERC20(asset).approve(lendingPool, 0);\n        IERC20(asset).approve(lendingPool, amount);\n\n        //lock collateral in vault\n        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);\n\n        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);\n    }\n\n    function _withdrawETH(uint256 amount) internal returns (uint256 received) {\n        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);\n\n        uint256 ethBalance = address(this).balance;\n\n        //lock collateral\n        IWETHGateway(wethGateway).withdrawETH(amount, address(this));\n\n        received = address(this).balance.sub(ethBalance);\n    }\n\n    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {\n        address aToken = liquidityToken(asset);\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));\n\n        IERC20(aToken).approve(lendingPool, amount);\n\n        //withdraw collateral from vault\n        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));\n\n        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "IPool.sol",
            "NoYield.sol",
            "AaveYield.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "//solidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    uint256 amount = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n    received = amount;\n}\n"
                ],
                "Type": " Wrong implementation of  NoYield.sol#emergencyWithdraw() ",
                "Description": "\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83\n\nsolidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    uint256 amount = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n    received = amount;\n}\n\n\nreceived is not being assigned prior to L81, therefore, at L81, received is 0.\n\nAs a result, the emergencyWithdraw() does not work, in essence.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    received = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n}\n\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/115) \n\n0xean (judge) commented(https://github.com/code-423n4/2021-12-sublime-findings/issues/115#issuecomment-1018669684):\n  upgrading to High  sev based on assets being \"lost\" directly.  IE the emergency function will not work.\n \n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.6;\n\nimport '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './interfaces/IPriceOracle.sol';\n\ncontract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {\n    using SafeMath for uint256;\n\n    uint32 uniswapPriceAveragingPeriod;\n    struct PriceData {\n        address oracle;\n        uint256 decimals;\n    }\n    /**\n     * @notice stores the price oracle and its decimals for chainlink feeds\n     **/\n    mapping(address => PriceData) public chainlinkFeedAddresses;\n    mapping(address => uint256) decimals;\n\n    /**\n     * @notice stores the addresses of price feeds for uniswap token pairs\n     **/\n    mapping(bytes32 => address) public uniswapPools;\n\n    /**\n     * @notice Used to initialize the price oracle contract\n     * @dev can only be invoked once\n     * @param _admin owner of the price oracle\n     **/\n    function initialize(address _admin) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_admin);\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from chainlink\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        PriceData memory _feedData1 = chainlinkFeedAddresses[num];\n        PriceData memory _feedData2 = chainlinkFeedAddresses[den];\n        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {\n            return (0, 0);\n        }\n        int256 price1;\n        int256 price2;\n        {\n            uint80 roundID1;\n            uint256 timeStamp1;\n            uint80 answeredInRound1;\n            (\n                roundID1,\n                price1,\n                ,\n                timeStamp1,\n                answeredInRound1\n            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();\n            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {\n                return (0, 0);\n            }\n        }\n        {\n            uint80 roundID2;\n            uint256 timeStamp2;\n            uint80 answeredInRound2;\n            (\n                roundID2,\n                price2,\n                ,\n                timeStamp2,\n                answeredInRound2\n            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();\n            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {\n                return (0, 0);\n            }\n        }\n        uint256 price = uint256(price1)\n            .mul(10**_feedData2.decimals)\n            .mul(10**30)\n            .div(uint256(price2))\n            .div(10**_feedData1.decimals)\n            .mul(10**decimals[den])\n            .div(10**decimals[num]);\n        return (price, 30);\n    }\n\n    /**\n     * @notice Used to get decimals for a token\n     * @param _token address of the token\n     * @return number of decimals for the token\n     **/\n    function getDecimals(address _token) internal view returns (uint8) {\n        if (_token == address(0)) {\n            return 18;\n        }\n\n        try ERC20(_token).decimals() returns (uint8 v) {\n            return v;\n        } catch Error(string memory) {\n            return 0;\n        } catch (bytes memory) {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from uniswap\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);\n        address _pool = uniswapPools[_poolTokensId];\n        if (_pool == address(0)) {\n            return (0, 0);\n        }\n\n        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);\n        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);\n        return (_numTokens, 30);\n    }\n\n    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {\n        if (uint256(num) < uint256(den)) {\n            return keccak256(abi.encodePacked(num, den));\n        } else {\n            return keccak256(abi.encodePacked(den, num));\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n        uint256 _price;\n        uint256 _decimals;\n        (_price, _decimals) = getChainlinkLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        (_price, _decimals) = getUniswapLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        revert(\"PriceOracle::getLatestPrice - Price Feed doesn't exist\");\n    }\n\n    /**\n     * @notice used to check if price feed exists between 2 tokens\n     * @param token1 one of the token for which price feed is to be checked\n     * @param token2 other token for which price feed is to be checked\n     * @return if price feed exists for the token pair\n     **/\n    function doesFeedExist(address token1, address token2) external view override returns (bool) {\n        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {\n            return true;\n        }\n\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n\n        if (uniswapPools[_poolTokensId] != address(0)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token in chainlink\n     * @dev only owner can set\n     * @param token address of token for which price feed is added\n     * @param priceOracle addrewss of the price feed for the token\n     **/\n    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {\n        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();\n        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);\n        decimals[token] = getDecimals(token);\n        emit ChainlinkFeedUpdated(token, priceOracle);\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token pair in uniswap\n     * @dev only owner can set\n     * @param token1 address of one of the tokens for which price feed is added\n     * @param token2 address of other token for which price feed is added\n     * @param pool addrewss of the price feed for the token pair\n     **/\n    function setUniswapFeedAddress(\n        address token1,\n        address token2,\n        address pool\n    ) external onlyOwner {\n        require(token1 != token2, 'token1 and token2 should be different addresses');\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n        uniswapPools[_poolTokensId] = pool;\n        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);\n    }\n\n    /**\n     * @notice Used to set the period in which uniswap price is averaged\n     * @dev only owner can set. This is used to prevent attacks to control price feed\n     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging\n     **/\n    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {\n        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;\n        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IStrategyRegistry.sol';\n\n/**\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n **/\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     **/\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /**\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId => Strategy => collateralShares\n     **/\n    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;\n\n    /**\n     * @notice stores the variables to maintain a credit line\n     **/\n    mapping(uint256 => CreditLineVariables) public creditLineVariables;\n\n    /**\n     * @notice stores the constants related to a credit line\n     **/\n    mapping(uint256 => CreditLineConstants) public creditLineConstants;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address public savingsAccount;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    address public priceOracle;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    address public strategyRegistry;\n\n    /**\n     * @notice stores the address of default strategy\n     **/\n    address public defaultStrategy;\n\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    /**\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public liquidatorRewardFraction;\n    /**\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     **/\n    modifier ifCreditLineExists(uint256 _id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineLender(uint256 _id) {\n        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');\n        _;\n    }\n\n    /**\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /**\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     */\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /**\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /**\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /**\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     */\n    event CreditLineAccepted(uint256 indexed id);\n\n    /**\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /**\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /**\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     */\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /**\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /**\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /**\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /**\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), 'cant be 0 address');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'CL::I zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /**\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /**\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(\n            10**_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible > _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible > _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');\n    }\n\n    /**\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /**\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),\n            \"Only Borrower or Lender who hasn't requested can accept\"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /**\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, \"CreditLine::_depositCollateral - value to transfer doesn't match argument\");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, 'insufficient balance');\n    }\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\n            require(feeSuccess, 'Transfer fail');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\n            require(success, 'Transfer fail');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /**\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount >= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount > _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /**\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     */\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            'CreditLine: Permission denied while closing Line of credit'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 10**30 to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(\n            10**_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10**_decimals)\n            .div(10**30);\n\n        if (_collateralNeeded >= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert('insufficient collateral');\n    }\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,\n            'CreditLine: Collateral ratio is higher than ideal value'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}('');\n                    require(success, 'Transfer fail');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /**\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IRepayment.sol';\n\n/**\n * @title Repayments contract\n * @dev For accuracy considering base itself as (10**30)\n * @notice Implements the functions related to repayments (payments that\n * have to made by the borrower back to the pool)\n * @author Sublime\n */\ncontract Repayments is Initializable, IRepayment, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    uint256 constant MAX_INT = 2**256 - 1;\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    IPoolFactory poolFactory;\n\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repaymennt defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n\n    uint256 gracePenaltyRate;\n    uint256 gracePeriodFraction; // fraction of the repayment interval\n\n    struct RepaymentVariables {\n        uint256 repaidAmount;\n        bool isLoanExtensionActive;\n        uint256 loanDurationCovered;\n        uint256 loanExtensionPeriod; // period for which the extension was granted, ie, if loanExtensionPeriod is 7 * 10**30, 7th instalment can be repaid by 8th instalment deadline\n    }\n\n    struct RepaymentConstants {\n        uint256 numberOfTotalRepayments; // using it to check if RepaymentDetails Exists as repayment Interval!=0 in any case\n        uint256 gracePenaltyRate;\n        uint256 gracePeriodFraction;\n        uint256 loanDuration;\n        uint256 repaymentInterval;\n        uint256 borrowRate;\n        uint256 loanStartTime;\n        address repayAsset;\n    }\n\n    /**\n     * @notice used to maintain the variables related to repayment against a pool\n     */\n    mapping(address => RepaymentVariables) public repayVariables;\n\n    /**\n     * @notice used to maintain the constants related to repayment against a pool\n     */\n    mapping(address => RepaymentConstants) public repayConstants;\n\n    /// @notice determines if the pool is active or not based on whether repayments have been started by the\n    ///borrower for this particular pool or not\n    /// @param _poolID address of the pool for which we want to test statu\n    modifier isPoolInitialized(address _poolID) {\n        require(repayConstants[_poolID].numberOfTotalRepayments != 0, 'Pool is not Initiliazed');\n        _;\n    }\n\n    /// @notice modifier used to determine whether the current pool is valid or not\n    /// @dev poolRegistry from IPoolFactory interface returns a bool\n    modifier onlyValidPool() {\n        require(poolFactory.poolRegistry(msg.sender), 'Repayments::onlyValidPool - Invalid Pool');\n        _;\n    }\n\n    /**\n     * @notice modifier used to check if msg.sender is the owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == poolFactory.owner(), 'Not owner');\n        _;\n    }\n\n    /// @notice Initializes the contract (similar to a constructor)\n    /// @dev Since we cannot use constructors when using OpenZeppelin Upgrades, we use the initialize function\n    ///and the initializer modifier makes sure that this function is called only once\n    /// @param _poolFactory The address of the pool factory\n    /// @param _gracePenaltyRate The penalty rate levied in the grace period\n    /// @param _gracePeriodFraction The fraction of repayment interval that will be allowed as grace period\n    function initialize(\n        address _poolFactory,\n        uint256 _gracePenaltyRate,\n        uint256 _gracePeriodFraction\n    ) external initializer {\n        _updatePoolFactory(_poolFactory);\n        _updateGracePenaltyRate(_gracePenaltyRate);\n        _updateGracePeriodFraction(_gracePeriodFraction);\n    }\n\n    /**\n     * @notice used to update pool factory address\n     * @param _poolFactory address of pool factory contract\n     */\n    function updatePoolFactory(address _poolFactory) external onlyOwner {\n        _updatePoolFactory(_poolFactory);\n    }\n\n    function _updatePoolFactory(address _poolFactory) internal {\n        require(_poolFactory != address(0), '0 address not allowed');\n        poolFactory = IPoolFactory(_poolFactory);\n        emit PoolFactoryUpdated(_poolFactory);\n    }\n\n    /**\n     * @notice used to update grace period as a fraction of repayment interval\n     * @param _gracePeriodFraction updated value of gracePeriodFraction multiplied by 10**30\n     */\n    function updateGracePeriodFraction(uint256 _gracePeriodFraction) external onlyOwner {\n        _updateGracePeriodFraction(_gracePeriodFraction);\n    }\n\n    function _updateGracePeriodFraction(uint256 _gracePeriodFraction) internal {\n        gracePeriodFraction = _gracePeriodFraction;\n        emit GracePeriodFractionUpdated(_gracePeriodFraction);\n    }\n\n    /**\n     * @notice used to update grace penality rate\n     * @param _gracePenaltyRate value of grace penality rate multiplied by 10**30\n     */\n    function updateGracePenaltyRate(uint256 _gracePenaltyRate) external onlyOwner {\n        _updateGracePenaltyRate(_gracePenaltyRate);\n    }\n\n    function _updateGracePenaltyRate(uint256 _gracePenaltyRate) internal {\n        gracePenaltyRate = _gracePenaltyRate;\n        emit GracePenaltyRateUpdated(_gracePenaltyRate);\n    }\n\n    /// @notice For a valid pool, the repayment schedule is being initialized here\n    /// @dev Imported from RepaymentStorage.sol repayConstants is a mapping(address => repayConstants)\n    /// @param numberOfTotalRepayments The total number of repayments that will be required from the borrower\n    /// @param repaymentInterval Intervals after which repayment will be due\n    /// @param borrowRate The rate at which lending took place\n    /// @param loanStartTime The starting time of the loan\n    /// @param lentAsset The address of the asset that was lent (basically a ERC20 token address)\n    function initializeRepayment(\n        uint256 numberOfTotalRepayments,\n        uint256 repaymentInterval,\n        uint256 borrowRate,\n        uint256 loanStartTime,\n        address lentAsset\n    ) external override onlyValidPool {\n        repayConstants[msg.sender].gracePenaltyRate = gracePenaltyRate;\n        repayConstants[msg.sender].gracePeriodFraction = gracePeriodFraction;\n        repayConstants[msg.sender].numberOfTotalRepayments = numberOfTotalRepayments;\n        repayConstants[msg.sender].loanDuration = repaymentInterval.mul(numberOfTotalRepayments).mul(10**30);\n        repayConstants[msg.sender].repaymentInterval = repaymentInterval.mul(10**30);\n        repayConstants[msg.sender].borrowRate = borrowRate;\n        repayConstants[msg.sender].loanStartTime = loanStartTime.mul(10**30);\n        repayConstants[msg.sender].repayAsset = lentAsset;\n    }\n\n    /**\n     * @notice returns the number of repayment intervals that have been repaid,\n     * if repayment interval = 10 secs, loan duration covered = 55 secs, repayment intervals covered = 5\n     * @param _poolID address of the pool\n     * @return scaled interest per second\n     */\n\n    function getInterestPerSecond(address _poolID) public view returns (uint256) {\n        uint256 _activePrincipal = IPool(_poolID).totalSupply();\n        uint256 _interestPerSecond = _activePrincipal.mul(repayConstants[_poolID].borrowRate).div(YEAR_IN_SECONDS);\n        return _interestPerSecond;\n    }\n\n    /// @notice This function determines the number of completed instalments\n    /// @param _poolID The address of the pool for which we want the completed instalments\n    /// @return scaled instalments completed\n    function getInstalmentsCompleted(address _poolID) public view returns (uint256) {\n        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;\n        uint256 _loanDurationCovered = repayVariables[_poolID].loanDurationCovered;\n        uint256 _instalmentsCompleted = _loanDurationCovered.div(_repaymentInterval).mul(10**30); // dividing exponents, returns whole number rounded down\n\n        return _instalmentsCompleted;\n    }\n\n    /// @notice This function determines the interest that is due for the borrower till the current instalment deadline\n    /// @param _poolID The address of the pool for which we want the interest\n    /// @return scaled interest due till instalment deadline\n    function getInterestDueTillInstalmentDeadline(address _poolID) public view returns (uint256) {\n        uint256 _interestPerSecond = getInterestPerSecond(_poolID);\n        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);\n        uint256 _loanDurationCovered = repayVariables[_poolID].loanDurationCovered;\n        uint256 _interestDueTillInstalmentDeadline = (\n            _nextInstalmentDeadline.sub(repayConstants[_poolID].loanStartTime).sub(_loanDurationCovered)\n        ).mul(_interestPerSecond).div(10**30);\n        return _interestDueTillInstalmentDeadline;\n    }\n\n    /// @notice This function determines the timestamp of the next instalment deadline\n    /// @param _poolID The address of the pool for which we want the next instalment deadline\n    /// @return timestamp before which next instalment ends\n    function getNextInstalmentDeadline(address _poolID) public view override returns (uint256) {\n        uint256 _instalmentsCompleted = getInstalmentsCompleted(_poolID);\n        if (_instalmentsCompleted == repayConstants[_poolID].numberOfTotalRepayments.mul(10**30)) {\n            revert('Pool completely repaid');\n        }\n        uint256 _loanExtensionPeriod = repayVariables[_poolID].loanExtensionPeriod;\n        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;\n        uint256 _loanStartTime = repayConstants[_poolID].loanStartTime;\n        uint256 _nextInstalmentDeadline;\n\n        if (_loanExtensionPeriod > _instalmentsCompleted) {\n            _nextInstalmentDeadline = ((_instalmentsCompleted.add(10**30).add(10**30)).mul(_repaymentInterval).div(10**30)).add(\n                _loanStartTime\n            );\n        } else {\n            _nextInstalmentDeadline = ((_instalmentsCompleted.add(10**30)).mul(_repaymentInterval).div(10**30)).add(_loanStartTime);\n        }\n        return _nextInstalmentDeadline;\n    }\n\n    /// @notice This function determine the current instalment interval\n    /// @param _poolID The address of the pool for which we want the current instalment interval\n    /// @return scaled instalment interval\n    function getCurrentInstalmentInterval(address _poolID) public view returns (uint256) {\n        uint256 _instalmentsCompleted = getInstalmentsCompleted(_poolID);\n        return _instalmentsCompleted.add(10**30);\n    }\n\n    /// @notice This function determines the current (loan) interval\n    /// @dev adding 10**30 to add 1. Considering base itself as (10**30)\n    /// @param _poolID The address of the pool for which we want the current loan interval\n    /// @return scaled current loan interval\n    function getCurrentLoanInterval(address _poolID) external view override returns (uint256) {\n        uint256 _loanStartTime = repayConstants[_poolID].loanStartTime;\n        uint256 _currentTime = block.timestamp.mul(10**30);\n        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;\n        uint256 _currentInterval = ((_currentTime.sub(_loanStartTime)).mul(10**30).div(_repaymentInterval)).add(10**30);\n\n        return _currentInterval;\n    }\n\n    /// @notice Check if grace penalty is applicable or not\n    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations\n    /// @param _poolID address of the pool for which we want to inquire if grace penalty is applicable or not\n    /// @return boolean value indicating if applicable or not\n    function isGracePenaltyApplicable(address _poolID) public view returns (bool) {\n        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;\n        uint256 _currentTime = block.timestamp.mul(10**30);\n        uint256 _gracePeriodFraction = repayConstants[_poolID].gracePeriodFraction;\n        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);\n        uint256 _gracePeriodDeadline = _nextInstalmentDeadline.add(_gracePeriodFraction.mul(_repaymentInterval).div(10**30));\n\n        require(_currentTime <= _gracePeriodDeadline, 'Borrower has defaulted');\n\n        if (_currentTime <= _nextInstalmentDeadline) return false;\n        else return true;\n    }\n\n    /// @notice Checks if the borrower has defaulted\n    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations\n    /// @param _poolID address of the pool from which borrower borrowed\n    /// @return bool indicating whether the borrower has defaulted\n    function didBorrowerDefault(address _poolID) external view override returns (bool) {\n        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;\n        uint256 _currentTime = block.timestamp.mul(10**30);\n        uint256 _gracePeriodFraction = repayConstants[_poolID].gracePeriodFraction;\n        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);\n        uint256 _gracePeriodDeadline = _nextInstalmentDeadline.add(_gracePeriodFraction.mul(_repaymentInterval).div(10**30));\n        if (_currentTime > _gracePeriodDeadline) return true;\n        else return false;\n    }\n\n    /// @notice Determines entire interest remaining to be paid for the loan issued to the borrower\n    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations\n    /// @param _poolID address of the pool for which we want to calculate remaining interest\n    /// @return interest remaining\n    function getInterestLeft(address _poolID) public view returns (uint256) {\n        uint256 _interestPerSecond = getInterestPerSecond((_poolID));\n        uint256 _loanDurationLeft = repayConstants[_poolID].loanDuration.sub(repayVariables[_poolID].loanDurationCovered);\n        uint256 _interestLeft = _interestPerSecond.mul(_loanDurationLeft).div(10**30); // multiplying exponents\n\n        return _interestLeft;\n    }\n\n    /// @notice Given there is no loan extension, find the overdue interest after missing the repayment deadline\n    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations\n    /// @param _poolID address of the pool\n    /// @return interest amount that is overdue\n    function getInterestOverdue(address _poolID) public view returns (uint256) {\n        require(repayVariables[_poolID].isLoanExtensionActive, 'No overdue');\n        uint256 _instalmentsCompleted = getInstalmentsCompleted(_poolID);\n        uint256 _interestPerSecond = getInterestPerSecond(_poolID);\n        uint256 _interestOverdue = (\n            (\n                (_instalmentsCompleted.add(10**30)).mul(repayConstants[_poolID].repaymentInterval).div(10**30).sub(\n                    repayVariables[_poolID].loanDurationCovered\n                )\n            )\n        ).mul(_interestPerSecond).div(10**30);\n        return _interestOverdue;\n    }\n\n    /// @notice Used to for your overdues, grace penalty and interest\n    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations\n    /// @param _poolID address of the pool\n    /// @param _amount amount repaid by the borrower\n    function repay(address _poolID, uint256 _amount) external payable nonReentrant isPoolInitialized(_poolID) {\n        address _asset = repayConstants[_poolID].repayAsset;\n        uint256 _amountRepaid = _repay(_poolID, _amount, false);\n\n        _transferTokens(msg.sender, _poolID, _asset, _amountRepaid);\n    }\n\n    function _repayExtension(address _poolID) internal returns (uint256) {\n        if (repayVariables[_poolID].isLoanExtensionActive) {\n            uint256 _interestOverdue = getInterestOverdue(_poolID);\n            repayVariables[_poolID].isLoanExtensionActive = false; // deactivate loan extension flag\n            repayVariables[_poolID].loanDurationCovered = (getInstalmentsCompleted(_poolID).add(10**30))\n                .mul(repayConstants[_poolID].repaymentInterval)\n                .div(10**30);\n            emit ExtensionRepaid(_poolID, _interestOverdue);\n            return _interestOverdue;\n        } else {\n            return 0;\n        }\n    }\n\n    function _repayGracePenalty(address _poolID) internal returns (uint256) {\n        bool _isBorrowerLate = isGracePenaltyApplicable(_poolID);\n\n        if (_isBorrowerLate) {\n            uint256 _penalty = repayConstants[_poolID].gracePenaltyRate.mul(getInterestDueTillInstalmentDeadline(_poolID)).div(10**30);\n            emit GracePenaltyRepaid(_poolID, _penalty);\n            return _penalty;\n        } else {\n            return 0;\n        }\n    }\n\n    function _repayInterest(\n        address _poolID,\n        uint256 _amount,\n        bool _isLastRepayment\n    ) internal returns (uint256) {\n        uint256 _interestLeft = getInterestLeft(_poolID);\n        require((_amount < _interestLeft) != _isLastRepayment, 'Repayments::repay complete interest must be repaid along with principal');\n\n        if (_amount < _interestLeft) {\n            uint256 _interestPerSecond = getInterestPerSecond(_poolID);\n            uint256 _newDurationRepaid = _amount.mul(10**30).div(_interestPerSecond); // dividing exponents\n            repayVariables[_poolID].loanDurationCovered = repayVariables[_poolID].loanDurationCovered.add(_newDurationRepaid);\n            emit InterestRepaid(_poolID, _amount);\n            return _amount;\n        } else {\n            repayVariables[_poolID].loanDurationCovered = repayConstants[_poolID].loanDuration; // full interest repaid\n            emit InterestRepaymentComplete(_poolID, _interestLeft);\n            return _interestLeft;\n        }\n    }\n\n    function _updateRepaidAmount(address _poolID, uint256 _scaledRepaidAmount) internal returns (uint256) {\n        uint256 _toPay = _scaledRepaidAmount.div(10**30);\n        repayVariables[_poolID].repaidAmount = repayVariables[_poolID].repaidAmount.add(_toPay);\n        return _toPay;\n    }\n\n    function _repay(\n        address _poolID,\n        uint256 _amount,\n        bool _isLastRepayment\n    ) internal returns (uint256) {\n        IPool _pool = IPool(_poolID);\n        _amount = _amount * 10**30;\n        uint256 _loanStatus = _pool.getLoanStatus();\n        require(_loanStatus == uint(LoanStatus.ACTIVE) , 'Repayments:repayInterest Pool should be active.');\n\n        uint256 _initialAmount = _amount;\n\n        // pay off grace penality\n        uint256 _gracePenaltyDue = _repayGracePenalty(_poolID);\n        _amount = _amount.sub(_gracePenaltyDue, 'doesnt cover grace penality');\n\n        // pay off the overdue\n        uint256 _interestOverdue = _repayExtension(_poolID);\n        _amount = _amount.sub(_interestOverdue, 'doesnt cover overdue interest');\n\n        // pay interest\n        uint256 _interestRepaid = _repayInterest(_poolID, _amount, _isLastRepayment);\n        _amount = _amount.sub(_interestRepaid);\n\n        return _updateRepaidAmount(_poolID, _initialAmount.sub(_amount));\n    }\n\n    /// @notice Used to pay off the principal of the loan, once the overdues and interests are repaid\n    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations\n    /// @param _poolID address of the pool\n    function repayPrincipal(address payable _poolID) external payable nonReentrant isPoolInitialized(_poolID) {\n        address _asset = repayConstants[_poolID].repayAsset;\n        uint256 _interestToRepay = _repay(_poolID, MAX_INT, true);\n        IPool _pool = IPool(_poolID);\n\n        require(!repayVariables[_poolID].isLoanExtensionActive, 'Repayments:repayPrincipal Repayment overdue unpaid');\n\n        require(\n            repayConstants[_poolID].loanDuration == repayVariables[_poolID].loanDurationCovered,\n            'Repayments:repayPrincipal Unpaid interest'\n        );\n\n        uint256 _amount = _pool.totalSupply();\n        uint256 _amountToPay = _amount.add(_interestToRepay);\n        _transferTokens(msg.sender, _poolID, _asset, _amountToPay);\n        emit PrincipalRepaid(_poolID, _amount);\n\n        IPool(_poolID).closeLoan();\n    }\n\n    /// @notice Returns the total amount that has been repaid by the borrower till now\n    /// @param _poolID address of the pool\n    /// @return total amount repaid\n    function getTotalRepaidAmount(address _poolID) external view override returns (uint256) {\n        return repayVariables[_poolID].repaidAmount;\n    }\n\n    /// @notice This function activates the instalment deadline\n    /// @param _poolID address of the pool for which deadline is extended\n    function instalmentDeadlineExtended(address _poolID) external override {\n        require(msg.sender == poolFactory.extension(), 'Repayments::repaymentExtended - Invalid caller');\n\n        repayVariables[_poolID].isLoanExtensionActive = true;\n        repayVariables[_poolID].loanExtensionPeriod = getCurrentInstalmentInterval(_poolID);\n    }\n\n    /// @notice Returns the loanDurationCovered till now and the interest per second which will help in interest calculation\n    /// @param _poolID address of the pool for which we want to calculate interest\n    /// @return Loan Duration Covered and the interest per second\n    function getInterestCalculationVars(address _poolID) external view override returns (uint256, uint256) {\n        uint256 _interestPerSecond = getInterestPerSecond(_poolID);\n        return (repayVariables[_poolID].loanDurationCovered, _interestPerSecond);\n    }\n\n    /// @notice Returns the fraction of repayment interval decided as the grace period fraction\n    /// @return grace period fraction\n    function getGracePeriodFraction() external view override returns (uint256) {\n        return gracePeriodFraction;\n    }\n\n    function _transferTokens(\n        address _from,\n        address _to,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        if (_asset == address(0)) {\n            (bool transferSuccess, ) = _to.call{value: _amount}('');\n            require(transferSuccess, '_transferTokens: Transfer failed');\n            if (msg.value != _amount) {\n                (bool refundSuccess, ) = payable(_from).call{value: msg.value.sub(_amount)}('');\n                require(refundSuccess, '_transferTokens: Refund failed');\n            }\n        } else {\n            IERC20(_asset).safeTransferFrom(_from, _to, _amount);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IYield.sol';\nimport '../interfaces/Invest/IWETHGateway.sol';\nimport '../interfaces/Invest/AaveLendingPool.sol';\nimport '../interfaces/Invest/IScaledBalanceToken.sol';\nimport '../interfaces/Invest/IProtocolDataProvider.sol';\n\n/**\n * @title Yield contract\n * @notice Implements the functions to lock/unlock tokens into Aave protocol\n * @author Sublime\n **/\ncontract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice address of wethGateway used to deposit ETH to aave\n     */\n    address public wethGateway;\n\n    /**\n     * @notice address of protocolDataProvider which provides info about aTokens related to any token\n     */\n    address public protocolDataProvider;\n\n    /**\n     * @notice address of lendingPoolAddressesProvider used to get the pool related to any token\n     */\n    address public lendingPoolAddressesProvider;\n\n    /**\n     * @notice address of savings account contract\n     */\n    address payable public savingsAccount;\n\n    /**\n     * @notice aave referral code to represent sublime\n     */\n    uint16 public referralCode;\n\n    /**\n     * @notice emitted when aave protocol related addresses are updated\n     * @param wethGateway address of wethGateway\n     * @param protocolDataProvider address of protocol data provider\n     * @param lendingPoolAddressesProvider address of lending pool addresses provider\n     */\n    event AaveAddressesUpdated(\n        address indexed wethGateway,\n        address indexed protocolDataProvider,\n        address indexed lendingPoolAddressesProvider\n    );\n\n    /**\n     * @notice emitted when aave referral code is updated\n     * @param referralCode updated referral code\n     */\n    event ReferralCodeUpdated(uint16 referralCode);\n\n    /**\n     * @notice verifies if savings account invoked the contract\n     */\n    modifier onlySavingsAccount() {\n        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');\n        _;\n    }\n\n    /**\n     * @notice To initialize the contract addresses interacting with this contract\n     * @dev can only be initialized once\n     * @param _owner address of owner\n     * @param _savingsAccount address of the savings account contract\n     * @param _wethGateway address of wethGateway\n     * @param _protocolDataProvider the address of ProtocolDataProvider\n     * @param _lendingPoolAddressesProvider the address of LendingPoolAddressesProvider\n     **/\n    function initialize(\n        address _owner,\n        address payable _savingsAccount,\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateSavingsAccount(_savingsAccount);\n        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    /**\n     * @notice Used to get liquidity token address from asset address\n     * @param asset the address of underlying token\n     * @return aToken address of liquidity token\n     **/\n    function liquidityToken(address asset) public view override returns (address aToken) {\n        if (asset == address(0)) {\n            aToken = IWETHGateway(wethGateway).getAWETHAddress();\n        } else {\n            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);\n        }\n    }\n\n    /**\n     * @notice used to update savings account address\n     * @dev only owner can update\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address payable _savingsAccount) internal {\n        require(_savingsAccount != address(0), 'Invest: zero address');\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update aave protocol related addresses\n     * @dev only owner can update\n     * @param _wethGateway address of wethGateway\n     * @param _protocolDataProvider address of protocol data provider\n     * @param _lendingPoolAddressesProvider address of lending pool addresses provider\n     */\n    function updateAaveAddresses(\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) external onlyOwner {\n        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    function _updateAaveAddresses(\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) internal {\n        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');\n        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');\n        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');\n        wethGateway = _wethGateway;\n        protocolDataProvider = _protocolDataProvider;\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    /**\n     * @notice used to update referral code\n     * @dev only owner can update\n     * @param _referralCode updated referral code\n     */\n    function updateReferralCode(uint16 _referralCode) external onlyOwner {\n        referralCode = _referralCode;\n        emit ReferralCodeUpdated(_referralCode);\n    }\n\n    /**\n     * @notice used to withdraw all tokens of a type in case of emergencies\n     * @dev only owner can withdraw\n     * @param _asset address of the token being withdrawn\n     * @param _wallet address to which tokens are withdrawn\n     */\n    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n        require(_wallet != address(0), 'cant burn');\n        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));\n\n        if (_asset == address(0)) {\n            received = _withdrawETH(amount);\n            (bool success, ) = _wallet.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            received = _withdrawERC(_asset, amount);\n            IERC20(_asset).safeTransfer(_wallet, received);\n        }\n    }\n\n    /**\n     * @notice Used to lock tokens in protocol\n     * @dev Asset Tokens to be locked must be approved to this contract by user\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n        require(amount != 0, 'Invest: amount');\n\n        address investedTo;\n        if (asset == address(0)) {\n            require(msg.value == amount, 'Invest: ETH amount');\n            (investedTo, sharesReceived) = _depositETH(amount);\n        } else {\n            IERC20(asset).safeTransferFrom(user, address(this), amount);\n            (investedTo, sharesReceived) = _depositERC20(asset, amount);\n        }\n\n        emit LockedTokens(user, investedTo, sharesReceived);\n    }\n\n    /**\n     * @notice Used to unlock tokens from available protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of asset\n     * @return received amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {\n        require(amount != 0, 'Invest: amount');\n\n        if (asset == address(0)) {\n            received = _withdrawETH(amount);\n            (bool success, ) = savingsAccount.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            received = _withdrawERC(asset, amount);\n            IERC20(asset).safeTransfer(savingsAccount, received);\n        }\n\n        emit UnlockedTokens(asset, received);\n    }\n\n    /**\n     * @notice Used to unlock shares\n     * @param asset the address of underlying token\n     * @param amount the amount of shares to unlock\n     * @return received amount of shares received\n     **/\n    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n\n        require(asset != address(0), 'Asset address cannot be address(0)');\n        IERC20(asset).safeTransfer(savingsAccount, amount);\n\n        emit UnlockedShares(asset, amount);\n        return amount;\n    }\n\n    /**\n     * @notice Used to get amount of underlying tokens for current number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n        if (shares == 0) return 0;\n        address aToken = liquidityToken(asset);\n\n        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);\n\n        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(\n            IERC20(aToken).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Used to get number of shares from an amount of underlying tokens\n     * @param amount the amount of tokens\n     * @param asset the address of token\n     * @return shares amount of shares for given tokens\n     **/\n    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {\n        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));\n    }\n\n    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {\n        aToken = IWETHGateway(wethGateway).getAWETHAddress();\n\n        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        //lock collateral\n        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);\n\n        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);\n    }\n\n    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {\n        aToken = liquidityToken(asset);\n        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        //approve collateral to vault\n        IERC20(asset).approve(lendingPool, 0);\n        IERC20(asset).approve(lendingPool, amount);\n\n        //lock collateral in vault\n        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);\n\n        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);\n    }\n\n    function _withdrawETH(uint256 amount) internal returns (uint256 received) {\n        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);\n\n        uint256 ethBalance = address(this).balance;\n\n        //lock collateral\n        IWETHGateway(wethGateway).withdrawETH(amount, address(this));\n\n        received = address(this).balance.sub(ethBalance);\n    }\n\n    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {\n        address aToken = liquidityToken(asset);\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));\n\n        IERC20(aToken).approve(lendingPool, amount);\n\n        //withdraw collateral from vault\n        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));\n\n        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "PriceOracle.sol",
            "CreditLine.sol",
            "Repayments.sol",
            "AaveYield.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-11",
                "Location": [
                    "//solidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    uint256 amount = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n    received = amount;\n}\n"
                ],
                "Type": " Unable To Call  emergencyWithdraw  ETH in  NoYield  Contract",
                "Description": "\n\nThe emergencyWithdraw function is implemented in all yield sources to allow the onlyOwner role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on _asset which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the NoYield contract in the event of an emergency.\n\n\nConsider the case where _asset == address(0). An external call is made to check the contract's token balance for the target _asset. However, this call will revert as _asset is the zero address. As a result, the onlyOwner role will never be able to withdraw ETH tokens during an emergency.\nsolidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    uint256 amount = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n    received = amount;\n}\n\nAffected function as per below:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/NoYield.sol#L78-L83\n\n",
                "Repair": "\nConsider handling the case where _asset is the zero address, i.e. the asset to be withdrawn under emergency is the ETH token.\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/52)\n0xean (judge) commented(https://github.com/code-423n4/2021-12-sublime-findings/issues/52#issuecomment-1018680972):\n  Upgrading to Sev 3 in line with #4  / #115 as this results in funds being stuck in the contract. \n\n\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IStrategyRegistry.sol';\n\n/**\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n **/\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     **/\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /**\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId => Strategy => collateralShares\n     **/\n    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;\n\n    /**\n     * @notice stores the variables to maintain a credit line\n     **/\n    mapping(uint256 => CreditLineVariables) public creditLineVariables;\n\n    /**\n     * @notice stores the constants related to a credit line\n     **/\n    mapping(uint256 => CreditLineConstants) public creditLineConstants;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address public savingsAccount;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    address public priceOracle;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    address public strategyRegistry;\n\n    /**\n     * @notice stores the address of default strategy\n     **/\n    address public defaultStrategy;\n\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    /**\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public liquidatorRewardFraction;\n    /**\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     **/\n    modifier ifCreditLineExists(uint256 _id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineLender(uint256 _id) {\n        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');\n        _;\n    }\n\n    /**\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /**\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     */\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /**\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /**\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /**\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     */\n    event CreditLineAccepted(uint256 indexed id);\n\n    /**\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /**\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /**\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     */\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /**\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /**\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /**\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /**\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), 'cant be 0 address');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'CL::I zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /**\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /**\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(\n            10**_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible > _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible > _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');\n    }\n\n    /**\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /**\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),\n            \"Only Borrower or Lender who hasn't requested can accept\"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /**\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, \"CreditLine::_depositCollateral - value to transfer doesn't match argument\");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, 'insufficient balance');\n    }\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\n            require(feeSuccess, 'Transfer fail');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\n            require(success, 'Transfer fail');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /**\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount >= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount > _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /**\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     */\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            'CreditLine: Permission denied while closing Line of credit'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 10**30 to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(\n            10**_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10**_decimals)\n            .div(10**30);\n\n        if (_collateralNeeded >= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert('insufficient collateral');\n    }\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,\n            'CreditLine: Collateral ratio is higher than ideal value'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}('');\n                    require(success, 'Transfer fail');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /**\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '../Proxy.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IVerification.sol';\nimport '../interfaces/IStrategyRegistry.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\n\n/**\n * @title Pool Factory contract with methods for handling different pools\n * @notice Implements the functions related to Pool (CRUD)\n * @author Sublime\n */\ncontract PoolFactory is Initializable, OwnableUpgradeable, IPoolFactory {\n    /*\n     * @notice Used to define limits for the Pool parameters\n     * @param min the minimum threshold for the parameter\n     * @param max the maximum threshold for the parameter\n     */\n    struct Limits {\n        uint256 min;\n        uint256 max;\n    }\n\n    /**\n     * @notice function definition of the pool contract\n     */\n    bytes4 public poolInitFuncSelector; //  bytes4(keccak256(\"initialize(uint256,address,address,address,uint256,uint256,uint256,uint256,bool)\"))\n\n    /**\n     * @notice address of the latest implementation of the pool logic\n     */\n    address public poolImpl;\n\n    /**\n     * @notice address of the contract storing the user registry\n     */\n    address public override userRegistry;\n\n    /**\n     * @notice address of the contract storing the strategy registry\n     */\n    address public strategyRegistry;\n\n    /**\n     * @notice address of the latest implementation of the extension logic\n     */\n    address public override extension;\n\n    /**\n     * @notice address of the latest implementation of the repayment logic\n     */\n    address public override repaymentImpl;\n\n    /**\n     * @notice address of the latest implementation of the pool logic\n     */\n    address public override priceOracle;\n\n    /**\n     * @notice address of the savings account used\n     */\n    address public override savingsAccount;\n\n    /**\n     * @notice the time interval for the lenders to make contributions to pool\n     */\n    uint256 public override collectionPeriod;\n\n    /**\n     * @notice the time interval for the borrower to withdraw the loan from pool\n     */\n    uint256 public override loanWithdrawalDuration;\n\n    /**\n     * @notice the time interval for the active stage of the margin call\n     */\n    uint256 public override marginCallDuration;\n\n    /**\n     * @notice Fraction of the requested amount for pool below which pool is cancelled\n     */\n    uint256 public override minBorrowFraction;\n\n    /**\n     * @notice the fraction used for calculating the liquidator reward\n     */\n    uint256 public override liquidatorRewardFraction;\n\n    /**\n     * @notice the fraction used for calculating the penalty when the pool is cancelled\n     */\n    uint256 public override poolCancelPenaltyMultiple;\n\n    /**\n     * @notice Contract Address of no yield\n     */\n    address public override noStrategyAddress;\n\n    uint256 protocolFeeFraction;\n    address protocolFeeCollector;\n\n    /*\n     * @notice Used to mark assets supported for borrowing\n     */\n    mapping(address => bool) isBorrowToken;\n\n    /*\n     * @notice Used to mark supported collateral assets\n     */\n    mapping(address => bool) isCollateralToken;\n\n    /**\n     * @notice Used to keep track of valid pool addresses\n     */\n    mapping(address => bool) public override poolRegistry;\n\n    /*\n     * @notice Used to set the min/max borrow amount for Pools\n     */\n    Limits poolSizeLimit;\n\n    /*\n     * @notice Used to set the min/max collateral ratio for Pools\n     */\n    Limits idealCollateralRatioLimit;\n\n    /*\n     * @notice Used to set the min/max borrow rates (interest rate provided by borrower) for Pools\n     */\n    Limits borrowRateLimit;\n\n    /*\n     * @notice used to set the min/max repayment interval for Pools\n     */\n    Limits repaymentIntervalLimit;\n\n    /*\n     * @notice used to set the min/max number of repayment intervals for Pools\n     */\n    Limits noOfRepaymentIntervalsLimit;\n\n    /**\n     * @notice functions affected by this modifier can only be invoked by the Pool\n     */\n    modifier onlyPool() {\n        require(poolRegistry[msg.sender], 'PoolFactory::onlyPool - Only pool can destroy itself');\n        _;\n    }\n\n    /**\n     * @notice functions affected by this modifier can only be invoked by the borrow of the Pool\n     */\n    modifier onlyBorrower(address _verifier) {\n        require(\n            IVerification(userRegistry).isUser(msg.sender, _verifier),\n            'PoolFactory::onlyBorrower - Only a valid Borrower can create Pool'\n        );\n        _;\n    }\n\n    /**\n     * @notice returns the owner of the pool\n     */\n    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {\n        return OwnableUpgradeable.owner();\n    }\n\n    /**\n     * @notice used to initialize the pool factory\n     * @dev initializer can only be run once\n     * @param _admin address of admin\n     * @param _collectionPeriod period for which lenders can lend for pool\n     * @param _loanWithdrawalDuration period for which lent tokens can be withdrawn after pool starts\n     * @param _marginCallDuration duration of margin call before which collateral ratio has to be maintained\n     * @param _poolInitFuncSelector function signature for initializing pool\n     * @param _liquidatorRewardFraction fraction of liquidation amount which is given to liquidator as reward multiplied by 10**30\n     * @param _poolCancelPenaltyMultiple multiple of borrow rate of pool as penality for cancellation of pool multiplied by 10**30\n     * @param _minBorrowFraction amountCollected/amountRequested for a pool, if less than fraction by pool start time then pool can be cancelled without penality multiplied by 10**30\n     * @param _protocolFeeFraction fraction of amount borrowed in pool which is collected as protocol fee\n     * @param _protocolFeeCollector address where protocol fee is collected\n     * @param _noStrategy address of the no strategy address\n     */\n    function initialize(\n        address _admin,\n        uint256 _collectionPeriod,\n        uint256 _loanWithdrawalDuration,\n        uint256 _marginCallDuration,\n        bytes4 _poolInitFuncSelector,\n        uint256 _liquidatorRewardFraction,\n        uint256 _poolCancelPenaltyMultiple,\n        uint256 _minBorrowFraction,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        address _noStrategy\n    ) external initializer {\n        {\n            OwnableUpgradeable.__Ownable_init();\n            OwnableUpgradeable.transferOwnership(_admin);\n        }\n        _updateCollectionPeriod(_collectionPeriod);\n        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);\n        _updateMarginCallDuration(_marginCallDuration);\n        _updatepoolInitFuncSelector(_poolInitFuncSelector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);\n        _updateMinBorrowFraction(_minBorrowFraction);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateNoStrategy(_noStrategy);\n    }\n\n    /**\n     * @notice used to setImplementation addresses\n     * @dev used to set some of the contracts pool factory interacts with. only admin can invoke\n     * @param _poolImpl address of the implementation address of pool\n     * @param _repaymentImpl address of the implementation address of repayments\n     * @param _userRegistry address of the user registry where users are verified\n     * @param _strategyRegistry address of the startegy registry where strategies are whitelisted\n     * @param _priceOracle address of the price oracle\n     * @param _savingsAccount address of the savings account contract\n     * @param _extension address of the extension contract for pools\n     */\n    function setImplementations(\n        address _poolImpl,\n        address _repaymentImpl,\n        address _userRegistry,\n        address _strategyRegistry,\n        address _priceOracle,\n        address _savingsAccount,\n        address _extension\n    ) external onlyOwner {\n        _updatePoolLogic(_poolImpl);\n        _updateRepaymentImpl(_repaymentImpl);\n        _updateSavingsAccount(_savingsAccount);\n        _updatedExtension(_extension);\n        _updateUserRegistry(_userRegistry);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updatePriceoracle(_priceOracle);\n    }\n\n    /**\n     * @notice invoked when a new borrow pool is created. deploys a new pool for every borrow request\n     * @param _poolSize loan amount requested\n     * @param _borrowToken borrow asset requested\n     * @param _collateralToken collateral asset requested\n     * @param _idealCollateralRatio ideal pool collateral ratio set by the borrower\n     * @param _borrowRate interest rate provided by the borrower\n     * @param _repaymentInterval interval between the last dates of two repayment cycles\n     * @param _noOfRepaymentIntervals number of repayments to be made during the duration of the loan\n     * @param _poolSavingsStrategy savings strategy selected for the pool collateral\n     * @param _collateralAmount collateral amount deposited\n     * @param _transferFromSavingsAccount if true, initial collateral is transferred from borrower's savings account, if false, borrower transfers initial collateral deposit from wallet\n     * @param _salt random and unique initial seed\n     */\n    function createPool(\n        uint256 _poolSize,\n        uint256 _borrowRate,\n        address _borrowToken,\n        address _collateralToken,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        bytes32 _salt,\n        address _verifier,\n        address _lenderVerifier\n    ) external payable onlyBorrower(_verifier) {\n        if (_collateralToken == address(0)) {\n            require(msg.value == _collateralAmount, 'PoolFactory::createPool - Ether send is different from collateral amount specified');\n        }\n        require(_borrowToken != _collateralToken, 'PoolFactory::createPool - cant borrow the asset put in as collateralToken');\n        require(isBorrowToken[_borrowToken], 'PoolFactory::createPool - Invalid borrow token type');\n        require(isCollateralToken[_collateralToken], 'PoolFactory::createPool - Invalid collateral token type');\n        require(\n            IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken),\n            \"PoolFactory::createPool - Price feed doesn't support token pair\"\n        );\n        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy), 'PoolFactory::createPool - Invalid strategy');\n        require(isWithinLimits(_poolSize, poolSizeLimit.min, poolSizeLimit.max), 'PoolFactory::createPool - PoolSize not within limits');\n        require(\n            isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max),\n            'PoolFactory::createPool - Collateral Ratio not within limits'\n        );\n        require(\n            isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max),\n            'PoolFactory::createPool - Borrow rate not within limits'\n        );\n        require(\n            isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max),\n            'PoolFactory::createPool - Loan duration not within limits'\n        );\n        require(\n            isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max),\n            'PoolFactory::createPool - Repayment interval not within limits'\n        );\n        _createPool(\n            _poolSize,\n            _borrowRate,\n            _borrowToken,\n            _collateralToken,\n            _idealCollateralRatio,\n            _repaymentInterval,\n            _noOfRepaymentIntervals,\n            _poolSavingsStrategy,\n            _collateralAmount,\n            _transferFromSavingsAccount,\n            _salt,\n            _lenderVerifier\n        );\n    }\n\n    // @dev These functions are used to avoid stack too deep\n    function _createPool(\n        uint256 _poolSize,\n        uint256 _borrowRate,\n        address _borrowToken,\n        address _collateralToken,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        bytes32 _salt,\n        address _lenderVerifier\n    ) internal {\n        bytes memory data = _encodePoolInitCall(\n            _poolSize,\n            _borrowRate,\n            _borrowToken,\n            _collateralToken,\n            _idealCollateralRatio,\n            _repaymentInterval,\n            _noOfRepaymentIntervals,\n            _poolSavingsStrategy,\n            _collateralAmount,\n            _transferFromSavingsAccount,\n            _lenderVerifier\n        );\n        bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));\n        bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));\n        uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;\n\n        address pool = _deploy(amount, salt, bytecode);\n\n        poolRegistry[pool] = true;\n        emit PoolCreated(pool, msg.sender);\n    }\n\n    // @dev These functions are used to avoid stack too deep\n    function _encodePoolInitCall(\n        uint256 _poolSize,\n        uint256 _borrowRate,\n        address _borrowToken,\n        address _collateralToken,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier\n    ) internal view returns (bytes memory data) {\n        data = abi.encodeWithSelector(\n            poolInitFuncSelector,\n            _poolSize,\n            _borrowRate,\n            msg.sender,\n            _borrowToken,\n            _collateralToken,\n            _idealCollateralRatio,\n            _repaymentInterval,\n            _noOfRepaymentIntervals,\n            _poolSavingsStrategy,\n            _collateralAmount,\n            _transferFromSavingsAccount,\n            _lenderVerifier,\n            loanWithdrawalDuration,\n            collectionPeriod\n        );\n    }\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function _deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(bytecode.length != 0, 'Create2: bytecode length is zero');\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), 'Create2: Failed on deploy');\n    }\n\n    /**\n     * @notice invoked to check if pool parameters are within thresholds\n     * @param _value supplied value of the parameter\n     * @param _min minimum threshold of the parameter\n     * @param _max maximum threshold of the parameter\n     */\n    function isWithinLimits(\n        uint256 _value,\n        uint256 _min,\n        uint256 _max\n    ) internal pure returns (bool) {\n        if (_min != 0 && _max != 0) {\n            return (_value >= _min && _value <= _max);\n        } else if (_min != 0) {\n            return (_value >= _min);\n        } else if (_max != 0) {\n            return (_value <= _max);\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @notice used to update the list of supported borrow tokens\n     * @param _borrowToken address of the borrow asset\n     * @param _isSupported true if _borrowToken is a valid borrow asset, false if _borrowToken is an invalid borrow asset\n     */\n    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {\n        _updateSupportedBorrowTokens(_borrowToken, _isSupported);\n    }\n\n    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) internal {\n        isBorrowToken[_borrowToken] = _isSupported;\n        emit BorrowTokenUpdated(_borrowToken, _isSupported);\n    }\n\n    /**\n     * @notice used to update the list of supported Collateral tokens\n     * @param _collateralToken address of the Collateral asset\n     * @param _isSupported true if _collateralToken is a valid Collateral asset, false if _collateralToken is an invalid Collateral asset\n     */\n    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {\n        _updateSupportedCollateralTokens(_collateralToken, _isSupported);\n    }\n\n    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) internal {\n        isCollateralToken[_collateralToken] = _isSupported;\n        emit CollateralTokenUpdated(_collateralToken, _isSupported);\n    }\n\n    /**\n     * @notice used to update the pointer to Initializer function of the proxy pool contract\n     * @param _functionId updated function definition of the proxy pool contract\n     */\n    function updatepoolInitFuncSelector(bytes4 _functionId) external onlyOwner {\n        _updatepoolInitFuncSelector(_functionId);\n    }\n\n    function _updatepoolInitFuncSelector(bytes4 _functionId) internal {\n        poolInitFuncSelector = _functionId;\n        emit PoolInitSelectorUpdated(_functionId);\n    }\n\n    /**\n     * @notice used to update the Pool.sol logic\n     * @param _poolLogic the address of the new Pool logic contract\n     */\n    function updatePoolLogic(address _poolLogic) external onlyOwner {\n        _updatePoolLogic(_poolLogic);\n    }\n\n    function _updatePoolLogic(address _poolLogic) internal {\n        poolImpl = _poolLogic;\n        emit PoolLogicUpdated(_poolLogic);\n    }\n\n    /**\n     * @notice used to update the user registry\n     * @param _userRegistry address of the contract storing the user registry\n     */\n    function updateUserRegistry(address _userRegistry) external onlyOwner {\n        _updateUserRegistry(_userRegistry);\n    }\n\n    function _updateUserRegistry(address _userRegistry) internal {\n        userRegistry = _userRegistry;\n        emit UserRegistryUpdated(_userRegistry);\n    }\n\n    /**\n     * @notice used to update the strategy registry\n     * @param _strategyRegistry address of the contract storing the strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the implementation of the repayment logic\n     * @param _repaymentImpl address of the updated repayment.sol contract\n     */\n    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {\n        _updateRepaymentImpl(_repaymentImpl);\n    }\n\n    function _updateRepaymentImpl(address _repaymentImpl) internal {\n        repaymentImpl = _repaymentImpl;\n        emit RepaymentImplUpdated(_repaymentImpl);\n    }\n\n    /**\n     * @notice used to update contract address of nostrategy contract\n     * @param _noStrategy address of the updated noYield.sol contract\n     */\n    function updateNoStrategy(address _noStrategy) external onlyOwner {\n        _updateNoStrategy(_noStrategy);\n    }\n\n    function _updateNoStrategy(address _noStrategy) internal {\n        noStrategyAddress = _noStrategy;\n        emit NoStrategyUpdated(_noStrategy);\n    }\n\n    /**\n     * @notice used to update the implementation of the price oracle logic\n     * @param _priceOracle address of the updated price oracle contract\n     */\n    function updatePriceoracle(address _priceOracle) external onlyOwner {\n        _updatePriceoracle(_priceOracle);\n    }\n\n    function _updatePriceoracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the extensions contract\n     * @param _extension address of the updated extensions contract\n     */\n    function updatedExtension(address _extension) external onlyOwner {\n        _updatedExtension(_extension);\n    }\n\n    function _updatedExtension(address _extension) internal {\n        extension = _extension;\n        emit ExtensionImplUpdated(_extension);\n    }\n\n    /**\n     * @notice used to update the savings account contract\n     * @param _savingsAccount address of the updated savings account contract\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the collection period of the Pool\n     * @param _collectionPeriod updated value of the collection period\n     */\n    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {\n        _updateCollectionPeriod(_collectionPeriod);\n    }\n\n    function _updateCollectionPeriod(uint256 _collectionPeriod) internal {\n        collectionPeriod = _collectionPeriod;\n        emit CollectionPeriodUpdated(_collectionPeriod);\n    }\n\n    /**\n     * @notice used to update the loan withdrawal duration by owner\n     * @param _loanWithdrawalDuration updated value of loanWithdrawalDuration\n     */\n    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {\n        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);\n    }\n\n    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) internal {\n        loanWithdrawalDuration = _loanWithdrawalDuration;\n        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);\n    }\n\n    /**\n     * @notice used to update the active stage of the margin call of the Pool\n     * @param _marginCallDuration updated value of the margin call duration\n     */\n    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {\n        _updateMarginCallDuration(_marginCallDuration);\n    }\n\n    function _updateMarginCallDuration(uint256 _marginCallDuration) internal {\n        marginCallDuration = _marginCallDuration;\n        emit MarginCallDurationUpdated(_marginCallDuration);\n    }\n\n    /**\n     * @notice used to update the min borrow fraction by owner\n     * @param _minBorrowFraction updated value of min borrow fraction multiplied by 10**30\n     */\n    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {\n        _updateMinBorrowFraction(_minBorrowFraction);\n    }\n\n    function _updateMinBorrowFraction(uint256 _minBorrowFraction) internal {\n        minBorrowFraction = _minBorrowFraction;\n        emit MinBorrowFractionUpdated(_minBorrowFraction);\n    }\n\n    /**\n     * @notice used to update the reward fraction for liquidation of the Pool\n     * @param _liquidatorRewardFraction updated value of the reward fraction for liquidation multiplied by 10**30\n     */\n    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) internal {\n        liquidatorRewardFraction = _liquidatorRewardFraction;\n        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the pool cancel penalty multiple\n     * @param _poolCancelPenaltyMultiple updated value of the pool cancel penalty multiple multiplied by 10**30\n     */\n    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {\n        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);\n    }\n\n    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) internal {\n        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;\n        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);\n    }\n\n    /**\n     * @notice used to update the fraction of borrowed amount charged as protocol fee\n     * @param _protocolFee updated value of protocol fee fraction multiplied by 10**30\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the address in which protocol fee is collected\n     * @param _protocolFeeCollector updated address of protocol fee collector\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the thresholds of the pool size of the Pool\n     * @param _min updated value of the minimum threshold value of the pool size\n     * @param _max updated value of the maximum threshold value of the pool size\n     */\n    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {\n        poolSizeLimit = Limits(_min, _max);\n        emit LimitsUpdated('PoolSize', _min, _max);\n    }\n\n    /**\n     * @notice used to update the thresholds of the collateral ratio of the Pool\n     * @param _min updated value of the minimum threshold value of the collateral ratio\n     * @param _max updated value of the maximum threshold value of the collateral ratio\n     */\n    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {\n        idealCollateralRatioLimit = Limits(_min, _max);\n        emit LimitsUpdated('CollateralRatio', _min, _max);\n    }\n\n    /**\n     * @notice used to update the thresholds of the borrow rate of the Pool\n     * @param _min updated value of the minimum threshold value of the borrow rate\n     * @param _max updated value of the maximum threshold value of the borrow rate\n     */\n    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {\n        borrowRateLimit = Limits(_min, _max);\n        emit LimitsUpdated('BorrowRate', _min, _max);\n    }\n\n    /**\n     * @notice used to update the thresholds of the repayment interval of the Pool\n     * @param _min updated value of the minimum threshold value of the repayment interval\n     * @param _max updated value of the maximum threshold value of the repayment interval\n     */\n    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {\n        repaymentIntervalLimit = Limits(_min, _max);\n        emit LimitsUpdated('RepaymentInterval', _min, _max);\n    }\n\n    /**\n     * @notice used to update the thresholds of the number of repayment intervals of the Pool\n     * @param _min updated value of the minimum threshold value of the number of repayment intervals\n     * @param _max updated value of the maximum threshold value of the number of repayment intervals\n     */\n    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {\n        noOfRepaymentIntervalsLimit = Limits(_min, _max);\n        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);\n    }\n\n    /**\n     * @notice used to query protocol fee fraction and address of the collector\n     * @return protocolFee Fraction multiplied by 10**30\n     * @return address of protocol fee collector\n     */\n    function getProtocolFeeData() external view override returns (uint256, address) {\n        return (protocolFeeFraction, protocolFeeCollector);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IExtension.sol';\nimport '../interfaces/IVerification.sol';\n\n/**\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n\n    address poolFactory;\n\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n\n    /**\n     * @notice used to keep track of lenders' details\n     */\n    mapping(address => LendingDetails) public lenders;\n\n    /**\n     * @notice object of type PoolConstants\n     */\n    PoolConstants public poolConstants;\n\n    /**\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n\n    /**\n     * @notice checks if the _user is pool's valid borrower\n     * @param _user address of the borrower\n     */\n    modifier onlyBorrower(address _user) {\n        require(_user == poolConstants.borrower, 'OB1');\n        _;\n    }\n\n    /**\n     * @notice checks if the _lender is pool's valid lender\n     * @param _lender address of the lender\n     */\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, 'IL1');\n        _;\n    }\n\n    /**\n     * @notice checks if the msg.sender is pool's valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');\n        _;\n    }\n\n    /**\n     * @notice checks if the msg.sender is pool's latest repayment implementation\n     */\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');\n        _;\n    }\n\n    /**\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     */\n    function initialize(\n        uint256 _borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init('Pool Tokens', 'PT');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n\n    /**\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, 'DC1');\n        require(balanceOf(msg.sender) == 0, 'DC2');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n\n    /**\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n\n    /**\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     */\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n\n    /**\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n\n    /**\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet\n     */\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');\n        require(balanceOf(msg.sender) == 0, 'ACMC2');\n        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');\n\n        require(_amount != 0, 'ACMC4');\n\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n\n        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n\n    /**\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     */\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &&\n                poolConstants.loanStartTime < block.timestamp &&\n                block.timestamp < poolConstants.loanWithdrawalDeadline,\n            'WBA1'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');\n\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');\n\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);\n        delete poolConstants.loanWithdrawalDeadline;\n\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n\n    /**\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n\n    /**\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     */\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower && _borrower != msg.sender, 'L1');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n\n    /**\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), 'TT1');\n        }\n        require(_to != poolConstants.borrower, 'TT2');\n\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');\n        }\n        require(getMarginCallEndTime(_from) == 0, 'TT3');\n        require(getMarginCallEndTime(_to) == 0, 'TT4');\n\n        //Withdraw repayments for user\n\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp > _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp > _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n\n    /**\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n\n        if (\n            _loanStartTime < block.timestamp &&\n            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)\n        ) {\n            return _cancelPool(0);\n        }\n\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n\n        if (_loanWithdrawalDeadline > block.timestamp) {\n            require(msg.sender == poolConstants.borrower, 'CP2');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(10**30)\n            .mul(_collateralLiquidityShare)\n            .div(10**30)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n\n    /**\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n\n    /**\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     */\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');\n        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n\n    /**\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     */\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n\n    /**\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');\n\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n\n        emit PoolClosed();\n    }\n\n    /**\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     */\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            'WL1'\n        );\n\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n\n    /**\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     */\n\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');\n        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');\n\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n\n        emit MarginCalled(msg.sender);\n    }\n\n    /**\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(10**30);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));\n        if (_loanDurationTillNow <= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);\n\n        return _interestAccrued;\n    }\n\n    /**\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));\n    }\n\n    /**\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n\n    /**\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     */\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n\n    /**\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     */\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        uint256 _collateralTokens = _collateralLiquidityShare;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);\n\n        uint256 _poolBorrowTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        delete poolVariables.extraLiquidityShares;\n        delete poolVariables.baseLiquidityShares;\n\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));\n        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);\n        emit PoolLiquidated(msg.sender);\n    }\n\n    /**\n     * @notice internal function used to withdraw tokens\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     * @param _asset address of the asset to be withdrawn\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _amountInTokens amount of tokens to be withdrawn from the pool\n     * @return amount of equivalent shares from given asset\n     */\n    function _withdraw(\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare,\n        address _asset,\n        address _poolSavingsStrategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n        return\n            SavingsAccountUtil.depositFromSavingsAccount(\n                _savingsAccount,\n                address(this),\n                msg.sender,\n                _amountInTokens,\n                _asset,\n                _poolSavingsStrategy,\n                _recieveLiquidityShare,\n                _toSavingsAccount\n            );\n    }\n\n    /**\n     * @notice used to ensure if a lender can be liquidated\n     * @param _lender address of the lender to be liquidated\n     */\n    function _canLenderBeLiquidated(address _lender) internal {\n        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');\n        require(_marginCallEndTime < block.timestamp, 'CLBL3');\n\n        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');\n        require(balanceOf(_lender) != 0, 'CLBL5');\n    }\n\n    /**\n     * @notice used to add extra liquidity shares to lender's share\n     * @param _lender address of the lender to be liquidated\n     * @return _lenderCollateralLPShare share of the lender in collateral tokens\n     * @return _lenderBalance balance of lender in pool tokens\n     */\n    function _updateLenderSharesDuringLiquidation(address _lender)\n        internal\n        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)\n    {\n        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;\n        _lenderBalance = balanceOf(_lender);\n\n        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());\n        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;\n        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);\n\n        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);\n    }\n\n    /**\n     * @notice internal function to liquidate lender of the borrow pool\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _lender address of the lender to be liquidated\n     * @param _lenderCollateralTokens share of the lender in collateral tokens\n     */\n    function _liquidateForLender(\n        bool _fromSavingsAccount,\n        address _lender,\n        uint256 _lenderCollateralTokens\n    ) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(\n            _lenderCollateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);\n        _withdrawRepayment(_lender);\n    }\n\n    /**\n     * @notice used to liquidate lender and burn lender's shares\n     * @param _lender address of the lender to be liquidated\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     */\n    function liquidateForLender(\n        address _lender,\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        _canLenderBeLiquidated(_lender);\n\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);\n\n        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;\n        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);\n\n        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);\n\n        uint256 _amountReceived = _withdraw(\n            _toSavingsAccount,\n            _recieveLiquidityShare,\n            poolConstants.collateralAsset,\n            _poolSavingsStrategy,\n            _lenderCollateralTokens\n        );\n        _burn(_lender, _lenderBalance);\n        delete lenders[_lender];\n        emit LenderLiquidated(msg.sender, _lender, _amountReceived);\n    }\n\n    /**\n     * @notice used to get corresponding borrow tokens for given collateral tokens\n     * @param _totalCollateralTokens amount of collateral tokens\n     * @param _priceOracle address of the pool\n     * @param _fraction Incentivizing fraction for the liquidator\n     * @return corresponding borrow tokens for collateral tokens\n     */\n    function correspondingBorrowTokens(\n        uint256 _totalCollateralTokens,\n        address _priceOracle,\n        uint256 _fraction\n    ) public view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(\n            poolConstants.collateralAsset,\n            poolConstants.borrowAsset\n        );\n        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);\n    }\n\n    /**\n     * @notice used to get the interest per second on the principal amount\n     * @param _principal amount of principal lent\n     * @return interest accrued on the principal in a second\n     */\n    function interestPerSecond(uint256 _principal) public view returns (uint256) {\n        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);\n        return _interest;\n    }\n\n    /**\n     * @notice used to get the interest per period on the principal amount\n     * @param _balance amount of principal lent\n     * @return interest accrued on the principal in a period\n     */\n    function interestPerPeriod(uint256 _balance) external view returns (uint256) {\n        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));\n    }\n\n    /**\n     * @notice used to get the current repayment period for the borrow pool\n     * @return current repayment period\n     */\n    function calculateCurrentPeriod() external view returns (uint256) {\n        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);\n        return _currentPeriod;\n    }\n\n    /**\n     * @notice internal function used to get the withdrawable amount for a _lender\n     * @param _lender address of the _lender\n     * @return amount of withdrawable token from the borrow pool\n     */\n    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n\n        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(\n            lenders[_lender].effectiveInterestWithdrawn\n        );\n\n        return _amountWithdrawable;\n    }\n\n    /**\n     * @notice used to get the withdrawable amount of borrow token for a lender\n     */\n    function withdrawRepayment() external isLender(msg.sender) nonReentrant {\n        _withdrawRepayment(msg.sender);\n    }\n\n    /**\n     * @notice internal function used to withdraw borrow asset from the pool by _lender\n     * @param _lender address of the _lender\n     */\n    function _withdrawRepayment(address _lender) internal {\n        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);\n\n        if (_amountToWithdraw == 0) {\n            return;\n        }\n        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);\n\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);\n    }\n\n    /**\n     * @notice used to get the end time for a margin call\n     * @param _lender address of the lender who has requested a margin call\n     * @return the time at which the margin call ends\n     */\n    function getMarginCallEndTime(address _lender) public view override returns (uint256) {\n        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n\n        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {\n            _marginCallEndTime = 0;\n        }\n        return _marginCallEndTime;\n    }\n\n    /**\n     * @notice used to get the balance details of a _lender\n     * @param _lender address of the _lender\n     * @return amount of pool tokens available with the _lender\n     * @return amount of pool tokens available in the pool\n     */\n    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {\n        return (balanceOf(_lender), totalSupply());\n    }\n\n    /**\n     * @notice used to get the loan status of the borrow pool\n     * @return integer respresenting loan status\n     */\n    function getLoanStatus() external view override returns (uint256) {\n        return uint256(poolVariables.loanStatus);\n    }\n\n    /**\n     * @notice used to receive ethers from savings accounts\n     */\n    receive() external payable {}\n\n    /**\n     * @notice used to get the equivalent amount of tokens from source to target tokens\n     * @param _source address of the tokens to be converted\n     * @param _target address of target conversion token\n     * @param _amount amount of tokens to be converted\n     * @return the equivalent amount of target tokens for given source tokens\n     */\n    function getEquivalentTokens(\n        address _source,\n        address _target,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);\n        return _amount.mul(_price).div(10**_decimals);\n    }\n\n    /**\n     * @notice used to get the address of the borrower of the pool\n     * @return address of the borrower\n     */\n    function borrower() external view override returns (address) {\n        return poolConstants.borrower;\n    }\n\n    /**\n     * @notice used to total supply of pool tokens for the pool\n     * @return total supply of pool tokens\n     */\n    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {\n        return ERC20Upgradeable.totalSupply();\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.6;\n\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool);\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n\n\n",
        "CodeNames": [
            "CreditLine.sol",
            "PoolFactory.sol",
            "Pool.sol",
            "IUniswapV3Factory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\n// _createPool L349\nuint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;\n"
                ],
                "Type": " Ether can be locked in the  PoolFactory  contract without a way to retrieve it",
                "Description": "\nIf a borrower calls the createPool function with a non-zero value, but also includes an ERC20 token address for _collateralToken, then the Ether value sent will be locked in the PoolFactory contract forever.\n\n*   createPool L260-317(https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/PoolFactory.sol#L260-L317)\n\nIn the _createPool function, a _collateralToken address other than the zero address will set the amount variable to zero. That amount variable will be passed to create2 which will send 0 wei to the newly created Pool contract.\n\nsolidity\n// _createPool L349\nuint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;\n\n\n\nA borrower can accidentally lock Ether in the PoolFactory without the ability to retrieve it.\n\n\nA borrower reuses a script they made to create a pool and deposit collateral. They intend to deposit Ether as collateral so they send value with the transaction, but forget to change the _collateralToken address to address(0). The Pool contract will be deployed using the _collateralToken, and will lock the Ether sent in the PoolFactory\n\n\nManual analysis and Hardhat.\n\n",
                "Repair": "\nIf msg.value is greater than 0, make sure the _collateralToken address is set to address(0).\n\n\nritik99 (Sublime) disputed and disagreed with severity(https://github.com/code-423n4/2021-12-sublime-findings/issues/168#issuecomment-1001018859):\n  We will add this check but the scenario laid out is more about sanity checks on the side of the end-user. Assets are not stolen or compromised directly but because of user error. Such cases are better handled via UI/UX. We would suggest a (1) Low rating given the likelihood\n\n0xean (judge) commented(https://github.com/code-423n4/2021-12-sublime-findings/issues/168#issuecomment-1018049928):\n  Marking down to medium risk based on the c4 documentation and some external requirements on how this would have to occur. \n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IStrategyRegistry.sol';\n\n/**\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n **/\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     **/\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /**\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId => Strategy => collateralShares\n     **/\n    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;\n\n    /**\n     * @notice stores the variables to maintain a credit line\n     **/\n    mapping(uint256 => CreditLineVariables) public creditLineVariables;\n\n    /**\n     * @notice stores the constants related to a credit line\n     **/\n    mapping(uint256 => CreditLineConstants) public creditLineConstants;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address public savingsAccount;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    address public priceOracle;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    address public strategyRegistry;\n\n    /**\n     * @notice stores the address of default strategy\n     **/\n    address public defaultStrategy;\n\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    /**\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public liquidatorRewardFraction;\n    /**\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     **/\n    modifier ifCreditLineExists(uint256 _id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineLender(uint256 _id) {\n        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');\n        _;\n    }\n\n    /**\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /**\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     */\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /**\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /**\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /**\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     */\n    event CreditLineAccepted(uint256 indexed id);\n\n    /**\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /**\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /**\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     */\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /**\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /**\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /**\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /**\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), 'cant be 0 address');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'CL::I zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /**\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /**\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(\n            10**_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible > _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible > _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');\n    }\n\n    /**\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /**\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),\n            \"Only Borrower or Lender who hasn't requested can accept\"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /**\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, \"CreditLine::_depositCollateral - value to transfer doesn't match argument\");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, 'insufficient balance');\n    }\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\n            require(feeSuccess, 'Transfer fail');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\n            require(success, 'Transfer fail');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /**\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount >= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount > _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /**\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     */\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            'CreditLine: Permission denied while closing Line of credit'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 10**30 to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(\n            10**_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10**_decimals)\n            .div(10**30);\n\n        if (_collateralNeeded >= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert('insufficient collateral');\n    }\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,\n            'CreditLine: Collateral ratio is higher than ideal value'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}('');\n                    require(success, 'Transfer fail');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /**\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');\n    }\n}\n\n\n",
        "CodeNames": [
            "CreditLine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "autoLiquidation"
                ],
                "Type": " CreditLine.liquidate doesn't transfer borrowed ETH to a lender",
                "Description": "\n\nFunds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.\n\n\nETH sent to CreditLine.liquidate by an external liquidator when autoLiquidation is enabled remain with the contract and aren't transferred to the lender:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L1015\n\n",
                "Repair": "\nAdd transfer to a lender for ETH case:\n\nNow:\nsolidity\n\nif (_borrowAsset == address(0)) {\n        uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n        if (_returnETH != 0) {\n                (bool success, ) = msg.sender.call{value: _returnETH}('');\n                require(success, 'Transfer fail');\n        }\n}\n\nTo be:\nsolidity\n\nif (_borrowAsset == address(0)) {\n        uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n        \n        (bool success, ) = _lender.call{value: _borrowTokens}('');\n        require(success, 'liquidate: Transfer failed');\n        \n        if (_returnETH != 0) {\n                (success, ) = msg.sender.call{value: _returnETH}('');\n                require(success, 'liquidate: Return transfer failed');\n        }\n}\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/90)\n\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [
                    "approve(_spender,",
                    "approve()",
                    "IERC"
                ],
                "Type": " Missing approve(0)",
                "Description": "\n\nThere are 3 instances where the IERC20.approve() function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling approve(_spender, 0). Transactions will revert when using an unsupported token like USDT (see the approve() function requirement at line 199(https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)).\n\n\n*   CreditLine/CreditLine.sol:647(https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L647)\n*   CreditLine/CreditLine.sol:779(https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L779)\n*   yield/AaveYield.sol:324(https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L324)\n\nNote: the usage of approve() in yield/CompoundYield.sol ([lines 211-212(https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/CompoundYield.sol#L211-L212)), in yield/YearnYield.sol ([lines 211-212(https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/YearnYield.sol#L210-L211)), and in yield/AaveYield.sol ([lines 297-298(https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L297-L298)) do not need modification since it they already use the recommended approach. Additionally the usage of approve() in yield/AaveYield.sol:307(https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307) likely does not need modification since that approve function only handles ETH.\n\n",
                "Repair": "\nUse approve(_spender, 0) to set the allowance to zero immediately before each of the existing approve() calls.\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/97)\n0xean (judge) commented(https://github.com/code-423n4/2021-12-sublime-findings/issues/97#issuecomment-1018865958):\n  moving to medium risk as the availability of the protocol is affected. \n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.6;\n\nimport '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './interfaces/IPriceOracle.sol';\n\ncontract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {\n    using SafeMath for uint256;\n\n    uint32 uniswapPriceAveragingPeriod;\n    struct PriceData {\n        address oracle;\n        uint256 decimals;\n    }\n    /**\n     * @notice stores the price oracle and its decimals for chainlink feeds\n     **/\n    mapping(address => PriceData) public chainlinkFeedAddresses;\n    mapping(address => uint256) decimals;\n\n    /**\n     * @notice stores the addresses of price feeds for uniswap token pairs\n     **/\n    mapping(bytes32 => address) public uniswapPools;\n\n    /**\n     * @notice Used to initialize the price oracle contract\n     * @dev can only be invoked once\n     * @param _admin owner of the price oracle\n     **/\n    function initialize(address _admin) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_admin);\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from chainlink\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        PriceData memory _feedData1 = chainlinkFeedAddresses[num];\n        PriceData memory _feedData2 = chainlinkFeedAddresses[den];\n        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {\n            return (0, 0);\n        }\n        int256 price1;\n        int256 price2;\n        {\n            uint80 roundID1;\n            uint256 timeStamp1;\n            uint80 answeredInRound1;\n            (\n                roundID1,\n                price1,\n                ,\n                timeStamp1,\n                answeredInRound1\n            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();\n            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {\n                return (0, 0);\n            }\n        }\n        {\n            uint80 roundID2;\n            uint256 timeStamp2;\n            uint80 answeredInRound2;\n            (\n                roundID2,\n                price2,\n                ,\n                timeStamp2,\n                answeredInRound2\n            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();\n            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {\n                return (0, 0);\n            }\n        }\n        uint256 price = uint256(price1)\n            .mul(10**_feedData2.decimals)\n            .mul(10**30)\n            .div(uint256(price2))\n            .div(10**_feedData1.decimals)\n            .mul(10**decimals[den])\n            .div(10**decimals[num]);\n        return (price, 30);\n    }\n\n    /**\n     * @notice Used to get decimals for a token\n     * @param _token address of the token\n     * @return number of decimals for the token\n     **/\n    function getDecimals(address _token) internal view returns (uint8) {\n        if (_token == address(0)) {\n            return 18;\n        }\n\n        try ERC20(_token).decimals() returns (uint8 v) {\n            return v;\n        } catch Error(string memory) {\n            return 0;\n        } catch (bytes memory) {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from uniswap\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);\n        address _pool = uniswapPools[_poolTokensId];\n        if (_pool == address(0)) {\n            return (0, 0);\n        }\n\n        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);\n        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);\n        return (_numTokens, 30);\n    }\n\n    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {\n        if (uint256(num) < uint256(den)) {\n            return keccak256(abi.encodePacked(num, den));\n        } else {\n            return keccak256(abi.encodePacked(den, num));\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n        uint256 _price;\n        uint256 _decimals;\n        (_price, _decimals) = getChainlinkLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        (_price, _decimals) = getUniswapLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        revert(\"PriceOracle::getLatestPrice - Price Feed doesn't exist\");\n    }\n\n    /**\n     * @notice used to check if price feed exists between 2 tokens\n     * @param token1 one of the token for which price feed is to be checked\n     * @param token2 other token for which price feed is to be checked\n     * @return if price feed exists for the token pair\n     **/\n    function doesFeedExist(address token1, address token2) external view override returns (bool) {\n        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {\n            return true;\n        }\n\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n\n        if (uniswapPools[_poolTokensId] != address(0)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token in chainlink\n     * @dev only owner can set\n     * @param token address of token for which price feed is added\n     * @param priceOracle addrewss of the price feed for the token\n     **/\n    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {\n        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();\n        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);\n        decimals[token] = getDecimals(token);\n        emit ChainlinkFeedUpdated(token, priceOracle);\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token pair in uniswap\n     * @dev only owner can set\n     * @param token1 address of one of the tokens for which price feed is added\n     * @param token2 address of other token for which price feed is added\n     * @param pool addrewss of the price feed for the token pair\n     **/\n    function setUniswapFeedAddress(\n        address token1,\n        address token2,\n        address pool\n    ) external onlyOwner {\n        require(token1 != token2, 'token1 and token2 should be different addresses');\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n        uniswapPools[_poolTokensId] = pool;\n        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);\n    }\n\n    /**\n     * @notice Used to set the period in which uniswap price is averaged\n     * @dev only owner can set. This is used to prevent attacks to control price feed\n     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging\n     **/\n    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {\n        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;\n        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IExtension {\n    /**\n     * @notice emitted when the Voting Pass Ratio parameter for Pools is updated\n     * @param votingPassRatio the new value of the voting pass threshold for  Pools\n     */\n    event VotingPassRatioUpdated(uint256 votingPassRatio);\n\n    /**\n     * @notice emitted when the pool factory is updated in extension\n     * @param poolFactory updated address of pool factory\n     */\n    event PoolFactoryUpdated(address indexed poolFactory);\n\n    /**\n     * @notice emitted when an extension is requested by a borrower for Pools\n     * @param extensionVoteEndTime the value of the vote end time for the requested extension\n     */\n    event ExtensionRequested(uint256 extensionVoteEndTime);\n\n    /**\n     * @notice emitted when the requested extension for Pools is approved\n     * @param poolID the address of the pool for which extension passed\n     */\n    event ExtensionPassed(address poolID);\n\n    /**\n     * @notice emitted when the lender for Pools has voted on extension request\n     * @param lender address of the lender who voted\n     * @param totalExtensionSupport the value of the total extension support for the Pools\n     * @param lastVoteTime the last time the lender has voted on an extension request\n     */\n    event LenderVoted(address indexed lender, uint256 totalExtensionSupport, uint256 lastVoteTime);\n\n    function initializePoolExtension(uint256 _repaymentInterval) external;\n\n    function closePoolExtension() external;\n\n    function removeVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IExtension.sol';\nimport '../interfaces/IRepayment.sol';\n\n/**\n * @title Extension contract with methods related to Extension period\n * @notice Implements the functions related to Extension period of the pool\n * @author Sublime\n */\ncontract Extension is Initializable, IExtension {\n    using SafeMath for uint256;\n\n    struct ExtensionVariables {\n        bool hasExtensionPassed;\n        uint256 totalExtensionSupport;\n        uint256 extensionVoteEndTime;\n        uint256 repaymentInterval;\n        mapping(address => uint256) lastVotedExtension;\n    }\n\n    /**\n     * @notice used to keep track of extension details against a pool\n     */\n    mapping(address => ExtensionVariables) public extensions;\n    IPoolFactory poolFactory;\n    /**\n     * @notice used to store voting pass ratio for approving extension\n     */\n    uint256 public votingPassRatio;\n\n    /**\n     * @notice checks if the msg.sender is pool's valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == poolFactory.owner(), 'Not owner');\n        _;\n    }\n\n    /**\n     * @notice checks if the address is pool's valid borrower\n     * @param _pool address of the borrower\n     */\n    modifier onlyBorrower(address _pool) {\n        require(IPool(_pool).borrower() == msg.sender, 'Not Borrower');\n        _;\n    }\n\n    /**\n     * @notice initializing the Pool and the voting pass ratio\n     * @param _poolFactory address of the Pool\n     * @param _votingPassRatio the value of the voting pass ratio\n     */\n    function initialize(address _poolFactory, uint256 _votingPassRatio) external initializer {\n        _updatePoolFactory(_poolFactory);\n        _updateVotingPassRatio(_votingPassRatio);\n    }\n\n    /**\n     * @notice initializing the pool extension for the Pool\n     * @param _repaymentInterval value of the repayment interval\n     */\n    function initializePoolExtension(uint256 _repaymentInterval) external override {\n        IPoolFactory _poolFactory = poolFactory;\n        require(extensions[msg.sender].repaymentInterval == 0, 'Extension::initializePoolExtension - already initialized');\n        require(_poolFactory.poolRegistry(msg.sender), 'Repayments::onlyValidPool - Invalid Pool');\n        extensions[msg.sender].repaymentInterval = _repaymentInterval;\n    }\n\n    /**\n     * @notice used for requesting an extension by a borrower\n     * @param _pool address of the Pool\n     */\n    function requestExtension(address _pool) external onlyBorrower(_pool) {\n        uint256 _repaymentInterval = extensions[_pool].repaymentInterval;\n        require(_repaymentInterval != 0, 'Extension::requestExtension - Uninitialized pool');\n        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;\n        require(block.timestamp > _extensionVoteEndTime, 'Extension::requestExtension - Extension requested already'); // _extensionVoteEndTime is 0 when no extension is active\n\n        // This check is required so that borrower doesn't ask for more extension if previously an extension is already granted\n        require(!extensions[_pool].hasExtensionPassed, 'Extension::requestExtension: Extension already availed');\n\n        extensions[_pool].totalExtensionSupport = 0; // As we can multiple voting every time new voting start we have to make previous votes 0\n        IRepayment _repayment = IRepayment(poolFactory.repaymentImpl());\n        uint256 _nextDueTime = _repayment.getNextInstalmentDeadline(_pool);\n        _extensionVoteEndTime = (_nextDueTime).div(10**30);\n        extensions[_pool].extensionVoteEndTime = _extensionVoteEndTime; // this makes extension request single use\n        emit ExtensionRequested(_extensionVoteEndTime);\n    }\n\n    /**\n     * @notice used to rebalance votes of from and to addresses when pool tokens are transferred\n     * @dev only pool can change its votes\n     * @param _from address of user from whom pool tokens are transferred\n     * @param _to address of user to whom pool tokens are transferred\n     * @param _amount amount of pool tokens transferred\n     */\n    function removeVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override {\n        address _pool = msg.sender;\n        if (extensions[_pool].hasExtensionPassed) {\n            return;\n        }\n\n        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;\n\n        if (_extensionVoteEndTime != 0 && _extensionVoteEndTime <= block.timestamp) {\n            if (extensions[_pool].lastVotedExtension[_from] == _extensionVoteEndTime) {\n                extensions[_pool].totalExtensionSupport = extensions[_pool].totalExtensionSupport.sub(_amount);\n            }\n\n            if (extensions[_pool].lastVotedExtension[_to] == _extensionVoteEndTime) {\n                extensions[_pool].totalExtensionSupport = extensions[_pool].totalExtensionSupport.add(_amount);\n            }\n        }\n    }\n\n    /**\n     * @notice used for requesting an extension by a borrower\n     * @param _pool address of the Pool\n     */\n    function voteOnExtension(address _pool) external {\n        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;\n        require(block.timestamp < _extensionVoteEndTime, 'Pool::voteOnExtension - Voting is over');\n\n        (uint256 _balance, uint256 _totalSupply) = IPool(_pool).getBalanceDetails(msg.sender);\n        require(_balance != 0, 'Pool::voteOnExtension - Not a valid lender for pool');\n\n        uint256 _votingPassRatio = votingPassRatio;\n\n        uint256 _lastVotedExtension = extensions[_pool].lastVotedExtension[msg.sender]; //Lender last vote time need to store it as it checks that a lender only votes once\n        require(_lastVotedExtension != _extensionVoteEndTime, 'Pool::voteOnExtension - you have already voted');\n\n        uint256 _extensionSupport = extensions[_pool].totalExtensionSupport;\n        _lastVotedExtension = _extensionVoteEndTime;\n        _extensionSupport = _extensionSupport.add(_balance);\n\n        extensions[_pool].lastVotedExtension[msg.sender] = _lastVotedExtension;\n        emit LenderVoted(msg.sender, _extensionSupport, _lastVotedExtension);\n        extensions[_pool].totalExtensionSupport = _extensionSupport;\n\n        if (((_extensionSupport)) >= (_totalSupply.mul(_votingPassRatio)).div(10**30)) {\n            grantExtension(_pool);\n        }\n    }\n\n    /**\n     * @notice used for granting an extension for the repayment of loan\n     * @param _pool address of the Pool\n     */\n    function grantExtension(address _pool) internal {\n        IPoolFactory _poolFactory = poolFactory;\n        IRepayment _repayment = IRepayment(_poolFactory.repaymentImpl());\n\n        extensions[_pool].hasExtensionPassed = true;\n        extensions[_pool].extensionVoteEndTime = block.timestamp; // voting is over\n\n        _repayment.instalmentDeadlineExtended(_pool);\n\n        emit ExtensionPassed(_pool);\n    }\n\n    /**\n     * @notice used for closing the pool extension\n     */\n    function closePoolExtension() external override {\n        delete extensions[msg.sender];\n    }\n\n    /**\n     * @notice used for updating the voting pass ratio of the Pool\n     * @param _votingPassRatio the value of the new voting pass ratio\n     */\n    function updateVotingPassRatio(uint256 _votingPassRatio) external onlyOwner {\n        _updateVotingPassRatio(_votingPassRatio);\n    }\n\n    function _updateVotingPassRatio(uint256 _votingPassRatio) internal {\n        votingPassRatio = _votingPassRatio;\n        emit VotingPassRatioUpdated(_votingPassRatio);\n    }\n\n    /**\n     * @notice used to update the pool factory contract address\n     * @dev only owner can update\n     * @param _poolFactory updated pool factory contract address\n     */\n    function updatePoolFactory(address _poolFactory) external onlyOwner {\n        _updatePoolFactory(_poolFactory);\n    }\n\n    function _updatePoolFactory(address _poolFactory) internal {\n        require(_poolFactory != address(0), 'Zero address not allowed');\n        poolFactory = IPoolFactory(_poolFactory);\n        emit PoolFactoryUpdated(_poolFactory);\n    }\n}\n\n\n",
        "CodeNames": [
            "PriceOracle.sol",
            "IExtension.sol",
            "Extension.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "removeVotes",
                    "totalExtensionSupport",
                    "from",
                    "voteOnExtension"
                ],
                "Type": " Extension voting threshold check needs to rerun on each transfer",
                "Description": "\nThe Extension contract correctly reduces votes from the from address of a transfer and adds it to the to address of the transfer (in case both of them voted on it before), but it does not rerun the voting logic in voteOnExtension that actually grants the extension.\nThis leads to issues where an extension should be granted but is not:\n\n\n*   to address has 100 tokens and votes for the extension\n*   from address has 100 tokens but does not vote for the extension and transfers the 100 tokens to to\n*   to now has 200 tokens, removeVotes is run, the totalExtensionSupport is increased by 100 to 200. In theory, the threshold is reached and the vote should pass if to could call voteOnExtension again.\n*   But their call to voteOnExtension with the new balance will fail as they already voted on it (lastVotedExtension == _extensionVoteEndTime). The extension is not granted.\n\n\nExtensions that should be granted after a token transfer are not granted.\n\n",
                "Repair": "\nRerun the threshold logic in removeVotes as it has the potential to increase the total support if to voted for the extension but from did not.\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/141)\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.6;\n\nimport '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './interfaces/IPriceOracle.sol';\n\ncontract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {\n    using SafeMath for uint256;\n\n    uint32 uniswapPriceAveragingPeriod;\n    struct PriceData {\n        address oracle;\n        uint256 decimals;\n    }\n    /**\n     * @notice stores the price oracle and its decimals for chainlink feeds\n     **/\n    mapping(address => PriceData) public chainlinkFeedAddresses;\n    mapping(address => uint256) decimals;\n\n    /**\n     * @notice stores the addresses of price feeds for uniswap token pairs\n     **/\n    mapping(bytes32 => address) public uniswapPools;\n\n    /**\n     * @notice Used to initialize the price oracle contract\n     * @dev can only be invoked once\n     * @param _admin owner of the price oracle\n     **/\n    function initialize(address _admin) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_admin);\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from chainlink\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        PriceData memory _feedData1 = chainlinkFeedAddresses[num];\n        PriceData memory _feedData2 = chainlinkFeedAddresses[den];\n        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {\n            return (0, 0);\n        }\n        int256 price1;\n        int256 price2;\n        {\n            uint80 roundID1;\n            uint256 timeStamp1;\n            uint80 answeredInRound1;\n            (\n                roundID1,\n                price1,\n                ,\n                timeStamp1,\n                answeredInRound1\n            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();\n            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {\n                return (0, 0);\n            }\n        }\n        {\n            uint80 roundID2;\n            uint256 timeStamp2;\n            uint80 answeredInRound2;\n            (\n                roundID2,\n                price2,\n                ,\n                timeStamp2,\n                answeredInRound2\n            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();\n            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {\n                return (0, 0);\n            }\n        }\n        uint256 price = uint256(price1)\n            .mul(10**_feedData2.decimals)\n            .mul(10**30)\n            .div(uint256(price2))\n            .div(10**_feedData1.decimals)\n            .mul(10**decimals[den])\n            .div(10**decimals[num]);\n        return (price, 30);\n    }\n\n    /**\n     * @notice Used to get decimals for a token\n     * @param _token address of the token\n     * @return number of decimals for the token\n     **/\n    function getDecimals(address _token) internal view returns (uint8) {\n        if (_token == address(0)) {\n            return 18;\n        }\n\n        try ERC20(_token).decimals() returns (uint8 v) {\n            return v;\n        } catch Error(string memory) {\n            return 0;\n        } catch (bytes memory) {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from uniswap\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);\n        address _pool = uniswapPools[_poolTokensId];\n        if (_pool == address(0)) {\n            return (0, 0);\n        }\n\n        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);\n        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);\n        return (_numTokens, 30);\n    }\n\n    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {\n        if (uint256(num) < uint256(den)) {\n            return keccak256(abi.encodePacked(num, den));\n        } else {\n            return keccak256(abi.encodePacked(den, num));\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n        uint256 _price;\n        uint256 _decimals;\n        (_price, _decimals) = getChainlinkLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        (_price, _decimals) = getUniswapLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        revert(\"PriceOracle::getLatestPrice - Price Feed doesn't exist\");\n    }\n\n    /**\n     * @notice used to check if price feed exists between 2 tokens\n     * @param token1 one of the token for which price feed is to be checked\n     * @param token2 other token for which price feed is to be checked\n     * @return if price feed exists for the token pair\n     **/\n    function doesFeedExist(address token1, address token2) external view override returns (bool) {\n        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {\n            return true;\n        }\n\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n\n        if (uniswapPools[_poolTokensId] != address(0)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token in chainlink\n     * @dev only owner can set\n     * @param token address of token for which price feed is added\n     * @param priceOracle addrewss of the price feed for the token\n     **/\n    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {\n        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();\n        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);\n        decimals[token] = getDecimals(token);\n        emit ChainlinkFeedUpdated(token, priceOracle);\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token pair in uniswap\n     * @dev only owner can set\n     * @param token1 address of one of the tokens for which price feed is added\n     * @param token2 address of other token for which price feed is added\n     * @param pool addrewss of the price feed for the token pair\n     **/\n    function setUniswapFeedAddress(\n        address token1,\n        address token2,\n        address pool\n    ) external onlyOwner {\n        require(token1 != token2, 'token1 and token2 should be different addresses');\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n        uniswapPools[_poolTokensId] = pool;\n        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);\n    }\n\n    /**\n     * @notice Used to set the period in which uniswap price is averaged\n     * @dev only owner can set. This is used to prevent attacks to control price feed\n     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging\n     **/\n    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {\n        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;\n        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IStrategyRegistry.sol';\n\n/**\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n **/\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /**\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     **/\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /**\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId => Strategy => collateralShares\n     **/\n    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;\n\n    /**\n     * @notice stores the variables to maintain a credit line\n     **/\n    mapping(uint256 => CreditLineVariables) public creditLineVariables;\n\n    /**\n     * @notice stores the constants related to a credit line\n     **/\n    mapping(uint256 => CreditLineConstants) public creditLineConstants;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address public savingsAccount;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    address public priceOracle;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    address public strategyRegistry;\n\n    /**\n     * @notice stores the address of default strategy\n     **/\n    address public defaultStrategy;\n\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    /**\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 10**30\n     **/\n    uint256 public liquidatorRewardFraction;\n    /**\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     **/\n    modifier ifCreditLineExists(uint256 _id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     **/\n    modifier onlyCreditLineLender(uint256 _id) {\n        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');\n        _;\n    }\n\n    /**\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /**\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     */\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /**\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /**\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /**\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     */\n    event CreditLineAccepted(uint256 indexed id);\n\n    /**\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /**\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /**\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     */\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /**\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /**\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /**\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /**\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), 'cant be 0 address');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), 'CL::I zero address');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /**\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /**\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(\n            10**_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible > _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible > _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');\n    }\n\n    /**\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /**\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),\n            \"Only Borrower or Lender who hasn't requested can accept\"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /**\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, \"CreditLine::_depositCollateral - value to transfer doesn't match argument\");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, 'insufficient balance');\n    }\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount <= _borrowableAmount, \"CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount\");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\n            require(feeSuccess, 'Transfer fail');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\n            require(success, 'Transfer fail');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index < _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) >= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /**\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');\n        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount >= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount > _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /**\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     */\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            'CreditLine: Permission denied while closing Line of credit'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 10**30 to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(\n            10**_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10**_decimals)\n            .div(10**30);\n\n        if (_collateralNeeded >= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index < _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert('insufficient collateral');\n    }\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');\n        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,\n            'CreditLine: Collateral ratio is higher than ideal value'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}('');\n                    require(success, 'Transfer fail');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /**\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IYield {\n    /**\n     * @dev emitted when tokens are locked\n     * @param user the address of user, tokens locked for\n     * @param investedTo the address of contract to invest in\n     * @param lpTokensReceived the amount of shares received\n     **/\n    event LockedTokens(address indexed user, address indexed investedTo, uint256 lpTokensReceived);\n\n    /**\n     * @dev emitted when tokens are unlocked/redeemed\n     * @param investedTo the address of contract invested in\n     * @param collateralReceived the amount of underlying asset received\n     **/\n    event UnlockedTokens(address indexed investedTo, uint256 collateralReceived);\n\n    /**\n     * @notice emitted when a shares are unlocked from yield\n     * @param asset address of the base token for which shares are being withdrawn\n     * @param sharesReleased amount of shares unlocked\n     */\n    event UnlockedShares(address indexed asset, uint256 sharesReleased);\n\n    /**\n     * @notice emitted when savings account address is updated\n     * @param savingsAccount updated address of the savings account contract\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @dev Used to get liquidity token address from asset address\n     * @param asset the address of underlying token\n     * @return tokenAddress address of liquidity token\n     **/\n    function liquidityToken(address asset) external view returns (address tokenAddress);\n\n    /**\n     * @dev Used to lock tokens in available protocol\n     * @param user the address of user locking tokens\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable returns (uint256 sharesReceived);\n\n    /**\n     * @dev Used to unlock tokens from available protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of liquidity shares to unlock\n     * @return tokensReceived amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount) external returns (uint256 tokensReceived);\n\n    function unlockShares(address asset, uint256 amount) external returns (uint256 received);\n\n    /**\n     * @dev Used to get amount of underlying tokens for current number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) external returns (uint256 amount);\n\n    function getSharesForTokens(uint256 amount, address asset) external returns (uint256 shares);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IYield.sol';\nimport '../interfaces/Invest/ICEther.sol';\nimport '../interfaces/Invest/ICToken.sol';\n\n/**\n * @title Yield contract\n * @notice Implements the functions to lock/unlock tokens into available exchanges\n * @author Sublime\n **/\ncontract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address payable public savingsAccount;\n\n    /**\n     * @notice checks if contract is invoked by savings account\n     **/\n    modifier onlySavingsAccount() {\n        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');\n        _;\n    }\n\n    /**\n     * @notice used to initialize the variables in the contract\n     * @dev can only be called once\n     * @param _owner address of the owner\n     * @param _savingsAccount address of the savings account contract\n     **/\n    function initialize(address _owner, address payable _savingsAccount) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    /**\n     * @notice used to query liquidity token for a given asset\n     * @param _asset address of the asset\n     * @return _tokenAddress address of the lqiudity token for the asset\n     **/\n    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {\n        _tokenAddress = _asset;\n    }\n\n    /**\n     * @notice used to update savings account contract address\n     * @dev can only be called by owner\n     * @param _savingsAccount address of updated savings account contract\n     **/\n    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address payable _savingsAccount) internal {\n        require(_savingsAccount != address(0), 'Invest: zero address');\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to withdraw all tokens of a type in case of emergencies\n     * @dev only owner can withdraw\n     * @param _asset address of the token being withdrawn\n     * @param _wallet address to which tokens are withdrawn\n     */\n    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n        require(_wallet != address(0), 'cant burn');\n        uint256 amount = IERC20(_asset).balanceOf(address(this));\n        IERC20(_asset).safeTransfer(_wallet, received);\n        received = amount;\n    }\n\n    /**\n     * @notice Used to lock tokens in the protocol\n     * @dev Asset Tokens to be locked must be approved to this contract by user\n     * @param user the address of user\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n        require(amount != 0, 'Invest: amount');\n        if (asset != address(0)) {\n            IERC20(asset).safeTransferFrom(user, address(this), amount);\n        } else {\n            require(msg.value == amount, 'Invest: ETH amount');\n        }\n        sharesReceived = amount;\n        emit LockedTokens(user, asset, sharesReceived);\n    }\n\n    /**\n     * @notice Used to unlock tokens from the protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of asset\n     * @return tokensReceived received amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount)\n        external\n        override\n        onlySavingsAccount\n        nonReentrant\n        returns (uint256 tokensReceived)\n    {\n        tokensReceived = _unlockTokens(asset, amount);\n    }\n\n    /**\n     * @notice Used to unlock shares\n     * @param asset the address of underlying token\n     * @param amount the amount of shares to unlock\n     * @return received amount of shares received\n     **/\n    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {\n        received = _unlockTokens(asset, amount);\n    }\n\n    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {\n        require(amount != 0, 'Invest: amount');\n        received = amount;\n        if (asset == address(0)) {\n            (bool success, ) = savingsAccount.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            IERC20(asset).safeTransfer(savingsAccount, received);\n        }\n        emit UnlockedTokens(asset, received);\n    }\n\n    /**\n     * @dev Used to get amount of underlying tokens for given number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {\n        amount = shares;\n    }\n\n    /**\n     * @notice Used to get number of shares from an amount of underlying tokens\n     * @param amount the amount of tokens\n     * @param asset the address of token\n     * @return shares amount of shares for given tokens\n     **/\n    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {\n        shares = amount;\n    }\n}\n\n\n",
        "CodeNames": [
            "PriceOracle.sol",
            "CreditLine.sol",
            "IYield.sol",
            "NoYield.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction lockTokens(\n    address user,\n    address asset,\n    uint256 amount\n) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n    require(amount != 0, 'Invest: amount');\n    if (asset != address(0)) {\n        IERC20(asset).safeTransferFrom(user, address(this), amount);\n    } else {\n        require(msg.value == amount, 'Invest: ETH amount');\n    }\n    sharesReceived = amount;\n    emit LockedTokens(user, asset, sharesReceived);\n}\n",
                    "//solidity\nfunction _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {\n    require(amount != 0, 'Invest: amount');\n    received = amount;\n    if (asset == address(0)) {\n        (bool success, ) = savingsAccount.call{value: received}('');\n        require(success, 'Transfer failed');\n    } else {\n        IERC20(asset).safeTransfer(savingsAccount, received);\n    }\n    emit UnlockedTokens(asset, received);\n}\n"
                ],
                "Type": "  NoYield.sol  Tokens with fee on transfer are not supported",
                "Description": "\n\nThere are ERC20 tokens that charge fee for every transfer() or transferFrom().\n\nIn the current implementation, NoYield.sol#lockTokens() assumes that the received amount is the same as the transfer amount, and uses it to calculate sharesReceived amounts.\n\nAs a result, in unlockTokens(), later users may not be able to successfully withdraw their tokens, as it may revert at L141 for insufficient balance.\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L93-L106\n\nsolidity\nfunction lockTokens(\n    address user,\n    address asset,\n    uint256 amount\n) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n    require(amount != 0, 'Invest: amount');\n    if (asset != address(0)) {\n        IERC20(asset).safeTransferFrom(user, address(this), amount);\n    } else {\n        require(msg.value == amount, 'Invest: ETH amount');\n    }\n    sharesReceived = amount;\n    emit LockedTokens(user, asset, sharesReceived);\n}\n\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L134-L144\n\nsolidity\nfunction _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {\n    require(amount != 0, 'Invest: amount');\n    received = amount;\n    if (asset == address(0)) {\n        (bool success, ) = savingsAccount.call{value: received}('');\n        require(success, 'Transfer failed');\n    } else {\n        IERC20(asset).safeTransfer(savingsAccount, received);\n    }\n    emit UnlockedTokens(asset, received);\n}\n\n\n",
                "Repair": "\nConsider comparing before and after balance to get the actual transferred amount.\n\nritik99 (Sublime) acknowledged and disagreed with severity(https://github.com/code-423n4/2021-12-sublime-findings/issues/142)\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IYield {\n    /**\n     * @dev emitted when tokens are locked\n     * @param user the address of user, tokens locked for\n     * @param investedTo the address of contract to invest in\n     * @param lpTokensReceived the amount of shares received\n     **/\n    event LockedTokens(address indexed user, address indexed investedTo, uint256 lpTokensReceived);\n\n    /**\n     * @dev emitted when tokens are unlocked/redeemed\n     * @param investedTo the address of contract invested in\n     * @param collateralReceived the amount of underlying asset received\n     **/\n    event UnlockedTokens(address indexed investedTo, uint256 collateralReceived);\n\n    /**\n     * @notice emitted when a shares are unlocked from yield\n     * @param asset address of the base token for which shares are being withdrawn\n     * @param sharesReleased amount of shares unlocked\n     */\n    event UnlockedShares(address indexed asset, uint256 sharesReleased);\n\n    /**\n     * @notice emitted when savings account address is updated\n     * @param savingsAccount updated address of the savings account contract\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /**\n     * @dev Used to get liquidity token address from asset address\n     * @param asset the address of underlying token\n     * @return tokenAddress address of liquidity token\n     **/\n    function liquidityToken(address asset) external view returns (address tokenAddress);\n\n    /**\n     * @dev Used to lock tokens in available protocol\n     * @param user the address of user locking tokens\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable returns (uint256 sharesReceived);\n\n    /**\n     * @dev Used to unlock tokens from available protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of liquidity shares to unlock\n     * @return tokensReceived amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount) external returns (uint256 tokensReceived);\n\n    function unlockShares(address asset, uint256 amount) external returns (uint256 received);\n\n    /**\n     * @dev Used to get amount of underlying tokens for current number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) external returns (uint256 amount);\n\n    function getSharesForTokens(uint256 amount, address asset) external returns (uint256 shares);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IYield.sol';\nimport '../interfaces/Invest/IWETHGateway.sol';\nimport '../interfaces/Invest/AaveLendingPool.sol';\nimport '../interfaces/Invest/IScaledBalanceToken.sol';\nimport '../interfaces/Invest/IProtocolDataProvider.sol';\n\n/**\n * @title Yield contract\n * @notice Implements the functions to lock/unlock tokens into Aave protocol\n * @author Sublime\n **/\ncontract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice address of wethGateway used to deposit ETH to aave\n     */\n    address public wethGateway;\n\n    /**\n     * @notice address of protocolDataProvider which provides info about aTokens related to any token\n     */\n    address public protocolDataProvider;\n\n    /**\n     * @notice address of lendingPoolAddressesProvider used to get the pool related to any token\n     */\n    address public lendingPoolAddressesProvider;\n\n    /**\n     * @notice address of savings account contract\n     */\n    address payable public savingsAccount;\n\n    /**\n     * @notice aave referral code to represent sublime\n     */\n    uint16 public referralCode;\n\n    /**\n     * @notice emitted when aave protocol related addresses are updated\n     * @param wethGateway address of wethGateway\n     * @param protocolDataProvider address of protocol data provider\n     * @param lendingPoolAddressesProvider address of lending pool addresses provider\n     */\n    event AaveAddressesUpdated(\n        address indexed wethGateway,\n        address indexed protocolDataProvider,\n        address indexed lendingPoolAddressesProvider\n    );\n\n    /**\n     * @notice emitted when aave referral code is updated\n     * @param referralCode updated referral code\n     */\n    event ReferralCodeUpdated(uint16 referralCode);\n\n    /**\n     * @notice verifies if savings account invoked the contract\n     */\n    modifier onlySavingsAccount() {\n        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');\n        _;\n    }\n\n    /**\n     * @notice To initialize the contract addresses interacting with this contract\n     * @dev can only be initialized once\n     * @param _owner address of owner\n     * @param _savingsAccount address of the savings account contract\n     * @param _wethGateway address of wethGateway\n     * @param _protocolDataProvider the address of ProtocolDataProvider\n     * @param _lendingPoolAddressesProvider the address of LendingPoolAddressesProvider\n     **/\n    function initialize(\n        address _owner,\n        address payable _savingsAccount,\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateSavingsAccount(_savingsAccount);\n        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    /**\n     * @notice Used to get liquidity token address from asset address\n     * @param asset the address of underlying token\n     * @return aToken address of liquidity token\n     **/\n    function liquidityToken(address asset) public view override returns (address aToken) {\n        if (asset == address(0)) {\n            aToken = IWETHGateway(wethGateway).getAWETHAddress();\n        } else {\n            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);\n        }\n    }\n\n    /**\n     * @notice used to update savings account address\n     * @dev only owner can update\n     * @param _savingsAccount address of the updated savings account\n     */\n    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address payable _savingsAccount) internal {\n        require(_savingsAccount != address(0), 'Invest: zero address');\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update aave protocol related addresses\n     * @dev only owner can update\n     * @param _wethGateway address of wethGateway\n     * @param _protocolDataProvider address of protocol data provider\n     * @param _lendingPoolAddressesProvider address of lending pool addresses provider\n     */\n    function updateAaveAddresses(\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) external onlyOwner {\n        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    function _updateAaveAddresses(\n        address _wethGateway,\n        address _protocolDataProvider,\n        address _lendingPoolAddressesProvider\n    ) internal {\n        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');\n        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');\n        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');\n        wethGateway = _wethGateway;\n        protocolDataProvider = _protocolDataProvider;\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);\n    }\n\n    /**\n     * @notice used to update referral code\n     * @dev only owner can update\n     * @param _referralCode updated referral code\n     */\n    function updateReferralCode(uint16 _referralCode) external onlyOwner {\n        referralCode = _referralCode;\n        emit ReferralCodeUpdated(_referralCode);\n    }\n\n    /**\n     * @notice used to withdraw all tokens of a type in case of emergencies\n     * @dev only owner can withdraw\n     * @param _asset address of the token being withdrawn\n     * @param _wallet address to which tokens are withdrawn\n     */\n    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n        require(_wallet != address(0), 'cant burn');\n        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));\n\n        if (_asset == address(0)) {\n            received = _withdrawETH(amount);\n            (bool success, ) = _wallet.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            received = _withdrawERC(_asset, amount);\n            IERC20(_asset).safeTransfer(_wallet, received);\n        }\n    }\n\n    /**\n     * @notice Used to lock tokens in protocol\n     * @dev Asset Tokens to be locked must be approved to this contract by user\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n        require(amount != 0, 'Invest: amount');\n\n        address investedTo;\n        if (asset == address(0)) {\n            require(msg.value == amount, 'Invest: ETH amount');\n            (investedTo, sharesReceived) = _depositETH(amount);\n        } else {\n            IERC20(asset).safeTransferFrom(user, address(this), amount);\n            (investedTo, sharesReceived) = _depositERC20(asset, amount);\n        }\n\n        emit LockedTokens(user, investedTo, sharesReceived);\n    }\n\n    /**\n     * @notice Used to unlock tokens from available protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of asset\n     * @return received amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {\n        require(amount != 0, 'Invest: amount');\n\n        if (asset == address(0)) {\n            received = _withdrawETH(amount);\n            (bool success, ) = savingsAccount.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            received = _withdrawERC(asset, amount);\n            IERC20(asset).safeTransfer(savingsAccount, received);\n        }\n\n        emit UnlockedTokens(asset, received);\n    }\n\n    /**\n     * @notice Used to unlock shares\n     * @param asset the address of underlying token\n     * @param amount the amount of shares to unlock\n     * @return received amount of shares received\n     **/\n    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n\n        require(asset != address(0), 'Asset address cannot be address(0)');\n        IERC20(asset).safeTransfer(savingsAccount, amount);\n\n        emit UnlockedShares(asset, amount);\n        return amount;\n    }\n\n    /**\n     * @notice Used to get amount of underlying tokens for current number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n        if (shares == 0) return 0;\n        address aToken = liquidityToken(asset);\n\n        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);\n\n        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(\n            IERC20(aToken).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Used to get number of shares from an amount of underlying tokens\n     * @param amount the amount of tokens\n     * @param asset the address of token\n     * @return shares amount of shares for given tokens\n     **/\n    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {\n        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));\n    }\n\n    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {\n        aToken = IWETHGateway(wethGateway).getAWETHAddress();\n\n        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        //lock collateral\n        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);\n\n        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);\n    }\n\n    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {\n        aToken = liquidityToken(asset);\n        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        //approve collateral to vault\n        IERC20(asset).approve(lendingPool, 0);\n        IERC20(asset).approve(lendingPool, amount);\n\n        //lock collateral in vault\n        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);\n\n        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);\n    }\n\n    function _withdrawETH(uint256 amount) internal returns (uint256 received) {\n        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);\n\n        uint256 ethBalance = address(this).balance;\n\n        //lock collateral\n        IWETHGateway(wethGateway).withdrawETH(amount, address(this));\n\n        received = address(this).balance.sub(ethBalance);\n    }\n\n    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {\n        address aToken = liquidityToken(asset);\n\n        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();\n\n        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));\n\n        IERC20(aToken).approve(lendingPool, amount);\n\n        //withdraw collateral from vault\n        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));\n\n        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "IYield.sol",
            "AaveYield.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "_depositETH",
                    "_withdrawETH",
                    "liquidityToken",
                    "wethGateway"
                ],
                "Type": " AaveYield: Misspelled external function name making functions fail",
                "Description": "\n\nIn AaveYield.sol the functions:\n\n*   liquidityToken\n*   _withdrawETH\n*   _depositETH\n\nMake a conditional call to IWETHGateway(wethGateway).getAWETHAddress()\n\nThis function does not exist in the wethGateway contract, causing these function to fail with the error \"Fallback not allowed\".\n\nThe function they should be calling is getWethAddress() without the \"A\".\n\nSmall yet dangerous typo.\n\n\nSimply modify:\n\nIWETHGateway(wethGateway).getAWETHAddress()\n\nto:\n\nIWETHGateway(wethGateway).getWETHAddress()\n\nIn the functions mentioned above.\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2021-12-sublime-findings/issues/42#issuecomment-1001348407):\n  We were using an older version of the contracts that had this definition(https://etherscan.io/address/dcd33426ba191383f1c9b431a342498fdac73488#code#F1#L158), will be updated accordingly\n\n\n\n",
                "Repair": ""
            }
        ]
    }
]