[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n  function _processPayment(JBDidPayData calldata _data) internal override {\n    // Keep a reference to the amount of credits the beneficiary already has.\n    uint256 _credits = creditsOf[_data.beneficiary];\n    ...\n    if (\n      _data.metadata.length  36 &&\n      bytes4(_data.metadata[32:36]) == type(IJB721Delegate).interfaceId\n    ) {\n      ...\n      // Don't mint if not desired.\n      if (_dontMint) return;\n      ...\n    }\n    ...\n    // If there are funds leftover, mint the best available with it.\n    if (_leftoverAmount != 0) {\n      _leftoverAmount = _mintBestAvailableTier(\n        _leftoverAmount,\n        _data.beneficiary,\n        _expectMintFromExtraFunds\n      );\n\n      if (_leftoverAmount != 0) {\n        // Make sure there are no leftover funds after minting if not expected.\n        if (_dontOverspend) revert OVERSPENDING();\n\n        // Increment the leftover amount.\n        creditsOf[_data.beneficiary] = _leftoverAmount;\n      } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n    } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n  }\n",
                    "//solidity\n  function testPaymentNotAddedToCreditsOf() public{\n    address _user = address(bytes20(keccak256('user')));\n    (\n      JBDeployTiered721DelegateData memory NFTRewardDeployerData,\n      JBLaunchProjectData memory launchProjectData\n    ) = createData();\n\n    uint256 projectId = deployer.launchProjectFor(\n      _projectOwner,\n      NFTRewardDeployerData,\n      launchProjectData\n    );\n\n    // Get the dataSource\n    IJBTiered721Delegate _delegate = IJBTiered721Delegate(\n      _jbFundingCycleStore.currentOf(projectId).dataSource()\n    );\n\n    address NFTRewardDataSource = _jbFundingCycleStore.currentOf(projectId).dataSource();\n\n    uint256 _creditBefore = IJBTiered721Delegate(NFTRewardDataSource).creditsOf(_user);\n\n    // Project is initiated with 10 different tiers with contributionFee of 10,20,30,40, .... , 100\n\n    // Make payment to mint 1 NFT\n    uint256 _payAmount = 10;\n    _jbETHPaymentTerminal.pay{value: _payAmount}(\n      projectId,\n      100,\n      address(0),\n      _user,\n      0,\n      false,\n      'Take my money!',\n      new bytes(0)\n    );\n\n    // Minted 1 NFT\n    assertEq(IERC721(NFTRewardDataSource).balanceOf(_user), 1);\n\n    // Now, we make the payment but supply _dontMint metadata\n    bool _dontMint = true;\n    uint16[] memory empty;\n    _jbETHPaymentTerminal.pay{value: _payAmount}(\n      projectId,\n      100,\n      address(0),\n      _user,\n      0,\n      false,\n      'Take my money!',\n      //new bytes(0)\n      abi.encode(\n        bytes32(0),\n        type(IJB721Delegate).interfaceId,\n        _dontMint,\n        false,\n        false,\n        empty\n        )\n    );\n\n    // NFT not minted\n    assertEq(IERC721(NFTRewardDataSource).balanceOf(_user), 1);\n\n    // Check that credits of user is still the same as before even though we have made the payment\n    assertEq(IJBTiered721Delegate(NFTRewardDataSource).creditsOf(_user),_creditBefore);\n\n  }\n"
                ],
                "Type": " Making a payment to the protocol with  _dontMint  parameter will result in lost fund for user.",
                "Description": "*Submitted by yixxas(https://github.com/code-423n4/2022-10-juicebox-findings/issues/45), also found by minhquanym(https://github.com/code-423n4/2022-10-juicebox-findings/issues/157) and cccz(https://github.com/code-423n4/2022-10-juicebox-findings/issues/84)*\n\nUser will have their funds lost if they tries to pay the protocol with _dontMint = False. A payment made with this parameter set should increase the creditsOf[] balance of user.\n\nIn _processPayment(), creditsOf[_data.beneficiary] is updated at the end if there are leftover funds. However, If metadata is provided and _dontMint == true, it immediately returns.\nJBTiered721Delegate.sol#L524-L590(https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L524-L590)\n\nsolidity\n  function _processPayment(JBDidPayData calldata _data) internal override {\n    // Keep a reference to the amount of credits the beneficiary already has.\n    uint256 _credits = creditsOf[_data.beneficiary];\n    ...\n    if (\n      _data.metadata.length  36 &&\n      bytes4(_data.metadata[32:36]) == type(IJB721Delegate).interfaceId\n    ) {\n      ...\n      // Don't mint if not desired.\n      if (_dontMint) return;\n      ...\n    }\n    ...\n    // If there are funds leftover, mint the best available with it.\n    if (_leftoverAmount != 0) {\n      _leftoverAmount = _mintBestAvailableTier(\n        _leftoverAmount,\n        _data.beneficiary,\n        _expectMintFromExtraFunds\n      );\n\n      if (_leftoverAmount != 0) {\n        // Make sure there are no leftover funds after minting if not expected.\n        if (_dontOverspend) revert OVERSPENDING();\n\n        // Increment the leftover amount.\n        creditsOf[_data.beneficiary] = _leftoverAmount;\n      } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n    } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n  }\n\n\n\nI've wrote a coded POC to illustrate this. It uses the same Foundry environment used by the project. Simply copy this function to E2E.t.sol to verify.\n\nsolidity\n  function testPaymentNotAddedToCreditsOf() public{\n    address _user = address(bytes20(keccak256('user')));\n    (\n      JBDeployTiered721DelegateData memory NFTRewardDeployerData,\n      JBLaunchProjectData memory launchProjectData\n    ) = createData();\n\n    uint256 projectId = deployer.launchProjectFor(\n      _projectOwner,\n      NFTRewardDeployerData,\n      launchProjectData\n    );\n\n    // Get the dataSource\n    IJBTiered721Delegate _delegate = IJBTiered721Delegate(\n      _jbFundingCycleStore.currentOf(projectId).dataSource()\n    );\n\n    address NFTRewardDataSource = _jbFundingCycleStore.currentOf(projectId).dataSource();\n\n    uint256 _creditBefore = IJBTiered721Delegate(NFTRewardDataSource).creditsOf(_user);\n\n    // Project is initiated with 10 different tiers with contributionFee of 10,20,30,40, .... , 100\n\n    // Make payment to mint 1 NFT\n    uint256 _payAmount = 10;\n    _jbETHPaymentTerminal.pay{value: _payAmount}(\n      projectId,\n      100,\n      address(0),\n      _user,\n      0,\n      false,\n      'Take my money!',\n      new bytes(0)\n    );\n\n    // Minted 1 NFT\n    assertEq(IERC721(NFTRewardDataSource).balanceOf(_user), 1);\n\n    // Now, we make the payment but supply _dontMint metadata\n    bool _dontMint = true;\n    uint16[] memory empty;\n    _jbETHPaymentTerminal.pay{value: _payAmount}(\n      projectId,\n      100,\n      address(0),\n      _user,\n      0,\n      false,\n      'Take my money!',\n      //new bytes(0)\n      abi.encode(\n        bytes32(0),\n        type(IJB721Delegate).interfaceId,\n        _dontMint,\n        false,\n        false,\n        empty\n        )\n    );\n\n    // NFT not minted\n    assertEq(IERC721(NFTRewardDataSource).balanceOf(_user), 1);\n\n    // Check that credits of user is still the same as before even though we have made the payment\n    assertEq(IJBTiered721Delegate(NFTRewardDataSource).creditsOf(_user),_creditBefore);\n\n  }\n\n\n\nFoundry\n\n",
                "Repair": "\nUpdate the creditsOf[] in the if(_dontMint) check.\n\ndiff\nif(_dontMint) return;\n+ if(_dontMint){ creditsOf[_data.beneficiary] += _value; }\n\n\nmejango (Juicebox DAO) commented on duplicate issue #157(https://github.com/code-423n4/2022-10-juicebox-findings/issues/157#issuecomment-1289367091):\n mixed feels. _dontMint basically says \"Save me gas at all costs.\". I see the argument for value leaking being bad though. will mull over.\n\ndrgorillamd (Juicebox DAO) commented on duplicate issue #157(https://github.com/code-423n4/2022-10-juicebox-findings/issues/157#issuecomment-1298417807):\n paying small amounts (under the floor or with dontMint) only to save them to later mint is a bit of a nonsense - it's way cheaper to just not pay, save in an eoa then mint within the same tx.\n \n I have the feeling the severity is based on seeing _credit as a saving account, while it's rather something to collect leftovers.\n \n Anyway, we changed it, but not sure of high sev on this one, happy to see others' point of view.\n\nPicodes (judge) commented(https://github.com/code-423n4/2022-10-juicebox-findings/issues/157#issuecomment-1303536360):\n @drgorillamd @mejango I have to say that I don't see why someone would use the dontMint flag in the first place. Wasn't the original intent to use this flag specifically to modify _credit without minting?\n In the meantime I'll keep the High label for this one, the dontMint functionality being flawed and leading to a loss of funds. \n\ndrgorillamd (Juicebox DAO) commented(https://github.com/code-423n4/2022-10-juicebox-findings/issues/157#issuecomment-1304540813):\n @Picodes nftReward is just an extension plugged into a Jb project - dontMint is to avoid forcing users of the project who don't want a nft reward when contributing, i.e. \"classic\" use of a Jb project.\n The use case we had in mind was smaller payers, wanting to get the erc20 (or even just donating), without the gas burden of a nft reward (which might, on L1, sometimes be more than the contribution itself).\n Does that make sense?\n\nPicodes (judge) commented(https://github.com/code-423n4/2022-10-juicebox-findings/issues/157#issuecomment-1304553910):\n Definitely, thanks for the clarification @drgorillamd.\n\nPicodes (judge) commented(https://github.com/code-423n4/2022-10-juicebox-findings/issues/157#issuecomment-1373365444):\n The final decision for this issue was to keep the high severity because of the leak of value and the possibility that some users use the function thinking it will change _credit, despite the fact that it was not the original intent of the code.\n\nmejango (Juicebox DAO) commented(https://github.com/code-423n4/2022-10-juicebox-findings/issues/157#issuecomment-1374569372):\n We ended up adding credits even when _dontMint is true!!<br\n It was a last minute design decision, initially we marked the issue as \"Disagree with severity\" and we were planning on keeping the code unchanged since it didnt pose a risk and was working as designed.<br\n We ended up changing the design, but the wardens' feedback was ultimately helpful!<br\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [],
                "Type": " Minting and redeeming will break for fully minted tiers with  reserveRate != 0  and  reserveRate / MaxReserveRate  tokens burned",
                "Description": "*Submitted by 0x52(https://github.com/code-423n4/2022-10-juicebox-findings/issues/113)*\n\nMinting and redeeming become impossible.\n\n\n    uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -\n      _storedTier.remainingQuantity -\n      _reserveTokensMinted;\n\n    uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);\n\n    uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;\n\n    if (_numerator JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable  0)\n      ++_numberReservedTokensMintable;\n\n    return _numberReservedTokensMintable _reserveTokensMinted;\n\nThe lines above are taken from JBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor and used to calculate and return the available number of reserve tokens that can be minted. Since the return statement doesn't check that _numberReservedTokensMintable = _reserveTokensMinted, it will revert under those circumstances. The issue is that there are legitimate circumstances in which this becomes false. If a tier is fully minted then all reserve tokens are mintable. When the tier begins to redeem, _numberReservedTokensMintable will fall under _reserveTokensMinted, permanently breaking minting and redeeming. Minting is broken because all mint functions directly call _numberOfReservedTokensOutstandingFor. Redeeming is broken because the redeem callback (JB721Delegate#redeemParams) calls _totalRedemtionWeight which calls _numberOfReservedTokensOutstandingFor.\n\nExample:\n\nA tier has a reserveRate of 100 (1/100 tokens reserved) and an initialQuantity of 10000. We assume that the tier has been fully minted, that is, _reserveTokensMinted is 100 and remainingQuantity = 0. Now we begin burning the tokens. Let's run through the lines above after 100 tokens have been burned (remainingQuantity = 100):\n\n_numberOfNonReservedMinted = 10000 100 100 = 9800\n\n_numerator = 9800 &ast; 100 = 980000\n\n_numberReservedTokensMintable = 980000 / 10000 = 98\n\nSince _numberReservedTokensMintable < _reserveTokensMinted the line will underflow and revert.\n\nJBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor will now revert every time it is called. This affects all minting functions as well as totalRedemptionWeight. Since those functions now revert when called, it is impossible to mint or redeem anymore NFTs.\n\n",
                "Repair": "\nAdd a check before returning:\n\n    +   if (_reserveTokensMinted  _numberReservedTokensMintable) {\n    +       return 0;\n    +   }\n\n        return _numberReservedTokensMintable _reserveTokensMinted;\n\nmejango (Juicebox DAO) confirmed(https://github.com/code-423n4/2022-10-juicebox-findings/issues/113) \n\nTrust (warden) commented(https://github.com/code-423n4/2022-10-juicebox-findings/issues/113#issuecomment-1288218772):\n  The root cause seems to be that there is no tracking of reserve tokens burnt.\n\nmejango (Juicebox DAO) commented(https://github.com/code-423n4/2022-10-juicebox-findings/issues/113#issuecomment-1289371161):\n  @Trust fair. this would require extra storage to track which tokenIDs were minted as reserves. could be a nice-to-have, and also used to prevent this issue.\n\nPicodes (judge) commented(https://github.com/code-423n4/2022-10-juicebox-findings/issues/113#issuecomment-1303719893):\n  Without tracking the number of burnt tokens, the mitigation suggested by the warden avoids the underflow so solves the main issue, which is that minting and redeeming break\n \n Accounting for numberOfBurnedReservesFor may help fixing the math but the underflow would still be possible if only non reserve tokens are burned\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n// Add the tier's contribution floor multiplied by the quantity minted.\nweight +=\n  (_storedTier.contributionFloor *\n    (_storedTier.initialQuantity _storedTier.remainingQuantity)) +\n  _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);\n"
                ],
                "Type": " Outstanding reserved tokens are incorrectly counted in total redemption weight",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-10-juicebox-findings/issues/129), also found by Trust(https://github.com/code-423n4/2022-10-juicebox-findings/issues/194), ladboy233(https://github.com/code-423n4/2022-10-juicebox-findings/issues/43), and cccz(https://github.com/code-423n4/2022-10-juicebox-findings/issues/28)*\n\nThe amounts redeemed in overflow redemption can be calculated incorrectly due to incorrect accounting of the outstanding number of reserved tokens.\n\n\nProject contributors are allowed to redeem their NFT tokens for a portion of the overflow (excessive funded amounts). The amount a contributor receives is calculated as overflow &ast; (user's redemption rate / total redemption weight)(https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L135-L142), where user's redemption weight is the total contribution floor of all their NFTs(https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L532-L539) and total redemption weight is the total contribution floor of all minted NFTs(https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566). Since the total redemption weight is the sum of individual contributor redemption weights, the amount they can redeem is proportional to their contribution.\n\nHowever, the total redemption weight calculation incorrectly accounts outstanding reserved tokens ([JBTiered721DelegateStore.sol#L563-L566(https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566)):\n\nsolidity\n// Add the tier's contribution floor multiplied by the quantity minted.\nweight +=\n  (_storedTier.contributionFloor *\n    (_storedTier.initialQuantity _storedTier.remainingQuantity)) +\n  _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);\n\n\nSpecifically, the *number* of reserved tokens is added to the *weight* of minted tokens. This disrupts the redemption amount calculation formula since the total redemption weight is in fact not the sum of individual contributor redemption weights.\n\n",
                "Repair": "\nTwo options can be seen:\n\n1.  if the outstanding number of reserved tokens is considered minted (which seems to be so, judging by this logic(https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1058-L1063)) then it needs to be added to the quantity, i.e.:\n    diff\n    --a/contracts/JBTiered721DelegateStore.sol\n    +++ b/contracts/JBTiered721DelegateStore.sol\n    @@ -562,8 +562,7 @@ contract JBTiered721DelegateStore is IJBTiered721DelegateStore {\n          // Add the tier's contribution floor multiplied by the quantity minted.\n          weight +=\n            (_storedTier.contributionFloor *\n             (_storedTier.initialQuantity _storedTier.remainingQuantity)) +\n           _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);\n    +          (_storedTier.initialQuantity _storedTier.remainingQuantity +\n    +           _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier)));\n\n          unchecked {\n            ++_i;\n    \n2.  if it's not considered minted, then it shouldn't be counted at all.\n\ndrgorillamd (Juicebox DAO) confirmed(https://github.com/code-423n4/2022-10-juicebox-findings/issues/129) \n\nPicodes (judge) upgraded severity(https://github.com/code-423n4/2022-10-juicebox-findings/issues/129#issuecomment-1303554688):\n  As the redeemed amounts are at stake, upgrading to High\n\n\n*\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [],
                "Type": " Redemption weight of tiered NFTs miscalculates, making users redeem incorrect amounts - Bug #1",
                "Description": "*Submitted by Trust(https://github.com/code-423n4/2022-10-juicebox-findings/issues/193), also found by Aymen0909(https://github.com/code-423n4/2022-10-juicebox-findings/issues/171) and 0x52(https://github.com/code-423n4/2022-10-juicebox-findings/issues/105)*\n\nRedemption weight is a concept used in Juicebox to determine investor's eligible percentage of the non-locked funds. In redeemParams, JB721Delegate calculates user's share using:\n\n    uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds);\n    uint256 _total = _totalRedemptionWeight();\n    uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);\n\n_totalRedemptionWeight eventually is implemented in DelegateStore:\n\n    for (uint256 _i; _i < _maxTierId; ) {\n      // Keep a reference to the stored tier.\n      _storedTier = _storedTierOf[_nft][_i + 1];\n      // Add the tier's contribution floor multiplied by the quantity minted.\n      weight +=\n        (_storedTier.contributionFloor *\n          (_storedTier.initialQuantity _storedTier.remainingQuantity)) +\n        _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);\n      unchecked {\n        ++_i;\n      }\n    }\n\nIf we pay attention to _numberOfReservedTokensOutstandingFor() call, we can see it is called with tierId = i, yet storedTier of i+1. It is definitely not the intention as for example, recordMintReservesFor() uses the function correctly:\n\n    function recordMintReservesFor(uint256 _tierId, uint256 _count)\n      external\n      override\n      returns (uint256[] memory tokenIds)\n    {\n      // Get a reference to the tier.\n      JBStored721Tier storage _storedTier = _storedTierOf[msg.sender][_tierId];\n      // Get a reference to the number of reserved tokens mintable for the tier.\n      uint256 _numberOfReservedTokensOutstanding = _numberOfReservedTokensOutstandingFor(\n        msg.sender,\n        _tierId,\n        _storedTier\n      );\n      ...\n\nThe impact of this bug is incorrect calculation of the weight of user's contributions. The initialQuantity and remainingQuantity values are taken from the correct tier, but _reserveTokensMinted minted is taken from previous tier. In the case where _reserveTokensMinted is smaller than correct value, for example tierID=0 which is empty, the outstanding value returned is larger, meaning weight is larger and redemptions are worth less. In the opposite case, where lower tierID has higher _reserveTokensMinted, the redemptions will receive *more* payout than they should.\n\n\nUsers of projects can receive less or more funds than they are eligible for when redeeming NFT rewards.\n\n\n1. Suppose we have a project with 2 tiers, reserve ratio = 50%, redemption ratio = 100%:\n\n|        |              |                  |                    |                 |                      |\n| -----| -----------| ---------------| -----------------| --------------| -------------------|\n| Tier   | Contribution | Initial quantity | Remaining quantity | Reserves minted | Reserves outstanding |\n| Tier 1 | 50           | 10               | 3                  | 1               | 2                    |\n| Tier 2 | 100          | 30               | 2                  | 8               | 2                    |\n\nWhen calculating totalRedemptionWeight(), the correct result is\n\n50 &ast; (10 3) + 2 + 100 &ast; (30-2) + 2 = 3154\n\nThe wrong result will be:\n\n50 &ast; (10 -3) + 4 + 100 &ast; (30-2) + 13  = 3167\n\nTherefore, when users redeem NFT rewards, they will get less value than they are eligible for. Note that totalRedemptionWeight() has an *additional* bug where the reserve amount is not multiplied by the contribution, which is discussed in another submission. If it would be calculated correctly, the correct weight would be 3450.\n\n",
                "Repair": "\nChange the calculation to:\n\n    _numberOfReservedTokensOutstandingFor(_nft, _i+1, _storedTier);\n\n### Additional discussion\n\nLikelihood of impact is very high, because the conditions will arise naturally (different tiers, different reserve minted count for each tier, user calls redeem). \nSeverity of impact is high because users receive less or more tokens than they are eligible for.\n\nInitially I thought this bug could allow attacker to steal entire unlocked project funds, using a mint/burn loop. However, this would not be profitable because their calculated share of the funds would always be at most what they put in, because reserve tokens are printed out of thin air.\n\nmejango (Juicebox DAO) confirmed(https://github.com/code-423n4/2022-10-juicebox-findings/issues/193) \n\n\n*\n \n\n"
            }
        ]
    }
]