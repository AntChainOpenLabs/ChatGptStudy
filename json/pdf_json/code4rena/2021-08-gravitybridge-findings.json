[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": " Cannot actually submit evidence",
                "Description": "\nThe SubmitBadSignatureEvidence is not actually registered in the handler and hence no one can actually submit this message, rendering the message useless. This harms the security model of Gravity since validators have no disincentive to attempt to collude and take over the bridge.\n\nThe SubmitBadSignatureEvidence handler is omitted from module/x/gravity/handler.go\n\nVisual inspection\n\n",
                "Repair": "Handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go\n\njkilpatr (Althea) confirmed and patched(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/64#issuecomment-916884977):\n  This was resolved here\n\n https://github.com/althea-net/cosmos-gravity-bridge/commit/ad6bd78d4c968c3eef5a8ab7a38b42cd3269d186\n\n This is a valid bug considering this fix is not included in the code hash up for review.\n\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\ndata memory bytes = hex\"f7955637000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000461746f6d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000673796d626fc00000000000000000000000000000000000000000000000000000\";\ngravity.call(data);\n",
                    "//solidity\n    ERC20DeployedEvent(\"atom\", \"name\", \u276eutf8 decode failed\u276f: 0x73796d626fc0, 18, 2)\n",
                    "//rust\n    let symbol = String::from_utf8(input.data[index_start..index_end].to_vec());\n    trace!(\"Symbol {:?}\", symbol);\n    if symbol.is_err() {\n        return Err(GravityError::InvalidEventLogError(format!(\n            \"{:?} is not valid utf8, probably incorrect parsing\",\n            symbol\n        )));\n    }\n",
                    "//rust\nlet erc20_deploys = Erc20DeployedEvent::from_logs(&deploys)?;\n"
                ],
                "Type": " Freeze Bridge via Non-UTF8 Token Name/Symbol/Denom",
                "Description": "\nManual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. The fix is non-trivial and likely requires significant redesign.\n\nNote the c0 in the last argument of the call data (invalid UTF8).\n\nIt can be triggered with:\n\nsolidity\ndata memory bytes = hex\"f7955637000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000461746f6d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000673796d626fc00000000000000000000000000000000000000000000000000000\";\ngravity.call(data);\n\n\nThe log output is as follows:\nsolidity\n    ERC20DeployedEvent(\"atom\", \"name\", \u276eutf8 decode failed\u276f: 0x73796d626fc0, 18, 2)\n\n\nWhich hits this code path(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/gravity_utils/src/types/ethereum_events.rs#L431-L438):\n\nrust\n    let symbol = String::from_utf8(input.data[index_start..index_end].to_vec());\n    trace!(\"Symbol {:?}\", symbol);\n    if symbol.is_err() {\n        return Err(GravityError::InvalidEventLogError(format!(\n            \"{:?} is not valid utf8, probably incorrect parsing\",\n            symbol\n        )));\n    }\n\n\nAnd would cause an early return here(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L99):\n\nrust\nlet erc20_deploys = Erc20DeployedEvent::from_logs(&deploys)?;\n\n\nNever updating last checked block and therefore, this will freeze the bridge by disallowing any attestations to take place. This is an extremely low cost way to bring down the network.\n\n",
                "Repair": "This is a hard one. Re-syncing is permanently borked because, on the Go side, there is seemingly no way to ever process the event nonce because protobufs do not handle non-utf8 strings. The validator would report they need event nonce N from the orchestrator, but they can never parse the event N. Seemingly, validators & orchestrators would have to know to ignore that specific event nonce. But it is a permissionless function, so it can be used to effectively permanently stop attestations & the bridge until a new Gravity.sol is deployed.\n\nOne potential fix is to check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. This likely will be expensive though. Alternatively, you could require that validators sign ERC20 creation requests and perform checks before the transaction is sent.\n\njkilpatr (Althea) confirmed(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/4#issuecomment-917151454):\n  This is a valid and well considered bug.\n\n I do disagree about the difficulty of the fix though, if we fail to parse the token name as utf8 we can just encode the bytes themselves in hex and pass that along. The result will be perfectly valid if a little unergonomic.\n\nalbertchon (judge) commented(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/4#issuecomment-925867313):\n  Clever, great catch\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "//rust\nlet erc20_deployed = web3\n    .check_for_events(\n        starting_block.clone(),\n        Some(latest_block.clone()),\n        vec![gravity_contract_address],\n        vec![ERC20_DEPLOYED_EVENT_SIG],\n    )\n    .await;\n",
                    "//rust\npub async fn eth_get_logs(&self, new_filter: NewFilter) - Result<Vec<Log, Web3Error {\n    self.jsonrpc_client\n        .request_method(\n            \"eth_getLogs\",\n            vec![new_filter],\n            self.timeout,\n            Some(10_000_000),\n        )\n        .await\n}\n",
                    "//rust\nlet res: Response<R = match res.json().limit(limit).await {\n    Ok(val) = val,\n    Err(e) = return Err(Web3Error::BadResponse(format!(\"Web3 Error {}\", e))),\n};\n",
                    "//solidity\nfunction deployERC20(\n    string memory _cosmosDenom,\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n) public {\n    // Deploy an ERC20 with entire supply granted to Gravity.sol\n    CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);\n\n    // Fire an event to let the Cosmos module know\n    state_lastEventNonce = state_lastEventNonce.add(1);\n    emit ERC20DeployedEvent(\n        _cosmosDenom,\n        address(erc20),\n        _name,\n        _symbol,\n        _decimals,\n        state_lastEventNonce\n    );\n}\n"
                ],
                "Type": " Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms",
                "Description": "\nEthereum Oracles watch for events on the Gravity.sol contract on the Ethereum blockchain. This is performed in the check_for_events(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L23) function, and run in the eth_oracle_main_loop(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/main_loop.rs#L94).\n\nIn this function, there is the following code snippet(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L66-L73):\n\nrust\nlet erc20_deployed = web3\n    .check_for_events(\n        starting_block.clone(),\n        Some(latest_block.clone()),\n        vec![gravity_contract_address],\n        vec![ERC20_DEPLOYED_EVENT_SIG],\n    )\n    .await;\n\n\nThis snippet leverages the web30 library to check for events from the starting_block to the latest_block. Inside the web30 library this nets out to calling:\n\nrust\npub async fn eth_get_logs(&self, new_filter: NewFilter) - Result<Vec<Log, Web3Error {\n    self.jsonrpc_client\n        .request_method(\n            \"eth_getLogs\",\n            vec![new_filter],\n            self.timeout,\n            Some(10_000_000),\n        )\n        .await\n}\n\n\nThe 10_000_000 specifies the maximum size of the return in bytes and returns an error if the return is larger:\n\nrust\nlet res: Response<R = match res.json().limit(limit).await {\n    Ok(val) = val,\n    Err(e) = return Err(Web3Error::BadResponse(format!(\"Web3 Error {}\", e))),\n};\n\n\nThis can be triggered at will and keep the loop in a perpetual state of returning the GravityError::EthereumRestError(Web3Error::BadResponse(\n            \"Failed to get logs!\".to_string())) error. To force the node into this state, you just have to deploy ERC20s generated by the public function in Gravity.sol(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L546-L565):\n\nsolidity\nfunction deployERC20(\n    string memory _cosmosDenom,\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n) public {\n    // Deploy an ERC20 with entire supply granted to Gravity.sol\n    CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);\n\n    // Fire an event to let the Cosmos module know\n    state_lastEventNonce = state_lastEventNonce.add(1);\n    emit ERC20DeployedEvent(\n        _cosmosDenom,\n        address(erc20),\n        _name,\n        _symbol,\n        _decimals,\n        state_lastEventNonce\n    );\n}\n\n\nAnd specify a large string as the denom, name, or symbol.\n\nIf an attacker uses the denom as the attack vector, they save significant gas costing just 256 per additional 32 bytes. For other cases, to avoid gas overhead, you can have the string be mostly 0s resulting in just 584 gas per additional 32 bytes. This leaves it feasible to surpass the 10mb response data in the 6 block buffer. This would throw every ethereum oracle into a state of perpetual errors and all would fall out of sync with the ethereum blockchain. This would result in the batches, logic calls, deposits, ERC20 creations, and valset updates to never receive attestations from other validators because their ethereum oracles would be down; the bridge would be frozen and remain frozen until the bug is fixed due to get_last_checked_block.\n\nThis will freeze the bridge by disallowing attestations to take place.\n\nThis requires a patch to reenable the bridge.\n\n",
                "Repair": "Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.\n\nAdditionally, you could require that validators sign ERC20 creation requests.\n\njkilpatr (Althea) confirmed(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/5#issuecomment-917150363):\n  Excellent bug report.\n\n I just ran into the buffer limit issue this morning with an Ethereum block. I agree handling this error correctly is essential to long term reliability.\n\nalbertchon (judge) commented(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/5#issuecomment-925869600):\n  Nice :)\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "//rust\nlet mut all_valset_events = web3\n    .check_for_events(\n        end_search.clone(),\n        Some(current_block.clone()),\n        vec![gravity_contract_address],\n        vec![VALSET_UPDATED_EVENT_SIG],\n    )\n    .await?;\n"
                ],
                "Type": " Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayers",
                "Description": "\nIn a similar vein to \"Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms\", a sufficiently large validator set or sufficiently rapid validator update, could cause both the eth_oracle_main_loop and relayer_main_loop to fall into a state of perpetual errors. In find_latest_valset, we call(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/relayer/src/find_latest_valset.rs#L33-L40):\n\nrust\nlet mut all_valset_events = web3\n    .check_for_events(\n        end_search.clone(),\n        Some(current_block.clone()),\n        vec![gravity_contract_address],\n        vec![VALSET_UPDATED_EVENT_SIG],\n    )\n    .await?;\n\n\nWhich if the validator set is sufficiently large, or sufficiently rapidly updated, continuoussly return an error if the logs in a 5000 (see: const BLOCKS_TO_SEARCH: u128 = 5_000u128;) block range are in excess of 10mb. Cosmos hub says they will be pushing the number of validators up to 300 (currently 125). At 300, each log would produce 19328 bytes of data (4*32+64*300). Given this, there must be below 517 updates per 5000 block range otherwise the node will fall out of sync.\n\nThis will freeze the bridge by disallowing attestations to take place.\n\nThis requires a patch to reenable the bridge.\n\n",
                "Repair": "\nHandle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.\n\njkilpatr (Althea) confirmed(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/6#issuecomment-916968683):\n  This is a solid report with detailed computations to back it up. I appreciate it and will take actions in our web3 library to prevent this exact scenario.\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [],
                "Type": " The function  updateValset  does not have enough sanity checks",
                "Description": "\nIn the updateValset(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L224) function, the current set of validators adds a new set.\n\nIt is missing the check that the combined power of all new validators is above the state_powerThreshold. If this is false, then the contract is effectively stuck. Consider adding an on-chain check for this.\n\nIt is also worth adding a that the size of the new validator check is less than a certain number.\n\nHere is a rough calculation explaining how 10000 validators (an extreme example) is too much:\n\n1.  Let us say that the new set of validators have the property that at least, say, N validators are needed to get the total threshold above state_powerThreshold.\n2.  Since each validating signature requires a call to ecrecover, costing at least 3000 gas, the minimum gas needed for getting a proposal over state_powerThreshold would be N * 3000\n3.  N * 3000 cannot be more than the block.gaslimit Currently, this puts N to be less than 10000\n\nAnother approach to solve the above potential problems is to do the updating as a two step process:\n\n1.  The current set of validators proposes a pending set of validators.\n2.  And the pending set of validators need to do the transition to become the new set of validators. Going through the same threshold checks.\n\nThis guarantees that the new set of validators has enough power to pass threshold and doesn't have gas limit issues in doing so.\n\njkilpatr (Althea) confirmed(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/51#issuecomment-916505723):\n  Semi duplicate of #63, #37 which describes the power sum issue\n\n Also a semi duplicate of #9 which describes the block size issue\n\n these are both valid and should be assigned congruent severity with the duplicates.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-02",
                "Location": [
                    "//rust\nlet logic_call_executed_events = web3\n    .check_for_events(\n        end_search.clone(),\n        Some(current_block.clone()),\n        vec![gravity_contract_address],\n        vec![LOGIC_CALL_EVENT_SIG],\n    )\n    .await;\n",
                    "//rust\nfor event in logic_call_executed_events {\n    match LogicCallExecutedEvent::from_log(&event) {\n        Ok(call) = {\n            trace!(\n                \"{} LogicCall event nonce {} last event nonce\",\n                call.event_nonce,\n                last_event_nonce\n            );\n            if upcast(call.event_nonce) == last_event_nonce && event.block_number.is_some()\n            {\n                return event.block_number.unwrap();\n            }\n        }\n        Err(e) = error!(\"Got ERC20Deployed event that we can't parse {}\", e),\n    }\n}\n",
                    "//rust\nimpl LogicCallExecutedEvent {\n    pub fn from_log(_input: &Log) - Result<LogicCallExecutedEvent, GravityError {\n        unimplemented!()\n    }\n    // snip...\n}\n",
                    "//rust\nlet logic_calls = LogicCallExecutedEvent::from_logs(&logic_calls)?;\n"
                ],
                "Type": " Crash Eth Oracle On Any  LogicCallEvent ",
                "Description": "\nLikelihood: high\n\nIn eth_oracle_main_loop, get_last_checked_block is called. Followed by:\n\nrust\nlet logic_call_executed_events = web3\n    .check_for_events(\n        end_search.clone(),\n        Some(current_block.clone()),\n        vec![gravity_contract_address],\n        vec![LOGIC_CALL_EVENT_SIG],\n    )\n    .await;\n\n\nand may hit the code path:\n\nrust\nfor event in logic_call_executed_events {\n    match LogicCallExecutedEvent::from_log(&event) {\n        Ok(call) = {\n            trace!(\n                \"{} LogicCall event nonce {} last event nonce\",\n                call.event_nonce,\n                last_event_nonce\n            );\n            if upcast(call.event_nonce) == last_event_nonce && event.block_number.is_some()\n            {\n                return event.block_number.unwrap();\n            }\n        }\n        Err(e) = error!(\"Got ERC20Deployed event that we can't parse {}\", e),\n    }\n}\n\n\nBut will panic at from_log here:\n\nrust\nimpl LogicCallExecutedEvent {\n    pub fn from_log(_input: &Log) - Result<LogicCallExecutedEvent, GravityError {\n        unimplemented!()\n    }\n    // snip...\n}\n\n\nIt can/will also be triggered here in check_for_events:\n\nrust\nlet logic_calls = LogicCallExecutedEvent::from_logs(&logic_calls)?;\n\n\nAttestations will be frozen until patched.\n\n",
                "Repair": "Implement the method.\n\njkilpatr (Althea) confirmed(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/11#issuecomment-917137570):\n  Valid issue, but with zero probability. Since there is nothing on the module side that currently triggers arbitrary logic.\n\n Despite the fact that it can't currently happen this is still a good report.\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": " Win all relayer rewards",
                "Description": "\n\"Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayer\" can affect just the relayers & not affect the oracle in certain circumstances. This could result in valid attestations, but prevent any of the other relayers from being able to participate in the execution. While the other relayers are down from the other attack, the attacker can win all batch, logic, and valset rewards as their node is the only relayer running. This is possible because find_latest_valset is run in the main relayer loop and everytime tries for 5000 blocks of logs.\n\njkilpatr (Althea) confirmed(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/7#issuecomment-917140352):\n  This is a reasonable consequence of #6\n\n I consider it medium risk because it reduces the number of relayers active, not because of the reward assignment\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-04",
                "Location": [],
                "Type": " Incorrect accounting on transfer-on-fee/deflationary tokens in  Gravity ",
                "Description": "\nThe sendToCosmos function of Gravity transfers _amount of _tokenContract from the sender using the function transferFrom. If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than _amount. However, since _amount is passed as a parameter of the SendToCosmosEvent event, the Cosmos side will think more tokens are locked on the Ethereum side.\n\nReferenced code:\n* Gravity.sol#L535(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L535)\n* Gravity.sol#L541(https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L541)\n\n",
                "Repair": "\nConsider getting the received amount by calculating the difference of token balance (using balanceOf) before and after the transferFrom.\n\njkilpatr (Althea) confirmed(https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/62#issuecomment-916196186):\n  This is a valid issue, it does present the ability to 'steal' tokens from the bridge, so I think that justifies the severity.\n\n If user (A) deposits a deflationary token and gets slightly more vouchers than where actually deposited into the bridge upon withdraw they could steal tokens from user (B) who had also deposited.\n\n\n"
            }
        ]
    }
]