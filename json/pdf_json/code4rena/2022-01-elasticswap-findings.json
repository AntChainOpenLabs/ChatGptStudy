[
    {
        "Code": "//SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.4;\n\nimport \"../libraries/MathLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IExchangeFactory.sol\";\n\n/**\n * @title Exchange contract for Elastic Swap representing a single ERC20 pair of tokens to be swapped.\n * @author Elastic DAO\n * @notice This contract provides all of the needed functionality for a liquidity provider to supply/withdraw ERC20\n * tokens and traders to swap tokens for one another.\n */\ncontract Exchange is ERC20, ReentrancyGuard {\n    using MathLib for uint256;\n    using SafeERC20 for IERC20;\n\n    address public immutable baseToken; // address of ERC20 base token (elastic or fixed supply)\n    address public immutable quoteToken; // address of ERC20 quote token (WETH or a stable coin w/ fixed supply)\n    address public immutable exchangeFactoryAddress;\n\n    uint256 public constant TOTAL_LIQUIDITY_FEE = 30; // fee provided to liquidity providers + DAO in basis points\n\n    MathLib.InternalBalances public internalBalances =\n        MathLib.InternalBalances(0, 0, 0);\n\n    event AddLiquidity(\n        address indexed liquidityProvider,\n        uint256 baseTokenQtyAdded,\n        uint256 quoteTokenQtyAdded\n    );\n    event RemoveLiquidity(\n        address indexed liquidityProvider,\n        uint256 baseTokenQtyRemoved,\n        uint256 quoteTokenQtyRemoved\n    );\n    event Swap(\n        address indexed sender,\n        uint256 baseTokenQtyIn,\n        uint256 quoteTokenQtyIn,\n        uint256 baseTokenQtyOut,\n        uint256 quoteTokenQtyOut\n    );\n\n    /**\n     * @dev Called to check timestamps from users for expiration of their calls.\n     * Used in place of a modifier for byte code savings\n     */\n    function isNotExpired(uint256 _expirationTimeStamp) internal view {\n        require(_expirationTimeStamp >= block.timestamp, \"Exchange: EXPIRED\");\n    }\n\n    /**\n     * @notice called by the exchange factory to create a new erc20 token swap pair (do not call this directly!)\n     * @param _name The human readable name of this pair (also used for the liquidity token name)\n     * @param _symbol Shortened symbol for trading pair (also used for the liquidity token symbol)\n     * @param _baseToken address of the ERC20 base token in the pair. This token can have a fixed or elastic supply\n     * @param _quoteToken address of the ERC20 quote token in the pair. This token is assumed to have a fixed supply.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _baseToken,\n        address _quoteToken,\n        address _exchangeFactoryAddress\n    ) ERC20(_name, _symbol) {\n        baseToken = _baseToken;\n        quoteToken = _quoteToken;\n        exchangeFactoryAddress = _exchangeFactoryAddress;\n    }\n\n    /**\n     * @notice primary entry point for a liquidity provider to add new liquidity (base and quote tokens) to the exchange\n     * and receive liquidity tokens in return.\n     * Requires approvals to be granted to this exchange for both base and quote tokens.\n     * @param _baseTokenQtyDesired qty of baseTokens that you would like to add to the exchange\n     * @param _quoteTokenQtyDesired qty of quoteTokens that you would like to add to the exchange\n     * @param _baseTokenQtyMin minimum acceptable qty of baseTokens that will be added (or transaction will revert)\n     * @param _quoteTokenQtyMin minimum acceptable qty of quoteTokens that will be added (or transaction will revert)\n     * @param _liquidityTokenRecipient address for the exchange to issue the resulting liquidity tokens from\n     * this transaction to\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function addLiquidity(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        address _liquidityTokenRecipient,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() {\n        isNotExpired(_expirationTimestamp);\n\n        MathLib.TokenQtys memory tokenQtys =\n            MathLib.calculateAddLiquidityQuantities(\n                _baseTokenQtyDesired,\n                _quoteTokenQtyDesired,\n                _baseTokenQtyMin,\n                _quoteTokenQtyMin,\n                IERC20(baseToken).balanceOf(address(this)),\n                IERC20(quoteToken).balanceOf(address(this)),\n                this.totalSupply(),\n                internalBalances\n            );\n\n        internalBalances.kLast =\n            internalBalances.baseTokenReserveQty *\n            internalBalances.quoteTokenReserveQty;\n\n        if (tokenQtys.liquidityTokenFeeQty > 0) {\n            // mint liquidity tokens to fee address for k growth.\n            _mint(\n                IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n                tokenQtys.liquidityTokenFeeQty\n            );\n        }\n        _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient\n\n        if (tokenQtys.baseTokenQty != 0) {\n            bool isExchangeEmpty =\n                IERC20(baseToken).balanceOf(address(this)) == 0;\n\n            // transfer base tokens to Exchange\n            IERC20(baseToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenQtys.baseTokenQty\n            );\n\n            if (isExchangeEmpty) {\n                require(\n                    IERC20(baseToken).balanceOf(address(this)) ==\n                        tokenQtys.baseTokenQty,\n                    \"Exchange: FEE_ON_TRANSFER_NOT_SUPPORTED\"\n                );\n            }\n        }\n\n        if (tokenQtys.quoteTokenQty != 0) {\n            // transfer quote tokens to Exchange\n            IERC20(quoteToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenQtys.quoteTokenQty\n            );\n        }\n\n        emit AddLiquidity(\n            msg.sender,\n            tokenQtys.baseTokenQty,\n            tokenQtys.quoteTokenQty\n        );\n    }\n\n    /**\n     * @notice called by a liquidity provider to redeem liquidity tokens from the exchange and receive back\n     * base and quote tokens. Required approvals to be granted to this exchange for the liquidity token\n     * @param _liquidityTokenQty qty of liquidity tokens that you would like to redeem\n     * @param _baseTokenQtyMin minimum acceptable qty of base tokens to receive back (or transaction will revert)\n     * @param _quoteTokenQtyMin minimum acceptable qty of quote tokens to receive back (or transaction will revert)\n     * @param _tokenRecipient address for the exchange to issue the resulting base and\n     * quote tokens from this transaction to\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function removeLiquidity(\n        uint256 _liquidityTokenQty,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        address _tokenRecipient,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() {\n        isNotExpired(_expirationTimestamp);\n        require(this.totalSupply() > 0, \"Exchange: INSUFFICIENT_LIQUIDITY\");\n        require(\n            _baseTokenQtyMin > 0 && _quoteTokenQtyMin > 0,\n            \"Exchange: MINS_MUST_BE_GREATER_THAN_ZERO\"\n        );\n\n        uint256 baseTokenReserveQty =\n            IERC20(baseToken).balanceOf(address(this));\n        uint256 quoteTokenReserveQty =\n            IERC20(quoteToken).balanceOf(address(this));\n\n        uint256 totalSupplyOfLiquidityTokens = this.totalSupply();\n        // calculate any DAO fees here.\n        uint256 liquidityTokenFeeQty =\n            MathLib.calculateLiquidityTokenFees(\n                totalSupplyOfLiquidityTokens,\n                internalBalances\n            );\n\n        // we need to factor this quantity in to any total supply before redemption\n        totalSupplyOfLiquidityTokens += liquidityTokenFeeQty;\n\n        uint256 baseTokenQtyToReturn =\n            (_liquidityTokenQty * baseTokenReserveQty) /\n                totalSupplyOfLiquidityTokens;\n        uint256 quoteTokenQtyToReturn =\n            (_liquidityTokenQty * quoteTokenReserveQty) /\n                totalSupplyOfLiquidityTokens;\n\n        require(\n            baseTokenQtyToReturn >= _baseTokenQtyMin,\n            \"Exchange: INSUFFICIENT_BASE_QTY\"\n        );\n\n        require(\n            quoteTokenQtyToReturn >= _quoteTokenQtyMin,\n            \"Exchange: INSUFFICIENT_QUOTE_QTY\"\n        );\n\n        // this ensure that we are removing the equivalent amount of decay\n        // when this person exits.\n        uint256 baseTokenQtyToRemoveFromInternalAccounting =\n            (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /\n                totalSupplyOfLiquidityTokens;\n\n        internalBalances\n            .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting;\n\n        // We should ensure no possible overflow here.\n        if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {\n            internalBalances.quoteTokenReserveQty = 0;\n        } else {\n            internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;\n        }\n\n        internalBalances.kLast =\n            internalBalances.baseTokenReserveQty *\n            internalBalances.quoteTokenReserveQty;\n\n        if (liquidityTokenFeeQty > 0) {\n            _mint(\n                IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n                liquidityTokenFeeQty\n            );\n        }\n\n        _burn(msg.sender, _liquidityTokenQty);\n        IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);\n        IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);\n        emit RemoveLiquidity(\n            msg.sender,\n            baseTokenQtyToReturn,\n            quoteTokenQtyToReturn\n        );\n    }\n\n    /**\n     * @notice swaps base tokens for a minimum amount of quote tokens.  Fees are included in all transactions.\n     * The exchange must be granted approvals for the base token by the caller.\n     * @param _baseTokenQty qty of base tokens to swap\n     * @param _minQuoteTokenQty minimum qty of quote tokens to receive in exchange for\n     * your base tokens (or the transaction will revert)\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function swapBaseTokenForQuoteToken(\n        uint256 _baseTokenQty,\n        uint256 _minQuoteTokenQty,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() {\n        isNotExpired(_expirationTimestamp);\n        require(\n            _baseTokenQty > 0 && _minQuoteTokenQty > 0,\n            \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n        );\n\n        uint256 quoteTokenQty =\n            MathLib.calculateQuoteTokenQty(\n                _baseTokenQty,\n                _minQuoteTokenQty,\n                TOTAL_LIQUIDITY_FEE,\n                internalBalances\n            );\n\n        IERC20(baseToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _baseTokenQty\n        );\n\n        IERC20(quoteToken).safeTransfer(msg.sender, quoteTokenQty);\n        emit Swap(msg.sender, _baseTokenQty, 0, 0, quoteTokenQty);\n    }\n\n    /**\n     * @notice swaps quote tokens for a minimum amount of base tokens.  Fees are included in all transactions.\n     * The exchange must be granted approvals for the quote token by the caller.\n     * @param _quoteTokenQty qty of quote tokens to swap\n     * @param _minBaseTokenQty minimum qty of base tokens to receive in exchange for\n     * your quote tokens (or the transaction will revert)\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function swapQuoteTokenForBaseToken(\n        uint256 _quoteTokenQty,\n        uint256 _minBaseTokenQty,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() {\n        isNotExpired(_expirationTimestamp);\n        require(\n            _quoteTokenQty > 0 && _minBaseTokenQty > 0,\n            \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n        );\n\n        uint256 baseTokenQty =\n            MathLib.calculateBaseTokenQty(\n                _quoteTokenQty,\n                _minBaseTokenQty,\n                IERC20(baseToken).balanceOf(address(this)),\n                TOTAL_LIQUIDITY_FEE,\n                internalBalances\n            );\n\n        IERC20(quoteToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _quoteTokenQty\n        );\n\n        IERC20(baseToken).safeTransfer(msg.sender, baseTokenQty);\n        emit Swap(msg.sender, 0, _quoteTokenQty, baseTokenQty, 0);\n    }\n}\n\n\n//SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.4;\n\nimport \"../contracts/Exchange.sol\";\n\n/**\n * @title MathLib\n * @author ElasticDAO\n */\nlibrary MathLib {\n    struct InternalBalances {\n        // x*y=k - we track these internally to compare to actual balances of the ERC20's\n        // in order to calculate the \"decay\" or the amount of balances that are not\n        // participating in the pricing curve and adding additional liquidity to swap.\n        uint256 baseTokenReserveQty; // x\n        uint256 quoteTokenReserveQty; // y\n        uint256 kLast; // as of the last add / rem liquidity event\n    }\n\n    // aids in avoiding stack too deep errors.\n    struct TokenQtys {\n        uint256 baseTokenQty;\n        uint256 quoteTokenQty;\n        uint256 liquidityTokenQty;\n        uint256 liquidityTokenFeeQty;\n    }\n\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public constant WAD = 10**18; // represent a decimal with 18 digits of precision\n\n    /**\n     * @dev divides two float values, required since solidity does not handle\n     * floating point values.\n     *\n     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol\n     *\n     * NOTE: this rounds to the nearest integer (up or down). For example .666666 would end up\n     * rounding to .66667.\n     *\n     * @return uint256 wad value (decimal with 18 digits of precision)\n     */\n    function wDiv(uint256 a, uint256 b) public pure returns (uint256) {\n        return ((a * WAD) + (b / 2)) / b;\n    }\n\n    /**\n     * @dev rounds a integer (a) to the nearest n places.\n     * IE roundToNearest(123, 10) would round to the nearest 10th place (120).\n     */\n    function roundToNearest(uint256 a, uint256 n)\n        public\n        pure\n        returns (uint256)\n    {\n        return ((a + (n / 2)) / n) * n;\n    }\n\n    /**\n     * @dev multiplies two float values, required since solidity does not handle\n     * floating point values\n     *\n     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol\n     *\n     * @return uint256 wad value (decimal with 18 digits of precision)\n     */\n    function wMul(uint256 a, uint256 b) public pure returns (uint256) {\n        return ((a * b) + (WAD / 2)) / WAD;\n    }\n\n    /**\n     * @dev calculates an absolute diff between two integers. Basically the solidity\n     * equivalent of Math.abs(a-b);\n     */\n    function diff(uint256 a, uint256 b) public pure returns (uint256) {\n        if (a >= b) {\n            return a - b;\n        }\n        return b - a;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    /**\n     * @dev defines the amount of decay needed in order for us to require a user to handle the\n     * decay prior to a double asset entry as the equivalent of 1 unit of quote token\n     */\n    function isSufficientDecayPresent(\n        uint256 _baseTokenReserveQty,\n        InternalBalances memory _internalBalances\n    ) public pure returns (bool) {\n        return (wDiv(\n            diff(_baseTokenReserveQty, _internalBalances.baseTokenReserveQty) *\n                WAD,\n            wDiv(\n                _internalBalances.baseTokenReserveQty,\n                _internalBalances.quoteTokenReserveQty\n            )\n        ) >= WAD); // the amount of base token (a) decay is greater than 1 unit of quote token (token b)\n    }\n\n    /**\n     * @dev used to calculate the qty of token a liquidity provider\n     * must add in order to maintain the current reserve ratios\n     * @param _tokenAQty base or quote token qty to be supplied by the liquidity provider\n     * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)\n     * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)\n     */\n    function calculateQty(\n        uint256 _tokenAQty,\n        uint256 _tokenAReserveQty,\n        uint256 _tokenBReserveQty\n    ) public pure returns (uint256 tokenBQty) {\n        require(_tokenAQty > 0, \"MathLib: INSUFFICIENT_QTY\");\n        require(\n            _tokenAReserveQty > 0 && _tokenBReserveQty > 0,\n            \"MathLib: INSUFFICIENT_LIQUIDITY\"\n        );\n        tokenBQty = (_tokenAQty * _tokenBReserveQty) / _tokenAReserveQty;\n    }\n\n    /**\n     * @dev used to calculate the qty of token a trader will receive (less fees)\n     * given the qty of token A they are providing\n     * @param _tokenASwapQty base or quote token qty to be swapped by the trader\n     * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)\n     * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)\n     * @param _liquidityFeeInBasisPoints fee to liquidity providers represented in basis points\n     */\n    function calculateQtyToReturnAfterFees(\n        uint256 _tokenASwapQty,\n        uint256 _tokenAReserveQty,\n        uint256 _tokenBReserveQty,\n        uint256 _liquidityFeeInBasisPoints\n    ) public pure returns (uint256 qtyToReturn) {\n        uint256 tokenASwapQtyLessFee =\n            _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);\n        qtyToReturn =\n            (tokenASwapQtyLessFee * _tokenBReserveQty) /\n            ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee);\n    }\n\n    /**\n     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier\n     * of a single asset entry when decay is present.\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _tokenQtyAToAdd the amount of tokens being added by the caller to remove the current decay\n     * @param _internalTokenAReserveQty the internal balance (X or Y) of token A as a result of this transaction\n     * @param _tokenBDecayChange the change that will occur in the decay in the opposite token as a result of\n     * this transaction\n     * @param _tokenBDecay the amount of decay in tokenB\n     *\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateLiquidityTokenQtyForSingleAssetEntry(\n        uint256 _totalSupplyOfLiquidityTokens,\n        uint256 _tokenQtyAToAdd,\n        uint256 _internalTokenAReserveQty,\n        uint256 _tokenBDecayChange,\n        uint256 _tokenBDecay\n    ) public pure returns (uint256 liquidityTokenQty) {\n        // gamma = deltaY / Y' / 2 * (deltaX / alphaDecay')\n        uint256 wGamma =\n            wDiv(\n                (\n                    wMul(\n                        wDiv(_tokenQtyAToAdd, _internalTokenAReserveQty),\n                        _tokenBDecayChange * WAD\n                    )\n                ),\n                _tokenBDecay\n            ) /\n                WAD /\n                2;\n\n        liquidityTokenQty =\n            wDiv(\n                wMul(_totalSupplyOfLiquidityTokens * WAD, wGamma),\n                WAD - wGamma\n            ) /\n            WAD;\n    }\n\n    /**\n     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier\n     * of a single asset entry when decay is present.\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _quoteTokenQty the amount of quote token the user it adding to the pool (deltaB or deltaY)\n     * @param _quoteTokenReserveBalance the total balance (external) of quote tokens in our pool (Beta)\n     *\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateLiquidityTokenQtyForDoubleAssetEntry(\n        uint256 _totalSupplyOfLiquidityTokens,\n        uint256 _quoteTokenQty,\n        uint256 _quoteTokenReserveBalance\n    ) public pure returns (uint256 liquidityTokenQty) {\n        liquidityTokenQty =\n            (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /\n            _quoteTokenReserveBalance;\n    }\n\n    /**\n     * @dev used to calculate the qty of quote token required and liquidity tokens (deltaRo) to be issued\n     * in order to add liquidity and remove base token decay.\n     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute\n     * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     *\n     * @return quoteTokenQty qty of quote token the user must supply\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateAddQuoteTokenLiquidityQuantities(\n        uint256 _quoteTokenQtyDesired,\n        uint256 _quoteTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances storage _internalBalances\n    ) public returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) {\n        uint256 baseTokenDecay =\n            _baseTokenReserveQty - _internalBalances.baseTokenReserveQty;\n\n        // determine max amount of quote token that can be added to offset the current decay\n        uint256 wInternalBaseTokenToQuoteTokenRatio =\n            wDiv(\n                _internalBalances.baseTokenReserveQty,\n                _internalBalances.quoteTokenReserveQty\n            );\n\n        // alphaDecay / omega (A/B)\n        uint256 maxQuoteTokenQty =\n            wDiv(baseTokenDecay, wInternalBaseTokenToQuoteTokenRatio);\n\n        require(\n            _quoteTokenQtyMin < maxQuoteTokenQty,\n            \"MathLib: INSUFFICIENT_DECAY\"\n        );\n\n        if (_quoteTokenQtyDesired > maxQuoteTokenQty) {\n            quoteTokenQty = maxQuoteTokenQty;\n        } else {\n            quoteTokenQty = _quoteTokenQtyDesired;\n        }\n\n        uint256 baseTokenQtyDecayChange =\n            roundToNearest(\n                (quoteTokenQty * wInternalBaseTokenToQuoteTokenRatio),\n                WAD\n            ) / WAD;\n\n        require(\n            baseTokenQtyDecayChange > 0,\n            \"MathLib: INSUFFICIENT_CHANGE_IN_DECAY\"\n        );\n        //x += alphaDecayChange\n        //y += deltaBeta\n        _internalBalances.baseTokenReserveQty += baseTokenQtyDecayChange;\n        _internalBalances.quoteTokenReserveQty += quoteTokenQty;\n\n        // calculate the number of liquidity tokens to return to user using\n        liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntry(\n            _totalSupplyOfLiquidityTokens,\n            quoteTokenQty,\n            _internalBalances.quoteTokenReserveQty,\n            baseTokenQtyDecayChange,\n            baseTokenDecay\n        );\n        return (quoteTokenQty, liquidityTokenQty);\n    }\n\n    /**\n     * @dev used to calculate the qty of base tokens required and liquidity tokens (deltaRo) to be issued\n     * in order to add liquidity and remove base token decay.\n     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute\n     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return baseTokenQty qty of base token the user must supply\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateAddBaseTokenLiquidityQuantities(\n        uint256 _baseTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances memory _internalBalances\n    ) public pure returns (uint256 baseTokenQty, uint256 liquidityTokenQty) {\n        uint256 maxBaseTokenQty =\n            _internalBalances.baseTokenReserveQty - _baseTokenReserveQty;\n        require(\n            _baseTokenQtyMin < maxBaseTokenQty,\n            \"MathLib: INSUFFICIENT_DECAY\"\n        );\n\n        if (_baseTokenQtyDesired > maxBaseTokenQty) {\n            baseTokenQty = maxBaseTokenQty;\n        } else {\n            baseTokenQty = _baseTokenQtyDesired;\n        }\n\n        // determine the quote token qty decay change quoted on our current ratios\n        uint256 wInternalQuoteToBaseTokenRatio =\n            wDiv(\n                _internalBalances.quoteTokenReserveQty,\n                _internalBalances.baseTokenReserveQty\n            );\n\n        // NOTE we need this function to use the same\n        // rounding scheme as wDiv in order to avoid a case\n        // in which a user is trying to resolve decay in which\n        // quoteTokenQtyDecayChange ends up being 0 and we are stuck in\n        // a bad state.\n        uint256 quoteTokenQtyDecayChange =\n            roundToNearest(\n                (baseTokenQty * wInternalQuoteToBaseTokenRatio),\n                MathLib.WAD\n            ) / WAD;\n\n        require(\n            quoteTokenQtyDecayChange > 0,\n            \"MathLib: INSUFFICIENT_CHANGE_IN_DECAY\"\n        );\n\n        // we can now calculate the total amount of quote token decay\n        uint256 quoteTokenDecay =\n            (maxBaseTokenQty * wInternalQuoteToBaseTokenRatio) / WAD;\n\n        // this may be redundant quoted on the above math, but will check to ensure the decay wasn't so small\n        // that it was <1 and rounded down to 0 saving the caller some gas\n        // also could fix a potential revert due to div by zero.\n        require(quoteTokenDecay > 0, \"MathLib: NO_QUOTE_DECAY\");\n\n        // we are not changing anything about our internal accounting here. We are simply adding tokens\n        // to make our internal account \"right\"...or rather getting the external balances to match our internal\n        // quoteTokenReserveQty += quoteTokenQtyDecayChange;\n        // baseTokenReserveQty += baseTokenQty;\n\n        // calculate the number of liquidity tokens to return to user using:\n        liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntry(\n            _totalSupplyOfLiquidityTokens,\n            baseTokenQty,\n            _internalBalances.baseTokenReserveQty,\n            quoteTokenQtyDecayChange,\n            quoteTokenDecay\n        );\n        return (baseTokenQty, liquidityTokenQty);\n    }\n\n    /**\n     * @dev used to calculate the qty of tokens a user will need to contribute and be issued in order to add liquidity\n     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute\n     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute\n     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)\n     * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _quoteTokenReserveQty the external quote token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return tokenQtys qty of tokens needed to complete transaction \n     */\n    function calculateAddLiquidityQuantities(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _quoteTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances storage _internalBalances\n    ) public returns (TokenQtys memory tokenQtys) {\n        if (_totalSupplyOfLiquidityTokens > 0) {\n            // we have outstanding liquidity tokens present and an existing price curve\n\n            tokenQtys.liquidityTokenFeeQty = calculateLiquidityTokenFees(\n                _totalSupplyOfLiquidityTokens,\n                _internalBalances\n            );\n\n            // we need to take this amount (that will be minted) into account for below calculations\n            _totalSupplyOfLiquidityTokens += tokenQtys.liquidityTokenFeeQty;\n\n            // confirm that we have no beta or alpha decay present\n            // if we do, we need to resolve that first\n            if (\n                isSufficientDecayPresent(\n                    _baseTokenReserveQty,\n                    _internalBalances\n                )\n            ) {\n                // decay is present and needs to be dealt with by the caller.\n\n                uint256 baseTokenQtyFromDecay;\n                uint256 quoteTokenQtyFromDecay;\n                uint256 liquidityTokenQtyFromDecay;\n\n                if (\n                    _baseTokenReserveQty > _internalBalances.baseTokenReserveQty\n                ) {\n                    // we have more base token than expected (base token decay) due to rebase up\n                    // we first need to handle this situation by requiring this user\n                    // to add quote tokens\n                    (\n                        quoteTokenQtyFromDecay,\n                        liquidityTokenQtyFromDecay\n                    ) = calculateAddQuoteTokenLiquidityQuantities(\n                        _quoteTokenQtyDesired,\n                        0, // there is no minimum for this particular call since we may use quote tokens later.\n                        _baseTokenReserveQty,\n                        _totalSupplyOfLiquidityTokens,\n                        _internalBalances\n                    );\n                } else {\n                    // we have less base token than expected (quote token decay) due to a rebase down\n                    // we first need to handle this by adding base tokens to offset this.\n                    (\n                        baseTokenQtyFromDecay,\n                        liquidityTokenQtyFromDecay\n                    ) = calculateAddBaseTokenLiquidityQuantities(\n                        _baseTokenQtyDesired,\n                        0, // there is no minimum for this particular call since we may use base tokens later.\n                        _baseTokenReserveQty,\n                        _totalSupplyOfLiquidityTokens,\n                        _internalBalances\n                    );\n                }\n\n                if (\n                    quoteTokenQtyFromDecay < _quoteTokenQtyDesired &&\n                    baseTokenQtyFromDecay < _baseTokenQtyDesired\n                ) {\n                    // the user still has qty that they desire to contribute to the exchange for liquidity\n                    (\n                        tokenQtys.baseTokenQty,\n                        tokenQtys.quoteTokenQty,\n                        tokenQtys.liquidityTokenQty\n                    ) = calculateAddTokenPairLiquidityQuantities(\n                        _baseTokenQtyDesired - baseTokenQtyFromDecay, // safe from underflow quoted on above IF\n                        _quoteTokenQtyDesired - quoteTokenQtyFromDecay, // safe from underflow quoted on above IF\n                        0, // we will check minimums below\n                        0, // we will check minimums below\n                        _quoteTokenReserveQty + quoteTokenQtyFromDecay,\n                        _totalSupplyOfLiquidityTokens +\n                            liquidityTokenQtyFromDecay,\n                        _internalBalances // NOTE: these balances have already been updated when we did the decay math.\n                    );\n                }\n                tokenQtys.baseTokenQty += baseTokenQtyFromDecay;\n                tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay;\n                tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay;\n\n                require(\n                    tokenQtys.baseTokenQty >= _baseTokenQtyMin,\n                    \"MathLib: INSUFFICIENT_BASE_QTY\"\n                );\n\n                require(\n                    tokenQtys.quoteTokenQty >= _quoteTokenQtyMin,\n                    \"MathLib: INSUFFICIENT_QUOTE_QTY\"\n                );\n            } else {\n                // the user is just doing a simple double asset entry / providing both base and quote.\n                (\n                    tokenQtys.baseTokenQty,\n                    tokenQtys.quoteTokenQty,\n                    tokenQtys.liquidityTokenQty\n                ) = calculateAddTokenPairLiquidityQuantities(\n                    _baseTokenQtyDesired,\n                    _quoteTokenQtyDesired,\n                    _baseTokenQtyMin,\n                    _quoteTokenQtyMin,\n                    _quoteTokenReserveQty,\n                    _totalSupplyOfLiquidityTokens,\n                    _internalBalances\n                );\n            }\n        } else {\n            // this user will set the initial pricing curve\n            require(\n                _baseTokenQtyDesired > 0,\n                \"MathLib: INSUFFICIENT_BASE_QTY_DESIRED\"\n            );\n            require(\n                _quoteTokenQtyDesired > 0,\n                \"MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED\"\n            );\n\n            tokenQtys.baseTokenQty = _baseTokenQtyDesired;\n            tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;\n            tokenQtys.liquidityTokenQty = sqrt(\n                _baseTokenQtyDesired * _quoteTokenQtyDesired\n            );\n\n            _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;\n            _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty;\n        }\n    }\n\n    /**\n     * @dev calculates the qty of base and quote tokens required and liquidity tokens (deltaRo) to be issued\n     * in order to add liquidity when no decay is present.\n     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute\n     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute\n     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)\n     * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)\n     * @param _quoteTokenReserveQty the external quote token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return baseTokenQty qty of base token the user must supply\n     * @return quoteTokenQty qty of quote token the user must supply\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateAddTokenPairLiquidityQuantities(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        uint256 _quoteTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances storage _internalBalances\n    )\n        public\n        returns (\n            uint256 baseTokenQty,\n            uint256 quoteTokenQty,\n            uint256 liquidityTokenQty\n        )\n    {\n        uint256 requiredQuoteTokenQty =\n            calculateQty(\n                _baseTokenQtyDesired,\n                _internalBalances.baseTokenReserveQty,\n                _internalBalances.quoteTokenReserveQty\n            );\n\n        if (requiredQuoteTokenQty <= _quoteTokenQtyDesired) {\n            // user has to provide less than their desired amount\n            require(\n                requiredQuoteTokenQty >= _quoteTokenQtyMin,\n                \"MathLib: INSUFFICIENT_QUOTE_QTY\"\n            );\n            baseTokenQty = _baseTokenQtyDesired;\n            quoteTokenQty = requiredQuoteTokenQty;\n        } else {\n            // we need to check the opposite way.\n            uint256 requiredBaseTokenQty =\n                calculateQty(\n                    _quoteTokenQtyDesired,\n                    _internalBalances.quoteTokenReserveQty,\n                    _internalBalances.baseTokenReserveQty\n                );\n\n            require(\n                requiredBaseTokenQty >= _baseTokenQtyMin,\n                \"MathLib: INSUFFICIENT_BASE_QTY\"\n            );\n            baseTokenQty = requiredBaseTokenQty;\n            quoteTokenQty = _quoteTokenQtyDesired;\n        }\n\n        liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(\n            _totalSupplyOfLiquidityTokens,\n            quoteTokenQty,\n            _quoteTokenReserveQty\n        );\n\n        _internalBalances.baseTokenReserveQty += baseTokenQty;\n        _internalBalances.quoteTokenReserveQty += quoteTokenQty;\n    }\n\n    /**\n     * @dev calculates the qty of base tokens a user will receive for swapping their quote tokens (less fees)\n     * @param _quoteTokenQty the amount of quote tokens the user wants to swap\n     * @param _baseTokenQtyMin the minimum about of base tokens they are willing to receive in return (slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return baseTokenQty qty of base token the user will receive back\n     */\n    function calculateBaseTokenQty(\n        uint256 _quoteTokenQty,\n        uint256 _baseTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _liquidityFeeInBasisPoints,\n        InternalBalances storage _internalBalances\n    ) public returns (uint256 baseTokenQty) {\n        require(\n            _baseTokenReserveQty > 0 &&\n                _internalBalances.baseTokenReserveQty > 0,\n            \"MathLib: INSUFFICIENT_BASE_TOKEN_QTY\"\n        );\n\n        // check to see if we have experience quote token decay / a rebase down event\n        if (_baseTokenReserveQty < _internalBalances.baseTokenReserveQty) {\n            // we have less reserves than our current price curve will expect, we need to adjust the curve\n            uint256 wPricingRatio =\n                wDiv(\n                    _internalBalances.baseTokenReserveQty,\n                    _internalBalances.quoteTokenReserveQty\n                ); // omega\n\n            uint256 impliedQuoteTokenQty =\n                wDiv(_baseTokenReserveQty, wPricingRatio); // no need to divide by WAD, wPricingRatio is already a WAD.\n\n            baseTokenQty = calculateQtyToReturnAfterFees(\n                _quoteTokenQty,\n                impliedQuoteTokenQty,\n                _baseTokenReserveQty, // use the actual balance here since we adjusted the quote token to match ratio!\n                _liquidityFeeInBasisPoints\n            );\n        } else {\n            // we have the same or more reserves, no need to alter the curve.\n            baseTokenQty = calculateQtyToReturnAfterFees(\n                _quoteTokenQty,\n                _internalBalances.quoteTokenReserveQty,\n                _internalBalances.baseTokenReserveQty,\n                _liquidityFeeInBasisPoints\n            );\n        }\n\n        require(\n            baseTokenQty > _baseTokenQtyMin,\n            \"MathLib: INSUFFICIENT_BASE_TOKEN_QTY\"\n        );\n\n        _internalBalances.baseTokenReserveQty -= baseTokenQty;\n        _internalBalances.quoteTokenReserveQty += _quoteTokenQty;\n    }\n\n    /**\n     * @dev calculates the qty of quote tokens a user will receive for swapping their base tokens (less fees)\n     * @param _baseTokenQty the amount of bases tokens the user wants to swap\n     * @param _quoteTokenQtyMin the minimum about of quote tokens they are willing to receive in return (slippage)\n     * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return quoteTokenQty qty of quote token the user will receive back\n     */\n    function calculateQuoteTokenQty(\n        uint256 _baseTokenQty,\n        uint256 _quoteTokenQtyMin,\n        uint256 _liquidityFeeInBasisPoints,\n        InternalBalances storage _internalBalances\n    ) public returns (uint256 quoteTokenQty) {\n        require(\n            _baseTokenQty > 0 && _quoteTokenQtyMin > 0,\n            \"MathLib: INSUFFICIENT_TOKEN_QTY\"\n        );\n\n        quoteTokenQty = calculateQtyToReturnAfterFees(\n            _baseTokenQty,\n            _internalBalances.baseTokenReserveQty,\n            _internalBalances.quoteTokenReserveQty,\n            _liquidityFeeInBasisPoints\n        );\n\n        require(\n            quoteTokenQty > _quoteTokenQtyMin,\n            \"MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY\"\n        );\n\n        _internalBalances.baseTokenReserveQty += _baseTokenQty;\n        _internalBalances.quoteTokenReserveQty -= quoteTokenQty;\n    }\n\n    /**\n     * @dev calculates the qty of liquidity tokens that should be sent to the DAO due to the growth in K from trading.\n     * The DAO takes 1/6 of the total fees (30BP total fee, 25 BP to lps and 5 BP to the DAO)\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return liquidityTokenFeeQty qty of tokens to be minted to the fee address for the growth in K\n     */\n    function calculateLiquidityTokenFees(\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances memory _internalBalances\n    ) public pure returns (uint256 liquidityTokenFeeQty) {\n        uint256 rootK =\n            sqrt(\n                _internalBalances.baseTokenReserveQty *\n                    _internalBalances.quoteTokenReserveQty\n            );\n        uint256 rootKLast = sqrt(_internalBalances.kLast);\n        if (rootK > rootKLast) {\n            uint256 numerator =\n                _totalSupplyOfLiquidityTokens * (rootK - rootKLast);\n            uint256 denominator = (rootK * 5) + rootKLast;\n            liquidityTokenFeeQty = numerator / denominator;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Exchange.sol",
            "MathLib.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "addLiquidity()",
                    "Gamma",
                    "baseToken",
                    "quoteToken"
                ],
                "Type": " In the case of Single Asset Entry, new liquidity providers will suffer fund loss due to wrong formula of \u0394Ro",
                "Description": "\n\n\nPer the document: <https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20alphaDecay\n\nand related code: <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L283\n\nGamma is the ratio of shares received by the new liquidity provider when addLiquidity() (\u0394Ro) to the new totalSupply (total shares = Ro' = Ro + \u0394Ro).\n\n    \u0394Ro = (Ro/(1 \u03b3)) * \u03b3\n\n            Ro * Gamma\n        = --------------\n             1 Gamma\n    \u27fa\n    \u0394Ro * ( 1 Gamma ) = Gamma * Ro\n    \u0394Ro Gamma * \u0394Ro = Gamma * Ro\n    \u0394Ro = Gamma * Ro + Gamma * \u0394Ro\n               \u0394Ro    \n    Gamma = ---------\n             Ro + \u0394Ro \n\nIn the current implementation:\n\n    \u03b3 = \u0394Y / Y' / 2 * ( \u0394X / \u03b1^ )\n\n\u0394Y is the quoteToken added by the new liquidity provider. See:\n\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L277\n\nY' is the new Y after addLiquidity(), Y' = Y + \u0394Y. See:\n\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L272\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L278\n\n\u0394X is \u0394Y * Omega. See:\n\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L259-L263\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L279\n\n\u03b1^ is Alpha X. See:\n\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L234-L235\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L280\n\nFor instance:\n\nGiven:\n\n*   Original State: X = Alpha = 1, Y = Beta = 1, Omega = X/Y = 1\n*   When baseToken rebase up: Alpha becomes 10\n*   Current State: Alpha = 10, X = 1, Y = Beta = 1, Omega = 1\n\nWhen: new liquidity provider addLiquidity() with 4 quoteToken:\n\n                 4          4 * Omega      16\n    Gamma = -----------* -----------= ----\n             (1+4) * 2       10 1        90\n\nAfter addLiquidity():\n\n*   baseToken belongs to the newLP: 10 * 16 / 90 = 160 / 90 = 1.7777777777777777\n*   quoteToken belongs to the newLP: (1+4) * 16 / 90 = 80 / 90 = 0.8888888888888888\n*   In the terms of quoteToken, the total value is: 160 / 90 / Omega + 80 / 90 = 240 / 90 = 2.6666666666666665\n\nAs a result, the new liquidity provider suffers a fund loss of 4 240 / 90 = 1.3333333333333333 in the terms of quoteToken\n\nThe case above can be reproduced by changing the numbers in this test unit(https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L1804).\n\n\nPer the document: <https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20betaDecay\n\nand related code: <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L297-L363\n\nGamma is the ratio of shares received by the new liquidity provider when addLiquidity() (\u0394Ro) to the new totalSupply (total shares = Ro' = Ro + \u0394Ro).\n\n    \u0394Ro = (Ro/(1 \u03b3)) * \u03b3\n\n            Ro * Gamma\n        = --------------\n             1 Gamma\n    \u27fa\n    \u0394Ro * ( 1 Gamma ) = Gamma * Ro\n    \u0394Ro Gamma * \u0394Ro = Gamma * Ro\n    \u0394Ro = Gamma * Ro + Gamma * \u0394Ro\n               \u0394Ro    \n    Gamma = ---------\n             Ro + \u0394Ro \n\nIn the current implementation:\n\n    \u03b3 = \u0394X / X / 2 * ( \u0394XByQuoteTokenAmount / \u03b2^ )\n\n\u0394X is the amount of baseToken added by the new liquidity provider. See:\n\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L357\n\nX is the balanceOf baseToken. See:\n\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L358\n\n\u0394XByQuoteTokenAmount is \u0394X / Omega, the value of \u0394X in the terms of quoteToken. See:\n\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L329-L333\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L359\n\n\u03b2^ is max\u0394X / Omega, the value of max\u0394X in the terms of quoteToken. max\u0394X = X Alpha. See:\n\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L304-L305\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L341-L342\n*   <https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L360\n\nFor instance:\n\nGiven:\n\n*   Original State: X = Alpha = 10, Y = Beta = 10, Omega = X/Y = 1\n*   When baseToken rebase down, Alpha becomes 1\n*   Current State: Alpha = 1, X = 10, Y = Beta = 10, Omega = 1\n\nWhen: new liquidity provider addLiquidity() with 4 baseToken\n\n                4          4 / Omega       8\n    Gamma = -------* ---------------= ----\n              10 * 2    (10-1) / Omega     90\n\nAfter addLiquidity():\n\n*   baseToken belongs to the newLP: (1 + 4) * 8 / 90 = 40 / 90 = 0.4444444444444444\n*   quoteToken belongs to the newLP: 10 * 8 / 90 = 80 / 90 = 0.8888888888888888\n*   In the terms of quoteToken, the total value is: 40 / 90 + 80 / 90 * Omega = 120 / 90 = 1.3333333333333333 < 4\n\nAs a result, the new liquidity provider suffers a fund loss of 4 120 / 90 = 2.6666666666666665 in the terms of quoteToken\n\nThe case above can be reproduced by changing the numbers in this test unit(https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L2146).\n\n\nSee issue page for details.(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/144)\n\n\n",
                "Repair": "\nUpdate code and document using the correct formula for \u0394Ro.\n\n0xean (ElasticSwap) confirmed and commented(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/144#issuecomment-1030633292):\n  Finding is valid solution seems to be partially correct and we are working on the fully correct version.\n \n It seems that the suggested formula doesn\u2019t cover a rebase down correctly and this is where our efforts are focused now.  \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/144#issuecomment-1038297316):\n  The warden has identified an issue with the math that reliably will provide a less-than-expected value to single-sided liquidity providers.\n The warden showed a consistent way for this to occur and while the recommended fix may not be completely correct, I believe the finding to be valid.\n \n Because the warden found a set of cases that reliably make the protocol return less value than expected when compared to the goals of the protocol, I believe High Severity to be appropriate.\n\n0xean (ElasticSwap) resolved(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/144#event-6163747395)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.4;\n\nimport \"../libraries/MathLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IExchangeFactory.sol\";\n\n/**\n * @title Exchange contract for Elastic Swap representing a single ERC20 pair of tokens to be swapped.\n * @author Elastic DAO\n * @notice This contract provides all of the needed functionality for a liquidity provider to supply/withdraw ERC20\n * tokens and traders to swap tokens for one another.\n */\ncontract Exchange is ERC20, ReentrancyGuard {\n    using MathLib for uint256;\n    using SafeERC20 for IERC20;\n\n    address public immutable baseToken; // address of ERC20 base token (elastic or fixed supply)\n    address public immutable quoteToken; // address of ERC20 quote token (WETH or a stable coin w/ fixed supply)\n    address public immutable exchangeFactoryAddress;\n\n    uint256 public constant TOTAL_LIQUIDITY_FEE = 30; // fee provided to liquidity providers + DAO in basis points\n\n    MathLib.InternalBalances public internalBalances =\n        MathLib.InternalBalances(0, 0, 0);\n\n    event AddLiquidity(\n        address indexed liquidityProvider,\n        uint256 baseTokenQtyAdded,\n        uint256 quoteTokenQtyAdded\n    );\n    event RemoveLiquidity(\n        address indexed liquidityProvider,\n        uint256 baseTokenQtyRemoved,\n        uint256 quoteTokenQtyRemoved\n    );\n    event Swap(\n        address indexed sender,\n        uint256 baseTokenQtyIn,\n        uint256 quoteTokenQtyIn,\n        uint256 baseTokenQtyOut,\n        uint256 quoteTokenQtyOut\n    );\n\n    /**\n     * @dev Called to check timestamps from users for expiration of their calls.\n     * Used in place of a modifier for byte code savings\n     */\n    function isNotExpired(uint256 _expirationTimeStamp) internal view {\n        require(_expirationTimeStamp >= block.timestamp, \"Exchange: EXPIRED\");\n    }\n\n    /**\n     * @notice called by the exchange factory to create a new erc20 token swap pair (do not call this directly!)\n     * @param _name The human readable name of this pair (also used for the liquidity token name)\n     * @param _symbol Shortened symbol for trading pair (also used for the liquidity token symbol)\n     * @param _baseToken address of the ERC20 base token in the pair. This token can have a fixed or elastic supply\n     * @param _quoteToken address of the ERC20 quote token in the pair. This token is assumed to have a fixed supply.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _baseToken,\n        address _quoteToken,\n        address _exchangeFactoryAddress\n    ) ERC20(_name, _symbol) {\n        baseToken = _baseToken;\n        quoteToken = _quoteToken;\n        exchangeFactoryAddress = _exchangeFactoryAddress;\n    }\n\n    /**\n     * @notice primary entry point for a liquidity provider to add new liquidity (base and quote tokens) to the exchange\n     * and receive liquidity tokens in return.\n     * Requires approvals to be granted to this exchange for both base and quote tokens.\n     * @param _baseTokenQtyDesired qty of baseTokens that you would like to add to the exchange\n     * @param _quoteTokenQtyDesired qty of quoteTokens that you would like to add to the exchange\n     * @param _baseTokenQtyMin minimum acceptable qty of baseTokens that will be added (or transaction will revert)\n     * @param _quoteTokenQtyMin minimum acceptable qty of quoteTokens that will be added (or transaction will revert)\n     * @param _liquidityTokenRecipient address for the exchange to issue the resulting liquidity tokens from\n     * this transaction to\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function addLiquidity(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        address _liquidityTokenRecipient,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() {\n        isNotExpired(_expirationTimestamp);\n\n        MathLib.TokenQtys memory tokenQtys =\n            MathLib.calculateAddLiquidityQuantities(\n                _baseTokenQtyDesired,\n                _quoteTokenQtyDesired,\n                _baseTokenQtyMin,\n                _quoteTokenQtyMin,\n                IERC20(baseToken).balanceOf(address(this)),\n                IERC20(quoteToken).balanceOf(address(this)),\n                this.totalSupply(),\n                internalBalances\n            );\n\n        internalBalances.kLast =\n            internalBalances.baseTokenReserveQty *\n            internalBalances.quoteTokenReserveQty;\n\n        if (tokenQtys.liquidityTokenFeeQty > 0) {\n            // mint liquidity tokens to fee address for k growth.\n            _mint(\n                IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n                tokenQtys.liquidityTokenFeeQty\n            );\n        }\n        _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient\n\n        if (tokenQtys.baseTokenQty != 0) {\n            bool isExchangeEmpty =\n                IERC20(baseToken).balanceOf(address(this)) == 0;\n\n            // transfer base tokens to Exchange\n            IERC20(baseToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenQtys.baseTokenQty\n            );\n\n            if (isExchangeEmpty) {\n                require(\n                    IERC20(baseToken).balanceOf(address(this)) ==\n                        tokenQtys.baseTokenQty,\n                    \"Exchange: FEE_ON_TRANSFER_NOT_SUPPORTED\"\n                );\n            }\n        }\n\n        if (tokenQtys.quoteTokenQty != 0) {\n            // transfer quote tokens to Exchange\n            IERC20(quoteToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenQtys.quoteTokenQty\n            );\n        }\n\n        emit AddLiquidity(\n            msg.sender,\n            tokenQtys.baseTokenQty,\n            tokenQtys.quoteTokenQty\n        );\n    }\n\n    /**\n     * @notice called by a liquidity provider to redeem liquidity tokens from the exchange and receive back\n     * base and quote tokens. Required approvals to be granted to this exchange for the liquidity token\n     * @param _liquidityTokenQty qty of liquidity tokens that you would like to redeem\n     * @param _baseTokenQtyMin minimum acceptable qty of base tokens to receive back (or transaction will revert)\n     * @param _quoteTokenQtyMin minimum acceptable qty of quote tokens to receive back (or transaction will revert)\n     * @param _tokenRecipient address for the exchange to issue the resulting base and\n     * quote tokens from this transaction to\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function removeLiquidity(\n        uint256 _liquidityTokenQty,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        address _tokenRecipient,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() {\n        isNotExpired(_expirationTimestamp);\n        require(this.totalSupply() > 0, \"Exchange: INSUFFICIENT_LIQUIDITY\");\n        require(\n            _baseTokenQtyMin > 0 && _quoteTokenQtyMin > 0,\n            \"Exchange: MINS_MUST_BE_GREATER_THAN_ZERO\"\n        );\n\n        uint256 baseTokenReserveQty =\n            IERC20(baseToken).balanceOf(address(this));\n        uint256 quoteTokenReserveQty =\n            IERC20(quoteToken).balanceOf(address(this));\n\n        uint256 totalSupplyOfLiquidityTokens = this.totalSupply();\n        // calculate any DAO fees here.\n        uint256 liquidityTokenFeeQty =\n            MathLib.calculateLiquidityTokenFees(\n                totalSupplyOfLiquidityTokens,\n                internalBalances\n            );\n\n        // we need to factor this quantity in to any total supply before redemption\n        totalSupplyOfLiquidityTokens += liquidityTokenFeeQty;\n\n        uint256 baseTokenQtyToReturn =\n            (_liquidityTokenQty * baseTokenReserveQty) /\n                totalSupplyOfLiquidityTokens;\n        uint256 quoteTokenQtyToReturn =\n            (_liquidityTokenQty * quoteTokenReserveQty) /\n                totalSupplyOfLiquidityTokens;\n\n        require(\n            baseTokenQtyToReturn >= _baseTokenQtyMin,\n            \"Exchange: INSUFFICIENT_BASE_QTY\"\n        );\n\n        require(\n            quoteTokenQtyToReturn >= _quoteTokenQtyMin,\n            \"Exchange: INSUFFICIENT_QUOTE_QTY\"\n        );\n\n        // this ensure that we are removing the equivalent amount of decay\n        // when this person exits.\n        uint256 baseTokenQtyToRemoveFromInternalAccounting =\n            (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /\n                totalSupplyOfLiquidityTokens;\n\n        internalBalances\n            .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting;\n\n        // We should ensure no possible overflow here.\n        if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {\n            internalBalances.quoteTokenReserveQty = 0;\n        } else {\n            internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;\n        }\n\n        internalBalances.kLast =\n            internalBalances.baseTokenReserveQty *\n            internalBalances.quoteTokenReserveQty;\n\n        if (liquidityTokenFeeQty > 0) {\n            _mint(\n                IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n                liquidityTokenFeeQty\n            );\n        }\n\n        _burn(msg.sender, _liquidityTokenQty);\n        IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);\n        IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);\n        emit RemoveLiquidity(\n            msg.sender,\n            baseTokenQtyToReturn,\n            quoteTokenQtyToReturn\n        );\n    }\n\n    /**\n     * @notice swaps base tokens for a minimum amount of quote tokens.  Fees are included in all transactions.\n     * The exchange must be granted approvals for the base token by the caller.\n     * @param _baseTokenQty qty of base tokens to swap\n     * @param _minQuoteTokenQty minimum qty of quote tokens to receive in exchange for\n     * your base tokens (or the transaction will revert)\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function swapBaseTokenForQuoteToken(\n        uint256 _baseTokenQty,\n        uint256 _minQuoteTokenQty,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() {\n        isNotExpired(_expirationTimestamp);\n        require(\n            _baseTokenQty > 0 && _minQuoteTokenQty > 0,\n            \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n        );\n\n        uint256 quoteTokenQty =\n            MathLib.calculateQuoteTokenQty(\n                _baseTokenQty,\n                _minQuoteTokenQty,\n                TOTAL_LIQUIDITY_FEE,\n                internalBalances\n            );\n\n        IERC20(baseToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _baseTokenQty\n        );\n\n        IERC20(quoteToken).safeTransfer(msg.sender, quoteTokenQty);\n        emit Swap(msg.sender, _baseTokenQty, 0, 0, quoteTokenQty);\n    }\n\n    /**\n     * @notice swaps quote tokens for a minimum amount of base tokens.  Fees are included in all transactions.\n     * The exchange must be granted approvals for the quote token by the caller.\n     * @param _quoteTokenQty qty of quote tokens to swap\n     * @param _minBaseTokenQty minimum qty of base tokens to receive in exchange for\n     * your quote tokens (or the transaction will revert)\n     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)\n     */\n    function swapQuoteTokenForBaseToken(\n        uint256 _quoteTokenQty,\n        uint256 _minBaseTokenQty,\n        uint256 _expirationTimestamp\n    ) external nonReentrant() {\n        isNotExpired(_expirationTimestamp);\n        require(\n            _quoteTokenQty > 0 && _minBaseTokenQty > 0,\n            \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n        );\n\n        uint256 baseTokenQty =\n            MathLib.calculateBaseTokenQty(\n                _quoteTokenQty,\n                _minBaseTokenQty,\n                IERC20(baseToken).balanceOf(address(this)),\n                TOTAL_LIQUIDITY_FEE,\n                internalBalances\n            );\n\n        IERC20(quoteToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _quoteTokenQty\n        );\n\n        IERC20(baseToken).safeTransfer(msg.sender, baseTokenQty);\n        emit Swap(msg.sender, 0, _quoteTokenQty, baseTokenQty, 0);\n    }\n}\n\n\n",
        "CodeNames": [
            "Exchange.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nliquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(\n    _totalSupplyOfLiquidityTokens,\n    quoteTokenQty,\n    _quoteTokenReserveQty // IERC20(quoteToken).balanceOf(address(this))\n);\n"
                ],
                "Type": " Transferring  quoteToken  to the exchange pool contract will cause future liquidity providers to lose funds",
                "Description": "\nIn the current implementation, the amount of LP tokens to be minted when addLiquidity() is calculated based on the ratio between the amount of newly added quoteToken and the current wallet balance of quoteToken in the Exchange contract.\n\nHowever, since anyone can transfer quoteToken to the contract, and make the balance of quoteToken to be larger than _internalBalances.quoteTokenReserveQty, existing liquidity providers can take advantage of this by donating quoteToken and make future liquidity providers receive fewer LP tokens than expected and lose funds.\n\n<https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L578-L582\n\nsolidity\nliquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(\n    _totalSupplyOfLiquidityTokens,\n    quoteTokenQty,\n    _quoteTokenReserveQty // IERC20(quoteToken).balanceOf(address(this))\n);\n\n\n\nGiven:\n\n*   The Exchange pool is new;\n\n1.  Alice addLiquidity() with 1e18 baseToken and 1e18 quoteToken, recived 1e18 LP token;\n2.  Alice transfer 99e18 quoteToken to the Exchange pool contract;\n3.  Bob addLiquidity() with 1e18 baseToken and 1e18 quoteToken;\n4.  Bob removeLiquidity() with all the LP token in balance.\n\nExpected Results: Bob recived 1e18 baseToken and = 1e18 quoteToken.\n\nActual Results: Bob recived ~0.02e18 baseToken and ~1e18 quoteToken.\n\nAlice can now removeLiquidity() and recive ~1.98e18 baseToken and ~100e18 quoteToken.\n\nAs a result, Bob suffers a fund loss of 0.98e18 baseToken.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nliquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(\n    _totalSupplyOfLiquidityTokens,\n    quoteTokenQty,\n    _internalBalances.quoteTokenReserveQty\n);\n\n0xean (ElasticSwap) confirmed and commented(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/146#issuecomment-1023217456):\n  This does appear to be correct after attempting a POC. Thank you WatchPug! \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/146#issuecomment-1038288670):\n  The warden identified a way to exploit the protocol math to devalue future liquidity provision at the advantage of early liquidity providers.\n \n The exploit is extractive in nature, however, because this is reliably performable and effectively breaks the protocol's goals and mechanics, I believe High Severity to be appropriate.\n\n0xean (ElasticSwap) resolved(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/146#event-6163742328)\n\n\n\n*\n\n \n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\n} else {\n    // this user will set the initial pricing curve\n    require(\n        _baseTokenQtyDesired  0,\n        \"MathLib: INSUFFICIENT_BASE_QTY_DESIRED\"\n    );\n    require(\n        _quoteTokenQtyDesired  0,\n        \"MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED\"\n    );\n\n    tokenQtys.baseTokenQty = _baseTokenQtyDesired;\n    tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;\n    tokenQtys.liquidityTokenQty = sqrt(\n        _baseTokenQtyDesired * _quoteTokenQtyDesired\n    );\n\n    _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;\n    _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty;\n}\n",
                    "//solidity\nfunction calculateLiquidityTokenQtyForDoubleAssetEntry(\n    uint256 _totalSupplyOfLiquidityTokens,\n    uint256 _quoteTokenQty,\n    uint256 _quoteTokenReserveBalance\n) public pure returns (uint256 liquidityTokenQty) {\n    liquidityTokenQty =\n        (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /\n        _quoteTokenReserveBalance;\n}\n"
                ],
                "Type": " The value of LP token can be manipulated by the first minister, which allows the attacker to dilute future liquidity providers' shares",
                "Description": "\nFor the first minter of an Exchange pool, the ratio of X/Y and the totalSupply of the LP token can be manipulated.\n\nA sophisticated attacker can mint and burn all of the LP tokens but 1 Wei, and then artificially create a situation of rebasing up by transferring baseToken to the pool contract. Then addLiquidity() in singleAssetEntry mode.\n\nDue to the special design of singleAssetEntry mode, the value of LP token can be inflated very quickly.\n\nAs a result, 1 Wei of LP token can be worthing a significate amount of baseToken and quoteToken.\n\nCombine this with the precision loss when calculating the amount of LP tokens to be minted to the new liquidity provider, the attacker can turn the pool into a trap which will take a certain amount of cut for all future liquidity providers by minting fewer LP tokens to them.\n\n<https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L493-L512\n\nsolidity\n} else {\n    // this user will set the initial pricing curve\n    require(\n        _baseTokenQtyDesired  0,\n        \"MathLib: INSUFFICIENT_BASE_QTY_DESIRED\"\n    );\n    require(\n        _quoteTokenQtyDesired  0,\n        \"MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED\"\n    );\n\n    tokenQtys.baseTokenQty = _baseTokenQtyDesired;\n    tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;\n    tokenQtys.liquidityTokenQty = sqrt(\n        _baseTokenQtyDesired * _quoteTokenQtyDesired\n    );\n\n    _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;\n    _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty;\n}\n\n\n<https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L204-L212\n\nsolidity\nfunction calculateLiquidityTokenQtyForDoubleAssetEntry(\n    uint256 _totalSupplyOfLiquidityTokens,\n    uint256 _quoteTokenQty,\n    uint256 _quoteTokenReserveBalance\n) public pure returns (uint256 liquidityTokenQty) {\n    liquidityTokenQty =\n        (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /\n        _quoteTokenReserveBalance;\n}\n\n\n\nGiven:\n\n*   The Pool is newly created;\n*   The market price of baseToken in terms of quoteToken is 1.\n\nThe attacker can do the following steps in one tx:\n\n1.  addLiquidity() with 2 Wei of baseToken and 100e18 quoteToken, received 14142135623 LP tokens;\n2.  removeLiquidity() with 14142135622 LP tokens, the Pool state becomes:\n\n*   totalSupply of LP tokens: 1 Wei\n*   baseTokenReserveQty: 1 Wei\n*   quoteTokenReserveQty: 7071067813 Wei\n\n3.  baseToken.transfer() 7071067812 Wei to the Pool contract;\n4.  addLiquidity() with no baseToken and 50e18 quoteToken;\n5.  swapBaseTokenForQuoteToken() with 600000000000000 baseToken, the Pool state becomes:\n\n*   totalSupply of LP tokens: 1 Wei\n*   quoteTokenReserveQty 591021750159032\n*   baseTokenReserveQty 600007071067801\n\n6.  baseToken.transfer() 999399992928932200 Wei to the Pool contract;\n7.  addLiquidity() with no baseToken and 1e18 quoteToken, the Pool state becomes:\n\n*   totalSupply of LP tokens: 1 Wei\n*   quoteTokenReserveQty: 1000000000000000013\n*   quoteTokenReserveQty: 985024641638342212\n*   baseTokenDecay: 0\n\nFrom now on, addLiquidity() with less than 1e18 of baseToken and quoteToken will receive 0 LP token due to precision loss.\n\nThe amounts can be manipulated to higher numbers and cause most future liquidity providers to receive fewer LP tokens than expected, and the attacker will be able to profit from it as the attacker will take a larger share of the pool than expected.\n\n",
                "Repair": "\nConsider requiring a certain amount of minimal LP token amount (eg, 1e8) for the first minter and lock some of the first minter's LP tokens by minting ~1% of the initial amount to the factory address.\n\n0xean (ElasticSwap) confirmed, but disagreed with High severity and commented(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/145#issuecomment-1023222249):\n  Thanks for the report, I don't agree with the severity based on this\n \n \n From now on, addLiquidity() with less than 1e18 of baseToken and quoteToken will receive 0 LP token due to precision loss.\n \n \n which in your example represents a user trying to add dust to the contract after the attack.\n \n I think we will implement the minimum locked liquidity to avoid rounding errors, but this attack assumes users are adding dust to the contract and that they are totally unaware of the contract state which is incorrect.  Users specific a min and a max token qty's when adding liquidity. \n \n Would recommend med. risk on this one if not low risk given the attack is on \"dust\" amounts of tokens. \n\nAlex the Entreprenerd (judge) changed severity to Medium and commented(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/145#issuecomment-1030966153):\n  I agree with the finding and remember coming across it when reading the Yearn V0.4.2 Audit by Trails of Bits.(https://docs.yearn.finance/security/index#third-party-audits)\n \n Ultimately this is contingent on a donation, that will make each share more valuable, so it's effectively a way to use rounding against making dust donations.\n \n Technically this same idea can be extended to huge donations, however there are very dubious economic reasons as to why you'd do that (perhaps frontrunning a moderate deposit with the goal of using this method to earn that MEV).\n \n Ultimately this is something that can happen anytime you have X shares and Y totalSupply\n If the total supply reaches greater units than the shares, then integer division will inevitably eat out some of those shares.\n \n Have yet to see a long term solution to this rounding problem, however, a simple initial addition that mints 1e18 shares will require some economic commitment by the potential exploiters.\n \n Agree with medium severity.\n\n0xean (ElasticSwap) resolved(https://github.com/code-423n4/2022-01-elasticswap-findings/issues/145#event-6163749549)\n\n\n\n*\n\n\n"
            }
        ]
    }
]