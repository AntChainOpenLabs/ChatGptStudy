[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./amm/interfaces/ITempusAMM.sol\";\nimport \"./amm/interfaces/IVault.sol\";\nimport \"./ITempusPool.sol\";\nimport \"./math/Fixed256xVar.sol\";\nimport \"./utils/PermanentlyOwnable.sol\";\nimport \"./utils/AMMBalancesHelper.sol\";\nimport \"./utils/UntrustedERC20.sol\";\n\ncontract TempusController is PermanentlyOwnable, ReentrancyGuard {\n    using Fixed256xVar for uint256;\n    using SafeERC20 for IERC20;\n    using UntrustedERC20 for IERC20;\n    using AMMBalancesHelper for uint256[];\n\n    /// @dev Event emitted on a successful BT/YBT deposit.\n    /// @param pool The Tempus Pool to which assets were deposited\n    /// @param depositor Address of the user who deposited Yield Bearing Tokens to mint\n    ///                  Tempus Principal Share (TPS) and Tempus Yield Shares\n    /// @param recipient Address of the recipient who will receive TPS and TYS tokens\n    /// @param yieldTokenAmount Amount of yield tokens received from underlying pool\n    /// @param backingTokenValue Value of @param yieldTokenAmount expressed in backing tokens\n    /// @param shareAmounts Number of Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS) granted to `recipient`\n    /// @param interestRate Interest Rate of the underlying pool from Yield Bearing Tokens to the underlying asset\n    /// @param fee The fee which was deducted (in terms of yield bearing tokens)\n    event Deposited(\n        address indexed pool,\n        address indexed depositor,\n        address indexed recipient,\n        uint256 yieldTokenAmount,\n        uint256 backingTokenValue,\n        uint256 shareAmounts,\n        uint256 interestRate,\n        uint256 fee\n    );\n\n    /// @dev Event emitted on a successful BT/YBT redemption.\n    /// @param pool The Tempus Pool from which Tempus Shares were redeemed\n    /// @param redeemer Address of the user whose Shares (Principals and Yields) are redeemed\n    /// @param recipient Address of user that recieved Yield Bearing Tokens\n    /// @param principalShareAmount Number of Tempus Principal Shares (TPS) to redeem into the Yield Bearing Token (YBT)\n    /// @param yieldShareAmount Number of Tempus Yield Shares (TYS) to redeem into the Yield Bearing Token (YBT)\n    /// @param yieldTokenAmount Number of Yield bearing tokens redeemed from the pool\n    /// @param backingTokenValue Value of @param yieldTokenAmount expressed in backing tokens\n    /// @param interestRate Interest Rate of the underlying pool from Yield Bearing Tokens to the underlying asset\n    /// @param fee The fee which was deducted (in terms of yield bearing tokens)\n    /// @param isEarlyRedeem True in case of early redemption, otherwise false\n    event Redeemed(\n        address indexed pool,\n        address indexed redeemer,\n        address indexed recipient,\n        uint256 principalShareAmount,\n        uint256 yieldShareAmount,\n        uint256 yieldTokenAmount,\n        uint256 backingTokenValue,\n        uint256 interestRate,\n        uint256 fee,\n        bool isEarlyRedeem\n    );\n\n    /// @dev Atomically deposits YBT/BT to TempusPool and provides liquidity\n    ///      to the corresponding Tempus AMM with the issued TYS & TPS\n    /// @param tempusAMM Tempus AMM to use to swap TYS for TPS\n    /// @param tokenAmount Amount of YBT/BT to be deposited\n    /// @param isBackingToken specifies whether the deposited asset is the Backing Token or Yield Bearing Token\n    function depositAndProvideLiquidity(\n        ITempusAMM tempusAMM,\n        uint256 tokenAmount,\n        bool isBackingToken\n    ) external payable nonReentrant {\n        _depositAndProvideLiquidity(tempusAMM, tokenAmount, isBackingToken);\n    }\n\n    /// @dev Adds liquidity to tempusAMM with ratio of shares that is equal to ratio in AMM\n    /// @param tempusAMM Tempus AMM to provide liquidity to\n    /// @param sharesAmount Amount of shares to be used to provide liquidity, one of the sahres will be partially used\n    /// @notice If sharesAmount is 100 and amm balances ratio is 1 principal : 10 yields 90 principal will be \"unused\"\n    ///         So, liquidity will be provided with 10 principals and 100 yields\n    /// @notice msg.sender needs to approve Controller for both Principals and Yields for @param sharesAmount\n    function provideLiquidity(ITempusAMM tempusAMM, uint256 sharesAmount) external nonReentrant {\n        (\n            IVault vault,\n            bytes32 poolId,\n            IERC20[] memory ammTokens,\n            uint256[] memory ammBalances\n        ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);\n\n        _provideLiquidity(msg.sender, vault, poolId, ammTokens, ammBalances, sharesAmount, msg.sender);\n    }\n\n    /// @dev Atomically deposits YBT/BT to TempusPool and swaps TYS for TPS to get fixed yield\n    ///      See https://docs.balancer.fi/developers/guides/single-swaps#swap-overview\n    /// @param tempusAMM Tempus AMM to use to swap TYS for TPS\n    /// @param tokenAmount Amount of YBT/BT to be deposited in underlying YBT/BT decimal precision\n    /// @param isBackingToken specifies whether the deposited asset is the Backing Token or Yield Bearing Token\n    /// @param minTYSRate Minimum exchange rate of TYS (denominated in TPS) to receive in exchange for TPS\n    function depositAndFix(\n        ITempusAMM tempusAMM,\n        uint256 tokenAmount,\n        bool isBackingToken,\n        uint256 minTYSRate\n    ) external payable nonReentrant {\n        _depositAndFix(tempusAMM, tokenAmount, isBackingToken, minTYSRate);\n    }\n\n    /// @dev Deposits Yield Bearing Tokens to a Tempus Pool.\n    /// @param targetPool The Tempus Pool to which tokens will be deposited\n    /// @param yieldTokenAmount amount of Yield Bearing Tokens to be deposited\n    ///                         in YBT Contract precision which can be 18 or 8 decimals\n    /// @param recipient Address which will receive Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS)\n    function depositYieldBearing(\n        ITempusPool targetPool,\n        uint256 yieldTokenAmount,\n        address recipient\n    ) public nonReentrant {\n        _depositYieldBearing(targetPool, yieldTokenAmount, recipient);\n    }\n\n    /// @dev Deposits Backing Tokens into the underlying protocol and\n    ///      then deposited the minted Yield Bearing Tokens to the Tempus Pool.\n    /// @param targetPool The Tempus Pool to which tokens will be deposited\n    /// @param backingTokenAmount amount of Backing Tokens to be deposited into the underlying protocol\n    /// @param recipient Address which will receive Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS)\n    function depositBacking(\n        ITempusPool targetPool,\n        uint256 backingTokenAmount,\n        address recipient\n    ) public payable nonReentrant {\n        _depositBacking(targetPool, backingTokenAmount, recipient);\n    }\n\n    /// @dev Redeem TPS+TYS held by msg.sender into Yield Bearing Tokens\n    /// @notice `msg.sender` must approve Principals and Yields amounts to `targetPool`\n    /// @notice `msg.sender` will receive yield bearing tokens\n    /// @notice Before maturity, `principalAmount` must equal to `yieldAmount`\n    /// @param targetPool The Tempus Pool from which to redeem Tempus Shares\n    /// @param principalAmount Amount of Tempus Principals to redeem in PrincipalShare decimal precision\n    /// @param yieldAmount Amount of Tempus Yields to redeem in YieldShare decimal precision\n    /// @param recipient Address of user that will recieve yield bearing tokens\n    function redeemToYieldBearing(\n        ITempusPool targetPool,\n        uint256 principalAmount,\n        uint256 yieldAmount,\n        address recipient\n    ) public nonReentrant {\n        _redeemToYieldBearing(targetPool, msg.sender, principalAmount, yieldAmount, recipient);\n    }\n\n    /// @dev Redeem TPS+TYS held by msg.sender into Backing Tokens\n    /// @notice `sender` must approve Principals and Yields amounts to this TempusPool\n    /// @notice `recipient` will receive the backing tokens\n    /// @notice Before maturity, `principalAmount` must equal to `yieldAmount`\n    /// @param targetPool The Tempus Pool from which to redeem Tempus Shares\n    /// @param principalAmount Amount of Tempus Principals to redeem in PrincipalShare decimal precision\n    /// @param yieldAmount Amount of Tempus Yields to redeem in YieldShare decimal precision\n    /// @param recipient Address of user that will recieve yield bearing tokens\n    function redeemToBacking(\n        ITempusPool targetPool,\n        uint256 principalAmount,\n        uint256 yieldAmount,\n        address recipient\n    ) public nonReentrant {\n        _redeemToBacking(targetPool, msg.sender, principalAmount, yieldAmount, recipient);\n    }\n\n    /// @dev Withdraws liquidity from TempusAMM\n    /// @notice `msg.sender` needs to approve controller for @param lpTokensAmount of LP tokens\n    /// @notice Transfers LP tokens to controller and exiting tempusAmm with `msg.sender` as recipient\n    /// @param tempusAMM Tempus AMM instance\n    /// @param lpTokensAmount Amount of LP tokens to be withdrawn\n    /// @param principalAmountOutMin Minimal amount of TPS to be withdrawn\n    /// @param yieldAmountOutMin Minimal amount of TYS to be withdrawn\n    /// @param toInternalBalances Withdrawing liquidity to internal balances\n    function exitTempusAMM(\n        ITempusAMM tempusAMM,\n        uint256 lpTokensAmount,\n        uint256 principalAmountOutMin,\n        uint256 yieldAmountOutMin,\n        bool toInternalBalances\n    ) external nonReentrant {\n        _exitTempusAMM(tempusAMM, lpTokensAmount, principalAmountOutMin, yieldAmountOutMin, toInternalBalances);\n    }\n\n    /// @dev Withdraws liquidity from TempusAMM and redeems Shares to Yield Bearing or Backing Tokens\n    ///      Checks user's balance of principal shares and yield shares\n    ///      and exits AMM with exact amounts needed for redemption.\n    /// @notice `msg.sender` needs to approve `tempusAMM.tempusPool` for both Yields and Principals\n    ///         for `sharesAmount`\n    /// @notice `msg.sender` needs to approve controller for whole balance of LP token\n    /// @notice Transfers users' LP tokens to controller, then exits tempusAMM with `msg.sender` as recipient.\n    ///         After exit transfers remainder of LP tokens back to user\n    /// @notice Can fail if there is not enough user balance\n    /// @notice Only available before maturity since exiting AMM with exact amounts is disallowed after maturity\n    /// @param tempusAMM TempusAMM instance to withdraw liquidity from\n    /// @param principals Amount of Principals to redeem\n    /// @param yields Amount of Yields to redeem\n    /// @param principalsStaked Amount of staked principals (in TempusAMM) to redeem\n    /// @param yieldsStaked Amount of staked yields (in TempusAMM) to redeem\n    /// @param maxLpTokensToRedeem Maximum amount of LP tokens to spend for staked shares redemption\n    /// @param toBackingToken If true redeems to backing token, otherwise redeems to yield bearing\n    function exitTempusAMMAndRedeem(\n        ITempusAMM tempusAMM,\n        uint256 principals,\n        uint256 yields,\n        uint256 principalsStaked,\n        uint256 yieldsStaked,\n        uint256 maxLpTokensToRedeem,\n        bool toBackingToken\n    ) external nonReentrant {\n        _exitTempusAMMAndRedeem(\n            tempusAMM,\n            principals,\n            yields,\n            principalsStaked,\n            yieldsStaked,\n            maxLpTokensToRedeem,\n            toBackingToken\n        );\n    }\n\n    /// @dev Withdraws ALL liquidity from TempusAMM and redeems Shares to Yield Bearing or Backing Tokens\n    /// @notice `msg.sender` needs to approve controller for whole balance for both Yields and Principals\n    /// @notice `msg.sender` needs to approve controller for whole balance of LP token\n    /// @notice Can fail if there is not enough user balance\n    /// @param tempusAMM TempusAMM instance to withdraw liquidity from\n    /// @param lpTokens Number of Lp tokens to redeem\n    /// @param principals Number of Principals to redeem\n    /// @param yields Number of Yields to redeem\n    /// @param minPrincipalsStaked Minimum amount of staked principals to redeem for `lpTokens`\n    /// @param minYieldsStaked Minimum amount of staked yields to redeem for `lpTokens`\n    /// @param maxLeftoverShares Maximum amount of Principals or Yields to be left in case of early exit\n    /// @param toBackingToken If true redeems to backing token, otherwise redeems to yield bearing\n    function exitTempusAmmAndRedeem(\n        ITempusAMM tempusAMM,\n        uint256 lpTokens,\n        uint256 principals,\n        uint256 yields,\n        uint256 minPrincipalsStaked,\n        uint256 minYieldsStaked,\n        uint256 maxLeftoverShares,\n        bool toBackingToken\n    ) external nonReentrant {\n        _exitTempusAmmAndRedeem(\n            tempusAMM,\n            lpTokens,\n            principals,\n            yields,\n            getAMMOrderedAmounts(tempusAMM.tempusPool(), minPrincipalsStaked, minYieldsStaked),\n            maxLeftoverShares,\n            toBackingToken\n        );\n    }\n\n    /// Finalize the pool after maturity.\n    function finalize(ITempusPool targetPool) external nonReentrant {\n        targetPool.finalize();\n    }\n\n    /// Transfers accumulated Yield Bearing Token (YBT) fees\n    /// from @param targetPool contract to `recipient`.\n    /// @param targetPool The Tempus Pool from which to transfer fees\n    /// @param recipient Address which will receive the specified amount of YBT\n    function transferFees(ITempusPool targetPool, address recipient) external nonReentrant {\n        targetPool.transferFees(msg.sender, recipient);\n    }\n\n    function swap(\n        ITempusAMM tempusAMM,\n        uint256 swapAmount,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 minReturn\n    ) private {\n        require(swapAmount > 0, \"Invalid swap amount.\");\n        tokenIn.safeIncreaseAllowance(address(tempusAMM.getVault()), swapAmount);\n\n        (IVault vault, bytes32 poolId, , ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);\n\n        IVault.SingleSwap memory singleSwap = IVault.SingleSwap({\n            poolId: poolId,\n            kind: IVault.SwapKind.GIVEN_IN,\n            assetIn: tokenIn,\n            assetOut: tokenOut,\n            amount: swapAmount,\n            userData: \"\"\n        });\n\n        IVault.FundManagement memory fundManagement = IVault.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: payable(address(this)),\n            toInternalBalance: false\n        });\n        vault.swap(singleSwap, fundManagement, minReturn, block.timestamp);\n    }\n\n    function _depositAndProvideLiquidity(\n        ITempusAMM tempusAMM,\n        uint256 tokenAmount,\n        bool isBackingToken\n    ) private {\n        (\n            IVault vault,\n            bytes32 poolId,\n            IERC20[] memory ammTokens,\n            uint256[] memory ammBalances\n        ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);\n\n        uint256 mintedShares = _deposit(tempusAMM.tempusPool(), tokenAmount, isBackingToken);\n\n        uint256[] memory sharesUsed = _provideLiquidity(\n            address(this),\n            vault,\n            poolId,\n            ammTokens,\n            ammBalances,\n            mintedShares,\n            msg.sender\n        );\n\n        // Send remaining Shares to user\n        if (sharesUsed[0] < mintedShares) {\n            ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);\n        }\n        if (sharesUsed[1] < mintedShares) {\n            ammTokens[1].safeTransfer(msg.sender, mintedShares - sharesUsed[1]);\n        }\n    }\n\n    function _provideLiquidity(\n        address sender,\n        IVault vault,\n        bytes32 poolId,\n        IERC20[] memory ammTokens,\n        uint256[] memory ammBalances,\n        uint256 sharesAmount,\n        address recipient\n    ) private returns (uint256[] memory) {\n        uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);\n\n        if (sender != address(this)) {\n            ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);\n            ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);\n        }\n\n        ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);\n        ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);\n\n        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({\n            assets: ammTokens,\n            maxAmountsIn: ammLiquidityProvisionAmounts,\n            userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),\n            fromInternalBalance: false\n        });\n\n        // Provide TPS/TYS liquidity to TempusAMM\n        vault.joinPool(poolId, address(this), recipient, request);\n\n        return ammLiquidityProvisionAmounts;\n    }\n\n    function _depositAndFix(\n        ITempusAMM tempusAMM,\n        uint256 tokenAmount,\n        bool isBackingToken,\n        uint256 minTYSRate\n    ) private {\n        ITempusPool targetPool = tempusAMM.tempusPool();\n        IERC20 principalShares = IERC20(address(targetPool.principalShare()));\n        IERC20 yieldShares = IERC20(address(targetPool.yieldShare()));\n\n        uint256 swapAmount = _deposit(targetPool, tokenAmount, isBackingToken);\n\n        yieldShares.safeIncreaseAllowance(address(tempusAMM.getVault()), swapAmount);\n        uint256 minReturn = swapAmount.mulfV(minTYSRate, targetPool.backingTokenONE());\n        swap(tempusAMM, swapAmount, yieldShares, principalShares, minReturn);\n\n        // At this point all TYS must be swapped for TPS\n        uint256 principalsBalance = principalShares.balanceOf(address(this));\n        assert(principalsBalance > 0);\n        assert(yieldShares.balanceOf(address(this)) == 0);\n\n        principalShares.safeTransfer(msg.sender, principalsBalance);\n    }\n\n    function _deposit(\n        ITempusPool targetPool,\n        uint256 tokenAmount,\n        bool isBackingToken\n    ) private returns (uint256 mintedShares) {\n        mintedShares = isBackingToken\n            ? _depositBacking(targetPool, tokenAmount, address(this))\n            : _depositYieldBearing(targetPool, tokenAmount, address(this));\n    }\n\n    function _depositYieldBearing(\n        ITempusPool targetPool,\n        uint256 yieldTokenAmount,\n        address recipient\n    ) private returns (uint256) {\n        require(yieldTokenAmount > 0, \"yieldTokenAmount is 0\");\n\n        IERC20 yieldBearingToken = IERC20(targetPool.yieldBearingToken());\n\n        // Deposit to controller and approve transfer from controller to targetPool\n        uint transferredYBT = yieldBearingToken.untrustedTransferFrom(msg.sender, address(this), yieldTokenAmount);\n        yieldBearingToken.safeIncreaseAllowance(address(targetPool), transferredYBT);\n\n        (uint mintedShares, uint depositedBT, uint fee, uint rate) = targetPool.deposit(transferredYBT, recipient);\n\n        emit Deposited(\n            address(targetPool),\n            msg.sender,\n            recipient,\n            transferredYBT,\n            depositedBT,\n            mintedShares,\n            rate,\n            fee\n        );\n\n        return mintedShares;\n    }\n\n    function _depositBacking(\n        ITempusPool targetPool,\n        uint256 backingTokenAmount,\n        address recipient\n    ) private returns (uint256) {\n        require(backingTokenAmount > 0, \"backingTokenAmount is 0\");\n\n        IERC20 backingToken = IERC20(targetPool.backingToken());\n\n        if (msg.value == 0) {\n            backingTokenAmount = backingToken.untrustedTransferFrom(msg.sender, address(this), backingTokenAmount);\n            backingToken.safeIncreaseAllowance(address(targetPool), backingTokenAmount);\n        } else {\n            require(address(backingToken) == address(0), \"given TempusPool's Backing Token is not ETH\");\n        }\n\n        (uint256 mintedShares, uint256 depositedYBT, uint256 fee, uint256 interestRate) = targetPool.depositBacking{\n            value: msg.value\n        }(backingTokenAmount, recipient);\n\n        emit Deposited(\n            address(targetPool),\n            msg.sender,\n            recipient,\n            depositedYBT,\n            backingTokenAmount,\n            mintedShares,\n            interestRate,\n            fee\n        );\n\n        return mintedShares;\n    }\n\n    function _redeemToYieldBearing(\n        ITempusPool targetPool,\n        address sender,\n        uint256 principals,\n        uint256 yields,\n        address recipient\n    ) private {\n        require((principals > 0) || (yields > 0), \"principalAmount and yieldAmount cannot both be 0\");\n\n        (uint redeemedYBT, uint fee, uint interestRate) = targetPool.redeem(sender, principals, yields, recipient);\n\n        uint redeemedBT = targetPool.numAssetsPerYieldToken(redeemedYBT, targetPool.currentInterestRate());\n        bool earlyRedeem = !targetPool.matured();\n        emit Redeemed(\n            address(targetPool),\n            sender,\n            recipient,\n            principals,\n            yields,\n            redeemedYBT,\n            redeemedBT,\n            fee,\n            interestRate,\n            earlyRedeem\n        );\n    }\n\n    function _redeemToBacking(\n        ITempusPool targetPool,\n        address sender,\n        uint256 principals,\n        uint256 yields,\n        address recipient\n    ) private {\n        require((principals > 0) || (yields > 0), \"principalAmount and yieldAmount cannot both be 0\");\n\n        (uint redeemedYBT, uint redeemedBT, uint fee, uint rate) = targetPool.redeemToBacking(\n            sender,\n            principals,\n            yields,\n            recipient\n        );\n\n        bool earlyRedeem = !targetPool.matured();\n        emit Redeemed(\n            address(targetPool),\n            sender,\n            recipient,\n            principals,\n            yields,\n            redeemedYBT,\n            redeemedBT,\n            fee,\n            rate,\n            earlyRedeem\n        );\n    }\n\n    function _exitTempusAMM(\n        ITempusAMM tempusAMM,\n        uint256 lpTokensAmount,\n        uint256 principalAmountOutMin,\n        uint256 yieldAmountOutMin,\n        bool toInternalBalances\n    ) private {\n        require(tempusAMM.transferFrom(msg.sender, address(this), lpTokensAmount), \"LP token transfer failed\");\n\n        ITempusPool tempusPool = tempusAMM.tempusPool();\n        uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalAmountOutMin, yieldAmountOutMin);\n        _exitTempusAMMGivenLP(tempusAMM, address(this), msg.sender, lpTokensAmount, amounts, toInternalBalances);\n\n        assert(tempusAMM.balanceOf(address(this)) == 0);\n    }\n\n    function _exitTempusAMMGivenLP(\n        ITempusAMM tempusAMM,\n        address sender,\n        address recipient,\n        uint256 lpTokensAmount,\n        uint256[] memory minAmountsOut,\n        bool toInternalBalances\n    ) private {\n        require(lpTokensAmount > 0, \"LP token amount is 0\");\n\n        (IVault vault, bytes32 poolId, IERC20[] memory ammTokens, ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);\n\n        IVault.ExitPoolRequest memory request = IVault.ExitPoolRequest({\n            assets: ammTokens,\n            minAmountsOut: minAmountsOut,\n            userData: abi.encode(uint8(ITempusAMM.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT), lpTokensAmount),\n            toInternalBalance: toInternalBalances\n        });\n        vault.exitPool(poolId, sender, payable(recipient), request);\n    }\n\n    function _exitTempusAMMGivenAmountsOut(\n        ITempusAMM tempusAMM,\n        address sender,\n        address recipient,\n        uint256[] memory amountsOut,\n        uint256 lpTokensAmountInMax,\n        bool toInternalBalances\n    ) private {\n        (IVault vault, bytes32 poolId, IERC20[] memory ammTokens, ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);\n\n        IVault.ExitPoolRequest memory request = IVault.ExitPoolRequest({\n            assets: ammTokens,\n            minAmountsOut: amountsOut,\n            userData: abi.encode(\n                uint8(ITempusAMM.ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT),\n                amountsOut,\n                lpTokensAmountInMax\n            ),\n            toInternalBalance: toInternalBalances\n        });\n        vault.exitPool(poolId, sender, payable(recipient), request);\n    }\n\n    function _exitTempusAMMAndRedeem(\n        ITempusAMM tempusAMM,\n        uint256 principals,\n        uint256 yields,\n        uint256 principalsStaked,\n        uint256 yieldsStaked,\n        uint256 maxLpTokensToRedeem,\n        bool toBackingToken\n    ) private {\n        ITempusPool tempusPool = tempusAMM.tempusPool();\n        require(!tempusPool.matured(), \"Pool already finalized\");\n        principals += principalsStaked;\n        yields += yieldsStaked;\n        require(principals == yields, \"Needs equal amounts of shares before maturity\");\n\n        // transfer LP tokens to controller\n        require(tempusAMM.transferFrom(msg.sender, address(this), maxLpTokensToRedeem), \"LP token transfer failed\");\n\n        uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalsStaked, yieldsStaked);\n        _exitTempusAMMGivenAmountsOut(tempusAMM, address(this), msg.sender, amounts, maxLpTokensToRedeem, false);\n\n        // transfer remainder of LP tokens back to user\n        uint256 lpTokenBalance = tempusAMM.balanceOf(address(this));\n        require(tempusAMM.transferFrom(address(this), msg.sender, lpTokenBalance), \"LP token transfer failed\");\n\n        if (toBackingToken) {\n            _redeemToBacking(tempusPool, msg.sender, principals, yields, msg.sender);\n        } else {\n            _redeemToYieldBearing(tempusPool, msg.sender, principals, yields, msg.sender);\n        }\n    }\n\n    function _exitTempusAmmAndRedeem(\n        ITempusAMM tempusAMM,\n        uint256 lpTokens,\n        uint256 principals,\n        uint256 yields,\n        uint256[] memory minLpAmountsOut,\n        uint256 maxLeftoverShares,\n        bool toBackingToken\n    ) private {\n        ITempusPool tempusPool = tempusAMM.tempusPool();\n\n        IERC20 principalShare = IERC20(address(tempusPool.principalShare()));\n        IERC20 yieldShare = IERC20(address(tempusPool.yieldShare()));\n        require(principalShare.transferFrom(msg.sender, address(this), principals), \"Principals transfer failed\");\n        require(yieldShare.transferFrom(msg.sender, address(this), yields), \"Yields transfer failed\");\n\n        if (lpTokens > 0) {\n            // if there is LP balance, transfer to controller\n            require(tempusAMM.transferFrom(msg.sender, address(this), lpTokens), \"LP token transfer failed\");\n\n            // exit amm and sent shares to controller\n            _exitTempusAMMGivenLP(tempusAMM, address(this), address(this), lpTokens, minLpAmountsOut, false);\n        }\n\n        principals = principalShare.balanceOf(address(this));\n        yields = yieldShare.balanceOf(address(this));\n\n        if (!tempusPool.matured()) {\n            bool yieldsIn = yields > principals;\n            uint256 difference = yieldsIn ? (yields - principals) : (principals - yields);\n\n            if (difference >= maxLeftoverShares) {\n                (IERC20 tokenIn, IERC20 tokenOut) = yieldsIn\n                    ? (yieldShare, principalShare)\n                    : (principalShare, yieldShare);\n\n                swap(\n                    tempusAMM,\n                    tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),\n                    tokenIn,\n                    tokenOut,\n                    0\n                );\n\n                principals = principalShare.balanceOf(address(this));\n                yields = yieldShare.balanceOf(address(this));\n            }\n            (yields, principals) = (principals <= yields) ? (principals, principals) : (yields, yields);\n        }\n\n        if (toBackingToken) {\n            _redeemToBacking(tempusPool, address(this), principals, yields, msg.sender);\n        } else {\n            _redeemToYieldBearing(tempusPool, address(this), principals, yields, msg.sender);\n        }\n    }\n\n    function _getAMMDetailsAndEnsureInitialized(ITempusAMM tempusAMM)\n        private\n        view\n        returns (\n            IVault vault,\n            bytes32 poolId,\n            IERC20[] memory ammTokens,\n            uint256[] memory ammBalances\n        )\n    {\n        vault = tempusAMM.getVault();\n        poolId = tempusAMM.getPoolId();\n        (ammTokens, ammBalances, ) = vault.getPoolTokens(poolId);\n        require(\n            ammTokens.length == 2 && ammBalances.length == 2 && ammBalances[0] > 0 && ammBalances[1] > 0,\n            \"AMM not initialized\"\n        );\n    }\n\n    function getAMMOrderedAmounts(\n        ITempusPool tempusPool,\n        uint256 principalAmount,\n        uint256 yieldAmount\n    ) private view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](2);\n        (amounts[0], amounts[1]) = (tempusPool.principalShare() < tempusPool.yieldShare())\n            ? (principalAmount, yieldAmount)\n            : (yieldAmount, principalAmount);\n        return amounts;\n    }\n}\n\n\n",
        "CodeNames": [
            "TempusController.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "_depositAndProvideLiquidity"
                ],
                "Type": " Steal tokens from TempusController",
                "Description": "\n\nThe function _depositAndProvideLiquidity can be used go retrieve arbitrary ERC20 tokens from the TempusController.sol contract.\n\nAs the test contract of TempusController.sol <https://goerli.etherscan.io/address/0xd4330638b87f97ec1605d7ec7d67ea1de5dd7aaa shows, it has indeed ERC20 tokens.\n\nThe problem is due to the fact that you supply an arbitrary tempusAMM to depositAndProvideLiquidity and thus to _depositAndProvideLiquidity.\ntempusAMM could be a fake contract that supplies values that are completely fake.\n\nAt the end of the function _depositAndProvideLiquidity, ERC20 tokens are send to the user. If you can manipulate the variables ammTokens,  mintedShares  and sharesUsed you can send back\nany tokens held in the contract\n\"ammTokens[0].safeTransfer(msg.sender, mintedShares sharesUsed[0]);\"\n\nThe Proof of Concept shows an approach to do this.\n\n\n<https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L73-L79\n\n<https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L304-L335\n\nCreate a fake Vault contract (fakeVault) with the following functions:\nfakeVault.getPoolTokens(poolId) -- returns {TokenToSteal1,TokenToSteal2},{fakeBalance1,fakeBalance2},0\nfakeVault.JoinPoolRequest() -- do nothing\nfakeVault.joinPool() -- do nothing\n\nCreate a fake Pool contract (fakePool) with the following functions:\nfakePool.yieldBearingToken() -- returns fakeYieldBearingToken\nfakePool.deposit() -- returns fakeMintedShares,....\n\nCreate a fake ammTokens contract with the following functions:\ntempusAMM.getVault() -- returns fakeVault\ntempusAMM.getPoolId() -- returns 0\ntempusAMM.tempusPool() -- returns fakePool\n\ncall depositAndProvideLiquidity(fakeTempusAMM,1,false) // false - yieldBearingToken\n_getAMMDetailsAndEnsureInitialized returns fakeVault,0, {token1,token2},{balance1,balance2}\n_deposit(fakePool,1,false) calls _depositYieldBearing which calls fakePool.deposit()  and returns fakeMintedShares\n_provideLiquidity(...)  calculates a vale of ammLiquidityProvisionAmounts\n_provideLiquidity(...)  skips the safeTransferFrom because sender == address(this))\nthe calls to fakeVault.JoinPoolRequest() and fakeVault.joinPool() can be faked.\n_provideLiquidity(...)  returns the value ammLiquidityProvisionAmounts\n\nNow fakeMintedShares ammLiquidityProvisionAmounts number of TokenToSteal1 and TokenToSteal2 are transferred to msg.sender\n\nAs you can both manipulate TokenToSteal1 and fakeMintedShares, you can transfer any token to msg.sender\n\n",
                "Repair": "\nCreate a whitelist for tempusAMMs\n\nmijovic (Tempus) confirmed(https://github.com/code-423n4/2021-10-tempus-findings/issues/10#issuecomment-946718849):\n  This is a good point. However, these tokens that are locked in TempusController are coming from dust that was left when the user is doing early redemption. As this needs to be done with equal shares, we have a threshold parameter that is used as the maximum leftover behind redemption (usually there is a need to do a swap before redemption to make this work). So, this is going to be pennies always.\n\n I would not consider this as high risk, and we are not planning to fix this as steps to make this hack are too complicated to steal pennies... Also, the gas cost of doing it costs by far more than the funds that someone can steal.\n\nmijovic (Tempus) commented(https://github.com/code-423n4/2021-10-tempus-findings/issues/10#issuecomment-946905741):\n  We changed point of view here a little bit. Will add registry of TempusAMMs and TempusPools that can be used with controller, just to prevent possible attacks with fake amms and pools.\n\nmijovic (Tempus) patched(https://github.com/code-423n4/2021-10-tempus-findings/issues/10#issuecomment-948351797):\n  Added whitelist registry for both TempusAMM and TempusPool in this PR https://github.com/tempus-finance/tempus-protocol/pull/365\n However, as amount of tokens that TempusController holds is so small (I would say this is of severity 2)\n\n0xean (judge) commented(https://github.com/code-423n4/2021-10-tempus-findings/issues/10#issuecomment-954181571):\n  The C4 docs don't speculate on the amount of assets stolen in the TLDR of risk assessment.\n\n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n Given the fact that some amount of assets could be stolen, i believe this is the correct severity for the issue.\n\n\n\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "exitTempusAMM",
                    "_exitTempusAMM",
                    "lpTokensAmount",
                    "assert(tempusAMM.balanceOf(address(this)) =="
                ],
                "Type": "  exitTempusAMM  can be made to fail",
                "Description": "\nThere's a griefing attack where an attacker can make any user transaction for TempusController.exitTempusAMM fail.\nIn _exitTempusAMM, the user exits their LP position and claims back yield and principal shares.\nThe LP amounts to redeem are determined by the function parameter lpTokensAmount.\nA final assert(tempusAMM.balanceOf(address(this)) == 0) statement checks that the LP token amount of the contract is zero after the exit.\nThis is only true if no other LP shares were already in the contract.\n\nHowever, an attacker can frontrun this call and send the smallest unit of LP shares to the contract which then makes the original deposit-and-fix transaction fail.\n\n\nAll exitTempusAMM calls can be made to fail and this function becomes unusable.\n\n",
                "Repair": "\nRemove the assert check.\n\nmijovic (Tempus) confirmed(https://github.com/code-423n4/2021-10-tempus-findings/issues/21#issuecomment-947962445):\n  Great finding. This can block people exiting AMM via TempusController.\n\nmijovic (Tempus) patched(https://github.com/code-423n4/2021-10-tempus-findings/issues/21#issuecomment-948350606):\n  Fixed in https://github.com/tempus-finance/tempus-protocol/pull/369\n\n\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "depositAndFix",
                    "swapAmount",
                    "assert(yieldShares.balanceOf(address(this)) ==",
                    "_depositAndFix"
                ],
                "Type": "  depositAndFix  can be made to fail",
                "Description": "\nThere's a griefing attack where an attacker can make any user transaction for TempusController.depositAndFix fail.\nIn _depositAndFix, swapAmount many yield shares are swapped to principal where swapAmount is derived from the function arguments.\nA final assert(yieldShares.balanceOf(address(this)) == 0) statement checks that the yield shares of the contract are zero after the swap.\nThis is only true if no other yield shares were already in the contract.\n\nHowever, an attacker can frontrun this call and send the smallest unit of yield shares to the contract which then makes the original deposit-and-fix transaction fail.\n\n\nAll depositAndFix calls can be made to fail and this function becomes unusable.\n\n",
                "Repair": "\nRemove the assert check.\n\nmijovic confirmed(https://github.com/code-423n4/2021-10-tempus-findings/issues/20#issuecomment-948017482):\n  Good catch. This can block users from doing this action via controller\n\nmijovic patched(https://github.com/code-423n4/2021-10-tempus-findings/issues/20#issuecomment-948350220):\n  Fixed in https://github.com/tempus-finance/tempus-protocol/pull/370\n\n"
            }
        ]
    }
]