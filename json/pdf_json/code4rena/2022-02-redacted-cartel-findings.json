[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}\n\n\n",
        "CodeNames": [
            "BribeVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "setFee"
                ],
                "Type": " Manipulations of  setFee ",
                "Description": "\nBribeVault.sol#L104-L113(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L104-L113)<br\nBribeVault.sol#L164(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164)<br\nBribeVault.sol#L213(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L213)<br\nBribeVault.sol#L256(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L256)<br\n\nIf we consider that the fee variable is meaningfully applied, there will still be several problems with this:\n\n1.  Admin can setFee up to 100%. This is bad for users, fees should have a reasonable upper limit, e.g. 30% to prevent potential griefing.\n2.  Tokens are transferred in a separate function called transferBribes, which means that depositBribe txs have already settled. setFee can happen anytime, so an admin can change fees for already made deposits. I think this is again bad for users, as you need extra trust on an admin to not exploit this, and smart contracts should aim for as little external trust as possible.\n3.  Even if a fee would be applied in depositBribe, function setFee could frontrun user deposits. Consider using a timelock, so that users have time to react and adjust.\n\nkphed (Redacted Cartel) disagreed with Medium severity and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/113#issuecomment-1043705156):\n  We will likely set an upper bound as recommended, to ease user concerns. The admin being the Redacted multisig should also instill much trust and address most concerns.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/113#issuecomment-1052867924):\n  The warden identified a potential admin privilege that would allow to set the fee to 100%.\n \n I agree with the finding and severity.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nfunction depositBribeERC20(\n    bytes32 bribeIdentifier,\n    bytes32 rewardIdentifier,\n    address token,\n    uint256 amount,\n    address briber\n) external onlyRole(DEPOSITOR_ROLE) {\n    require(bribeIdentifier.length  0, \"Invalid bribeIdentifier\");\n    require(rewardIdentifier.length  0, \"Invalid rewardIdentifier\");\n    require(token != address(0), \"Invalid token\");\n    require(amount  0, \"Amount must be greater than 0\");\n    require(briber != address(0), \"Invalid briber\");\n\n    Bribe storage b = bribes[bribeIdentifier];\n    address currentToken = b.token;\n    require(\n        // If bribers want to bribe with a different token they need a new identifier\n        currentToken == address(0) || currentToken == token,\n        \"Cannot change token\"\n    );\n\n    // Since this method is called by a depositor contract, we must transfer from the account\n    // that called the depositor contract amount must be approved beforehand\n    IERC20(token).safeTransferFrom(briber, address(this), amount);\n    ...\n",
                    "//solidity\nfunction grantDepositorRole(address depositor)\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n{\n    require(depositor != address(0), \"Invalid depositor\");\n    _grantRole(DEPOSITOR_ROLE, depositor);\n\n    emit GrantDepositorRole(depositor);\n}\n"
                ],
                "Type": "  DEFAULT_ADMIN_ROLE  of  BribeVault  can steal tokens from users' wallets",
                "Description": "\nThe current design/implementation allows the DEFAULT_ADMIN_ROLE of BribeVault to steal funds from any address that approved this contract up to allowance:\n\nAs a DEFAULT_ADMIN_ROLE, the attack is simply do the following steps:\n\n    1. grantDepositorRole() to self;\n    2. BribeVault#depositBribeERC20() and transfer funds from victim's wallet;\n    3. emergencyWithdrawERC20().\n\nThis can be effectively used as a backdoor/attack vector for a malicious/compromised wallet with DEFAULT_ADMIN_ROLE of BribeVault to steal all the tokens from users' wallets for these users who have approved BribeVault.\n\nBribeVault.sol#L164-L187(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L164-L187)<br\n\nsolidity\nfunction depositBribeERC20(\n    bytes32 bribeIdentifier,\n    bytes32 rewardIdentifier,\n    address token,\n    uint256 amount,\n    address briber\n) external onlyRole(DEPOSITOR_ROLE) {\n    require(bribeIdentifier.length  0, \"Invalid bribeIdentifier\");\n    require(rewardIdentifier.length  0, \"Invalid rewardIdentifier\");\n    require(token != address(0), \"Invalid token\");\n    require(amount  0, \"Amount must be greater than 0\");\n    require(briber != address(0), \"Invalid briber\");\n\n    Bribe storage b = bribes[bribeIdentifier];\n    address currentToken = b.token;\n    require(\n        // If bribers want to bribe with a different token they need a new identifier\n        currentToken == address(0) || currentToken == token,\n        \"Cannot change token\"\n    );\n\n    // Since this method is called by a depositor contract, we must transfer from the account\n    // that called the depositor contract amount must be approved beforehand\n    IERC20(token).safeTransferFrom(briber, address(this), amount);\n    ...\n\n\nBribeVault.sol#L80-L88(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L80-L88)<br\n\nsolidity\nfunction grantDepositorRole(address depositor)\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n{\n    require(depositor != address(0), \"Invalid depositor\");\n    _grantRole(DEPOSITOR_ROLE, depositor);\n\n    emit GrantDepositorRole(depositor);\n}\n\n\n\nGiven:\n\n*   Alice (the victim) has approved BribeVault to spend WBTC;\n*   Alice has 100e8 WBTC in their wallet balance.\n\nA malicious/compromised DEFAULT_ADMIN_ROLE of BribeVault can do the following to steal tokens from users' wallets.\n\n1.  grantDepositorRole() to self;\n2.  depositBribeERC20() with: token = WBTC, amount = 100e8, and briber = Alice;\n3.  emergencyWithdrawERC20() with:  token = WBTC, amount = 100e8.\n\nAs a result, the 100e8 WBTC belongs Alice is now stolen by the Hacker.\n\nThe steps above can be repeated for all tokens and users, effectively stealing all the token balances from all the wallets that approved BribeVault up to the allowance limit, which usually is unlimited.\n\n",
                "Repair": "\n1.  Consider using TokemakBribe instead of BribeVault to hold users' allowances;\n2.  Consider making sure that the from parameter of transferFrom can only be msg.sender;\n3.  Consider using a multi-sig for the DEFAULT_ADMIN_ROLE of BribeVault.\n\nAlex the Entreprenerd (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/86#issuecomment-1059801248):\n  Fully agree with the finding and appreciate the level of detail.\n \n Because the exploit is contingent on a malicious owner, I believe Medium Severity to be more appropriate.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/86#issuecomment-1059801440):\n  The emergencyWithdrawERC20 without any check is a rug vector, protected exclusively by the multisig.<br\n While depositors may opt into this system, that doesn't mean that it's trust is fully reliant on the mulsitig, which means the code has trust assumptions by design.\n \n These trust assumptions make medium severity appropriate.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "SafeERC",
                    "transferBribes()"
                ],
                "Type": "  SafeERC20.sol  is imported but not used in the  transferBribes()  function ",
                "Description": "\nIn BribeVault.sol the transferBribes() function uses token.transfer() instead of token.safeTransfer.\nTokens that don\u2019t correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  The fact that the SafeERC20.sol library is imported at the top of the BribeVault.sol implies that safeTransfer should be being used but may have been forgotten.\n\n\nBribeVault.sol#L296(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296)<br\n\n",
                "Repair": "\nIt's recommended to use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.\n\nkphed (Redacted Cartel) confirmed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4#issuecomment-1040506429):\n  Good catch!\n \n Thanks again for participating in our contest jayjonah8, looking forward to more feedback/suggestions/comments.\n\nAlex the Entreprenerd (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4#issuecomment-1059786452):\n  Agree with the finding, because this is contingent on the specific token failing. I believe Medium severity to be more appropriate.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-10",
                "Location": [
                    "distributions",
                    "amounts[i]",
                    "transferBribes"
                ],
                "Type": " Distributions must not match actual bribes",
                "Description": "\nThe BribeVault.transferBribes transfers tokens for distribution.<br\nAll parameters (amounts, distributions) are blindly accepted by the function and never verified to match the actual bribes that were deposited for the distributions[i].rewardIdentifier.\n\nThe distributions[i].token must not match the distributions[i].rewardIdentifier's token (included in the reward identifier hash), and the amounts[i] (and fees) must not match the bribes[bribeIdentifier].amount.\n\nThe admin can submit arbitrary values and create distributions that don't reflect the bribe the distribution is actually for.\nIt's easy to under-or overreport amounts for a bribe, take amounts from a different bribe, or steal all amounts from users by using 100% fees, distribute the same bribe over and over, etc.\n\n",
                "Repair": "\nReduce the trust that users need to have in the admin by validating the Common.Distribution[] calldata distributions,  uint256[] calldata amounts, uint256[] calldata fees parameters against the deposited bribes.\n\nFor example:\n\n*   Check that the distributions[i].token matches the distributions[i].rewardIdentifier\n*   The amount + fees equal the bribes[bribeIdentifier].amount, then reset the bribes[bribeIdentifier].amount.\n\nkphed (Redacted Cartel) disagreed with High severity and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/33#issuecomment-1041726853):\n  We will be adding validation to the transferBribes method to provide peace of mind to our users, however, we consider this low-risk for the reasons below.\n \n  All parameters (amounts, distributions) are blindly accepted by the function and never verified to match the actual bribes that were deposited for the distributions[i].rewardIdentifier.\n  ...\n \n Compilation and thorough validation of the data necessary for calling transferBribes will be done off-chain using a publicly auditable set of scripts in our repo.\n \n Additionally, since the method can only be called by the protocol multisig (i.e. admin), signers will have the opportunity to review the data prior to submitting their signature. In conjunction with the above, they can generate their own data using the script and compare it against what is to be submitted.\n \n Thanks again for participating in our contest cmichel, looking forward to more feedback/suggestions/comments.\n\nAlex the Entreprenerd (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/33#issuecomment-1059803795):\n  I agree with the finding, the math for onChain bribes is not validated, while the math for bribes distribution is blindly trusted.\n \n This finding highlights a type of admin privilege, in which the admin can set arbitrary claims which do not reflect the actual state of the system.\n \n For this reason, as well as the eloquence of the warden, am going to mark this as valid and of medium severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-12",
                "Location": [
                    "updateRewardsMetadata()"
                ],
                "Type": " Users Can Frontrun Calls to  updateRewardsMetadata()  And Claim Tokens Twice",
                "Description": "\nThe updateRewardsMetadata() function is called by the BribeVault contract by the admin role. The function will take a list of distributions which are used to update the associated reward metadata. It is expected that the merkle root will be updated to correctly identify which claimers have already claimed tokens.\n\nreward.updateCount is incremented to reset the claimed tracker, allowing users that may have previously claimed, to claim their updated reward. However, there is potential for mis-use if users frontrun calls to updateRewardsMetadata() and claim their reward after the new merkle root has been calculated and updated by the admin role. This may allow the claimer to double claim their rewards or lead to a loss in rewards if the reward metadata completely replaces the previous list of claimers.\n\n\nRewardDistributor.sol#L97-L119(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119)<br\nRewardDistributor.sol#L127-L209(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209)<br\n\n",
                "Repair": "\nConsider implementing a delay where users cannot claim rewards before a call to updateRewardsMetadata() is made. This should ensure the admin role can construct a merkle tree based on the most up-to-date and correct data.\n\nkphed (Redacted Cartel) confirmed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118#issuecomment-1043693014):\n After speaking with leastwood via Discord, I now believe this issue to be meaningfully different from issue M-09 and is a valid attack vector. His recommended solution above inspired a fix which we both agreed would solve the problem (i.e. set a \"blank\" merkle root, evaluate the users who claimed with the previous merkle root, and construct a new one accordingly).\n\nAlex the Entreprenerd (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118#issuecomment-1059807830):\n  I appreciate the nuance from the sponsor over this finding.\n \n Ultimately when using a merkle proof system, the new proof is calculated at a certain time. (ProofX)\n \n If UserA didn't claim when the proof was generated, they technically have time between when the proof is generated and the proof is published to claim for the first time.\n \n Because the new Merkle Proof (ProofX) was built to allow UserA to claim, they will be able to claim again.\n \n The only way I can think of to avoid this is to always only have one proof per set of claims, as to avoid getting front-run.\n \n There is merit to make this finding separate, although ultimately the reason why this is possible is because of the Admin ability to change the proofs at any time.\n \n So I'm going to suggest that this finding is similar to M-09, it's mitigation should be basically the same, however I'll mark as separate to give credit where it's due.\n \n Because the finding is contingent on external conditions (owner getting frontrun or owner being malicious), I believe medium severity to be appropriate.\n \n A mitigation could be to push new proofs via Flashbots, and use a snapshot like system to check that no claims where made in the time between the proof generation and the proof being set.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-15",
                "Location": [
                    "fee",
                    "transferBribes"
                ],
                "Type": " Fees can be any amount",
                "Description": "\nIn transferBribes, the fees are user input, rather than  calculation using fee (state var).<br\nCurrently, fee is unused:\nBribeVault.sol#L23(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L23).<br\n\nTherefore the fees amounts might be wrong.\n\nAlex the Entreprenerd (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/74#issuecomment-1059990473):\n  I don't believe M-14 mentions validation of fees, as such will mark this finding as unique.\n\n Ultimately the function trusts the Admin input instead of using the storage variable, giving less security guarantees as to the fairness of the Distribution of the Bribes.\n \n Because this is contingent on a malicious admin, I believe medium severity to be appropriate.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "safeTransfer",
                    "safeTransferFrom",
                    "SafeERC"
                ],
                "Type": " BribeVault: Use  safeTransfer  for tokens",
                "Description": "\n\nBribeVault.sol#L296-L297(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297)<br\nBribeVault.sol#L337(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337)\n\n\nSome ERC20 tokens like ZRX don\u2019t revert if the transfer fails. Since the SafeERC20 has already been imported and the safeTransferFrom method used, the same should be done for token transfers.\n\n",
                "Repair": "\nReplace transfer with safeTransfer.\n\n\n"
            },
            {
                "Name": "-08",
                "Location": [
                    "//solidity\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length  0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length  0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value  0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n"
                ],
                "Type": " Avoid unnecessary storage read can save gas",
                "Description": "\n_Note: Suggested optimation, save a decent amount of gas without compromising readability_\n\nBribeVault.sol#L213-L248(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L213-L248)<br\n\nsolidity\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length  0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length  0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value  0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n\nBased on L224~~L230, L235~~L236, we know that b.token == address(this), therefore at L243 b.token can be replaced with address(this).\n\nUse address(this) directly can avoid unnecessary storage read of b.token and save some gas.\n\n",
                "Repair": "\nReplace:\n\nsolidity\nemit DepositBribe(\n    bribeIdentifier,\n    rewardIdentifier,\n    b.token,\n    msg.value,\n    b.amount,\n    briber\n);\n\n\nwith:\n\nsolidity\nemit DepositBribe(\n    bribeIdentifier,\n    rewardIdentifier,\n    address(this),\n    msg.value,\n    b.amount,\n    briber\n);\n\n\ndrahrealm (Redacted Cartel) confirmed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84#issuecomment-1045947596):\n  Some new gas optimization tricks confirmed \ud83d\udc4d \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84#issuecomment-1051415615):\n  Submission is really good.\n \n Adding the exact gas savings would be the cherry on top.\n \n Additionally adding a list of all the places in which to apply the optimization would have made this the best finding.\n \n Pretty good.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84#issuecomment-1051421241):\n  Best submission 8/10\n \n To improve:\n Actual Gas Savings math (sort findings by impact)\n List of all spots to fix (So the sponsor can implement instead of it being a puzzle)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ncontract RewardDistributor is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct Reward {\n        address token;\n        bytes32 merkleRoot;\n        bytes32 proof;\n        uint256 updateCount;\n    }\n\n    struct Claim {\n        bytes32 identifier;\n        address account;\n        uint256 index;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    address public bribeVault;\n    mapping(bytes32 => Reward) public rewards; // Maps each of the reward identifier to its metadata\n    mapping(bytes32 => mapping(uint256 => mapping(uint256 => uint256)))\n        private claimed; // Tracks whether a specific reward claim has been done\n\n    event SetBribeVault(address _bribeVault);\n    event RewardClaimed(\n        bytes32 indexed identifier,\n        address indexed tokenAddress,\n        address indexed account,\n        uint256 updateCount,\n        uint256 index,\n        uint256 amount\n    );\n    event RewardMetadataUpdated(\n        bytes32 indexed identifier,\n        address indexed token,\n        bytes32 merkleRoot,\n        bytes32 proof,\n        uint256 indexed updateCount\n    );\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Enables BribeVault to transfer native tokens\n    receive() external payable {}\n\n    /**\n        @notice Set bribe vault\n        @param  _bribeVault address New address of the bribe vault\n     */\n    function setBribeVault(address _bribeVault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        emit SetBribeVault(bribeVault);\n    }\n\n    /**\n        @notice Claim rewards based on the specified metadata\n        @param  _claims   Claim[] List of claim metadata\n     */\n    function claim(Claim[] calldata _claims) external nonReentrant {\n        require(_claims.length > 0, \"Invalid _claims\");\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            _claim(\n                _claims[i].identifier,\n                _claims[i].index,\n                _claims[i].account,\n                _claims[i].amount,\n                _claims[i].merkleProof\n            );\n        }\n    }\n\n    /**\n        @notice Update the overall metadata of the specified reward identifiers\n        @param  _distributions    Distribution[] List of reward distribution details\n     */\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length > 0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n\n    /**\n        @notice Check if the reward on the specified identifier and index has been claimed\n        @param  _identifier    bytes32 The specified identifier\n        @param  _index         bytes32 The specified index\n        @return  claimed       bool    Whether reward has been claimed\n     */\n    function isRewardClaimed(bytes32 _identifier, uint256 _index)\n        public\n        view\n        returns (bool)\n    {\n        // Get the group index for the specified index along with the bit index\n        // and check if the corresponding bit index is flipped\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n        uint256 claimedGroupState = claimed[_identifier][reward.updateCount][\n            claimedGroup\n        ];\n        uint256 mask = (1 << claimedIndex);\n        return claimedGroupState & mask == mask;\n    }\n\n    /**\n        @notice Claim a reward\n        @param  _rewardIdentifier  bytes32    Reward identifier\n        @param  _index             uint256    Node index\n        @param  _account           address    Eligible user account\n        @param  _amount            bytes32    Reward amount\n        @param  _merkleProof       bytes32[]  Merkle proof\n     */\n    function _claim(\n        bytes32 _rewardIdentifier,\n        uint256 _index,\n        address _account,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal {\n        Reward memory reward = rewards[_rewardIdentifier];\n        require(reward.merkleRoot != 0, \"Distribution not enabled\");\n        require(\n            !isRewardClaimed(_rewardIdentifier, _index),\n            \"Reward already claimed\"\n        );\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\n        require(\n            MerkleProof.verify(_merkleProof, reward.merkleRoot, node),\n            \"Invalid proof\"\n        );\n\n        _setClaimed(_rewardIdentifier, _index);\n\n        // Check whether the reward is in the form of native tokens or ERC20\n        // by checking if the token address is set to the bribe vault or not\n        address token = reward.token;\n        if (token != bribeVault) {\n            IERC20(token).safeTransfer(_account, _amount);\n        } else {\n            payable(_account).transfer(_amount);\n        }\n\n        emit RewardClaimed(\n            _rewardIdentifier,\n            token,\n            _account,\n            reward.updateCount,\n            _index,\n            _amount\n        );\n    }\n\n    /**\n        @notice Set a reward as claimed\n        @param  _identifier  bytes32    Reward identifier\n        @param  _index       uint256    Node index\n     */\n    function _setClaimed(bytes32 _identifier, uint256 _index) internal {\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n\n        // Flip the bit state to mark the corresponding index as claimed\n        claimed[_identifier][reward.updateCount][claimedGroup] =\n            claimed[_identifier][reward.updateCount][claimedGroup] |\n            (1 << claimedIndex);\n    }\n}\n\n\n",
        "CodeNames": [
            "BribeVault.sol",
            "RewardDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "\n\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n"
                ],
                "Type": " DEPOSITOR_ROLE can be granted by the deployer of  BribeVault  and transfer briber's approved ERC20 tokens to  bribeVault  by specifying any  bribeIdentifier  and  rewardIdentifier ",
                "Description": "\nIn the depositBribeERC20() function of the TokemakBribe contract, the briber can specify a proposal, and then call the depositBribeERC20 function of the bribeVault contract to deposit the reward.\n\n        function depositBribeERC20(\n            address proposal,\n            address token,\n            uint256 amount\n        ) external {\n            uint256 currentRound = _round;\n            require(\n                proposalDeadlines[proposal]  block.timestamp,\n                \"Proposal deadline has passed\"\n            );\n            require(token != address(0), \"Invalid token\");\n            require(amount  0, \"Bribe amount must be greater than 0\");\n\n            bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n                proposal,\n                currentRound,\n                token\n            );\n            bytes32 rewardIdentifier = generateRewardIdentifier(\n                currentRound,\n                token\n            );\n\n            IBribeVault(bribeVault).depositBribeERC20(\n                bribeIdentifier,\n                rewardIdentifier,\n                token,\n                amount,\n                msg.sender\n            );\n\nBut in the depositBribeERC20 function of the bribeVault contract, the address with DEPOSITOR_ROLE can transfer the briber's approved ERC20 tokens to bribeVault by specifying any bribeIdentifier and rewardIdentifier via safeTransferFrom.\n\n        function depositBribeERC20(\n            bytes32 bribeIdentifier,\n            bytes32 rewardIdentifier,\n            address token,\n            uint256 amount,\n            address briber\n        ) external onlyRole(DEPOSITOR_ROLE) {\n            require(bribeIdentifier.length  0, \"Invalid bribeIdentifier\");\n            require(rewardIdentifier.length  0, \"Invalid rewardIdentifier\");\n            require(token != address(0), \"Invalid token\");\n            require(amount  0, \"Amount must be greater than 0\");\n            require(briber != address(0), \"Invalid briber\");\n\n            Bribe storage b = bribes[bribeIdentifier];\n            address currentToken = b.token;\n            require(\n                // If bribers want to bribe with a different token they need a new identifier\n                currentToken == address(0) || currentToken == token,\n                \"Cannot change token\"\n            );\n\n            // Since this method is called by a depositor contract, we must transfer from the account\n            // that called the depositor contract amount must be approved beforehand\n            IERC20(token).safeTransferFrom(briber, address(this), amount);\n\nDEPOSITOR_ROLE can be granted by the deployer of BribeVault.\n\n\n\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n\n\n\nBribeVault.sol#L164-L205(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164-L205)\n\n",
                "Repair": "\nThe depositBribeERC20 function of the TokemakBribe contract needs to first transfer the briber's tokens to the TokemakBribe contract, and then transfer the tokens to the bribeVault contract in the depositBribeERC20 function of the bribeVault contract. Make sure the first parameter of safeTransferFrom is msg.sender.\n\nTokemakBribe.depositBribeERC20()\n\n        function depositBribeERC20(\n            address proposal,\n            address token,\n            uint256 amount\n        ) external {\n            uint256 currentRound = _round;\n            require(\n                proposalDeadlines[proposal]  block.timestamp,\n                \"Proposal deadline has passed\"\n            );\n            require(token != address(0), \"Invalid token\");\n            require(amount  0, \"Bribe amount must be greater than 0\");\n\n            bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n                proposal,\n                currentRound,\n                token\n            );\n            bytes32 rewardIdentifier = generateRewardIdentifier(\n                currentRound,\n                token\n            );\n    +       IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n            IBribeVault(bribeVault).depositBribeERC20(\n                bribeIdentifier,\n                rewardIdentifier,\n                token,\n                amount,\n                msg.sender\n            );\n\nbribeVault.depositBribeERC20()\n\n\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length  0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length  0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount  0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract amount must be approved beforehand\n      IERC20(token).safeTransferFrom(briber, address(this), amount);\n+\tIERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n\n\nkphed (Redacted Cartel) disputed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1#issuecomment-1040452376):\n  This isn't a concern since the \"depositor\" role can only be granted by admin (protocol multisig) depositors will only be bribe contracts that we've written and deployed.\n\n In the future, we may grant the depositor role to contracts that are written and deployed by 3rd parties, but they would all be thoroughly vetted in some manner and need to conform to the BribeVault's interface. \n\n Thanks again for participating in our contest cccz, looking forward to more feedback/suggestions/comments.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1#issuecomment-1059778323):\n  While this may not be a concern for the sponsor, the smart contract is supposed to be given allowance, this allowance can then be used by the DEPOSITOR_ROLE to perform a transfer.\n \n The smart can then allow the DEFAULT_ADMIN_ROLE to withdraw the funds.\n \n Ultimately the ability to deposit being permissioned and it's ability to pull unlimited funds is a strong admin privilege, which I'd recommend the sponsor to remove.\n \n A similar deposit flow with less strict permissions can be found in most Yield Farming Vaults, see Badger Vaults for example: Badger-Finance/Vault.sol#L671(https://github.com/Badger-Finance/badger-sett-1.5/blob/86a586cf30b806dc1ab7ea090f002e06a59d0706/contracts/Vault.sol#L671).\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "bribeVault",
                    "token",
                    "transfer()",
                    "ERC",
                    "setBribeVault()"
                ],
                "Type": " Changing  bribeVault  in  RewardDistributor.sol  will Lock Current ETH Rewards",
                "Description": "\nRewardDistributor.sol#L178-#L182(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L178-#L182)<br\nRewardDistributor.sol#L65-#L73(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65-#L73)\n\nClaiming of the ETH native currency requires token to be set to bribeVault. If the bribeVault is modified in setBribeVault() then users who have ETH rewards will now be considered to have ERC20(bribeVault) tokens. Since bribeVault is not an ERC20 token the transfer() call will fail and the users will not be able to claim their funds.\n\n",
                "Repair": "\nConsider removing the functionality to change the bribeVault or ensuring all funds have been withdraw i.e. balanceOf(address(this)) == 0 before changing the bribeVault.\n\nkphed (Redacted Cartel) confirmed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7#issuecomment-1040568870):\n  Good find, we're going to address this by making bribeVault immutable and removing the setter.\n \n Thanks again for participating in our contest kirk-baird, looking forward to more feedback/suggestions/comments.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7#issuecomment-1059788677):\n  Agree with the finding, ultimately preventing bribeVault from changing will provide users further security guarantees.\n \n An alternative solution would be to use a different code for ETH (I've seen protocols use address(0) or perhaps 0xeeeeeeee).\n \n However I believe that making bribeVault immutable will provide the stronger guarantees.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-09",
                "Location": [
                    "//solidity\nfunction updateRewardsMetadata(Common.Distribution[] calldata distributions)\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n{\n    require(distributions.length  0, \"Invalid distributions\");\n    IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n}\n",
                    "//solidity\nfunction updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length  0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n"
                ],
                "Type": " Improper control over the versions of distributions' metadata may lead to repeated claims of rewards",
                "Description": "\nBribeVault.sol#L317-L324(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L317-L324)<br\n\nsolidity\nfunction updateRewardsMetadata(Common.Distribution[] calldata distributions)\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n{\n    require(distributions.length  0, \"Invalid distributions\");\n    IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n}\n\n\nIn the current implementation, DEFAULT_ADMIN_ROLE of BribeVault can call updateRewardsMetadata() to update the rewards metadata for the specified identifiers.\n\nWhen a distribution's metadata is updated, it will also increase the updateCount and reset the claimed tracker.\n\nRewardDistributor.sol#L97-L119(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L97-L119)<br\n\nsolidity\nfunction updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length  0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n\n\nHowever, when the network is congested, DEFAULT_ADMIN_ROLE of BribeVault may mistakenly send 2 updateRewardsMetadata() txs, and the transactions can be packaged into different blocks.\n\nLet's say there 2 updateRewardsMetadata() tx with the same calldata, if someone claims rewards in between the two txs, then they can claim again after the second transaction.\n\n\nGiven:\n\n*   distributionA's proof is set wrong in transferBribes()\n*   Alice is eligible for rewards in distributionA\n*   the network is congested\n*   current block number = 10000\n\n1.  DEFAULT_ADMIN_ROLE of BribeVault tries to call updateRewardsMetadata() and update distributionA's proof;\n2.  After a while, since the prev tx is stucked, DEFAULT_ADMIN_ROLE of BribeVault calls updateRewardsMetadata() again with same calldata;\n3.  The first tx got packed into block 10010;\n4.  Alice calls claim() and got the reward;\n5.  The 2nd tx got packed into block 10020;\n6.  Alice calls claim() again and get the reward again.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nstruct UpdateDistribution {\n    bytes32 rewardIdentifier;\n    address token;\n    bytes32 merkleRoot;\n    bytes32 proof;\n    uint256 prevUpdateCount;\n}\n\nfunction updateRewardsMetadata(\n    Common.UpdateDistribution[] calldata _distributions\n) external {\n    require(msg.sender == bribeVault, \"Invalid access\");\n    require(_distributions.length  0, \"Invalid _distributions\");\n\n    for (uint256 i = 0; i < _distributions.length; i++) {\n        require(reward.updateCount == _distributions[i].prevUpdateCount, \"Invalid updateCount\");\n        // Update the metadata and also increment the update to reset the claimed tracker\n        Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n        reward.token = _distributions[i].token;\n        reward.merkleRoot = _distributions[i].merkleRoot;\n        reward.proof = _distributions[i].proof;\n        reward.updateCount += 1;\n\n        emit RewardMetadataUpdated(\n            _distributions[i].rewardIdentifier,\n            _distributions[i].token,\n            _distributions[i].merkleRoot,\n            _distributions[i].proof,\n            reward.updateCount\n        );\n    }\n}\n\n\nkphed (Redacted Cartel) disputed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/89#issuecomment-1043630034):\n   However, when the network is congested, DEFAULT_ADMIN_ROLE of BribeVault may mistakenly send 2 updateRewardsMetadata() txs, and the transactions can be packaged into different blocks.\n \n The tx is executed via a multisig we won't accidentally call it twice.\n \n  After a while, since the prev tx is stucked, DEFAULT_ADMIN_ROLE of BribeVault calls updateRewardsMetadata() again with same calldata;\n \n In the scenario where we wanted to call updateRewardsMetadata again with the same calldata, we would use the same nonce as the stuck transaction.\n\nAlex the Entreprenerd (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/89#issuecomment-1059802903):\n  I agree with both the warden and the sponsor in that I believe that:\n 1) the DEFAULT_ADMIN_ROLE can set metadata back to allow further (arbitrary) claims\n 2) This can be used by the admin to grief or alter the claimable rewards\n \n At the same time I have to agree that the Sponsor wouldn't be calling this \"accidentally\".\n \n I believe this finding to be valid, and to shed light into Admin Privilege, in that the Admin can set the metadata to whatever they want, allowing or denying claims at their will.\n \n As such I believe the finding to be valid, and Medium Severity to be more appropriate.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [],
                "Type": " RewardDistributor: Change  payable(account).transfer()  to  .call()  for native fund transfers",
                "Description": "\n\nRewardDistributor.sol#L181(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)<br\n\n\nBribeVault uses .call() for native fund transfers, but RewardDistributor uses .transfer(). They should be standardized to .call(), the currently recommended method since .transfer() fowards 2300 gas whereas .call() forwards all / set gas.(https://solidity-by-example.org/sending-ether/)\n\n",
                "Repair": "\njsx\n(bool sentAccount, ) = _account.call{value: _amount}(\"\");\nrequire(sentAccount, \"Failed to transfer to _account\");\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBTRFLY is IERC20 {\n    function burn(uint256 amount) external;\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IRedactedTreasury {\n    function manage(address _token, uint256 _amount) external;\n}\n\ninterface ICurveCryptoPool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\n        external\n        payable;\n\n    function calc_token_amount(uint256[2] calldata amounts)\n        external\n        view\n        returns (uint256);\n\n    // Would be replaced by Chainlink based oracle\n    function price_oracle() external view returns (uint256);\n\n    function token() external view returns (address);\n}\n\ncontract ThecosomataETH is Ownable {\n    address public immutable BTRFLY;\n    address public immutable WETH;\n    address public immutable CURVEPOOL;\n    address public immutable TREASURY;\n\n    uint256 private immutable _btrflyDecimals;\n    uint256 private immutable _ethDecimals;\n\n    uint256 public slippage = 5; // in 1000th\n\n    event AddLiquidity(\n        uint256 ethLiquidity,\n        uint256 btrflyLiquidity,\n        uint256 btrflyBurned\n    );\n\n    constructor(\n        address _BTRFLY,\n        address _WETH,\n        address _TREASURY,\n        address _CURVEPOOL\n    ) {\n        require(_BTRFLY != address(0), \"Invalid BTRFLY address\");\n        BTRFLY = _BTRFLY;\n\n        require(_WETH != address(0), \"Invalid WETH address\");\n        WETH = _WETH;\n\n        require(_CURVEPOOL != address(0), \"Invalid POOL address\");\n        CURVEPOOL = _CURVEPOOL;\n\n        require(_TREASURY != address(0), \"Invalid TREASURY address\");\n        TREASURY = _TREASURY;\n\n        IERC20(_BTRFLY).approve(_CURVEPOOL, 2**256 - 1);\n        IERC20(_WETH).approve(_CURVEPOOL, 2**256 - 1);\n\n        _btrflyDecimals = IBTRFLY(_BTRFLY).decimals();\n        _ethDecimals = IBTRFLY(_WETH).decimals();\n    }\n\n    // Update slippage percentage (in 1000th)\n    function setSlippage(uint256 _slippage) external onlyOwner {\n        // Make sure the slippage is less than 10%\n        require(_slippage < 100, \"Slippage too high\");\n        slippage = _slippage;\n    }\n\n    // Return whether we should perform an upkeep based on the contract's BTRFLY balance\n    function checkUpkeep()\n        public\n        view\n        returns (bool upkeepNeeded)\n    {\n        if (IBTRFLY(BTRFLY).balanceOf(address(this)) > 0) {\n            return true;\n        }\n    }\n\n    // Fetch the equivalent value of either specified BTRFLY/ETH amount\n    function calculateAmountRequiredForLP(uint256 amount, bool isBTRFLY)\n        internal\n        view\n        returns (uint256)\n    {\n        // Default price is based off \"1 BTRFLY = X ETH\", in 10^18 format\n        uint256 priceOracle = ICurveCryptoPool(CURVEPOOL).price_oracle();\n\n        if (isBTRFLY) {\n            return (((amount * priceOracle) / (10**18)) * (10**_ethDecimals)) /\n                (10**_btrflyDecimals);\n        }\n\n        return\n            (((amount * (10**18)) / priceOracle) *\n                (10**_btrflyDecimals)) / (10**_ethDecimals);\n    }\n\n    // Calculate the min. LP token amount (after slippage) and attempt to add liquidity\n    function addLiquidity(uint256 ethAmount, uint256 btrflyAmount) internal {\n        uint256[2] memory amounts = [ethAmount, btrflyAmount];\n        uint256 expectedAmount = ICurveCryptoPool(CURVEPOOL).calc_token_amount(\n            amounts\n        );\n        uint256 minAmount = expectedAmount - ((expectedAmount * slippage) / 1000);\n\n        ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount);\n    }\n\n    // Perform the actual upkeep flow\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap > ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity > 0 && btrflyLiquidity > 0, \"Insufficient amounts\");\n        addLiquidity(ethLiquidity, btrflyLiquidity);\n\n        // Transfer out the pool token to treasury\n        address token = ICurveCryptoPool(CURVEPOOL).token();\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(TREASURY, tokenBalance);\n\n        uint256 unusedBTRFLY = IBTRFLY(BTRFLY).balanceOf(address(this));\n\n        if (unusedBTRFLY > 0) {\n            IBTRFLY(BTRFLY).burn(unusedBTRFLY);\n        }\n\n        emit AddLiquidity(ethLiquidity, btrflyLiquidity, unusedBTRFLY);\n    }\n\n    // Withdraw arbitrary token and amount owned by the contract\n    function withdraw(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external onlyOwner {\n        require(recipient != address(0), \"Invalid recipient\");\n        IERC20(token).transfer(recipient, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ThecosomataETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nfunction addLiquidity(uint256 ethAmount, uint256 btrflyAmount) internal {\n    uint256[2] memory amounts = ethAmount, btrflyAmount];\n    uint256 expectedAmount = ICurveCryptoPool(CURVEPOOL).calc_token_amount(\n        amounts\n    );\n    uint256 minAmount = expectedAmount ((expectedAmount * slippage) / 1000);\n\n    ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount);\n}\n"
                ],
                "Type": " Wrong slippage check",
                "Description": "\nThe ThecosomataETH.addLiquidity function computes the expectedAmount and then subtracts a slippage percentage from it.\n\nsolidity\nfunction addLiquidity(uint256 ethAmount, uint256 btrflyAmount) internal {\n    uint256[2] memory amounts = ethAmount, btrflyAmount];\n    uint256 expectedAmount = ICurveCryptoPool(CURVEPOOL).calc_token_amount(\n        amounts\n    );\n    uint256 minAmount = expectedAmount ((expectedAmount * slippage) / 1000);\n\n    ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount);\n}\n\n\nAccording to the Curve docs 21.4(https://curve.readthedocs.io/_/downloads/en/latest/pdf/), this amount is already exact and takes the slippage into account (but not fees).\n\nIf the pool is imbalanced, the calc_token_amount will already return a wrong amount and the additional slippage check on the wrong amount is unnecessary (except for the fees).\n\n",
                "Repair": "\nConsider computing the minimum expected LP tokens off-chain and pass them to the performUpkeep function as a parameter to prevent sandwich attacks.\n\ndrahrealm (Redacted Cartel) confirmed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1041827707):\n  Thanks for the finding. Confirmed that this is not the right way for handling slippage. Will be updating the flow a little bit to allow externally sourced data for the expected amount.\n\nkphed (Redacted Cartel) disputed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1059166618):\n  Changing to \"sponsor disputed\" since using values derived off-chain doesn't prevent sandwich attacks and could make it easier to get sandwiched: using the off-chain calculation method, a MEV operator would only need to parse the tx input when deciding to front run us (vs. needing to simulate the tx if we were to do our calculations on-chain).\n \n Additionally, we're not using the StableSwap contract referenced in the warden's comment.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1059785983):\n  I think the sponsor's perspective is interesting in that I believe any MEV researcher could write a simple algorithm to check for the tx inputs to detect a slippage check.\n \n However in practice they'd still have to run a simulation as you could input the off-chain price with any variation (different decimals, as ETH, as USD, as BTC, multiply by 2 or 5 or w/e)\n \n Additionally while there can be arguments made as to how to mitigate, the finding is still valid.\n \n Asking Curve for the calc_token_amount will return whatever price the pool can offer at that time, because tx are atomic that means that any front-running or price manipulation would have already happened in a tx before the request.\n \n This means that at worst you could directly use the output from calc_token_amount (multiplication has no impact).\n \n What the finding also implies, is that if the pool were to be completely imbalances (99% of in asset, 1% of out asset) the price you'd get would be very low, and the code wouldn't be able to detect it (the code is effectively same as having 0 * .95)\n \n Because the finding has to do with potential value extraction, I believe the finding to be valid and of medium severity.\n \n As for mitigation, there are 2 viable options:\n 1) Use Chainlink Price Feed to get an accurate price\n 2) Provide the price as a parameter\n \n For option 2, I don't believe that argument to be valid for the examples above (just shift, multiply or obfuscate the param)\n Additionally, while you may never get a guarantee of perfect pricing, providing a price will give you a guarantee of a minimum price, this ensures you can opt-in into the slippage you'd be willing to tolerate.\n \n To give further details, let's look at using Flashbots (Flashbots RPC or a private mempool, either is a great idea).\n \n By using a private tx with the code provided for this contest, in the case of low liquidity, you'd still loose a considerable amount of value. No front-run needs to happen as in asking the price to the pool, you'll always get a valid response.\n \n This has happened to Yield Farming Aggregators (last I remember was yearn with StakeDAO token or similar). To summarize: Asking the price to the pool in the same tx is the same as having a 0 slippage check, which means you can loose value even without being front-run.\n \n Now let's add the idea of being front-run while using Flashbots RPC:<br\n - You have calculate the off-chain Price, which means there' a require that will revert if the tx will fail, which means (because Flashbots is awesome) the tx won't be mined unless the tx goes through (miner get's a tip).<br\n This means you can be extremely strict with your slippage check, providing you with as much MEV protection as possible.\n \n For these reasons I believe the finding to be valid and I recommend you do explore:\n Flashbots (private TXs)\n Price as parameter\n Chainlink Price Feeds\n \n\nkphed (Redacted Cartel) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1059802427):\n   I think the sponsor's perspective is interesting in that I believe any MEV researcher could write a simple algorithm to check for the tx inputs to detect a slippage check.\n \n That was my point, that it lowers the difficulty threshold.\n \n Thanks, the warden's recommended solution makes more sense now after your elaboration. We were planning on using Flashbots Protect and will look into your other suggestions as well.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-17",
                "Location": [
                    "jsx\n\u03b1 = 2^(\u2212 t / T1/2);\np_new = pLast * (1 \u03b1) + \u03b1 * p_old // p_old = current price_oracle\n"
                ],
                "Type": " ThecosomataETH: Oracle price can be better secured (freshness + tamper-resistance)",
                "Description": "\nThecosomataETH.sol#L94-L110(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L94-L110)<br\n\nThe ThecosomataETH contract adds ETH and BTRFLY tokens as liquidity into the ETH-BTRFLY curve crypto pool(https://etherscan.io/address/0xf43b15ab692fde1f9c24a9fce700adcc809d5391). The calculateAmountRequiredForLP() function relies on the price_oracle value returned by the pool to calculate the ETH and BTRFLY amounts to be added as liquidity. It is therefore important to ensure that price_oracle is accurate.\n\nAt the time of writing, the pool has about $5M in liquidity, which is comparable to that of the liquidity provided on UniswapV3(https://info.uniswap.org/#/pools/0xdf9ab3c649005ebfdf682d2302ca1f673e0d37a2). Flash loan attacks are therefore possible, but ineffective (explained further later).\n\nIn the curve v2 whitepaper(https://curve.fi/files/crypto-pools-paper.pdf), the price oracle mechanism is explained briefly in the \u201cAlgorithm for repegging\u201d section. It is reproduced below for convenience.\n\n Internally, we have a price oracle given by an exponential moving average (EMA) applied in N-dimensional price space. Suppose that the last reported price is pLast, and the update happened t seconds ago while the half-time of the EMA is T1/2. Then the oracle price p_new is given as:\n\njsx\n\u03b1 = 2^(\u2212 t / T1/2);\np_new = pLast * (1 \u03b1) + \u03b1 * p_old // p_old = current price_oracle\n\n\n\nWith oracles (curve pool now, to be switched to chainlink based oracle as per comment in L27), there is an inverse correlation between freshness and tamper-resistance.\n\nWe can expect price_oracle to be relatively fresh as trades will occur whenever arbitrage opportunities arise against the UniV3 pool which has comparable liquidity. Note that the ETH-BTRFLY pool has a half-time of 10 minutes (T1/2 = 600). This means that after exactly 10 mins, both pLast and p_old have equal weightage.\n\nIt is unclear how resistant the EMA oracle is against manipulation. Flash loan attacks, while possible, will be ineffective because t will be zero (pLast will be ignored in the update). However, a sophisticated attacker could possibly skew the price oracle by inflating the price of BTRFLY a couple of blocks before the performUpkeep() transaction to get the treasury to deposit more ETH / burn more BTRFLY than necessary.\n\n",
                "Repair": "\nIn my opinion, both freshness and tamper-resistance can be better secured.\n\nThis can be done by:\n\n1.  Ensuring that the price was updated within a certain limit.\n\njsx\n// eg. last price update / trade must have been executed within the past hour\nuint256 lastPricesTimestamp = ICurveCryptoPool(CURVEPOOL).last_prices_timestamp();\nrequire(block.timestamp lastPricesTimestamp <= 1 hours, 'stale price');\n\n\n2.  Checking that the last reported price pLast has not deviated too far from the current oracle price p_old. One can argue that it would be safer to add liquidity when the market isn\u2019t volatile.\n\njsx\nuint256 lastPrice = ICurveCryptoPool(CURVEPOOL).last_prices();\nuint256 oraclePrice = ICurveCryptoPool(CURVEPOOL).price_oracle();\nuint256 percentDiff;\n// eg. require difference in prices to be within 5%\nif (lastPrice  oraclePrice) {\n  percentDiff = (lastPrice oraclePrice) * 1e18 / oraclePrice;\n} else {\n  percentDiff = (oraclePrice lastPrice) * 1e18 / oraclePrice;\n}\nrequire(percentDiff <= 5e16, 'volatile market');\n\n\ndrahrealm (Redacted Cartel) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49#issuecomment-1042571538):\n  Idem with M-05, we will proceed with doing calculating the min token amount off-chain, then specify it when calling performUpKeep.\n \n Thanks for the finding.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49#issuecomment-1060059235):\n  Agree that solution is based off of M-05.<br \n While I believe simpler solutions where highlighted, I feel the warden put in the extra effort to make a valuable submission.\n \n As such, I'll mark the finding as unique.\n \n Personally I would not trust Curve Pricing model over a Price Feed at this time, however am happy to be proven wrong.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBTRFLY is IERC20 {\n    function burn(uint256 amount) external;\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IRedactedTreasury {\n    function manage(address _token, uint256 _amount) external;\n}\n\ninterface ICurveCryptoPool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\n        external\n        payable;\n\n    function calc_token_amount(uint256[2] calldata amounts)\n        external\n        view\n        returns (uint256);\n\n    // Would be replaced by Chainlink based oracle\n    function price_oracle() external view returns (uint256);\n\n    function token() external view returns (address);\n}\n\ncontract ThecosomataETH is Ownable {\n    address public immutable BTRFLY;\n    address public immutable WETH;\n    address public immutable CURVEPOOL;\n    address public immutable TREASURY;\n\n    uint256 private immutable _btrflyDecimals;\n    uint256 private immutable _ethDecimals;\n\n    uint256 public slippage = 5; // in 1000th\n\n    event AddLiquidity(\n        uint256 ethLiquidity,\n        uint256 btrflyLiquidity,\n        uint256 btrflyBurned\n    );\n\n    constructor(\n        address _BTRFLY,\n        address _WETH,\n        address _TREASURY,\n        address _CURVEPOOL\n    ) {\n        require(_BTRFLY != address(0), \"Invalid BTRFLY address\");\n        BTRFLY = _BTRFLY;\n\n        require(_WETH != address(0), \"Invalid WETH address\");\n        WETH = _WETH;\n\n        require(_CURVEPOOL != address(0), \"Invalid POOL address\");\n        CURVEPOOL = _CURVEPOOL;\n\n        require(_TREASURY != address(0), \"Invalid TREASURY address\");\n        TREASURY = _TREASURY;\n\n        IERC20(_BTRFLY).approve(_CURVEPOOL, 2**256 - 1);\n        IERC20(_WETH).approve(_CURVEPOOL, 2**256 - 1);\n\n        _btrflyDecimals = IBTRFLY(_BTRFLY).decimals();\n        _ethDecimals = IBTRFLY(_WETH).decimals();\n    }\n\n    // Update slippage percentage (in 1000th)\n    function setSlippage(uint256 _slippage) external onlyOwner {\n        // Make sure the slippage is less than 10%\n        require(_slippage < 100, \"Slippage too high\");\n        slippage = _slippage;\n    }\n\n    // Return whether we should perform an upkeep based on the contract's BTRFLY balance\n    function checkUpkeep()\n        public\n        view\n        returns (bool upkeepNeeded)\n    {\n        if (IBTRFLY(BTRFLY).balanceOf(address(this)) > 0) {\n            return true;\n        }\n    }\n\n    // Fetch the equivalent value of either specified BTRFLY/ETH amount\n    function calculateAmountRequiredForLP(uint256 amount, bool isBTRFLY)\n        internal\n        view\n        returns (uint256)\n    {\n        // Default price is based off \"1 BTRFLY = X ETH\", in 10^18 format\n        uint256 priceOracle = ICurveCryptoPool(CURVEPOOL).price_oracle();\n\n        if (isBTRFLY) {\n            return (((amount * priceOracle) / (10**18)) * (10**_ethDecimals)) /\n                (10**_btrflyDecimals);\n        }\n\n        return\n            (((amount * (10**18)) / priceOracle) *\n                (10**_btrflyDecimals)) / (10**_ethDecimals);\n    }\n\n    // Calculate the min. LP token amount (after slippage) and attempt to add liquidity\n    function addLiquidity(uint256 ethAmount, uint256 btrflyAmount) internal {\n        uint256[2] memory amounts = [ethAmount, btrflyAmount];\n        uint256 expectedAmount = ICurveCryptoPool(CURVEPOOL).calc_token_amount(\n            amounts\n        );\n        uint256 minAmount = expectedAmount - ((expectedAmount * slippage) / 1000);\n\n        ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount);\n    }\n\n    // Perform the actual upkeep flow\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap > ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity > 0 && btrflyLiquidity > 0, \"Insufficient amounts\");\n        addLiquidity(ethLiquidity, btrflyLiquidity);\n\n        // Transfer out the pool token to treasury\n        address token = ICurveCryptoPool(CURVEPOOL).token();\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(TREASURY, tokenBalance);\n\n        uint256 unusedBTRFLY = IBTRFLY(BTRFLY).balanceOf(address(this));\n\n        if (unusedBTRFLY > 0) {\n            IBTRFLY(BTRFLY).burn(unusedBTRFLY);\n        }\n\n        emit AddLiquidity(ethLiquidity, btrflyLiquidity, unusedBTRFLY);\n    }\n\n    // Withdraw arbitrary token and amount owned by the contract\n    function withdraw(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external onlyOwner {\n        require(recipient != address(0), \"Invalid recipient\");\n        IERC20(token).transfer(recipient, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0; \n\n// https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/release-v4.5/contracts/token/ERC20/ERC20.sol\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n",
        "CodeNames": [
            "ThecosomataETH.sol",
            "BribeVault.sol",
            "ERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "owner",
                    "withdraw"
                ],
                "Type": " Admin Privilege - Owner can rug via  ThecosomataETH.withdraw ",
                "Description": "\nDue to the generalized nature of withdraw the function is a clear rug-vector, allowing the owner to steal all funds.\n\nIdeally, you should add some validation logic to limit the tokens or the amounts that the owner can withdraw.\n\nAdditionally, it's important that you disclose the level of admin privilege and the risk it can cause to your users and depositors.\n\n",
                "Repair": "\nDisclose the admin privilege in your docs.<br\nRefactor the code to reduce it.\n\nkphed (Redacted Cartel) disputed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1042428554):\n  The owner is our protocol multisig which has proven itself to be a trustworthy steward of funds (e.g. manages the Redacted treasury funds).\n \n The withdraw method is simply a utility to remove any ERC20 tokens that are unintentionally received. There won't be any funds to steal since it's not intended for the Thecosomata contract to custody funds for any extended period of time: our keepers will constantly poll the contract so that any BTRFLY received gets paired with ETH and added to our Curve LP immediately any excess is burned.\n\nAlex the Entreprenerd (judge) closed as Invalid and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051071492):\n  It should be noted that I have submitted the finding, and in being judge of the contest am forfeiting my potential winnings.\n \n Personally, I don't believe a multisig gives any particular security guarantee to depositors beside the fact that it takes X amount of people to agree on how to move funds.\n \n The sponsor is making it clear that the owner in this case is also the depositor of funds.<br\n This means that the multi-sig is self custodying the funds into the contract.\n \n As such, the finding doesn't prove any additional security risk beside those that comes with a multi-sig.\n \n For those reasons, the finding is invalid.\n\nkphed (Redacted Cartel) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051158419):\n  Thanks for following up with your thoughts @Alex the Entreprenerd.\n \n NOTE: Mistakenly made comment below because I thought this was referring to the BribeVault contract.\n \n  The sponsor is making it clear that the owner in this case is also the depositor of funds.\n This means that the multi-sig is self custodying the funds into the contract.\n \n Just to clear up any miscommunication or misunderstandings, we've never stated that the owner is the depositor of funds the funds are deposited by bribers. The owner/admin only whitelists contracts that have permission to call the BribeVault's deposit methods but those contracts do not custody funds beyond the deposit transactions (this is also only the case when a briber deposits a native token).\n\nAlex the Entreprenerd (judge) reopened as Valid and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051192536):\n  Thank you for the clarification @kphed.\n \n If the bribers are not the same as the owner then the owner technically has the ability of withdrawing funds at any time, which puts the depositors under the risk of the owner rugging.\n \n Typically a Vault Protocol (Yearn, Badger) would have a check for \"protectedTokens\", in this case BTRFLY and WETH to prevent taking that type of operation.\n \n As it stands, the multisig can move the funds at any time, technically can frontrun the keeper and steal the funds.\n \n Also notice that you said that there will be a keeper for performUpkeep but the modifier is onlyOwner which either means you'll have an EOA as the owner, or you may want to change the access control checker (or remove it as Chainlink docs would require you to).\n \n With the information I have, I'm inclined to revert back to medium severity.\n \n While there's always the counter-argument that the multisig or governance will not rug, the only guarantee for it is the inability to rug by structuring the smart contract in a way that makes it impossible to move funds (e.g. add a check against moving BTRFLY and WETH, allow sweeping of other \"random\" tokens)\n\nkphed (Redacted Cartel) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051525527):\n  Sorry, disregard my last comment, I mistakenly read your comment as one directed towards BribeVault (which also has a method to withdraw tokens). You're correct, BTRFLY is minted by our protocol for ThecosomataETH. That said, we still don't consider the possibility of admin-rugging a real concern.\n \n  Typically a Vault Protocol (Yearn, Badger) would have a check for \"protectedTokens\", in this case BTRFLY and WETH to prevent taking that type of operation.\n \n This is a potential idea, thanks, I'll share it with the team.\n \n  Also notice that you said that there will be a keeper for performUpkeep but the modifier is onlyOwner which either means you'll have an EOA as the owner, or you may want to change the access control checker (or remove it as Chainlink docs would require you to).\n \n Tagging @drahrealm as he's implementing ThecosomataETH. Your comment about onlyOwner is a good one though it does appear to be a mistake or can be improved tremendously (e.g. use AccessControl and add a role limited to calling this and not the withdraw method).\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1059793149):\n  Would highly recommend limiting the withdrawal to specific tokens (ideally exclude important tokens), this would provide strong security guarantees against a rug.\n \n Also limiting roles can help reduce trust, however, it wouldn't address the underlying issue that \"someone\" can move the funds.\n \n With the information I have, I believe Medium Severity to be appropriate, and believe the sponsor has set motion to minimize trust as well as add additional security guarantees.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0; \n\n// https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/release-v4.5/contracts/token/ERC20/ERC20.sol\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n",
        "CodeNames": [
            "BribeVault.sol",
            "ERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-13",
                "Location": [
                    "transferFrom",
                    "bribeIdentifier",
                    "token",
                    "DEPOSITOR_ROLE",
                    "depositBribeERC",
                    "uint(-",
                    "amount"
                ],
                "Type": " Reentrancy in  depositBribeERC20  function",
                "Description": "\nBribeVault.sol#L164-L205(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164-L205)\n\ndepositBribeERC20 function in BriveVault is reentrant in line 187, where an address supplied by the caller is called.\n\nA bad actor that has DEPOSITOR_ROLE and is a contract can execute a folowing attack:\n\n1.  Create a dummy token contract, reentrant in the transferFrom() function. All tokens are approved to the BriveVault and the attacker contract has unlimited tokens. Reentrancy aims back to a function in the attacker contract, which calls depositBribeERC20 again.\n2.  The first call by the contract must use a novel bribeIdentifier. token is set to a dummy contract and amount to uint(-2).\n3.  All checks pass, transferFrom is called, which calls attacker contract, which can call depositBribeERC20 again, this time will transfer 1 wei of a valuable token, using the same bribeIdentifier. All checks pass as the previous token hasn't been registered yet. Then, a valid transfer happens. After that, the amount is set to 1 wei and the token is saved. Event is emitted and the function returns value. Then, attacker function returns and dummy token returns. The operation is to increment amount in storage by the transfer value, which increases b.amount to the maximum integer. The token is nonzero, so the if statement is passed.\n\nThus, an attacker can grant any amount of tokens from BriveVault to a certain bribe, stealing all the funds once the bribe will be withdrawn.\n\n",
                "Repair": "\nSet bribe token before the transfer is made.\n\nAlex the Entreprenerd (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/122#issuecomment-1059989503):\n  I do believe re-entrancy is possible, so I recommend the sponsor to add the nonReentrant modifier to the deposit function.\n \n I'll keep the finding separate from M-02] as this deals with reEntrancy.<br\n Mitigation would be to enforce a bribeIdentifier to be used for a specific token (and it being enforced), as well as adding nonReentrant.\n \n Because the function is permissioned, I believe medium severity to be more appropriate.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBTRFLY is IERC20 {\n    function burn(uint256 amount) external;\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IRedactedTreasury {\n    function manage(address _token, uint256 _amount) external;\n}\n\ninterface ICurveCryptoPool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\n        external\n        payable;\n\n    function calc_token_amount(uint256[2] calldata amounts)\n        external\n        view\n        returns (uint256);\n\n    // Would be replaced by Chainlink based oracle\n    function price_oracle() external view returns (uint256);\n\n    function token() external view returns (address);\n}\n\ncontract ThecosomataETH is Ownable {\n    address public immutable BTRFLY;\n    address public immutable WETH;\n    address public immutable CURVEPOOL;\n    address public immutable TREASURY;\n\n    uint256 private immutable _btrflyDecimals;\n    uint256 private immutable _ethDecimals;\n\n    uint256 public slippage = 5; // in 1000th\n\n    event AddLiquidity(\n        uint256 ethLiquidity,\n        uint256 btrflyLiquidity,\n        uint256 btrflyBurned\n    );\n\n    constructor(\n        address _BTRFLY,\n        address _WETH,\n        address _TREASURY,\n        address _CURVEPOOL\n    ) {\n        require(_BTRFLY != address(0), \"Invalid BTRFLY address\");\n        BTRFLY = _BTRFLY;\n\n        require(_WETH != address(0), \"Invalid WETH address\");\n        WETH = _WETH;\n\n        require(_CURVEPOOL != address(0), \"Invalid POOL address\");\n        CURVEPOOL = _CURVEPOOL;\n\n        require(_TREASURY != address(0), \"Invalid TREASURY address\");\n        TREASURY = _TREASURY;\n\n        IERC20(_BTRFLY).approve(_CURVEPOOL, 2**256 - 1);\n        IERC20(_WETH).approve(_CURVEPOOL, 2**256 - 1);\n\n        _btrflyDecimals = IBTRFLY(_BTRFLY).decimals();\n        _ethDecimals = IBTRFLY(_WETH).decimals();\n    }\n\n    // Update slippage percentage (in 1000th)\n    function setSlippage(uint256 _slippage) external onlyOwner {\n        // Make sure the slippage is less than 10%\n        require(_slippage < 100, \"Slippage too high\");\n        slippage = _slippage;\n    }\n\n    // Return whether we should perform an upkeep based on the contract's BTRFLY balance\n    function checkUpkeep()\n        public\n        view\n        returns (bool upkeepNeeded)\n    {\n        if (IBTRFLY(BTRFLY).balanceOf(address(this)) > 0) {\n            return true;\n        }\n    }\n\n    // Fetch the equivalent value of either specified BTRFLY/ETH amount\n    function calculateAmountRequiredForLP(uint256 amount, bool isBTRFLY)\n        internal\n        view\n        returns (uint256)\n    {\n        // Default price is based off \"1 BTRFLY = X ETH\", in 10^18 format\n        uint256 priceOracle = ICurveCryptoPool(CURVEPOOL).price_oracle();\n\n        if (isBTRFLY) {\n            return (((amount * priceOracle) / (10**18)) * (10**_ethDecimals)) /\n                (10**_btrflyDecimals);\n        }\n\n        return\n            (((amount * (10**18)) / priceOracle) *\n                (10**_btrflyDecimals)) / (10**_ethDecimals);\n    }\n\n    // Calculate the min. LP token amount (after slippage) and attempt to add liquidity\n    function addLiquidity(uint256 ethAmount, uint256 btrflyAmount) internal {\n        uint256[2] memory amounts = [ethAmount, btrflyAmount];\n        uint256 expectedAmount = ICurveCryptoPool(CURVEPOOL).calc_token_amount(\n            amounts\n        );\n        uint256 minAmount = expectedAmount - ((expectedAmount * slippage) / 1000);\n\n        ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount);\n    }\n\n    // Perform the actual upkeep flow\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap > ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity > 0 && btrflyLiquidity > 0, \"Insufficient amounts\");\n        addLiquidity(ethLiquidity, btrflyLiquidity);\n\n        // Transfer out the pool token to treasury\n        address token = ICurveCryptoPool(CURVEPOOL).token();\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(TREASURY, tokenBalance);\n\n        uint256 unusedBTRFLY = IBTRFLY(BTRFLY).balanceOf(address(this));\n\n        if (unusedBTRFLY > 0) {\n            IBTRFLY(BTRFLY).burn(unusedBTRFLY);\n        }\n\n        emit AddLiquidity(ethLiquidity, btrflyLiquidity, unusedBTRFLY);\n    }\n\n    // Withdraw arbitrary token and amount owned by the contract\n    function withdraw(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external onlyOwner {\n        require(recipient != address(0), \"Invalid recipient\");\n        IERC20(token).transfer(recipient, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}\n\n\n",
        "CodeNames": [
            "ThecosomataETH.sol",
            "BribeVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-16",
                "Location": [
                    "briber",
                    "WETH",
                    "DEPOSITOR_ROLE",
                    "safeTransferFrom"
                ],
                "Type": "  DEPOSITOR_ROLE  can manipulate  b.amount  value",
                "Description": "\nBribeVault.sol#L187(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L187)<br\n\nMalicious DEPOSITOR_ROLE can doing self transfer and manipulate b.amount\n\n\nIn case malicious DEPOSITOR_ROLE inputing WETH address and putting briber == address(this) in safeTransferFrom argument (which is self transfering). Therefore, it is posible to increase b.amount without any cost.\n\nWETH token contract:\n\n    //Line 62 WETH contract\n    function transferFrom(address src, address dst, uint wad)\n            public\n            returns (bool)\n        {\n            require(balanceOf[src] = wad);\n\n            if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) { \n                require(allowance[src][msg.sender] = wad); \n                allowance[src][msg.sender] -= wad; // <----------this line won't executed\n            }\n\n            balanceOf[src] -= wad;\n            balanceOf[dst] += wad;\n\n            Transfer(src, dst, wad);\n\n            return true;\n        }\n\nIf the condition didn't pass (in this case msg.sender != src ), the transaction will treated like a transfer (doesn't need an allowance), Therefore its possible to do self transfer\n\n",
                "Repair": "\nI recommend to validate that bribe != Address(this)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/95#issuecomment-1059993804):\n  I'm marking the finding as unique because of the interesting mechanic.<br\n Some ERC20 will revert on trying to transfer to yourself, however the warden showed a specific exploit, using WETH, that could be used against the vault.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ncontract RewardDistributor is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct Reward {\n        address token;\n        bytes32 merkleRoot;\n        bytes32 proof;\n        uint256 updateCount;\n    }\n\n    struct Claim {\n        bytes32 identifier;\n        address account;\n        uint256 index;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    address public bribeVault;\n    mapping(bytes32 => Reward) public rewards; // Maps each of the reward identifier to its metadata\n    mapping(bytes32 => mapping(uint256 => mapping(uint256 => uint256)))\n        private claimed; // Tracks whether a specific reward claim has been done\n\n    event SetBribeVault(address _bribeVault);\n    event RewardClaimed(\n        bytes32 indexed identifier,\n        address indexed tokenAddress,\n        address indexed account,\n        uint256 updateCount,\n        uint256 index,\n        uint256 amount\n    );\n    event RewardMetadataUpdated(\n        bytes32 indexed identifier,\n        address indexed token,\n        bytes32 merkleRoot,\n        bytes32 proof,\n        uint256 indexed updateCount\n    );\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Enables BribeVault to transfer native tokens\n    receive() external payable {}\n\n    /**\n        @notice Set bribe vault\n        @param  _bribeVault address New address of the bribe vault\n     */\n    function setBribeVault(address _bribeVault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        emit SetBribeVault(bribeVault);\n    }\n\n    /**\n        @notice Claim rewards based on the specified metadata\n        @param  _claims   Claim[] List of claim metadata\n     */\n    function claim(Claim[] calldata _claims) external nonReentrant {\n        require(_claims.length > 0, \"Invalid _claims\");\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            _claim(\n                _claims[i].identifier,\n                _claims[i].index,\n                _claims[i].account,\n                _claims[i].amount,\n                _claims[i].merkleProof\n            );\n        }\n    }\n\n    /**\n        @notice Update the overall metadata of the specified reward identifiers\n        @param  _distributions    Distribution[] List of reward distribution details\n     */\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length > 0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n\n    /**\n        @notice Check if the reward on the specified identifier and index has been claimed\n        @param  _identifier    bytes32 The specified identifier\n        @param  _index         bytes32 The specified index\n        @return  claimed       bool    Whether reward has been claimed\n     */\n    function isRewardClaimed(bytes32 _identifier, uint256 _index)\n        public\n        view\n        returns (bool)\n    {\n        // Get the group index for the specified index along with the bit index\n        // and check if the corresponding bit index is flipped\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n        uint256 claimedGroupState = claimed[_identifier][reward.updateCount][\n            claimedGroup\n        ];\n        uint256 mask = (1 << claimedIndex);\n        return claimedGroupState & mask == mask;\n    }\n\n    /**\n        @notice Claim a reward\n        @param  _rewardIdentifier  bytes32    Reward identifier\n        @param  _index             uint256    Node index\n        @param  _account           address    Eligible user account\n        @param  _amount            bytes32    Reward amount\n        @param  _merkleProof       bytes32[]  Merkle proof\n     */\n    function _claim(\n        bytes32 _rewardIdentifier,\n        uint256 _index,\n        address _account,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal {\n        Reward memory reward = rewards[_rewardIdentifier];\n        require(reward.merkleRoot != 0, \"Distribution not enabled\");\n        require(\n            !isRewardClaimed(_rewardIdentifier, _index),\n            \"Reward already claimed\"\n        );\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\n        require(\n            MerkleProof.verify(_merkleProof, reward.merkleRoot, node),\n            \"Invalid proof\"\n        );\n\n        _setClaimed(_rewardIdentifier, _index);\n\n        // Check whether the reward is in the form of native tokens or ERC20\n        // by checking if the token address is set to the bribe vault or not\n        address token = reward.token;\n        if (token != bribeVault) {\n            IERC20(token).safeTransfer(_account, _amount);\n        } else {\n            payable(_account).transfer(_amount);\n        }\n\n        emit RewardClaimed(\n            _rewardIdentifier,\n            token,\n            _account,\n            reward.updateCount,\n            _index,\n            _amount\n        );\n    }\n\n    /**\n        @notice Set a reward as claimed\n        @param  _identifier  bytes32    Reward identifier\n        @param  _index       uint256    Node index\n     */\n    function _setClaimed(bytes32 _identifier, uint256 _index) internal {\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n\n        // Flip the bit state to mark the corresponding index as claimed\n        claimed[_identifier][reward.updateCount][claimedGroup] =\n            claimed[_identifier][reward.updateCount][claimedGroup] |\n            (1 << claimedIndex);\n    }\n}\n\n\n",
        "CodeNames": [
            "RewardDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-03",
                "Location": [
                    "bribeVault"
                ],
                "Type": " RewardDistributor: Limit native fund transfers to  bribeVault ",
                "Description": "\n\nRewardDistributor.sol#L58-L59(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L58-L59)\n\n\nSince the only source of native fund transfers is expected to be the bribeVault contract, it would be good to restrict incoming fund transfers from other sources to prevent accidental transfers.\n\n",
                "Repair": "\njsx\nreceive() external payable {\n  require(msg.sender == bribeVault, 'only bribeVault');\n}\n\n\n\n"
            },
            {
                "Name": "-02",
                "Location": [
                    "bribeVault",
                    "SetBribeVault",
                    "setBribeVault()"
                ],
                "Type": " Emit relevant events in constructor methods when variables are set, or abstract to internal functions",
                "Description": "\n\nBribeVault.sol#L59-L74(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74)<br\n\nRewardDistributor.sol#L51-L56(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L51-L56)\n\n\nSome variables are set in the constructor method but do not emit events, unlike their setter counterparts. For instance, bribeVault in the RewardDistributor contract fails to emit the SetBribeVault event, but this is emitted in the setBribeVault() function.\n\n",
                "Repair": "\nEither emit the events in the constructor, or make the setter functions public and have the constructor call it.\n\nkphed (Redacted Cartel) confirmed and commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47#issuecomment-1045048948):\n   Overall, the code quality is great. Inline comments and documentation provided was adequate. Various parties / roles and contract interactions were well explained.\n \n Thanks for the compliment and the thorough code review! Both are greatly appreciated.\n \n  L-01] RewardDistributor: Change payable(account).transfer() to .call() for native fund transfers<br\n  L-02] BribeVault: Use safeTransfer for tokens<br\n  L-03] RewardDistributor: Limit native fund transfers to bribeVault<br\n  N-01] TokemakBribe: getBribe() has incorrect description<br\n  N-02] Emit relevant events in constructor methods when variables are set, or abstract to internal functions\n \n Thank you, we're planning on implementing all of the above.\n \n  L-04] TokemakBribe: Sync rounds with Tokemak\u2019s manager instead of manually setting rounds via setRound()\n \n This was an option we've considered but we opted for setting the round manually since our schedule may not always be in lockstep with Tokemak's (e.g. there may be off-chain activities governance, disputes, etc. that may result in us taking delayed action). That said, your recommended implementation is a great middle ground solution, thank you for that.\n\nkphed (Redacted Cartel) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47#issuecomment-1045081504):\n  Your comment has inspired a potentially more streamlined solution without needing round: using a proposal's deadline to segregate the token deposits for a general time period (i.e. voting round). Thank you!\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47#issuecomment-1052808940):\n  The report is great, gives some general considerations as well as specific advice to implement.<br\n Great submission.\n \n Only negative note is the warden missed re-entrancy, beside that, this is how I think a QA report should be done.\n\n Score: 7/10\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 18 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84) by warden team WatchPug received the top score from the judge.\n\n_The following wardens also submitted reports: csanuragjain(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/8), 0x1f8b(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/12), Jujic(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/53), ye0lde(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/79), hickuphh3(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/46), IllIllI(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/59), pauliax(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/116), kenta(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/16), robee(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/28), gzeon(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/71), Omik(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/110), rfa(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/99), z3s(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/63), d4rk(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/50), SolidityScan(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/94), Tomio(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/124), and defsec(https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/100)._\n\n\n"
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\n    address public bribeVault;\n",
                    "//solidity\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n"
                ],
                "Type": " Using immutable variable can save gas",
                "Description": "\n_Note: Suggested optimation, save a decent amount of gas without compromising readability._\n\nTokemakBribe.sol#L28-L28(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L28-L28)<br\n\nsolidity\n    address public bribeVault;\n\n\nTokemakBribe.sol#L60-L65(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L60-L65)<br\n\nsolidity\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n\nConsidering that bribeVault will never change, changing it to immutable variable instead of storage variable can save gas.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ninterface IBribeVault {\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external;\n\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount);\n\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable;\n}\n\ncontract TokemakBribe is AccessControl {\n    address public bribeVault;\n\n    // Used for generating the bribe and reward identifiers\n    string public constant protocol = \"TOKEMAK\";\n    uint256 private _round;\n\n    // Proposal addresses mapped to deadlines by which bribers can deposit\n    mapping(address => uint256) public proposalDeadlines;\n\n    // Voter addresses mapped to addresses which will claim rewards on their behalf\n    mapping(address => address) public rewardForwarding;\n\n    bytes32 public constant TEAM_ROLE = keccak256(\"TEAM_ROLE\");\n\n    event GrantTeamRole(address teamMember);\n    event RevokeTeamRole(address teamMember);\n    event SetProposal(\n        address indexed proposal,\n        uint256 deadline,\n        uint256 indexed round\n    );\n    event SetProposals(address[] proposals, uint256[] deadlines, uint256 round);\n    event DepositBribe(\n        address indexed proposal,\n        uint256 indexed round,\n        address indexed token,\n        uint256 amount,\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier\n    );\n    event SetRewardForwarding(address from, address to);\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                hasRole(TEAM_ROLE, msg.sender),\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    /**\n        @notice Grant the team role to an address\n        @param  teamMember  address  Address to grant the teamMember role\n     */\n    function grantTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(teamMember != address(0), \"Invalid teamMember\");\n        _grantRole(TEAM_ROLE, teamMember);\n\n        emit GrantTeamRole(teamMember);\n    }\n\n    /**\n        @notice Revoke the team role from an address\n        @param  teamMember  address  Address to revoke the teamMember role\n     */\n    function revokeTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(TEAM_ROLE, teamMember), \"Invalid teamMember\");\n        _revokeRole(TEAM_ROLE, teamMember);\n\n        emit RevokeTeamRole(teamMember);\n    }\n\n    /**\n        @notice Set a new voting round\n        @param  _newRound uint256 The new round number\n     */\n    function setRound(uint256 _newRound) external onlyAuthorized {\n        _round = _newRound;\n    }\n\n    /**\n        @notice Set a new voting round\n        @return round uint256 The current round number\n     */\n    function getRound() external view returns (uint256) {\n        return _round;\n    }\n\n    /**\n        @notice Set a single proposal\n        @param  proposal  addresss Proposal address\n        @param  deadline  uint256  Proposal deadline\n     */\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline >= block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n\n        emit SetProposal(proposal, deadline, _round);\n    }\n\n    /**\n        @notice Set multiple proposals\n        @param  proposals  address[]  Proposal addresses\n        @param  deadlines  uint256[]  Proposal deadlines\n     */\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length > 0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n\n    /**\n        @notice Generate the BribeVault identifier based on a scheme\n        @param  proposal    address  Proposal\n        @param  round       uint256  Voting round\n        @param  token       address  Token\n        @return identifier  bytes32  BribeVault identifier\n     */\n    function generateBribeVaultIdentifier(\n        address proposal,\n        uint256 round,\n        address token\n    ) internal pure returns (bytes32 identifier) {\n        return keccak256(abi.encodePacked(protocol, proposal, round, token));\n    }\n\n    /**\n        @notice Generate the reward identifier based on a scheme\n        @param  round       uint256  Round\n        @param  token       address  Token\n        @return identifier  bytes32  Reward identifier\n     */\n    function generateRewardIdentifier(uint256 round, address token)\n        internal\n        pure\n        returns (bytes32 identifier)\n    {\n        return keccak256(abi.encodePacked(protocol, round, token));\n    }\n\n    /**\n        @notice Get bribe from BribeVault\n        @param  proposal            address  Proposal\n        @param  token               address  Token\n        @return bribeToken          address  Token address\n        @return bribeAmount         address  Token address\n     */\n    function getBribe(\n        address proposal,\n        uint256 round,\n        address token\n    ) external view returns (address bribeToken, uint256 bribeAmount) {\n        return\n            IBribeVault(bribeVault).getBribe(\n                generateBribeVaultIdentifier(proposal, round, token)\n            );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (ERC20 tokens only)\n        @param  proposal  address  Proposal\n        @param  token     address  Token\n        @param  amount    uint256  Token amount\n     */\n    function depositBribeERC20(\n        address proposal,\n        address token,\n        uint256 amount\n    ) external {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            token\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            token\n        );\n\n        IBribeVault(bribeVault).depositBribeERC20(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            token,\n            amount,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (native token only)\n        @param  proposal  address  Proposal\n     */\n    function depositBribe(address proposal) external payable {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(msg.value > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            bribeVault\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            bribeVault\n        );\n\n        IBribeVault(bribeVault).depositBribe{value: msg.value}(\n            // NOTE: Native token bribes have bribeVault set as the address\n            bribeIdentifier,\n            rewardIdentifier,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            bribeVault,\n            msg.value,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Voters can opt in or out of reward-forwarding\n        @notice Opt-in: A voter sets another address to forward rewards to\n        @notice Opt-out: A voter sets their own address or the zero address\n        @param  to  address  Account that rewards will be sent to\n     */\n    function setRewardForwarding(address to) public {\n        rewardForwarding[msg.sender] = to;\n\n        emit SetRewardForwarding(msg.sender, to);\n    }\n}\n\n\n",
        "CodeNames": [
            "TokemakBribe.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-04",
                "Location": [
                    "setRound()"
                ],
                "Type": " TokemakBribe: Sync rounds with Tokemak\u2019s manager instead of manually setting rounds via  setRound() ",
                "Description": "\n\nTokemakBribe.sol#L104-L110(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L104-L110)\n\n\nInstead of manually setting rounds, consider fetching the round number directly from Tokemak\u2019s manager contract via [manager.currentCycleIndex()(https://etherscan.io/address/0xa86e412109f77c45a3bc1c5870b880492fb86a14#readProxyContract). While I initially wrote an issue about being able to set previous round numbers, after having chatted with the sponsor, it is intended to be a feature, not a bug.\n\n",
                "Repair": "\njsx\n// TODO: change _round to getRound() wherever it is called in other internal functions\nfunction getRound() public view returns (uint256) {\n  // if round is overridden, return set value\n  if (_round != 0) return _round;\n  // otherwise, if value is 0, use Tokemak's currentCycleIndex()\n  // Tokemak manager at 0xa86e412109f77c45a3bc1c5870b880492fb86a14\n  return manager.currentCycleIndex();\n}\n\n\n\n"
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline = block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n\n        emit SetProposal(proposal, deadline, _round);\n    }\n",
                    "//solidity\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length  0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n"
                ],
                "Type": " Remove redundant access control checks can save gas",
                "Description": "\n_Note: suggested optimation, save a decent amount of gas without compromising readability._\n\nTokemakBribe.sol#L125-L135(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L125-L135)<br\n\nsolidity\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline = block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n\n        emit SetProposal(proposal, deadline, _round);\n    }\n\n\nTokemakBribe.sol#L142-L157(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L142-L157)<br\n\nsolidity\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length  0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n\n\nsetProposal() already got onlyAuthorized check, and setProposals() will check it again multiple times.\n\nConsider creating _setProposal() private function without access control and call it inside the public functions.\n\n",
                "Repair": "\nChange to:\n\nsolidity\n    function _setProposal(address proposal, uint256 deadline)\n        private\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline = block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n    }\n\n    /\n        @notice Set a single proposal\n        @param  proposal  addresss Proposal address\n        @param  deadline  uint256  Proposal deadline\n     */\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        _setProposal(proposal, deadline);\n        emit SetProposal(proposal, deadline, _round);\n    }\n\n    /\n        @notice Set multiple proposals\n        @param  proposals  address[]  Proposal addresses\n        @param  deadlines  uint256[]  Proposal deadlines\n     */\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length  0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            _setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ninterface IBribeVault {\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external;\n\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount);\n\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable;\n}\n\ncontract TokemakBribe is AccessControl {\n    address public bribeVault;\n\n    // Used for generating the bribe and reward identifiers\n    string public constant protocol = \"TOKEMAK\";\n    uint256 private _round;\n\n    // Proposal addresses mapped to deadlines by which bribers can deposit\n    mapping(address => uint256) public proposalDeadlines;\n\n    // Voter addresses mapped to addresses which will claim rewards on their behalf\n    mapping(address => address) public rewardForwarding;\n\n    bytes32 public constant TEAM_ROLE = keccak256(\"TEAM_ROLE\");\n\n    event GrantTeamRole(address teamMember);\n    event RevokeTeamRole(address teamMember);\n    event SetProposal(\n        address indexed proposal,\n        uint256 deadline,\n        uint256 indexed round\n    );\n    event SetProposals(address[] proposals, uint256[] deadlines, uint256 round);\n    event DepositBribe(\n        address indexed proposal,\n        uint256 indexed round,\n        address indexed token,\n        uint256 amount,\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier\n    );\n    event SetRewardForwarding(address from, address to);\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                hasRole(TEAM_ROLE, msg.sender),\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    /**\n        @notice Grant the team role to an address\n        @param  teamMember  address  Address to grant the teamMember role\n     */\n    function grantTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(teamMember != address(0), \"Invalid teamMember\");\n        _grantRole(TEAM_ROLE, teamMember);\n\n        emit GrantTeamRole(teamMember);\n    }\n\n    /**\n        @notice Revoke the team role from an address\n        @param  teamMember  address  Address to revoke the teamMember role\n     */\n    function revokeTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(TEAM_ROLE, teamMember), \"Invalid teamMember\");\n        _revokeRole(TEAM_ROLE, teamMember);\n\n        emit RevokeTeamRole(teamMember);\n    }\n\n    /**\n        @notice Set a new voting round\n        @param  _newRound uint256 The new round number\n     */\n    function setRound(uint256 _newRound) external onlyAuthorized {\n        _round = _newRound;\n    }\n\n    /**\n        @notice Set a new voting round\n        @return round uint256 The current round number\n     */\n    function getRound() external view returns (uint256) {\n        return _round;\n    }\n\n    /**\n        @notice Set a single proposal\n        @param  proposal  addresss Proposal address\n        @param  deadline  uint256  Proposal deadline\n     */\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline >= block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n\n        emit SetProposal(proposal, deadline, _round);\n    }\n\n    /**\n        @notice Set multiple proposals\n        @param  proposals  address[]  Proposal addresses\n        @param  deadlines  uint256[]  Proposal deadlines\n     */\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length > 0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n\n    /**\n        @notice Generate the BribeVault identifier based on a scheme\n        @param  proposal    address  Proposal\n        @param  round       uint256  Voting round\n        @param  token       address  Token\n        @return identifier  bytes32  BribeVault identifier\n     */\n    function generateBribeVaultIdentifier(\n        address proposal,\n        uint256 round,\n        address token\n    ) internal pure returns (bytes32 identifier) {\n        return keccak256(abi.encodePacked(protocol, proposal, round, token));\n    }\n\n    /**\n        @notice Generate the reward identifier based on a scheme\n        @param  round       uint256  Round\n        @param  token       address  Token\n        @return identifier  bytes32  Reward identifier\n     */\n    function generateRewardIdentifier(uint256 round, address token)\n        internal\n        pure\n        returns (bytes32 identifier)\n    {\n        return keccak256(abi.encodePacked(protocol, round, token));\n    }\n\n    /**\n        @notice Get bribe from BribeVault\n        @param  proposal            address  Proposal\n        @param  token               address  Token\n        @return bribeToken          address  Token address\n        @return bribeAmount         address  Token address\n     */\n    function getBribe(\n        address proposal,\n        uint256 round,\n        address token\n    ) external view returns (address bribeToken, uint256 bribeAmount) {\n        return\n            IBribeVault(bribeVault).getBribe(\n                generateBribeVaultIdentifier(proposal, round, token)\n            );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (ERC20 tokens only)\n        @param  proposal  address  Proposal\n        @param  token     address  Token\n        @param  amount    uint256  Token amount\n     */\n    function depositBribeERC20(\n        address proposal,\n        address token,\n        uint256 amount\n    ) external {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            token\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            token\n        );\n\n        IBribeVault(bribeVault).depositBribeERC20(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            token,\n            amount,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (native token only)\n        @param  proposal  address  Proposal\n     */\n    function depositBribe(address proposal) external payable {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(msg.value > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            bribeVault\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            bribeVault\n        );\n\n        IBribeVault(bribeVault).depositBribe{value: msg.value}(\n            // NOTE: Native token bribes have bribeVault set as the address\n            bribeIdentifier,\n            rewardIdentifier,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            bribeVault,\n            msg.value,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Voters can opt in or out of reward-forwarding\n        @notice Opt-in: A voter sets another address to forward rewards to\n        @notice Opt-out: A voter sets their own address or the zero address\n        @param  to  address  Account that rewards will be sent to\n     */\n    function setRewardForwarding(address to) public {\n        rewardForwarding[msg.sender] = to;\n\n        emit SetRewardForwarding(msg.sender, to);\n    }\n}\n\n\n",
        "CodeNames": [
            "BribeVault.sol",
            "TokemakBribe.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-01",
                "Location": [
                    "bribeAmount",
                    "round",
                    "getBribe()"
                ],
                "Type": " TokemakBribe:  getBribe()  has incorrect description",
                "Description": "\n\nTokemakBribe.sol#L188-L194(https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L188-L194)\n\n\n*   Missing round param\n*   bribeAmount has incorrect description\n\n",
                "Repair": "\njsx\n/\n\t  @notice Get bribe from BribeVault\n\t  @param  proposal            address  Proposal\n          @param  round               uint256  Round\n\t  @param  token               address  Token\n\t  @return bribeToken          address  Bribe token address\n\t  @return bribeAmount         uint256  Bribe token amount\n*/\n\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-04",
                "Location": [
                    "//solidity\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap  ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap  ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity  0 && btrflyLiquidity  0, \"Insufficient amounts\");\n        // ...\n    }\n"
                ],
                "Type": " Validation can be done earlier to save gas",
                "Description": "\n_Note: suggested optimation, save a decent amount of gas without compromising readability._\n\nCheck if ethLiquidity  0 && btrflyLiquidity  0 earlier can avoid unnecessary external call (IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);) when this check failed.\n\nThecosomataETH.sol#L124-L155(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L124-L155)<br\n\nsolidity\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap  ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap  ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity  0 && btrflyLiquidity  0, \"Insufficient amounts\");\n        // ...\n    }\n\n\n",
                "Repair": "\nChange to:\n\nsolidity\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap  ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap  ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity  0 && btrflyLiquidity  0, \"Insufficient amounts\");\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // ...\n    }\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0; \n\n// https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/release-v4.5/contracts/token/ERC20/ERC20.sol\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n",
        "CodeNames": [
            "ERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-05",
                "Location": [
                    "type(uint"
                ],
                "Type": "  type(uint256).max  is more gas efficient than  2256 - 1 ",
                "Description": "\n_Note: minor optimation, the amount of gas saved is minor, change when you see fit._\n\nThecosomataETH.sol#L68-L69(https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69)\n\n\n",
                "Repair": ""
            }
        ]
    }
]