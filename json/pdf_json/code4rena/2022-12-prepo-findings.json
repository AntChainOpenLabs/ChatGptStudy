[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nFile: apps/smart-contracts/core/contracts/interfaces/IWithdrawHook.sol\n63:   /\n64:    * @notice Sets the length in seconds for which user withdraw limits will\n65:    * be evaluated against. Every time `userPeriodLength` seconds passes, the\n66:    * amount withdrawn for all users will be reset to 0. This amount is only\n",
                    "node\n  describe('user withdraw is delayd', () = {\n    beforeEach(async () = {\n      await withdrawHook.setCollateral(collateral.address)\n      await withdrawHook.connect(deployer).setWithdrawalsAllowed(true)\n      await withdrawHook.connect(deployer).setGlobalPeriodLength(0)\n      await withdrawHook.connect(deployer).setUserPeriodLength(TEST_USER_PERIOD_LENGTH)\n      await withdrawHook.connect(deployer).setGlobalWithdrawLimitPerPeriod(0)\n      await withdrawHook.connect(deployer).setUserWithdrawLimitPerPeriod(TEST_USER_WITHDRAW_LIMIT)\n      await withdrawHook.connect(deployer).setDepositRecord(depositRecord.address)\n      await withdrawHook.connect(deployer).setTreasury(treasury.address)\n      await withdrawHook.connect(deployer).setTokenSender(tokenSender.address)\n      await testToken.connect(deployer).mint(collateral.address, TEST_GLOBAL_DEPOSIT_CAP)\n      await testToken.connect(deployer).mint(user.address, TEST_GLOBAL_DEPOSIT_CAP)\n      await testToken.connect(deployer).mint(user2.address, TEST_GLOBAL_DEPOSIT_CAP)\n      await testToken\n        .connect(collateralSigner)\n        .approve(withdrawHook.address, ethers.constants.MaxUint256)\n      tokenSender.send.returns()\n    })\n\n    it('reverts if user withdraw limit exceeded for period', async () = {\n      \n      // first withdraw with the limit amount for a user\n      await withdrawHook.connect(collateralSigner).hook(user.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      expect(await withdrawHook.getAmountWithdrawnThisPeriod(user.address)).to.eq(TEST_USER_WITHDRAW_LIMIT)\n      \n      // we move to a new epoch in the future\n      const previousResetTimestamp = await getLastTimestamp(ethers.provider)\n      await setNextTimestamp(\n        ethers.provider,\n        previousResetTimestamp + TEST_USER_PERIOD_LENGTH + 1\n      )\n      \n      // now another user is the first one to withdraw in this new epoch      \n      await withdrawHook.connect(collateralSigner).hook(user2.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      expect(await withdrawHook.getAmountWithdrawnThisPeriod(user2.address)).to.eq(TEST_USER_WITHDRAW_LIMIT)\n      \n      // this will revert, because userToAmountWithdrawnThisPeriod[_sender] is not reset\n      // but it should not revert as it's a new epoch and the user didn't withdraw yet\n      await expect(\n        withdrawHook.connect(collateralSigner).hook(user.address, 1, 1)\n      ).to.revertedWith('user withdraw limit exceeded')\n      \n    })\n  })\n"
                ],
                "Type": " griefing / blocking / delaying users to withdraw",
                "Description": "*Submitted by zaskoh(https://github.com/code-423n4/2022-12-prepo-findings/issues/116), also found by unforgiven(https://github.com/code-423n4/2022-12-prepo-findings/issues/325), deliriusz(https://github.com/code-423n4/2022-12-prepo-findings/issues/223), rvierdiiev(https://github.com/code-423n4/2022-12-prepo-findings/issues/175), and Tricko(https://github.com/code-423n4/2022-12-prepo-findings/issues/149)*\n\nTo withdraw, a user needs to convert his collateral for the base token. This is done in the withdraw function in Collateral.\n\nThe WithdrawHook has some security mechanics that can be activated like a global max withdraw in a specific timeframe, also for users to have a withdraw limit for them in a specific timeframe. It also collects the fees.\n\nThe check for the user withdraw is wrongly implemented and can lead to an unepexted delay for a user with a position  userWithdrawLimitPerPeriod. To withdraw all his funds he needs to be the first in every first new epoch (lastUserPeriodReset + userPeriodLength) to get his amount out. If he is not the first transaction in the new epoch, he needs to wait for a complete new epoch and depending on the timeframe from lastUserPeriodReset + userPeriodLength this can get a long delay to get his funds out.\n\nThe documentation says, that after every epoch all the user withdraws will be reset and they can withdraw the next set.\n\nsolidity\nFile: apps/smart-contracts/core/contracts/interfaces/IWithdrawHook.sol\n63:   /\n64:    * @notice Sets the length in seconds for which user withdraw limits will\n65:    * be evaluated against. Every time userPeriodLength seconds passes, the\n66:    * amount withdrawn for all users will be reset to 0. This amount is only\n\n\nBut the implementation only resets the amount for the first user that interacts with the contract in the new epoch and leaves all other users with their old limit. This can lead to a delay for every user that is on his limit from a previous epoch until they manage to be the first to interact with the contract in the new epoch.\n\n\n<https://github.com/prepo-io/prepo-monorepo/blob/feat/2022-12-prepo/apps/smart-contracts/core/contracts/WithdrawHook.sol#L66-L72\n\nThe following test shows how a user is locked out to withdraw if he's at his limit from a previous epoch and another withdraw is done before him.\n\napps/smart-contracts/core/test/WithdrawHook.test.ts\n\nnode\n  describe('user withdraw is delayd', () = {\n    beforeEach(async () = {\n      await withdrawHook.setCollateral(collateral.address)\n      await withdrawHook.connect(deployer).setWithdrawalsAllowed(true)\n      await withdrawHook.connect(deployer).setGlobalPeriodLength(0)\n      await withdrawHook.connect(deployer).setUserPeriodLength(TEST_USER_PERIOD_LENGTH)\n      await withdrawHook.connect(deployer).setGlobalWithdrawLimitPerPeriod(0)\n      await withdrawHook.connect(deployer).setUserWithdrawLimitPerPeriod(TEST_USER_WITHDRAW_LIMIT)\n      await withdrawHook.connect(deployer).setDepositRecord(depositRecord.address)\n      await withdrawHook.connect(deployer).setTreasury(treasury.address)\n      await withdrawHook.connect(deployer).setTokenSender(tokenSender.address)\n      await testToken.connect(deployer).mint(collateral.address, TEST_GLOBAL_DEPOSIT_CAP)\n      await testToken.connect(deployer).mint(user.address, TEST_GLOBAL_DEPOSIT_CAP)\n      await testToken.connect(deployer).mint(user2.address, TEST_GLOBAL_DEPOSIT_CAP)\n      await testToken\n        .connect(collateralSigner)\n        .approve(withdrawHook.address, ethers.constants.MaxUint256)\n      tokenSender.send.returns()\n    })\n\n    it('reverts if user withdraw limit exceeded for period', async () = {\n      \n      // first withdraw with the limit amount for a user\n      await withdrawHook.connect(collateralSigner).hook(user.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      expect(await withdrawHook.getAmountWithdrawnThisPeriod(user.address)).to.eq(TEST_USER_WITHDRAW_LIMIT)\n      \n      // we move to a new epoch in the future\n      const previousResetTimestamp = await getLastTimestamp(ethers.provider)\n      await setNextTimestamp(\n        ethers.provider,\n        previousResetTimestamp + TEST_USER_PERIOD_LENGTH + 1\n      )\n      \n      // now another user is the first one to withdraw in this new epoch      \n      await withdrawHook.connect(collateralSigner).hook(user2.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      expect(await withdrawHook.getAmountWithdrawnThisPeriod(user2.address)).to.eq(TEST_USER_WITHDRAW_LIMIT)\n      \n      // this will revert, because userToAmountWithdrawnThisPeriod[_sender] is not reset\n      // but it should not revert as it's a new epoch and the user didn't withdraw yet\n      await expect(\n        withdrawHook.connect(collateralSigner).hook(user.address, 1, 1)\n      ).to.revertedWith('user withdraw limit exceeded')\n      \n    })\n  })\n\n\nTo get the test running you need to add let user2: SignerWithAddress and the user2 in await ethers.getSigners()\n\n",
                "Repair": "\nThe check how the user periods are handled need to be changed. One possible way is to change the lastUserPeriodReset to a mapping like\nmapping(address = uint256) private lastUserPeriodReset to track the time for every user separately.\n\nWith a mapping you can change the condition to:\n\nsolidity\nFile: apps/smart-contracts/core/contracts/WithdrawHook.sol\n18:   mapping(address = uint256) lastUserPeriodReset;\n\nFile: apps/smart-contracts/core/contracts/WithdrawHook.sol\n66:     if (lastUserPeriodReset[_sender] + userPeriodLength < block.timestamp) {\n67:       lastUserPeriodReset[_sender] = block.timestamp;\n68:       userToAmountWithdrawnThisPeriod[_sender] = _amountBeforeFee;\n69:     } else {\n70:       require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, \"user withdraw limit exceeded\");\n71:       userToAmountWithdrawnThisPeriod[_sender] += _amountBeforeFee;\n72:     }\n\n\nWith this change, we can change the test to how we would normaly expect the contract to work and see that it is correct.\n\nnode\n    it('withdraw limit is checked for every use seperatly', async () = {\n      \n      // first withdraw with the limit amount for a user\n      await withdrawHook.connect(collateralSigner).hook(user.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      \n      // we move to a new epoch in the future\n      const previousResetTimestamp = await getLastTimestamp(ethers.provider)\n      await setNextTimestamp(\n        ethers.provider,\n        previousResetTimestamp + TEST_USER_PERIOD_LENGTH + 1\n      )\n      \n      // now another user is the first one to withdraw in this new epoch      \n      await withdrawHook.connect(collateralSigner).hook(user2.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      \n      // the first user also can withdraw his limit in this epoch\n      await withdrawHook.connect(collateralSigner).hook(user.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      \n      // we move the time, but stay in the same epoch\n      const previousResetTimestamp2 = await getLastTimestamp(ethers.provider)\n      await setNextTimestamp(\n        ethers.provider,\n        previousResetTimestamp2 + TEST_USER_PERIOD_LENGTH 1\n      )\n\n      // this now will fail as we're in the same epoch\n      await expect(\n        withdrawHook.connect(collateralSigner).hook(user.address, 1, 1)\n      ).to.revertedWith('user withdraw limit exceeded')\n      \n    })\n\n\nramenforbreakfast (prePO) confirmed(https://github.com/code-423n4/2022-12-prepo-findings/issues/325) \n\n*\n\n\n"
            }
        ]
    }
]