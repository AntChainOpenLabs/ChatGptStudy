[
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\ncontract DelegatedStaking is OwnableUpgradeable{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    uint256 constant divider = 10**18; // 18 decimals used for scaling the rates\n    uint128 validatorCoolDown; // how many epochs until validator unstaking is unlocked\n    uint128 delegatorCoolDown; // how many epochs until delegator unstaking is unlocked\n    uint128 maxCapMultiplier;\n    uint128 validatorMinStakedRequired; // minimum # of tokens validator is required to have staked\n    uint128 allocatedTokensPerEpoch; // # of tokens per epoch to be distributed\n    uint128 rewardsLocked; // # of tokens the owner sent to the contract\n    uint128 endEpoch; // the epoch when the contract will be out of allocated reward tokens\n    uint128 totalGlobalShares; // global shares\n    uint128 lastUpdateEpoch; // block # when the global exchange rate was updated last\n    uint128 globalExchangeRate;\n    uint128 validatorsN; // number of validators, used to get validator ids\n    mapping(uint128 => Validator) validators; // id -> validator instance\n    IERC20Upgradeable constant CQT = IERC20Upgradeable(0xD417144312DbF50465b1C641d016962017Ef6240);\n\n    struct Staking {\n        uint128 staked; // initial CQT amount staked\n        uint128 shares; // # of validator shares that delegate owns\n    }\n    struct Unstaking {\n        uint128 coolDownEnd; // epoch when unstaking can be redeemed\n        uint128 amount;\n    }\n    struct Validator {\n        address _address;\n        address operator;\n        uint128 commissionRate; // validator commission rate\n        uint128 disabledEpoch; // epoch when validator got disabled, if set to 0, validator is enabled\n        uint128 globalShares; // total number of global shares under a validator\n        uint128 lastUpdateGlobalRate; // global exchange rate when the validator was updated the last time\n        uint128 totalShares; // total number of validator shares\n        uint128 delegated; // total number of tokens originally staked/delegated to the validator, this does not include interest\n        uint128 exchangeRate; // validator exchange rate\n        uint128 commissionAvailableToRedeem; // # of CQTs paid to the validator\n        mapping(address => Staking) stakings;\n        mapping(address => Unstaking[]) unstakings;\n    }\n    event RewardTokensDeposited(uint128 amount);\n    event ValidatorAdded(uint128 indexed id, address indexed validator, address indexed operator);\n    event ValidatorDisabled(uint128 indexed id);\n    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);\n    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount);\n    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 amount);\n    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n    event AllocatedTokensTaken(uint128 amount);\n    event MaxCapMultiplierChanged(uint128 amount);\n    event TransferredUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n    event EmissionRateChanged(uint128 newRate);\n    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 newRate);\n    event ValidatorMinStakedRequiredChanged(uint128 amount);\n    event Initialized(uint128 minStakedRequired, uint128 validatorCoolDown, uint128 delegatorCoolDown, uint128 maxCapMultiplier, uint128 allocatedTokensPerEpoch, uint128 globalExchangeRate);\n\n    // this is used to have the contract upgradeable\n    function initialize(uint128 minStakedRequired) public initializer {\n        __Ownable_init();\n        validatorMinStakedRequired = minStakedRequired;\n        validatorCoolDown = 180*6646; // ~ 6 months\n        delegatorCoolDown = 28*6646; // ~ 28 days\n        maxCapMultiplier = 10;\n        allocatedTokensPerEpoch = 1*10**18; // should never be 0\n        globalExchangeRate = 10**18; // 1 to 1\n        emit Initialized(minStakedRequired, validatorCoolDown, delegatorCoolDown, maxCapMultiplier, allocatedTokensPerEpoch, globalExchangeRate);\n    }\n\n    // used to transfer CQT from delegators, validators and the owner to the contract\n    function _transferToContract(address from, uint128 amount) internal {\n        CQT.safeTransferFrom(from, address(this), amount);\n    }\n\n    // used to transfer CQT from contract, for rewards redemption or transferring out unstaked\n    function _transferFromContract(address to, uint128 amount) internal {\n        CQT.safeTransfer(to, amount);\n    }\n\n    // transfer CQT from the owner to the contract for rewards allocation, must change end epoch\n    function depositRewardTokens(uint128 amount) public onlyOwner {\n        require(amount >= allocatedTokensPerEpoch, \"Does not cover least 1 epoch\");\n        require(amount % allocatedTokensPerEpoch == 0, \"Not multiple\");\n        if (endEpoch != 0) {\n            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }\n        }\n        else{\n            unchecked { rewardsLocked += amount; }\n        }\n        _transferToContract(msg.sender, amount);\n        emit RewardTokensDeposited(amount);\n    }\n\n    // transfer reward CQT from the contract to the owner, must change end epoch and not allow transfer from the past\n    function takeOutRewardTokens(uint128 amount) public onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        require(amount % allocatedTokensPerEpoch == 0, \"Not multiple\");\n        if (endEpoch != 0){\n            uint128 currentEpoch = uint128(block.number);\n            uint128 epochs = amount / allocatedTokensPerEpoch;\n            require(endEpoch - epochs > currentEpoch, \"Cannot takeout rewards from past\");\n            unchecked { endEpoch = endEpoch - epochs; }\n        }\n        else{\n            require(rewardsLocked >= amount, \"Amount is greater than available\");\n            unchecked { rewardsLocked -= amount; }\n        }\n        _transferFromContract(msg.sender, amount);\n        emit AllocatedTokensTaken(amount);\n    }\n\n    // update global exchange rate\n    function _updateGlobalExchangeRate() internal {\n        uint128 currentBlock = uint128(block.number);\n        // if the program ended, set update epoch to the end epoch\n        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;\n        if (currentEpoch != lastUpdateEpoch){\n            // when no one has staked anything, do not update the rate\n            if(totalGlobalShares > 0)\n            {\n                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }\n            }\n            lastUpdateEpoch = currentEpoch;\n        }\n    }\n\n    // update validator exchange rate\n    function _updateValidator(Validator storage v) internal {\n        // if validator is disabled, we do not update it since it was updated during disabling transaction\n        if(v.disabledEpoch == 0){\n            if (v.totalShares == 0){\n                // when validator stakes the first time, the exchange rate must be equal to the current global exchange rate\n                v.exchangeRate = globalExchangeRate;\n            }\n            else {\n                // the growth of global exchange rate since the validator was updated the last time\n                uint128 rateDifference;\n                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }\n                // tokens given to the validator and its delegators since last update\n                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);\n                // commission paid out of the tokens\n                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);\n                // increase validator exchange rate by distributing the leftover tokens through the validator shares\n                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);\n                // give commission tokens to the validator\n                unchecked { v.commissionAvailableToRedeem += commissionPaid; }\n            }\n            // set the last update global rate to the current one\n            v.lastUpdateGlobalRate = globalExchangeRate;\n        }\n    }\n    // used to convert global shares or validator shares to CQT\n    function _sharesToTokens(uint128 sharesN, uint128 rate) internal view returns(uint128){\n        return uint128(uint256(sharesN) * uint256(rate) / divider);\n    }\n    // used to convert CQT to global shares or validator shares\n    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){\n        return uint128(uint256(amount) * divider / uint256(rate));\n    }\n\n    function stake(uint128 validatorId, uint128 amount) public {\n        _stake(validatorId, amount, true);\n    }\n    // need to update global exchange rate, validator data and then delegator instance\n    // withTransfer set to false when delegators recover unstake, because the tokens are already in the contract\n    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {\n        require(amount >= divider, \"Amount must be at least 1 token\");\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = validators[validatorId];\n        require(v.disabledEpoch == 0, \"Validator is disabled\");\n        // if this is the first stake, then set the end epoch\n        if (endEpoch == 0){\n            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }\n            rewardsLocked = 0; // no longer used and saves a bit of gas\n        }\n        require(endEpoch > block.number, \"Program ended\");\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        // if staker is validator who self delegates\n        if (msg.sender == v._address){\n            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, \"Amount < min staked required\");\n        }\n        else {\n            // otherwise need to check for max cap\n            uint128 validatorStaked = v.stakings[v._address].staked;\n            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;\n            uint128 newDelegated = v.delegated - validatorStaked + amount;\n            require(newDelegated <= validatorMaxCap, \"Validator max capacity exceeded\");\n        }\n        // it is set to true when there is a stake\n        // it is set to false when we recover delegation from unstaking\n        if (withTransfer)\n            _transferToContract(msg.sender, amount);\n        Staking storage s = v.stakings[msg.sender];\n\n        // update global shares #\n        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);\n        unchecked { totalGlobalShares += globalSharesToAdd; }\n        unchecked { v.globalShares += globalSharesToAdd; }\n\n        // update validator shares #\n        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);\n        unchecked { v.totalShares += newDelegatorSharesN; }\n        unchecked { s.shares += newDelegatorSharesN; }\n        unchecked { v.delegated += amount; }\n        unchecked { s.staked += amount; }\n        emit Staked(validatorId, msg.sender, amount);\n    }\n\n    // need to update global exchange rate, validator data and then delegator instance\n    function unstake(uint128 validatorId, uint128 amount) public {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n        require(s.staked >= amount, \"Staked < amount provided\");\n        bool isValidator = msg.sender == v._address;\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        // only update if the validator is enabled, otherwise the global shares were already excluded during disableValidator call and the rest does not matter anymore\n        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);\n        require(validatorSharesRemove > 0, \"Unstake amount is too small\");\n        if (v.disabledEpoch == 0){\n            // if validator is enabled and the program has not ended -> check for unstaking beyond max cap or min stake required\n            if (isValidator && endEpoch > block.number){\n                uint128 newValidatorStaked = s.staked - amount;\n                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;\n                uint128 delegated = v.delegated - s.staked;\n                require(delegated <= newValidatorMaxCap, \"Cannot unstake beyond max cap\");\n                require(newValidatorStaked >= validatorMinStakedRequired, \"Unstake > min staked required\");\n            }\n\n            // update global shares #\n            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);\n            require(globalSharesRemove > 0, \"Unstake amount is too small\");\n            unchecked { totalGlobalShares -= globalSharesRemove;}\n            unchecked { v.globalShares -= globalSharesRemove; }\n\n            // update validator shares #\n            unchecked { v.totalShares -= validatorSharesRemove; }\n            unchecked { v.delegated -= amount; }\n        }\n        unchecked { s.shares -= validatorSharesRemove; }\n        unchecked { s.staked -= amount; }\n\n        // create unstaking instance\n        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);\n        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }\n        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));\n        emit Unstaked(validatorId, msg.sender, amount);\n    }\n\n    // restake unstaked tokens\n    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) public{\n        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        _stake(validatorId, amount, false);\n        us.amount -= amount;\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if(us.amount == 0)\n            us.coolDownEnd = 0;\n        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);\n    }\n\n    // if amount is 0 then redeem all\n    function _redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) internal {\n        require(beneficiary!=address(0x0), \"Invalid beneficiary\");\n        _updateGlobalExchangeRate();\n        Validator storage v = validators[validatorId];\n        _updateValidator(v);\n        Staking storage s = v.stakings[msg.sender];\n\n        uint128 rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;\n        if(msg.sender == v._address){\n            if(amount == 0){\n                unchecked { amount = rewards + v.commissionAvailableToRedeem; }\n            }\n            require(rewards + v.commissionAvailableToRedeem >= amount, \"Redeem amount > available\");\n            // first redeem rewards from commission\n            uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;\n            // if there is more, redeem  it from regular rewards\n            if (commissionLeftOver == 0){\n                uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);\n                unchecked { s.shares -= validatorSharesRemove; }\n                unchecked { v.totalShares -= validatorSharesRemove; }\n            }\n            emit CommissionRewardRedeemed(validatorId, beneficiary, v.commissionAvailableToRedeem - commissionLeftOver);\n            v.commissionAvailableToRedeem = commissionLeftOver;\n        }\n        else {\n            if(amount == 0){\n                amount = rewards;\n            }\n            require(rewards >= amount, \"Redeem amount > available\");\n            uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);\n            unchecked { s.shares -= validatorSharesRemove; }\n            unchecked { v.totalShares -= validatorSharesRemove; }\n        }\n        _transferFromContract(beneficiary, amount);\n\n        // update global shares #\n        // this includes commission and rewards earned\n        // only update if the validator is enabled, otherwise the shares were already excluded during disableValidator call\n        if (v.disabledEpoch == 0){\n            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);\n            unchecked { totalGlobalShares -= globalSharesRemove; }\n            unchecked { v.globalShares -= globalSharesRemove; }\n        }\n        emit RewardRedeemed(validatorId, beneficiary, amount);\n    }\n\n    // redeem all available rewards\n    function redeemAllRewards( uint128 validatorId, address beneficiary) external {\n        _redeemRewards(validatorId, beneficiary, 0);\n    }\n\n    // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards\n    function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) external {\n        require(amount > 0, \"Amount is 0\");\n        _redeemRewards(validatorId, beneficiary, amount);\n    }\n\n    // add new validator instance\n    function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {\n        require(commissionRate < divider, \"Rate must be less than 100%\");\n        uint128 N = validatorsN;\n        validators[N]._address = validator;\n        validators[N].operator = operator;\n        validators[N].commissionRate = commissionRate;\n        emit ValidatorAdded(N, validator, operator);\n        unchecked { validatorsN += 1; }\n    }\n\n    // can only be called by the owner or the validator, disabling will allow validator to fully unstake\n    // validator instance can only be disabled once and can never be reenabled\n    function disableValidator(uint128 validatorId) public {\n        Validator storage v = validators[validatorId];\n        require(v.disabledEpoch == 0, \"Validator is already disabled\");\n        require(v._address == msg.sender || msg.sender == owner(), \"Caller is not owner or validator\");\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        v.disabledEpoch = uint128(block.number) < endEpoch? uint128(block.number) : endEpoch;\n        unchecked { totalGlobalShares -= v.globalShares; }\n        emit ValidatorDisabled(validatorId);\n    }\n\n    // change emission rate, should reset end epoch\n    function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        uint128 toTransfer;\n        if (endEpoch != 0){\n            _updateGlobalExchangeRate();\n            // get number of epochs from now to the end epoch\n            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;\n            // calculate how much rewards would be distributed with the old emission rate\n            uint128 futureRewards = allocatedTokensPerEpoch * epochs;\n            // calculate how many epochs will be covered\n            uint128 addEpochs = futureRewards / amount;\n            toTransfer = futureRewards % amount;\n            require(addEpochs != 0, \"This amount will end the program\");\n            unchecked { endEpoch = uint128(block.number) + addEpochs; }\n        }\n        else {\n          toTransfer = rewardsLocked % amount;\n        }\n        allocatedTokensPerEpoch = amount;\n        emit EmissionRateChanged(amount);\n        if(toTransfer > 0)\n            _transferFromContract(msg.sender, toTransfer);\n\n    }\n\n    // we assume that we will never set it to less than what is staked already\n    function setMaxCapMultiplier(uint128 amount) public onlyOwner {\n        require(amount > 0, \"Must be greater than 0\");\n        maxCapMultiplier = amount;\n        emit MaxCapMultiplierChanged(amount);\n    }\n\n    // only owner can change commission rate\n    function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner {\n        require(amount < divider, \"Rate must be less than 100%\");\n        _updateGlobalExchangeRate();\n        _updateValidator(validators[validatorId]);\n        validators[validatorId].commissionRate = amount;\n        emit ValidatorCommissionRateChanged(validatorId, amount);\n    }\n\n    // we are assuming there will never be a case when the owner sets the value to something extremely big and if that happens accidentally, we will just recall the function\n    function setValidatorMinStakedRequired(uint128 amount) public onlyOwner {\n        validatorMinStakedRequired = amount;\n        emit ValidatorMinStakedRequiredChanged(amount);\n    }\n\n    // if a validator gets disabled, delegators can redelegate their tokens to another validator\n    // first they need to unstake\n    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) public {\n        require(validators[oldValidatorId].disabledEpoch != 0, \"Validator is not disabled\");\n        require(validators[oldValidatorId]._address != msg.sender, \"Validator cannot redelegate\");\n        Unstaking storage us = validators[oldValidatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        _stake(newValidatorId, amount, false);\n        unchecked { us.amount -= amount; }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if(us.amount == 0)\n            us.coolDownEnd = 0;\n        emit TransferredUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);\n    }\n\n    // transfer out unlocked unstaked tokens back to the delegator\n    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) public {\n        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];\n        require( uint128(block.number) > us.coolDownEnd, \"Cooldown period has not ended\" );\n        require(us.amount >= amount, \"Amount is too high\");\n        _transferFromContract(msg.sender, amount);\n        unchecked { us.amount -= amount; }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0)\n            us.coolDownEnd = 0;\n        emit UnstakeRedeemed(validatorId, msg.sender, amount);\n    }\n\n    // returns details of each validator\n    // array index is id\n    function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {\n        commissionRates = new uint128[](validatorsN);\n        delegated = new uint128[](validatorsN);\n        for (uint128 i = 0; i < validatorsN; ++i){\n            Validator storage v = validators[i];\n            commissionRates[i] = v.commissionRate;\n            delegated[i] = v.delegated - v.stakings[v._address].staked;\n        }\n        return (commissionRates, delegated);\n    }\n\n    // this follows the same logic as _updateGlobalExchangeRate and _updateValidator\n    // array index is id of validator\n    function getDelegatorDetails(address delegator) public view returns( uint128[] memory delegated,  uint128[] memory rewardsAvailable, uint128[] memory commissionRewards) {\n       delegated = new uint128[](validatorsN);\n       rewardsAvailable = new uint128[](validatorsN);\n       commissionRewards = new uint128[](validatorsN);\n       uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;\n       uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;\n       Validator storage v;\n       Staking storage s;\n        for (uint128 i = 0; i < validatorsN; ++i){\n            v = validators[i];\n            s = v.stakings[delegator];\n            delegated[i] = s.staked;\n            if (v.disabledEpoch == 0){\n                uint128 newTokensGiven = _sharesToTokens(v.globalShares, newGlobalExchangeRate - v.lastUpdateGlobalRate);\n                uint128 commissionPaid = uint128(uint256(newTokensGiven) * uint256(v.commissionRate) /  divider);\n                uint128 rateIncrease = uint128(uint256(newTokensGiven - commissionPaid) * divider / v.totalShares);\n                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate + rateIncrease) - s.staked;\n                if(delegator == v._address)\n                    commissionRewards[i] = v.commissionAvailableToRedeem + commissionPaid;\n            }\n            else {\n                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;\n                if(delegator == v._address)\n                    commissionRewards[i] = v.commissionAvailableToRedeem;\n            }\n        }\n        return (delegated, rewardsAvailable, commissionRewards);\n    }\n\n    function getMetadata() public view returns(uint128,  uint128, uint128, uint128, uint128 ){\n        uint128 totalStaked = uint128(uint256(totalGlobalShares) * uint256(globalExchangeRate) / divider);\n        return (allocatedTokensPerEpoch, endEpoch, maxCapMultiplier, totalStaked, validatorsN);\n    }\n}\n\n",
        "CodeNames": [
            "DelegatedStaking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n// this is used to have the contract upgradeable\nfunction initialize(uint128 minStakedRequired) public initializer {\n"
                ],
                "Type": " Usage of an incorrect version of  Ownbale  library can potentially malfunction all  onlyOwner  functions",
                "Description": "\nDelegatedStaking.sol L62-L63(https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L62-L63)\n\nsolidity\n// this is used to have the contract upgradeable\nfunction initialize(uint128 minStakedRequired) public initializer {\n\n\nBased on the context and comments in the code, the DelegatedStaking.sol contract is designed to be deployed as an upgradeable proxy contract.\n\nHowever, the current implementation is using an non-upgradeable version of the Ownbale library: @openzeppelin/contracts/access/Ownable.sol instead of the upgradeable version: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol.\n\nA regular, non-upgradeable Ownbale library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract.\n\nAs a result, all the onlyOwner functions will be inaccessible.\n\n",
                "Repair": "Use @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol and @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol instead.\n\nAnd change the initialize() function to:\n\nsolidity\nfunction initialize(uint128 minStakedRequired) public initializer {\n    __Ownable_init();\n    ...\n}\n\n\nkitti-katy (Covalent) confirmed(https://github.com/code-423n4/2021-10-covalent-findings/issues/45)\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-covalent-findings/issues/45#issuecomment-955111019):\n  Agree with the finding, when using Upgradeable Proxies it's important to use the adequate libraries that will be compatible with initializable contracts\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-covalent-findings/issues/45#issuecomment-955111738):\n  The sponsor has mitigated the issue\n\nkitti-katy (Covalent) patched(https://github.com/code-423n4/2021-10-covalent/pull/23)\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n// @audit shares are computed here with old rate\nuint128 validatorSharesRemove = tokensToShares(amount, v.exchangeRate);\nrequire(validatorSharesRemove  0, \"Unstake amount is too small\");\n\nif (v.disabledEpoch == 0) {\n    // @audit rates are updated here\n    updateGlobalExchangeRate();\n    updateValidator(v);\n    // ...\n}\n"
                ],
                "Type": "  unstake  should update exchange rates first",
                "Description": "\nThe unstake function does not immediately update the exchange rates. It first computes the validatorSharesRemove = tokensToShares(amount, v.exchangeRate) with the old exchange rate.\n\nOnly afterwards, it updates the exchange rates (if the validator is not disabled):\n\nsolidity\n// @audit shares are computed here with old rate\nuint128 validatorSharesRemove = tokensToShares(amount, v.exchangeRate);\nrequire(validatorSharesRemove  0, \"Unstake amount is too small\");\n\nif (v.disabledEpoch == 0) {\n    // @audit rates are updated here\n    updateGlobalExchangeRate();\n    updateValidator(v);\n    // ...\n}\n\n\nMore shares for the amount are burned than required and users will lose rewards in the end.\n\nDemonstrating that users will lose rewards:\n\n1.  Assume someone staked 1000 amount and received 1000 shares, and v.exchangeRate = 1.0. (This user is the single staker)\n2.  Several epochs pass, interest accrues, and 1000 tokens accrue for the validator, tokensGivenToValidator = 1000. User should be entitled to 1000 in principal + 1000 in rewards = 2000 tokens.\n3.  But user calls unstake(1000), which sets validatorSharesRemove = tokensToShares(amount, v.exchangeRate) = 1000 / 1.0 = 1000. Afterwards, the exchange rate is updated: v.exchangeRate += tokensGivenToValidator / totalShares = 1.0 + 1.0 = 2.0. The staker is updated with s.shares -= validatorSharesRemove = 0 and s.staked -= amount = 0. And the user receives their 1000 tokens but notice how the user's shares are now at zero as well.\n4.  User tries to claim rewards calling redeemAllRewards which fails as the rewards are 0.\n\nIf the user had first called redeemAllRewards and unstake afterwards they'd have received their 2000 tokens.\n\n",
                "Repair": "The exchange rates always need to be updated first before doing anything.\nMove the updateGlobalExchangeRate() and updateValidator(v) calls to the beginning of the function.\n\n\nkitti-katy (Covalent) confirmed(https://github.com/code-423n4/2021-10-covalent-findings/issues/57)\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-covalent-findings/issues/57#issuecomment-955111691):\n  Agree with the finding, using the old exchange rate ends up burning more shares than what would be correct\n The sponsor has mitigated the issue\n\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "depositRewardTokens",
                    "endEpoch",
                    "setAllocatedTokensPerEpoch()",
                    "takeOutRewardTokens()",
                    "allocatedTokensPerEpoch"
                ],
                "Type": " reward tokens could get lost due to rounding down",
                "Description": "\nThe function depositRewardTokens divides the \"amount\" of tokens by allocatedTokensPerEpoch to calculate the endEpoch.\nWhen \"amount\" isn't a multiple of allocatedTokensPerEpoch the result of the division will be rounded down,\neffectively losing a number of tokens for the rewards.\n\nFor example if allocatedTokensPerEpoch is set to 3e18 and \"amount\" is 100e18 then endEpoch will be increased with 33e18 and the last 1e18 tokens are lost.\n\nA similar problem occurs here:\n in setAllocatedTokensPerEpoch(), with the recalculation of endEpoch\n in takeOutRewardTokens(), with the retrieval of tokens\n in _stake(), when initializing endEpoch (e.g. when endEpoch==0)\n\nDelegatedStaking.sol L90-L98(https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L90-L98)\nDelegatedStaking.sol L368-L383(https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L368-L383)\n\n",
                "Repair": "In depositRewardTokens() add, in the beginning of function, before the if statement:\nsolidity\nrequire(amount % allocatedTokensPerEpoch == 0,\"Not multiple\");\n\n\nIn takeOutRewardTokens() add:\nsolidity\nrequire(amount % allocatedTokensPerEpoch == 0,\"Not multiple\");\n\n\nUpdate setAllocatedTokensPerEpoch() to something like:\n\nsolidity\nif (endEpoch != 0) {\n...\nuint128 futureRewards = ...\nrequire(futureRewards % amount ==0,\"Not multiple\");\n...\n} else { // to prevent issues with _stake()\nrequire(rewardsLocked % allocatedTokensPerEpoch==0,\"Not multiple\");\n}\n\n\nkitti-katy (Covalent) confirmed(https://github.com/code-423n4/2021-10-covalent-findings/issues/10#issuecomment-948903386):\n  Agreed, the original assumption was that the owner would always make sure the take out and deposit amount is multiple of emission rate. But yes, this is good to add the check. Also it is not that risky since the emission rate wouldn't be that high per epoch and the loss will always be less than the emission rate.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-covalent-findings/issues/10#issuecomment-957018348):\n  Agree with the finding, since it's a rounding error the max loss in rewards can at most be 1 less than the denominator\n\n That said, this is a Medium Severity Finding as per the doc:\n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n Where in this case the rounding is a way to leak value (loss of yield)\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "totalGlobalShares",
                    "updateGlobalExchangeRate"
                ],
                "Type": " Incorrect  updateGlobalExchangeRate  implementation",
                "Description": "\nUpdateGlobalExchangeRate has incorrect implementation when totalGlobalShares is zero.\n\nIf any user didn't start stake, totalGlobalShares is 0, and every stake it will increase.\nbut there is possibility that totalGlobalShares can be 0 amount later by unstake or disable validator.\n\nThis is my test case to proof this issue: C4_issues.js L76(https://github.com/xYrYuYx/C4-2021-10-covalent/blob/main/test/c4-tests/C4_issues.js#L76)\n\nIn my test case, I disabled validator to make totalGlobalShares to zero.\nAnd in this case, some reward amount will be forever locked in the contract.\nAfter disable validator, I mined 10 blocks, and 4 more blocks mined due to other function calls,\nSo total 14 CQT is forever locked in the contract.\n\nHardhat test\n\n",
                "Repair": "Please think again when totalGlobalShares is zero.\n\nkitti-katy (Covalent) acknowledged(https://github.com/code-423n4/2021-10-covalent-findings/issues/17#issuecomment-948913401):\n  That is right, and I think the best solution would be to add a validator instance who is the owner and stake some low amount of tokens in it. This way we can make sure there is no such situation when totalGlobalShares  becomes 0 and if everyone unstaked, the owner could take out reward tokens and then unstake / redeem rewards.\n\n Not sure. That could even be marked as \"high risk\". if the situation happens and not handled right away (taking out reward tokens), then there could be more significant financial loss.\n\nkitti-katy (Covalent) commented(https://github.com/code-423n4/2021-10-covalent-findings/issues/17#issuecomment-950028436):\n  marked resolved as it will be manually handled\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-covalent-findings/issues/17#issuecomment-962730124):\n  The issue found by the warden is straightforward:\n Through mix of unstaking and the use of disableValidator the warden was able to lock funds, making them irredemeable\n\n It seems to me that this is caused by the fact that unstake as well as disableValidator will reduce the shares: https://github.com/code-423n4/2021-10-covalent/blob/a8368e7982d336a4b464a53cfe221b2395da801f/contracts/DelegatedStaking.sol#L348\n\n I would recommend separating the shares accounting from the activation of validator, simply removing the subtraction  of global shares in disableValidator would allow them to claim those shares.\n\n The function disableValidator can be called by either the validator or the owner, while onlyOwner can add a new validator\n\n The owner has the ability to perform this type of griefing, as well as a group of validators if they so chose\n\n Due to the specifics of the grief I will rate it of Medium Severity, as per the docs:\n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n In this case we have a way to leak value (lock funds) with specific condition (malicious owner or multiple griefing validators)\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nuint128 rewards = sharesToTokens(s.shares, v.exchangeRate) s.staked;\nrequire(rewards  0, \"Nothing to redeem\");\n"
                ],
                "Type": " Validator can fail to receive commission reward in  redeemAllRewards ",
                "Description": "\nValidator can fail to receive commission reward by calling redeemAllRewards.\nThere's a check in redeemAllRewards\n\nsolidity\nuint128 rewards = sharesToTokens(s.shares, v.exchangeRate) s.staked;\nrequire(rewards  0, \"Nothing to redeem\");\n\n\nThe validator's tx might be reverted here even if he got some commission reward to receive.\n\nWe can trigger the bug by setting commisionRate to 1e18 1 ([DelegatedStaking.sol L275-L276(https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L275-L276))\n\n",
                "Repair": "Though this may rarely happen and the validator can redeem the reward through redeemRewards, this may cause some issues when the validator is handled by a contract.\n\nI consider calling redeemRewards in redeemAllReawards as a more succinct way to do this.\n\nkitti-katy (Covalent) acknowledged(https://github.com/code-423n4/2021-10-covalent-findings/issues/65#issuecomment-948954017):\n  I don't think there will ever be a commission rate set to almost 100%. Since it is changed by the owner we will make sure the input is correct.\n\nGalloDaSballo (judge) commented(https://github.com/code-423n4/2021-10-covalent-findings/issues/65#issuecomment-957813671):\n  Agree with the finding and understand the sponsors take.\n\n As per the docs for contests:\n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n This fall as a medium severity\n\n A simple mitigation would be to limit the commisionRate to less than the value that causes issues\n\n\n"
            }
        ]
    }
]