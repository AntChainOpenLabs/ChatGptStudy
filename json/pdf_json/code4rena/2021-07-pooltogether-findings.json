[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": "  onlyOwnerOrAssetManager  can swap Yield Source in  SwappableYieldSource  at any time, immediately rugging all funds from old yield source",
                "Description": "\nThe function swapYieldSource SwappableYieldSource.sol L307(https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L307)\n\nCan be called by the owner (deployer / initializer) or Asset Manager. The function will take all funds from the old Yield Source, and transfer them to the new Yield source. Any contract that implement the function function depositToken() external returns (address) will pass the check\n\nHowever, if either the owner or the assetManager have malicious intent, this function allows them to instantly rug all funds\n\n1) Create a contract that implements the function depositToken() external returns (address)\n2) Be the Owner or AssetManager\n3) Call setYieldSource while pointing at your malicious contract\n4) Profit\n\nI highly recommend checking that the YieldSource is from a trusted registry before allowing this swap.\n\nAlternatively forcing each Owner to be a TimeLock with at least 48 hours may provide enough security to allow this to be used in practice\n\nPierrickGT (PoolTogether) disputed(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/14#issuecomment-897195417):\n  This is why we will use a multi sig owned by governance to deploy swappable yield sources and manage them. This way, we will avoid these kind of scenarios.\n\n0xean (Judge) commented(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/14#issuecomment-904860248):\n  Agree with warden on the risk here. Will both the AssetManager and the Owner be owned by your governance?\n\n The YieldSource could easily extract user funds or send them back to the SwappableYieldSource contract and then remove them from there.\n\nPierrickGT (PoolTogether) commented(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/14#issuecomment-908774312):\n  We have removed the AssetManager role and Owner will be owned by governance who will vet any change of yield source before going through a vote.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-02",
                "Location": [],
                "Type": "  redeemToken  can fail for certain tokens",
                "Description": "\nThe SwappableYieldSource.redeemToken function transfers tokens from the contract back to the sender, however, it uses the ERC20.transferFrom(address(this), msg.sender, redeemableBalance) function for this.\nSome deposit token implementations might fail as transferFrom checks if the contract approved itself for the redeemableBalance instead of skipping the allowance check in case the sender is the from address.\n\nThis can make the transaction revert and the deposited funds will be unrecoverable for the user.\n\nIt's recommended to use _depositToken.safeTransfer(msg.sender, redeemableBalance) instead.\n\nPierrickGT (PoolTogether) commented(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/61#issuecomment-894368935):\n  Duplicate of https://github.com/code-423n4/2021-07-pooltogether-findings/issues/25\n\n0xean (Judge) commented(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/61#issuecomment-904799020):\n  re-opening this issue and marking #25 as a duplicate of this issue which clearly articulates the potential severity of unrecoverable user funds.\n\nPierrickGT (PoolTogether) resolved(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/61#issuecomment-908446620):\n  This issue has been fixed and we are now using safeTransfer: https://github.com/pooltogether/swappable-yield-source/blob/bf943b3818b81d5f5cb9d8ecc6f13ffecd33a1ff/contracts/SwappableYieldSource.sol#L235\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n// https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol\nfunction setYieldSource(IYieldSource _newYieldSource) external `onlyOwnerOrAssetManager` returns (bool) {\n  _setYieldSource(_newYieldSource);\n\nfunction _setYieldSource(IYieldSource _newYieldSource) internal {\n..\n    yieldSource = _newYieldSource;\n\n function supplyTokenTo(uint256 amount, address to) external override nonReentrant {\n   ..\n    yieldSource.supplyTokenTo(amount, address(this));\n    _mintShares(amount, to);\n  }\n\n function _mintShares(uint256 mintAmount, address to) internal {\n    uint256 shares = `_tokenToShares`(mintAmount);\n    require(shares  0, \"SwappableYieldSource/shares-gt-zero\");\n    _mint(to, shares);\n  }\n\n function _tokenToShares(uint256 tokens) internal returns (uint256) {\n    uint256 shares;\n    uint256 _totalSupply = totalSupply();\n..\n      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this))); // based on incomplete yieldSource.balanceOfToken(address(this))\n      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);\n\n\nfunction balanceOfToken(address addr) external override returns (uint256) {\n    return _sharesToToken(balanceOf(addr));\n  }\n\n function _sharesToToken(uint256 shares) internal returns (uint256) {\n    uint256 tokens;\n    uint256 _totalSupply = totalSupply();\n..\n      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply); // based on incomplete yieldSource.balanceOfToken(address(this))\n      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);\n"
                ],
                "Type": "  setYieldSource  leads to temporary wrong results",
                "Description": "\nThe use of setYieldSource leaves the contract in a temporary inconsistent state because it changes the underlying yield source,\nbut doesn't (yet) transfer the underlying balances, while the shares stay the same.\n\nThe function balanceOfToken will show the wrong results, because it is based on _sharesToToken, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.\n\nMore importantly supplyTokenTo will give the wrong amount of shares back:\nFirst it supplies tokens to the yieldsource.\nThen is calls _mintShares, which calls _tokenToShares, which calculates the shares, using yieldSource.balanceOfToken(address(this))\nThis yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource.\nSo the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).\n\nIt is possible to make use of this problem in the following way:\nmonitor the blockchain until you see setYieldSource has been done\nimmediately call the function supplyTokenTo (which can be called because there is no access control on this function)\n\nsolidity\n// https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol\nfunction setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {\n  _setYieldSource(_newYieldSource);\n\nfunction _setYieldSource(IYieldSource _newYieldSource) internal {\n..\n    yieldSource = _newYieldSource;\n\n function supplyTokenTo(uint256 amount, address to) external override nonReentrant {\n   ..\n    yieldSource.supplyTokenTo(amount, address(this));\n    _mintShares(amount, to);\n  }\n\n function _mintShares(uint256 mintAmount, address to) internal {\n    uint256 shares = _tokenToShares(mintAmount);\n    require(shares  0, \"SwappableYieldSource/shares-gt-zero\");\n    _mint(to, shares);\n  }\n\n function _tokenToShares(uint256 tokens) internal returns (uint256) {\n    uint256 shares;\n    uint256 _totalSupply = totalSupply();\n..\n      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this))); // based on incomplete yieldSource.balanceOfToken(address(this))\n      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);\n\n\nfunction balanceOfToken(address addr) external override returns (uint256) {\n    return _sharesToToken(balanceOf(addr));\n  }\n\n function _sharesToToken(uint256 shares) internal returns (uint256) {\n    uint256 tokens;\n    uint256 _totalSupply = totalSupply();\n..\n      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply); // based on incomplete yieldSource.balanceOfToken(address(this))\n      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);\n\n\nReocommend removing the function setYieldSource  (e.g. only leave swapYieldSource)\nOr temporally disable actions like supplyTokenTo, redeemToken and balanceOfToken, after setYieldSource and until transferFunds has been done.\n\nPierrickGT (PoolTogether) confirmed and resolved(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/4#issuecomment-896981238):\n  PR: https://github.com/pooltogether/swappable-yield-source/pull/4\n We've mitigated this issue by removing the transferFunds and setYieldSource external functions and making swapYieldSource callable only by the owner that will be a multi sig wallet for governance pools.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-04",
                "Location": [
                    "jsx\nfunction _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {\n    require(address(_yieldSource) != address(yieldSource), \"SwappableYieldSource/same-yield-source\");\n\t\trequire(_newYieldSource.depositToken() == yieldSource.depositToken(), \"SwappableYieldSource/different-deposit-token\");\n}\n"
                ],
                "Type": "  SwappableYieldSource : Missing same deposit token check in  transferFunds() ",
                "Description": "\ntransferFunds() will transfer funds from a specified yield source _yieldSource to the current yield source set in the contract _currentYieldSource. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.\n\nAssumptions:\n_yieldSource has a deposit token of WETH (18 decimals)\n_currentYieldSource has a deposit token of DAI (18 decimals)\n1 WETH  1 DAI (definitely true, I'd be really sad otherwise)\n\nAttacker does the following:\n1. Deposit 100 DAI into the swappable yield source contract\n2. Call transferFunds(_yieldSource, 100 * 1e18)\n    _requireDifferentYieldSource() passes\n    _transferFunds(_yieldSource, 100 * 1e18) is called\n        _yieldSource.redeemToken(_amount); \u2192 This will transfer 100 WETH out of the _yieldSource into the contract\n        uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this)); \u2192 This will equate to \u2265 100 WETH.\n        require(_amount <= currentBalance, \"SwappableYieldSource/transfer-amount-different\"); is true since both are 100 * 1e18\n        _currentYieldSource.supplyTokenTo(currentBalance, address(this)); \u2192 This supplies the transferred 100 DAI from step 1 to the current yield source\n    We now have 100 WETH in the swappable yield source contract\n3. Call transferERC20(WETH, attackerAddress, 100 * 1e18) to withdraw 100 WETH out of the contract to the attacker's desired address.\n\n_requireDifferentYieldSource() should also verify that the yield sources' deposit token addresses are the same.\n\njsx\nfunction _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {\n    require(address(_yieldSource) != address(yieldSource), \"SwappableYieldSource/same-yield-source\");\n\t\trequire(_newYieldSource.depositToken() == yieldSource.depositToken(), \"SwappableYieldSource/different-deposit-token\");\n}\n\n\nPierrickGT (PoolTogether) acknowledged(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/29#issuecomment-897208429):\n  This exploit was indeed possible when we had the transferFunds function but now that we have removed it and funds can only be moved by swapYieldSource(), this exploit is no longer possible since we check for the same depositToken in _setYieldSource().\n\n https://github.com/pooltogether/swappable-yield-source/pull/4\n\n0xean (Judge) commented(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/29#issuecomment-904807211):\n  Upgrading to 3 considering the potential for loss of funds\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-01",
                "Location": [],
                "Type": " Single-step process for critical ownership transfer/renounce is risky",
                "Description": "\nThe SwappableYieldSource allows owners and asset managers to set/swap/transfer yield sources/funds. As such, the contract ownership plays a critical role in the protocol.\n\nGiven that AssetManager is derived from Ownable, the ownership management of this contract defaults to Ownable\u2019s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.\n\nScenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner()  or onlyOwnerOrAssetManager() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.\n\nSee similar High Risk severity finding(https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf) from Trail-of-Bits Audit of Hermez.\n\nSee similar[ Medium Risk severity(https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf) finding from Trail-of-Bits Audit of Uniswap V3:\n\n",
                "Repair": "Recommend overriding the inherited methods to null functions and use separate functions for a two-step address change:\n1) Approve a new address as a pendingOwner\n2) A transaction from the pendingOwner address claims the pending ownership change.\n\nThis mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.\n\nAlso, consider adding a time-delay for such sensitive actions. And at a minimum, use a multisig owner address and not an EOA.\n\nPierrickGT (PoolTogether) disputed(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/40#issuecomment-897217286):\n  This isn't a security issue but an improper use of the initialize function.\n We do check for address zero so at least the risk of deploying the contract with address zero is excluded. Also, these contracts will be deployed by a multi sig owned by governance so the risk of a single human error is almost null.\n\n0xean (Judge) commented(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/40#issuecomment-904802425):\n  Disagree with sponsor.  A two step process would be a safer implementation.  A multi-sig does not remove human error or the potential risk here. It may be an acceptable risk to the team, but still worth highlighting with the given severity.\n\nPierrickGT (PoolTogether) acknowledged(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/40#issuecomment-908780172):\n  We have studied this solution and decided to not implement it since it would make it a pretty tedious process to deploy a swappable yield source, especially through the use of our builder which would mean that a user would have to manually claimOwnership after deploying a pool. Plus, this contract will be owned by governance so it will be very difficult to transfer it to another owner or renounce ownership.\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [],
                "Type": " Use of  safeApprove  will always cause  approveMax  to revert",
                "Description": "\nUnlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin\u2019s safeApprove() which has been documented as (1) Deprecated because of approve-like race condition and (2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.\n\nThe usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0. See issue page for referenced code.\n\n",
                "Repair": "Recommend Using logic similar to SwappableYieldSource instead of using safeApprove().\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/47#issuecomment-898731351):\n  This issue has been fixed in the following commit: https://github.com/pooltogether/pooltogether-mstable/pull/3/commits/156a990901e6ddff543897905e3ea3d09c78d817\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": " Inconsistent balance when supplying transfer-on-fee or deflationary tokens",
                "Description": "\nThe supplyTokenTo function of SwappableYieldSource assumes that amount of _depositToken is transferred to itself after calling the safeTransferFrom function (and thus it supplies amount of token to the yield source). However, this may not be true if the _depositToken is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. SwappableYieldSource.sol L211-L212(https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L211-L212)\n\n",
                "Repair": "Recommend getting the actual received amount by calculating the difference of token balance before and after the transfer. For example, re-writing line 211-212 to:\n\nsolidity\nuint256 balanceBefore = _depositToken.balanceOf(address(this));\n_depositToken.safeTransferFrom(msg.sender, address(this), amount);\nuint256 receivedAmount = _depositToken.balanceOf(address(this)) balanceBefore;\nyieldSource.supplyTokenTo(receivedAmount, address(this));\n\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-07-pooltogether-findings/issues/52#issuecomment-897951282):\n  PR: https://github.com/pooltogether/swappable-yield-source/pull/9\n\n\n"
            }
        ]
    }
]