[
    {
        "Code": "/**SPDX-License-Identifier: BUSL-1.1\n\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\n \u2588\u2588 \"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\n */\npragma solidity 0.8.16;\n\nimport \"contracts/cash/interfaces/ICashManager.sol\";\nimport \"contracts/cash/interfaces/IMulticall.sol\";\nimport \"contracts/cash/token/Cash.sol\";\nimport \"contracts/cash/kyc/KYCRegistryClientConstructable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/SafeERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract CashManager is\n  ICashManager,\n  IMulticall,\n  AccessControlEnumerable,\n  KYCRegistryClientConstructable,\n  Pausable,\n  ReentrancyGuard\n{\n  using SafeERC20 for IERC20;\n\n  /// @dev Tokens\n  // ERC20 token used to Mint CASH with\n  IERC20 public immutable collateral;\n\n  // CASH contract\n  Cash public immutable cash;\n\n  /// @dev Collateral Recipients\n  // The address to which the `collateral` is sent\n  address public assetRecipient;\n\n  // The address to which fees are sent\n  address public feeRecipient;\n\n  // The address from which redemptions are processed\n  address public assetSender;\n\n  /// @dev Mint/Redeem Parameters\n  // Minimum amount that must be deposited to mint CASH\n  // Denoted in decimals of `collateral`\n  uint256 public minimumDepositAmount = 10_000;\n\n  // Minimum amount that must be redeemed for a withdraw request\n  uint256 public minimumRedeemAmount;\n\n  // Minting fee specified in basis points\n  uint256 public mintFee = 0;\n\n  // Limit for how far `exchangeRate` can stray from\n  // `lastSetMintExchangeRate` within an epoch (in basis points)\n  uint256 public exchangeRateDeltaLimit = 100;\n\n  // Struct representing all redemption requests in an epoch\n  struct RedemptionRequests {\n    // Total CASH burned in the epoch\n    uint256 totalBurned;\n    // Mapping from address to amount of CASH address burned\n    mapping(address => uint256) addressToBurnAmt;\n  }\n\n  // Mapping from epoch to redemption info struct for that epoch\n  mapping(uint256 => RedemptionRequests) public redemptionInfoPerEpoch;\n\n  // Mapping used for getting the exchange rate during a given epoch\n  mapping(uint256 => uint256) public epochToExchangeRate;\n\n  // Nested mapping containing mint requests for an epoch\n  // { <epoch> : {<user> : <collateralAmount> }\n  mapping(uint256 => mapping(address => uint256)) public mintRequestsPerEpoch;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Decimal multiplier representing the difference between `CASH` decimals\n  // In `collateral` token decimals\n  uint256 public immutable decimalsMultiplier;\n\n  /// @dev Epoch Parameters\n  // Epoch that contract is currently in\n  uint256 public currentEpoch;\n\n  // Duration of an epoch in seconds\n  uint256 public epochDuration;\n\n  // Timestamp of the start of `currentEpoch`\n  uint256 public currentEpochStartTimestamp;\n\n  // `exchangeRate` at start of `currentEpoch`\n  uint256 public lastSetMintExchangeRate = 1e6;\n\n  /// @dev Mint/Redeem Limit Parameters\n  // Maximum amount that can be minted during an epoch\n  uint256 public mintLimit;\n\n  // Amount already minted during the `currentEpoch`\n  uint256 public currentMintAmount;\n\n  // Maximum amount that can be redeemed during an epoch\n  uint256 public redeemLimit;\n\n  // Amount already redeemed during the `currentEpoch`\n  uint256 public currentRedeemAmount;\n\n  /// @dev Role Based Access control members\n  bytes32 public constant MANAGER_ADMIN = keccak256(\"MANAGER_ADMIN\");\n  bytes32 public constant PAUSER_ADMIN = keccak256(\"PAUSER_ADMIN\");\n  bytes32 public constant SETTER_ADMIN = keccak256(\"SETTER_ADMIN\");\n\n  /// @notice constructor\n  constructor(\n    address _collateral,\n    address _cash,\n    address managerAdmin,\n    address pauser,\n    address _assetRecipient,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _mintLimit,\n    uint256 _redeemLimit,\n    uint256 _epochDuration,\n    address _kycRegistry,\n    uint256 _kycRequirementGroup\n  ) KYCRegistryClientConstructable(_kycRegistry, _kycRequirementGroup) {\n    if (_collateral == address(0)) {\n      revert CollateralZeroAddress();\n    }\n    if (_cash == address(0)) {\n      revert CashZeroAddress();\n    }\n    if (_assetRecipient == address(0)) {\n      revert AssetRecipientZeroAddress();\n    }\n    if (_assetSender == address(0)) {\n      revert AssetSenderZeroAddress();\n    }\n    if (_feeRecipient == address(0)) {\n      revert FeeRecipientZeroAddress();\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, managerAdmin);\n    _grantRole(MANAGER_ADMIN, managerAdmin);\n    _setRoleAdmin(PAUSER_ADMIN, MANAGER_ADMIN);\n    _setRoleAdmin(SETTER_ADMIN, MANAGER_ADMIN);\n    _grantRole(PAUSER_ADMIN, pauser);\n\n    collateral = IERC20(_collateral);\n    cash = Cash(_cash);\n    feeRecipient = _feeRecipient;\n    assetRecipient = _assetRecipient;\n    assetSender = _assetSender;\n    currentEpoch = currentEpoch;\n\n    mintLimit = _mintLimit;\n    redeemLimit = _redeemLimit;\n    epochDuration = _epochDuration;\n\n    currentEpochStartTimestamp =\n      block.timestamp -\n      (block.timestamp % epochDuration);\n\n    // Implicit constraint: cash decimals >= collateral decimals.\n    decimalsMultiplier =\n      10 **\n        (IERC20Metadata(_cash).decimals() -\n          IERC20Metadata(_collateral).decimals());\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Mint Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function used by users to submit a request to mint\n   *\n   * @param collateralAmountIn The amount of collateral one wishes to deposit\n   *                           to mint CASH tokens\n   */\n  function requestMint(\n    uint256 collateralAmountIn\n  )\n    external\n    override\n    updateEpoch\n    nonReentrant\n    whenNotPaused\n    checkKYC(msg.sender)\n  {\n    if (collateralAmountIn < minimumDepositAmount) {\n      revert MintRequestAmountTooSmall();\n    }\n\n    uint256 feesInCollateral = _getMintFees(collateralAmountIn);\n    uint256 depositValueAfterFees = collateralAmountIn - feesInCollateral;\n\n    _checkAndUpdateMintLimit(depositValueAfterFees);\n\n    collateral.safeTransferFrom(msg.sender, feeRecipient, feesInCollateral);\n    collateral.safeTransferFrom(\n      msg.sender,\n      assetRecipient,\n      depositValueAfterFees\n    );\n\n    mintRequestsPerEpoch[currentEpoch][msg.sender] += depositValueAfterFees;\n\n    emit MintRequested(\n      msg.sender,\n      currentEpoch,\n      collateralAmountIn,\n      depositValueAfterFees,\n      feesInCollateral\n    );\n  }\n\n  /**\n   * @notice Function used by users to claim an airdrop for a given epoch\n   *\n   * @param user       The user who requested to mint\n   * @param epochToClaim The epoch in which the mint was requested\n   *\n   * @dev We perform KYC check on the user destined to receive `cash`, not the\n   *      msg.sender\n   */\n  function claimMint(\n    address user,\n    uint256 epochToClaim\n  ) external override updateEpoch nonReentrant whenNotPaused checkKYC(user) {\n    uint256 collateralDeposited = mintRequestsPerEpoch[epochToClaim][user];\n    if (collateralDeposited == 0) {\n      revert NoCashToClaim();\n    }\n    if (epochToExchangeRate[epochToClaim] == 0) {\n      revert ExchangeRateNotSet();\n    }\n\n    // Get the amount of CASH due at a given rate per epoch\n    uint256 cashOwed = _getMintAmountForEpoch(\n      collateralDeposited,\n      epochToClaim\n    );\n\n    mintRequestsPerEpoch[epochToClaim][user] = 0;\n    cash.mint(user, cashOwed);\n\n    emit MintCompleted(\n      user,\n      cashOwed,\n      collateralDeposited,\n      epochToExchangeRate[epochToClaim],\n      epochToClaim\n    );\n  }\n\n  /**\n   * @notice Sets mint exchange rate\n   *\n   * @param exchangeRate New mint exchange rate (in 6 decimals)\n   * @param epochToSet   The epoch we want to set the exchange rate for\n   *\n   * @dev If the exchange rate differs more than `exchangeRateDeltaLimit`\n   *      from the last exchange rate set, the entire contract will be paused.\n   *      See `overrideExchangeRate` should this check need to be bypassed\n   */\n  function setMintExchangeRate(\n    uint256 exchangeRate,\n    uint256 epochToSet\n  ) external override updateEpoch onlyRole(SETTER_ADMIN) {\n    if (exchangeRate == 0) {\n      revert ZeroExchangeRate();\n    }\n    if (epochToSet >= currentEpoch) {\n      revert EpochNotElapsed();\n    }\n    if (epochToExchangeRate[epochToSet] != 0) {\n      revert EpochExchangeRateAlreadySet();\n    }\n\n    uint256 rateDifference;\n    if (exchangeRate > lastSetMintExchangeRate) {\n      rateDifference = exchangeRate - lastSetMintExchangeRate;\n    } else if (exchangeRate < lastSetMintExchangeRate) {\n      rateDifference = lastSetMintExchangeRate - exchangeRate;\n    }\n\n    uint256 maxDifferenceThisEpoch = (lastSetMintExchangeRate *\n      exchangeRateDeltaLimit) / BPS_DENOMINATOR;\n\n    if (rateDifference > maxDifferenceThisEpoch) {\n      epochToExchangeRate[epochToSet] = exchangeRate;\n      _pause();\n      emit MintExchangeRateCheckFailed(\n        epochToSet,\n        lastSetMintExchangeRate,\n        exchangeRate\n      );\n    } else {\n      uint256 oldExchangeRate = lastSetMintExchangeRate;\n      epochToExchangeRate[epochToSet] = exchangeRate;\n      lastSetMintExchangeRate = exchangeRate;\n      emit MintExchangeRateSet(epochToSet, oldExchangeRate, exchangeRate);\n    }\n  }\n\n  /**\n   * @notice Override admin function for changing the representation of the\n   *         amount of collateral a user has deposited to kick off minting\n   *         process\n   *\n   * @param user       The user whose balance is being set\n   * @param epoch      The epoch in which to set user balance for\n   * @param oldBalance The user's previous balance\n   * @param newBalance The user's new balance to set\n   *\n   * @dev The total burned amount for the epoch must be set appropriately\n   *      in order to correctly calculate redemptions.\n   * @dev `oldBalance` is provided to prevent front running attacks where a\n   *      user could attempt to claim before and after this is set.\n   */\n  function setPendingMintBalance(\n    address user,\n    uint256 epoch,\n    uint256 oldBalance,\n    uint256 newBalance\n  ) external updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (oldBalance != mintRequestsPerEpoch[epoch][user]) {\n      revert UnexpectedMintBalance();\n    }\n    if (epoch > currentEpoch) {\n      revert CannotServiceFutureEpoch();\n    }\n    mintRequestsPerEpoch[epoch][user] = newBalance;\n    emit PendingMintBalanceSet(user, epoch, oldBalance, newBalance);\n  }\n\n  /**\n   * @notice Allows for the `MANAGER_ADMIN` to arbitrarily set an exchange\n   *         rate for a given epoch\n   *\n   * @param correctExchangeRate      The exchange rate we wish to update to\n   * @param epochToSet               The epoch for which we want to set the rate\n   * @param _lastSetMintExchangeRate Value to set `lastSetMintExchangeRate` to\n   *                                 if not equal to 0\n   *\n   * @dev This function allows the caller to also update the\n   *      `lastSetMintExchangeRate`, which is compared against\n   *      when calling `setMintExchangeRate` to prevent large\n   *      swings in prices.\n   */\n  function overrideExchangeRate(\n    uint256 correctExchangeRate,\n    uint256 epochToSet,\n    uint256 _lastSetMintExchangeRate\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (epochToSet >= currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    uint256 incorrectRate = epochToExchangeRate[epochToSet];\n    epochToExchangeRate[epochToSet] = correctExchangeRate;\n    if (_lastSetMintExchangeRate != 0) {\n      lastSetMintExchangeRate = _lastSetMintExchangeRate;\n    }\n    emit MintExchangeRateOverridden(\n      epochToSet,\n      incorrectRate,\n      correctExchangeRate,\n      lastSetMintExchangeRate\n    );\n  }\n\n  /**\n   * @notice Sets mint exchange rate delta limit\n   *\n   * @param _exchangeRateDeltaLimit New mint exchange rate delta limit (in bps)\n   */\n  function setMintExchangeRateDeltaLimit(\n    uint256 _exchangeRateDeltaLimit\n  ) external override onlyRole(MANAGER_ADMIN) {\n    uint256 oldExchangeRateDeltaLimit = exchangeRateDeltaLimit;\n    exchangeRateDeltaLimit = _exchangeRateDeltaLimit;\n    emit ExchangeRateDeltaLimitSet(\n      oldExchangeRateDeltaLimit,\n      _exchangeRateDeltaLimit\n    );\n  }\n\n  /**\n   * @notice Sets mint fee\n   *\n   * @param _mintFee new mint fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setMintFee(\n    uint256 _mintFee\n  ) external override onlyRole(MANAGER_ADMIN) {\n    if (_mintFee >= BPS_DENOMINATOR) {\n      revert MintFeeTooLarge();\n    }\n    uint256 oldMintFee = mintFee;\n    mintFee = _mintFee;\n    emit MintFeeSet(oldMintFee, _mintFee);\n  }\n\n  /**\n   * @notice Sets minimum deposit amount\n   *\n   * @param _minimumDepositAmount New minimum deposit amount\n   *                              (in decimals specified by `collateral`)\n   *\n   * @dev Must be larger than BPS_DENOMINATOR due to keep our `_getMintFees`\n   *      calculation correct. For example, if a deposit amount is less than\n   *      BPS_DENOMINAOR (say 9999) and `mintFee` = 1,\n   *      (collateralAmount * mintFee) / BPS_DENOMINATOR will incorrectly\n   *      return 0.\n   */\n  function setMinimumDepositAmount(\n    uint256 _minimumDepositAmount\n  ) external override onlyRole(MANAGER_ADMIN) {\n    if (_minimumDepositAmount < BPS_DENOMINATOR) {\n      revert MinimumDepositAmountTooSmall();\n    }\n    uint256 oldMinimumDepositAmount = minimumDepositAmount;\n    minimumDepositAmount = _minimumDepositAmount;\n    emit MinimumDepositAmountSet(\n      oldMinimumDepositAmount,\n      _minimumDepositAmount\n    );\n  }\n\n  /**\n   * @notice Sets fee recipient\n   *\n   * @param _feeRecipient New fee recipient address\n   */\n  function setFeeRecipient(\n    address _feeRecipient\n  ) external override onlyRole(MANAGER_ADMIN) {\n    address oldFeeRecipient = feeRecipient;\n    feeRecipient = _feeRecipient;\n    emit FeeRecipientSet(oldFeeRecipient, _feeRecipient);\n  }\n\n  /**\n   * @notice Sets asset recipient\n   *\n   * @param _assetRecipient New asset recipient address\n   */\n  function setAssetRecipient(\n    address _assetRecipient\n  ) external override onlyRole(MANAGER_ADMIN) {\n    address oldAssetRecipient = assetRecipient;\n    assetRecipient = _assetRecipient;\n    emit AssetRecipientSet(oldAssetRecipient, _assetRecipient);\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much CASH should be\n   *         minted\n   *\n   * @param collateralAmountIn Amount of `collateral` to exchange\n   *                           (in 18 decimals)\n   * @param epoch              The epoch we want to set the rate\n   *                           for\n   *\n   * @return cashAmountOut The amount of cash to be returned\n   *\n   * @dev Scales to 24 decimals to divide by exchange rate in 6 decimals,\n   *      bringing us down to 18 decimals of precision\n   */\n  function _getMintAmountForEpoch(\n    uint256 collateralAmountIn,\n    uint256 epoch\n  ) private view returns (uint256 cashAmountOut) {\n    uint256 amountE24 = _scaleUp(collateralAmountIn) * 1e6;\n    cashAmountOut = amountE24 / epochToExchangeRate[epoch];\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how\n   *\n   *\n   * @param collateralAmount Amount `collateral` to exchange\n   *                         (in decimals of `collateral`)\n   */\n  function _getMintFees(\n    uint256 collateralAmount\n  ) private view returns (uint256) {\n    return (collateralAmount * mintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Scale provided amount up by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting the collateral's decimals\n   *      representation to the CASH amount decimals representation.\n   */\n  function _scaleUp(uint256 amount) private view returns (uint256) {\n    return amount * decimalsMultiplier;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Pause Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Will pause minting functionality of this contract\n   *\n   */\n  function pause() external onlyRole(PAUSER_ADMIN) {\n    _pause();\n  }\n\n  /**\n   * @notice Will unpause minting functionality of this contract\n   */\n  function unpause() external onlyRole(MANAGER_ADMIN) {\n    _unpause();\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Epoch and Rate Limiting Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Update the duration of one epoch\n   *\n   * @param _epochDuration The epoch duration in seconds\n   */\n  function setEpochDuration(\n    uint256 _epochDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldEpochDuration = epochDuration;\n    epochDuration = _epochDuration;\n    emit EpochDurationSet(oldEpochDuration, _epochDuration);\n  }\n\n  /**\n   * @notice Modifier to transition epoch\n   */\n  modifier updateEpoch() {\n    transitionEpoch();\n    _;\n  }\n\n  /**\n   * @notice Transition to another epoch\n   *\n   * @dev Should be called prior to `_checkAndUpdateRedeemLimit`\n   *      and `_checkAndUpdateMintLimit`\n   * @dev Epochs do not always have to be incremented by 1\n   *\n   * @notice If this function determines to transition the epoch\n   *         1) The total supply at the end of the epoch is stored\n   *         2) `currentRedeemAmount` & `currentMintAmount` are set to 0\n   *         3) `currentEpoch` is incremented by number of epochs that\n   *            have elapsed\n   *         4) `currentEpochStartTimestamp` is set.\n   */\n  function transitionEpoch() public {\n    uint256 epochDifference = (block.timestamp - currentEpochStartTimestamp) /\n      epochDuration;\n    if (epochDifference > 0) {\n      currentRedeemAmount = 0;\n      currentMintAmount = 0;\n      currentEpoch += epochDifference;\n      currentEpochStartTimestamp =\n        block.timestamp -\n        (block.timestamp % epochDuration);\n    }\n  }\n\n  /**\n   * @notice Update the amount of token that can be minted during one epoch\n   *\n   * @param _mintLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function setMintLimit(uint256 _mintLimit) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldMintLimit = mintLimit;\n    mintLimit = _mintLimit;\n    emit MintLimitSet(oldMintLimit, _mintLimit);\n  }\n\n  /**\n   * @notice Update the amount of token that can be redeemed during one epoch\n   *\n   * @param _redeemLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function setRedeemLimit(\n    uint256 _redeemLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldRedeemLimit = redeemLimit;\n    redeemLimit = _redeemLimit;\n    emit RedeemLimitSet(oldRedeemLimit, _redeemLimit);\n  }\n\n  /**\n   * @notice Checks the requested mint amount against the rate limiter\n   *\n   * @param collateralAmountIn The requested mint amount\n   *\n   * @dev Reverts if the requested mint amount exceeds the current limit\n   * @dev Should only be called w/n functions w/ `updateEpoch` modifier\n   */\n  function _checkAndUpdateMintLimit(uint256 collateralAmountIn) private {\n    if (collateralAmountIn > mintLimit - currentMintAmount) {\n      revert MintExceedsRateLimit();\n    }\n\n    currentMintAmount += collateralAmountIn;\n  }\n\n  /**\n   * @notice Checks the requested redeem amount against the rate limiter\n   *\n   * @param amount The requested redeem amount\n   *\n   * @dev Reverts if the requested redeem amount exceeds the current limit\n   * @dev Should only be called w/n function w/ `updateEpoch` modifier\n   */\n  function _checkAndUpdateRedeemLimit(uint256 amount) private {\n    if (amount == 0) {\n      revert RedeemAmountCannotBeZero();\n    }\n    if (amount > redeemLimit - currentRedeemAmount) {\n      revert RedeemExceedsRateLimit();\n    }\n\n    currentRedeemAmount += amount;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Redeem Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a RedemptionRequests member to the current epoch array &\n   *         burns tokens\n   *\n   * @param amountCashToRedeem The requested redeem amount\n   */\n  function requestRedemption(\n    uint256 amountCashToRedeem\n  )\n    external\n    override\n    updateEpoch\n    nonReentrant\n    whenNotPaused\n    checkKYC(msg.sender)\n  {\n    if (amountCashToRedeem < minimumRedeemAmount) {\n      revert WithdrawRequestAmountTooSmall();\n    }\n\n    _checkAndUpdateRedeemLimit(amountCashToRedeem);\n\n    redemptionInfoPerEpoch[currentEpoch].addressToBurnAmt[\n        msg.sender\n      ] += amountCashToRedeem;\n    redemptionInfoPerEpoch[currentEpoch].totalBurned += amountCashToRedeem;\n\n    cash.burnFrom(msg.sender, amountCashToRedeem);\n\n    emit RedemptionRequested(msg.sender, amountCashToRedeem, currentEpoch);\n  }\n\n  /**\n   * @notice Allows for an admin account to distribute collateral to users\n   *         based off of the total amount of cash tokens burned w/n a given\n   *         epoch. This function also allows for an admin to refund redemption\n   *         requests w/n an epoch provided that the redemption cannot be\n   *         serviced\n   *\n   * @param redeemers              List of addresses to which we want to\n   *                               issue redemptions to\n   * @param refundees              List of addresses to which we want to issue\n   *                               refunds to in the form of cash tokens\n   * @param collateralAmountToDist The total amount to distribute for redemptions\n   *                               including fees to accrue to Ondo\n   *                               (In units of collateral)\n   * @param epochToService         The epoch number we wish to issue redemptions/\n   *                               refunds for\n   * @param fees                   The amount of fees to send to Ondo\n   *                               (In units of collateral)\n   */\n  function completeRedemptions(\n    address[] calldata redeemers,\n    address[] calldata refundees,\n    uint256 collateralAmountToDist,\n    uint256 epochToService,\n    uint256 fees\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    _checkAddressesKYC(redeemers);\n    _checkAddressesKYC(refundees);\n    if (epochToService >= currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    // Calculate the total quantity of shares tokens burned w/n an epoch\n    uint256 refundedAmt = _processRefund(refundees, epochToService);\n    uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n      .totalBurned - refundedAmt;\n    uint256 amountToDist = collateralAmountToDist - fees;\n    _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n    collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n    emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n  }\n\n  /**\n   * @notice Will iterate over the array of `addressToWithdraw` calculate\n   *         the proportion of burned tokens w/n a given epoch and will\n   *         then distribute collateral based off this % of burned tokens\n   *\n   * @param redeemers      List of addresses we are issuing redemptions too\n   * @param amountToDist   The amount to distribute to clients minus the\n   *                       the fee amount taken by Ondo\n   * @param quantityBurned The total amount of tokens burned in an epoch\n   *                       minus those burned by users who are issued a\n   *                       refund\n   * @param epochToService The epoch we wish to service redemptions and\n   *                       redemptions for\n   */\n  function _processRedemption(\n    address[] calldata redeemers,\n    uint256 amountToDist,\n    uint256 quantityBurned,\n    uint256 epochToService\n  ) private {\n    uint256 size = redeemers.length;\n    for (uint256 i = 0; i < size; ++i) {\n      address redeemer = redeemers[i];\n      uint256 cashAmountReturned = redemptionInfoPerEpoch[epochToService]\n        .addressToBurnAmt[redeemer];\n      redemptionInfoPerEpoch[epochToService].addressToBurnAmt[redeemer] = 0;\n      uint256 collateralAmountDue = (amountToDist * cashAmountReturned) /\n        quantityBurned;\n\n      if (collateralAmountDue == 0) {\n        revert CollateralRedemptionTooSmall();\n      }\n\n      collateral.safeTransferFrom(assetSender, redeemer, collateralAmountDue);\n      emit RedemptionCompleted(\n        redeemer,\n        cashAmountReturned,\n        collateralAmountDue,\n        epochToService\n      );\n    }\n  }\n\n  /**\n   * @notice Iterates over the array of `addressToRefund` and mint them\n   *         back the same quantity of cash tokens burned.\n   *\n   * @param refundees      List of addresses we are issuing refunds for\n   * @param epochToService The epoch we wish to service redemptions for\n   *\n   * @return totalCashAmountRefunded The total amount of cash refunded for `epochToService`.\n   */\n  function _processRefund(\n    address[] calldata refundees,\n    uint256 epochToService\n  ) private returns (uint256 totalCashAmountRefunded) {\n    uint256 size = refundees.length;\n    for (uint256 i = 0; i < size; ++i) {\n      address refundee = refundees[i];\n      uint256 cashAmountBurned = redemptionInfoPerEpoch[epochToService]\n        .addressToBurnAmt[refundee];\n      redemptionInfoPerEpoch[epochToService].addressToBurnAmt[refundee] = 0;\n      cash.mint(refundee, cashAmountBurned);\n      totalCashAmountRefunded += cashAmountBurned;\n      emit RefundIssued(refundee, cashAmountBurned, epochToService);\n    }\n    return totalCashAmountRefunded;\n  }\n\n  /**\n   * @notice will change the `assetSender` variable\n   *\n   * @param newAssetSender The address we wish to change `assetSender` too\n   */\n  function setAssetSender(\n    address newAssetSender\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldAssetSender = assetSender;\n    assetSender = newAssetSender;\n    emit AssetSenderSet(oldAssetSender, newAssetSender);\n  }\n\n  /**\n   * @notice Allows for `MANAGER_ADMIN` to set a new `minimumRedeemAmount`\n   *\n   * @param newRedeemMinimum The new minimum redemption amount\n   *                         in units of 1e18\n   */\n  function setRedeemMinimum(\n    uint256 newRedeemMinimum\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldRedeemMin = minimumRedeemAmount;\n    minimumRedeemAmount = newRedeemMinimum;\n    emit MinimumRedeemAmountSet(oldRedeemMin, minimumRedeemAmount);\n  }\n\n  /**\n   * @notice Custom view function to return the quantity burned by\n   *         an address w/n a given epoch.\n   *\n   * @param epoch The epoch we want to query\n   * @param user  The user we want to know the burned quantity\n   *              of cash tokens for in a given epoch\n   */\n  function getBurnedQuantity(\n    uint256 epoch,\n    address user\n  ) external view returns (uint256) {\n    return redemptionInfoPerEpoch[epoch].addressToBurnAmt[user];\n  }\n\n  /**\n   * @notice Override admin function for changing the representation of the\n   *         amount of CASH a user has burned to kick off redemption process\n   *\n   * @param user    The user whose balance is being set\n   * @param epoch   The epoch in which to set user balance for\n   * @param balance The user's new balance\n   *\n   * @dev The total burned amount for the epoch must be set appropriately\n   *      in order to correctly calculate redemptions.\n   */\n  function setPendingRedemptionBalance(\n    address user,\n    uint256 epoch,\n    uint256 balance\n  ) external updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (epoch > currentEpoch) {\n      revert CannotServiceFutureEpoch();\n    }\n    uint256 previousBalance = redemptionInfoPerEpoch[epoch].addressToBurnAmt[\n      user\n    ];\n    // Increment or decrement total burned for the epoch based on whether we\n    // are increasing or decreasing the balance.\n    if (balance < previousBalance) {\n      redemptionInfoPerEpoch[epoch].totalBurned -= previousBalance - balance;\n    } else if (balance > previousBalance) {\n      redemptionInfoPerEpoch[epoch].totalBurned += balance - previousBalance;\n    }\n    redemptionInfoPerEpoch[epoch].addressToBurnAmt[user] = balance;\n    emit PendingRedemptionBalanceSet(\n      user,\n      epoch,\n      balance,\n      redemptionInfoPerEpoch[epoch].totalBurned\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           KYC FUNCTIONS\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Modifier to check KYC status of an account\n   */\n  modifier checkKYC(address account) {\n    _checkKYC(account);\n    _;\n  }\n\n  /**\n   * @notice Update KYC group of the contract for which\n   *         accounts are checked against\n   *\n   * @param _kycRequirementGroup The new KYC requirement group\n   */\n  function setKYCRequirementGroup(\n    uint256 _kycRequirementGroup\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Update KYC registry address\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function setKYCRegistry(\n    address _kycRegistry\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setKYCRegistry(_kycRegistry);\n  }\n\n  /**\n   * @notice Private function to check KYC status\n   *         of an address\n   *\n   * @param account The account to check KYC status for\n   */\n  function _checkKYC(address account) private view {\n    if (!_getKYCStatus(account)) {\n      revert KYCCheckFailed();\n    }\n  }\n\n  /**\n   * @notice Private function to check KYC status\n   *         of an array of addresses\n   *\n   * @param accounts The accounts to check KYC status for\n   */\n  function _checkAddressesKYC(address[] calldata accounts) private view {\n    uint256 size = accounts.length;\n    for (uint256 i = 0; i < size; ++i) {\n      _checkKYC(accounts[i]);\n    }\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  )\n    external\n    payable\n    override\n    nonReentrant\n    onlyRole(MANAGER_ADMIN)\n    whenPaused\n    returns (bytes[] memory results)\n  {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "CashManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction completeRedemptions(\n  address[] calldata redeemers,\n  address[] calldata refundees,\n  uint256 collateralAmountToDist,\n  uint256 epochToService,\n  uint256 fees\n) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n  _checkAddressesKYC(redeemers);\n  _checkAddressesKYC(refundees);\n  if (epochToService = currentEpoch) {\n    revert MustServicePastEpoch();\n  }\n  // Calculate the total quantity of shares tokens burned w/n an epoch\n  uint256 refundedAmt = _processRefund(refundees, epochToService);\n  uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n    .totalBurned refundedAmt;\n  uint256 amountToDist = collateralAmountToDist fees;\n  _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n  collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n  emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n}\n",
                    "//solidity\nuint256 collateralAmountDue = (amountToDist * cashAmountReturned) /\n        quantityBurned;\n",
                    "//solidity\ncontract TestAudit is BasicDeployment {\n    function setUp() public {\n        createDeploymentCash();\n\n        // Grant Setter\n        vm.startPrank(managerAdmin);\n        cashManager.grantRole(cashManager.SETTER_ADMIN(), address(this));\n        cashManager.grantRole(cashManager.SETTER_ADMIN(), managerAdmin);\n        vm.stopPrank();\n\n        // Seed address with 1000000 USDC\n        vm.prank(USDC_WHALE);\n        USDC.transfer(address(this), INIT_BALANCE_USDC);\n    }\n\n    function test_CashManager_completeRedemptions_BadReedem() public {\n        _setupKYCStatus();\n\n        // Seed alice and bob with 200 cash tokens\n        _seed(200e18, 200e18, 50e18);\n\n        // Have alice request to withdraw 200 cash tokens\n        vm.startPrank(alice);\n        tokenProxied.approve(address(cashManager), 200e18);\n        cashManager.requestRedemption(200e18);\n        vm.stopPrank();\n\n        // Have bob request to withdraw 200 cash tokens\n        vm.startPrank(bob);\n        tokenProxied.approve(address(cashManager), 200e18);\n        cashManager.requestRedemption(200e18);\n        vm.stopPrank();\n\n        // Have charlie request to withdraw his tokens\n        vm.startPrank(charlie);\n        tokenProxied.approve(address(cashManager), 50e18);\n        cashManager.requestRedemption(50e18);\n        vm.stopPrank();\n\n        // Move forward to the next epoch\n        vm.warp(block.timestamp + 1 days);\n        vm.prank(managerAdmin);\n        cashManager.setMintExchangeRate(2e6, 0);\n\n        // Approve the cashMinter contract from the assetSender account\n        _seedSenderWithCollateral(300e6);\n\n        // First call, withdraw Alice and refund Charlie\n        address[] memory withdrawFirstCall = new address[(1);\n        withdrawFirstCall[0] = alice;\n        address[] memory refundFirstCall = new address[(1);\n        refundFirstCall[0] = charlie;\n\n        vm.prank(managerAdmin);\n        cashManager.completeRedemptions(\n            withdrawFirstCall, // Addresses to issue collateral to\n            refundFirstCall, // Addresses to refund cash\n            300e6, // Total amount of money to dist incl fees\n            0, // Epoch we wish to process\n            0 // Fee amount to be transferred to ondo\n        );\n\n        // Alice redemption is calculated taking the refund into account\n        uint256 aliceExpectedBalance = 200e18 * 300e6 / ((200e18 + 200e18 + 50e18) 50e18);\n        assertEq(USDC.balanceOf(alice), aliceExpectedBalance);\n        assertEq(USDC.balanceOf(bob), 0);\n        assertEq(tokenProxied.balanceOf(charlie), 50e18);\n\n        // Second call, withdraw Bob\n        address[] memory withdrawSecondCall = new address[(1);\n        withdrawSecondCall[0] = bob;\n        address[] memory refundSecondCall = new address[(0);\n\n        vm.prank(managerAdmin);\n        cashManager.completeRedemptions(\n            withdrawSecondCall, // Addresses to issue collateral to\n            refundSecondCall, // Addresses to refund cash\n            300e6, // Total amount of money to dist incl fees\n            0, // Epoch we wish to process\n            0 // Fee amount to be transferred to ondo\n        );\n\n        // But here, Bob's redemption doesn't consider the previous refund.\n        uint256 bobBadBalance = uint256(200e18 * 300e6) / (200e18 + 200e18 + 50e18);\n        assertEq(USDC.balanceOf(bob), bobBadBalance);\n    }\n\n    function _setupKYCStatus() internal {\n        // Add KYC addresses\n        address[] memory addressesToKYC = new address[(5);\n        addressesToKYC[0] = guardian;\n        addressesToKYC[1] = address(cashManager);\n        addressesToKYC[2] = alice;\n        addressesToKYC[3] = bob;\n        addressesToKYC[4] = charlie;\n        registry.addKYCAddresses(kycRequirementGroup, addressesToKYC);\n    }\n\n    function _seed(\n        uint256 aliceAmt,\n        uint256 bobAmt,\n        uint256 charlieAmt\n    ) internal {\n        vm.startPrank(guardian);\n        tokenProxied.mint(alice, aliceAmt);\n        tokenProxied.mint(bob, bobAmt);\n        tokenProxied.mint(charlie, charlieAmt);\n        vm.stopPrank();\n    }\n\n    function _seedSenderWithCollateral(uint256 usdcAmount) internal {\n        vm.prank(USDC_WHALE);\n        USDC.transfer(assetSender, usdcAmount);\n        vm.prank(assetSender);\n        USDC.approve(address(cashManager), usdcAmount);\n    }\n}\n"
                ],
                "Type": " Loss of user funds when completing CASH redemptions",
                "Description": "*Submitted by adriro(https://github.com/code-423n4/2023-01-ondo-findings/issues/325), also found by minhquanym(https://github.com/code-423n4/2023-01-ondo-findings/issues/312), minhquanym(https://github.com/code-423n4/2023-01-ondo-findings/issues/311), zaskoh(https://github.com/code-423n4/2023-01-ondo-findings/issues/291), cccz(https://github.com/code-423n4/2023-01-ondo-findings/issues/178), and peanuts(https://github.com/code-423n4/2023-01-ondo-findings/issues/75)*\n\nThe function completeRedemptions present in the CashManager contract is used by the manager to complete redemptions requested by users and also to process refunds.\n\n<https://github.com/code-423n4/2023-01-ondo/blob/main/contracts/cash/CashManager.sol#L707-L727\n\nsolidity\nfunction completeRedemptions(\n  address[] calldata redeemers,\n  address[] calldata refundees,\n  uint256 collateralAmountToDist,\n  uint256 epochToService,\n  uint256 fees\n) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n  _checkAddressesKYC(redeemers);\n  _checkAddressesKYC(refundees);\n  if (epochToService = currentEpoch) {\n    revert MustServicePastEpoch();\n  }\n  // Calculate the total quantity of shares tokens burned w/n an epoch\n  uint256 refundedAmt = _processRefund(refundees, epochToService);\n  uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n    .totalBurned refundedAmt;\n  uint256 amountToDist = collateralAmountToDist fees;\n  _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n  collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n  emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n}\n\n\nThe total refunded amount that is returned from the internal call to _processRefund is then used to calculate the effective amount of CASH burned (redemptionInfoPerEpoch[epochToService].totalBurned refundedAmt). This resulting value is then used to calculate how much each user should receive based on how much CASH they redeemed and the total amount that was burned.\n\nThe main issue here is that the refunded amount is not updated in the totalBurned storage variable for the given epoch. Any subsequent call to this function won't take into account refunds from previous calls.\n\n\nIf the manager completes the refunds and redemptions at different steps or stages for a given epoch, using multiple calls to the completeRedemptions, then any refunded amount won't be considered in subsequent calls to the function.\n\nAny redemption that is serviced in a call after a refund will be calculated using the total burned without subtracting the previous refunds. The function completeRedemptions will call the internal function _processRedemption passing the burned amount as the quantityBurned argument, the value is calculated in line 755:\n\n<https://github.com/code-423n4/2023-01-ondo/blob/main/contracts/cash/CashManager.sol#L755\n\nsolidity\nuint256 collateralAmountDue = (amountToDist * cashAmountReturned) /\n        quantityBurned;\n\n\nThis means that redemptions that are processed after one or more previous refunds will receive less collateral tokens even if they redeemed the same amount of CASH tokens (i.e. greater quantityBurned, less collateralAmountDue), causing loss of funds for the users.\n\n\nIn the following test, Alice, Bob and Charlie request a redemption. The admin first calls completeRedemptions to process Alice's request and refund Charlie. The admin then makes a second call to completeRedemptions to process Bob's request. Even though they redeemed the same amount of CASH (each 200e18), Alice gets 150e6 tokens while Bob is sent ~133e6.\n\nsolidity\ncontract TestAudit is BasicDeployment {\n    function setUp() public {\n        createDeploymentCash();\n\n        // Grant Setter\n        vm.startPrank(managerAdmin);\n        cashManager.grantRole(cashManager.SETTER_ADMIN(), address(this));\n        cashManager.grantRole(cashManager.SETTER_ADMIN(), managerAdmin);\n        vm.stopPrank();\n\n        // Seed address with 1000000 USDC\n        vm.prank(USDC_WHALE);\n        USDC.transfer(address(this), INIT_BALANCE_USDC);\n    }\n\n    function test_CashManager_completeRedemptions_BadReedem() public {\n        _setupKYCStatus();\n\n        // Seed alice and bob with 200 cash tokens\n        _seed(200e18, 200e18, 50e18);\n\n        // Have alice request to withdraw 200 cash tokens\n        vm.startPrank(alice);\n        tokenProxied.approve(address(cashManager), 200e18);\n        cashManager.requestRedemption(200e18);\n        vm.stopPrank();\n\n        // Have bob request to withdraw 200 cash tokens\n        vm.startPrank(bob);\n        tokenProxied.approve(address(cashManager), 200e18);\n        cashManager.requestRedemption(200e18);\n        vm.stopPrank();\n\n        // Have charlie request to withdraw his tokens\n        vm.startPrank(charlie);\n        tokenProxied.approve(address(cashManager), 50e18);\n        cashManager.requestRedemption(50e18);\n        vm.stopPrank();\n\n        // Move forward to the next epoch\n        vm.warp(block.timestamp + 1 days);\n        vm.prank(managerAdmin);\n        cashManager.setMintExchangeRate(2e6, 0);\n\n        // Approve the cashMinter contract from the assetSender account\n        _seedSenderWithCollateral(300e6);\n\n        // First call, withdraw Alice and refund Charlie\n        address[] memory withdrawFirstCall = new address[(1);\n        withdrawFirstCall[0] = alice;\n        address[] memory refundFirstCall = new address[(1);\n        refundFirstCall[0] = charlie;\n\n        vm.prank(managerAdmin);\n        cashManager.completeRedemptions(\n            withdrawFirstCall, // Addresses to issue collateral to\n            refundFirstCall, // Addresses to refund cash\n            300e6, // Total amount of money to dist incl fees\n            0, // Epoch we wish to process\n            0 // Fee amount to be transferred to ondo\n        );\n\n        // Alice redemption is calculated taking the refund into account\n        uint256 aliceExpectedBalance = 200e18 * 300e6 / ((200e18 + 200e18 + 50e18) 50e18);\n        assertEq(USDC.balanceOf(alice), aliceExpectedBalance);\n        assertEq(USDC.balanceOf(bob), 0);\n        assertEq(tokenProxied.balanceOf(charlie), 50e18);\n\n        // Second call, withdraw Bob\n        address[] memory withdrawSecondCall = new address[(1);\n        withdrawSecondCall[0] = bob;\n        address[] memory refundSecondCall = new address[(0);\n\n        vm.prank(managerAdmin);\n        cashManager.completeRedemptions(\n            withdrawSecondCall, // Addresses to issue collateral to\n            refundSecondCall, // Addresses to refund cash\n            300e6, // Total amount of money to dist incl fees\n            0, // Epoch we wish to process\n            0 // Fee amount to be transferred to ondo\n        );\n\n        // But here, Bob's redemption doesn't consider the previous refund.\n        uint256 bobBadBalance = uint256(200e18 * 300e6) / (200e18 + 200e18 + 50e18);\n        assertEq(USDC.balanceOf(bob), bobBadBalance);\n    }\n\n    function _setupKYCStatus() internal {\n        // Add KYC addresses\n        address[] memory addressesToKYC = new address[(5);\n        addressesToKYC[0] = guardian;\n        addressesToKYC[1] = address(cashManager);\n        addressesToKYC[2] = alice;\n        addressesToKYC[3] = bob;\n        addressesToKYC[4] = charlie;\n        registry.addKYCAddresses(kycRequirementGroup, addressesToKYC);\n    }\n\n    function _seed(\n        uint256 aliceAmt,\n        uint256 bobAmt,\n        uint256 charlieAmt\n    ) internal {\n        vm.startPrank(guardian);\n        tokenProxied.mint(alice, aliceAmt);\n        tokenProxied.mint(bob, bobAmt);\n        tokenProxied.mint(charlie, charlieAmt);\n        vm.stopPrank();\n    }\n\n    function _seedSenderWithCollateral(uint256 usdcAmount) internal {\n        vm.prank(USDC_WHALE);\n        USDC.transfer(assetSender, usdcAmount);\n        vm.prank(assetSender);\n        USDC.approve(address(cashManager), usdcAmount);\n    }\n}\n\n\n",
                "Repair": "\nUpdate the totalBurned amount to consider refunds resulting from the call to _processRefund:\n\nsolidity\n  function completeRedemptions(\n    address[] calldata redeemers,\n    address[] calldata refundees,\n    uint256 collateralAmountToDist,\n    uint256 epochToService,\n    uint256 fees\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    _checkAddressesKYC(redeemers);\n    _checkAddressesKYC(refundees);\n    if (epochToService = currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    // Calculate the total quantity of shares tokens burned w/n an epoch\n    uint256 refundedAmt = _processRefund(refundees, epochToService);\n    uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n      .totalBurned refundedAmt;\n+   redemptionInfoPerEpoch[epochToService].totalBurned = quantityBurned;\n    uint256 amountToDist = collateralAmountToDist fees;\n    _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n    collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n    emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n  }\n\n\nali2251 (Ondo Finance) confirmed(https://github.com/code-423n4/2023-01-ondo-findings/issues/325)\n\nypatil12 (Ondo Finance) resolved(https://github.com/code-423n4/2023-01-ondo-findings/issues/325#issuecomment-1410627920)\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]