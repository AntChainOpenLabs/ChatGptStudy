[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ICollateral.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"./interfaces/IHook.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ncontract Collateral is\n    ICollateral,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bool private _depositsAllowed;\n    bool private _withdrawalsAllowed;\n    address private _treasury;\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n    IERC20Upgradeable private _baseToken;\n    IStrategyController private _strategyController;\n\n    uint256 private _delayedWithdrawalExpiry;\n    mapping(address => WithdrawalRequest) private _accountToWithdrawalRequest;\n\n    IHook private _depositHook;\n    IHook private _withdrawHook;\n\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    function initialize(address _newBaseToken, address _newTreasury)\n        public\n        initializer\n    {\n        __Ownable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n        __ERC20_init_unchained(\n            string(\"prePO Collateral Token\"),\n            string(\"preCT\")\n        );\n        _baseToken = IERC20Upgradeable(_newBaseToken);\n        _treasury = _newTreasury;\n    }\n\n    function deposit(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_depositsAllowed, \"Deposits not allowed\");\n        _baseToken.safeTransferFrom(msg.sender, address(this), _amount);\n        // Calculate fees and shares to mint including latent contract funds\n        uint256 _amountToDeposit = _baseToken.balanceOf(address(this));\n        // Record deposit before fee is taken\n        if (address(_depositHook) != address(0)) {\n            _depositHook.hook(msg.sender, _amount, _amountToDeposit);\n        }\n        /**\n         * Add 1 to avoid rounding to zero, only process deposit if user is\n         * depositing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountToDeposit * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amountToDeposit > _fee, \"Deposit amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        _amountToDeposit -= _fee;\n\n        uint256 _valueBefore = _strategyController.totalValue();\n        _baseToken.approve(address(_strategyController), _amountToDeposit);\n        _strategyController.deposit(_amountToDeposit);\n        uint256 _valueAfter = _strategyController.totalValue();\n        _amountToDeposit = _valueAfter - _valueBefore;\n\n        uint256 _shares = 0;\n        if (totalSupply() == 0) {\n            _shares = _amountToDeposit;\n        } else {\n            /**\n             * # of shares owed = amount deposited / cost per share, cost per\n             * share = total supply / total value.\n             */\n            _shares = (_amountToDeposit * totalSupply()) / (_valueBefore);\n        }\n        _mint(msg.sender, _shares);\n        return _shares;\n    }\n\n    function initiateWithdrawal(uint256 _amount) external override {\n        /**\n         * Checking the balance before initiation is necessary since a user\n         * could initiate an unlimited withdrawal amount ahead of time,\n         * negating the protection a delayed withdrawal offers.\n         */\n        require(balanceOf(msg.sender) >= _amount, \"Insufficient balance\");\n        _accountToWithdrawalRequest[msg.sender].amount = _amount;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = block.number;\n    }\n\n    function uninitiateWithdrawal() external override {\n        _accountToWithdrawalRequest[msg.sender].amount = 0;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = 0;\n    }\n\n    function _processDelayedWithdrawal(address _account, uint256 _amount)\n        internal\n    {\n        /**\n         * Verify that the withdrawal being processed matches what was\n         * recorded during initiation.\n         */\n        require(\n            _accountToWithdrawalRequest[_account].amount == _amount,\n            \"Initiated amount does not match\"\n        );\n        uint256 _recordedBlock = _accountToWithdrawalRequest[_account]\n            .blockNumber;\n        require(\n            _recordedBlock + _delayedWithdrawalExpiry >= block.number,\n            \"Must withdraw before expiry\"\n        );\n        require(\n            block.number > _recordedBlock,\n            \"Must withdraw in a later block\"\n        );\n        // Reset the initiation prior to withdrawal.\n        _accountToWithdrawalRequest[_account].amount = 0;\n        _accountToWithdrawalRequest[_account].blockNumber = 0;\n    }\n\n    function withdraw(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_withdrawalsAllowed, \"Withdrawals not allowed\");\n        if (_delayedWithdrawalExpiry != 0) {\n            _processDelayedWithdrawal(msg.sender, _amount);\n        }\n        uint256 _owed = (_strategyController.totalValue() * _amount) /\n            totalSupply();\n        _burn(msg.sender, _amount);\n\n        uint256 _balanceBefore = _baseToken.balanceOf(address(this));\n        _strategyController.withdraw(address(this), _owed);\n        uint256 _balanceAfter = _baseToken.balanceOf(address(this));\n\n        uint256 _amountWithdrawn = _balanceAfter - _balanceBefore;\n        // Record withdrawal before fee is taken\n        if (address(_withdrawHook) != address(0)) {\n            _withdrawHook.hook(msg.sender, _amount, _amountWithdrawn);\n        }\n\n        /**\n         * Send redemption fee to the protocol treasury. Add 1 to avoid\n         * rounding to zero, only process withdrawal if user is\n         * withdrawing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountWithdrawn * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_amountWithdrawn > _fee, \"Withdrawal amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        _amountWithdrawn -= _fee;\n        _baseToken.safeTransfer(msg.sender, _amountWithdrawn);\n        return _amountWithdrawn;\n    }\n\n    function setDepositsAllowed(bool _allowed) external override onlyOwner {\n        _depositsAllowed = _allowed;\n        emit DepositsAllowedChanged(_allowed);\n    }\n\n    function setWithdrawalsAllowed(bool _allowed) external override onlyOwner {\n        _withdrawalsAllowed = _allowed;\n        emit WithdrawalsAllowedChanged(_allowed);\n    }\n\n    function setStrategyController(IStrategyController _newStrategyController)\n        external\n        override\n        onlyOwner\n    {\n        _strategyController = _newStrategyController;\n        emit StrategyControllerChanged(address(_strategyController));\n    }\n\n    function setDelayedWithdrawalExpiry(uint256 _newDelayedWithdrawalExpiry)\n        external\n        override\n        onlyOwner\n    {\n        _delayedWithdrawalExpiry = _newDelayedWithdrawalExpiry;\n        emit DelayedWithdrawalExpiryChanged(_delayedWithdrawalExpiry);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_mintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_redemptionFee);\n    }\n\n    function setDepositHook(IHook _newDepositHook)\n        external\n        override\n        onlyOwner\n    {\n        _depositHook = _newDepositHook;\n        emit DepositHookChanged(address(_depositHook));\n    }\n\n    function setWithdrawHook(IHook _newWithdrawHook)\n        external\n        override\n        onlyOwner\n    {\n        _withdrawHook = _newWithdrawHook;\n        emit WithdrawHookChanged(address(_withdrawHook));\n    }\n\n    function getDepositsAllowed() external view override returns (bool) {\n        return _depositsAllowed;\n    }\n\n    function getWithdrawalsAllowed() external view override returns (bool) {\n        return _withdrawalsAllowed;\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getBaseToken()\n        external\n        view\n        override\n        returns (IERC20Upgradeable)\n    {\n        return _baseToken;\n    }\n\n    function getStrategyController()\n        external\n        view\n        override\n        returns (IStrategyController)\n    {\n        return _strategyController;\n    }\n\n    function getDelayedWithdrawalExpiry()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _delayedWithdrawalExpiry;\n    }\n\n    function getWithdrawalRequest(address _account)\n        external\n        view\n        override\n        returns (WithdrawalRequest memory)\n    {\n        return _accountToWithdrawalRequest[_account];\n    }\n\n    function getDepositHook() external view override returns (IHook) {\n        return _depositHook;\n    }\n\n    function getWithdrawHook() external view override returns (IHook) {\n        return _withdrawHook;\n    }\n\n    function getAmountForShares(uint256 _shares)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() == 0) {\n            return _shares;\n        }\n        return (_shares * totalAssets()) / totalSupply();\n    }\n\n    function getSharesForAmount(uint256 _amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _totalAssets = totalAssets();\n        return\n            (_totalAssets > 0)\n                ? ((_amount * totalSupply()) / _totalAssets)\n                : 0;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return\n            _baseToken.balanceOf(address(this)) +\n            _strategyController.totalValue();\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IAccountAccessController.sol\";\n\ncontract AccountAccessController is Ownable, IAccountAccessController {\n    bytes32 private _root;\n    uint16 internal _allowedAccountsIndex;\n    uint16 internal _blockedAccountsIndex;\n    mapping(uint16 => mapping(address => bool)) private _allowedAccounts;\n    mapping(uint16 => mapping(address => bool)) private _blockedAccounts;\n\n    constructor() {}\n\n    function setRoot(bytes32 _newRoot) external override onlyOwner {\n        _setRoot(_newRoot);\n    }\n\n    function clearAllowedAccounts() external override onlyOwner {\n        _clearAllowedAccounts();\n    }\n\n    function setRootAndClearAllowedAccounts(bytes32 _newRoot)\n        external\n        override\n        onlyOwner\n    {\n        _setRoot(_newRoot);\n        _clearAllowedAccounts();\n    }\n\n    function clearBlockedAccounts() external override onlyOwner {\n        _blockedAccountsIndex++;\n        emit BlockedAccountsCleared(_blockedAccountsIndex);\n    }\n\n    function allowAccounts(address[] calldata _accounts)\n        external\n        override\n        onlyOwner\n    {\n        for (uint256 _i = 0; _i < _accounts.length; _i++) {\n            _allowedAccounts[_allowedAccountsIndex][_accounts[_i]] = true;\n            emit AccountAllowed(_accounts[_i]);\n        }\n    }\n\n    function blockAccounts(address[] calldata _accounts)\n        external\n        override\n        onlyOwner\n    {\n        for (uint256 _i = 0; _i < _accounts.length; _i++) {\n            _blockedAccounts[_blockedAccountsIndex][_accounts[_i]] = true;\n            emit AccountBlocked(_accounts[_i]);\n        }\n    }\n\n    function allowSelf(bytes32[] calldata _proof) external override {\n        require(\n            _allowedAccounts[_allowedAccountsIndex][msg.sender] == false,\n            \"Account already registered\"\n        );\n        bytes32 _leaf = keccak256(abi.encodePacked(msg.sender));\n\n        require(MerkleProof.verify(_proof, _root, _leaf), \"Invalid proof\");\n        _allowedAccounts[_allowedAccountsIndex][msg.sender] = true;\n        emit AccountAllowed(msg.sender);\n    }\n\n    function getRoot() external view override returns (bytes32) {\n        return _root;\n    }\n\n    function isAccountAllowed(address _account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _allowedAccounts[_allowedAccountsIndex][_account];\n    }\n\n    function isAccountBlocked(address _account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _blockedAccounts[_blockedAccountsIndex][_account];\n    }\n\n    function _setRoot(bytes32 _newRoot) internal {\n        _root = _newRoot;\n        emit RootChanged(_root);\n    }\n\n    function _clearAllowedAccounts() internal {\n        _allowedAccountsIndex++;\n        emit AllowedAccountsCleared(_allowedAccountsIndex);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SingleStrategyController is\n    IStrategyController,\n    Ownable,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    address private _vault;\n    IStrategy private _strategy;\n    IERC20 private immutable _baseToken;\n\n    modifier onlyVault() {\n        require(msg.sender == _vault, \"Caller is not the vault\");\n        _;\n    }\n\n    constructor(IERC20 _token) {\n        require(address(_token) != address(0), \"Zero address\");\n        _baseToken = _token;\n    }\n\n    // Assumes approval to take `_amount` has already been given by vault\n    function deposit(uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _baseToken.safeTransferFrom(_vault, address(this), _amount);\n        _strategy.deposit(_baseToken.balanceOf(address(this)));\n    }\n\n    function withdraw(address _recipient, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _strategy.withdraw(_recipient, _amount);\n    }\n\n    function migrate(IStrategy _newStrategy)\n        external\n        override\n        onlyOwner\n        nonReentrant\n    {\n        uint256 _oldStrategyBalance;\n        IStrategy _oldStrategy = _strategy;\n        _strategy = _newStrategy;\n        _baseToken.approve(address(_newStrategy), type(uint256).max);\n        if (address(_oldStrategy) != address(0)) {\n            _baseToken.approve(address(_oldStrategy), 0);\n            _oldStrategyBalance = _oldStrategy.totalValue();\n            _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n            _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n        }\n        emit StrategyMigrated(\n            address(_oldStrategy),\n            address(_newStrategy),\n            _oldStrategyBalance\n        );\n    }\n\n    function setVault(address _newVault) external override onlyOwner {\n        _vault = _newVault;\n        emit VaultChanged(_newVault);\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return _baseToken.balanceOf(address(this)) + _strategy.totalValue();\n    }\n\n    function getVault() external view override returns (address) {\n        return _vault;\n    }\n\n    function getStrategy() external view override returns (IStrategy) {\n        return _strategy;\n    }\n\n    function getBaseToken() external view override returns (IERC20) {\n        return _baseToken;\n    }\n}\n\n\n",
        "CodeNames": [
            "Collateral.sol",
            "AccountAccessController.sol",
            "SingleStrategyController.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "(_strategyController.totalValue() * _amount) / totalSupply()",
                    "_owed",
                    "totalSupply()",
                    "uint",
                    "deposit()",
                    "totalValue()",
                    "migrate()",
                    "_shares = (_amountToDeposit * totalSupply()) / (_valueBefore);",
                    "withdraw()"
                ],
                "Type": " Strategy Migration May Leave Tokens in the Old Strategy Impacting Share Calculations",
                "Description": "\nIf a strategy does not have sufficient funds to withdraw() for the full amount then it is possible that tokens will be left in this yield contract during migrate().\n\nIt is common for withdrawal from a strategy to withdraw less than a user's balance. The reason is that these yield protocols may lend the deposited funds to borrowers, if there is less funds in the pool than the withdrawal amount the withdrawal may succeed but only transfer the funds available rather than the full withdrawal amount.\n\nThe impact of tokens remaining in the old strategy is that when we call StrategyController.totalValue() this will only account for the tokens deposited in the new strategy and not those stuck in the previous strategy. Therefore totalValue() is undervalued.\n\nThus, when a user calls Collateral.deposit() the share calculations _shares = (_amountToDeposit * totalSupply()) / (_valueBefore); will be over stated (note: uint256 _valueBefore = _strategyController.totalValue();). Hence, the user will receive more shares than they should.\n\nThe old tokens may be recovered by calling migrate() back to the old strategy. If this is done then totalValue() will now include the tokens previously stuck. The recent depositer may now withdraw and will be owed (_strategyController.totalValue() * _amount) / totalSupply(). Since totalValue() is now includes the previously stuck tokens  _owed will be overstated and the user will receive more collateral than they should.\n\nThe remaining users who had deposited before migrate() will lose tokens proportional to their share of the totalSupply().\n\n\nSingleStrategyController.sol#L51-L72(https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72)<br\n\n        function migrate(IStrategy _newStrategy)\n            external\n            override\n            onlyOwner\n            nonReentrant\n        {\n            uint256 _oldStrategyBalance;\n            IStrategy _oldStrategy = _strategy;\n            _strategy = _newStrategy;\n            _baseToken.approve(address(_newStrategy), type(uint256).max);\n            if (address(_oldStrategy) != address(0)) {\n                _baseToken.approve(address(_oldStrategy), 0);\n                _oldStrategyBalance = _oldStrategy.totalValue();\n                _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n                _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n            }\n            emit StrategyMigrated(\n                address(_oldStrategy),\n                address(_newStrategy),\n                _oldStrategyBalance\n            );\n        }\n\n",
                "Repair": "\nThe recommendation is to ensure that require(_oldStrategy.totalValue() == 0) after calling _oldStrategy.withdraw(). This ensures that no funds are left in the strategy. Consider the code example below.\n\n        function migrate(IStrategy _newStrategy)\n            external\n            override\n            onlyOwner\n            nonReentrant\n        {\n            uint256 _oldStrategyBalance;\n            IStrategy _oldStrategy = _strategy;\n            _strategy = _newStrategy;\n            _baseToken.approve(address(_newStrategy), type(uint256).max);\n            if (address(_oldStrategy) != address(0)) {\n                _baseToken.approve(address(_oldStrategy), 0);\n                _oldStrategyBalance = _oldStrategy.totalValue();\n                _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n                require(_oldStrategy.totalValue() == 0)\n                _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n            }\n            emit StrategyMigrated(\n                address(_oldStrategy),\n                address(_newStrategy),\n                _oldStrategyBalance\n            );\n        }\n\nramenforbreakfast (prePO) confirmed and commented(https://github.com/code-423n4/2022-03-prepo-findings/issues/26#issuecomment-1075728097):\n  This is a valid claim, although it is an edge case. I will maintain the severity of this issue as is. Should consider removing a fixed migration procedure altogether as this issue demonstrates one of the many problems that can occur.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-03-prepo-findings/issues/26#issuecomment-1086869784):\n  Agree with sponsor.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ICollateral.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"./interfaces/IHook.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ncontract Collateral is\n    ICollateral,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bool private _depositsAllowed;\n    bool private _withdrawalsAllowed;\n    address private _treasury;\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n    IERC20Upgradeable private _baseToken;\n    IStrategyController private _strategyController;\n\n    uint256 private _delayedWithdrawalExpiry;\n    mapping(address => WithdrawalRequest) private _accountToWithdrawalRequest;\n\n    IHook private _depositHook;\n    IHook private _withdrawHook;\n\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    function initialize(address _newBaseToken, address _newTreasury)\n        public\n        initializer\n    {\n        __Ownable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n        __ERC20_init_unchained(\n            string(\"prePO Collateral Token\"),\n            string(\"preCT\")\n        );\n        _baseToken = IERC20Upgradeable(_newBaseToken);\n        _treasury = _newTreasury;\n    }\n\n    function deposit(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_depositsAllowed, \"Deposits not allowed\");\n        _baseToken.safeTransferFrom(msg.sender, address(this), _amount);\n        // Calculate fees and shares to mint including latent contract funds\n        uint256 _amountToDeposit = _baseToken.balanceOf(address(this));\n        // Record deposit before fee is taken\n        if (address(_depositHook) != address(0)) {\n            _depositHook.hook(msg.sender, _amount, _amountToDeposit);\n        }\n        /**\n         * Add 1 to avoid rounding to zero, only process deposit if user is\n         * depositing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountToDeposit * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amountToDeposit > _fee, \"Deposit amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        _amountToDeposit -= _fee;\n\n        uint256 _valueBefore = _strategyController.totalValue();\n        _baseToken.approve(address(_strategyController), _amountToDeposit);\n        _strategyController.deposit(_amountToDeposit);\n        uint256 _valueAfter = _strategyController.totalValue();\n        _amountToDeposit = _valueAfter - _valueBefore;\n\n        uint256 _shares = 0;\n        if (totalSupply() == 0) {\n            _shares = _amountToDeposit;\n        } else {\n            /**\n             * # of shares owed = amount deposited / cost per share, cost per\n             * share = total supply / total value.\n             */\n            _shares = (_amountToDeposit * totalSupply()) / (_valueBefore);\n        }\n        _mint(msg.sender, _shares);\n        return _shares;\n    }\n\n    function initiateWithdrawal(uint256 _amount) external override {\n        /**\n         * Checking the balance before initiation is necessary since a user\n         * could initiate an unlimited withdrawal amount ahead of time,\n         * negating the protection a delayed withdrawal offers.\n         */\n        require(balanceOf(msg.sender) >= _amount, \"Insufficient balance\");\n        _accountToWithdrawalRequest[msg.sender].amount = _amount;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = block.number;\n    }\n\n    function uninitiateWithdrawal() external override {\n        _accountToWithdrawalRequest[msg.sender].amount = 0;\n        _accountToWithdrawalRequest[msg.sender].blockNumber = 0;\n    }\n\n    function _processDelayedWithdrawal(address _account, uint256 _amount)\n        internal\n    {\n        /**\n         * Verify that the withdrawal being processed matches what was\n         * recorded during initiation.\n         */\n        require(\n            _accountToWithdrawalRequest[_account].amount == _amount,\n            \"Initiated amount does not match\"\n        );\n        uint256 _recordedBlock = _accountToWithdrawalRequest[_account]\n            .blockNumber;\n        require(\n            _recordedBlock + _delayedWithdrawalExpiry >= block.number,\n            \"Must withdraw before expiry\"\n        );\n        require(\n            block.number > _recordedBlock,\n            \"Must withdraw in a later block\"\n        );\n        // Reset the initiation prior to withdrawal.\n        _accountToWithdrawalRequest[_account].amount = 0;\n        _accountToWithdrawalRequest[_account].blockNumber = 0;\n    }\n\n    function withdraw(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(_withdrawalsAllowed, \"Withdrawals not allowed\");\n        if (_delayedWithdrawalExpiry != 0) {\n            _processDelayedWithdrawal(msg.sender, _amount);\n        }\n        uint256 _owed = (_strategyController.totalValue() * _amount) /\n            totalSupply();\n        _burn(msg.sender, _amount);\n\n        uint256 _balanceBefore = _baseToken.balanceOf(address(this));\n        _strategyController.withdraw(address(this), _owed);\n        uint256 _balanceAfter = _baseToken.balanceOf(address(this));\n\n        uint256 _amountWithdrawn = _balanceAfter - _balanceBefore;\n        // Record withdrawal before fee is taken\n        if (address(_withdrawHook) != address(0)) {\n            _withdrawHook.hook(msg.sender, _amount, _amountWithdrawn);\n        }\n\n        /**\n         * Send redemption fee to the protocol treasury. Add 1 to avoid\n         * rounding to zero, only process withdrawal if user is\n         * withdrawing an amount large enough to pay a fee.\n         */\n        uint256 _fee = (_amountWithdrawn * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_amountWithdrawn > _fee, \"Withdrawal amount too small\");\n        _baseToken.safeTransfer(_treasury, _fee);\n        _amountWithdrawn -= _fee;\n        _baseToken.safeTransfer(msg.sender, _amountWithdrawn);\n        return _amountWithdrawn;\n    }\n\n    function setDepositsAllowed(bool _allowed) external override onlyOwner {\n        _depositsAllowed = _allowed;\n        emit DepositsAllowedChanged(_allowed);\n    }\n\n    function setWithdrawalsAllowed(bool _allowed) external override onlyOwner {\n        _withdrawalsAllowed = _allowed;\n        emit WithdrawalsAllowedChanged(_allowed);\n    }\n\n    function setStrategyController(IStrategyController _newStrategyController)\n        external\n        override\n        onlyOwner\n    {\n        _strategyController = _newStrategyController;\n        emit StrategyControllerChanged(address(_strategyController));\n    }\n\n    function setDelayedWithdrawalExpiry(uint256 _newDelayedWithdrawalExpiry)\n        external\n        override\n        onlyOwner\n    {\n        _delayedWithdrawalExpiry = _newDelayedWithdrawalExpiry;\n        emit DelayedWithdrawalExpiryChanged(_delayedWithdrawalExpiry);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_mintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_redemptionFee);\n    }\n\n    function setDepositHook(IHook _newDepositHook)\n        external\n        override\n        onlyOwner\n    {\n        _depositHook = _newDepositHook;\n        emit DepositHookChanged(address(_depositHook));\n    }\n\n    function setWithdrawHook(IHook _newWithdrawHook)\n        external\n        override\n        onlyOwner\n    {\n        _withdrawHook = _newWithdrawHook;\n        emit WithdrawHookChanged(address(_withdrawHook));\n    }\n\n    function getDepositsAllowed() external view override returns (bool) {\n        return _depositsAllowed;\n    }\n\n    function getWithdrawalsAllowed() external view override returns (bool) {\n        return _withdrawalsAllowed;\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getBaseToken()\n        external\n        view\n        override\n        returns (IERC20Upgradeable)\n    {\n        return _baseToken;\n    }\n\n    function getStrategyController()\n        external\n        view\n        override\n        returns (IStrategyController)\n    {\n        return _strategyController;\n    }\n\n    function getDelayedWithdrawalExpiry()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _delayedWithdrawalExpiry;\n    }\n\n    function getWithdrawalRequest(address _account)\n        external\n        view\n        override\n        returns (WithdrawalRequest memory)\n    {\n        return _accountToWithdrawalRequest[_account];\n    }\n\n    function getDepositHook() external view override returns (IHook) {\n        return _depositHook;\n    }\n\n    function getWithdrawHook() external view override returns (IHook) {\n        return _withdrawHook;\n    }\n\n    function getAmountForShares(uint256 _shares)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() == 0) {\n            return _shares;\n        }\n        return (_shares * totalAssets()) / totalSupply();\n    }\n\n    function getSharesForAmount(uint256 _amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _totalAssets = totalAssets();\n        return\n            (_totalAssets > 0)\n                ? ((_amount * totalSupply()) / _totalAssets)\n                : 0;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return\n            _baseToken.balanceOf(address(this)) +\n            _strategyController.totalValue();\n    }\n}\n\n\n",
        "CodeNames": [
            "Collateral.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "jsx\nit(\"will cause 0 share issuance\", async () = {\n\t// 1. first user deposits 2 wei because 1 wei will be deducted for fee\n\tlet firstDepositAmount = ethers.BigNumber.from(2)\n\tawait transferAndApproveForDeposit(\n\t    user,\n\t    collateral.address,\n\t    firstDepositAmount\n\t)\n\t\n\tawait collateral\n\t    .connect(user)\n\t    .deposit(firstDepositAmount)\n\t\n\t// 2. do huge transfer of 1M to strategy to controller\n\t// to greatly inflate share price\n\tawait baseToken.transfer(strategyController.address, ethers.utils.parseEther(\"1000000\"));\n\t\n\t// 3. deployer tries to deposit reasonable amount of 10_000\n\tlet subsequentDepositAmount = ethers.utils.parseEther(\"10000\");\n\tawait transferAndApproveForDeposit(\n\t    deployer,\n\t    collateral.address,\n\t    subsequentDepositAmount\n\t)\n\n\tawait collateral\n\t    .connect(deployer)\n\t    .deposit(subsequentDepositAmount)\n\t\n\t// receives 0 shares in return\n\texpect(await collateral.balanceOf(deployer.address)).to.be.eq(0)\n});\n"
                ],
                "Type": " First depositor can break minting of shares",
                "Description": "\nCollateral.sol#L82-L91(https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/Collateral.sol#L82-L91)<br\n\nThe attack vector and impact is the same as TOB-YEARN-003(https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.\n\n\n*   Attacker deposits 2 wei (so that it is greater than min fee) to mint 1 share\n*   Attacker transfers exorbitant amount to _strategyController to greatly inflate the share\u2019s price. Note that the _strategyController deposits its entire balance to the strategy when its deposit() function is called.\n*   Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.\n\njsx\nit(\"will cause 0 share issuance\", async () = {\n\t// 1. first user deposits 2 wei because 1 wei will be deducted for fee\n\tlet firstDepositAmount = ethers.BigNumber.from(2)\n\tawait transferAndApproveForDeposit(\n\t    user,\n\t    collateral.address,\n\t    firstDepositAmount\n\t)\n\t\n\tawait collateral\n\t    .connect(user)\n\t    .deposit(firstDepositAmount)\n\t\n\t// 2. do huge transfer of 1M to strategy to controller\n\t// to greatly inflate share price\n\tawait baseToken.transfer(strategyController.address, ethers.utils.parseEther(\"1000000\"));\n\t\n\t// 3. deployer tries to deposit reasonable amount of 10_000\n\tlet subsequentDepositAmount = ethers.utils.parseEther(\"10000\");\n\tawait transferAndApproveForDeposit(\n\t    deployer,\n\t    collateral.address,\n\t    subsequentDepositAmount\n\t)\n\n\tawait collateral\n\t    .connect(deployer)\n\t    .deposit(subsequentDepositAmount)\n\t\n\t// receives 0 shares in return\n\texpect(await collateral.balanceOf(deployer.address)).to.be.eq(0)\n});\n\n\n",
                "Repair": "\n*   Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address(https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when totalSupply() == 0, send the first min liquidity LP tokens to the zero address to enable share dilution.\n*   Ensure the number of shares to be minted is non-zero: require(_shares != 0, \"zero shares minted\");\n*   Create a periphery contract that contains a wrapper function that atomically calls initialize() and deposit()\n*   Call deposit() once in initialize() to achieve the same effect as the suggestion above.\n\nramenforbreakfast (prePO) confirmed and commented(https://github.com/code-423n4/2022-03-prepo-findings/issues/27#issuecomment-1075728622):\n  Valid submission, good explanation of the problem and nice to see it being demonstrated via a test case block.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-03-prepo-findings/issues/27#issuecomment-1086869644):\n  Agree with sponsor.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "initiateWithdrawal",
                    "amount",
                    "_delayedWithdrawalExpiry =",
                    "initiateWithdrawal("
                ],
                "Type": " Withdrawal delay can be circumvented",
                "Description": "\nCollateral.sol#L97(https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L97)<br\n\nAfter initiating a withdrawal with initiateWithdrawal, it's still possible to transfer the collateral tokens.\nThis can be used to create a second account, transfer the accounts to them and initiate withdrawals at a different time frame such that one of the accounts is always in a valid withdrawal window, no matter what time it is.\nIf the token owner now wants to withdraw they just transfer the funds to the account that is currently in a valid withdrawal window.\n\nAlso, note that each account can withdraw the specified amount. Creating several accounts and circling & initiating withdrawals with all of them allows withdrawing larger amounts even at the same block as they are purchased in the future.\n\nI consider this high severity because it breaks core functionality of the Collateral token.\n\n\nFor example, assume the _delayedWithdrawalExpiry = 20 blocks. Account A owns 1000 collateral tokens, they create a second account B.\n\n*   At block=0, A calls initiateWithdrawal(1000). They send their balance to account B.\n*   At block=10, B calls initiateWithdrawal(1000). They send their balance to account A.\n*   They repeat these steps, alternating the withdrawal initiation every 10 blocks.\n*   One of the accounts is always in a valid withdrawal window (initiationBlock < block && block <= initiationBlock + 20). They can withdraw their funds at any time.\n\n",
                "Repair": "\nIf there's a withdrawal request for the token owner (_accountToWithdrawalRequest[owner].blockNumber  0), disable their transfers for the time.\n\nsolidity\n// pseudo-code not tested\nbeforeTransfer(from, to, amount) {\n  super();\n  uint256 withdrawalStart =  _accountToWithdrawalRequest[from].blockNumber;\n  if(withdrawalStart  0 && withdrawalStart + _delayedWithdrawalExpiry < block.number) {\n    revert(); // still in withdrawal window\n  }\n}\n\n\nramenforbreakfast (prePO) commented(https://github.com/code-423n4/2022-03-prepo-findings/issues/54#issuecomment-1075791543):\n  This is a valid claim.\n\ngzeon (judge) commented(https://github.com/code-423n4/2022-03-prepo-findings/issues/54#issuecomment-1086869763):\n  Agree with sponsor.\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]