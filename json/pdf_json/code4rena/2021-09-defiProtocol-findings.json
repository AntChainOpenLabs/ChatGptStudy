[
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24;\n    uint256 private constant BLOCK_DECREMENT = 10000;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    bool public override initialized;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(!initialized);\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basketAsERC20.transfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty memory bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\npragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Basket is IBasket, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {\n        return (pendingWeights.tokens, pendingWeights.weights);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        require(balanceOf(msg.sender) >= amount);\n\n        handleFees();\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction external override {\n        handleFees();\n\n        _burn(msg.sender, amount);\n\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees() private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else {\n            uint256 startSupply = totalSupply();\n\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0)) {\n            require(pendingPublisher.publisher == newPublisher);\n            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);\n            publisher = pendingPublisher.publisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.block = block.number;\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0) {\n            require(pendingLicenseFee.licenseFee == newLicenseFee);\n            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);\n            licenseFee = pendingLicenseFee.licenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.block = block.number;\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.block = block.number;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.block = block.number;\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(publisher);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).approve(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\n",
        "CodeNames": [
            "Auction.sol",
            "Basket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n// this is the safety check if basket still has all the tokens after removing arbitrary amounts\nfor (uint256 i = 0; i < pendingWeights.length; i++) {\n    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n    require(IERC20(pendingTokens[i]).balanceOf(address(basket)) = tokensNeeded);\n}\n",
                    "//solidity\n// a = 2 * ibRatio\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\n// b = (bondTimestamp auctionStart) * 1e14\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\n// newRatio = a b = 2 * ibRatio (bondTimestamp auctionStart) * 1e14\nuint256 newRatio = a b;\n",
                    "python\nnewRatio = a b = 2 * 1e18 (11000) * 1e14 = 2e18 1.1e18 = 0.9e18 < 1e18 = basket.ibRatio\n"
                ],
                "Type": " Re-entrancy in  settleAuction  allow stealing all funds",
                "Description": "\nNote that the Basket contract approved the Auction contract with all tokens and the settleAuction function allows the auction bonder to transfer all funds out of the basket to themselves.\nThe only limiting factor is the check afterwards that needs to be abided by. It checks if enough tokens are still in the basket after settlement:\n\nsolidity\n// this is the safety check if basket still has all the tokens after removing arbitrary amounts\nfor (uint256 i = 0; i < pendingWeights.length; i++) {\n    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n    require(IERC20(pendingTokens[i]).balanceOf(address(basket)) = tokensNeeded);\n}\n \n\nThe bonder can pass in any inputTokens, even malicious ones they created.\nThis allows them to re-enter the settleAuction multiple times for the same auction.\n\nCalling this function at the correct time (such that bondTimestamp auctionStart makes newRatio < basket.ibRatio()), the attacker can drain more funds each time, eventually draining the entire basket.\n\n\nAssume that the current basket.ibRatio is 1e18 (the initial value).\nThe basket publisher calls basket.publishNewIndex with some tokens and weights.\nFor simplicity, assume that the pending tokens are the same as tokens as before, only the weights are different, i.e., this would just rebalance the portfolio.\nThe function call then starts the auction.\n\nThe important step to note is that the tokensNeeded value in settleAuction determines how many tokens need to stay in the basket.\nIf we can continuously lower this value, we can keep removing tokens from the basket until it is empty.\n\nThe tokensNeeded variable is computed as basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE.\nThe only variable that changes in the computation when re-entering the function is newRatio (no basket tokens are burned, and the pending weights are never cleared).\n\nThus if we can show that newRatio decreases on each re-entrant call, we can move out more and more funds each time.\n\n\nAfter some time, the attacker calls bondForRebalance. This determines the bondTimestamp auctionStart value in settleAuction.\nThe attack is possible as soon as newRatio < basket.ibRatio().\nFor example, using the standard parameters the calculation would be:\n\nsolidity\n// a = 2 * ibRatio\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\n// b = (bondTimestamp auctionStart) * 1e14\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\n// newRatio = a b = 2 * ibRatio (bondTimestamp auctionStart) * 1e14\nuint256 newRatio = a b;\n\n\nWith our initial assumption of ibRatio = 1e18 and calling bondForRebalance after 11,000 seconds (~3 hours) we will get our result that newRatio is less than the initial ibRatio:\n\npython\nnewRatio = a b = 2 * 1e18 (11000) * 1e14 = 2e18 1.1e18 = 0.9e18 < 1e18 = basket.ibRatio\n\n\n This seems to be a reasonable value (when the pending tokens and weights are equal in value to the previous ones) as no other bonder would want to call this earlier such when newRatio  basket.ibRatio as they would put in more total value in tokens as they can take out of the basket.\n\n\nThe attacker creates a custom token attackerToken that re-enters the Auction.settleAuction function on transferFrom with parameters we will specify.\n\nThey call settleAuction with inputTokens = attackerToken] to re-enter several times.\n\nIn the inner-most call where newRatio = 0.9e18, they choose the inputTokens/outputTokens parameters in a way to pass the initial require(IERC20(pendingTokens[i]).balanceOf(address(basket)) = tokensNeeded); check transferring out any other tokens of basket with outputTokens.\n\nThe function will continue to run and call basket.setNewWeights(); and basket.updateIBRatio(newRatio); which will set the new weights (but not clear the pending ones) and set the new basket.ibRatio.\n\nExecution then jumps to the 2nd inner call after the IERC20(inputTokens[i]=attackerToken).safeTransferFrom(...) and has the chance to transfer out tokens again.\nIt will compute newRatio with the new lowered basket.ibRatio of 0.9e18: newRatio = a b = 2 * 0.9e18 1.1e18 = 0.7e18.\nTherefore, tokensNeeded is lowered as well and the attacker was allowed to transfer out more tokens having carefully chosen outputWeights.\n\nThis repeats with newRatio = 0.3.\n\nThe attack is quite complicated and requires carefully precomputing and then setting the parameters, as well as sending back the bondAmount tokens to the auction contract which are then each time transferred back in the function body.\nBut I believe this should work.\n\n\nThe basket funds can be stolen.\n\n",
                "Repair": "\nAdd re-entrancy checks (for example, OpenZeppelin's \"locks\") to the settleAuction function.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/223) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/223#issuecomment-997410663):\n  Let's dissect the finding to prove whether it's valid or not.\n \n First of all, we do have the pre-conditions for re-entrancy:\n Allows any token as input (untrusted input)\n No re-entrancy modifier\n Checks are performed at the beginning, transfers in the middle, and state changes at the end (violation of check effect interaction pattern)\n \n So in any case this is a report for reEntrancy (medium severity)\n \n However, the warden is showing a specific attack vector that, if proven, allows to steal the majority of funds from the basket.\n \n Let's investigate (with a single re-entrant call example):\n \n The require checks at the top pass, as we're rebalancing the basket, we'll make sure to use an additional inputToken (malicious token), that will call settleAuction again.\n \n This second call (Call B), will execute as normal, extracting the correct amount of value in return for rebalancing, the new ibRatio is 0.9 as shown by the warden POC.\n \n Call B ends by setting ibRatio to 0.9, and hasBonded to false (which will cause a revert if you try to perform this without re-entrancy)\n \n However, we have already entered and Call A can resume, it now has ibRatio set to 0.9 which allows it to further extract value (as tokensNeeded decreases as ibRatio decreases)\n \n This can be extended to have further re-entrant calls and can be effectively executed until the basket is hollowed out\n \n This is a Miro Board to highlight the dynamics of the exploit: https://miro.com/app/board/uXjVOZk4gxw=/?invite_link_id=246345621880\n \n Huge props to the warden, brilliant find!\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/223#issuecomment-997411166):\n  For mitigation:\n Adding a re-entrancy check would be the place to start\n Requiring the list of input tokens to match the output can also be useful to avoid any other shenanigans\n Setting the time difference (bondTimestamp, auctionStart) to be 0 would also negate the ability to further manipulate the ibRatio\n\n\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "ibRatio",
                    "_burn()",
                    "auctionBurn()",
                    "sol#auctionBurn()"
                ],
                "Type": "  Basket.sol#auctionBurn()  A failed auction will freeze part of the funds",
                "Description": "\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L102-L108\n\nGiven the auctionBurn() function will _burn() the auction bond without updating the ibRatio. Once the bond of a failed auction is burned, the proportional underlying tokens won't be able to be withdrawn, in other words, being frozen in the contract.\n\n\nWith the configuration of:\n\nbasket.ibRatio = 1e18\nfactory.bondPercentDiv = 400\nbasket.totalSupply = 400\nbasket.tokens = [BTC, ETH]\nbasket.weights = [1, 1]\n\n1.  Create an auction;\n2.  Bond with 1 BASKET TOKEN;\n3.  Wait for 24 hrs and call auctionBurn();\n\nbasket.ibRatio remains to be 1e18; basket.totalSupply = 399.\n\nBurn 1 BASKET TOKEN will only get back 1 BTC and 1 ETH, which means, there are 1 BTC and 1 ETH frozen in the contract.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction auctionBurn(uint256 amount) onlyAuction external override {\n    handleFees();\n    uint256 startSupply = totalSupply();\n    _burn(msg.sender, amount);\n\n    uint256 newIbRatio = ibRatio * startSupply / (startSupply amount);\n    ibRatio = newIbRatio;\n\n    emit NewIBRatio(newIbRatio);\n    emit Burned(msg.sender, amount);\n}\n\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/134)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/134#issuecomment-997303460):\n  The warden has identified a way for funds to be stuck without a way to recoup them, this is because ibRatio is not updated, while totalSupply is.\n \n Because this is a specific accounting error, which is effectively a bug in the logic of the protocol, and funds can be irrevocably lost, this is a high severity finding\n\n\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "settleAuction()",
                    "pendingWeights.pending = false",
                    "settleAuction",
                    "burn()",
                    "publishNewIndex()",
                    "transfer()",
                    "auctionOngoing = false",
                    "setNewWeights()",
                    "pendingWeights",
                    "withdrawBounty()"
                ],
                "Type": " Reentrancy in settleAuction(): malicious publisher can bypass index timelock mechanism, inject malicious index, and rug the basket",
                "Description": "\nThe settleAuction() function calls withdrawBounty() before setting auctionOngoing = false, thereby allowing reentrancy.\n\n\nA malicious publisher can bypass the index timelock mechanism and publish new index which the basket's users won't have time to respond to.\nAt worst case, this means setting weights that allow the publisher to withdraw all the basket's underlying funds for himself, under the guise of a valid new index.\n\n\n1.  The publisher (a contract) will propose new valid index and bond the auction.\n\n    To settle the auction, the publisher will execute the following steps in the same transaction:\n\n2. Add a bounty of an ERC20 contract with a malicious transfer() function.\n\n3. Settle the valid new weights correctly (using settleAuction() with the correct parameters, and passing the malicious bounty id).\n\n4. settleAuction() will call withdrawBounty() which upon transfer will call the publisher's malicious ERC20 contract.\n\n5. The contract will call settleAuction() again, with empty parameters. Since the previous call's effects have already set all the requirements to be met, settleAuction() will finish correctly and call setNewWeights() which will set the new valid weights and set pendingWeights.pending = false.\n\n6. Still inside the malicious ERC20 contract transfer function, the attacker will now call the basket's publishNewIndex(), with weights that will transfer all the funds to him upon his burning of shares. This call will succeed to set new pending weights as the previous step set pendingWeights.pending = false.\n\n7. Now the malicious withdrawBounty() has ended, and the original settleAuction() is resuming, but now with malicious weights in pendingWeights (set in step 6). settleAuction() will now call setNewWeights() which will set the basket's weights to be the malicious pending weights.\n\n8. Now settleAuction has finished, and the publisher (within the same transaction) will burn() all his shares of the basket, thereby transferring all the tokens to himself.\n\nPOC exploit:\nPassword to both files: \"exploit\".\nAttackPublisher.sol , to be put under contracts/contracts/Exploit: <https://pastebin.com/efHZjstS\nExploitPublisher.test.js , to be put under contracts/test: <https://pastebin.com/knBtcWkk\n\n\nManual analysis, hardhat.\n\n",
                "Repair": "\nIn settleAuction(), move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern.\n\nfrank-beard (defiProtocol) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/31) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/31#issuecomment-997413099):\n  This is a re-entrancy finding.\n \n There is no denying that the code is vulnerable to re-entrancy\n \n The warden identified the way to exploit re-entrancy by using a malicious bounty token.\n \n I think the finding is valid and the warden has shown how to run re-entrnacy.\n \n That said the POC the warden shows requires calling publishNewIndex which is a onlyPublisher function.\n This exploit would be contingent on the publisher rugging the basket.\n  \n The code is:\n Vulnerable to re-entancy\n The warden showed how to trigger it\n \n Despite the fact that the POC is flawed, I believe this finding highlights a different vector for re-entrancy (bounty token transfers) as such I agree with a high severity\n \n \n\n\n\n \n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "js\nit(\"should divide by 0\", async () = {\nawait basket.connect(addr1).burn(await basket.balanceOf(addr1.address));\nawait basket.connect(addr2).burn(await basket.balanceOf(addr2.address));\n\n    await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));\n    await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));\n    await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));\n    await basket.connect(addr1).mint(ethers.BigNumber.from(1));\n});\n"
                ],
                "Type": " Basket becomes unusable if everybody burns their shares",
                "Description": "\nWhile handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.\n\n\nIf everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.\n\n\nVulnerable line:\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124\nYou can add the following test to Basket.test.js and see that it reverts:\njs\nit(\"should divide by 0\", async () = {\nawait basket.connect(addr1).burn(await basket.balanceOf(addr1.address));\nawait basket.connect(addr2).burn(await basket.balanceOf(addr2.address));\n\n    await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));\n    await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));\n    await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));\n    await basket.connect(addr1).mint(ethers.BigNumber.from(1));\n});\n\n\n\nManual analysis, hardhat.\n\n",
                "Repair": "\nAdd a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees.\nYou might want to reset ibRatio to BASE at this point.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/64) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/64#issuecomment-997210497):\n  I feel like this can also happen right after the contract was created\n mintTo(https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L76) will call handleFees which will revert due to division by 0\n \n Finding is valid\n\n\n\n\n"
            },
            {
                "Name": "M-09",
                "Location": [
                    "BASE",
                    "feePct"
                ],
                "Type": " Fee calculation is potentially incorrect",
                "Description": "\n\nMore fees are actually charged than intended\n\n\nBasket.sol line 118(https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L118)\n\nAssume that license fee is 10% i.e. 1e17 and time diff = half a year.\n\nWhen you calculate feePct, you expect to get 5e16 since that's 5% and the actual amount of fee to be charged should be totalSupply * feePct (5) / BASE (100) but on line 118, we are actually dividing by BASE feePct i.e. 95.\n\n5 / 95 = 0.052 instead of the intended 0.05.\n\nSolution is to replace BASE feePct in the denominator with BASE.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/129)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/129#issuecomment-997228019):\n  The warden identified an inconsistency with the math that charged more fees than intended\n\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-14",
                "Location": [
                    "//solidity\nfunction handleFees() private {\n    if (lastFee == 0) {\n        lastFee = block.timestamp;\n    } else {\n        uint256 startSupply = totalSupply();\n\n        uint256 timeDiff = (block.timestamp lastFee);\n        uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n        uint256 fee = startSupply * feePct / (BASE feePct);\n\n        _mint(publisher, fee * (BASE factory.ownerSplit()) / BASE);\n        _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n        lastFee = block.timestamp;\n\n        uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(ibRatio);\n    }\n}\n"
                ],
                "Type": "  Basket.sol#handleFees()  could potentially cause disruption of minting and burning",
                "Description": "\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110-L129\n\nsolidity\nfunction handleFees() private {\n    if (lastFee == 0) {\n        lastFee = block.timestamp;\n    } else {\n        uint256 startSupply = totalSupply();\n\n        uint256 timeDiff = (block.timestamp lastFee);\n        uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n        uint256 fee = startSupply * feePct / (BASE feePct);\n\n        _mint(publisher, fee * (BASE factory.ownerSplit()) / BASE);\n        _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n        lastFee = block.timestamp;\n\n        uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(ibRatio);\n    }\n}\n\n\ntimeDiff * licenseFee can be greater than ONE_YEAR when timeDiff and/or licenseFee is large enough, which makes feePct to be greater than BASE so that BASE feePct will revert on underflow.\n\n\nMinting and burning of the basket token are being disrupted until the publisher update the licenseFee.\n\n\n1.  Create a basket with a licenseFee of 1e19 or 1000% per year and mint 1 basket token;\n2.  The basket remain inactive (not being minted or burned) for 2 months;\n3.  Calling mint and burn reverts at handleFees().\n\n",
                "Repair": "\nLimit the max value of feePct.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/79)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/79#issuecomment-997304574):\n  The finding is valid, there are conditions that would cause feePct to be greater than BASE\n \n The conditions to trigger this seem to be: \n Wait enough time\n Have a high enough fee\n \n Because this can happen under specific conditions, I will grade this finding as medium severity:\n \n I would highly recommend the sponsor to consider the possibility of capping the licenseFee to make it easier to predict cases in which the operation can revert\n\n\n\n\n"
            },
            {
                "Name": "M-18",
                "Location": [
                    "BASE",
                    "feePct",
                    "changeLicenseFee",
                    "handleFees()"
                ],
                "Type": " licenseFee can be greater than BASE",
                "Description": "\n\nWorst case no functions that contains handleFees() can pass because line 118(https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L118) will always underflow and revert. You only need feePct to be bigger than BASE for the handleFees() function to fail which will result in a lot of gas wasted and potentially bond burnt.\n\nI did not classify this as high risk because a simple fix would be to simply reduce the licenseFee via changeLicenseFee.\n\n",
                "Repair": "\nAdd these require statement to the following functions:\n\n*   Basket.changeLicenseFee()\n    *   require(newLicenseFee <= BASE, \"changeLicenseFee: license fee cannot be greater than 100%\");\n*   Factory.proposeBasketLicense()\n    *   require(licenseFee <= BASE, \"proposeBasketLicense: license fee cannot be greater than 100%\");\n\nfrank-beard (Kuiper) acknowledged(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/104) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/104#issuecomment-997467988):\n  Agree with the finding, the warden highlighted an admin exploit that allows to DOS the basket.\n Adding a check not only prevents the exploit, but gives a security guarantee to the protocol users\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24;\n    uint256 private constant BLOCK_DECREMENT = 10000;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    bool public override initialized;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(!initialized);\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basketAsERC20.transfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty memory bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\n",
        "CodeNames": [
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "transfer()",
                    "safeTransfer()"
                ],
                "Type": " Use safeTransfer instead of transfer",
                "Description": "\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L146\n\ntransfer() might return false instead of reverting, in this case, ignoring return value leads to considering it successful.\n\nuse safeTransfer() or check the return value if length of returned data is  0.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/196) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/196#issuecomment-983125327):\n  Agree with finding, agree with severity given the specific example given as the funds would be stuck in the contract\n\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-07",
                "Location": [
                    "//solidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a b;\n"
                ],
                "Type": " No minimum rate in the auction may break the protocol under network failure",
                "Description": "\n\nThe aution contract decides a new ibRatio in the function settleAuction. Auction.sol#L89-L91(https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)\n\nsolidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a b;\n\n\nThere's a chance that newRatio would be really close to zero. This imposes too much risk on the protocol. The network may not really be healthy all the time. Solana and Arbitrum were down and Ethereum was suffered a forking issue recently. Also, the network may be jammed from time to time. This could cause huge damage to a protocol. Please refer to Black Thursday for makerdao 8.32 million was liquidated for 0 dai(https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6)\n\nGiven the chance that all user may lose their money, I consider this is a medium-risk issue.\n\n\nBlack Thursfay for makerdao 8.32 million was liquidated for 0 dai(https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6)\nbug-impacting-over-50-of-ethereum-clients-leads-to-fork(https://www.theblockcrypto.com/post/115822/bug-impacting-over-50-of-ethereum-clients-leads-to-fork)\n\n\nNone\n\n",
                "Repair": "\nI recommend setting a minimum ibRatio when a publisher publishes a new index. The auction should be killed if the ibRatio is too low.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/42)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/42#issuecomment-997215459):\n  Agree that newRatio decreases over time, if nothing is done it will eventually get close to 0, at which point tokensNeeded will tend to 0, which would mean that the amount of underlying necessary to redeem the bond decreases over time\n \n This can hypothetically allow to redeem the bond for extremely cheap if not for free\n \n The bond is denominated in the basketToken which effectively represents the value of the \"mixture\" of the tokens\n \n Over time, you're getting the same bond (basket) for less tokens (tokensNeeded), which also means that the basket itself is loosing value (because you can extra the excess value via bonding)\n \n Sounds to me like the entire settleAuction mechanism is devaluing the basket over time which arguably is a high severity vulnerability.\n \n Will continue the judging and may end up getting in touch with the sponsor over some additional risks.\n \n The finding is valid because it shows that the protocol can break given a specific circumstance, I do believe the warden could have found a higher severity by digging deeper\n\n\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [
                    "//solidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a b;\n",
                    "python\nbasket.functions.publishNewIndex([dai.address], deposit_amount]).transact()\n\nfor i in range(4 * 60 * 24):\n    w3.provider.make_request('evm_mine', ])\nbasket.functions.publishNewIndex([dai.address], deposit_amount]).transact()\n\nprint('auction on going', auction.functions.auctionOngoing().call())\nfor i in range(20000):\n    w3.provider.make_request('evm_mine', ])\n\nall_token = basket.functions.balanceOf(user).call()\nbasket.functions.approve(auction.address, all_token).transact()\nauction.functions.bondForRebalance().transact()\n# error Log\n# {'code': -32603, 'message': 'Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'}\nauction.functions.settleAuction([], ], ], ], ]).transact()\n"
                ],
                "Type": "  settleAuction may be impossible if locked at a wrong time.",
                "Description": "\n\nThe auction contract decides a new ibRatio in the function settleAuction. Auction.sol#L89-L91(https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)\n\nsolidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a b;\n\n\nIn this equation, a would not always be greater than b. The   auctionBonder  may lock the token in bondForRebalance() at a point that a-b would always revert.\n\nThe contract should not allow users to lock the token at the point that not gonna succeed. Given the possible (huge) loss of the user may suffer, I consider this is a medium-risk issue.\n\n\nHere's a web3.py script to trigger this bug.\n\npython\nbasket.functions.publishNewIndex([dai.address], deposit_amount]).transact()\n\nfor i in range(4 * 60 * 24):\n    w3.provider.make_request('evm_mine', ])\nbasket.functions.publishNewIndex([dai.address], deposit_amount]).transact()\n\nprint('auction on going', auction.functions.auctionOngoing().call())\nfor i in range(20000):\n    w3.provider.make_request('evm_mine', ])\n\nall_token = basket.functions.balanceOf(user).call()\nbasket.functions.approve(auction.address, all_token).transact()\nauction.functions.bondForRebalance().transact()\n# error Log\n# {'code': -32603, 'message': 'Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'}\nauction.functions.settleAuction([], ], ], ], ]).transact()\n\n\n\nNone\n\n",
                "Repair": "\nRecommend to calculate the new irate in bondForRebalance. I understand the auctionBonder should take the risk to get the profit. However, the contract should protect the user in the first place when this auction is doomed to fail.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/41)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/41#issuecomment-997222428):\n  I do not believe the users are at risk of a specific loss as they can always redeem their shares for underlying Basket.burn\n However, this is still a valid finding, and the external conditions make medium severity appropriate\n\n\n\n\n"
            },
            {
                "Name": "M-11",
                "Location": [
                    "auctionMultiplier",
                    "tokensNeeded",
                    "auctionDecrement",
                    "newRatio"
                ],
                "Type": " Owner can steal all Basket funds during auction",
                "Description": "\n\nThe owner of Factory contract can modify the values of auctionMultiplier and auctionDecrement at any time.\nDuring an auction, these values are used to calculate newRatio and thereby tokensNeeded: specifically, it's easy to set the factory parameters so that tokensNeeded = 0 (or close to zero) for every token.\nThis way the owner can participate at an auction, change the parameters, and get the underlying tokens from a Basket without transferring any pending tokens.\n\n\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L99\n\n\neditor\n\n",
                "Repair": "\nConsider adding a Timelock to these Factory functions. Otherwise a way to not modify them if an auction is ongoing (maybe Auction saves the values it reads when startAuction is called).\n\nfrank-beard (Kuiper) confirmed and disagreed with severity(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/265#issuecomment-929613048):\n  the owner for this is intended to be a dao that acts in support of the protocol, however this is a good point to the centralization concerns for the protocol, we will most likely manage this by adding a timelock to these function\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/265#issuecomment-997302120):\n  Agree with the finding from the warden, highly recommend the sponsor to add these possibilities in their docs to make it easy for users to understand them.\n \n That said, a possible remediation would also be to add checks in the setters, to avoid for these specific edge cases.\n \n Because the exploit is dependent on an external condition (setting to a specific value by governance), the finding is of medium severity\n\n\n\n\n"
            },
            {
                "Name": "M-15",
                "Location": [
                    "//solidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a b;\n"
                ],
                "Type": "  Auction.sol#settleAuction()  late auction bond could potentially not being able to be settled, cause funds loss to bonder",
                "Description": "\nThe newRatio that determines tokensNeeded to settle the auction is calculated based on auctionMultiplier, bondTimestamp auctionStart and auctionDecrement.\n\nsolidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a b;\n\n\nHowever, if an auction is bonded late (bondTimestamp auctionStart is a large number), and/or the auctionMultiplier is small enough, and/or the auctionDecrement is small enough, that makes b to be greater than a, so that uint256 newRatio = a b; will revert on underflow.\n\nThis might seem to be an edge case issue, but considering that a rebalance auction of a bag of shitcoin to high-value tokens might just end up being bonded at the last minute, with a newRatio near zero. When we take the time between the bonder submits the transaction and it got packed into a block, it's quite possible that the final bondTimestamp gets large enough to revet a b.\n\n\nAn auction successfully bonded by a regular user won't be able to be settled, and the user will lose the bond.\n\n\nWith the configuration of:\n\nbasket.ibRatio = 1e18\nfactory.auctionDecrement = 5760 (Blocks per day)\nfactory.auctionMultiplier = 2\n\n1.  Create an auction;\n2.  The auction remain inactive (not get bonded) for more than 2 days (11,520 blocks);\n3.  Call bondForRebalance() and it will succeed;\n4.  Calling settleAuction() will always revert.\n\n",
                "Repair": "\nCalculate and require newRatio  0 in bondForRebalance(), or limit the max value of decrement and make sure newRatio always  0 in settleAuction().\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/90)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/90#issuecomment-997305014):\n  Finding is valid, there are cases that can cause a b to revert\n \n The finding is reliant on external condition (multiplier being low and / or bonding late) as such I believe this to be a medium severity finding.\n \n Note for the sponsor: The cause for reverts should get clearer with time (as people use the protocol), you definitely want to model these revert behaviour to avoid edge cases that will make funds stuck\n\n\n\n\n"
            },
            {
                "Name": "M-16",
                "Location": [
                    "//solidity\nfunction withdrawBounty(uint256[] memory bountyIds) internal {\n    // withdraw bounties\n    for (uint256 i = 0; i < bountyIds.length; i++) {\n        Bounty memory bounty = _bounties[bountyIds[i]];\n        require(bounty.active);\n\n        IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n        bounty.active = false;\n\n        emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n    }\n}\n"
                ],
                "Type": "  Auction.sol#settleAuction()  Mishandling bounty state could potentially disrupt  settleAuction() ",
                "Description": "\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L143\n\nsolidity\nfunction withdrawBounty(uint256[] memory bountyIds) internal {\n    // withdraw bounties\n    for (uint256 i = 0; i < bountyIds.length; i++) {\n        Bounty memory bounty = _bounties[bountyIds[i]];\n        require(bounty.active);\n\n        IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n        bounty.active = false;\n\n        emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n    }\n}\n\n\nIn the withdrawBounty function, bounty.active should be set to false when the bounty is claimed.\n\nHowever, since bounty is stored in memory, the state update will not succeed.\n\n\nAn auction successfully bonded by a regular user won't be able to be settled if they passed seemly active bountyIds, and the bonder will lose the bond.\n\n\n1.  Create an auction;\n2.  Add a bounty;\n3.  Auction settled with bounty claimed;\n4.  Create a new auction;\n5.  Add a new bounty;\n6.  Calling settleAuction() with the bountyIds of the 2 seemly active bounties always reverts.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nBounty storage bounty = _bounties[bountyIds[i]];\n\n\nfrank-beard (Kuiper) confirmed and marked as duplicate(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/136#issuecomment-936623596):\n  duplicate of https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/168\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/136#issuecomment-997414434):\n  Finding is valid, because the warden didn't provide a POC of how to steal user funds, the finding is of medium severity\n\n\n\n\n"
            },
            {
                "Name": "M-17",
                "Location": [
                    "python\nusdt.functions.approve(basket.address, 100).transact()\n## the second tx would be reverted as the allowance is not zero\nusdt.functions.approve(basket.address, 50).transact()\n"
                ],
                "Type": " Unsafe approve would halt the auction and burn the bond",
                "Description": "\n\nBasket.sol#L224-L228(https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L224-L228) calls approve that do not handle non-standard erc20 behavior.\n\n1.  Some token contracts do not return any value.\n2.  Some token contracts revert the transaction when the allowance is not zero.\n\nSince the auction contract calls setNewWeights in function settleAuction, auctionBonder may lock its bond and never successfully settles the auction. This leads to the auctionBonder loss he's bond and the basket and the auction becomes suspended.\n\nauctionBonder would lose his bond and the contract would be suspended. I consider this a high-risk issue.\n\n\nUSDT may be a classic non-standard erc20 token.\n\nHere's a short POC.\n\npython\nusdt.functions.approve(basket.address, 100).transact()\n## the second tx would be reverted as the allowance is not zero\nusdt.functions.approve(basket.address, 50).transact()\n\n\n\nNone\n\n",
                "Repair": "\nRecommend to use safeApprove instead and set the allowance to 0 before calling it.\n\nsolidity\nfunction approveUnderlying(address spender) private {\n    for (uint256 i = 0; i < weights.length; i++) {\n        IERC20(tokens[i]).safeApprove(spender, 0);\n        IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n    }\n}\n\n\nfrank-beard (Kuiper) marked as duplicate(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/35#issuecomment-929652005):\n  duplicate of https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/260\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/35#issuecomment-997415208):\n  Agree with the finding, because this is contingent on an external condition (token being USDT) the finding is of medium severity\n\n\n\n\n"
            },
            {
                "Name": "M-19",
                "Location": [
                    "bondForRebalance()",
                    "settleAuction()"
                ],
                "Type": " Scoop ERC20 tokens from basket contract",
                "Description": "\n\nSuppose some unrelated ERC20 tokens end up in the basket contract  (via an airdrop, a user mistake etc)\n\nThen anyone can do a bondForRebalance() and settleAuction() to scoop these tokens.\n\nThe function settleAuction() allows you to specify an outputToken, so also completely unrelated tokens.\nThus you can retrieve additional tokens with  settleAuction()\n\n\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69\nfunction settleAuction(..  address[] memory outputTokens, uint256[] memory outputWeights) public override {\n...\nfor (uint256 i = 0; i < outputTokens.length; i++) {\nIERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n}\n\n",
                "Repair": "\nCheck outputTokens are part of the previous basket tokens  (e.g. basket.tokens() )\n\nfrank-beard (Kuiper) acknowledged(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/56) \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/56#issuecomment-997468442):\n  If the Auction contract has any ERC20 that is not checked against the require, those tokens can be taken away for free.\n The warden didn't directly mention this, but this can also apply to bounties.\n Any bounty specified in a token that is not protected can be taken without claiming the bounty (as the require won't check for it)\n \n I think that the finding has appropriate severity, although the warden didn't directly mention the ability to steal bounties\n\n\n\n\n"
            },
            {
                "Name": "M-20",
                "Location": [
                    "//solidity\nfunction setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {\n    auctionMultiplier = newAuctionMultiplier;\n}\n",
                    "//solidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\n    uint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\n    uint256 newRatio = a b;\n"
                ],
                "Type": " Auction multiplier set to zero",
                "Description": "\nsolidity\nfunction setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {\n    auctionMultiplier = newAuctionMultiplier;\n}\n\n\nauction multiplier can be set to zero by factory owner. This would stop the auction settling, function would always revert.\nsolidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\n    uint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\n    uint256 newRatio = a b;\n\n\ncausing a safe math error and newRatio to revert.\n\n\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.\n\n",
                "Repair": "\nfrank-beard (Kuiper) acknowledged and disagreed with severity(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/242#issuecomment-931568844):\n  it is assumed the owner is trustworthy in this version of the protocol, however we will add mitigations and further decentralization in future updates\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/242#issuecomment-997469832):\n  Agree with the finding, because the warden showed a specific \"admin privilege\" that DOSses the protocol, the finding is valid and of medium severity\n\n\n\n\n"
            },
            {
                "Name": "M-22",
                "Location": [
                    "auctionBonder",
                    "withdrawBounty()",
                    "_bounties"
                ],
                "Type": " Incorrect data location specifier can be abused to cause DoS and fund loss",
                "Description": "\n\nThe withdrawBounty() loops through the _bounties array looking for active bounties and transferring amounts from active ones. However, the data location specifier used for bounty is memory which makes a copy of the _bounties array member instead of a reference. So when bounty.active is set to false, this is changing only the memory copy and not the array element of the storage variable. This results in bounties never being set to inactive, keeping them always active forever and every withdrawBounty() will attempt to transfer bounty amount from the Auction contract to the msg.sender.\n\nTherefore, while the transfer will work the first time, subsequent attempts to claim this bounty will revert on transfer (because the Auction contract will not have required amount of bounty tokens) causing withdrawBounty() to always revert and therefore preventing settling of any auction.\n\nA malicious attacker can add a tiny bounty on any/every Auction contract to prevent any reindexing on that contract to happen because it will always revert on auction settling. This can be used to cause DoS on any auctionBonder so as to make them lose their bondAmount because their bonded auction cannot be settled.\n\n\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143\n\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143-L147\n\n<https://docs.soliditylang.org/en/v0.8.7/types.html#data-location-and-assignment-behaviour\n\n\nManual Analysis\n\n",
                "Repair": "\nRecommend changing storage specifier of bounty to \"storage\" instead of \u201cmemory\".\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/168)  \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/168#issuecomment-997414247):\n  Great find, adding the same bounty multiple times can allow the exploiter to drain the entire contract as long as the bounties are denominated in the underlying token\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/168#issuecomment-999137782):\n  Because the warden shows a way to cause DOS, which is contingent on setting it as well as redeeming that bounty (which can be avoided by simply not adding it to the bountiesID calldata), I will rate this finding as Medium Severity\n \n The DOS is low severity as it can be sidestep very easily, see #82 \n \n However, the warden has identified a technical issue with the protocol (unflagging of bounty), as such I agree with a medium severity\n\n\n\n\n"
            },
            {
                "Name": "M-23",
                "Location": [
                    "//solidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a b;\n\nfor (uint256 i = 0; i < pendingWeights.length; i++) {\n    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n    require(IERC20(pendingTokens[i]).balanceOf(address(basket)) = tokensNeeded);\n}\n"
                ],
                "Type": " Auction settler can steal user funds if bond timestamp is high enough",
                "Description": "\nAfter an auction has started, as time passes and according to the bondTimestamp, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket.\nThis is not capped, and after a while, newRatio can become smaller than current ibRatio.\n\n\nIf for some reason nobody has settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.\n\n\nThese are the vulnerable lines:\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L89:#L99\n\nsolidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondTimestamp auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a b;\n\nfor (uint256 i = 0; i < pendingWeights.length; i++) {\n    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n    require(IERC20(pendingTokens[i]).balanceOf(address(basket)) = tokensNeeded);\n}\n\n\nThe function verifies that pendingTokens[i].balanceOf(basket) = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE. This is the formula that will be used later to mint/burn/withdraw user funds.\nAs bondTimestamp increases, newRatio will get smaller, and there is no check on this.\nAfter a while we'll arrive at a point where newRatio ~= 0, so tokensNeeded = newRatio*(...) ~= 0, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.\n\n\nManual analysis, hardhat.\n\n",
                "Repair": "\nYour needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction:\n\n    require (newRatio  basket.ibRatio());\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/45)  \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/45#issuecomment-997472588):\n  Would need confirmation from the sponsor here (this finding was also submitted on the more recent contest)\n As discount is part of the protocol (I think)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/45#issuecomment-997499754):\n  @frank-beard is the discount a feature or a bug?\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/45#issuecomment-1001265126):\n  As per this discussion: https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/51\n \n The finding is valid and of medium severity\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24;\n    uint256 private constant BLOCK_DECREMENT = 10000;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    bool public override initialized;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(!initialized);\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basketAsERC20.transfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty memory bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\npragma solidity =0.8.7;\n\nimport \"hardhat/console.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\n\ncontract Factory is IFactory, Ownable {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n\n    constructor (IAuction _auctionImpl, IBasket _basketImpl) {\n        auctionImpl = _auctionImpl;\n        basketImpl = _basketImpl;\n        ownerSplit = 0;\n    }\n\n    Proposal[] private _proposals;\n\n    IAuction public override auctionImpl;\n    IBasket public override basketImpl;\n\n    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%\n    uint256 public override auctionDecrement = 10000;\n    uint256 public override auctionMultiplier = 2;\n    uint256 public override bondPercentDiv = 400;\n    uint256 public override ownerSplit;\n\n    function proposal(uint256 proposalId) external override view returns (Proposal memory) {\n        return _proposals[proposalId];\n    }\n\n    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {\n        minLicenseFee = newMinLicenseFee;\n    }\n\n    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {\n        auctionDecrement = newAuctionDecrement;\n    }\n\n    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {\n        auctionMultiplier = newAuctionMultiplier;\n    }\n\n    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {\n        bondPercentDiv = newBondPercentDiv;\n    }\n\n    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {\n        require(newOwnerSplit <= 2e17); // 20%\n\n        ownerSplit = newOwnerSplit;\n    }\n\n    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {\n        return (_proposals[id].tokens, _proposals[id].weights);\n    }\n\n    function proposeBasketLicense(\n        uint256 licenseFee, \n        string memory tokenName, \n        string memory tokenSymbol, \n        address[] memory tokens,\n        uint256[] memory weights\n    ) public override returns (uint256 id) {\n        basketImpl.validateWeights(tokens, weights);\n\n        require(licenseFee >= minLicenseFee);\n\n        // create proposal object\n        Proposal memory proposal = Proposal({\n            licenseFee: licenseFee,\n            tokenName: tokenName,\n            tokenSymbol: tokenSymbol,\n            proposer: address(msg.sender),\n            tokens: tokens,\n            weights: weights,\n            basket: address(0)\n        });\n\n        emit BasketLicenseProposed(msg.sender, tokenName);\n        _proposals.push(proposal);\n\n        return _proposals.length - 1;\n    }\n\n    function createBasket(uint256 idNumber) external override returns (IBasket) {\n        Proposal memory bProposal = _proposals[idNumber];\n        require(bProposal.basket == address(0));\n\n        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));\n        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));\n\n        newAuction.initialize(address(newBasket), address(this));\n        newBasket.initialize(bProposal, newAuction);\n\n        for (uint256 i = 0; i < bProposal.weights.length; i++) {\n            IERC20 token = IERC20(bProposal.tokens[i]);\n            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n            token.safeApprove(address(newBasket), bProposal.weights[i]);\n        }\n\n        newBasket.mintTo(BASE, msg.sender);\n\n        _proposals[idNumber].basket = address(newBasket);\n\n        emit BasketCreated(address(newBasket));\n\n        return newBasket;\n    }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol",
            "Factory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nfunction createBasket(uint256 idNumber) external override returns (IBasket) {\n    // ...\n    for (uint256 i = 0; i < bProposal.weights.length; i++) {\n        IERC20 token = IERC20(bProposal.tokens[i]);\n        token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n        token.safeApprove(address(newBasket), bProposal.weights[i]);\n    }\n    // ...\n}\n"
                ],
                "Type": " Fee on transfer tokens can lead to incorrect approval",
                "Description": "\n\nThe\ncreateBasket(https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L106)\nfunction does not account for tokens with fee on transfer.\n\nsolidity\nfunction createBasket(uint256 idNumber) external override returns (IBasket) {\n    // ...\n    for (uint256 i = 0; i < bProposal.weights.length; i++) {\n        IERC20 token = IERC20(bProposal.tokens[i]);\n        token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n        token.safeApprove(address(newBasket), bProposal.weights[i]);\n    }\n    // ...\n}\n\n\nThe function safeTransferFrom may not transfer exactly\nbProposal.weights[i] amount of tokens, for tokens with a fee on\ntransfer. This means that the safeApprove call in the next line would\nbe approving more tokens than what was received, leading to accounting\nissues.\n\n",
                "Repair": "\nIt is recommended to find the balance of the current contract before and\nafter the transferFrom to see how much tokens were received, and\napprove only what was received.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/236#issuecomment-946911439):\n  the protocol for now is only expected to work with defi safe, standard erc-20 tokens. \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/236#issuecomment-984191431):\n  This finding is similar to #206 , but in contrast to it, it shows a specific way to brick / grief the protocol, as per the docs:\n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n This is an hypothetical attack with stated assumptions\n \n Will not mark as duplicate and will consider this as a valid finding as it shows a specific vulnerability when paired with feeOnTransfer tokens\n \n Mitigation can be as simple as never using feeOnTransfer tokens\n\n\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "auctionMultiplier",
                    "auctionDecrement",
                    "settleAuction()",
                    "onlyOwner"
                ],
                "Type": "  onlyOwner  Role Can Unintentionally Influence  settleAuction() ",
                "Description": "\n\nThe onlyOwner role is able to make changes to the protocol with an immediate affect, while other changes made in Basket.sol and Auction.sol incur a one day timelock. As a result, an onlyOwner role may unintentionally frontrun a settleAuction() transaction by making changes to auctionDecrement and auctionMultiplier, potentially causing the auction bonder to over compensate during a rebalance. Additionally, there is no way for an auction bonder to recover their tokens in the event this does happen.\n\n\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L39-L59\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L99\n\n\nManual code review\n\n",
                "Repair": "\nConsider adding a timelock delay to all functions affecting protocol execution. Alternatively, bondForRebalance() can set state variables for any external calls made to Factory.sol (i.e. factory.auctionMultiplier() and factory.auctionDecrement()), ensuring that settleAuction() is called according to these expected results.\n\nfrank-beard (Kuiper) acknowledged(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/192#issuecomment-931571215):\n  it is assumed the owner is trustworthy in this version of the protocol, however we will add mitigations and further decentralization in future updates\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/192#issuecomment-997205975):\n  Agree with the finding, users are taking \"owner privileges\" risks while interacting with the protocol.\n The warden has identified a specific grief / DOS that the owner can cause\n\n\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "bondPercentDiv",
                    "setBondPercentDiv"
                ],
                "Type": " lack of checks in  Factory::setBondPercentDiv  allow owner to prevent bonding in Auction::bondForRebalance()",
                "Description": "\n\nsetBondPercentDiv has no checks for min and max\n\nSetting bondPercentDiv to 0 will cause Auction::bondForRebalance() to revert\n\nThis allows the owner to prevent bonding by setting the bondPercentDiv to 0\n\n",
                "Repair": "\nRefactor to\n\nsolidity\nfunction setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {\n    require(newBondPercentDiv  AMOUNT);\n    require(newBondPercentDiv <= AMOUNT_2);\n    bondPercentDiv = newBondPercentDiv;\n}\n\n\nfrank-beard (Kuiper) acknowledged and disagreed with severity(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/121#issuecomment-929647297):\n  the owner for this is intended to be a dao that acts in support of the protocol, however this is a good point to the centralization concerns for the protocol, we will most likely manage this by adding a timelock to these function\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/121#issuecomment-997302531):\n  Similarly to #119 \n Am forfeiting my wins\n Always important to flag up admin privileges so people can use the protocol while being aware of the risks they are undertaking\n Medium severity as depends on a specific config\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Basket is IBasket, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {\n        return (pendingWeights.tokens, pendingWeights.weights);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        require(balanceOf(msg.sender) >= amount);\n\n        handleFees();\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction external override {\n        handleFees();\n\n        _burn(msg.sender, amount);\n\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees() private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else {\n            uint256 startSupply = totalSupply();\n\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0)) {\n            require(pendingPublisher.publisher == newPublisher);\n            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);\n            publisher = pendingPublisher.publisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.block = block.number;\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0) {\n            require(pendingLicenseFee.licenseFee == newLicenseFee);\n            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);\n            licenseFee = pendingLicenseFee.licenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.block = block.number;\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.block = block.number;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.block = block.number;\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(publisher);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).approve(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\n",
        "CodeNames": [
            "Basket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "js\nit(\"should give to user more than he deserves\", async () = {\n    await UNI.connect(owner).mint(ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));\n    await COMP.connect(owner).mint(ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));\n    await AAVE.connect(owner).mint(ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));\n\n    await UNI.connect(owner).approve(basket.address, ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));\n    await COMP.connect(owner).approve(basket.address, ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));\n    await AAVE.connect(owner).approve(basket.address, ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));\n\n    console.log(\"User balance before minting:\");\n    console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());\n    console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());\n    console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());\n\n    \n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n\n    console.log(\"nUser balance after minting 1 share 5 times:\");\n    console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());\n    console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());\n    console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());\n\n    await basket.connect(owner).burn(await basket.balanceOf(owner.address));\n    console.log(\"nUser balance after burning all shares:\");\n    console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());\n    console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());\n    console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());\n});\n"
                ],
                "Type": " User can mint miniscule amount of shares, later withdraw miniscule more than deposited",
                "Description": "\nIf a user is minting small amount of shares (like 1 amount depends on baskets weights), the calculated amount of tokens to pull from the user can be less than 1, and therefore no tokens will be pulled. However the shares would still be minted.\nIf the user does this a few times, he could then withdraw the total minted shares and end up with more tokens than he started with although a miniscule amount.\n\n\nUser can end up with more tokens than he started with. However, I didn't find a way for the user to get an amount to make this a feasible attack. He gets dust. However he can still get more than he deserves. If for some reason the basket weights grow in a substantial amount, this could give the user more tokens that he didn't pay for.\n\n\nAdd the following test to Basket.test.js.\nThe user starts with 5e18 UNI, 1e18 COMP, 1e18 AAVE,\nand ends with 5e18+4, 1e18+4, 1e18+4.\njs\nit(\"should give to user more than he deserves\", async () = {\n    await UNI.connect(owner).mint(ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));\n    await COMP.connect(owner).mint(ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));\n    await AAVE.connect(owner).mint(ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));\n\n    await UNI.connect(owner).approve(basket.address, ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));\n    await COMP.connect(owner).approve(basket.address, ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));\n    await AAVE.connect(owner).approve(basket.address, ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));\n\n    console.log(\"User balance before minting:\");\n    console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());\n    console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());\n    console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());\n\n    \n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n    await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));\n\n    console.log(\"nUser balance after minting 1 share 5 times:\");\n    console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());\n    console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());\n    console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());\n\n    await basket.connect(owner).burn(await basket.balanceOf(owner.address));\n    console.log(\"nUser balance after burning all shares:\");\n    console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());\n    console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());\n    console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());\n});\n\n\n\nManual analysis, hardhat.\n\n",
                "Repair": "\nAdd a check to pullUnderlying:\nsolidity\nrequire(tokenAmount  0);\n\n\nI think it makes sense that if a user is trying to mint an amount so small that no tokens could be pulled from him, the mint request should be denied.\nPer my tests, for an initial ibRatio, this number (the minimal amount of shares that can be minted) is 2 for weights in magnitude of 1e18, and if the weights are eg. smaller by 100, this number will be 101.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/81)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/81#issuecomment-997206834):\n  Great find, because this finding shows a clear POC of how to extract value from the system, I agree with medium severity\n\n\n\n\n"
            },
            {
                "Name": "M-10",
                "Location": [
                    "burn",
                    "mintTo"
                ],
                "Type": "  burn  and  mintTo  in  Basket.sol  vulnerable to reentrancy",
                "Description": "\n\nThe functions mintTo(https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L82)\nand burn(https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L96) make external calls prior to updating the state. If a basket contains an ERC777 token, attackers can mint free basket tokens.\n\n\nAn attacker could reenter the mintTo function when the contract pulls an ERC777 token from the user and mint more tokens than they deposited.\n\n\nSlither\n\n",
                "Repair": "\nMove external calls after state updates. It is best practice to make external calls after updating state in accordance with the check-effect-interact pattern.\n\nfrank-beard (Kuiper) acknowledged(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/248#issuecomment-929628079):\n  For now we are only concerned with 'Defi Safe' tokens that conform to the erc-20 standard. It is expected that publishers and users should do due diligence when adding assets to a basket\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/248#issuecomment-997301870):\n  I agree with the warden finding that the function can be subject to re-entrancy.\n \n Because the exploit is dependent on the token of choice, this is not a guarantee but rather the possibility of the system being vulnerable.\n \n I highly recommend the sponsor to add re-entrancy checks.\n \n As for the finding, because it is conditional on using a vulnerable token, I'll downgrade to medium severity as it requires an external condition for the re-entrance to be possible\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/248#issuecomment-1001268732):\n  After re-review I agree with medium severity on reentrancy findings on burn and mint, in contract with the \"generic\" re-entrancy finding with the additional bounties that lack any poc.\n \n The findings with specific poc have been rated as separate findings (some of which have high risk) as they show an actual way to exploit the protocol\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24;\n    uint256 private constant BLOCK_DECREMENT = 10000;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    bool public override initialized;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(!initialized);\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basketAsERC20.transfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty memory bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\npragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Basket is IBasket, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {\n        return (pendingWeights.tokens, pendingWeights.weights);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        require(balanceOf(msg.sender) >= amount);\n\n        handleFees();\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction external override {\n        handleFees();\n\n        _burn(msg.sender, amount);\n\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees() private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else {\n            uint256 startSupply = totalSupply();\n\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0)) {\n            require(pendingPublisher.publisher == newPublisher);\n            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);\n            publisher = pendingPublisher.publisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.block = block.number;\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0) {\n            require(pendingLicenseFee.licenseFee == newLicenseFee);\n            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);\n            licenseFee = pendingLicenseFee.licenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.block = block.number;\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.block = block.number;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.block = block.number;\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(publisher);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).approve(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\npragma solidity =0.8.7;\n\nimport \"hardhat/console.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\n\ncontract Factory is IFactory, Ownable {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n\n    constructor (IAuction _auctionImpl, IBasket _basketImpl) {\n        auctionImpl = _auctionImpl;\n        basketImpl = _basketImpl;\n        ownerSplit = 0;\n    }\n\n    Proposal[] private _proposals;\n\n    IAuction public override auctionImpl;\n    IBasket public override basketImpl;\n\n    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%\n    uint256 public override auctionDecrement = 10000;\n    uint256 public override auctionMultiplier = 2;\n    uint256 public override bondPercentDiv = 400;\n    uint256 public override ownerSplit;\n\n    function proposal(uint256 proposalId) external override view returns (Proposal memory) {\n        return _proposals[proposalId];\n    }\n\n    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {\n        minLicenseFee = newMinLicenseFee;\n    }\n\n    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {\n        auctionDecrement = newAuctionDecrement;\n    }\n\n    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {\n        auctionMultiplier = newAuctionMultiplier;\n    }\n\n    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {\n        bondPercentDiv = newBondPercentDiv;\n    }\n\n    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {\n        require(newOwnerSplit <= 2e17); // 20%\n\n        ownerSplit = newOwnerSplit;\n    }\n\n    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {\n        return (_proposals[id].tokens, _proposals[id].weights);\n    }\n\n    function proposeBasketLicense(\n        uint256 licenseFee, \n        string memory tokenName, \n        string memory tokenSymbol, \n        address[] memory tokens,\n        uint256[] memory weights\n    ) public override returns (uint256 id) {\n        basketImpl.validateWeights(tokens, weights);\n\n        require(licenseFee >= minLicenseFee);\n\n        // create proposal object\n        Proposal memory proposal = Proposal({\n            licenseFee: licenseFee,\n            tokenName: tokenName,\n            tokenSymbol: tokenSymbol,\n            proposer: address(msg.sender),\n            tokens: tokens,\n            weights: weights,\n            basket: address(0)\n        });\n\n        emit BasketLicenseProposed(msg.sender, tokenName);\n        _proposals.push(proposal);\n\n        return _proposals.length - 1;\n    }\n\n    function createBasket(uint256 idNumber) external override returns (IBasket) {\n        Proposal memory bProposal = _proposals[idNumber];\n        require(bProposal.basket == address(0));\n\n        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));\n        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));\n\n        newAuction.initialize(address(newBasket), address(this));\n        newBasket.initialize(bProposal, newAuction);\n\n        for (uint256 i = 0; i < bProposal.weights.length; i++) {\n            IERC20 token = IERC20(bProposal.tokens[i]);\n            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n            token.safeApprove(address(newBasket), bProposal.weights[i]);\n        }\n\n        newBasket.mintTo(BASE, msg.sender);\n\n        _proposals[idNumber].basket = address(newBasket);\n\n        emit BasketCreated(address(newBasket));\n\n        return newBasket;\n    }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol",
            "Basket.sol",
            "Factory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [
                    "settleAuction",
                    "owner",
                    "auctionDecrement",
                    "setAuctionDecrement",
                    "setAuctionDecrement("
                ],
                "Type": " Factory.sol - lack of checks in  setAuctionDecrement  will cause reverts in Auction::settleAuction()",
                "Description": "\n\nsetAuctionDecrement doesn't check for a min nor a max amount\nThis means we can change auctionDecrement which would allow owner\u00a0to set auctionDecrement to 0\n\nThis will cause the function settleAuction in Auction.sol to revert\n\nThis allows the owner to block auctions from being settled\n\n\nsetAuctionDecrement(0)\nNow settleAuction\u00a0will revert due to division by 0\n\n",
                "Repair": "\nAdd checks in setAuctionDecrement\nRefactor to\nsolidity\nfunction setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {\n    require(newAuctionDecrement  AMOUNT);\n    require(newAuctionDecrement <= AMOUNT_2);\n    auctionDecrement = newAuctionDecrement;\n}\n\n\nfrank-beard (Kuiper) acknowledged and disagreed with severity(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/119#issuecomment-929647365):\n  the owner for this is intended to be a dao that acts in support of the protocol, however this is a good point to the centralization concerns for the protocol, we will most likely manage this by adding a timelock to these function\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/119#issuecomment-997302382):\n  I wrote the finding and in being the contest judge will be forfeiting all winnings.\n \n After thinking about it, this is a medium severity finding because it is a DOS that relies on a specific condition.\n While the argument that the owner can be being always hold up, it is important that protocol users understand the risk, so it's important to flag up admin privileges\n\n\n\n\n"
            },
            {
                "Name": "M-21",
                "Location": [
                    "//solidity\nProposal memory proposal = Proposal({\n        licenseFee: 10,\n        tokenName: abc,\n        tokenSymbol: aa,\n        proposer: 0xabc,\n        tokens: {},\n        weights: {},\n        basket: address(0)\n});\n",
                    "//solidity\nfunction validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n    require(_tokens.length == _weights.length);\n    uint256 length = _tokens.length;\n    address[] memory tokenList = new address[(length);\n\n    // check uniqueness of tokens and not token(0)\n\n    for (uint i = 0; i < length; i++) {\n        ...\n    }\n}\n",
                    "//solidity\n   _proposals.push(proposal);\n",
                    "//solidity\nfunction createBasket(uint256 idNumber) external override returns (IBasket) {\n    Proposal memory bProposal = _proposals[idNumber];\n    require(bProposal.basket == address(0));\n\n    ....\n\n    for (uint256 i = 0; i < bProposal.weights.length; i++) {\n        ...\n    }\n    ...\n    return newBasket;\n}\n",
                    "//solidity\nnewBasket.mintTo(BASE, msg.sender);\n_proposals[idNumber].basket = address(newBasket);\n",
                    "//solidity\nfunction mint(uint256 amount) public override {\n    mintTo(amount, msg.sender);\n}\n\nfunction mintTo(uint256 amount, address to) public override {\n    ...\n\n    pullUnderlying(amount, msg.sender);\n\n    _mint(to, amount);\n\n    ...\n}\n",
                    "//solidity\nfunction pullUnderlying(uint256 amount, address from) private {\n    for (uint256 i = 0; i < weights.length; i++) {\n        uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n        IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n    }\n}\n",
                    "//solidity\n_mint(to, amount);\n",
                    "//solidity\nfunction publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {\n    validateWeights(_tokens, _weights);\n\n    if (pendingWeights.pending) {\n        require(block.number = pendingWeights.block + TIMELOCK_DURATION);\n        if (auction.auctionOngoing() == false) {\n            auction.startAuction();\n\n            emit PublishedNewIndex(publisher);\n        } else if (auction.hasBonded()) {\n\n        } else {\n            auction.killAuction();\n\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.block = block.number;\n        }\n    } else {\n        pendingWeights.pending = true;\n        pendingWeights.tokens = _tokens;\n        pendingWeights.weights = _weights;\n        pendingWeights.block = block.number;\n    }\n}\n",
                    "//solidity\nfunction burn(uint256 amount) public override {\n    require(auction.auctionOngoing() == false);\n    require(amount  0);\n    require(balanceOf(msg.sender) = amount);\n\n    handleFees();\n\n    pushUnderlying(amount, msg.sender);\n    _burn(msg.sender, amount);\n    \n    emit Burned(msg.sender, amount);\n}\n"
                ],
                "Type": " Zero weighted baskets are allowed to steal funds",
                "Description": "\n\nIt was observed that Publisher is allowed to create a basket with zero token and weight. This can lead to user fund stealing as described in below poc\nThe issue was discovered in validateWeights function of Basket contract\n\n\n1.  User proposes a new Basket with 0 tokens and weights using proposeBasketLicense function in Factory contract\n\nsolidity\nProposal memory proposal = Proposal({\n        licenseFee: 10,\n        tokenName: abc,\n        tokenSymbol: aa,\n        proposer: 0xabc,\n        tokens: {},\n        weights: {},\n        basket: address(0)\n});\n\n\n2.  validateWeights function is called and it returns success as the only check performed is _tokens.length == _weights.length (0=0)\n\nsolidity\nfunction validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n    require(_tokens.length == _weights.length);\n    uint256 length = _tokens.length;\n    address[] memory tokenList = new address[(length);\n\n    // check uniqueness of tokens and not token(0)\n\n    for (uint i = 0; i < length; i++) {\n        ...\n    }\n}\n\n\n3.  A new proposal gets created\nsolidity\n   _proposals.push(proposal);\n\n\n4.  User creates new Basket with this proposal using createBasket function\n\nsolidity\nfunction createBasket(uint256 idNumber) external override returns (IBasket) {\n    Proposal memory bProposal = _proposals[idNumber];\n    require(bProposal.basket == address(0));\n\n    ....\n\n    for (uint256 i = 0; i < bProposal.weights.length; i++) {\n        ...\n    }\n    ...\n    return newBasket;\n}\n\n\n5.  Since no weights and tokens were in this proposal so no token transfer is required (bProposal.weights.length will be 0 so loop won't run)\n\n6.  Basket gets created and user becomes publisher for this basket\n\nsolidity\nnewBasket.mintTo(BASE, msg.sender);\n_proposals[idNumber].basket = address(newBasket);\n\n\n7.  Publisher owned address calls the mint function with say amount 10 on Basket.sol contract\n\nsolidity\nfunction mint(uint256 amount) public override {\n    mintTo(amount, msg.sender);\n}\n\nfunction mintTo(uint256 amount, address to) public override {\n    ...\n\n    pullUnderlying(amount, msg.sender);\n\n    _mint(to, amount);\n\n    ...\n}\n\n\n8.  Since there is no weights so pullUnderlying function does nothing (weights.length is 0)\n\nsolidity\nfunction pullUnderlying(uint256 amount, address from) private {\n    for (uint256 i = 0; i < weights.length; i++) {\n        uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n        IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n    }\n}\n\n\n9.  Full amount 10 is minted to Publisher owned address setting balanceOf(msg.sender) = 10\n\nsolidity\n_mint(to, amount);\n\n\n10. Now Publisher calls the publishNewIndex to set new weights. Since pendingWeights.pending is false, else condition gets executed\n\nsolidity\nfunction publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {\n    validateWeights(_tokens, _weights);\n\n    if (pendingWeights.pending) {\n        require(block.number = pendingWeights.block + TIMELOCK_DURATION);\n        if (auction.auctionOngoing() == false) {\n            auction.startAuction();\n\n            emit PublishedNewIndex(publisher);\n        } else if (auction.hasBonded()) {\n\n        } else {\n            auction.killAuction();\n\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.block = block.number;\n        }\n    } else {\n        pendingWeights.pending = true;\n        pendingWeights.tokens = _tokens;\n        pendingWeights.weights = _weights;\n        pendingWeights.block = block.number;\n    }\n}\n\n\n11. Publisher calls the publishNewIndex again which starts the Auction. This auction is later settled using the settleAuction function in Auction contract\n\n12. Publisher owned address can now call burn and get the amount 10 even though he never made the payment since his balanceOf(msg.sender) = 10 (Step 9)\n\nsolidity\nfunction burn(uint256 amount) public override {\n    require(auction.auctionOngoing() == false);\n    require(amount  0);\n    require(balanceOf(msg.sender) = amount);\n\n    handleFees();\n\n    pushUnderlying(amount, msg.sender);\n    _burn(msg.sender, amount);\n    \n    emit Burned(msg.sender, amount);\n}\n\n",
                "Repair": "\nChange validateWeights to check for 0 length token\n\nsolidity\nfunction validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n    require(_tokens.length0);\n    ...\n}\n\n\nfrank-beard (defiProtocol) confirmed(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/21)  \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/21#issuecomment-997499391):\n  The warden identified a way to the publisher to effectively mint a ton of shares by setting weights to zero, for them to then change the weights and use their shares to dilute depositors.\n \n This may be a potential feature of the protocol at this time as there's no check for how the ratios relate to themselves\n \n The implications are actually pretty deep and I highly recommend the sponsor to consider the fact that if weights can be changed at any time by the publisher, they can effectively dilute / re-base the basket at any time very aggressively, to the detriment of users.\n \n As for the the finding by the warden, they have shown a specific way for the publisher to dilute other depositors, by setting up a basket with zero tokens initially.\n \n Becasue this is a specific attack that relies on external conditions, I'm downgrading the severity to medium\n\n\n\n\n"
            }
        ]
    }
]