[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nuint256 seqNum = inbox.createRetryableTicket{value: _l1CallValue}(\n    target,\n    _l2CallValue,\n    maxSubmissionCost,\n    from,\n    from,\n    maxGas,\n    gasPriceBid,\n    data\n);\n",
                    "//solidity\nuint256 amount = IBridgeMinter(bridgeMinterAddr)\n    .withdrawETHToL1Migrator();\n",
                    "//solidity\nsendTxToL2(\n    l2MigratorAddr,\n    address(this), // L2 alias of this contract will receive refunds\n    msg.value,\n    amount,\n    _maxSubmissionCost,\n    _maxGas,\n    _gasPriceBid,\n    \"\"\n)\n"
                ],
                "Type": " [WP-H5",
                "Description": "\nPer the arb-bridge-eth code:\n\n all msg.value will deposited to callValueRefundAddress on L2\n\n<https://github.com/OffchainLabs/arbitrum/blob/78118ba205854374ed280a27415cb62c37847f72/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L313\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1ArbitrumMessenger.sol#L65-L74\n\nsolidity\nuint256 seqNum = inbox.createRetryableTicket{value: _l1CallValue}(\n    target,\n    _l2CallValue,\n    maxSubmissionCost,\n    from,\n    from,\n    maxGas,\n    gasPriceBid,\n    data\n);\n\n\nAt L308-L309, ETH held by BridgeMinter is withdrawn to L1Migrator:\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L309\n\nsolidity\nuint256 amount = IBridgeMinter(bridgeMinterAddr)\n    .withdrawETHToL1Migrator();\n\n\nHowever, when calling sendTxToL2() the parameter _l1CallValue is only the msg.value, therefore, the ETH transferred to L2 does not include any funds from bridgeMinter.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L318-L327\n\nsolidity\nsendTxToL2(\n    l2MigratorAddr,\n    address(this), // L2 alias of this contract will receive refunds\n    msg.value,\n    amount,\n    _maxSubmissionCost,\n    _maxGas,\n    _gasPriceBid,\n    \"\"\n)\n\n\nAs a result, due to lack of funds, call with value = amount to l2MigratorAddr will always fail on L2.\n\nSince there is no other way to send ETH to L2, all the ETH from bridgeMinter is now frozen in the contract.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nsendTxToL2(\n    l2MigratorAddr,\n    address(this), // L2 alias of this contract will receive refunds\n    msg.value + amount, // the amount withdrawn from BridgeMinter should be added\n    amount,\n    _maxSubmissionCost,\n    _maxGas,\n    _gasPriceBid,\n    \"\"\n)\n\n\nyondonfu (Livepeer) confirmed and resolved(https://github.com/code-423n4/2022-01-livepeer-findings/issues/205#issuecomment-1021378858):\n  Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/51\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-livepeer-findings/issues/205#issuecomment-1025008573):\n  Awesome find!\n\n\n\n \n\n"
            },
            {
                "Name": "M-01",
                "Location": [],
                "Type": " L1Migrator.migrateLPT  can be used to take away protocol's access to LPT tokens in BridgeMinter",
                "Description": "\nSame thing as the ETH issue I reported earlier. I wasn't sure if those are supposed to be a single issue or not. The concept is the same. But, now you lose LPT tokens.\n\nThe L1Migrator.migrateLPT() function can be called by anyone. It pulls all the LPT from the BridgeMinter contract and starts the process of moving the funds to L2. First of all, this function is only executable once. The RetryableTicket created with the first call is the only chance of moving the funds to L2.\n\nThe attacker can call the function with parameters(https://developer.offchainlabs.com/docs/l1_l2_messages#parameters) that make the creation of the RetryableTicket on L2 fail. Thus, the LPT sits in the L1Migrator contract with no way of moving it to L2 or anywhere else. Effectively, the funds are lost.\n\n\nThe function is only executable once because it uses the amount returned by IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator() to specify the amount of LPT to be sent to L2: <https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L342\n\nAfter the first call to migrateLPT() that function will always return 0 since the BridgeMinter won't have any more LPT: <https://github.com/livepeer/protocol/blob/streamflow/contracts/token/BridgeMinter.sol#L107\n\nSo after the attacker called migrateLPT() with insufficient funds to create a RetryableTicket on L2 we have the following state:\n\n*   BridgeMinter has 0 LPT\n*   L1Migrator has X amount of LPT that is not accessible. There are no functions to get the LPT out of there.\n*   1 failed RetryTicket\n\nThe same thing can also be triggered by a non-malicious caller by simply providing insufficient funds. The whole design of only being able to try once is the issue here.\n\n",
                "Repair": "\nInstead of using the amount returned by IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator() you should use the balance of the L1Migrator contract.\n\nIt might also make sense to not allow anybody to call the function. I don't see the benefit of that.\n\nActually, the funds aren't lost. The funds are sent to the Escrow contract which can be used to transfer the funds back to the BridgeMinter contract. Thus, you could reset the whole thing to its initial state and call L1Migrator.migrateLPT() again. But, a really persistent attacker has the ability to DoS the function by frontrunning any call to it which results in the RetryableTicket failing again. Thus, you'd have to transfer the funds from the Escrow contract to the BrigeMinter again and so on.\n\nSo the same scenario I've outlined earlier is still viable. It's just a bit more difficult now since it has a higher cost for the attacker now. Because of that I think it's an medium issue instead of high.\n\nAlso, the mitigation steps I've given aren't valid. You can't use the L1Migrator contract's balance since it will always be 0 (the funds are sent to the Escrow contract). Thus the best solution would be to just limit the access to the function.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-livepeer-findings/issues/97#issuecomment-1025008823):\n  Nice find! The warden has outlined a potential DOS attack which can lead to funds lost which are only recoverable by the transferring the funds in the escrow contract back to the bridge minter contract.\n\nyondonfu (Livepeer) confirmed and resolved(https://github.com/code-423n4/2022-01-livepeer-findings/issues/97#issuecomment-1026222409):\n  Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/commit/5b6a349ad8f4e53c01d2e43eda36bbbf3037a3c9\n\n\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nuint256 amount = IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator();\n",
                    "//solidity\n(bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(\"\");\n"
                ],
                "Type": " [WP-H3",
                "Description": "\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L310\n\nsolidity\nuint256 amount = IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator();\n\n\nL1Migrator.sol#migrateETH() will call IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator() to withdraw ETH from BridgeMinter.\n\nHowever, the current implementation of L1Migrator is unable to receive ETH.\n\n<https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L94-L94\n\nsolidity\n(bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(\"\");\n\n\nA contract receiving Ether must have at least one of the functions below:\n\n*   receive() external payable\n*   fallback() external payable\n\nreceive() is called if msg.data is empty, otherwise fallback() is called.\n\nBecause L1Migrator implement neither receive() or fallback(), the call at L94 will always revert.\n\n\nAll the ETH held by the BridgeMinter can get stuck in the contract.\n\n",
                "Repair": "\nAdd receive() external payable {} in L1Migrator.\n\nyondonfu (Livepeer) confirmed and disagreed with severity(https://github.com/code-423n4/2022-01-livepeer-findings/issues/198#issuecomment-1019663325):\n  Severity: 2 (Med)\n \n We'll fix this, but noting that the funds are recoverable because the BridgeMinter can set a new L1Migrator that does have the receive() function which is why the suggested severity is 2 (Med).\n\nyondonfu (Livepeer) resolved(https://github.com/code-423n4/2022-01-livepeer-findings/issues/198#issuecomment-1021379439):\n  Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/50\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-livepeer-findings/issues/198#issuecomment-1025009024):\n  Agree with sponsor, these funds are recoverable. However, the warden has identified a DOS attack, which is a valid medium severity issue.\n\n\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) external payable override whenNotPaused returns (bytes memory) {\n    require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n    // nested scope to avoid stack too deep errors\n    address from;\n    uint256 seqNum;\n    bytes memory extraData;\n    {\n        uint256 maxSubmissionCost;\n        (from, maxSubmissionCost, extraData) = parseOutboundData(_data);\n        require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n        // transfer tokens to escrow\n        TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);\n\n        bytes memory outboundCalldata = getOutboundCalldata(\n            _l1Token,\n            from,\n            _to,\n            _amount,\n            extraData\n        );\n\n        seqNum = sendTxToL2(\n            l2Counterpart,\n            from,\n            maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            outboundCalldata\n        );\n    }\n\n    emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);\n\n    return abi.encode(seqNum);\n}\n"
                ],
                "Type": " Fund loss when insufficient call value to cover fee",
                "Description": "\nFund can be lost if the L1 call value provided is insufficient to cover _maxSubmissionCost, or stuck if insufficient to cover _maxSubmissionCost + (_maxGas * _gasPriceBid).\n\n\noutboundTransfer in L1LPTGateway does not check if the call value is sufficient, if it is < _maxSubmissionCost the retryable ticket creation will fail and fund is lost; if it is <_maxSubmissionCost + (_maxGas * _gasPriceBid) the ticket would require manual execution.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1LPTGateway.sol#L80\nsolidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) external payable override whenNotPaused returns (bytes memory) {\n    require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n    // nested scope to avoid stack too deep errors\n    address from;\n    uint256 seqNum;\n    bytes memory extraData;\n    {\n        uint256 maxSubmissionCost;\n        (from, maxSubmissionCost, extraData) = parseOutboundData(_data);\n        require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n        // transfer tokens to escrow\n        TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);\n\n        bytes memory outboundCalldata = getOutboundCalldata(\n            _l1Token,\n            from,\n            _to,\n            _amount,\n            extraData\n        );\n\n        seqNum = sendTxToL2(\n            l2Counterpart,\n            from,\n            maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            outboundCalldata\n        );\n    }\n\n    emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);\n\n    return abi.encode(seqNum);\n}\n\n",
                "Repair": "\nAdd check similar to the one used in L1GatewayRouter provided by Arbitrum team\n\n<https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L236\nsolidity\nuint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);\nrequire(_maxSubmissionCost  0, \"NO_SUBMISSION_COST\");\nrequire(msg.value == expectedEth, \"WRONG_ETH_VALUE\");\n\n\nyondonfu (Livepeer) confirmed and disagreed with severity(https://github.com/code-423n4/2022-01-livepeer-findings/issues/238#issuecomment-1018693125):\n  Labeled as disagree with severity because we think this is a 2 Med finding. We think that the likelihood of this occurring is low because in almost all cases users should be interacting with this contract using an application that handles calculating the maxSubmissionCost properly which would prevent the reported issue. However, we do think that the impact *if* this occurs is high since LPT *and* ETH could be lost if the reported issue happens. Thus, we think 2 Med is appropriate given that assets are not at direct risk, but there is a low probability path for assets to be lost.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-01-livepeer-findings/issues/238#issuecomment-1025009724):\n  I agree, there is potential for unintentional loss of funds, however, the attack vector makes assumptions on how this might occur. Due to the unlikely nature, I agree that this should be a medium severity issue..\n\nyondonfu (Livepeer) resolved(https://github.com/code-423n4/2022-01-livepeer-findings/issues/238#issuecomment-1026220888):\n  Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/commit/6615bb8ce0fced895acd0e5d3e826c1e7b5d0138\n\n\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\nfunction mint(address _to, uint256 _amount)\n    external\n    override\n    onlyRole(MINTER_ROLE)\n{\n    _mint(_to, _amount);\n    emit Mint(_to, _amount);\n}\n"
                ],
                "Type": " [WP-M0",
                "Description": "\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L23-L30\n\nsolidity\nfunction mint(address _to, uint256 _amount)\n    external\n    override\n    onlyRole(MINTER_ROLE)\n{\n    _mint(_to, _amount);\n    emit Mint(_to, _amount);\n}\n\n\nUsing the mint() function of L2LivepeerToken, an address with MINTER_ROLE can burn an arbitrary amount of tokens.\n\nIf the private key of the deployer or an address with the MINTER_ROLE is compromised, the attacker will be able to mint an unlimited amount of LPT tokens.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\n",
                "Repair": "\nConsider removing the MINTER_ROLE, make the L2LivepeerToken only mintable by the owner, and make the L2Minter contract to be the owner and therefore the only minter.\n\nyondonfu (Livepeer) acknowledged(https://github.com/code-423n4/2022-01-livepeer-findings/issues/193#issuecomment-1019660423):\n  Planning on keeping the role since the L2LPTGateway needs to be given minting rights as well in addition to the L2 Minter.\n\n\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nfunction burn(address _from, uint256 _amount)\n    external\n    override\n    onlyRole(BURNER_ROLE)\n{\n    _burn(_from, _amount);\n    emit Burn(_from, _amount);\n}\n"
                ],
                "Type": " [WP-M1",
                "Description": "\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L36-L43\n\nsolidity\nfunction burn(address _from, uint256 _amount)\n    external\n    override\n    onlyRole(BURNER_ROLE)\n{\n    _burn(_from, _amount);\n    emit Burn(_from, _amount);\n}\n\n\nUsing the burn() function of L2LivepeerToken, an address with BURNER_ROLE can burn an arbitrary amount of tokens from any address.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\nA malicious or compromised BURNER_ROLE address can take advantage of this, burn the balance of a Uniswap pool and effectively steal almost all the funds from the liquidity pool (eg, Uniswap LPT-WETH Pool).\n\n",
                "Repair": "\nConsider removing the BURNER_ROLE and change burn() function to:\n\nsolidity\nfunction burn(uint256 _amount)\n    external\n    override\n{\n    _burn(msg.sender, _amount);\n    emit Burn(msg.sender, _amount);\n}\n\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/49cf5401b0514511675d781a1e29d6b0325cfe88/contracts/L2/gateway/L2LPTGateway.sol#L34-L45\n\nMintable(l2Lpt).burn(from, _amount); in L2LPTGateway.sol#outboundTransfer() should also be replaced with:\n\nsolidity\nMintable(l2Lpt).transferFrom(from, _amount);\nMintable(l2Lpt).burn(_amount);\n\n\nyondonfu (Livepeer) confirmed and resolved(https://github.com/code-423n4/2022-01-livepeer-findings/issues/194#issuecomment-1021377760):\n  Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/52\n\n\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction approve(\n    address _token,\n    address _spender,\n    uint256 _value\n) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    ApproveLike(_token).approve(_spender, _value);\n    emit Approve(_token, _spender, _value);\n}\n"
                ],
                "Type": " [WP-M2",
                "Description": "\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/escrow/L1Escrow.sol#L21-L28\n\nsolidity\nfunction approve(\n    address _token,\n    address _spender,\n    uint256 _value\n) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    ApproveLike(_token).approve(_spender, _value);\n    emit Approve(_token, _spender, _value);\n}\n\n\nL1Escrow.sol#approve() allows an address with DEFAULT_ADMIN_ROLE can approve an arbitrary amount of tokens to any address.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\nA malicious or compromised DEFAULT_ADMIN_ROLE address can take advantage of this, and steal all the funds from the L1Escrow contract.\n\n",
                "Repair": "\nConsider removing approve() function and approve l1LPT to l1Gateway in the constructor.\n\nyondonfu (Livepeer) acknowledged(https://github.com/code-423n4/2022-01-livepeer-findings/issues/195#issuecomment-1019662710):\n  Likely won't change as we want to preserve the ability for protocol governance to move the LPT from the L1Escrow in the event of a L2 failure.\n\n\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "//solidity\nfunction outboundTransfer(\n    address _token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) external payable returns (bytes memory);\n",
                    "//solidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n) public payable returns (bytes memory) {\n    return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n}\n",
                    "//solidity\nfunction outboundTransfer(\n    address _token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) public payable virtual override returns (bytes memory) {\n    address gateway = getGateway(_token);\n    bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(\n        msg.sender,\n        _data\n    );\n\n    emit TransferRouted(_token, msg.sender, _to, gateway);\n    return\n        ITokenGateway(gateway).outboundTransfer{ value: msg.value }(\n            _token,\n            _to,\n            _amount,\n            _maxGas,\n            _gasPriceBid,\n            gatewayData\n        );\n}\n",
                    "//solidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n) public override whenNotPaused returns (bytes memory res) {\n    // ...\n}\n"
                ],
                "Type": " [WP-M4",
                "Description": "\nPer the document: <https://github.com/code-423n4/2022-01-livepeer#l2---l1-lpt-withdrawal\n\n The following occurs when LPT is withdrawn from L2 to L1:\n\n The user initiates a withdrawal for X LPT. This can be done in two ways: a. Call outboundTransfer() on L2GatewayRouter which will call outboundTransfer() on L2LPTGateway b. Call outboundTransfer() directly on L2LPTGateway\n\nThe method (a) described above won't work in the current implementation due to the missing interface on L2LPTGateway.\n\nWhen initiate a withdraw from the Arbitrum Gateway Router, L2GatewayRouter will call outboundTransfer(address,address,uint256,uint256,uint256,bytes) on ITokenGateway(gateway):\n\nsolidity\nfunction outboundTransfer(\n    address _token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) external payable returns (bytes memory);\n\n\n<https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol#L57-L64\n\nsolidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n) public payable returns (bytes memory) {\n    return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n}\n\n\n<https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol#L78-L102\n\nsolidity\nfunction outboundTransfer(\n    address _token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) public payable virtual override returns (bytes memory) {\n    address gateway = getGateway(_token);\n    bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(\n        msg.sender,\n        _data\n    );\n\n    emit TransferRouted(_token, msg.sender, _to, gateway);\n    return\n        ITokenGateway(gateway).outboundTransfer{ value: msg.value }(\n            _token,\n            _to,\n            _amount,\n            _maxGas,\n            _gasPriceBid,\n            gatewayData\n        );\n}\n\n\nHowever, L2LPTGateway dose not implement outboundTransfer(address,address,uint256,uint256,uint256,bytes) but only outboundTransfer(address,address,uint256,bytes):\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTGateway.sol#L65-L89\n\nsolidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n) public override whenNotPaused returns (bytes memory res) {\n    // ...\n}\n\n\nTherefore, the desired feature to withdraw LPT from L2 to L1 via Arbitrum Router will not be working properly.\n\n",
                "Repair": "\nConsider implementing the method used by  Arbitrum Router.\n\nSee also the implementation of L2DaiGateway by arbitrum-dai-bridge: <https://github.com/makerdao/arbitrum-dai-bridge/blob/master/contracts/l2/L2DaiGateway.sol#L88-L95\n\nyondonfu (Livepeer) confirmed and resolved(https://github.com/code-423n4/2022-01-livepeer-findings/issues/202#issuecomment-1026222951):\n  Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/57\n\n\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [],
                "Type": " Admin can rug L2 Escrow tokens leading to reputation risk",
                "Description": "\nThe L1Escrow contract has the function approve that is callable by the admin to approve an arbitrary spender with an arbitrary amount (so they can steal all of the escrow's holdings if they want). Even if the admin is well intended, the contract can still be called out which would degrade the reputation of the protocol (e.g. see here: <https://twitter.com/RugDocIO/status/1411732108029181960). LPT is valuable on the Ethereum mainnet, so this rug vector should be mitigated. It would be best to restrict this function's power by only allowing approvals to other trusted protocol contracts (like L1LPTGateway, which I believe uses the escrow's approval).\n\nNOTE: Even if the admin is under a timelock, this is still an issue, as users have to wait a whole week to withdraw from L2 - L1 due to the dispute period.\n\n\nSee the approve function here(https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/escrow/L1Escrow.sol#L21)\n\n",
                "Repair": "\nRestrict the power of this approve function so that the admin isn't able to steal funds. This can be accomplished by only allowing approvals to other protocol functions (instead of arbitrary approvals).\n\nyondonfu (Livepeer) acknowledged(https://github.com/code-423n4/2022-01-livepeer-findings/issues/165) \n\n\n"
            }
        ]
    }
]