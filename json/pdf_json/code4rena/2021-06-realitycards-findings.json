[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRealitio.sol\";\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    //\u2261\u2261\u2261\u2261\u2261\u2261\u2261 CONTRACT VARIABLES \u2261\u2261\u2261\u2261\u2261\u2261\u2261//\n    IRCTreasury public override treasury;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRealitio public realitio;\n\n    ///// CONTRACT ADDRESSES /////\n    /// @dev reference contract\n    address public referenceContractAddress;\n    /// @dev increments each time a new reference contract is added\n    uint256 public referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(uint256 => address[]) public marketAddresses;\n    mapping(address => bool) public mappingOfMarkets;\n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum tokens that must be sent when creating market which forms iniital pot\n    uint256 public sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public maximumDuration;\n    /// @dev list of governors\n    mapping(address => bool) public governors;\n    /// @dev if false, anyone can create markets\n    bool public marketCreationGovernorsOnly = true;\n    /// @dev if false, anyone can be an affiliate\n    bool public approvedAffilliatesOnly = true;\n    /// @dev if false, anyone can be an artist\n    bool public approvedArtistsOnly = true;\n    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity\n    bool public override trapIfUnapproved = true;\n    /// @dev high level owner who can change the factory address\n    address public uberOwner;\n    /// @dev the maximum number of rent collections to perform in a single transaction\n    uint256 public override maxRentIterations;\n    /// @dev the address of the arbitrator\n    address public arbitrator;\n    /// @dev the time allowed to dispute the oracle answer\n    uint32 public timeout;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public override isMarketApproved;\n    /// @dev allows artist to receive cut of total rent\n    mapping(address => bool) public isArtistApproved;\n    /// @dev allows affiliate to receive cut of total rent\n    mapping(address => bool) public isAffiliateApproved;\n    /// @dev allows card affiliate to receive cut of total rent\n    mapping(address => bool) public isCardAffiliateApproved;\n    /// @dev a limit to the number of NFTs to mint per market\n    uint256 public nftMintingLimit;\n\n    ///// OTHER /////\n    /// @dev counts the total NFTs minted across all events\n    /// @dev ... so the appropriate token id is used when upgrading to mainnet\n    uint256 public totalNftMintCount;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogMarketCreated1(\n        address contractAddress,\n        address treasuryAddress,\n        address nftHubAddress,\n        uint256 referenceContractVersion\n    );\n    event LogMarketCreated2(\n        address contractAddress,\n        uint32 mode,\n        string[] tokenURIs,\n        string ipfsHash,\n        uint32[] timestamps,\n        uint256 totalNftMintCount\n    );\n    event LogMarketApproved(address market, bool hidden);\n    event LogAdvancedWarning(uint256 _newAdvancedWarning);\n    event LogMaximumDuration(uint256 _newMaximumDuration);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev Treasury must be deployed before Factory\n    constructor(\n        IRCTreasury _treasuryAddress,\n        address _realitioAddress,\n        address _arbitratorAddress\n    ) {\n        require(address(_treasuryAddress) != address(0));\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise contract variable\n        treasury = _treasuryAddress;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate\n        setminimumPriceIncreasePercent(10); // 10%\n        setNFTMintingLimit(60); // current gas limit (12.5m) allows for 60 NFTs to be minted\n        setMaxRentIterations(35); // limit appears to be 41, set safe at 35 for now.\n        // oracle\n        setArbitrator(_arbitratorAddress);\n        setRealitioAddress(_realitioAddress);\n        setTimeout(86400); // 24 hours\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          VIEW FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Fetch the address of the most recently created market\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return the address of the most recent market in the given mode\n    function getMostRecentMarket(uint256 _mode)\n        external\n        view\n        returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n    /// @notice Fetch all the market addresses for a given mode\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return an array of all markets in a given mode\n    function getAllMarkets(uint256 _mode)\n        external\n        view\n        returns (address[] memory)\n    {\n        return marketAddresses[_mode];\n    }\n\n    /// @notice Returns the currently set pot distribution\n    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates\n    function getPotDistribution()\n        external\n        view\n        override\n        returns (uint256[5] memory)\n    {\n        return potDistribution;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev include the owner as a governor\n    modifier onlyGovernors() {\n        require(\n            governors[msgSender()] || owner() == msgSender(),\n            \"Not approved\"\n        );\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - OWNER (SETUP)  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n\n    /// @notice where the NFTs live\n    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but\n    /// @dev ... keeping flexible in case returning to previous contract\n    /// @param _newAddress the address to set\n    /// @param _newNftMintCount the number of NFTs this contract has minted, in order to keep them unique\n    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)\n        external\n        onlyOwner\n    {\n        require(address(_newAddress) != address(0));\n        nfthub = _newAddress;\n        totalNftMintCount = _newNftMintCount;\n    }\n\n    /// @notice set the address of the orderbook contract\n    /// @param _newAddress the address to set\n    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {\n        require(address(_newAddress) != address(0));\n        orderbook = _newAddress;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase & pot distribution emitted by Market.\n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice update stakeholder payouts\n    /// @dev in basis points (so 1000 = 100%)\n    /// @param _artistCut The artist that designed the card\n    /// @param _winnerCut Extra cut for the longest owner\n    /// @param _creatorCut The creator of the market\n    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts\n    /// @param _cardAffiliateCut An affiliate cur for specific cards\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) public onlyOwner {\n        require(\n            _artistCut +\n                _winnerCut +\n                _creatorCut +\n                _affiliateCut +\n                _cardAffiliateCut <=\n                1000,\n            \"Cuts too big\"\n        );\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%\n    function setminimumPriceIncreasePercent(uint256 _percentIncrease)\n        public\n        override\n        onlyOwner\n    {\n        minimumPriceIncreasePercent = _percentIncrease;\n    }\n\n    /// @notice A limit to the number of NFTs to mint per market\n    /// @dev to avoid gas limits\n    /// @param _mintLimit the limit to set\n    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {\n        nftMintingLimit = _mintLimit;\n    }\n\n    /// @notice A limit to the number of rent collections per transaction\n    /// @dev to avoid gas limits\n    /// @param _rentLimit the limit to set\n    function setMaxRentIterations(uint256 _rentLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxRentIterations = _rentLimit;\n    }\n\n    /// @notice set the address of the reality.eth contracts\n    /// @param _newAddress the address to set\n    function setRealitioAddress(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @notice address of the arbitrator, in case of continued disputes on reality.eth\n    /// @param _newAddress the address to set\n    function setArbitrator(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        arbitrator = _newAddress;\n    }\n\n    /// @notice set how long reality.eth waits for disputes before finalising\n    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs\n    function setTimeout(uint32 _newTimeout) public onlyOwner {\n        timeout = _newTimeout;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice whether or not only governors can create the market\n    function changeMarketCreationGovernorsOnly() external onlyOwner {\n        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;\n    }\n\n    /// @notice whether or not anyone can be an artist\n    function changeApprovedArtistsOnly() external onlyOwner {\n        approvedArtistsOnly = !approvedArtistsOnly;\n    }\n\n    /// @notice whether or not anyone can be an affiliate\n    function changeApprovedAffilliatesOnly() external onlyOwner {\n        approvedAffilliatesOnly = !approvedAffilliatesOnly;\n    }\n\n    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot\n    /// @param _amount the sponsorship required in wei\n    function setSponsorshipRequired(uint256 _amount) external onlyOwner {\n        sponsorshipRequired = _amount;\n    }\n\n    /// @notice if true, Cards in unapproved markets can't be upgraded\n    function changeTrapCardsIfUnapproved() external onlyOwner {\n        trapIfUnapproved = !trapIfUnapproved;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    /// @param _newAdvancedWarning the warning time to set in seconds\n    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {\n        advancedWarning = _newAdvancedWarning;\n        emit LogAdvancedWarning(_newAdvancedWarning);\n    }\n\n    /// @notice market closing time must be no more than this many seconds in the future\n    /// @param _newMaximumDuration the duration limit to set in seconds\n    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {\n        maximumDuration = _newMaximumDuration;\n        emit LogMaximumDuration(_newMaximumDuration);\n    }\n\n    /// @notice to fetch the owner of the contract\n    /// @dev used to specifiy the Ownable contract instead of the interface\n    function owner()\n        public\n        view\n        override(IRCFactory, Ownable)\n        returns (address)\n    {\n        return Ownable.owner();\n    }\n\n    /// @notice check if an address is a governor\n    /// @param _user the address to query\n    /// @return boolean return if true or false\n    function isGovernor(address _user) external view override returns (bool) {\n        return governors[_user];\n    }\n\n    // EDIT GOVERNORS\n\n    /// @notice add or remove an address from market creator whitelist\n    /// @param _governor the address to change approval for\n    /// @dev recommended to check isGovernor() afterwards to confirm the desired outcome\n    function changeGovernorApproval(address _governor) external onlyOwner {\n        require(_governor != address(0));\n        governors[_governor] = !governors[_governor];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - GOVERNORS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    /// @param _market the market address to change approval for\n    function changeMarketApproval(address _market) external onlyGovernors {\n        require(_market != address(0));\n        // check it's an RC contract\n        IRCMarket _marketToApprove = IRCMarket(_market);\n        assert(_marketToApprove.isMarket());\n        isMarketApproved[_market] = !isMarketApproved[_market];\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /// @notice artistAddress, passed in createMarket, must be approved\n    /// @param _artist the artist address to change approval for\n    function changeArtistApproval(address _artist) external onlyGovernors {\n        require(_artist != address(0));\n        isArtistApproved[_artist] = !isArtistApproved[_artist];\n    }\n\n    /// @notice affiliateAddress, passed in createMarket, must be approved\n    /// @param _affiliate the affiliate address to change approval for\n    function changeAffiliateApproval(address _affiliate)\n        external\n        onlyGovernors\n    {\n        require(_affiliate != address(0));\n        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];\n    }\n\n    /// @notice cardAffiliateAddress, passed in createMarket, must be approved\n    /// @param _affiliate the card affiliate address to change approval for\n    function changeCardAffiliateApproval(address _affiliate)\n        external\n        onlyGovernors\n    {\n        require(_affiliate != address(0));\n        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[\n            _affiliate\n        ];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    /// @notice change the reference contract for the contract logic\n    function setReferenceContractAddress(address _newAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newAddress != address(0));\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        assert(newContractVariable.isMarket());\n        // set\n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion += 1;\n    }\n\n    /// @notice to change or renounce ownership of the uberOwner role\n    function changeUberOwner(address _newUberOwner) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0));\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         MARKET CREATION         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Creates a new market with the given parameters\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    /// @param _sponsorship amount of sponsorship to create the market with\n    /// @return The address of the new market\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address) {\n        address _creator = msgSender();\n\n        // check sponsorship\n        require(\n            _sponsorship >= sponsorshipRequired,\n            \"Insufficient sponsorship\"\n        );\n        treasury.checkSponsorship(_creator, _sponsorship);\n\n        // check stakeholder addresses\n        // artist\n        if (approvedArtistsOnly) {\n            require(\n                isArtistApproved[_artistAddress] ||\n                    _artistAddress == address(0),\n                \"Artist not approved\"\n            );\n        }\n        // affiliate\n        if (approvedAffilliatesOnly) {\n            require(\n                isAffiliateApproved[_affiliateAddress] ||\n                    _affiliateAddress == address(0),\n                \"Affiliate not approved\"\n            );\n            // card affiliates\n            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {\n                require(\n                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||\n                        _cardAffiliateAddresses[i] == address(0),\n                    \"Card affiliate not approved\"\n                );\n            }\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(governors[_creator] || owner() == _creator, \"Not approved\");\n        }\n\n        // check timestamps\n        require(_timestamps.length == 3, \"Incorrect number of array elements\");\n        // check market opening time\n        if (advancedWarning != 0) {\n            require(\n                _timestamps[0] >= block.timestamp,\n                \"Market opening time not set\"\n            );\n            require(\n                _timestamps[0] - advancedWarning > block.timestamp,\n                \"Market opens too soon\"\n            );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(\n                _timestamps[1] < block.timestamp + maximumDuration,\n                \"Market locks too late\"\n            );\n        }\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(\n            _timestamps[1] + (1 weeks) > _timestamps[2] &&\n                _timestamps[1] <= _timestamps[2],\n            \"Oracle resolution time error\"\n        );\n\n        // check the number of NFTs to mint is within limits\n        require(\n            _tokenURIs.length <= nftMintingLimit,\n            \"Too many tokens to mint\"\n        );\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = Clones.clone(referenceContractAddress);\n        emit LogMarketCreated1(\n            _newAddress,\n            address(treasury),\n            address(nfthub),\n            referenceContractVersion\n        );\n        emit LogMarketCreated2(\n            _newAddress,\n            _mode,\n            _tokenURIs,\n            _ipfsHash,\n            _timestamps,\n            totalNftMintCount\n        );\n\n        // tell Treasury, Orderbook, and NFT hub about new market\n        // before initialize as during initialize the market may call the treasury\n        treasury.addMarket(_newAddress);\n        nfthub.addMarket(_newAddress);\n        orderbook.addMarket(\n            _newAddress,\n            _tokenURIs.length,\n            minimumPriceIncreasePercent\n        );\n\n        // update internals\n        marketAddresses[_mode].push(_newAddress);\n        mappingOfMarkets[_newAddress] = true;\n\n        // initialize the market\n        IRCMarket(_newAddress).initialize({\n            _mode: _mode,\n            _timestamps: _timestamps,\n            _numberOfTokens: _tokenURIs.length,\n            _totalNftMintCount: totalNftMintCount,\n            _artistAddress: _artistAddress,\n            _affiliateAddress: _affiliateAddress,\n            _cardAffiliateAddresses: _cardAffiliateAddresses,\n            _marketCreatorAddress: _creator,\n            _realitioQuestion: _realitioQuestion\n        });\n\n        // create the NFTs\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            uint256 _tokenId = i + totalNftMintCount;\n            require(\n                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),\n                \"Nft Minting Failed\"\n            );\n        }\n\n        // increment totalNftMintCount\n        totalNftMintCount = totalNftMintCount + _tokenURIs.length;\n\n        // pay sponsorship, if applicable\n        if (_sponsorship > 0) {\n            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);\n        }\n\n        return _newAddress;\n    }\n\n    /// @dev called by the market upon initialise\n    /// @dev not passed to initialise to avoid stack too deep error\n    function getOracleSettings()\n        external\n        view\n        override\n        returns (\n            IRealitio,\n            address,\n            uint32\n        )\n    {\n        return (realitio, arbitrator, timeout);\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public orderbook;\n    /// @dev nfthub instance, to query current card owner\n    IRCNftHubL2 public nfthub;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev address of the Factory so only the Factory can add new markets\n    address public override factoryAddress;\n    /// @dev so only markets can use certain functions\n    mapping(address => bool) public override isMarket;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public marketBalance;\n    /// @dev a quick check if a uesr is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 marketBalanceDiscrepancy;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent any cards for specific market\n    mapping(address => bool) public override marketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            UBER OWNER           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev high level owner who can change the factory address\n    address public override uberOwner;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1000000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /// @notice only allow markets to call these functions\n    modifier onlyMarkets {\n        require(isMarket[msgSender()], \"Not authorised\");\n        _;\n    }\n\n    /// @notice only allow orderbook to call these functions\n    modifier onlyOrderbook {\n        require(msgSender() == address(orderbook), \"Not authorised\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           ADD MARKETS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can move funds from deposits to marketPots and vice versa\n    function addMarket(address _newMarket) external override {\n        require(msgSender() == factoryAddress, \"Not factory\");\n        isMarket[_newMarket] = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyOwner\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyOwner {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental for a specific market\n    function changePauseMarket(address _market) external override onlyOwner {\n        require(isMarket[_market], \"This isn't a market\");\n        marketPaused[_market] = !marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyOwner {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add a user to the whitelist\n    function addToWhitelist(address _user) public override {\n        IRCFactory factory = IRCFactory(factoryAddress);\n        require(factory.isGovernor(msgSender()), \"Not authorised\");\n        isAllowed[_user] = !isAllowed[_user];\n    }\n\n    /// @notice Add multiple users to the whitelist\n    function batchAddToWhitelist(address[] calldata _users) public override {\n        for (uint256 index = 0; index < _users.length; index++) {\n            addToWhitelist(_users[index]);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    function setFactoryAddress(address _newFactory) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newFactory != address(0), \"Must set an address\");\n        factoryAddress = _newFactory;\n    }\n\n    function setOrderbookAddress(address _newOrderbook) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newOrderbook != address(0), \"Must set an address\");\n        orderbook = IRCOrderbook(_newOrderbook);\n    }\n\n    function setNftHubAddress(address _NFTHubAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_NFTHubAddress != address(0), \"Must set an address\");\n        nfthub = IRCNftHubL2(_NFTHubAddress);\n    }\n\n    function setTokenAddress(address _newToken) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    function changeUberOwner(address _newUberOwner) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0), \"Must set an address\");\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract (newRental) or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        public\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(isAllowed[msgSender()], \"Not in whitelist\");\n        }\n        erc20.transferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        if (\n            (user[_user].deposit + _amount) >\n            (user[_user].bidRate / minRentalDayDivisor)\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // stpe 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.transfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            isForeclosed[_msgSender] = true;\n            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(\n                _msgSender\n            );\n            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount) external override {\n        erc20.transferFrom(msgSender(), address(this), _amount);\n        if (_amount > marketBalanceDiscrepancy) {\n            marketBalanceDiscrepancy = 0;\n        } else {\n            marketBalanceDiscrepancy -= _amount;\n        }\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            marketBalanceDiscrepancy += _amount - marketBalance;\n            _amount -= (_amount - marketBalance);\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n\n        return true;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        assert(marketPot[msgSender()] >= _amount);\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        onlyMarkets\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        if (\n            isForeclosed[_user] &&\n            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.transferFrom(_sponsor, address(this), _amount);\n        marketPot[msgSender()] += _amount;\n        totalMarketPots += _amount;\n        return true;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyMarkets\n        returns (bool)\n    {\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        if (user[_user].lastRentCalc == 0) {\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n        return true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice provides the sum total of a users bids accross all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyOrderbook {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !isMarket[_newOwner]\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed =\n                    rentOwedBetweenTimestmaps(\n                        block.timestamp,\n                        _timeOwnershipChanged,\n                        _newPrice\n                    );\n                collectRentUser(_newOwner, block.timestamp);\n\n                // they have enough funds, just collect the extra\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /// @dev called when all a user's bids have been removed, disables foreclosure state\n    function resetUser(address _user) external override onlyOrderbook {\n        isForeclosed[_user] = false;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calcualtion and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calcualtes the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestmaps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the amount of deposit a user is able to withdraw\n    /// @notice ..after considering rent due to be paid\n    /// @param _user the user to query\n    function depositAbleToWithdraw(address _user)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 collection = rentOwedUser(_user, block.timestamp);\n        if (collection >= user[_user].deposit) {\n            return 0;\n        } else {\n            return uint256(user[_user].deposit) - (collection);\n        }\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)\n            //                   = (deposit * 1day) / totalUserDailyRent\n            uint256 timeLeftOfDeposit =\n                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard =\n                user[_user].lastRentCalc + timeLeftOfDeposit;\n\n            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {\n                // calculate how long they can own the new card for\n                uint256 _rentAlreadyOwed =\n                    rentOwedBetweenTimestmaps(\n                        user[_user].lastRentCalc,\n                        _timeOfNewBid,\n                        totalUserDailyRent\n                    );\n                uint256 _depositAtTimeOfNewBid =\n                    user[_user].deposit - _rentAlreadyOwed;\n                uint256 _timeLeftOfDepositWithNewBid =\n                    (_depositAtTimeOfNewBid * 1 days) /\n                        (totalUserDailyRent + _newBid);\n                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            // if no rentals they'll foreclose after the heat death of the universe\n            return type(uint256).max;\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        assert(_timeToCollectTo != 0);\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts =\n                    ((_timeToCollectTo - previousCollectionTime) *\n                        uint256(user[_user].deposit)) / rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepsitLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets availiable balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRealitio.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // CONTRACT SETUP\n    /// @dev = how many outcomes/teams/NFTs etc\n    uint256 public numberOfCards;\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n    uint256 public constant MIN_RENTAL_VALUE = 1 ether;\n    States public override state;\n    /// @dev type of event.\n    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}\n    Mode public mode;\n    /// @dev so the Factory can check it's a market\n    bool public constant override isMarket = true;\n    /// @dev counts the total NFTs minted across all events at the time market created\n    /// @dev nft tokenId = card Id + totalNftMintCount\n    uint256 public totalNftMintCount;\n\n    // CONTRACT VARIABLES\n    IRCTreasury public treasury;\n    IRCFactory public factory;\n    IRCNftHubL2 public nfthub;\n    IRCOrderbook public orderbook;\n\n    // PRICE, DEPOSITS, RENT\n    /// @dev in wei\n    mapping(uint256 => uint256) public cardPrice;\n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping(address => uint256) public rentCollectedPerUser;\n    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout\n    mapping(uint256 => uint256) public rentCollectedPerCard;\n    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout\n    mapping(address => mapping(uint256 => uint256))\n        public rentCollectedPerUserPerCard;\n    /// @dev an easy way to track the above across all cards\n    uint256 public totalRentCollected;\n    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)\n    mapping(address => uint256) public exitedTimestamp;\n\n    // PARAMETERS\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public minimumPriceIncreasePercent;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public minRentalDayDivisor;\n    /// @dev maximum number of times to calcualte rent in one transaction\n    uint256 public maxRentIterations;\n\n    // TIME\n    /// @dev how many seconds each user has held each card for, for determining winnings\n    mapping(uint256 => mapping(address => uint256)) public timeHeld;\n    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n    mapping(uint256 => uint256) public totalTimeHeld;\n    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n    mapping(uint256 => uint256) public timeLastCollected;\n    /// @dev to track the max timeheld of each card (for giving NFT to winner)\n    mapping(uint256 => uint256) public longestTimeHeld;\n    /// @dev to track who has owned it the most (for giving NFT to winner)\n    mapping(uint256 => address) public longestOwner;\n    /// @dev to track the card timeHeldLimit for the current owner\n    mapping(uint256 => uint256) public cardTimeLimit;\n\n    // TIMESTAMPS\n    /// @dev when the market opens\n    uint32 public marketOpeningTime;\n    /// @dev when the market locks\n    uint32 public override marketLockingTime;\n    /// @dev when the question can be answered on realitio\n    /// @dev only needed for circuit breaker\n    uint32 public oracleResolutionTime;\n\n    // PAYOUT VARIABLES\n    uint256 public winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping(address => bool) public userAlreadyWithdrawn;\n    /// @dev prevent users claiming twice\n    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool\n    /// @dev the artist\n    address public artistAddress;\n    uint256 public artistCut;\n    bool public artistPaid;\n    /// @dev the affiliate\n    address public affiliateAddress;\n    uint256 public affiliateCut;\n    bool public affiliatePaid;\n    /// @dev the winner\n    uint256 public winnerCut;\n    /// @dev the market creator\n    address public marketCreatorAddress;\n    uint256 public creatorCut;\n    bool public creatorPaid;\n    /// @dev card specific recipients\n    address[] public cardAffiliateAddresses;\n    uint256 public cardAffiliateCut;\n    mapping(uint256 => bool) public cardAffiliatePaid;\n\n    // ORACLE VARIABLES\n    bytes32 public questionId;\n    bool public questionFinalised;\n    address public arbitrator;\n    uint32 public timeout;\n    IRealitio public realitio;\n    address public _realitioAddress;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);\n    event LogRentCollection(\n        uint256 rentCollected,\n        uint256 indexed newTimeHeld,\n        uint256 indexed cardId,\n        address indexed owner\n    );\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(\n        address indexed paidTo,\n        uint256 indexed amountPaid\n    );\n    event LogRentReturned(\n        address indexed returnedTo,\n        uint256 indexed amountReturned\n    );\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(\n        address indexed owner,\n        uint256 newLimit,\n        uint256 cardId\n    );\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogNftUpgraded(\n        uint256 indexed currentTokenId,\n        uint256 indexed newTokenId\n    );\n    event LogPayoutDetails(\n        address indexed artistAddress,\n        address marketCreatorAddress,\n        address affiliateAddress,\n        address[] cardAffiliateAddresses,\n        uint256 indexed artistCut,\n        uint256 winnerCut,\n        uint256 creatorCut,\n        uint256 affiliateCut,\n        uint256 cardAffiliateCut\n    );\n    event LogSettings(\n        uint256 indexed minRentalDayDivisor,\n        uint256 indexed minimumPriceIncreasePercent\n    );\n    event LogLongestOwner(uint256 cardId, address longestOwner);\n    event LogQuestionPostedToOracle(\n        address indexed marketAddress,\n        bytes32 indexed questionId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfCards how many Cards in this market\n    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _marketCreatorAddress where to send market creator's cut, if any\n    /// @param _realitioQuestion the question posted to the Oracle\n    function initialize(\n        uint256 _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfCards,\n        uint256 _totalNftMintCount,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion\n    ) external override initializer {\n        assert(_mode <= 2);\n\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsMarket\", \"1\");\n\n        // external contract variables:\n        factory = IRCFactory(msgSender());\n        treasury = factory.treasury();\n        nfthub = factory.nfthub();\n        orderbook = factory.orderbook();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();\n        maxRentIterations = factory.maxRentIterations();\n\n        // initialiiize!\n        winningOutcome = MAX_UINT256; // default invalid\n\n        // assign arguments to public variables\n        mode = Mode(_mode);\n        numberOfCards = _numberOfCards;\n        totalNftMintCount = _totalNftMintCount;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n        (realitio, arbitrator, timeout) = factory.getOracleSettings();\n\n        // reduce artist cut to zero if zero adddress set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero adddress set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array.\n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfCards) {\n            for (uint256 i = 0; i < _numberOfCards; i++) {\n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {\n            winnerCut =\n                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -\n                cardAffiliateCut;\n        }\n\n        // post question to Oracle\n        questionFinalised = false;\n        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);\n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime <= block.timestamp) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(\n            _artistAddress,\n            _marketCreatorAddress,\n            _affiliateAddress,\n            cardAffiliateAddresses,\n            artistCut,\n            winnerCut,\n            creatorCut,\n            affiliateCut,\n            cardAffiliateCut\n        );\n        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            MODIFIERS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {\n            _incrementState();\n        }\n        _;\n    }\n\n    /// @notice automatically locks market if appropriate\n    modifier autoLock() {\n        _;\n        if (marketLockingTime <= block.timestamp) {\n            lockMarket();\n        }\n    }\n\n    /// @dev can only be called by Card owners\n    modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     NFT HUB CONTRACT CALLS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice send NFT to mainnet\n    /// @dev upgrades not possible if market not approved\n    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {\n        _checkState(States.WITHDRAW);\n        require(\n            !factory.trapIfUnapproved() ||\n                factory.isMarketApproved(address(this)),\n            \"Upgrade blocked\"\n        );\n        uint256 _tokenId = _card + totalNftMintCount;\n        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n        nfthub.withdrawWithMetadata(_tokenId);\n        emit LogNftUpgraded(_card, _tokenId);\n    }\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.ownerOf(_tokenId);\n    }\n\n    /// @notice gets tokenURI via their Card Id\n    function tokenURI(uint256 _cardId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.tokenURI(_tokenId);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called internally during contract open state\n    function _transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId\n    ) internal {\n        require(\n            _from != address(0) && _to != address(0),\n            \"Cannot send to/from zero address\"\n        );\n        uint256 _tokenId = _cardId + totalNftMintCount;\n\n        assert(nfthub.transferNft(_from, _to, _tokenId));\n        emit LogNewOwner(_cardId, _to);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called externaly by Orderbook during contract open state\n    function transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external override {\n        require(msgSender() == address(orderbook), \"Not orderbook\");\n        _checkState(States.OPEN);\n        if (_to != _from) {\n            _transferCard(_from, _to, _cardId);\n        }\n        cardTimeLimit[_cardId] = _timeLimit;\n        cardPrice[_cardId] = _price;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        ORACLE FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev called within initializer only\n    function _postQuestionToOracle(\n        string calldata _question,\n        uint32 _oracleResolutionTime\n    ) internal {\n        questionId = realitio.askQuestion(\n            2,\n            _question,\n            arbitrator,\n            timeout,\n            _oracleResolutionTime,\n            0\n        );\n        emit LogQuestionPostedToOracle(address(this), questionId);\n    }\n\n    /// @notice has the oracle finalised\n    function isFinalized() public view returns (bool) {\n        bool _isFinalized = realitio.isFinalized(questionId);\n        return _isFinalized;\n    }\n\n    /// @dev sets the winning outcome\n    /// @dev market.setWinner() will revert if done twice, because wrong state\n    function getWinnerFromOracle() external {\n        require(isFinalized(), \"Oracle not finalised\");\n        // check market state to prevent market closing early\n        require(marketLockingTime <= block.timestamp, \"Market not finished\");\n        questionFinalised = true;\n        bytes32 _winningOutcome = realitio.resultFor(questionId);\n        // call the market\n        setWinner(uint256(_winningOutcome));\n    }\n\n    /// @dev admin override of the oracle\n    function setAmicableResolution(uint256 _winningOutcome) external {\n        require(msgSender() == factory.owner(), \"Not authorised\");\n        questionFinalised = true;\n        setWinner(_winningOutcome);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551  MARKET RESOLUTION FUNCTIONS    \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice checks whether the competition has ended, if so moves to LOCKED state\n    /// @dev can be called by anyone\n    /// @dev public because called within autoLock modifier & setWinner\n    function lockMarket() public {\n        _checkState(States.OPEN);\n        require(\n            marketLockingTime <= block.timestamp,\n            \"Market has not finished\"\n        );\n        // do a final rent collection before the contract is locked down\n\n        if (collectRentAllCards()) {\n            orderbook.closeMarket();\n            _incrementState();\n\n            for (uint256 i; i < numberOfCards; i++) {\n                // bring the cards back to the market so the winners get the satisfcation of claiming them\n                _transferCard(ownerOf(i), address(this), i);\n                emit LogLongestOwner(i, longestOwner[i]);\n            }\n            emit LogContractLocked(true);\n        }\n    }\n\n    /// @notice called by getWinnerFromOracle, sets the winner\n    /// @param _winningOutcome the index of the winning card\n    function setWinner(uint256 _winningOutcome) internal {\n        if (state == States.OPEN) {\n            // change the locking time to allow lockMarket to lock\n            marketLockingTime = SafeCast.toUint32(block.timestamp);\n            lockMarket();\n        }\n        if (state == States.LOCKED) {\n            // get the winner. This will revert if answer is not resolved.\n            winningOutcome = _winningOutcome;\n            _incrementState();\n            emit LogWinnerKnown(winningOutcome);\n        }\n    }\n\n    /// @notice pays out winnings, or returns funds\n    function withdraw() external {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], \"Already withdrawn\");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (totalTimeHeld[winningOutcome] > 0) {\n            _payoutWinnings();\n        } else {\n            _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    /// @param _card the id of the card, the index\n    function claimCard(uint256 _card) external {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(!userAlreadyClaimed[_card][msgSender()], \"Already claimed\");\n        userAlreadyClaimed[_card][msgSender()] = true;\n        require(longestOwner[_card] == msgSender(), \"Not longest owner\");\n        _transferCard(ownerOf(_card), longestOwner[_card], _card);\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer = 0;\n        uint256 _remainingCut =\n            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -\n                winnerCut) - creatorCut;\n        // calculate longest owner's extra winnings, if relevant\n        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {\n            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);\n        }\n        uint256 _remainingPot = 0;\n        if (mode == Mode.SAFE_MODE) {\n            // return all rent paid on winning card\n            _remainingPot =\n                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *\n                    _remainingCut) /\n                (1000);\n            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][\n                winningOutcome\n            ];\n        } else {\n            // calculate normal winnings, if any\n            _remainingPot = (totalRentCollected * _remainingCut) / (1000);\n        }\n        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];\n        uint256 _numerator = _remainingPot * _winnersTimeHeld;\n        _winningsToTransfer =\n            _winningsToTransfer +\n            (_numerator / totalTimeHeld[winningOutcome]);\n        require(_winningsToTransfer > 0, \"Not a winner\");\n        _payout(msgSender(), _winningsToTransfer);\n        emit LogWinningsPaid(msgSender(), _winningsToTransfer);\n    }\n\n    /// @notice returns all funds to users in case of invalid outcome\n    function _returnRent() internal {\n        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)\n        uint256 _remainingCut =\n            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;\n        uint256 _rentCollected = rentCollectedPerUser[msgSender()];\n        require(_rentCollected > 0, \"Paid no rent\");\n        uint256 _rentCollectedAdjusted =\n            (_rentCollected * _remainingCut) / (1000);\n        _payout(msgSender(), _rentCollectedAdjusted);\n        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);\n    }\n\n    /// @notice all payouts happen through here\n    function _payout(address _recipient, uint256 _amount) internal {\n        assert(treasury.payout(_recipient, _amount));\n    }\n\n    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)\n    /// @dev they are not called within setWinner() because of the risk of an\n    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings\n    /// @dev [hangover from when ether was native currency, keeping in case we return to this]\n\n    /// @notice pay artist\n    function payArtist() external {\n        _checkState(States.WITHDRAW);\n        require(!artistPaid, \"Artist already paid\");\n        artistPaid = true;\n        _processStakeholderPayment(artistCut, artistAddress);\n    }\n\n    /// @notice pay market creator\n    function payMarketCreator() external {\n        _checkState(States.WITHDRAW);\n        require(totalTimeHeld[winningOutcome] > 0, \"No winner\");\n        require(!creatorPaid, \"Creator already paid\");\n        creatorPaid = true;\n        _processStakeholderPayment(creatorCut, marketCreatorAddress);\n    }\n\n    /// @notice pay affiliate\n    function payAffiliate() external {\n        _checkState(States.WITHDRAW);\n        require(!affiliatePaid, \"Affiliate already paid\");\n        affiliatePaid = true;\n        _processStakeholderPayment(affiliateCut, affiliateAddress);\n    }\n\n    /// @notice pay card affiliate\n    /// @dev does not call _processStakeholderPayment because it works differently\n    function payCardAffiliate(uint256 _card) external {\n        _checkState(States.WITHDRAW);\n        require(!cardAffiliatePaid[_card], \"Card affiliate already paid\");\n        cardAffiliatePaid[_card] = true;\n        uint256 _cardAffiliatePayment =\n            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);\n        if (_cardAffiliatePayment > 0) {\n            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);\n            emit LogStakeholderPaid(\n                cardAffiliateAddresses[_card],\n                _cardAffiliatePayment\n            );\n        }\n    }\n\n    function _processStakeholderPayment(uint256 _cut, address _recipient)\n        internal\n    {\n        if (_cut > 0) {\n            uint256 _payment = (totalRentCollected * _cut) / (1000);\n            _payout(_recipient, _payment);\n            emit LogStakeholderPaid(_recipient, _payment);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             EXTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev basically functions that have _checkState(States.OPEN) on first line\n\n    /// @notice collects rent for all cards\n    /// @dev cannot be external because it is called within the lockMarket function, therefore public\n    function collectRentAllCards() public override returns (bool) {\n        _checkState(States.OPEN);\n        bool _success = true;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != address(this)) {\n                _success = _collectRent(i);\n            }\n            if (!_success) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice rent every Card at the minimum price\n    /// @param _maxSumOfPrices a limit to the sum of the bids to place\n    function rentAllCards(uint256 _maxSumOfPrices) external {\n        // check that not being front run\n        uint256 _actualSumOfPrices;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);\n        }\n        require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");\n\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint256 _newPrice;\n                if (cardPrice[i] > 0) {\n                    _newPrice =\n                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /\n                        100;\n                } else {\n                    _newPrice = MIN_RENTAL_VALUE;\n                }\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n    /// @notice to rent a Card\n    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate\n    /// @param _newPrice the price to rent the card for\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _startingPosition where to start looking to insert the bid into the orderbook\n    /// @param _card the index of the card to update\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) public autoUnlock() autoLock() {\n        if (state == States.OPEN) {\n            require(_newPrice >= MIN_RENTAL_VALUE, \"Price below min\");\n            require(_card < numberOfCards, \"Card does not exist\");\n\n            address _user = msgSender();\n\n            require(\n                exitedTimestamp[_user] != block.timestamp,\n                \"Cannot lose and re-rent in same block\"\n            );\n            require(\n                !treasury.marketPaused(address(this)) &&\n                    !treasury.globalPause(),\n                \"Rentals are disabled\"\n            );\n            bool _userStillForeclosed = treasury.isForeclosed(_user);\n            if (_userStillForeclosed) {\n                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);\n            }\n            if (!_userStillForeclosed) {\n                if (ownerOf(_card) == _user) {\n                    // the owner may only increase by more than X% or reduce their price\n                    uint256 _requiredPrice =\n                        (cardPrice[_card] *\n                            (minimumPriceIncreasePercent + 100)) / (100);\n                    require(\n                        _newPrice >= _requiredPrice ||\n                            _newPrice < cardPrice[_card],\n                        \"Invalid price\"\n                    );\n                }\n\n                // do some cleaning up before we collect rent or check their bidRate\n                orderbook.removeOldBids(_user);\n\n                _collectRent(_card);\n\n                // check sufficient deposit\n                uint256 _userTotalBidRate =\n                    treasury.userTotalBids(_user) -\n                        (orderbook.getBidValue(_user, _card)) +\n                        _newPrice;\n                require(\n                    treasury.userDeposit(_user) >=\n                        _userTotalBidRate / minRentalDayDivisor,\n                    \"Insufficient deposit\"\n                );\n\n                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n                // replaces _newBid and _updateBid\n                orderbook.addBidToOrderbook(\n                    _user,\n                    _card,\n                    _newPrice,\n                    _timeHeldLimit,\n                    _startingPosition\n                );\n\n                assert(treasury.updateLastRentalTime(_user));\n            }\n        }\n    }\n\n    function _checkTimeHeldLimit(uint256 _timeHeldLimit)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_timeHeldLimit == 0) {\n            return 0;\n        } else {\n            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;\n            require(_timeHeldLimit >= _minRentalTime, \"Limit too low\");\n            return _timeHeldLimit;\n        }\n    }\n\n    /// @notice to change your timeHeldLimit without having to re-rent\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _card the index of the card to update\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external\n    {\n        _checkState(States.OPEN);\n        address _user = msgSender();\n\n        if (_collectRent(_card)) {\n            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);\n\n            if (ownerOf(_card) == _user) {\n                cardTimeLimit[_card] = _timeHeldLimit;\n            }\n\n            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);\n        }\n    }\n\n    /// @notice stop renting all cards\n    function exitAll() external override {\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            exit(i);\n        }\n    }\n\n    /// @notice stop renting a card and/or remove from orderbook\n    /// @dev public because called by exitAll()\n    /// @dev doesn't need to be current owner so user can prevent ownership returning to them\n    /// @dev does not apply minimum rental duration, because it returns ownership to the next user\n    /// @param _card The card index to exit\n    function exit(uint256 _card) public override {\n        _checkState(States.OPEN);\n        address _msgSender = msgSender();\n\n        // block frontrunning attack\n        exitedTimestamp[_msgSender] = block.timestamp;\n\n        // collectRent first\n        _collectRent(_card);\n\n        if (ownerOf(_card) == _msgSender) {\n            // if current owner, find a new one\n            orderbook.findNewOwner(_card, block.timestamp);\n            assert(!orderbook.bidExists(_msgSender, address(this), _card));\n        } else {\n            // if not owner, just delete from orderbook\n            if (orderbook.bidExists(_msgSender, address(this), _card)) {\n                orderbook.removeBidFromOrderbook(_msgSender, _card);\n            }\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by user, sponsor is msgSender\n    function sponsor(uint256 _amount) external override {\n        address _creator = msgSender();\n        treasury.checkSponsorship(_creator, _amount);\n        _sponsor(_creator, _amount);\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n    /// @dev actually processes the sponsorship\n    function _sponsor(address _sponsorAddress, uint256 _amount) internal {\n        _checkNotState(States.LOCKED);\n        _checkNotState(States.WITHDRAW);\n        require(_amount > 0, \"Must send something\");\n        // send tokens to the Treasury\n        require(treasury.sponsor(_sponsorAddress, _amount));\n        totalRentCollected = totalRentCollected + _amount;\n        // just so user can get it back if invalid outcome\n        rentCollectedPerUser[_sponsorAddress] =\n            rentCollectedPerUser[_sponsorAddress] +\n            _amount;\n        // allocate equally to each card, in case card specific affiliates\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            rentCollectedPerCard[i] =\n                rentCollectedPerCard[i] +\n                (_amount / numberOfCards);\n        }\n        emit LogSponsor(_sponsorAddress, _amount);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             INTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice collects rent for a specific card\n    /// @dev also calculates and updates how long the current user has held the card for\n    /// @dev is not a problem if called externally, but making internal over public to save gas\n    function _collectRentAction(uint256 _card)\n        internal\n        returns (bool shouldContinue)\n    {\n        address _user = ownerOf(_card);\n        uint256 _timeOfThisCollection = block.timestamp;\n\n        // don't collect rent beyond the locking time\n        if (marketLockingTime <= block.timestamp) {\n            _timeOfThisCollection = marketLockingTime;\n        }\n\n        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)\n        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)\n        if (\n            _user != address(this) &&\n            timeLastCollected[_card] < _timeOfThisCollection\n        ) {\n            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet\n            uint256 _timeUserForeclosed =\n                treasury.collectRentUser(_user, block.timestamp);\n\n            // Calculate the card timeLimitTimestamp\n            uint256 _cardTimeLimitTimestamp =\n                timeLastCollected[_card] + cardTimeLimit[_card];\n\n            // input bools\n            bool _foreclosed = _timeUserForeclosed != 0;\n            bool _limitHit =\n                cardTimeLimit[_card] != 0 &&\n                    _cardTimeLimitTimestamp < block.timestamp;\n            bool _marketLocked = marketLockingTime <= block.timestamp;\n\n            // outputs\n            bool _newOwner;\n            uint256 _refundTime; // seconds of rent to refund the user\n\n            /* Permutations of the events: Foreclosure, Time limit and Market Locking\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n            \u2502Case       \u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524\n            \u2502Foreclosure\u25020\u25020\u25020\u25020\u25021\u25021\u25021\u25021\u2502\n            \u2502Time Limit \u25020\u25020\u25021\u25021\u25020\u25020\u25021\u25021\u2502\n            \u2502Market Lock\u25020\u25021\u25020\u25021\u25020\u25021\u25020\u25021\u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n            */\n\n            if (!_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 1\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN simple rent collect, same owner\n                _timeOfThisCollection = _timeOfThisCollection;\n                _newOwner = false;\n                _refundTime = 0;\n            } else if (!_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 2\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN refund rent between locking and now\n                _timeOfThisCollection = marketLockingTime;\n                _newOwner = false;\n                _refundTime = block.timestamp - marketLockingTime;\n            } else if (!_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 3\n                // didn't foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN refund rent between time limit and now\n                _timeOfThisCollection = _cardTimeLimitTimestamp;\n                _newOwner = true;\n                _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n            } else if (!_foreclosed && _limitHit && _marketLocked) {\n                // CASE 4\n                // didn't foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN refund rent between the earliest event and now\n                if (_cardTimeLimitTimestamp < marketLockingTime) {\n                    // time limit hit before market locked\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked before time limit hit\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 5\n                // did foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN rent OK, find new owner\n                _timeOfThisCollection = _timeUserForeclosed;\n                _newOwner = true;\n                _refundTime = 0;\n            } else if (_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 6\n                // did foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN if foreclosed first rent ok, otherwise refund after locking\n                if (_timeUserForeclosed < marketLockingTime) {\n                    // user foreclosed before market locked\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // market locked before user foreclosed\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 7\n                // did foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN if foreclosed first rent ok, otherwise refund after limit\n                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {\n                    // user foreclosed before time limit\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // time limit hit before user foreclosed\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                }\n            } else {\n                // CASE 8\n                // did foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN (\u256f\u00b0\u76ca\u00b0)\u256f\u5f61\u253b\u2501\u253b\n                if (\n                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&\n                    _timeUserForeclosed < marketLockingTime\n                ) {\n                    // user foreclosed first (or at same time as time limit)\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else if (\n                    _cardTimeLimitTimestamp < _timeUserForeclosed &&\n                    _cardTimeLimitTimestamp < marketLockingTime\n                ) {\n                    // time limit hit first\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked first\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = _timeUserForeclosed - marketLockingTime;\n                }\n            }\n            if (_refundTime != 0) {\n                uint256 _refundAmount =\n                    (_refundTime * cardPrice[_card]) / 1 days;\n                treasury.refundUser(_user, _refundAmount);\n            }\n            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens\n\n            if (_newOwner) {\n                orderbook.findNewOwner(_card, _timeOfThisCollection);\n                return true;\n            }\n        } else {\n            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking\n            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental\n            timeLastCollected[_card] = _timeOfThisCollection;\n        }\n        return false;\n    }\n\n    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls\n    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit\n    function _collectRent(uint256 _card)\n        internal\n        returns (bool didUpdateEverything)\n    {\n        uint32 counter = 0;\n        bool shouldContinue = true;\n        while (counter < maxRentIterations && shouldContinue) {\n            shouldContinue = _collectRentAction(_card);\n            counter++;\n        }\n        return !shouldContinue;\n    }\n\n    /// @dev processes actual rent collection and updates the state\n    function _processRentCollection(\n        address _user,\n        uint256 _card,\n        uint256 _timeOfCollection\n    ) internal {\n        uint256 _rentOwed =\n            (cardPrice[_card] *\n                (_timeOfCollection - timeLastCollected[_card])) / 1 days;\n        treasury.payRent(_rentOwed);\n        uint256 _timeHeldToIncrement =\n            (_timeOfCollection - timeLastCollected[_card]);\n\n        // if the user has a timeLimit, adjust it as necessary\n        if (cardTimeLimit[_card] != 0) {\n            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);\n            cardTimeLimit[_card] -= _timeHeldToIncrement;\n        }\n        timeHeld[_card][_user] += _timeHeldToIncrement;\n        totalTimeHeld[_card] += _timeHeldToIncrement;\n        rentCollectedPerUser[_user] += _rentOwed;\n        rentCollectedPerCard[_card] += _rentOwed;\n        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;\n        totalRentCollected += _rentOwed;\n        timeLastCollected[_card] = _timeOfCollection;\n\n        // longest owner tracking\n        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {\n            longestTimeHeld[_card] = timeHeld[_card][_user];\n            longestOwner[_card] = _user;\n        }\n        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);\n    }\n\n    function _checkState(States currentState) internal view {\n        require(state == currentState, \"Incorrect state\");\n    }\n\n    function _checkNotState(States currentState) internal view {\n        require(state != currentState, \"Incorrect state\");\n    }\n\n    /// @dev should only be called thrice\n    function _incrementState() internal {\n        assert(uint256(state) < 4);\n        state = States(uint256(state) + (1));\n        emit LogStateChange(uint256(state));\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        CIRCUIT BREAKER          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev in case Oracle never resolves for any reason\n    /// @dev does not set a winner so same as invalid outcome\n    /// @dev market does not need to be locked, just in case lockMarket bugs out\n    function circuitBreaker() external {\n        require(\n            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),\n            \"Too early\"\n        );\n        _incrementState();\n        orderbook.closeMarket();\n        state = States.WITHDRAW;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCFactory.sol",
            "RCTreasury.sol",
            "RCMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nmodifier balancedBooks {\n    _;\n    // using = not == in case anyone sends tokens direct to contract\n    require(\n        erc20.balanceOf(address(this)) =\n            totalDeposits + marketBalance + totalMarketPots,\n        \"Books are unbalanced!\"\n    );\n}\n",
                    "//solidity\nfunction topupMarketBalance(uint256 _amount) external override {\n    erc20.transferFrom(msgSender(), address(this), _amount);\n    if (_amount  marketBalanceDiscrepancy) {\n        marketBalanceDiscrepancy = 0;\n    } else {\n        marketBalanceDiscrepancy -= _amount;\n    }\n    marketBalance += _amount;\n}\n"
                ],
                "Type": " Unchecked ERC20 transfers can cause lock up",
                "Description": "\nSome major tokens went live before ERC20 was finalized, resulting in a discrepancy whether the transfer functions should (A) return a boolean or (B) revert/fail on error. The current best practice is that they should revert, but return \u201ctrue\u201d on success. However, not every token claiming ERC20-compatibility is doing this \u2014 some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.\n\nToday many tools, including OpenZeppelin, offer a wrapper for \u201csafe ERC20 transfer\u201d(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol):\n\nRealityCards is not using such a wrapper, but instead tries to ensure successful transfers via the balancedBooks modifier:\n\nsolidity\nmodifier balancedBooks {\n    _;\n    // using = not == in case anyone sends tokens direct to contract\n    require(\n        erc20.balanceOf(address(this)) =\n            totalDeposits + marketBalance + totalMarketPots,\n        \"Books are unbalanced!\"\n    );\n}\n\n\nThis modifier is present on most functions, but is missing on topupMarketBalance:\nsolidity\nfunction topupMarketBalance(uint256 _amount) external override {\n    erc20.transferFrom(msgSender(), address(this), _amount);\n    if (_amount  marketBalanceDiscrepancy) {\n        marketBalanceDiscrepancy = 0;\n    } else {\n        marketBalanceDiscrepancy -= _amount;\n    }\n    marketBalance += _amount;\n}\n\n\nIn the case where an ERC20 token which is not reverting on failures is used, a malicious actor could call topupMarketBalance with a failing transfer, but also move the value of marketBalance above the actual holdings. After this, deposit, withdrawDeposit, payRent, payout, sponsor, etc. could be locked up and always failing with \u201cBooks are unbalanced\u201d.\n\nAnyone can call topupMarketBalance with some unrealistically large number, so that marketBalance does not overflow, but is above the actually helping balances. This is only possible if the underlying ERC20 used is not reverting on failures, but is returning \u201cfalse\u201d instead.\n\nRecommended Steps:\n1. Use something like OpenZeppelin\u2019s SafeERC20\n2. Set up an allow list for tokens, which are knowingly safe\n3. Consider a different approach to the balancedBooks modifier\n\nSplidge (Reality Cards) confirmed(https://github.com/code-423n4/2021-06-realitycards-findings/issues/2#issuecomment-860518142):\n  The particular ERC20 contracts we are using don't have this issue. However for futureproofing in the event we change ERC20 tokens we will implement the recommended mitigation 1 and start using OpenZeppelin\u2019s SafeERC20.\n\nSplidge (Reality Cards) resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/2#issuecomment-863130135):\n  Fix implemented here(https://github.com/RealityCards/RealityCards-Contracts/commit/6b2c25bea664efe0f573d8d1b8118ecad19a47ff)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-03",
                "Location": [
                    "deposit",
                    "refundUser()",
                    "withdrawDeposit",
                    "balancedBooks",
                    "payout",
                    "payRent",
                    "topupMarketBalance()"
                ],
                "Type": " Missing  balancedBooks  modifier could result in failed system insolvency detection",
                "Description": "\nThe balancedBooks modifier is used to \u201ccheck that funds haven't gone missing during this function call\u201d and is applied to deposit, withdrawDeposit, payRent, payout and sponsor Treasury functions which move funds in and out of the Treasury or adjust its market/user balances.\n\nHowever, this modifier is missing in the refundUser() and topupMarketBalance() functions which also perform similar actions. The impact is that any miscalculations in these functions will lead to the system becoming insolvent.\n\n",
                "Repair": "Recommend adding modifier to the two functions above where it is missing.\n\nSplidge (Reality Cards) confirmed and resolved in a duplicate issue(https://github.com/code-423n4/2021-06-realitycards-findings/issues/23#issuecomment-864906080):\n implemented here(https://github.com/RealityCards/RealityCards-Contracts/commit/6bb7b729fdc6f58a4b39c20ad3b24a61b5946cdf)\n\n_Note: Additional conversation regarding this vulnerability can be found here(https://github.com/code-423n4/2021-06-realitycards-findings/issues/23)_\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRealitio.sol\";\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    //\u2261\u2261\u2261\u2261\u2261\u2261\u2261 CONTRACT VARIABLES \u2261\u2261\u2261\u2261\u2261\u2261\u2261//\n    IRCTreasury public override treasury;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRealitio public realitio;\n\n    ///// CONTRACT ADDRESSES /////\n    /// @dev reference contract\n    address public referenceContractAddress;\n    /// @dev increments each time a new reference contract is added\n    uint256 public referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(uint256 => address[]) public marketAddresses;\n    mapping(address => bool) public mappingOfMarkets;\n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum tokens that must be sent when creating market which forms iniital pot\n    uint256 public sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public maximumDuration;\n    /// @dev list of governors\n    mapping(address => bool) public governors;\n    /// @dev if false, anyone can create markets\n    bool public marketCreationGovernorsOnly = true;\n    /// @dev if false, anyone can be an affiliate\n    bool public approvedAffilliatesOnly = true;\n    /// @dev if false, anyone can be an artist\n    bool public approvedArtistsOnly = true;\n    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity\n    bool public override trapIfUnapproved = true;\n    /// @dev high level owner who can change the factory address\n    address public uberOwner;\n    /// @dev the maximum number of rent collections to perform in a single transaction\n    uint256 public override maxRentIterations;\n    /// @dev the address of the arbitrator\n    address public arbitrator;\n    /// @dev the time allowed to dispute the oracle answer\n    uint32 public timeout;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public override isMarketApproved;\n    /// @dev allows artist to receive cut of total rent\n    mapping(address => bool) public isArtistApproved;\n    /// @dev allows affiliate to receive cut of total rent\n    mapping(address => bool) public isAffiliateApproved;\n    /// @dev allows card affiliate to receive cut of total rent\n    mapping(address => bool) public isCardAffiliateApproved;\n    /// @dev a limit to the number of NFTs to mint per market\n    uint256 public nftMintingLimit;\n\n    ///// OTHER /////\n    /// @dev counts the total NFTs minted across all events\n    /// @dev ... so the appropriate token id is used when upgrading to mainnet\n    uint256 public totalNftMintCount;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogMarketCreated1(\n        address contractAddress,\n        address treasuryAddress,\n        address nftHubAddress,\n        uint256 referenceContractVersion\n    );\n    event LogMarketCreated2(\n        address contractAddress,\n        uint32 mode,\n        string[] tokenURIs,\n        string ipfsHash,\n        uint32[] timestamps,\n        uint256 totalNftMintCount\n    );\n    event LogMarketApproved(address market, bool hidden);\n    event LogAdvancedWarning(uint256 _newAdvancedWarning);\n    event LogMaximumDuration(uint256 _newMaximumDuration);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev Treasury must be deployed before Factory\n    constructor(\n        IRCTreasury _treasuryAddress,\n        address _realitioAddress,\n        address _arbitratorAddress\n    ) {\n        require(address(_treasuryAddress) != address(0));\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise contract variable\n        treasury = _treasuryAddress;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate\n        setminimumPriceIncreasePercent(10); // 10%\n        setNFTMintingLimit(60); // current gas limit (12.5m) allows for 60 NFTs to be minted\n        setMaxRentIterations(35); // limit appears to be 41, set safe at 35 for now.\n        // oracle\n        setArbitrator(_arbitratorAddress);\n        setRealitioAddress(_realitioAddress);\n        setTimeout(86400); // 24 hours\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          VIEW FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Fetch the address of the most recently created market\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return the address of the most recent market in the given mode\n    function getMostRecentMarket(uint256 _mode)\n        external\n        view\n        returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n    /// @notice Fetch all the market addresses for a given mode\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return an array of all markets in a given mode\n    function getAllMarkets(uint256 _mode)\n        external\n        view\n        returns (address[] memory)\n    {\n        return marketAddresses[_mode];\n    }\n\n    /// @notice Returns the currently set pot distribution\n    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates\n    function getPotDistribution()\n        external\n        view\n        override\n        returns (uint256[5] memory)\n    {\n        return potDistribution;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev include the owner as a governor\n    modifier onlyGovernors() {\n        require(\n            governors[msgSender()] || owner() == msgSender(),\n            \"Not approved\"\n        );\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - OWNER (SETUP)  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n\n    /// @notice where the NFTs live\n    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but\n    /// @dev ... keeping flexible in case returning to previous contract\n    /// @param _newAddress the address to set\n    /// @param _newNftMintCount the number of NFTs this contract has minted, in order to keep them unique\n    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)\n        external\n        onlyOwner\n    {\n        require(address(_newAddress) != address(0));\n        nfthub = _newAddress;\n        totalNftMintCount = _newNftMintCount;\n    }\n\n    /// @notice set the address of the orderbook contract\n    /// @param _newAddress the address to set\n    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {\n        require(address(_newAddress) != address(0));\n        orderbook = _newAddress;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase & pot distribution emitted by Market.\n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice update stakeholder payouts\n    /// @dev in basis points (so 1000 = 100%)\n    /// @param _artistCut The artist that designed the card\n    /// @param _winnerCut Extra cut for the longest owner\n    /// @param _creatorCut The creator of the market\n    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts\n    /// @param _cardAffiliateCut An affiliate cur for specific cards\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) public onlyOwner {\n        require(\n            _artistCut +\n                _winnerCut +\n                _creatorCut +\n                _affiliateCut +\n                _cardAffiliateCut <=\n                1000,\n            \"Cuts too big\"\n        );\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%\n    function setminimumPriceIncreasePercent(uint256 _percentIncrease)\n        public\n        override\n        onlyOwner\n    {\n        minimumPriceIncreasePercent = _percentIncrease;\n    }\n\n    /// @notice A limit to the number of NFTs to mint per market\n    /// @dev to avoid gas limits\n    /// @param _mintLimit the limit to set\n    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {\n        nftMintingLimit = _mintLimit;\n    }\n\n    /// @notice A limit to the number of rent collections per transaction\n    /// @dev to avoid gas limits\n    /// @param _rentLimit the limit to set\n    function setMaxRentIterations(uint256 _rentLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxRentIterations = _rentLimit;\n    }\n\n    /// @notice set the address of the reality.eth contracts\n    /// @param _newAddress the address to set\n    function setRealitioAddress(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @notice address of the arbitrator, in case of continued disputes on reality.eth\n    /// @param _newAddress the address to set\n    function setArbitrator(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        arbitrator = _newAddress;\n    }\n\n    /// @notice set how long reality.eth waits for disputes before finalising\n    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs\n    function setTimeout(uint32 _newTimeout) public onlyOwner {\n        timeout = _newTimeout;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice whether or not only governors can create the market\n    function changeMarketCreationGovernorsOnly() external onlyOwner {\n        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;\n    }\n\n    /// @notice whether or not anyone can be an artist\n    function changeApprovedArtistsOnly() external onlyOwner {\n        approvedArtistsOnly = !approvedArtistsOnly;\n    }\n\n    /// @notice whether or not anyone can be an affiliate\n    function changeApprovedAffilliatesOnly() external onlyOwner {\n        approvedAffilliatesOnly = !approvedAffilliatesOnly;\n    }\n\n    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot\n    /// @param _amount the sponsorship required in wei\n    function setSponsorshipRequired(uint256 _amount) external onlyOwner {\n        sponsorshipRequired = _amount;\n    }\n\n    /// @notice if true, Cards in unapproved markets can't be upgraded\n    function changeTrapCardsIfUnapproved() external onlyOwner {\n        trapIfUnapproved = !trapIfUnapproved;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    /// @param _newAdvancedWarning the warning time to set in seconds\n    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {\n        advancedWarning = _newAdvancedWarning;\n        emit LogAdvancedWarning(_newAdvancedWarning);\n    }\n\n    /// @notice market closing time must be no more than this many seconds in the future\n    /// @param _newMaximumDuration the duration limit to set in seconds\n    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {\n        maximumDuration = _newMaximumDuration;\n        emit LogMaximumDuration(_newMaximumDuration);\n    }\n\n    /// @notice to fetch the owner of the contract\n    /// @dev used to specifiy the Ownable contract instead of the interface\n    function owner()\n        public\n        view\n        override(IRCFactory, Ownable)\n        returns (address)\n    {\n        return Ownable.owner();\n    }\n\n    /// @notice check if an address is a governor\n    /// @param _user the address to query\n    /// @return boolean return if true or false\n    function isGovernor(address _user) external view override returns (bool) {\n        return governors[_user];\n    }\n\n    // EDIT GOVERNORS\n\n    /// @notice add or remove an address from market creator whitelist\n    /// @param _governor the address to change approval for\n    /// @dev recommended to check isGovernor() afterwards to confirm the desired outcome\n    function changeGovernorApproval(address _governor) external onlyOwner {\n        require(_governor != address(0));\n        governors[_governor] = !governors[_governor];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - GOVERNORS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    /// @param _market the market address to change approval for\n    function changeMarketApproval(address _market) external onlyGovernors {\n        require(_market != address(0));\n        // check it's an RC contract\n        IRCMarket _marketToApprove = IRCMarket(_market);\n        assert(_marketToApprove.isMarket());\n        isMarketApproved[_market] = !isMarketApproved[_market];\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /// @notice artistAddress, passed in createMarket, must be approved\n    /// @param _artist the artist address to change approval for\n    function changeArtistApproval(address _artist) external onlyGovernors {\n        require(_artist != address(0));\n        isArtistApproved[_artist] = !isArtistApproved[_artist];\n    }\n\n    /// @notice affiliateAddress, passed in createMarket, must be approved\n    /// @param _affiliate the affiliate address to change approval for\n    function changeAffiliateApproval(address _affiliate)\n        external\n        onlyGovernors\n    {\n        require(_affiliate != address(0));\n        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];\n    }\n\n    /// @notice cardAffiliateAddress, passed in createMarket, must be approved\n    /// @param _affiliate the card affiliate address to change approval for\n    function changeCardAffiliateApproval(address _affiliate)\n        external\n        onlyGovernors\n    {\n        require(_affiliate != address(0));\n        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[\n            _affiliate\n        ];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    /// @notice change the reference contract for the contract logic\n    function setReferenceContractAddress(address _newAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newAddress != address(0));\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        assert(newContractVariable.isMarket());\n        // set\n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion += 1;\n    }\n\n    /// @notice to change or renounce ownership of the uberOwner role\n    function changeUberOwner(address _newUberOwner) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0));\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         MARKET CREATION         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Creates a new market with the given parameters\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    /// @param _sponsorship amount of sponsorship to create the market with\n    /// @return The address of the new market\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address) {\n        address _creator = msgSender();\n\n        // check sponsorship\n        require(\n            _sponsorship >= sponsorshipRequired,\n            \"Insufficient sponsorship\"\n        );\n        treasury.checkSponsorship(_creator, _sponsorship);\n\n        // check stakeholder addresses\n        // artist\n        if (approvedArtistsOnly) {\n            require(\n                isArtistApproved[_artistAddress] ||\n                    _artistAddress == address(0),\n                \"Artist not approved\"\n            );\n        }\n        // affiliate\n        if (approvedAffilliatesOnly) {\n            require(\n                isAffiliateApproved[_affiliateAddress] ||\n                    _affiliateAddress == address(0),\n                \"Affiliate not approved\"\n            );\n            // card affiliates\n            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {\n                require(\n                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||\n                        _cardAffiliateAddresses[i] == address(0),\n                    \"Card affiliate not approved\"\n                );\n            }\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(governors[_creator] || owner() == _creator, \"Not approved\");\n        }\n\n        // check timestamps\n        require(_timestamps.length == 3, \"Incorrect number of array elements\");\n        // check market opening time\n        if (advancedWarning != 0) {\n            require(\n                _timestamps[0] >= block.timestamp,\n                \"Market opening time not set\"\n            );\n            require(\n                _timestamps[0] - advancedWarning > block.timestamp,\n                \"Market opens too soon\"\n            );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(\n                _timestamps[1] < block.timestamp + maximumDuration,\n                \"Market locks too late\"\n            );\n        }\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(\n            _timestamps[1] + (1 weeks) > _timestamps[2] &&\n                _timestamps[1] <= _timestamps[2],\n            \"Oracle resolution time error\"\n        );\n\n        // check the number of NFTs to mint is within limits\n        require(\n            _tokenURIs.length <= nftMintingLimit,\n            \"Too many tokens to mint\"\n        );\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = Clones.clone(referenceContractAddress);\n        emit LogMarketCreated1(\n            _newAddress,\n            address(treasury),\n            address(nfthub),\n            referenceContractVersion\n        );\n        emit LogMarketCreated2(\n            _newAddress,\n            _mode,\n            _tokenURIs,\n            _ipfsHash,\n            _timestamps,\n            totalNftMintCount\n        );\n\n        // tell Treasury, Orderbook, and NFT hub about new market\n        // before initialize as during initialize the market may call the treasury\n        treasury.addMarket(_newAddress);\n        nfthub.addMarket(_newAddress);\n        orderbook.addMarket(\n            _newAddress,\n            _tokenURIs.length,\n            minimumPriceIncreasePercent\n        );\n\n        // update internals\n        marketAddresses[_mode].push(_newAddress);\n        mappingOfMarkets[_newAddress] = true;\n\n        // initialize the market\n        IRCMarket(_newAddress).initialize({\n            _mode: _mode,\n            _timestamps: _timestamps,\n            _numberOfTokens: _tokenURIs.length,\n            _totalNftMintCount: totalNftMintCount,\n            _artistAddress: _artistAddress,\n            _affiliateAddress: _affiliateAddress,\n            _cardAffiliateAddresses: _cardAffiliateAddresses,\n            _marketCreatorAddress: _creator,\n            _realitioQuestion: _realitioQuestion\n        });\n\n        // create the NFTs\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            uint256 _tokenId = i + totalNftMintCount;\n            require(\n                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),\n                \"Nft Minting Failed\"\n            );\n        }\n\n        // increment totalNftMintCount\n        totalNftMintCount = totalNftMintCount + _tokenURIs.length;\n\n        // pay sponsorship, if applicable\n        if (_sponsorship > 0) {\n            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);\n        }\n\n        return _newAddress;\n    }\n\n    /// @dev called by the market upon initialise\n    /// @dev not passed to initialise to avoid stack too deep error\n    function getOracleSettings()\n        external\n        view\n        override\n        returns (\n            IRealitio,\n            address,\n            uint32\n        )\n    {\n        return (realitio, arbitrator, timeout);\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRealitio.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // CONTRACT SETUP\n    /// @dev = how many outcomes/teams/NFTs etc\n    uint256 public numberOfCards;\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n    uint256 public constant MIN_RENTAL_VALUE = 1 ether;\n    States public override state;\n    /// @dev type of event.\n    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}\n    Mode public mode;\n    /// @dev so the Factory can check it's a market\n    bool public constant override isMarket = true;\n    /// @dev counts the total NFTs minted across all events at the time market created\n    /// @dev nft tokenId = card Id + totalNftMintCount\n    uint256 public totalNftMintCount;\n\n    // CONTRACT VARIABLES\n    IRCTreasury public treasury;\n    IRCFactory public factory;\n    IRCNftHubL2 public nfthub;\n    IRCOrderbook public orderbook;\n\n    // PRICE, DEPOSITS, RENT\n    /// @dev in wei\n    mapping(uint256 => uint256) public cardPrice;\n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping(address => uint256) public rentCollectedPerUser;\n    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout\n    mapping(uint256 => uint256) public rentCollectedPerCard;\n    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout\n    mapping(address => mapping(uint256 => uint256))\n        public rentCollectedPerUserPerCard;\n    /// @dev an easy way to track the above across all cards\n    uint256 public totalRentCollected;\n    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)\n    mapping(address => uint256) public exitedTimestamp;\n\n    // PARAMETERS\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public minimumPriceIncreasePercent;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public minRentalDayDivisor;\n    /// @dev maximum number of times to calcualte rent in one transaction\n    uint256 public maxRentIterations;\n\n    // TIME\n    /// @dev how many seconds each user has held each card for, for determining winnings\n    mapping(uint256 => mapping(address => uint256)) public timeHeld;\n    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n    mapping(uint256 => uint256) public totalTimeHeld;\n    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n    mapping(uint256 => uint256) public timeLastCollected;\n    /// @dev to track the max timeheld of each card (for giving NFT to winner)\n    mapping(uint256 => uint256) public longestTimeHeld;\n    /// @dev to track who has owned it the most (for giving NFT to winner)\n    mapping(uint256 => address) public longestOwner;\n    /// @dev to track the card timeHeldLimit for the current owner\n    mapping(uint256 => uint256) public cardTimeLimit;\n\n    // TIMESTAMPS\n    /// @dev when the market opens\n    uint32 public marketOpeningTime;\n    /// @dev when the market locks\n    uint32 public override marketLockingTime;\n    /// @dev when the question can be answered on realitio\n    /// @dev only needed for circuit breaker\n    uint32 public oracleResolutionTime;\n\n    // PAYOUT VARIABLES\n    uint256 public winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping(address => bool) public userAlreadyWithdrawn;\n    /// @dev prevent users claiming twice\n    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool\n    /// @dev the artist\n    address public artistAddress;\n    uint256 public artistCut;\n    bool public artistPaid;\n    /// @dev the affiliate\n    address public affiliateAddress;\n    uint256 public affiliateCut;\n    bool public affiliatePaid;\n    /// @dev the winner\n    uint256 public winnerCut;\n    /// @dev the market creator\n    address public marketCreatorAddress;\n    uint256 public creatorCut;\n    bool public creatorPaid;\n    /// @dev card specific recipients\n    address[] public cardAffiliateAddresses;\n    uint256 public cardAffiliateCut;\n    mapping(uint256 => bool) public cardAffiliatePaid;\n\n    // ORACLE VARIABLES\n    bytes32 public questionId;\n    bool public questionFinalised;\n    address public arbitrator;\n    uint32 public timeout;\n    IRealitio public realitio;\n    address public _realitioAddress;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);\n    event LogRentCollection(\n        uint256 rentCollected,\n        uint256 indexed newTimeHeld,\n        uint256 indexed cardId,\n        address indexed owner\n    );\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(\n        address indexed paidTo,\n        uint256 indexed amountPaid\n    );\n    event LogRentReturned(\n        address indexed returnedTo,\n        uint256 indexed amountReturned\n    );\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(\n        address indexed owner,\n        uint256 newLimit,\n        uint256 cardId\n    );\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogNftUpgraded(\n        uint256 indexed currentTokenId,\n        uint256 indexed newTokenId\n    );\n    event LogPayoutDetails(\n        address indexed artistAddress,\n        address marketCreatorAddress,\n        address affiliateAddress,\n        address[] cardAffiliateAddresses,\n        uint256 indexed artistCut,\n        uint256 winnerCut,\n        uint256 creatorCut,\n        uint256 affiliateCut,\n        uint256 cardAffiliateCut\n    );\n    event LogSettings(\n        uint256 indexed minRentalDayDivisor,\n        uint256 indexed minimumPriceIncreasePercent\n    );\n    event LogLongestOwner(uint256 cardId, address longestOwner);\n    event LogQuestionPostedToOracle(\n        address indexed marketAddress,\n        bytes32 indexed questionId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfCards how many Cards in this market\n    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _marketCreatorAddress where to send market creator's cut, if any\n    /// @param _realitioQuestion the question posted to the Oracle\n    function initialize(\n        uint256 _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfCards,\n        uint256 _totalNftMintCount,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion\n    ) external override initializer {\n        assert(_mode <= 2);\n\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsMarket\", \"1\");\n\n        // external contract variables:\n        factory = IRCFactory(msgSender());\n        treasury = factory.treasury();\n        nfthub = factory.nfthub();\n        orderbook = factory.orderbook();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();\n        maxRentIterations = factory.maxRentIterations();\n\n        // initialiiize!\n        winningOutcome = MAX_UINT256; // default invalid\n\n        // assign arguments to public variables\n        mode = Mode(_mode);\n        numberOfCards = _numberOfCards;\n        totalNftMintCount = _totalNftMintCount;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n        (realitio, arbitrator, timeout) = factory.getOracleSettings();\n\n        // reduce artist cut to zero if zero adddress set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero adddress set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array.\n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfCards) {\n            for (uint256 i = 0; i < _numberOfCards; i++) {\n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {\n            winnerCut =\n                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -\n                cardAffiliateCut;\n        }\n\n        // post question to Oracle\n        questionFinalised = false;\n        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);\n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime <= block.timestamp) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(\n            _artistAddress,\n            _marketCreatorAddress,\n            _affiliateAddress,\n            cardAffiliateAddresses,\n            artistCut,\n            winnerCut,\n            creatorCut,\n            affiliateCut,\n            cardAffiliateCut\n        );\n        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            MODIFIERS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {\n            _incrementState();\n        }\n        _;\n    }\n\n    /// @notice automatically locks market if appropriate\n    modifier autoLock() {\n        _;\n        if (marketLockingTime <= block.timestamp) {\n            lockMarket();\n        }\n    }\n\n    /// @dev can only be called by Card owners\n    modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     NFT HUB CONTRACT CALLS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice send NFT to mainnet\n    /// @dev upgrades not possible if market not approved\n    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {\n        _checkState(States.WITHDRAW);\n        require(\n            !factory.trapIfUnapproved() ||\n                factory.isMarketApproved(address(this)),\n            \"Upgrade blocked\"\n        );\n        uint256 _tokenId = _card + totalNftMintCount;\n        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n        nfthub.withdrawWithMetadata(_tokenId);\n        emit LogNftUpgraded(_card, _tokenId);\n    }\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.ownerOf(_tokenId);\n    }\n\n    /// @notice gets tokenURI via their Card Id\n    function tokenURI(uint256 _cardId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.tokenURI(_tokenId);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called internally during contract open state\n    function _transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId\n    ) internal {\n        require(\n            _from != address(0) && _to != address(0),\n            \"Cannot send to/from zero address\"\n        );\n        uint256 _tokenId = _cardId + totalNftMintCount;\n\n        assert(nfthub.transferNft(_from, _to, _tokenId));\n        emit LogNewOwner(_cardId, _to);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called externaly by Orderbook during contract open state\n    function transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external override {\n        require(msgSender() == address(orderbook), \"Not orderbook\");\n        _checkState(States.OPEN);\n        if (_to != _from) {\n            _transferCard(_from, _to, _cardId);\n        }\n        cardTimeLimit[_cardId] = _timeLimit;\n        cardPrice[_cardId] = _price;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        ORACLE FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev called within initializer only\n    function _postQuestionToOracle(\n        string calldata _question,\n        uint32 _oracleResolutionTime\n    ) internal {\n        questionId = realitio.askQuestion(\n            2,\n            _question,\n            arbitrator,\n            timeout,\n            _oracleResolutionTime,\n            0\n        );\n        emit LogQuestionPostedToOracle(address(this), questionId);\n    }\n\n    /// @notice has the oracle finalised\n    function isFinalized() public view returns (bool) {\n        bool _isFinalized = realitio.isFinalized(questionId);\n        return _isFinalized;\n    }\n\n    /// @dev sets the winning outcome\n    /// @dev market.setWinner() will revert if done twice, because wrong state\n    function getWinnerFromOracle() external {\n        require(isFinalized(), \"Oracle not finalised\");\n        // check market state to prevent market closing early\n        require(marketLockingTime <= block.timestamp, \"Market not finished\");\n        questionFinalised = true;\n        bytes32 _winningOutcome = realitio.resultFor(questionId);\n        // call the market\n        setWinner(uint256(_winningOutcome));\n    }\n\n    /// @dev admin override of the oracle\n    function setAmicableResolution(uint256 _winningOutcome) external {\n        require(msgSender() == factory.owner(), \"Not authorised\");\n        questionFinalised = true;\n        setWinner(_winningOutcome);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551  MARKET RESOLUTION FUNCTIONS    \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice checks whether the competition has ended, if so moves to LOCKED state\n    /// @dev can be called by anyone\n    /// @dev public because called within autoLock modifier & setWinner\n    function lockMarket() public {\n        _checkState(States.OPEN);\n        require(\n            marketLockingTime <= block.timestamp,\n            \"Market has not finished\"\n        );\n        // do a final rent collection before the contract is locked down\n\n        if (collectRentAllCards()) {\n            orderbook.closeMarket();\n            _incrementState();\n\n            for (uint256 i; i < numberOfCards; i++) {\n                // bring the cards back to the market so the winners get the satisfcation of claiming them\n                _transferCard(ownerOf(i), address(this), i);\n                emit LogLongestOwner(i, longestOwner[i]);\n            }\n            emit LogContractLocked(true);\n        }\n    }\n\n    /// @notice called by getWinnerFromOracle, sets the winner\n    /// @param _winningOutcome the index of the winning card\n    function setWinner(uint256 _winningOutcome) internal {\n        if (state == States.OPEN) {\n            // change the locking time to allow lockMarket to lock\n            marketLockingTime = SafeCast.toUint32(block.timestamp);\n            lockMarket();\n        }\n        if (state == States.LOCKED) {\n            // get the winner. This will revert if answer is not resolved.\n            winningOutcome = _winningOutcome;\n            _incrementState();\n            emit LogWinnerKnown(winningOutcome);\n        }\n    }\n\n    /// @notice pays out winnings, or returns funds\n    function withdraw() external {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], \"Already withdrawn\");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (totalTimeHeld[winningOutcome] > 0) {\n            _payoutWinnings();\n        } else {\n            _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    /// @param _card the id of the card, the index\n    function claimCard(uint256 _card) external {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(!userAlreadyClaimed[_card][msgSender()], \"Already claimed\");\n        userAlreadyClaimed[_card][msgSender()] = true;\n        require(longestOwner[_card] == msgSender(), \"Not longest owner\");\n        _transferCard(ownerOf(_card), longestOwner[_card], _card);\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer = 0;\n        uint256 _remainingCut =\n            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -\n                winnerCut) - creatorCut;\n        // calculate longest owner's extra winnings, if relevant\n        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {\n            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);\n        }\n        uint256 _remainingPot = 0;\n        if (mode == Mode.SAFE_MODE) {\n            // return all rent paid on winning card\n            _remainingPot =\n                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *\n                    _remainingCut) /\n                (1000);\n            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][\n                winningOutcome\n            ];\n        } else {\n            // calculate normal winnings, if any\n            _remainingPot = (totalRentCollected * _remainingCut) / (1000);\n        }\n        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];\n        uint256 _numerator = _remainingPot * _winnersTimeHeld;\n        _winningsToTransfer =\n            _winningsToTransfer +\n            (_numerator / totalTimeHeld[winningOutcome]);\n        require(_winningsToTransfer > 0, \"Not a winner\");\n        _payout(msgSender(), _winningsToTransfer);\n        emit LogWinningsPaid(msgSender(), _winningsToTransfer);\n    }\n\n    /// @notice returns all funds to users in case of invalid outcome\n    function _returnRent() internal {\n        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)\n        uint256 _remainingCut =\n            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;\n        uint256 _rentCollected = rentCollectedPerUser[msgSender()];\n        require(_rentCollected > 0, \"Paid no rent\");\n        uint256 _rentCollectedAdjusted =\n            (_rentCollected * _remainingCut) / (1000);\n        _payout(msgSender(), _rentCollectedAdjusted);\n        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);\n    }\n\n    /// @notice all payouts happen through here\n    function _payout(address _recipient, uint256 _amount) internal {\n        assert(treasury.payout(_recipient, _amount));\n    }\n\n    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)\n    /// @dev they are not called within setWinner() because of the risk of an\n    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings\n    /// @dev [hangover from when ether was native currency, keeping in case we return to this]\n\n    /// @notice pay artist\n    function payArtist() external {\n        _checkState(States.WITHDRAW);\n        require(!artistPaid, \"Artist already paid\");\n        artistPaid = true;\n        _processStakeholderPayment(artistCut, artistAddress);\n    }\n\n    /// @notice pay market creator\n    function payMarketCreator() external {\n        _checkState(States.WITHDRAW);\n        require(totalTimeHeld[winningOutcome] > 0, \"No winner\");\n        require(!creatorPaid, \"Creator already paid\");\n        creatorPaid = true;\n        _processStakeholderPayment(creatorCut, marketCreatorAddress);\n    }\n\n    /// @notice pay affiliate\n    function payAffiliate() external {\n        _checkState(States.WITHDRAW);\n        require(!affiliatePaid, \"Affiliate already paid\");\n        affiliatePaid = true;\n        _processStakeholderPayment(affiliateCut, affiliateAddress);\n    }\n\n    /// @notice pay card affiliate\n    /// @dev does not call _processStakeholderPayment because it works differently\n    function payCardAffiliate(uint256 _card) external {\n        _checkState(States.WITHDRAW);\n        require(!cardAffiliatePaid[_card], \"Card affiliate already paid\");\n        cardAffiliatePaid[_card] = true;\n        uint256 _cardAffiliatePayment =\n            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);\n        if (_cardAffiliatePayment > 0) {\n            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);\n            emit LogStakeholderPaid(\n                cardAffiliateAddresses[_card],\n                _cardAffiliatePayment\n            );\n        }\n    }\n\n    function _processStakeholderPayment(uint256 _cut, address _recipient)\n        internal\n    {\n        if (_cut > 0) {\n            uint256 _payment = (totalRentCollected * _cut) / (1000);\n            _payout(_recipient, _payment);\n            emit LogStakeholderPaid(_recipient, _payment);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             EXTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev basically functions that have _checkState(States.OPEN) on first line\n\n    /// @notice collects rent for all cards\n    /// @dev cannot be external because it is called within the lockMarket function, therefore public\n    function collectRentAllCards() public override returns (bool) {\n        _checkState(States.OPEN);\n        bool _success = true;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != address(this)) {\n                _success = _collectRent(i);\n            }\n            if (!_success) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice rent every Card at the minimum price\n    /// @param _maxSumOfPrices a limit to the sum of the bids to place\n    function rentAllCards(uint256 _maxSumOfPrices) external {\n        // check that not being front run\n        uint256 _actualSumOfPrices;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);\n        }\n        require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");\n\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint256 _newPrice;\n                if (cardPrice[i] > 0) {\n                    _newPrice =\n                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /\n                        100;\n                } else {\n                    _newPrice = MIN_RENTAL_VALUE;\n                }\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n    /// @notice to rent a Card\n    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate\n    /// @param _newPrice the price to rent the card for\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _startingPosition where to start looking to insert the bid into the orderbook\n    /// @param _card the index of the card to update\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) public autoUnlock() autoLock() {\n        if (state == States.OPEN) {\n            require(_newPrice >= MIN_RENTAL_VALUE, \"Price below min\");\n            require(_card < numberOfCards, \"Card does not exist\");\n\n            address _user = msgSender();\n\n            require(\n                exitedTimestamp[_user] != block.timestamp,\n                \"Cannot lose and re-rent in same block\"\n            );\n            require(\n                !treasury.marketPaused(address(this)) &&\n                    !treasury.globalPause(),\n                \"Rentals are disabled\"\n            );\n            bool _userStillForeclosed = treasury.isForeclosed(_user);\n            if (_userStillForeclosed) {\n                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);\n            }\n            if (!_userStillForeclosed) {\n                if (ownerOf(_card) == _user) {\n                    // the owner may only increase by more than X% or reduce their price\n                    uint256 _requiredPrice =\n                        (cardPrice[_card] *\n                            (minimumPriceIncreasePercent + 100)) / (100);\n                    require(\n                        _newPrice >= _requiredPrice ||\n                            _newPrice < cardPrice[_card],\n                        \"Invalid price\"\n                    );\n                }\n\n                // do some cleaning up before we collect rent or check their bidRate\n                orderbook.removeOldBids(_user);\n\n                _collectRent(_card);\n\n                // check sufficient deposit\n                uint256 _userTotalBidRate =\n                    treasury.userTotalBids(_user) -\n                        (orderbook.getBidValue(_user, _card)) +\n                        _newPrice;\n                require(\n                    treasury.userDeposit(_user) >=\n                        _userTotalBidRate / minRentalDayDivisor,\n                    \"Insufficient deposit\"\n                );\n\n                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n                // replaces _newBid and _updateBid\n                orderbook.addBidToOrderbook(\n                    _user,\n                    _card,\n                    _newPrice,\n                    _timeHeldLimit,\n                    _startingPosition\n                );\n\n                assert(treasury.updateLastRentalTime(_user));\n            }\n        }\n    }\n\n    function _checkTimeHeldLimit(uint256 _timeHeldLimit)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_timeHeldLimit == 0) {\n            return 0;\n        } else {\n            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;\n            require(_timeHeldLimit >= _minRentalTime, \"Limit too low\");\n            return _timeHeldLimit;\n        }\n    }\n\n    /// @notice to change your timeHeldLimit without having to re-rent\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _card the index of the card to update\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external\n    {\n        _checkState(States.OPEN);\n        address _user = msgSender();\n\n        if (_collectRent(_card)) {\n            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);\n\n            if (ownerOf(_card) == _user) {\n                cardTimeLimit[_card] = _timeHeldLimit;\n            }\n\n            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);\n        }\n    }\n\n    /// @notice stop renting all cards\n    function exitAll() external override {\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            exit(i);\n        }\n    }\n\n    /// @notice stop renting a card and/or remove from orderbook\n    /// @dev public because called by exitAll()\n    /// @dev doesn't need to be current owner so user can prevent ownership returning to them\n    /// @dev does not apply minimum rental duration, because it returns ownership to the next user\n    /// @param _card The card index to exit\n    function exit(uint256 _card) public override {\n        _checkState(States.OPEN);\n        address _msgSender = msgSender();\n\n        // block frontrunning attack\n        exitedTimestamp[_msgSender] = block.timestamp;\n\n        // collectRent first\n        _collectRent(_card);\n\n        if (ownerOf(_card) == _msgSender) {\n            // if current owner, find a new one\n            orderbook.findNewOwner(_card, block.timestamp);\n            assert(!orderbook.bidExists(_msgSender, address(this), _card));\n        } else {\n            // if not owner, just delete from orderbook\n            if (orderbook.bidExists(_msgSender, address(this), _card)) {\n                orderbook.removeBidFromOrderbook(_msgSender, _card);\n            }\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by user, sponsor is msgSender\n    function sponsor(uint256 _amount) external override {\n        address _creator = msgSender();\n        treasury.checkSponsorship(_creator, _amount);\n        _sponsor(_creator, _amount);\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n    /// @dev actually processes the sponsorship\n    function _sponsor(address _sponsorAddress, uint256 _amount) internal {\n        _checkNotState(States.LOCKED);\n        _checkNotState(States.WITHDRAW);\n        require(_amount > 0, \"Must send something\");\n        // send tokens to the Treasury\n        require(treasury.sponsor(_sponsorAddress, _amount));\n        totalRentCollected = totalRentCollected + _amount;\n        // just so user can get it back if invalid outcome\n        rentCollectedPerUser[_sponsorAddress] =\n            rentCollectedPerUser[_sponsorAddress] +\n            _amount;\n        // allocate equally to each card, in case card specific affiliates\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            rentCollectedPerCard[i] =\n                rentCollectedPerCard[i] +\n                (_amount / numberOfCards);\n        }\n        emit LogSponsor(_sponsorAddress, _amount);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             INTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice collects rent for a specific card\n    /// @dev also calculates and updates how long the current user has held the card for\n    /// @dev is not a problem if called externally, but making internal over public to save gas\n    function _collectRentAction(uint256 _card)\n        internal\n        returns (bool shouldContinue)\n    {\n        address _user = ownerOf(_card);\n        uint256 _timeOfThisCollection = block.timestamp;\n\n        // don't collect rent beyond the locking time\n        if (marketLockingTime <= block.timestamp) {\n            _timeOfThisCollection = marketLockingTime;\n        }\n\n        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)\n        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)\n        if (\n            _user != address(this) &&\n            timeLastCollected[_card] < _timeOfThisCollection\n        ) {\n            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet\n            uint256 _timeUserForeclosed =\n                treasury.collectRentUser(_user, block.timestamp);\n\n            // Calculate the card timeLimitTimestamp\n            uint256 _cardTimeLimitTimestamp =\n                timeLastCollected[_card] + cardTimeLimit[_card];\n\n            // input bools\n            bool _foreclosed = _timeUserForeclosed != 0;\n            bool _limitHit =\n                cardTimeLimit[_card] != 0 &&\n                    _cardTimeLimitTimestamp < block.timestamp;\n            bool _marketLocked = marketLockingTime <= block.timestamp;\n\n            // outputs\n            bool _newOwner;\n            uint256 _refundTime; // seconds of rent to refund the user\n\n            /* Permutations of the events: Foreclosure, Time limit and Market Locking\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n            \u2502Case       \u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524\n            \u2502Foreclosure\u25020\u25020\u25020\u25020\u25021\u25021\u25021\u25021\u2502\n            \u2502Time Limit \u25020\u25020\u25021\u25021\u25020\u25020\u25021\u25021\u2502\n            \u2502Market Lock\u25020\u25021\u25020\u25021\u25020\u25021\u25020\u25021\u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n            */\n\n            if (!_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 1\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN simple rent collect, same owner\n                _timeOfThisCollection = _timeOfThisCollection;\n                _newOwner = false;\n                _refundTime = 0;\n            } else if (!_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 2\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN refund rent between locking and now\n                _timeOfThisCollection = marketLockingTime;\n                _newOwner = false;\n                _refundTime = block.timestamp - marketLockingTime;\n            } else if (!_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 3\n                // didn't foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN refund rent between time limit and now\n                _timeOfThisCollection = _cardTimeLimitTimestamp;\n                _newOwner = true;\n                _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n            } else if (!_foreclosed && _limitHit && _marketLocked) {\n                // CASE 4\n                // didn't foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN refund rent between the earliest event and now\n                if (_cardTimeLimitTimestamp < marketLockingTime) {\n                    // time limit hit before market locked\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked before time limit hit\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 5\n                // did foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN rent OK, find new owner\n                _timeOfThisCollection = _timeUserForeclosed;\n                _newOwner = true;\n                _refundTime = 0;\n            } else if (_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 6\n                // did foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN if foreclosed first rent ok, otherwise refund after locking\n                if (_timeUserForeclosed < marketLockingTime) {\n                    // user foreclosed before market locked\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // market locked before user foreclosed\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 7\n                // did foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN if foreclosed first rent ok, otherwise refund after limit\n                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {\n                    // user foreclosed before time limit\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // time limit hit before user foreclosed\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                }\n            } else {\n                // CASE 8\n                // did foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN (\u256f\u00b0\u76ca\u00b0)\u256f\u5f61\u253b\u2501\u253b\n                if (\n                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&\n                    _timeUserForeclosed < marketLockingTime\n                ) {\n                    // user foreclosed first (or at same time as time limit)\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else if (\n                    _cardTimeLimitTimestamp < _timeUserForeclosed &&\n                    _cardTimeLimitTimestamp < marketLockingTime\n                ) {\n                    // time limit hit first\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked first\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = _timeUserForeclosed - marketLockingTime;\n                }\n            }\n            if (_refundTime != 0) {\n                uint256 _refundAmount =\n                    (_refundTime * cardPrice[_card]) / 1 days;\n                treasury.refundUser(_user, _refundAmount);\n            }\n            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens\n\n            if (_newOwner) {\n                orderbook.findNewOwner(_card, _timeOfThisCollection);\n                return true;\n            }\n        } else {\n            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking\n            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental\n            timeLastCollected[_card] = _timeOfThisCollection;\n        }\n        return false;\n    }\n\n    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls\n    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit\n    function _collectRent(uint256 _card)\n        internal\n        returns (bool didUpdateEverything)\n    {\n        uint32 counter = 0;\n        bool shouldContinue = true;\n        while (counter < maxRentIterations && shouldContinue) {\n            shouldContinue = _collectRentAction(_card);\n            counter++;\n        }\n        return !shouldContinue;\n    }\n\n    /// @dev processes actual rent collection and updates the state\n    function _processRentCollection(\n        address _user,\n        uint256 _card,\n        uint256 _timeOfCollection\n    ) internal {\n        uint256 _rentOwed =\n            (cardPrice[_card] *\n                (_timeOfCollection - timeLastCollected[_card])) / 1 days;\n        treasury.payRent(_rentOwed);\n        uint256 _timeHeldToIncrement =\n            (_timeOfCollection - timeLastCollected[_card]);\n\n        // if the user has a timeLimit, adjust it as necessary\n        if (cardTimeLimit[_card] != 0) {\n            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);\n            cardTimeLimit[_card] -= _timeHeldToIncrement;\n        }\n        timeHeld[_card][_user] += _timeHeldToIncrement;\n        totalTimeHeld[_card] += _timeHeldToIncrement;\n        rentCollectedPerUser[_user] += _rentOwed;\n        rentCollectedPerCard[_card] += _rentOwed;\n        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;\n        totalRentCollected += _rentOwed;\n        timeLastCollected[_card] = _timeOfCollection;\n\n        // longest owner tracking\n        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {\n            longestTimeHeld[_card] = timeHeld[_card][_user];\n            longestOwner[_card] = _user;\n        }\n        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);\n    }\n\n    function _checkState(States currentState) internal view {\n        require(state == currentState, \"Incorrect state\");\n    }\n\n    function _checkNotState(States currentState) internal view {\n        require(state != currentState, \"Incorrect state\");\n    }\n\n    /// @dev should only be called thrice\n    function _incrementState() internal {\n        assert(uint256(state) < 4);\n        state = States(uint256(state) + (1));\n        emit LogStateChange(uint256(state));\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        CIRCUIT BREAKER          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev in case Oracle never resolves for any reason\n    /// @dev does not set a winner so same as invalid outcome\n    /// @dev market does not need to be locked, just in case lockMarket bugs out\n    function circuitBreaker() external {\n        require(\n            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),\n            \"Too early\"\n        );\n        _incrementState();\n        orderbook.closeMarket();\n        state = States.WITHDRAW;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCFactory.sol",
            "RCMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards\n        return nfthub.ownerOf(_tokenId);\n    }\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313\n  modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\"); // _token could be higher than numberOfCards,\n        _;\n    }\n\nfunction upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,\n    _checkState(States.WITHDRAW);\n    require(\n        !factory.trapIfUnapproved() ||\n            factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market\n        \"Upgrade blocked\"\n    );\n    uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market\n    _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n    nfthub.withdrawWithMetadata(_tokenId);\n    emit LogNftUpgraded(_card, _tokenId);\n}\n"
                ],
                "Type": " Can access cards of other markets",
                "Description": "\nWithin RCMarket.sol the functions ownerOf and onlyTokenOwner do not check if the _cardId/_token is smaller than numberOfCards. So it's possible to supply a larger number and access cards of other markets.\nThe most problematic seems to be upgradeCard. Here the check for isMarketApproved can be circumvented by trying to move the card via another market.\n\nYou can still only move cards you own.\nsolidity\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards\n        return nfthub.ownerOf(_tokenId);\n    }\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313\n  modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\"); // _token could be higher than numberOfCards,\n        _;\n    }\n\nfunction upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,\n    _checkState(States.WITHDRAW);\n    require(\n        !factory.trapIfUnapproved() ||\n            factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market\n        \"Upgrade blocked\"\n    );\n    uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market\n    _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n    nfthub.withdrawWithMetadata(_tokenId);\n    emit LogNftUpgraded(_card, _tokenId);\n}\n\n\n",
                "Repair": "Recommend adding the following to ownerOf:\nrequire(_card < numberOfCards, \"Card does not exist\");\n\nSplidge (Reality Cards) confirmed but recommended *higher* severity(https://github.com/code-423n4/2021-06-realitycards-findings/issues/11#issuecomment-860545086):\n  I would assign this a higher severity level, I think it should be 3(High Risk) as this can be used to steal assets. An NFT being an asset as defined in the warden judging criteria found here(https://docs.code4rena.com/roles/wardens/judging-criteria).\n\n It is planned that eventually market creation will be opened up to anyone. There are several steps along this path towards opening up market creation:\n 1. only the Factory owner can create markets\n 2. Governors will be assigned who also have the ability to create markets\n 3. Anybody can be allowed to create markets by calling changeMarketCreationGovernorsOnly\n 4. NFTs allowed to be created (or more accurately not burned on market completion) by anyone by calling changeTrapCardsIfUnapproved\n\n The key here is that even in step 3 where anybody can create a market, the market will still require Governor approval for it to be displayed in the UI and for the NFT to be allowed to be upgraded. It is here in step 3 that upgradeCard could be called on an approved market in order to move a card from an unapproved market.\n\nmcplums (Reality Cards) confirmed(https://github.com/code-423n4/2021-06-realitycards-findings/issues/11#issuecomment-864044517):\n  Agreed, this indeed should have a higher severityfantastic catch @gpersoon!!\n\nSplidge (Reality Cards) resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/11#issuecomment-864892792):\n Fixed here(https://github.com/RealityCards/RealityCards-Contracts/commit/1f395f8cb415a1114cae60eb42c75c6539dfec73)\n Impressed also with the simplicity of the solution.\n\ndmvt (Judge) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/11#issuecomment-877651728):\n  Agree with the higher severity\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n"
                ],
                "Type": " anyone can call function  sponsor ",
                "Description": "\nThis function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is  0:\nsolidity\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n\n",
                "Repair": "Recommend checking that the sender is a factory contract.\n\nSplidge (Reality Cards) confirmed(https://github.com/code-423n4/2021-06-realitycards-findings/issues/40#issuecomment-861313681):\n  This is a good one!\n\nmcplums (Reality Cards) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/40#issuecomment-864040541):\n  Yeah this is massive one!! Thanks @pauliax :)\n\n\nSplidge (Reality Cards) resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/40#issuecomment-864915074):\n  fixed here(https://github.com/RealityCards/RealityCards-Contracts/commit/a234524ea563b00c67c6ac618e426a1354b75c93)\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "marketLockingTime",
                    "_incrementState()",
                    "createMarket()",
                    "_timestamps",
                    "_timestamps[",
                    "marketOpeningTime",
                    "oracleResolutionTime"
                ],
                "Type": "  RCFactory.createMarket()  does not enforce  _timestamps  and  _timestamps  being larger than  _timestamps , even though proper functioning requires them to be so",
                "Description": "\nRCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so.\n\nIRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. ([1(https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L7))\n\nThe comments explicitly state that _incrementState() should be called \"thrice\" ([2(https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1093))\n\nHowever, it is possible to create a market where these events do not occur sequentially.\n\nYou can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.\n\nThis is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0] ([3(https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L539))\n\nThis is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. ([4(https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L521))\n\nThus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.\n\nWhen calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0] ([5(https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L468))\n\n",
                "Repair": "Recommend adding the following check to RCFactory.createMarket():\nsolidity\nrequire(\n    _timestamps[0] < _timestamps[1],\n    \"market must begin before market can lock\"\n);\n\n\nSplidge (Reality Cards) confirmed and resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/61#issuecomment-864930732):\n  Implemented here(https://github.com/RealityCards/RealityCards-Contracts/commit/e47c6d845360166620dc014657d95d7180185c77)\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [
                    "refundUser()",
                    "globalPause",
                    "Treasury"
                ],
                "Type": " Flows can bypass market and global pause",
                "Description": "\nAbility to pause all token transfers and all state changes for contracts is a \u201cguarded-launch\u201d best-practice for emergency situations for newly launched projects. The project implements this using a marketsPaused flag per market and a globalPause flag across all markets.\n\nWhile these prevent renting of cards in a specific market and deposit/withdraw/rent cards across all markets, there are still public/external functions that are unguarded by these flags which can affect contract state in paused scenarios that will make it hard/impossible to recover correctly from the emergency pause.\n\nExamples includetopupMarketBalance() and refundUser() in Treasury can be triggered even in a globalPause scenario. There could be other function flows where it is not obvious that market/global pausing is enabled because it is enforced in one of the functions called deep within the code within one of the conditionals.\n\nThe impact is that markets get paused but the contracts cannot be restarted because of state changes affected during the pause via unguarded external/public functions.\n\n",
                "Repair": "Recommend applying marketPaused and globalPause check clearly in the beginning of all public/external functions which move tokens/funds in/out or change contract state in any way. Also, Validate all possible control flows to check that market/global pausing works in all scenarios and applies to all contract state and not specific functionalities.\n\nSplidge (Reality Cards) disputed and disagreed with severity(https://github.com/code-423n4/2021-06-realitycards-findings/issues/89#issuecomment-863985253):\n  marketPause is declared (https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L79)as only limiting rentals in a specific market.\n globalPause is declared (https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L77)as stopping deposits, withdraws and rentals across all markets.\n Therefore they are functioning as intended.\n\n Also, the example of refundUser() is not true, it will fail in a globalPause because it is only called by markets during a rent collection and a rent collection requires the calling of payout which is restricted by globalPause.\n\ndmvt (Judge) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/89#issuecomment-877668587):\n  topupMarketBalance does appear to be a deposit of sorts. I think the warden's take on the issue is valid and sponsor should seriously consider looking closer at the potential side effects of not fully pausing intentional transfer functions.\n\n\n"
            },
            {
                "Name": "M-09",
                "Location": [
                    "deposit()",
                    "_user",
                    "msgSender()"
                ],
                "Type": " Deposit whitelist enforced on  msg.sender  instead of user",
                "Description": "\nThe Treasury deposit() function credits amount to the user address in parameter instead of the msgSender() function that is actually making the deposit with the rationale (as explained in the Natspec comment) being that this may be called via contract or L1-L2 bot.\n\nHowever, the deposit whitelist should ideally be enforced on the _user address. If msgSender() is blacklisted, user address can still deposit() from another whitelisted msgSender() address while retaining the user address that is used for leader boards and NFTs.\n\nThe impact of this is that even if the user misbehaves in interactions with the system (e.g. trolls, spams) and their corresponding msgSender() is removed from the whitelist. The user can continue to deposit into the system via another whitelisted msgSender() without any impact to leader boards or NFTs.\n\n",
                "Repair": "Recommend using whitelist on user address instead of msgSender().\n\nSplidge (Reality Cards) disputed and disagreed with severity(https://github.com/code-423n4/2021-06-realitycards-findings/issues/107#issuecomment-864043844):\n  It is stated that the whitelist will \"only allow certain addresses to deposit\" here (https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L70)and that toggleWhitelist() allows an address to deposit here(https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L204).\n\n I think that the whitelist is performing as intended, but thanks for this issue report as this could easily have been a larger issue.\n\n We only plan to use the whitelist as a very rudimentary barrier just for the initial launch. I think that only allowing certain addresses to deposit is sufficient for now. Maybe if time allows I'll make the changes but changing the whitelist to allow the _user instead of the msgSender() would also block contracts and layer1-layer2 bot, so there'd need to be exceptions made for them. I'd rather not play about with sensitive functions at the last minute when we aren't going to be using the whitelist much anyway.\n\ndmvt (Judge) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/107#issuecomment-877673092):\n  Warden makes a good point. This could allow griefing of other parts of the system. If the barrier winds up being needed longer than expected or users act in unexpected ways, sponsor may wind up wishing they had reconsidered addressing this. Obviously, sponsor is free to ignore, but the issue seems to be a valid one with significant potential impact.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRealitio.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // CONTRACT SETUP\n    /// @dev = how many outcomes/teams/NFTs etc\n    uint256 public numberOfCards;\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n    uint256 public constant MIN_RENTAL_VALUE = 1 ether;\n    States public override state;\n    /// @dev type of event.\n    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}\n    Mode public mode;\n    /// @dev so the Factory can check it's a market\n    bool public constant override isMarket = true;\n    /// @dev counts the total NFTs minted across all events at the time market created\n    /// @dev nft tokenId = card Id + totalNftMintCount\n    uint256 public totalNftMintCount;\n\n    // CONTRACT VARIABLES\n    IRCTreasury public treasury;\n    IRCFactory public factory;\n    IRCNftHubL2 public nfthub;\n    IRCOrderbook public orderbook;\n\n    // PRICE, DEPOSITS, RENT\n    /// @dev in wei\n    mapping(uint256 => uint256) public cardPrice;\n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping(address => uint256) public rentCollectedPerUser;\n    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout\n    mapping(uint256 => uint256) public rentCollectedPerCard;\n    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout\n    mapping(address => mapping(uint256 => uint256))\n        public rentCollectedPerUserPerCard;\n    /// @dev an easy way to track the above across all cards\n    uint256 public totalRentCollected;\n    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)\n    mapping(address => uint256) public exitedTimestamp;\n\n    // PARAMETERS\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public minimumPriceIncreasePercent;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public minRentalDayDivisor;\n    /// @dev maximum number of times to calcualte rent in one transaction\n    uint256 public maxRentIterations;\n\n    // TIME\n    /// @dev how many seconds each user has held each card for, for determining winnings\n    mapping(uint256 => mapping(address => uint256)) public timeHeld;\n    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n    mapping(uint256 => uint256) public totalTimeHeld;\n    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n    mapping(uint256 => uint256) public timeLastCollected;\n    /// @dev to track the max timeheld of each card (for giving NFT to winner)\n    mapping(uint256 => uint256) public longestTimeHeld;\n    /// @dev to track who has owned it the most (for giving NFT to winner)\n    mapping(uint256 => address) public longestOwner;\n    /// @dev to track the card timeHeldLimit for the current owner\n    mapping(uint256 => uint256) public cardTimeLimit;\n\n    // TIMESTAMPS\n    /// @dev when the market opens\n    uint32 public marketOpeningTime;\n    /// @dev when the market locks\n    uint32 public override marketLockingTime;\n    /// @dev when the question can be answered on realitio\n    /// @dev only needed for circuit breaker\n    uint32 public oracleResolutionTime;\n\n    // PAYOUT VARIABLES\n    uint256 public winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping(address => bool) public userAlreadyWithdrawn;\n    /// @dev prevent users claiming twice\n    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool\n    /// @dev the artist\n    address public artistAddress;\n    uint256 public artistCut;\n    bool public artistPaid;\n    /// @dev the affiliate\n    address public affiliateAddress;\n    uint256 public affiliateCut;\n    bool public affiliatePaid;\n    /// @dev the winner\n    uint256 public winnerCut;\n    /// @dev the market creator\n    address public marketCreatorAddress;\n    uint256 public creatorCut;\n    bool public creatorPaid;\n    /// @dev card specific recipients\n    address[] public cardAffiliateAddresses;\n    uint256 public cardAffiliateCut;\n    mapping(uint256 => bool) public cardAffiliatePaid;\n\n    // ORACLE VARIABLES\n    bytes32 public questionId;\n    bool public questionFinalised;\n    address public arbitrator;\n    uint32 public timeout;\n    IRealitio public realitio;\n    address public _realitioAddress;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);\n    event LogRentCollection(\n        uint256 rentCollected,\n        uint256 indexed newTimeHeld,\n        uint256 indexed cardId,\n        address indexed owner\n    );\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(\n        address indexed paidTo,\n        uint256 indexed amountPaid\n    );\n    event LogRentReturned(\n        address indexed returnedTo,\n        uint256 indexed amountReturned\n    );\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(\n        address indexed owner,\n        uint256 newLimit,\n        uint256 cardId\n    );\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogNftUpgraded(\n        uint256 indexed currentTokenId,\n        uint256 indexed newTokenId\n    );\n    event LogPayoutDetails(\n        address indexed artistAddress,\n        address marketCreatorAddress,\n        address affiliateAddress,\n        address[] cardAffiliateAddresses,\n        uint256 indexed artistCut,\n        uint256 winnerCut,\n        uint256 creatorCut,\n        uint256 affiliateCut,\n        uint256 cardAffiliateCut\n    );\n    event LogSettings(\n        uint256 indexed minRentalDayDivisor,\n        uint256 indexed minimumPriceIncreasePercent\n    );\n    event LogLongestOwner(uint256 cardId, address longestOwner);\n    event LogQuestionPostedToOracle(\n        address indexed marketAddress,\n        bytes32 indexed questionId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfCards how many Cards in this market\n    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _marketCreatorAddress where to send market creator's cut, if any\n    /// @param _realitioQuestion the question posted to the Oracle\n    function initialize(\n        uint256 _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfCards,\n        uint256 _totalNftMintCount,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion\n    ) external override initializer {\n        assert(_mode <= 2);\n\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsMarket\", \"1\");\n\n        // external contract variables:\n        factory = IRCFactory(msgSender());\n        treasury = factory.treasury();\n        nfthub = factory.nfthub();\n        orderbook = factory.orderbook();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();\n        maxRentIterations = factory.maxRentIterations();\n\n        // initialiiize!\n        winningOutcome = MAX_UINT256; // default invalid\n\n        // assign arguments to public variables\n        mode = Mode(_mode);\n        numberOfCards = _numberOfCards;\n        totalNftMintCount = _totalNftMintCount;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n        (realitio, arbitrator, timeout) = factory.getOracleSettings();\n\n        // reduce artist cut to zero if zero adddress set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero adddress set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array.\n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfCards) {\n            for (uint256 i = 0; i < _numberOfCards; i++) {\n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {\n            winnerCut =\n                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -\n                cardAffiliateCut;\n        }\n\n        // post question to Oracle\n        questionFinalised = false;\n        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);\n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime <= block.timestamp) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(\n            _artistAddress,\n            _marketCreatorAddress,\n            _affiliateAddress,\n            cardAffiliateAddresses,\n            artistCut,\n            winnerCut,\n            creatorCut,\n            affiliateCut,\n            cardAffiliateCut\n        );\n        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            MODIFIERS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {\n            _incrementState();\n        }\n        _;\n    }\n\n    /// @notice automatically locks market if appropriate\n    modifier autoLock() {\n        _;\n        if (marketLockingTime <= block.timestamp) {\n            lockMarket();\n        }\n    }\n\n    /// @dev can only be called by Card owners\n    modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     NFT HUB CONTRACT CALLS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice send NFT to mainnet\n    /// @dev upgrades not possible if market not approved\n    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {\n        _checkState(States.WITHDRAW);\n        require(\n            !factory.trapIfUnapproved() ||\n                factory.isMarketApproved(address(this)),\n            \"Upgrade blocked\"\n        );\n        uint256 _tokenId = _card + totalNftMintCount;\n        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n        nfthub.withdrawWithMetadata(_tokenId);\n        emit LogNftUpgraded(_card, _tokenId);\n    }\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.ownerOf(_tokenId);\n    }\n\n    /// @notice gets tokenURI via their Card Id\n    function tokenURI(uint256 _cardId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.tokenURI(_tokenId);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called internally during contract open state\n    function _transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId\n    ) internal {\n        require(\n            _from != address(0) && _to != address(0),\n            \"Cannot send to/from zero address\"\n        );\n        uint256 _tokenId = _cardId + totalNftMintCount;\n\n        assert(nfthub.transferNft(_from, _to, _tokenId));\n        emit LogNewOwner(_cardId, _to);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called externaly by Orderbook during contract open state\n    function transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external override {\n        require(msgSender() == address(orderbook), \"Not orderbook\");\n        _checkState(States.OPEN);\n        if (_to != _from) {\n            _transferCard(_from, _to, _cardId);\n        }\n        cardTimeLimit[_cardId] = _timeLimit;\n        cardPrice[_cardId] = _price;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        ORACLE FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev called within initializer only\n    function _postQuestionToOracle(\n        string calldata _question,\n        uint32 _oracleResolutionTime\n    ) internal {\n        questionId = realitio.askQuestion(\n            2,\n            _question,\n            arbitrator,\n            timeout,\n            _oracleResolutionTime,\n            0\n        );\n        emit LogQuestionPostedToOracle(address(this), questionId);\n    }\n\n    /// @notice has the oracle finalised\n    function isFinalized() public view returns (bool) {\n        bool _isFinalized = realitio.isFinalized(questionId);\n        return _isFinalized;\n    }\n\n    /// @dev sets the winning outcome\n    /// @dev market.setWinner() will revert if done twice, because wrong state\n    function getWinnerFromOracle() external {\n        require(isFinalized(), \"Oracle not finalised\");\n        // check market state to prevent market closing early\n        require(marketLockingTime <= block.timestamp, \"Market not finished\");\n        questionFinalised = true;\n        bytes32 _winningOutcome = realitio.resultFor(questionId);\n        // call the market\n        setWinner(uint256(_winningOutcome));\n    }\n\n    /// @dev admin override of the oracle\n    function setAmicableResolution(uint256 _winningOutcome) external {\n        require(msgSender() == factory.owner(), \"Not authorised\");\n        questionFinalised = true;\n        setWinner(_winningOutcome);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551  MARKET RESOLUTION FUNCTIONS    \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice checks whether the competition has ended, if so moves to LOCKED state\n    /// @dev can be called by anyone\n    /// @dev public because called within autoLock modifier & setWinner\n    function lockMarket() public {\n        _checkState(States.OPEN);\n        require(\n            marketLockingTime <= block.timestamp,\n            \"Market has not finished\"\n        );\n        // do a final rent collection before the contract is locked down\n\n        if (collectRentAllCards()) {\n            orderbook.closeMarket();\n            _incrementState();\n\n            for (uint256 i; i < numberOfCards; i++) {\n                // bring the cards back to the market so the winners get the satisfcation of claiming them\n                _transferCard(ownerOf(i), address(this), i);\n                emit LogLongestOwner(i, longestOwner[i]);\n            }\n            emit LogContractLocked(true);\n        }\n    }\n\n    /// @notice called by getWinnerFromOracle, sets the winner\n    /// @param _winningOutcome the index of the winning card\n    function setWinner(uint256 _winningOutcome) internal {\n        if (state == States.OPEN) {\n            // change the locking time to allow lockMarket to lock\n            marketLockingTime = SafeCast.toUint32(block.timestamp);\n            lockMarket();\n        }\n        if (state == States.LOCKED) {\n            // get the winner. This will revert if answer is not resolved.\n            winningOutcome = _winningOutcome;\n            _incrementState();\n            emit LogWinnerKnown(winningOutcome);\n        }\n    }\n\n    /// @notice pays out winnings, or returns funds\n    function withdraw() external {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], \"Already withdrawn\");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (totalTimeHeld[winningOutcome] > 0) {\n            _payoutWinnings();\n        } else {\n            _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    /// @param _card the id of the card, the index\n    function claimCard(uint256 _card) external {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(!userAlreadyClaimed[_card][msgSender()], \"Already claimed\");\n        userAlreadyClaimed[_card][msgSender()] = true;\n        require(longestOwner[_card] == msgSender(), \"Not longest owner\");\n        _transferCard(ownerOf(_card), longestOwner[_card], _card);\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer = 0;\n        uint256 _remainingCut =\n            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -\n                winnerCut) - creatorCut;\n        // calculate longest owner's extra winnings, if relevant\n        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {\n            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);\n        }\n        uint256 _remainingPot = 0;\n        if (mode == Mode.SAFE_MODE) {\n            // return all rent paid on winning card\n            _remainingPot =\n                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *\n                    _remainingCut) /\n                (1000);\n            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][\n                winningOutcome\n            ];\n        } else {\n            // calculate normal winnings, if any\n            _remainingPot = (totalRentCollected * _remainingCut) / (1000);\n        }\n        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];\n        uint256 _numerator = _remainingPot * _winnersTimeHeld;\n        _winningsToTransfer =\n            _winningsToTransfer +\n            (_numerator / totalTimeHeld[winningOutcome]);\n        require(_winningsToTransfer > 0, \"Not a winner\");\n        _payout(msgSender(), _winningsToTransfer);\n        emit LogWinningsPaid(msgSender(), _winningsToTransfer);\n    }\n\n    /// @notice returns all funds to users in case of invalid outcome\n    function _returnRent() internal {\n        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)\n        uint256 _remainingCut =\n            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;\n        uint256 _rentCollected = rentCollectedPerUser[msgSender()];\n        require(_rentCollected > 0, \"Paid no rent\");\n        uint256 _rentCollectedAdjusted =\n            (_rentCollected * _remainingCut) / (1000);\n        _payout(msgSender(), _rentCollectedAdjusted);\n        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);\n    }\n\n    /// @notice all payouts happen through here\n    function _payout(address _recipient, uint256 _amount) internal {\n        assert(treasury.payout(_recipient, _amount));\n    }\n\n    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)\n    /// @dev they are not called within setWinner() because of the risk of an\n    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings\n    /// @dev [hangover from when ether was native currency, keeping in case we return to this]\n\n    /// @notice pay artist\n    function payArtist() external {\n        _checkState(States.WITHDRAW);\n        require(!artistPaid, \"Artist already paid\");\n        artistPaid = true;\n        _processStakeholderPayment(artistCut, artistAddress);\n    }\n\n    /// @notice pay market creator\n    function payMarketCreator() external {\n        _checkState(States.WITHDRAW);\n        require(totalTimeHeld[winningOutcome] > 0, \"No winner\");\n        require(!creatorPaid, \"Creator already paid\");\n        creatorPaid = true;\n        _processStakeholderPayment(creatorCut, marketCreatorAddress);\n    }\n\n    /// @notice pay affiliate\n    function payAffiliate() external {\n        _checkState(States.WITHDRAW);\n        require(!affiliatePaid, \"Affiliate already paid\");\n        affiliatePaid = true;\n        _processStakeholderPayment(affiliateCut, affiliateAddress);\n    }\n\n    /// @notice pay card affiliate\n    /// @dev does not call _processStakeholderPayment because it works differently\n    function payCardAffiliate(uint256 _card) external {\n        _checkState(States.WITHDRAW);\n        require(!cardAffiliatePaid[_card], \"Card affiliate already paid\");\n        cardAffiliatePaid[_card] = true;\n        uint256 _cardAffiliatePayment =\n            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);\n        if (_cardAffiliatePayment > 0) {\n            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);\n            emit LogStakeholderPaid(\n                cardAffiliateAddresses[_card],\n                _cardAffiliatePayment\n            );\n        }\n    }\n\n    function _processStakeholderPayment(uint256 _cut, address _recipient)\n        internal\n    {\n        if (_cut > 0) {\n            uint256 _payment = (totalRentCollected * _cut) / (1000);\n            _payout(_recipient, _payment);\n            emit LogStakeholderPaid(_recipient, _payment);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             EXTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev basically functions that have _checkState(States.OPEN) on first line\n\n    /// @notice collects rent for all cards\n    /// @dev cannot be external because it is called within the lockMarket function, therefore public\n    function collectRentAllCards() public override returns (bool) {\n        _checkState(States.OPEN);\n        bool _success = true;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != address(this)) {\n                _success = _collectRent(i);\n            }\n            if (!_success) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice rent every Card at the minimum price\n    /// @param _maxSumOfPrices a limit to the sum of the bids to place\n    function rentAllCards(uint256 _maxSumOfPrices) external {\n        // check that not being front run\n        uint256 _actualSumOfPrices;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);\n        }\n        require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");\n\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint256 _newPrice;\n                if (cardPrice[i] > 0) {\n                    _newPrice =\n                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /\n                        100;\n                } else {\n                    _newPrice = MIN_RENTAL_VALUE;\n                }\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n    /// @notice to rent a Card\n    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate\n    /// @param _newPrice the price to rent the card for\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _startingPosition where to start looking to insert the bid into the orderbook\n    /// @param _card the index of the card to update\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) public autoUnlock() autoLock() {\n        if (state == States.OPEN) {\n            require(_newPrice >= MIN_RENTAL_VALUE, \"Price below min\");\n            require(_card < numberOfCards, \"Card does not exist\");\n\n            address _user = msgSender();\n\n            require(\n                exitedTimestamp[_user] != block.timestamp,\n                \"Cannot lose and re-rent in same block\"\n            );\n            require(\n                !treasury.marketPaused(address(this)) &&\n                    !treasury.globalPause(),\n                \"Rentals are disabled\"\n            );\n            bool _userStillForeclosed = treasury.isForeclosed(_user);\n            if (_userStillForeclosed) {\n                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);\n            }\n            if (!_userStillForeclosed) {\n                if (ownerOf(_card) == _user) {\n                    // the owner may only increase by more than X% or reduce their price\n                    uint256 _requiredPrice =\n                        (cardPrice[_card] *\n                            (minimumPriceIncreasePercent + 100)) / (100);\n                    require(\n                        _newPrice >= _requiredPrice ||\n                            _newPrice < cardPrice[_card],\n                        \"Invalid price\"\n                    );\n                }\n\n                // do some cleaning up before we collect rent or check their bidRate\n                orderbook.removeOldBids(_user);\n\n                _collectRent(_card);\n\n                // check sufficient deposit\n                uint256 _userTotalBidRate =\n                    treasury.userTotalBids(_user) -\n                        (orderbook.getBidValue(_user, _card)) +\n                        _newPrice;\n                require(\n                    treasury.userDeposit(_user) >=\n                        _userTotalBidRate / minRentalDayDivisor,\n                    \"Insufficient deposit\"\n                );\n\n                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n                // replaces _newBid and _updateBid\n                orderbook.addBidToOrderbook(\n                    _user,\n                    _card,\n                    _newPrice,\n                    _timeHeldLimit,\n                    _startingPosition\n                );\n\n                assert(treasury.updateLastRentalTime(_user));\n            }\n        }\n    }\n\n    function _checkTimeHeldLimit(uint256 _timeHeldLimit)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_timeHeldLimit == 0) {\n            return 0;\n        } else {\n            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;\n            require(_timeHeldLimit >= _minRentalTime, \"Limit too low\");\n            return _timeHeldLimit;\n        }\n    }\n\n    /// @notice to change your timeHeldLimit without having to re-rent\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _card the index of the card to update\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external\n    {\n        _checkState(States.OPEN);\n        address _user = msgSender();\n\n        if (_collectRent(_card)) {\n            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);\n\n            if (ownerOf(_card) == _user) {\n                cardTimeLimit[_card] = _timeHeldLimit;\n            }\n\n            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);\n        }\n    }\n\n    /// @notice stop renting all cards\n    function exitAll() external override {\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            exit(i);\n        }\n    }\n\n    /// @notice stop renting a card and/or remove from orderbook\n    /// @dev public because called by exitAll()\n    /// @dev doesn't need to be current owner so user can prevent ownership returning to them\n    /// @dev does not apply minimum rental duration, because it returns ownership to the next user\n    /// @param _card The card index to exit\n    function exit(uint256 _card) public override {\n        _checkState(States.OPEN);\n        address _msgSender = msgSender();\n\n        // block frontrunning attack\n        exitedTimestamp[_msgSender] = block.timestamp;\n\n        // collectRent first\n        _collectRent(_card);\n\n        if (ownerOf(_card) == _msgSender) {\n            // if current owner, find a new one\n            orderbook.findNewOwner(_card, block.timestamp);\n            assert(!orderbook.bidExists(_msgSender, address(this), _card));\n        } else {\n            // if not owner, just delete from orderbook\n            if (orderbook.bidExists(_msgSender, address(this), _card)) {\n                orderbook.removeBidFromOrderbook(_msgSender, _card);\n            }\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by user, sponsor is msgSender\n    function sponsor(uint256 _amount) external override {\n        address _creator = msgSender();\n        treasury.checkSponsorship(_creator, _amount);\n        _sponsor(_creator, _amount);\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n    /// @dev actually processes the sponsorship\n    function _sponsor(address _sponsorAddress, uint256 _amount) internal {\n        _checkNotState(States.LOCKED);\n        _checkNotState(States.WITHDRAW);\n        require(_amount > 0, \"Must send something\");\n        // send tokens to the Treasury\n        require(treasury.sponsor(_sponsorAddress, _amount));\n        totalRentCollected = totalRentCollected + _amount;\n        // just so user can get it back if invalid outcome\n        rentCollectedPerUser[_sponsorAddress] =\n            rentCollectedPerUser[_sponsorAddress] +\n            _amount;\n        // allocate equally to each card, in case card specific affiliates\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            rentCollectedPerCard[i] =\n                rentCollectedPerCard[i] +\n                (_amount / numberOfCards);\n        }\n        emit LogSponsor(_sponsorAddress, _amount);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             INTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice collects rent for a specific card\n    /// @dev also calculates and updates how long the current user has held the card for\n    /// @dev is not a problem if called externally, but making internal over public to save gas\n    function _collectRentAction(uint256 _card)\n        internal\n        returns (bool shouldContinue)\n    {\n        address _user = ownerOf(_card);\n        uint256 _timeOfThisCollection = block.timestamp;\n\n        // don't collect rent beyond the locking time\n        if (marketLockingTime <= block.timestamp) {\n            _timeOfThisCollection = marketLockingTime;\n        }\n\n        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)\n        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)\n        if (\n            _user != address(this) &&\n            timeLastCollected[_card] < _timeOfThisCollection\n        ) {\n            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet\n            uint256 _timeUserForeclosed =\n                treasury.collectRentUser(_user, block.timestamp);\n\n            // Calculate the card timeLimitTimestamp\n            uint256 _cardTimeLimitTimestamp =\n                timeLastCollected[_card] + cardTimeLimit[_card];\n\n            // input bools\n            bool _foreclosed = _timeUserForeclosed != 0;\n            bool _limitHit =\n                cardTimeLimit[_card] != 0 &&\n                    _cardTimeLimitTimestamp < block.timestamp;\n            bool _marketLocked = marketLockingTime <= block.timestamp;\n\n            // outputs\n            bool _newOwner;\n            uint256 _refundTime; // seconds of rent to refund the user\n\n            /* Permutations of the events: Foreclosure, Time limit and Market Locking\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n            \u2502Case       \u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524\n            \u2502Foreclosure\u25020\u25020\u25020\u25020\u25021\u25021\u25021\u25021\u2502\n            \u2502Time Limit \u25020\u25020\u25021\u25021\u25020\u25020\u25021\u25021\u2502\n            \u2502Market Lock\u25020\u25021\u25020\u25021\u25020\u25021\u25020\u25021\u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n            */\n\n            if (!_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 1\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN simple rent collect, same owner\n                _timeOfThisCollection = _timeOfThisCollection;\n                _newOwner = false;\n                _refundTime = 0;\n            } else if (!_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 2\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN refund rent between locking and now\n                _timeOfThisCollection = marketLockingTime;\n                _newOwner = false;\n                _refundTime = block.timestamp - marketLockingTime;\n            } else if (!_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 3\n                // didn't foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN refund rent between time limit and now\n                _timeOfThisCollection = _cardTimeLimitTimestamp;\n                _newOwner = true;\n                _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n            } else if (!_foreclosed && _limitHit && _marketLocked) {\n                // CASE 4\n                // didn't foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN refund rent between the earliest event and now\n                if (_cardTimeLimitTimestamp < marketLockingTime) {\n                    // time limit hit before market locked\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked before time limit hit\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 5\n                // did foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN rent OK, find new owner\n                _timeOfThisCollection = _timeUserForeclosed;\n                _newOwner = true;\n                _refundTime = 0;\n            } else if (_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 6\n                // did foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN if foreclosed first rent ok, otherwise refund after locking\n                if (_timeUserForeclosed < marketLockingTime) {\n                    // user foreclosed before market locked\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // market locked before user foreclosed\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 7\n                // did foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN if foreclosed first rent ok, otherwise refund after limit\n                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {\n                    // user foreclosed before time limit\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // time limit hit before user foreclosed\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                }\n            } else {\n                // CASE 8\n                // did foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN (\u256f\u00b0\u76ca\u00b0)\u256f\u5f61\u253b\u2501\u253b\n                if (\n                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&\n                    _timeUserForeclosed < marketLockingTime\n                ) {\n                    // user foreclosed first (or at same time as time limit)\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else if (\n                    _cardTimeLimitTimestamp < _timeUserForeclosed &&\n                    _cardTimeLimitTimestamp < marketLockingTime\n                ) {\n                    // time limit hit first\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked first\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = _timeUserForeclosed - marketLockingTime;\n                }\n            }\n            if (_refundTime != 0) {\n                uint256 _refundAmount =\n                    (_refundTime * cardPrice[_card]) / 1 days;\n                treasury.refundUser(_user, _refundAmount);\n            }\n            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens\n\n            if (_newOwner) {\n                orderbook.findNewOwner(_card, _timeOfThisCollection);\n                return true;\n            }\n        } else {\n            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking\n            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental\n            timeLastCollected[_card] = _timeOfThisCollection;\n        }\n        return false;\n    }\n\n    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls\n    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit\n    function _collectRent(uint256 _card)\n        internal\n        returns (bool didUpdateEverything)\n    {\n        uint32 counter = 0;\n        bool shouldContinue = true;\n        while (counter < maxRentIterations && shouldContinue) {\n            shouldContinue = _collectRentAction(_card);\n            counter++;\n        }\n        return !shouldContinue;\n    }\n\n    /// @dev processes actual rent collection and updates the state\n    function _processRentCollection(\n        address _user,\n        uint256 _card,\n        uint256 _timeOfCollection\n    ) internal {\n        uint256 _rentOwed =\n            (cardPrice[_card] *\n                (_timeOfCollection - timeLastCollected[_card])) / 1 days;\n        treasury.payRent(_rentOwed);\n        uint256 _timeHeldToIncrement =\n            (_timeOfCollection - timeLastCollected[_card]);\n\n        // if the user has a timeLimit, adjust it as necessary\n        if (cardTimeLimit[_card] != 0) {\n            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);\n            cardTimeLimit[_card] -= _timeHeldToIncrement;\n        }\n        timeHeld[_card][_user] += _timeHeldToIncrement;\n        totalTimeHeld[_card] += _timeHeldToIncrement;\n        rentCollectedPerUser[_user] += _rentOwed;\n        rentCollectedPerCard[_card] += _rentOwed;\n        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;\n        totalRentCollected += _rentOwed;\n        timeLastCollected[_card] = _timeOfCollection;\n\n        // longest owner tracking\n        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {\n            longestTimeHeld[_card] = timeHeld[_card][_user];\n            longestOwner[_card] = _user;\n        }\n        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);\n    }\n\n    function _checkState(States currentState) internal view {\n        require(state == currentState, \"Incorrect state\");\n    }\n\n    function _checkNotState(States currentState) internal view {\n        require(state != currentState, \"Incorrect state\");\n    }\n\n    /// @dev should only be called thrice\n    function _incrementState() internal {\n        assert(uint256(state) < 4);\n        state = States(uint256(state) + (1));\n        emit LogStateChange(uint256(state));\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        CIRCUIT BREAKER          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev in case Oracle never resolves for any reason\n    /// @dev does not set a winner so same as invalid outcome\n    /// @dev market does not need to be locked, just in case lockMarket bugs out\n    function circuitBreaker() external {\n        require(\n            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),\n            \"Too early\"\n        );\n        _incrementState();\n        orderbook.closeMarket();\n        state = States.WITHDRAW;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "collectRentUser",
                    "newRental"
                ],
                "Type": " Anyone can affect deposits of any user and turn the owner of the token",
                "Description": "\nOn RCTreasury, we have the method collectRentUser. This method is public, so anyone can call it using whatever user and whatever timestamp.\nSo, calling this method using user = XXXXX and _timeToCollectTo = type(uint256).max), would make isForeclosed[user] = true.\n\nSee issue page(https://github.com/code-423n4/2021-06-realitycards-findings/issues/119) for referenced code\n\nNow, we can do the same for all the users bidding for a specific token.\nFinally, I can become the owner of the token by just calling newRental and using a small price. newRental will iterate over all the previous bid and will remove them because there are foreclosed.\n\n",
                "Repair": "Recommend that collectRentUser should be private and create a new public method with onlyOrderbook modifier.\n\nSplidge (Reality Cards) confirmed(https://github.com/code-423n4/2021-06-realitycards-findings/issues/119#issuecomment-863945050):\n  I like this.\n Although I might change the mitigation steps. I like keeping collectRentUser available to use, we can call it from our bot and it'll help keep user deposits updated in a timely manner for the frontend. I think I'll just add in\n solidity\n require(_timeToCollectTo <= block.timestamp, \"Can't collect future rent\")\n \n\nmcplums (Reality Cards) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/119#issuecomment-864033361):\n  Yeah this is a real doozie, very happy this one was spotted!! Thanks @a_delamo :)\n\nSplidge (Reality Cards) resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/119#issuecomment-865027036):\n  Fix implemented here(https://github.com/RealityCards/RealityCards-Contracts/commit/eb344de042217de28283c12281310b74f57a55f1)\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "isForeclosed",
                    "refundUser"
                ],
                "Type": " payout doesn't fix  isForeclosed  state",
                "Description": "\nThe function payout of RCTreasury.sol doesn't undo the isForeclosed state of a user.\nThis would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.\n\nFor example the function refundUser doesn't check and update the isForeclosed status in RCTreasury on L429(https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L429) and line 447(https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L447).\n\n",
                "Repair": "Recommend checking and updating the isForeclosed state in the payout function.\n\nSplidge (Reality Cards) confirmed and suggested upgrading from 0 to 2 severity(https://github.com/code-423n4/2021-06-realitycards-findings/issues/28#issuecomment-860740403):\n  The severity of this could be increased as a user might have believed that the payout would cancel their foreclosure.\n This could at a push count as 2 (Medium risk)  because the \"availability could be impacted\" as in the definition here(https://docs.code4rena.com/roles/wardens/judging-criteria). This is because the user wouldn't be allowed to place new bids without calling some other function that will cancel their foreclosure first.\n\ndmvt (Judge) agreed with sponsor and upgraded from 0 to 2 severity(https://github.com/code-423n4/2021-06-realitycards-findings/issues/105#issuecomment-877187804):\n\nSplidge (Reality Cards) resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/28#issuecomment-864907763):\n  Fixed here(https://github.com/RealityCards/RealityCards-Contracts/commit/9f179daf5a7b0a6256feba3648456650fedf4994)\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "rentAllCards()",
                    "maxSumOfPrices",
                    "_maxSumOfPrices"
                ],
                "Type": "  maxSumOfPrices  check is broken",
                "Description": "\nrentAllCards() requires the sender to specify a _maxSumOfPrices parameter which specifies \u201climit to the sum of the bids to place\u201d as specified in the Natspec @param comment. This is apparently for front-run protection.\n\nHowever, this function parameter constraint for _maxSumOfPrices is broken in the function implementation which leads to the total number of bids placed greater than the _maxSumOfPrices specified.\n\nThe impact of this is that the user may not have sufficient deposited, be foreclosed upon and/or impacted on other bids/markets.\n\nScenario: Assume two cards for a market with current winning rentals of 50 each. _maxSumofPrices = 101 passes check on L643 but then the forced 10% increase on L650 (assuming sender is not the owner of either card) causes newRentals to be called with 55 for each card thus totalling to 110 which is  101 as requested by the user.\n\n",
                "Repair": "Recommend modifing the max sum of prices check logic to consider the 10% increase scenarios. Document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership.\n\nSplidge (Reality Cards) confirmed and resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/87#issuecomment-864947965):\n  fixed here(https://github.com/RealityCards/RealityCards-Contracts/commit/10dfc77977f19fd4c233eb294ebc566526be9546)\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "//solidity\n_refundTime = block.timestamp marketLockingTime;\n",
                    "//solidity\n _refundTime = _timeUserForeclosed marketLockingTime;\n "
                ],
                "Type": " Wrong calculation on  _collectRentAction ",
                "Description": "\nThe method _collectRentAction contains the following code(https://github.com/code-423n4/2021-06-realitycards-findings/issues/122#issue-922787380):\n\nin case 6, it is doing:\nsolidity\n_refundTime = block.timestamp marketLockingTime;\n\ninstead of:\n solidity\n _refundTime = _timeUserForeclosed marketLockingTime;\n \nThis could lead to funds being drained by the miscalculation.\n\nmcplums (Reality Cards) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/122#issuecomment-864032806):\n  This is a really great find!!\n\nSplidge (Reality Cards) confirmed and resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/122#issuecomment-865026713):\n  Fix implemented here(https://github.com/RealityCards/RealityCards-Contracts/commit/457cc782c196e34b3b9d95a2d2c7b52ee6c17f2d)\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-14",
                "Location": [
                    "marketPaused",
                    "globalPause"
                ],
                "Type": " Market-specific pause is not checked for sponsor",
                "Description": "\nThe treasury only checks its globalPause field but does not check its market-specific marketPaused field for Treasury.sponsor.\nA paused market contract can therefore still deposit as a sponsor using Market.sponsor and result in the market-specific pause not work correctly.\n\n",
                "Repair": "Recommend adding checks for marketPaused in the Treasury for sponsor.\n\nmcplums (Reality Cards) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/145#issuecomment-862980785):\n  I don't think this is important but I guess it can't hurt to block sponsorship if paused\n\nSplidge (Reality Cards) confirmed but disagreed with severity(https://github.com/code-423n4/2021-06-realitycards-findings/issues/145#issuecomment-863178772):\n  I'm not sure why this is a severity 2? Maybe it should be lower.\n Sponsoring a market, whether paused or not, doesn't come with an expectation to receive the funds back. So assets are not at risk here.\n\nSplidge (Reality Cards) resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/145#issuecomment-865102061):\n  There have been changes made to marketPaused and how markets are created due to other issues that have been found. By default markets are now created in a paused state and it'd be useful to be able to sponsor them before the governors approve them. It's a nice thing for the sponsorship to be in place before anybody interacts with the contract.\n I have however made changes such that is the market pause is ever turned on by the Treasury owner then the sponsor function will revert.\n Changes here(https://github.com/RealityCards/RealityCards-Contracts/commit/4f7ab8074405058bf2bb24966886f3e0019e9208)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRealitio.sol\";\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    //\u2261\u2261\u2261\u2261\u2261\u2261\u2261 CONTRACT VARIABLES \u2261\u2261\u2261\u2261\u2261\u2261\u2261//\n    IRCTreasury public override treasury;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRealitio public realitio;\n\n    ///// CONTRACT ADDRESSES /////\n    /// @dev reference contract\n    address public referenceContractAddress;\n    /// @dev increments each time a new reference contract is added\n    uint256 public referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(uint256 => address[]) public marketAddresses;\n    mapping(address => bool) public mappingOfMarkets;\n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum tokens that must be sent when creating market which forms iniital pot\n    uint256 public sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public maximumDuration;\n    /// @dev list of governors\n    mapping(address => bool) public governors;\n    /// @dev if false, anyone can create markets\n    bool public marketCreationGovernorsOnly = true;\n    /// @dev if false, anyone can be an affiliate\n    bool public approvedAffilliatesOnly = true;\n    /// @dev if false, anyone can be an artist\n    bool public approvedArtistsOnly = true;\n    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity\n    bool public override trapIfUnapproved = true;\n    /// @dev high level owner who can change the factory address\n    address public uberOwner;\n    /// @dev the maximum number of rent collections to perform in a single transaction\n    uint256 public override maxRentIterations;\n    /// @dev the address of the arbitrator\n    address public arbitrator;\n    /// @dev the time allowed to dispute the oracle answer\n    uint32 public timeout;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public override isMarketApproved;\n    /// @dev allows artist to receive cut of total rent\n    mapping(address => bool) public isArtistApproved;\n    /// @dev allows affiliate to receive cut of total rent\n    mapping(address => bool) public isAffiliateApproved;\n    /// @dev allows card affiliate to receive cut of total rent\n    mapping(address => bool) public isCardAffiliateApproved;\n    /// @dev a limit to the number of NFTs to mint per market\n    uint256 public nftMintingLimit;\n\n    ///// OTHER /////\n    /// @dev counts the total NFTs minted across all events\n    /// @dev ... so the appropriate token id is used when upgrading to mainnet\n    uint256 public totalNftMintCount;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogMarketCreated1(\n        address contractAddress,\n        address treasuryAddress,\n        address nftHubAddress,\n        uint256 referenceContractVersion\n    );\n    event LogMarketCreated2(\n        address contractAddress,\n        uint32 mode,\n        string[] tokenURIs,\n        string ipfsHash,\n        uint32[] timestamps,\n        uint256 totalNftMintCount\n    );\n    event LogMarketApproved(address market, bool hidden);\n    event LogAdvancedWarning(uint256 _newAdvancedWarning);\n    event LogMaximumDuration(uint256 _newMaximumDuration);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev Treasury must be deployed before Factory\n    constructor(\n        IRCTreasury _treasuryAddress,\n        address _realitioAddress,\n        address _arbitratorAddress\n    ) {\n        require(address(_treasuryAddress) != address(0));\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise contract variable\n        treasury = _treasuryAddress;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate\n        setminimumPriceIncreasePercent(10); // 10%\n        setNFTMintingLimit(60); // current gas limit (12.5m) allows for 60 NFTs to be minted\n        setMaxRentIterations(35); // limit appears to be 41, set safe at 35 for now.\n        // oracle\n        setArbitrator(_arbitratorAddress);\n        setRealitioAddress(_realitioAddress);\n        setTimeout(86400); // 24 hours\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          VIEW FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Fetch the address of the most recently created market\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return the address of the most recent market in the given mode\n    function getMostRecentMarket(uint256 _mode)\n        external\n        view\n        returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n    /// @notice Fetch all the market addresses for a given mode\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return an array of all markets in a given mode\n    function getAllMarkets(uint256 _mode)\n        external\n        view\n        returns (address[] memory)\n    {\n        return marketAddresses[_mode];\n    }\n\n    /// @notice Returns the currently set pot distribution\n    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates\n    function getPotDistribution()\n        external\n        view\n        override\n        returns (uint256[5] memory)\n    {\n        return potDistribution;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev include the owner as a governor\n    modifier onlyGovernors() {\n        require(\n            governors[msgSender()] || owner() == msgSender(),\n            \"Not approved\"\n        );\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - OWNER (SETUP)  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n\n    /// @notice where the NFTs live\n    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but\n    /// @dev ... keeping flexible in case returning to previous contract\n    /// @param _newAddress the address to set\n    /// @param _newNftMintCount the number of NFTs this contract has minted, in order to keep them unique\n    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)\n        external\n        onlyOwner\n    {\n        require(address(_newAddress) != address(0));\n        nfthub = _newAddress;\n        totalNftMintCount = _newNftMintCount;\n    }\n\n    /// @notice set the address of the orderbook contract\n    /// @param _newAddress the address to set\n    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {\n        require(address(_newAddress) != address(0));\n        orderbook = _newAddress;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase & pot distribution emitted by Market.\n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice update stakeholder payouts\n    /// @dev in basis points (so 1000 = 100%)\n    /// @param _artistCut The artist that designed the card\n    /// @param _winnerCut Extra cut for the longest owner\n    /// @param _creatorCut The creator of the market\n    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts\n    /// @param _cardAffiliateCut An affiliate cur for specific cards\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) public onlyOwner {\n        require(\n            _artistCut +\n                _winnerCut +\n                _creatorCut +\n                _affiliateCut +\n                _cardAffiliateCut <=\n                1000,\n            \"Cuts too big\"\n        );\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%\n    function setminimumPriceIncreasePercent(uint256 _percentIncrease)\n        public\n        override\n        onlyOwner\n    {\n        minimumPriceIncreasePercent = _percentIncrease;\n    }\n\n    /// @notice A limit to the number of NFTs to mint per market\n    /// @dev to avoid gas limits\n    /// @param _mintLimit the limit to set\n    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {\n        nftMintingLimit = _mintLimit;\n    }\n\n    /// @notice A limit to the number of rent collections per transaction\n    /// @dev to avoid gas limits\n    /// @param _rentLimit the limit to set\n    function setMaxRentIterations(uint256 _rentLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxRentIterations = _rentLimit;\n    }\n\n    /// @notice set the address of the reality.eth contracts\n    /// @param _newAddress the address to set\n    function setRealitioAddress(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @notice address of the arbitrator, in case of continued disputes on reality.eth\n    /// @param _newAddress the address to set\n    function setArbitrator(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        arbitrator = _newAddress;\n    }\n\n    /// @notice set how long reality.eth waits for disputes before finalising\n    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs\n    function setTimeout(uint32 _newTimeout) public onlyOwner {\n        timeout = _newTimeout;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice whether or not only governors can create the market\n    function changeMarketCreationGovernorsOnly() external onlyOwner {\n        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;\n    }\n\n    /// @notice whether or not anyone can be an artist\n    function changeApprovedArtistsOnly() external onlyOwner {\n        approvedArtistsOnly = !approvedArtistsOnly;\n    }\n\n    /// @notice whether or not anyone can be an affiliate\n    function changeApprovedAffilliatesOnly() external onlyOwner {\n        approvedAffilliatesOnly = !approvedAffilliatesOnly;\n    }\n\n    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot\n    /// @param _amount the sponsorship required in wei\n    function setSponsorshipRequired(uint256 _amount) external onlyOwner {\n        sponsorshipRequired = _amount;\n    }\n\n    /// @notice if true, Cards in unapproved markets can't be upgraded\n    function changeTrapCardsIfUnapproved() external onlyOwner {\n        trapIfUnapproved = !trapIfUnapproved;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    /// @param _newAdvancedWarning the warning time to set in seconds\n    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {\n        advancedWarning = _newAdvancedWarning;\n        emit LogAdvancedWarning(_newAdvancedWarning);\n    }\n\n    /// @notice market closing time must be no more than this many seconds in the future\n    /// @param _newMaximumDuration the duration limit to set in seconds\n    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {\n        maximumDuration = _newMaximumDuration;\n        emit LogMaximumDuration(_newMaximumDuration);\n    }\n\n    /// @notice to fetch the owner of the contract\n    /// @dev used to specifiy the Ownable contract instead of the interface\n    function owner()\n        public\n        view\n        override(IRCFactory, Ownable)\n        returns (address)\n    {\n        return Ownable.owner();\n    }\n\n    /// @notice check if an address is a governor\n    /// @param _user the address to query\n    /// @return boolean return if true or false\n    function isGovernor(address _user) external view override returns (bool) {\n        return governors[_user];\n    }\n\n    // EDIT GOVERNORS\n\n    /// @notice add or remove an address from market creator whitelist\n    /// @param _governor the address to change approval for\n    /// @dev recommended to check isGovernor() afterwards to confirm the desired outcome\n    function changeGovernorApproval(address _governor) external onlyOwner {\n        require(_governor != address(0));\n        governors[_governor] = !governors[_governor];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - GOVERNORS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    /// @param _market the market address to change approval for\n    function changeMarketApproval(address _market) external onlyGovernors {\n        require(_market != address(0));\n        // check it's an RC contract\n        IRCMarket _marketToApprove = IRCMarket(_market);\n        assert(_marketToApprove.isMarket());\n        isMarketApproved[_market] = !isMarketApproved[_market];\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /// @notice artistAddress, passed in createMarket, must be approved\n    /// @param _artist the artist address to change approval for\n    function changeArtistApproval(address _artist) external onlyGovernors {\n        require(_artist != address(0));\n        isArtistApproved[_artist] = !isArtistApproved[_artist];\n    }\n\n    /// @notice affiliateAddress, passed in createMarket, must be approved\n    /// @param _affiliate the affiliate address to change approval for\n    function changeAffiliateApproval(address _affiliate)\n        external\n        onlyGovernors\n    {\n        require(_affiliate != address(0));\n        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];\n    }\n\n    /// @notice cardAffiliateAddress, passed in createMarket, must be approved\n    /// @param _affiliate the card affiliate address to change approval for\n    function changeCardAffiliateApproval(address _affiliate)\n        external\n        onlyGovernors\n    {\n        require(_affiliate != address(0));\n        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[\n            _affiliate\n        ];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    /// @notice change the reference contract for the contract logic\n    function setReferenceContractAddress(address _newAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newAddress != address(0));\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        assert(newContractVariable.isMarket());\n        // set\n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion += 1;\n    }\n\n    /// @notice to change or renounce ownership of the uberOwner role\n    function changeUberOwner(address _newUberOwner) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0));\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         MARKET CREATION         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Creates a new market with the given parameters\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    /// @param _sponsorship amount of sponsorship to create the market with\n    /// @return The address of the new market\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address) {\n        address _creator = msgSender();\n\n        // check sponsorship\n        require(\n            _sponsorship >= sponsorshipRequired,\n            \"Insufficient sponsorship\"\n        );\n        treasury.checkSponsorship(_creator, _sponsorship);\n\n        // check stakeholder addresses\n        // artist\n        if (approvedArtistsOnly) {\n            require(\n                isArtistApproved[_artistAddress] ||\n                    _artistAddress == address(0),\n                \"Artist not approved\"\n            );\n        }\n        // affiliate\n        if (approvedAffilliatesOnly) {\n            require(\n                isAffiliateApproved[_affiliateAddress] ||\n                    _affiliateAddress == address(0),\n                \"Affiliate not approved\"\n            );\n            // card affiliates\n            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {\n                require(\n                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||\n                        _cardAffiliateAddresses[i] == address(0),\n                    \"Card affiliate not approved\"\n                );\n            }\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(governors[_creator] || owner() == _creator, \"Not approved\");\n        }\n\n        // check timestamps\n        require(_timestamps.length == 3, \"Incorrect number of array elements\");\n        // check market opening time\n        if (advancedWarning != 0) {\n            require(\n                _timestamps[0] >= block.timestamp,\n                \"Market opening time not set\"\n            );\n            require(\n                _timestamps[0] - advancedWarning > block.timestamp,\n                \"Market opens too soon\"\n            );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(\n                _timestamps[1] < block.timestamp + maximumDuration,\n                \"Market locks too late\"\n            );\n        }\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(\n            _timestamps[1] + (1 weeks) > _timestamps[2] &&\n                _timestamps[1] <= _timestamps[2],\n            \"Oracle resolution time error\"\n        );\n\n        // check the number of NFTs to mint is within limits\n        require(\n            _tokenURIs.length <= nftMintingLimit,\n            \"Too many tokens to mint\"\n        );\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = Clones.clone(referenceContractAddress);\n        emit LogMarketCreated1(\n            _newAddress,\n            address(treasury),\n            address(nfthub),\n            referenceContractVersion\n        );\n        emit LogMarketCreated2(\n            _newAddress,\n            _mode,\n            _tokenURIs,\n            _ipfsHash,\n            _timestamps,\n            totalNftMintCount\n        );\n\n        // tell Treasury, Orderbook, and NFT hub about new market\n        // before initialize as during initialize the market may call the treasury\n        treasury.addMarket(_newAddress);\n        nfthub.addMarket(_newAddress);\n        orderbook.addMarket(\n            _newAddress,\n            _tokenURIs.length,\n            minimumPriceIncreasePercent\n        );\n\n        // update internals\n        marketAddresses[_mode].push(_newAddress);\n        mappingOfMarkets[_newAddress] = true;\n\n        // initialize the market\n        IRCMarket(_newAddress).initialize({\n            _mode: _mode,\n            _timestamps: _timestamps,\n            _numberOfTokens: _tokenURIs.length,\n            _totalNftMintCount: totalNftMintCount,\n            _artistAddress: _artistAddress,\n            _affiliateAddress: _affiliateAddress,\n            _cardAffiliateAddresses: _cardAffiliateAddresses,\n            _marketCreatorAddress: _creator,\n            _realitioQuestion: _realitioQuestion\n        });\n\n        // create the NFTs\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            uint256 _tokenId = i + totalNftMintCount;\n            require(\n                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),\n                \"Nft Minting Failed\"\n            );\n        }\n\n        // increment totalNftMintCount\n        totalNftMintCount = totalNftMintCount + _tokenURIs.length;\n\n        // pay sponsorship, if applicable\n        if (_sponsorship > 0) {\n            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);\n        }\n\n        return _newAddress;\n    }\n\n    /// @dev called by the market upon initialise\n    /// @dev not passed to initialise to avoid stack too deep error\n    function getOracleSettings()\n        external\n        view\n        override\n        returns (\n            IRealitio,\n            address,\n            uint32\n        )\n    {\n        return (realitio, arbitrator, timeout);\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "uberOwner",
                    "factory",
                    "market",
                    "Treasury",
                    "treasury",
                    "token",
                    "Nfthub",
                    "changeUberOwner()",
                    "Orderbook",
                    "Factory"
                ],
                "Type": " Critical  uberOwner  address changes should be a two-step process",
                "Description": "\nAs specified, uberOwners of Factory, Orderbook and Treasury have the highest privileges in the system because they can upgrade contracts of market, Nfthub, order book, treasury, token and factory which form the critical components of the protocol.\n\nThe contracts allow for uberOwners to be changed to a different address from the contract owner/deployer using the changeUberOwner() function which is callable by the current uberOwner. While this function checks for zero-address, there is no validation of the new address being correct. If the current uberOwner incorrectly uses an invalid address for which they do not have the private key, then the system gets locked because the uberOwner cannot be corrected and none of the other functions that require uberOwner caller can be executed.\n\nImpact: The current uberOwner uses a non-zero but incorrect address as the new uberOwner. This gets set and now the system is locked and none of the uberOwner-only callable functions are callable. This error cannot be fixed either and will require redeployment of contracts which will mean that all existing markets have to be terminated. The system will have to be shut and restarted completely from scratch which will take a reputation hit and have a serious technical and business impact.\n\n",
                "Repair": "Recommend changing the single-step change of uberOwner address to a two-step process where the current uberOwner first approves a new address as a pendingUberOwner. That pendingUberOwner has to then claim the ownership in a separate transaction which cannot be done if they do not have the correct private key. An incorrectly set pendingUberOwner can be reset by changing it again to the correct one who can then successfully claim it in the second step.\n\nSplidge (Reality Cards) marked as duplicate(https://github.com/code-423n4/2021-06-realitycards-findings/issues/105#issuecomment-863299789):\n  Duplicate of #5\n\ndmvt (Judge) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/105#issuecomment-877187804):\n  There is a very low probability coupled with a very high impact, making this a Medium risk issue in my opinion.\n\n _Note: Additional conversation regarding this vulnerability can be found here(https://github.com/code-423n4/2021-06-realitycards-findings/issues/5)_\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public orderbook;\n    /// @dev nfthub instance, to query current card owner\n    IRCNftHubL2 public nfthub;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev address of the Factory so only the Factory can add new markets\n    address public override factoryAddress;\n    /// @dev so only markets can use certain functions\n    mapping(address => bool) public override isMarket;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public marketBalance;\n    /// @dev a quick check if a uesr is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 marketBalanceDiscrepancy;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent any cards for specific market\n    mapping(address => bool) public override marketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            UBER OWNER           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev high level owner who can change the factory address\n    address public override uberOwner;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1000000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /// @notice only allow markets to call these functions\n    modifier onlyMarkets {\n        require(isMarket[msgSender()], \"Not authorised\");\n        _;\n    }\n\n    /// @notice only allow orderbook to call these functions\n    modifier onlyOrderbook {\n        require(msgSender() == address(orderbook), \"Not authorised\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           ADD MARKETS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can move funds from deposits to marketPots and vice versa\n    function addMarket(address _newMarket) external override {\n        require(msgSender() == factoryAddress, \"Not factory\");\n        isMarket[_newMarket] = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyOwner\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyOwner {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental for a specific market\n    function changePauseMarket(address _market) external override onlyOwner {\n        require(isMarket[_market], \"This isn't a market\");\n        marketPaused[_market] = !marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyOwner {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add a user to the whitelist\n    function addToWhitelist(address _user) public override {\n        IRCFactory factory = IRCFactory(factoryAddress);\n        require(factory.isGovernor(msgSender()), \"Not authorised\");\n        isAllowed[_user] = !isAllowed[_user];\n    }\n\n    /// @notice Add multiple users to the whitelist\n    function batchAddToWhitelist(address[] calldata _users) public override {\n        for (uint256 index = 0; index < _users.length; index++) {\n            addToWhitelist(_users[index]);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    function setFactoryAddress(address _newFactory) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newFactory != address(0), \"Must set an address\");\n        factoryAddress = _newFactory;\n    }\n\n    function setOrderbookAddress(address _newOrderbook) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newOrderbook != address(0), \"Must set an address\");\n        orderbook = IRCOrderbook(_newOrderbook);\n    }\n\n    function setNftHubAddress(address _NFTHubAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_NFTHubAddress != address(0), \"Must set an address\");\n        nfthub = IRCNftHubL2(_NFTHubAddress);\n    }\n\n    function setTokenAddress(address _newToken) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    function changeUberOwner(address _newUberOwner) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0), \"Must set an address\");\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract (newRental) or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        public\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(isAllowed[msgSender()], \"Not in whitelist\");\n        }\n        erc20.transferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        if (\n            (user[_user].deposit + _amount) >\n            (user[_user].bidRate / minRentalDayDivisor)\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // stpe 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.transfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            isForeclosed[_msgSender] = true;\n            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(\n                _msgSender\n            );\n            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount) external override {\n        erc20.transferFrom(msgSender(), address(this), _amount);\n        if (_amount > marketBalanceDiscrepancy) {\n            marketBalanceDiscrepancy = 0;\n        } else {\n            marketBalanceDiscrepancy -= _amount;\n        }\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            marketBalanceDiscrepancy += _amount - marketBalance;\n            _amount -= (_amount - marketBalance);\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n\n        return true;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        assert(marketPot[msgSender()] >= _amount);\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        onlyMarkets\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        if (\n            isForeclosed[_user] &&\n            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.transferFrom(_sponsor, address(this), _amount);\n        marketPot[msgSender()] += _amount;\n        totalMarketPots += _amount;\n        return true;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyMarkets\n        returns (bool)\n    {\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        if (user[_user].lastRentCalc == 0) {\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n        return true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice provides the sum total of a users bids accross all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyOrderbook {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !isMarket[_newOwner]\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed =\n                    rentOwedBetweenTimestmaps(\n                        block.timestamp,\n                        _timeOwnershipChanged,\n                        _newPrice\n                    );\n                collectRentUser(_newOwner, block.timestamp);\n\n                // they have enough funds, just collect the extra\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /// @dev called when all a user's bids have been removed, disables foreclosure state\n    function resetUser(address _user) external override onlyOrderbook {\n        isForeclosed[_user] = false;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calcualtion and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calcualtes the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestmaps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the amount of deposit a user is able to withdraw\n    /// @notice ..after considering rent due to be paid\n    /// @param _user the user to query\n    function depositAbleToWithdraw(address _user)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 collection = rentOwedUser(_user, block.timestamp);\n        if (collection >= user[_user].deposit) {\n            return 0;\n        } else {\n            return uint256(user[_user].deposit) - (collection);\n        }\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)\n            //                   = (deposit * 1day) / totalUserDailyRent\n            uint256 timeLeftOfDeposit =\n                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard =\n                user[_user].lastRentCalc + timeLeftOfDeposit;\n\n            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {\n                // calculate how long they can own the new card for\n                uint256 _rentAlreadyOwed =\n                    rentOwedBetweenTimestmaps(\n                        user[_user].lastRentCalc,\n                        _timeOfNewBid,\n                        totalUserDailyRent\n                    );\n                uint256 _depositAtTimeOfNewBid =\n                    user[_user].deposit - _rentAlreadyOwed;\n                uint256 _timeLeftOfDepositWithNewBid =\n                    (_depositAtTimeOfNewBid * 1 days) /\n                        (totalUserDailyRent + _newBid);\n                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            // if no rentals they'll foreclose after the heat death of the universe\n            return type(uint256).max;\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        assert(_timeToCollectTo != 0);\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts =\n                    ((_timeToCollectTo - previousCollectionTime) *\n                        uint256(user[_user].deposit)) / rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepsitLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets availiable balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRealitio.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // CONTRACT SETUP\n    /// @dev = how many outcomes/teams/NFTs etc\n    uint256 public numberOfCards;\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n    uint256 public constant MIN_RENTAL_VALUE = 1 ether;\n    States public override state;\n    /// @dev type of event.\n    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}\n    Mode public mode;\n    /// @dev so the Factory can check it's a market\n    bool public constant override isMarket = true;\n    /// @dev counts the total NFTs minted across all events at the time market created\n    /// @dev nft tokenId = card Id + totalNftMintCount\n    uint256 public totalNftMintCount;\n\n    // CONTRACT VARIABLES\n    IRCTreasury public treasury;\n    IRCFactory public factory;\n    IRCNftHubL2 public nfthub;\n    IRCOrderbook public orderbook;\n\n    // PRICE, DEPOSITS, RENT\n    /// @dev in wei\n    mapping(uint256 => uint256) public cardPrice;\n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping(address => uint256) public rentCollectedPerUser;\n    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout\n    mapping(uint256 => uint256) public rentCollectedPerCard;\n    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout\n    mapping(address => mapping(uint256 => uint256))\n        public rentCollectedPerUserPerCard;\n    /// @dev an easy way to track the above across all cards\n    uint256 public totalRentCollected;\n    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)\n    mapping(address => uint256) public exitedTimestamp;\n\n    // PARAMETERS\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public minimumPriceIncreasePercent;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public minRentalDayDivisor;\n    /// @dev maximum number of times to calcualte rent in one transaction\n    uint256 public maxRentIterations;\n\n    // TIME\n    /// @dev how many seconds each user has held each card for, for determining winnings\n    mapping(uint256 => mapping(address => uint256)) public timeHeld;\n    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n    mapping(uint256 => uint256) public totalTimeHeld;\n    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n    mapping(uint256 => uint256) public timeLastCollected;\n    /// @dev to track the max timeheld of each card (for giving NFT to winner)\n    mapping(uint256 => uint256) public longestTimeHeld;\n    /// @dev to track who has owned it the most (for giving NFT to winner)\n    mapping(uint256 => address) public longestOwner;\n    /// @dev to track the card timeHeldLimit for the current owner\n    mapping(uint256 => uint256) public cardTimeLimit;\n\n    // TIMESTAMPS\n    /// @dev when the market opens\n    uint32 public marketOpeningTime;\n    /// @dev when the market locks\n    uint32 public override marketLockingTime;\n    /// @dev when the question can be answered on realitio\n    /// @dev only needed for circuit breaker\n    uint32 public oracleResolutionTime;\n\n    // PAYOUT VARIABLES\n    uint256 public winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping(address => bool) public userAlreadyWithdrawn;\n    /// @dev prevent users claiming twice\n    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool\n    /// @dev the artist\n    address public artistAddress;\n    uint256 public artistCut;\n    bool public artistPaid;\n    /// @dev the affiliate\n    address public affiliateAddress;\n    uint256 public affiliateCut;\n    bool public affiliatePaid;\n    /// @dev the winner\n    uint256 public winnerCut;\n    /// @dev the market creator\n    address public marketCreatorAddress;\n    uint256 public creatorCut;\n    bool public creatorPaid;\n    /// @dev card specific recipients\n    address[] public cardAffiliateAddresses;\n    uint256 public cardAffiliateCut;\n    mapping(uint256 => bool) public cardAffiliatePaid;\n\n    // ORACLE VARIABLES\n    bytes32 public questionId;\n    bool public questionFinalised;\n    address public arbitrator;\n    uint32 public timeout;\n    IRealitio public realitio;\n    address public _realitioAddress;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);\n    event LogRentCollection(\n        uint256 rentCollected,\n        uint256 indexed newTimeHeld,\n        uint256 indexed cardId,\n        address indexed owner\n    );\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(\n        address indexed paidTo,\n        uint256 indexed amountPaid\n    );\n    event LogRentReturned(\n        address indexed returnedTo,\n        uint256 indexed amountReturned\n    );\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(\n        address indexed owner,\n        uint256 newLimit,\n        uint256 cardId\n    );\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogNftUpgraded(\n        uint256 indexed currentTokenId,\n        uint256 indexed newTokenId\n    );\n    event LogPayoutDetails(\n        address indexed artistAddress,\n        address marketCreatorAddress,\n        address affiliateAddress,\n        address[] cardAffiliateAddresses,\n        uint256 indexed artistCut,\n        uint256 winnerCut,\n        uint256 creatorCut,\n        uint256 affiliateCut,\n        uint256 cardAffiliateCut\n    );\n    event LogSettings(\n        uint256 indexed minRentalDayDivisor,\n        uint256 indexed minimumPriceIncreasePercent\n    );\n    event LogLongestOwner(uint256 cardId, address longestOwner);\n    event LogQuestionPostedToOracle(\n        address indexed marketAddress,\n        bytes32 indexed questionId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfCards how many Cards in this market\n    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _marketCreatorAddress where to send market creator's cut, if any\n    /// @param _realitioQuestion the question posted to the Oracle\n    function initialize(\n        uint256 _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfCards,\n        uint256 _totalNftMintCount,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion\n    ) external override initializer {\n        assert(_mode <= 2);\n\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsMarket\", \"1\");\n\n        // external contract variables:\n        factory = IRCFactory(msgSender());\n        treasury = factory.treasury();\n        nfthub = factory.nfthub();\n        orderbook = factory.orderbook();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();\n        maxRentIterations = factory.maxRentIterations();\n\n        // initialiiize!\n        winningOutcome = MAX_UINT256; // default invalid\n\n        // assign arguments to public variables\n        mode = Mode(_mode);\n        numberOfCards = _numberOfCards;\n        totalNftMintCount = _totalNftMintCount;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n        (realitio, arbitrator, timeout) = factory.getOracleSettings();\n\n        // reduce artist cut to zero if zero adddress set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero adddress set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array.\n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfCards) {\n            for (uint256 i = 0; i < _numberOfCards; i++) {\n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {\n            winnerCut =\n                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -\n                cardAffiliateCut;\n        }\n\n        // post question to Oracle\n        questionFinalised = false;\n        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);\n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime <= block.timestamp) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(\n            _artistAddress,\n            _marketCreatorAddress,\n            _affiliateAddress,\n            cardAffiliateAddresses,\n            artistCut,\n            winnerCut,\n            creatorCut,\n            affiliateCut,\n            cardAffiliateCut\n        );\n        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            MODIFIERS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {\n            _incrementState();\n        }\n        _;\n    }\n\n    /// @notice automatically locks market if appropriate\n    modifier autoLock() {\n        _;\n        if (marketLockingTime <= block.timestamp) {\n            lockMarket();\n        }\n    }\n\n    /// @dev can only be called by Card owners\n    modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     NFT HUB CONTRACT CALLS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice send NFT to mainnet\n    /// @dev upgrades not possible if market not approved\n    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {\n        _checkState(States.WITHDRAW);\n        require(\n            !factory.trapIfUnapproved() ||\n                factory.isMarketApproved(address(this)),\n            \"Upgrade blocked\"\n        );\n        uint256 _tokenId = _card + totalNftMintCount;\n        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n        nfthub.withdrawWithMetadata(_tokenId);\n        emit LogNftUpgraded(_card, _tokenId);\n    }\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.ownerOf(_tokenId);\n    }\n\n    /// @notice gets tokenURI via their Card Id\n    function tokenURI(uint256 _cardId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.tokenURI(_tokenId);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called internally during contract open state\n    function _transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId\n    ) internal {\n        require(\n            _from != address(0) && _to != address(0),\n            \"Cannot send to/from zero address\"\n        );\n        uint256 _tokenId = _cardId + totalNftMintCount;\n\n        assert(nfthub.transferNft(_from, _to, _tokenId));\n        emit LogNewOwner(_cardId, _to);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called externaly by Orderbook during contract open state\n    function transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external override {\n        require(msgSender() == address(orderbook), \"Not orderbook\");\n        _checkState(States.OPEN);\n        if (_to != _from) {\n            _transferCard(_from, _to, _cardId);\n        }\n        cardTimeLimit[_cardId] = _timeLimit;\n        cardPrice[_cardId] = _price;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        ORACLE FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev called within initializer only\n    function _postQuestionToOracle(\n        string calldata _question,\n        uint32 _oracleResolutionTime\n    ) internal {\n        questionId = realitio.askQuestion(\n            2,\n            _question,\n            arbitrator,\n            timeout,\n            _oracleResolutionTime,\n            0\n        );\n        emit LogQuestionPostedToOracle(address(this), questionId);\n    }\n\n    /// @notice has the oracle finalised\n    function isFinalized() public view returns (bool) {\n        bool _isFinalized = realitio.isFinalized(questionId);\n        return _isFinalized;\n    }\n\n    /// @dev sets the winning outcome\n    /// @dev market.setWinner() will revert if done twice, because wrong state\n    function getWinnerFromOracle() external {\n        require(isFinalized(), \"Oracle not finalised\");\n        // check market state to prevent market closing early\n        require(marketLockingTime <= block.timestamp, \"Market not finished\");\n        questionFinalised = true;\n        bytes32 _winningOutcome = realitio.resultFor(questionId);\n        // call the market\n        setWinner(uint256(_winningOutcome));\n    }\n\n    /// @dev admin override of the oracle\n    function setAmicableResolution(uint256 _winningOutcome) external {\n        require(msgSender() == factory.owner(), \"Not authorised\");\n        questionFinalised = true;\n        setWinner(_winningOutcome);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551  MARKET RESOLUTION FUNCTIONS    \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice checks whether the competition has ended, if so moves to LOCKED state\n    /// @dev can be called by anyone\n    /// @dev public because called within autoLock modifier & setWinner\n    function lockMarket() public {\n        _checkState(States.OPEN);\n        require(\n            marketLockingTime <= block.timestamp,\n            \"Market has not finished\"\n        );\n        // do a final rent collection before the contract is locked down\n\n        if (collectRentAllCards()) {\n            orderbook.closeMarket();\n            _incrementState();\n\n            for (uint256 i; i < numberOfCards; i++) {\n                // bring the cards back to the market so the winners get the satisfcation of claiming them\n                _transferCard(ownerOf(i), address(this), i);\n                emit LogLongestOwner(i, longestOwner[i]);\n            }\n            emit LogContractLocked(true);\n        }\n    }\n\n    /// @notice called by getWinnerFromOracle, sets the winner\n    /// @param _winningOutcome the index of the winning card\n    function setWinner(uint256 _winningOutcome) internal {\n        if (state == States.OPEN) {\n            // change the locking time to allow lockMarket to lock\n            marketLockingTime = SafeCast.toUint32(block.timestamp);\n            lockMarket();\n        }\n        if (state == States.LOCKED) {\n            // get the winner. This will revert if answer is not resolved.\n            winningOutcome = _winningOutcome;\n            _incrementState();\n            emit LogWinnerKnown(winningOutcome);\n        }\n    }\n\n    /// @notice pays out winnings, or returns funds\n    function withdraw() external {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], \"Already withdrawn\");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (totalTimeHeld[winningOutcome] > 0) {\n            _payoutWinnings();\n        } else {\n            _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    /// @param _card the id of the card, the index\n    function claimCard(uint256 _card) external {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(!userAlreadyClaimed[_card][msgSender()], \"Already claimed\");\n        userAlreadyClaimed[_card][msgSender()] = true;\n        require(longestOwner[_card] == msgSender(), \"Not longest owner\");\n        _transferCard(ownerOf(_card), longestOwner[_card], _card);\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer = 0;\n        uint256 _remainingCut =\n            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -\n                winnerCut) - creatorCut;\n        // calculate longest owner's extra winnings, if relevant\n        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {\n            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);\n        }\n        uint256 _remainingPot = 0;\n        if (mode == Mode.SAFE_MODE) {\n            // return all rent paid on winning card\n            _remainingPot =\n                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *\n                    _remainingCut) /\n                (1000);\n            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][\n                winningOutcome\n            ];\n        } else {\n            // calculate normal winnings, if any\n            _remainingPot = (totalRentCollected * _remainingCut) / (1000);\n        }\n        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];\n        uint256 _numerator = _remainingPot * _winnersTimeHeld;\n        _winningsToTransfer =\n            _winningsToTransfer +\n            (_numerator / totalTimeHeld[winningOutcome]);\n        require(_winningsToTransfer > 0, \"Not a winner\");\n        _payout(msgSender(), _winningsToTransfer);\n        emit LogWinningsPaid(msgSender(), _winningsToTransfer);\n    }\n\n    /// @notice returns all funds to users in case of invalid outcome\n    function _returnRent() internal {\n        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)\n        uint256 _remainingCut =\n            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;\n        uint256 _rentCollected = rentCollectedPerUser[msgSender()];\n        require(_rentCollected > 0, \"Paid no rent\");\n        uint256 _rentCollectedAdjusted =\n            (_rentCollected * _remainingCut) / (1000);\n        _payout(msgSender(), _rentCollectedAdjusted);\n        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);\n    }\n\n    /// @notice all payouts happen through here\n    function _payout(address _recipient, uint256 _amount) internal {\n        assert(treasury.payout(_recipient, _amount));\n    }\n\n    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)\n    /// @dev they are not called within setWinner() because of the risk of an\n    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings\n    /// @dev [hangover from when ether was native currency, keeping in case we return to this]\n\n    /// @notice pay artist\n    function payArtist() external {\n        _checkState(States.WITHDRAW);\n        require(!artistPaid, \"Artist already paid\");\n        artistPaid = true;\n        _processStakeholderPayment(artistCut, artistAddress);\n    }\n\n    /// @notice pay market creator\n    function payMarketCreator() external {\n        _checkState(States.WITHDRAW);\n        require(totalTimeHeld[winningOutcome] > 0, \"No winner\");\n        require(!creatorPaid, \"Creator already paid\");\n        creatorPaid = true;\n        _processStakeholderPayment(creatorCut, marketCreatorAddress);\n    }\n\n    /// @notice pay affiliate\n    function payAffiliate() external {\n        _checkState(States.WITHDRAW);\n        require(!affiliatePaid, \"Affiliate already paid\");\n        affiliatePaid = true;\n        _processStakeholderPayment(affiliateCut, affiliateAddress);\n    }\n\n    /// @notice pay card affiliate\n    /// @dev does not call _processStakeholderPayment because it works differently\n    function payCardAffiliate(uint256 _card) external {\n        _checkState(States.WITHDRAW);\n        require(!cardAffiliatePaid[_card], \"Card affiliate already paid\");\n        cardAffiliatePaid[_card] = true;\n        uint256 _cardAffiliatePayment =\n            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);\n        if (_cardAffiliatePayment > 0) {\n            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);\n            emit LogStakeholderPaid(\n                cardAffiliateAddresses[_card],\n                _cardAffiliatePayment\n            );\n        }\n    }\n\n    function _processStakeholderPayment(uint256 _cut, address _recipient)\n        internal\n    {\n        if (_cut > 0) {\n            uint256 _payment = (totalRentCollected * _cut) / (1000);\n            _payout(_recipient, _payment);\n            emit LogStakeholderPaid(_recipient, _payment);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             EXTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev basically functions that have _checkState(States.OPEN) on first line\n\n    /// @notice collects rent for all cards\n    /// @dev cannot be external because it is called within the lockMarket function, therefore public\n    function collectRentAllCards() public override returns (bool) {\n        _checkState(States.OPEN);\n        bool _success = true;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != address(this)) {\n                _success = _collectRent(i);\n            }\n            if (!_success) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice rent every Card at the minimum price\n    /// @param _maxSumOfPrices a limit to the sum of the bids to place\n    function rentAllCards(uint256 _maxSumOfPrices) external {\n        // check that not being front run\n        uint256 _actualSumOfPrices;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);\n        }\n        require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");\n\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint256 _newPrice;\n                if (cardPrice[i] > 0) {\n                    _newPrice =\n                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /\n                        100;\n                } else {\n                    _newPrice = MIN_RENTAL_VALUE;\n                }\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n    /// @notice to rent a Card\n    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate\n    /// @param _newPrice the price to rent the card for\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _startingPosition where to start looking to insert the bid into the orderbook\n    /// @param _card the index of the card to update\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) public autoUnlock() autoLock() {\n        if (state == States.OPEN) {\n            require(_newPrice >= MIN_RENTAL_VALUE, \"Price below min\");\n            require(_card < numberOfCards, \"Card does not exist\");\n\n            address _user = msgSender();\n\n            require(\n                exitedTimestamp[_user] != block.timestamp,\n                \"Cannot lose and re-rent in same block\"\n            );\n            require(\n                !treasury.marketPaused(address(this)) &&\n                    !treasury.globalPause(),\n                \"Rentals are disabled\"\n            );\n            bool _userStillForeclosed = treasury.isForeclosed(_user);\n            if (_userStillForeclosed) {\n                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);\n            }\n            if (!_userStillForeclosed) {\n                if (ownerOf(_card) == _user) {\n                    // the owner may only increase by more than X% or reduce their price\n                    uint256 _requiredPrice =\n                        (cardPrice[_card] *\n                            (minimumPriceIncreasePercent + 100)) / (100);\n                    require(\n                        _newPrice >= _requiredPrice ||\n                            _newPrice < cardPrice[_card],\n                        \"Invalid price\"\n                    );\n                }\n\n                // do some cleaning up before we collect rent or check their bidRate\n                orderbook.removeOldBids(_user);\n\n                _collectRent(_card);\n\n                // check sufficient deposit\n                uint256 _userTotalBidRate =\n                    treasury.userTotalBids(_user) -\n                        (orderbook.getBidValue(_user, _card)) +\n                        _newPrice;\n                require(\n                    treasury.userDeposit(_user) >=\n                        _userTotalBidRate / minRentalDayDivisor,\n                    \"Insufficient deposit\"\n                );\n\n                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n                // replaces _newBid and _updateBid\n                orderbook.addBidToOrderbook(\n                    _user,\n                    _card,\n                    _newPrice,\n                    _timeHeldLimit,\n                    _startingPosition\n                );\n\n                assert(treasury.updateLastRentalTime(_user));\n            }\n        }\n    }\n\n    function _checkTimeHeldLimit(uint256 _timeHeldLimit)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_timeHeldLimit == 0) {\n            return 0;\n        } else {\n            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;\n            require(_timeHeldLimit >= _minRentalTime, \"Limit too low\");\n            return _timeHeldLimit;\n        }\n    }\n\n    /// @notice to change your timeHeldLimit without having to re-rent\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _card the index of the card to update\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external\n    {\n        _checkState(States.OPEN);\n        address _user = msgSender();\n\n        if (_collectRent(_card)) {\n            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);\n\n            if (ownerOf(_card) == _user) {\n                cardTimeLimit[_card] = _timeHeldLimit;\n            }\n\n            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);\n        }\n    }\n\n    /// @notice stop renting all cards\n    function exitAll() external override {\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            exit(i);\n        }\n    }\n\n    /// @notice stop renting a card and/or remove from orderbook\n    /// @dev public because called by exitAll()\n    /// @dev doesn't need to be current owner so user can prevent ownership returning to them\n    /// @dev does not apply minimum rental duration, because it returns ownership to the next user\n    /// @param _card The card index to exit\n    function exit(uint256 _card) public override {\n        _checkState(States.OPEN);\n        address _msgSender = msgSender();\n\n        // block frontrunning attack\n        exitedTimestamp[_msgSender] = block.timestamp;\n\n        // collectRent first\n        _collectRent(_card);\n\n        if (ownerOf(_card) == _msgSender) {\n            // if current owner, find a new one\n            orderbook.findNewOwner(_card, block.timestamp);\n            assert(!orderbook.bidExists(_msgSender, address(this), _card));\n        } else {\n            // if not owner, just delete from orderbook\n            if (orderbook.bidExists(_msgSender, address(this), _card)) {\n                orderbook.removeBidFromOrderbook(_msgSender, _card);\n            }\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by user, sponsor is msgSender\n    function sponsor(uint256 _amount) external override {\n        address _creator = msgSender();\n        treasury.checkSponsorship(_creator, _amount);\n        _sponsor(_creator, _amount);\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n    /// @dev actually processes the sponsorship\n    function _sponsor(address _sponsorAddress, uint256 _amount) internal {\n        _checkNotState(States.LOCKED);\n        _checkNotState(States.WITHDRAW);\n        require(_amount > 0, \"Must send something\");\n        // send tokens to the Treasury\n        require(treasury.sponsor(_sponsorAddress, _amount));\n        totalRentCollected = totalRentCollected + _amount;\n        // just so user can get it back if invalid outcome\n        rentCollectedPerUser[_sponsorAddress] =\n            rentCollectedPerUser[_sponsorAddress] +\n            _amount;\n        // allocate equally to each card, in case card specific affiliates\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            rentCollectedPerCard[i] =\n                rentCollectedPerCard[i] +\n                (_amount / numberOfCards);\n        }\n        emit LogSponsor(_sponsorAddress, _amount);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             INTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice collects rent for a specific card\n    /// @dev also calculates and updates how long the current user has held the card for\n    /// @dev is not a problem if called externally, but making internal over public to save gas\n    function _collectRentAction(uint256 _card)\n        internal\n        returns (bool shouldContinue)\n    {\n        address _user = ownerOf(_card);\n        uint256 _timeOfThisCollection = block.timestamp;\n\n        // don't collect rent beyond the locking time\n        if (marketLockingTime <= block.timestamp) {\n            _timeOfThisCollection = marketLockingTime;\n        }\n\n        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)\n        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)\n        if (\n            _user != address(this) &&\n            timeLastCollected[_card] < _timeOfThisCollection\n        ) {\n            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet\n            uint256 _timeUserForeclosed =\n                treasury.collectRentUser(_user, block.timestamp);\n\n            // Calculate the card timeLimitTimestamp\n            uint256 _cardTimeLimitTimestamp =\n                timeLastCollected[_card] + cardTimeLimit[_card];\n\n            // input bools\n            bool _foreclosed = _timeUserForeclosed != 0;\n            bool _limitHit =\n                cardTimeLimit[_card] != 0 &&\n                    _cardTimeLimitTimestamp < block.timestamp;\n            bool _marketLocked = marketLockingTime <= block.timestamp;\n\n            // outputs\n            bool _newOwner;\n            uint256 _refundTime; // seconds of rent to refund the user\n\n            /* Permutations of the events: Foreclosure, Time limit and Market Locking\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n            \u2502Case       \u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524\n            \u2502Foreclosure\u25020\u25020\u25020\u25020\u25021\u25021\u25021\u25021\u2502\n            \u2502Time Limit \u25020\u25020\u25021\u25021\u25020\u25020\u25021\u25021\u2502\n            \u2502Market Lock\u25020\u25021\u25020\u25021\u25020\u25021\u25020\u25021\u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n            */\n\n            if (!_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 1\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN simple rent collect, same owner\n                _timeOfThisCollection = _timeOfThisCollection;\n                _newOwner = false;\n                _refundTime = 0;\n            } else if (!_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 2\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN refund rent between locking and now\n                _timeOfThisCollection = marketLockingTime;\n                _newOwner = false;\n                _refundTime = block.timestamp - marketLockingTime;\n            } else if (!_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 3\n                // didn't foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN refund rent between time limit and now\n                _timeOfThisCollection = _cardTimeLimitTimestamp;\n                _newOwner = true;\n                _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n            } else if (!_foreclosed && _limitHit && _marketLocked) {\n                // CASE 4\n                // didn't foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN refund rent between the earliest event and now\n                if (_cardTimeLimitTimestamp < marketLockingTime) {\n                    // time limit hit before market locked\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked before time limit hit\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 5\n                // did foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN rent OK, find new owner\n                _timeOfThisCollection = _timeUserForeclosed;\n                _newOwner = true;\n                _refundTime = 0;\n            } else if (_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 6\n                // did foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN if foreclosed first rent ok, otherwise refund after locking\n                if (_timeUserForeclosed < marketLockingTime) {\n                    // user foreclosed before market locked\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // market locked before user foreclosed\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 7\n                // did foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN if foreclosed first rent ok, otherwise refund after limit\n                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {\n                    // user foreclosed before time limit\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // time limit hit before user foreclosed\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                }\n            } else {\n                // CASE 8\n                // did foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN (\u256f\u00b0\u76ca\u00b0)\u256f\u5f61\u253b\u2501\u253b\n                if (\n                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&\n                    _timeUserForeclosed < marketLockingTime\n                ) {\n                    // user foreclosed first (or at same time as time limit)\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else if (\n                    _cardTimeLimitTimestamp < _timeUserForeclosed &&\n                    _cardTimeLimitTimestamp < marketLockingTime\n                ) {\n                    // time limit hit first\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked first\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = _timeUserForeclosed - marketLockingTime;\n                }\n            }\n            if (_refundTime != 0) {\n                uint256 _refundAmount =\n                    (_refundTime * cardPrice[_card]) / 1 days;\n                treasury.refundUser(_user, _refundAmount);\n            }\n            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens\n\n            if (_newOwner) {\n                orderbook.findNewOwner(_card, _timeOfThisCollection);\n                return true;\n            }\n        } else {\n            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking\n            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental\n            timeLastCollected[_card] = _timeOfThisCollection;\n        }\n        return false;\n    }\n\n    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls\n    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit\n    function _collectRent(uint256 _card)\n        internal\n        returns (bool didUpdateEverything)\n    {\n        uint32 counter = 0;\n        bool shouldContinue = true;\n        while (counter < maxRentIterations && shouldContinue) {\n            shouldContinue = _collectRentAction(_card);\n            counter++;\n        }\n        return !shouldContinue;\n    }\n\n    /// @dev processes actual rent collection and updates the state\n    function _processRentCollection(\n        address _user,\n        uint256 _card,\n        uint256 _timeOfCollection\n    ) internal {\n        uint256 _rentOwed =\n            (cardPrice[_card] *\n                (_timeOfCollection - timeLastCollected[_card])) / 1 days;\n        treasury.payRent(_rentOwed);\n        uint256 _timeHeldToIncrement =\n            (_timeOfCollection - timeLastCollected[_card]);\n\n        // if the user has a timeLimit, adjust it as necessary\n        if (cardTimeLimit[_card] != 0) {\n            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);\n            cardTimeLimit[_card] -= _timeHeldToIncrement;\n        }\n        timeHeld[_card][_user] += _timeHeldToIncrement;\n        totalTimeHeld[_card] += _timeHeldToIncrement;\n        rentCollectedPerUser[_user] += _rentOwed;\n        rentCollectedPerCard[_card] += _rentOwed;\n        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;\n        totalRentCollected += _rentOwed;\n        timeLastCollected[_card] = _timeOfCollection;\n\n        // longest owner tracking\n        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {\n            longestTimeHeld[_card] = timeHeld[_card][_user];\n            longestOwner[_card] = _user;\n        }\n        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);\n    }\n\n    function _checkState(States currentState) internal view {\n        require(state == currentState, \"Incorrect state\");\n    }\n\n    function _checkNotState(States currentState) internal view {\n        require(state != currentState, \"Incorrect state\");\n    }\n\n    /// @dev should only be called thrice\n    function _incrementState() internal {\n        assert(uint256(state) < 4);\n        state = States(uint256(state) + (1));\n        emit LogStateChange(uint256(state));\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        CIRCUIT BREAKER          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev in case Oracle never resolves for any reason\n    /// @dev does not set a winner so same as invalid outcome\n    /// @dev market does not need to be locked, just in case lockMarket bugs out\n    function circuitBreaker() external {\n        require(\n            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),\n            \"Too early\"\n        );\n        _incrementState();\n        orderbook.closeMarket();\n        state = States.WITHDRAW;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCTreasury.sol",
            "RCMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\nfunction initialize(\n     ...\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L322\n function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n...\n  require( user[_msgSender].bidRate == 0 || block.timestamp (user[_msgSender].lastRentalTime)  uint256(1 days) / minRentalDayDivisor, \"Too soon\");\n..\n if ( user[_msgSender].bidRate != 0 &&  user[_msgSender].bidRate / (minRentalDayDivisor)   user[_msgSender].deposit ) {\n..\n\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L169\n  function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n"
                ],
                "Type": "  minRentalDayDivisor  can be different between markets and treasury",
                "Description": "\nThe minRentalDayDivisor is defined in RCTreasury.sol and copied to each market.\nThe minRentalDayDivisor can be updated via setMinRental, but then it isn't updated in the already created market.\n\nTo calculate the minimum rent time, in function withdrawDeposit of RCTreasury.sol, the latest version of minRentalDayDivisor is used, which could be different than the values in the market.\nSo the markets will calculate the minimum rent time different.\nThis could lead to unexpected results\nsolidity\nfunction initialize(\n     ...\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L322\n function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n...\n  require( user[_msgSender].bidRate == 0 || block.timestamp (user[_msgSender].lastRentalTime)  uint256(1 days) / minRentalDayDivisor, \"Too soon\");\n..\n if ( user[_msgSender].bidRate != 0 &&  user[_msgSender].bidRate / (minRentalDayDivisor)   user[_msgSender].deposit ) {\n..\n\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L169\n  function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n\n",
                "Repair": "Recommend either accepting or at least documenting the risk of change to code to prevent this from happening.\n\nSplidge (Reality Cards) acknowledged(https://github.com/code-423n4/2021-06-realitycards-findings/issues/31#issuecomment-861301786):\n  Yes, This became apparent recently when we changed the minRentalDayDivisor during a beta test.\n Ideally this value is never changed and if it is changed then it will be done very infrequently.\n The main protection minRentalDayDivisor offers is against a DoS attack whereby an attacker gains some ownership time on a card and then will fill the orderbook with bids using sybil accounts (withdrawing almost all deposit after placing the bids), without minRentalDayDivisor these low value (but legitimate) bids would prevent other users from gaining ownership of the card (due to gas limits there's a limit to the rental collections we can perform) and give the attacker a greater share of the prize pot. The benefit of minRentalDayDivisor is that now these are zero value bids which are eligible for immediate deletion, and so there is now more of a cost to the attack which scales with the cost of the rental prices (which will closely be linked to the value of the prize pot). To this end minRentalDayDivisor is at it's most useful in the Treasury where it's main purpose is fulfilled in withdrawDeposit(), the usage in the markets is less beneficial and wasn't considered worth the extra gas usage to have the Markets fetch the updated value given the infrequency we will be changing it.\n We have accepted this risk.\n\ndmvt (Judge) upgraded severity from 1 to 2(https://github.com/code-423n4/2021-06-realitycards-findings/issues/31#issuecomment-877275766):\n  Updating to Medium risk to match the other reporting wardens: \"Possible accidental loss of funds or information due to code manipulation or bad side effects of not properly outlining a payable function\"\n\n\n"
            },
            {
                "Name": "M-10",
                "Location": [
                    "\n///remove bids in closed markets for a given user\n///this can reduce the users `bidRate` and chance to foreclose\n"
                ],
                "Type": " Missing call to  removeOldBids  may affect foreclosure",
                "Description": "\nOrderbook.removeBids() as commented:\n\n///remove bids in closed markets for a given user\n///this can reduce the users bidRate and chance to foreclose\n\n\n\nremoveOldBids() is performed currently in Market.newRental() and Treasury.deposit() to  \u201cdo some cleaning up, it might help cancel their foreclosure\u201d as commented. However, this is missing in the withdrawDeposit() function where the need is the most because user is removing deposit which may lead to foreclosure and is even commented as being useful on L356.\n\nThe impact is that, if we do not remove closed market bids during withdrawDeposit, the closed market bids still get accounted in user's bidRate in the conditional on L357 and therefore do not prevent the foreclosure in withdrawDeposit that may happen in L357-L367. User may get foreclosed because of mis-accounted closed-market bids in the order book.\n\n",
                "Repair": "Recommend adding call to removeOldBids() on L355 of withdrawDeposit() of Treasury.\n\nSplidge (Reality Cards) confirmed but disagreed with severity and then resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/109#issuecomment-864960734):\n  This was intentionally left out in an older version of the contracts because of the way withdrawDeposit worked before we had the per-user rent collection.\n Added it back in again here(https://github.com/RealityCards/RealityCards-Contracts/commit/93e80368cc1d5f0ea6b397c5733af40ee7100a0b).\n\n\n"
            },
            {
                "Name": "M-15",
                "Location": [
                    "transferFrom()",
                    "transfer()",
                    "deposit()"
                ],
                "Type": " Deposits don't work with fee-on transfer tokens",
                "Description": "\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom().\n\nThe deposit() function will introduce unexpected balance inconsistencies when comparing internal asset records with external ERC20 token contracts.\n\n",
                "Repair": "Recommend measuring the asset change right before and after the asset-transferring routines as a possible mitigation.\n\nmcplums (Reality Cards) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/152#issuecomment-862970135):\n  I think balancedBooks modifier should handle this?\n\n Of course it means we are unable to use such tokens, but that is ok\n\nSplidge (Reality Cards) disputed(https://github.com/code-423n4/2021-06-realitycards-findings/issues/152#issuecomment-863172608)\n  oh, trying the same one again..? \ud83d\ude01\n https://github.com/code-423n4/2021-05-88mph-findings/issues/16\n\n I'll fight this one though, I'd argue that we are using ERC20 tokens and according to the ERC20 spec(https://github.com/code-423n4/2021-05-88mph-findings/issues/16) for transferFrom:\n\n  Transfers _value amount of tokens from address _from to address _to\n\n A deflationary token therefore isn't compliant to ERC20 as it doesn't transfer the full _value and so it isn't what we are planning to use and not relevant here.\n\ndmvt (Judge) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/152#issuecomment-877676755):\n  If you plan not to support these tokens it should be very clearly documented. Keep in mind that \"we don't support that\" still has massive impact on the users involved. See: imBTC / ERC777 on Uniswap v1. The issue is valid and should stand in the audit report, in part so that future users see it.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\n\n/// @title Reality Cards Orderbook\n/// @author Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCOrderbook is Ownable, NativeMetaTransaction, IRCOrderbook {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev a record of a users single bid\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 token;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n    /// @dev maps a user address to an array of their bids\n    mapping(address => Bid[]) public user;\n    /// @dev index of a bid record in the user array, User|Market|Token->Index\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        public index;\n\n    /// @dev record of market specific variables\n    struct Market {\n        uint64 mode;\n        uint64 tokenCount;\n        uint64 minimumPriceIncreasePercent;\n        uint64 minimumRentalDuration;\n    }\n    /// @dev map a market address to a market record\n    mapping(address => Market) public market;\n    /// @dev true if the address is a market\n    mapping(address => bool) public isMarket;\n    /// @dev find the current owner of a token in a given market. Market -> Token -> Owner\n    mapping(address => mapping(uint256 => address)) public ownerOf;\n\n    /// @dev an array of closed markets, used to reduce user bid rates\n    address[] public closedMarkets;\n    /// @dev how far through the array a given user is, saves iterating the whole array every time.\n    mapping(address => uint256) public userClosedMarketIndex;\n\n    ///// GOVERNANCE VARIABLES /////\n    /// @dev only allow the uberOwner to call certain functions\n    address public uberOwner;\n    /// @dev the current factory address\n    address public factoryAddress;\n    /// @dev the current treasury address\n    address public treasuryAddress;\n    IRCTreasury public treasury;\n    /// @dev max number of searches to place an order in the book\n    /// @dev current estimates place limit around 2000\n    uint256 public maxSearchIterations = 1000;\n    /// @dev max number of records to delete in one transaction\n    uint256 public maxDeletions = 70;\n    /// @dev number of bids a user should clean when placing a new bid\n    uint256 public cleaningLoops = 2;\n    /// @dev nonce emitted with orderbook insertions, for frontend sorting\n    uint256 public nonce;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          MODIFIERS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice only allow markets to call certain functions\n    modifier onlyMarkets {\n        require(isMarket[msgSender()], \"Not authorised\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev emitted every time an order is added to the orderbook\n    event LogAddToOrderbook(\n        address indexed newOwner,\n        uint256 indexed newPrice,\n        uint256 timeHeldLimit,\n        uint256 nonce,\n        uint256 indexed tokenId,\n        address market\n    );\n    /// @dev emitted when an order is removed from an active market\n    event LogRemoveFromOrderbook(\n        address indexed owner,\n        address indexed market,\n        uint256 indexed tokenId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CONSTRUCTOR             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _factoryAddress, address _treasuryAddress) {\n        factoryAddress = _factoryAddress;\n        treasuryAddress = _treasuryAddress;\n        treasury = IRCTreasury(treasuryAddress);\n        uberOwner = msgSender();\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         GOVERNANCE              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function changeUberOwner(address _newUberOwner) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0));\n        uberOwner = _newUberOwner;\n    }\n\n    function setFactoryAddress(address _newFactory) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newFactory != address(0));\n        factoryAddress = _newFactory;\n    }\n\n    function setLimits(\n        uint256 _deletionLimit,\n        uint256 _cleaningLimit,\n        uint256 _searchLimit\n    ) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        if (_deletionLimit != 0) {\n            maxDeletions = _deletionLimit;\n        }\n        if (_cleaningLimit != 0) {\n            cleaningLoops = _cleaningLimit;\n        }\n        if (_searchLimit != 0) {\n            maxSearchIterations = _searchLimit;\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             INSERTIONS              \u2551\n      \u2551 functions that add to the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice adds a new market to the orderbook\n    function addMarket(\n        address _market,\n        uint256 _cardCount,\n        uint256 _minIncrease\n    ) external override {\n        require(msgSender() == factoryAddress);\n        isMarket[_market] = true;\n        market[_market].tokenCount = SafeCast.toUint64(_cardCount);\n        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(\n            _minIncrease\n        );\n        market[_market].minimumRentalDuration = SafeCast.toUint64(\n            1 days / treasury.minRentalDayDivisor()\n        );\n        for (uint64 i; i < _cardCount; i++) {\n            // create new record for each card that becomes the head&tail of the linked list\n            Bid memory _newBid;\n            _newBid.market = _market;\n            _newBid.token = i;\n            _newBid.prev = _market;\n            _newBid.next = _market;\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = type(uint64).max;\n            index[_market][_market][i] = user[_market].length;\n            user[_market].push(_newBid);\n        }\n    }\n\n    /// @notice adds or updates a bid in the orderbook\n    /// @param _user the user placing the bid\n    /// @param _card the token to place the bid on\n    /// @param _price the price of the new bid\n    /// @param _timeHeldLimit an optional time limit for the bid\n    /// @param _prevUserAddress to help find where to insert the bid\n    function addBidToOrderbook(\n        address _user,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external override onlyMarkets {\n        // each new bid can help clean up some junk\n        cleanWastePile();\n\n        if (user[_user].length == 0 && closedMarkets.length > 0) {\n            //users first bid, skip already closed markets\n            userClosedMarketIndex[_user] = closedMarkets.length - 1;\n        }\n\n        address _market = msgSender();\n        if (_prevUserAddress == address(0)) {\n            _prevUserAddress = _market;\n        } else {\n            require(\n                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]\n                    .price >= _price,\n                \"Location too low\"\n            );\n        }\n        Bid storage _prevUser =\n            user[_prevUserAddress][index[_prevUserAddress][_market][_card]];\n\n        if (bidExists(_user, _market, _card)) {\n            // old bid exists, update it\n            _updateBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        } else {\n            // new bid, add it\n            _newBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        }\n    }\n\n    /// @dev finds the correct location in the orderbook for a given bid\n    /// @dev returns an adjusted (lowered) bid price if necessary.\n    function _searchOrderbook(\n        Bid storage _prevUser,\n        address _market,\n        uint256 _card,\n        uint256 _price\n    ) internal view returns (Bid storage, uint256) {\n        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;\n        Bid storage _nextUser =\n            user[_prevUser.next][index[_prevUser.next][_market][_card]];\n        uint256 _requiredPrice =\n            (_nextUser.price * (_minIncrease + (100))) / (100);\n\n        uint256 i = 0;\n        while (\n            // break loop if match price above AND above price below (so if either is false, continue, hence OR )\n            // if match previous then must be greater than next to continue\n            (_price != _prevUser.price || _price <= _nextUser.price) &&\n            // break loop if price x% above below\n            _price < _requiredPrice &&\n            // break loop if hits max iterations\n            i < maxSearchIterations\n        ) {\n            _prevUser = _nextUser;\n            _nextUser = user[_prevUser.next][\n                index[_prevUser.next][_market][_card]\n            ];\n            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);\n            i++;\n        }\n        require(i < maxSearchIterations, \"Position in orderbook not found\");\n\n        // if previous price is zero it must be the market and this is a new owner\n        // .. then don't reduce their price, we already checked they are 10% higher\n        // .. than the previous owner.\n        if (_prevUser.price != 0 && _prevUser.price < _price) {\n            _price = _prevUser.price;\n        }\n        return (_prevUser, _price);\n    }\n\n    /// @dev add a new bid to the orderbook\n    function _newBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        if (ownerOf[_market][_card] != _market) {\n            (_prevUser, _price) = _searchOrderbook(\n                _prevUser,\n                _market,\n                _card,\n                _price\n            );\n        }\n\n        Bid storage _nextUser =\n            user[_prevUser.next][index[_prevUser.next][_market][_card]];\n\n        // create new record\n        Bid memory _newBid;\n        _newBid.market = _market;\n        _newBid.token = SafeCast.toUint64(_card);\n        _newBid.prev = _nextUser.prev;\n        _newBid.next = _prevUser.next;\n        _newBid.price = SafeCast.toUint128(_price);\n        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // insert in linked list\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n        user[_user].push(_newBid);\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = user[_user].length - (1);\n\n        emit LogAddToOrderbook(\n            _user,\n            _price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _price);\n        if (user[_user][index[_user][_market][_card]].prev == _market) {\n            address _oldOwner = user[_user][index[_user][_market][_card]].next;\n            transferCard(_market, _card, _oldOwner, _user, _price);\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                user[_oldOwner][index[_oldOwner][_market][_card]].price,\n                _price,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @dev updates a bid that is already in the orderbook\n    function _updateBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        // TODO no need to unlink and relink if bid doesn't change position in orderbook\n        // unlink current bid\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n        user[_currUser.next][index[_currUser.next][_market][_card]]\n            .prev = _currUser.prev;\n        user[_currUser.prev][index[_currUser.prev][_market][_card]]\n            .next = _currUser.next;\n        bool _owner = _currUser.prev == _market;\n\n        // find new position\n        (_prevUser, _price) = _searchOrderbook(\n            _prevUser,\n            _market,\n            _card,\n            _price\n        );\n        Bid storage _nextUser =\n            user[_prevUser.next][index[_prevUser.next][_market][_card]];\n\n        // update price, save old price for rental rate adjustment later\n        (_currUser.price, _price) = (\n            SafeCast.toUint128(_price),\n            uint256(_currUser.price)\n        );\n        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // relink bid\n        _currUser.next = _prevUser.next;\n        _currUser.prev = _nextUser.prev;\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n\n        emit LogAddToOrderbook(\n            _user,\n            _currUser.price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _currUser.price);\n        treasury.decreaseBidRate(_user, _price);\n        if (_owner && _currUser.prev == _market) {\n            // if owner before and after, update the price difference\n            transferCard(_market, _card, _user, _user, _currUser.price);\n            treasury.updateRentalRate(\n                _user,\n                _user,\n                _price,\n                _currUser.price,\n                block.timestamp\n            );\n        } else if (_owner && _currUser.prev != _market) {\n            // if owner before and not after, remove the old price\n            address _newOwner =\n                user[_market][index[_market][_market][_card]].next;\n            uint256 _newPrice =\n                user[_newOwner][index[_newOwner][_market][_card]].price;\n            treasury.updateRentalRate(\n                _user,\n                _newOwner,\n                _price,\n                _newPrice,\n                block.timestamp\n            );\n            transferCard(_market, _card, _user, _newOwner, _newPrice);\n        } else if (!_owner && _currUser.prev == _market) {\n            // if not owner before but is owner after, add new price\n            address _oldOwner = _currUser.next;\n            uint256 _oldPrice =\n                user[_oldOwner][index[_oldOwner][_market][_card]].price;\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                _oldPrice,\n                _currUser.price,\n                block.timestamp\n            );\n            transferCard(_market, _card, _oldOwner, _user, _currUser.price);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551                DELETIONS                 \u2551      \n      \u2551 functions that remove from the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice removes a single bid from the orderbook - onlyMarkets\n    function removeBidFromOrderbook(address _user, uint256 _card)\n        public\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        // update rates\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n        treasury.decreaseBidRate(_user, _currUser.price);\n        if (_currUser.prev == _market) {\n            // user is owner, deal with it\n            uint256 _price =\n                user[_currUser.next][index[_currUser.next][_market][_card]]\n                    .price;\n            transferCard(_market, _card, _user, _currUser.next, _price);\n            treasury.updateRentalRate(\n                _user,\n                _currUser.next,\n                _currUser.price,\n                _price,\n                block.timestamp\n            );\n        }\n        // extract from linked list\n        address _tempNext = _currUser.next;\n        address _tempPrev = _currUser.prev;\n        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;\n        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;\n\n        // overwrite array element\n        uint256 _index = index[_user][_market][_card];\n        uint256 _lastRecord = user[_user].length - (1);\n\n        // no point overwriting itself\n        if (_index != _lastRecord) {\n            user[_user][_index] = user[_user][_lastRecord];\n        }\n        user[_user].pop();\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = 0;\n        if (user[_user].length != 0 && _index != _lastRecord) {\n            index[_user][user[_user][_index].market][\n                user[_user][_index].token\n            ] = _index;\n        }\n        emit LogRemoveFromOrderbook(_user, _market, _card);\n    }\n\n    /// @dev removes a single bid from the orderbook, doesn't update ownership\n    function _removeBidFromOrderbookIgnoreOwner(address _user, uint256 _card)\n        internal\n        returns (uint256 _newPrice)\n    {\n        address _market = msgSender();\n        // update rates\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n        treasury.decreaseBidRate(_user, _currUser.price);\n\n        // extract from linked list\n        address _tempNext = _currUser.next;\n        address _tempPrev = _currUser.prev;\n        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;\n        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;\n\n        // return next users price to check they're eligable later\n        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;\n\n        // overwrite array element\n        uint256 _index = index[_user][_market][_card];\n        uint256 _lastRecord = user[_user].length - 1;\n        // no point overwriting itself\n        if (_index != _lastRecord) {\n            user[_user][_index] = user[_user][_lastRecord];\n        }\n        user[_user].pop();\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = 0;\n        if (user[_user].length != 0 && _index != _lastRecord) {\n            index[_user][user[_user][_index].market][\n                user[_user][_index].token\n            ] = _index;\n        }\n        emit LogRemoveFromOrderbook(_user, _market, _card);\n    }\n\n    /// @notice find the next valid owner of a given card - onlyMarkets\n    /// @param _card the token to remove\n    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes\n    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)\n        external\n        override\n        onlyMarkets\n        returns (address _newOwner)\n    {\n        address _market = msgSender();\n        // the market is the head of the list, the next bid is therefore the owner\n        Bid storage _head = user[_market][index[_market][_market][_card]];\n        address _oldOwner = _head.next;\n        uint256 _oldPrice =\n            user[_oldOwner][index[_oldOwner][_market][_card]].price;\n        uint256 minimumTimeToOwnTo =\n            _timeOwnershipChanged + market[_market].minimumRentalDuration;\n        uint256 _newPrice;\n\n        // delete current owner\n        do {\n            _newPrice = _removeBidFromOrderbookIgnoreOwner(_head.next, _card);\n            // delete next bid if foreclosed\n        } while (\n            treasury.foreclosureTimeUser(\n                _head.next,\n                _newPrice,\n                _timeOwnershipChanged\n            ) < minimumTimeToOwnTo\n        );\n\n        // the old owner is dead, long live the new owner\n        _newOwner = user[_market][index[_market][_market][_card]].next;\n        treasury.updateRentalRate(\n            _oldOwner,\n            _newOwner,\n            _oldPrice,\n            _newPrice,\n            _timeOwnershipChanged\n        );\n        transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);\n    }\n\n    /// @notice when a user has foreclosed we can freely delete their bids\n    /// @param _user the user whose bids to start deleting\n    /// @return _userForeclosed if the user doesn't have bids left they are considered not foreclosed anymore\n    function removeUserFromOrderbook(address _user)\n        external\n        override\n        returns (bool _userForeclosed)\n    {\n        require(treasury.isForeclosed(_user), \"User must be foreclosed\");\n        uint256 i = user[_user].length;\n        uint256 _limit = 0;\n        if (i > maxDeletions) {\n            _limit = i - maxDeletions;\n        }\n        address _market = user[_user][i - 1].market;\n        uint256 _card = user[_user][i - 1].token;\n\n        do {\n            i--;\n            index[_user][user[_user][i].market][user[_user][i].token] = 0;\n            address _tempPrev = user[_user][i].prev;\n            address _tempNext = user[_user][i].next;\n\n            // reduce the rentalRate if they are owner\n            if (_tempPrev == user[_user][i].market) {\n                _market = user[_user][i].market;\n                _card = user[_user][i].token;\n                uint256 _price =\n                    user[_tempNext][index[_tempNext][_market][_card]].price;\n                treasury.updateRentalRate(\n                    _user,\n                    _tempNext,\n                    user[_user][i].price,\n                    _price,\n                    block.timestamp\n                );\n                transferCard(_market, _card, _user, _tempNext, _price);\n            }\n\n            treasury.decreaseBidRate(_user, user[_user][i].price);\n\n            user[_tempNext][\n                index[_tempNext][user[_user][i].market][user[_user][i].token]\n            ]\n                .prev = _tempPrev;\n            user[_tempPrev][\n                index[_tempPrev][user[_user][i].market][user[_user][i].token]\n            ]\n                .next = _tempNext;\n            user[_user].pop();\n        } while (user[_user].length > _limit);\n        if (user[_user].length == 0) {\n            treasury.resetUser(_user);\n            _userForeclosed = false;\n        } else {\n            _userForeclosed = true;\n        }\n    }\n\n    /// @notice reduces the rentalRates of the card owners when a market closes\n    /// @dev too many bidders to reduce all bid rates also\n    function closeMarket() external override onlyMarkets {\n        address _market = msgSender();\n        closedMarkets.push(_market);\n\n        for (uint64 i = 0; i < market[_market].tokenCount; i++) {\n            // reduce owners rental rate\n            address _owner = user[_market][index[_market][_market][i]].next;\n            uint256 _price = user[_owner][index[_owner][_market][i]].price;\n            treasury.updateRentalRate(\n                _owner,\n                _market,\n                _price,\n                0,\n                block.timestamp\n            );\n\n            // store first and last bids for later\n            address _firstBid = _owner;\n            address _lastBid = user[_market][index[_market][_market][i]].prev;\n\n            // detach market from rest of list\n            user[_market][index[_market][_market][i]].prev = _market;\n            user[_market][index[_market][_market][i]].next = _market;\n            user[_firstBid][index[_market][_firstBid][i]].prev = address(this);\n            user[_lastBid][index[_market][_lastBid][i]].next = address(this);\n\n            // insert bids in the waste pile\n            Bid memory _newBid;\n            _newBid.market = _market;\n            _newBid.token = i;\n            _newBid.prev = _lastBid;\n            _newBid.next = _firstBid;\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = 0;\n            user[address(this)].push(_newBid);\n        }\n    }\n\n    /// @notice Remove bids in closed markets for a given user\n    /// @notice this can reduce the users bidRate and chance to foreclose\n    /// @param _user the address of the users bids to remove\n    function removeOldBids(address _user) external override {\n        address _market;\n        uint256 _cardCount;\n        uint256 _loopCounter;\n        while (\n            userClosedMarketIndex[_user] < closedMarkets.length &&\n            _loopCounter + _cardCount < maxDeletions\n        ) {\n            _market = closedMarkets[userClosedMarketIndex[_user]];\n            _cardCount = market[_market].tokenCount;\n            for (uint256 i = market[_market].tokenCount; i != 0; ) {\n                i--;\n                if (bidExists(_user, _market, i)) {\n                    // reduce bidRate\n                    uint256 _price =\n                        user[_user][index[_user][_market][i]].price;\n                    treasury.decreaseBidRate(_user, _price);\n\n                    // preserve linked list\n                    address _tempPrev =\n                        user[_user][index[_user][_market][i]].prev;\n                    address _tempNext =\n                        user[_user][index[_user][_market][i]].next;\n\n                    user[_tempNext][index[_tempNext][_market][i]]\n                        .prev = _tempPrev;\n                    user[_tempPrev][index[_tempPrev][_market][i]]\n                        .next = _tempNext;\n\n                    // delete bid\n                    user[_user].pop();\n                    index[_user][_market][i] = 0;\n\n                    // count deletions\n                    _loopCounter++;\n                }\n            }\n            userClosedMarketIndex[_user]++;\n        }\n    }\n\n    /// @dev remove bids in closed markets, not user specific\n    function cleanWastePile() internal {\n        uint256 i;\n        while (i < cleaningLoops && user[address(this)].length > 0) {\n            uint256 _pileHeight = user[address(this)].length - 1;\n\n            if (user[address(this)][_pileHeight].next == address(this)) {\n                user[address(this)].pop();\n            } else {\n                address _market = user[address(this)][_pileHeight].market;\n                uint256 _card = user[address(this)][_pileHeight].token;\n                address _user =\n                    user[address(this)][index[address(this)][_market][_card]]\n                        .next;\n\n                Bid storage _currUser =\n                    user[_user][index[_user][_market][_card]];\n                // extract from linked list\n                address _tempNext = _currUser.next;\n                address _tempPrev = _currUser.prev;\n                user[_tempNext][index[_tempNext][_market][_card]]\n                    .prev = _tempPrev;\n                user[_tempPrev][index[_tempPrev][_market][_card]]\n                    .next = _tempNext;\n\n                // overwrite array element\n                uint256 _index = index[_user][_market][_card];\n                uint256 _lastRecord = user[_user].length - (1);\n                // no point overwriting itself\n                if (_index != _lastRecord) {\n                    user[_user][_index] = user[_user][_lastRecord];\n                }\n                user[_user].pop();\n\n                // update the index to help find the record later\n                index[_user][_market][_card] = 0;\n                if (user[_user].length != 0 && _index != _lastRecord) {\n                    index[_user][user[_user][_index].market][\n                        user[_user][_index].token\n                    ] = _index;\n                }\n            }\n            i++;\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        HELPER FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check if a bid exists\n    /// @param _user the address of the user\n    /// @param _market the address of the market\n    /// @param _card the card index\n    /// @return if the bid exists or not\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) public view override returns (bool) {\n        if (user[_user].length != 0) {\n            //some bids exist\n            if (index[_user][_market][_card] != 0) {\n                // this bid exists\n                return true;\n            } else {\n                // check bid isn't index 0\n                if (\n                    user[_user][0].market == _market &&\n                    user[_user][0].token == _card\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function getBidValue(address _user, uint256 _card)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address _market = msgSender();\n        if (bidExists(_user, _market, _card)) {\n            return user[_user][index[_user][_market][_card]].price;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @dev just to pass old tests, not needed otherwise\n    /// @dev to be deleted once tests updated\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory) {\n        if (bidExists(_user, _market, _card)) {\n            Bid memory _bid = user[_user][index[_user][_market][_card]];\n            return _bid;\n        } else {\n            Bid memory _newBid;\n            _newBid.market = address(0);\n            _newBid.token = SafeCast.toUint64(_card);\n            _newBid.prev = address(0);\n            _newBid.next = address(0);\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = 0;\n            return _newBid;\n        }\n    }\n\n    function getTimeHeldlimit(address _user, uint256 _card)\n        external\n        view\n        override\n        onlyMarkets\n        returns (uint256)\n    {\n        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;\n    }\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeldLimit\n    ) external override onlyMarkets {\n        address _market = msgSender();\n        require(bidExists(_user, _market, _card), \"Bid doesn't exist\");\n        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast\n            .toUint64(_timeHeldLimit);\n    }\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeToReduce\n    ) external override onlyMarkets {\n        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast\n            .toUint64(_timeToReduce);\n    }\n\n    function transferCard(\n        address _market,\n        uint256 _card,\n        address _oldOwner,\n        address _newOwner,\n        uint256 _price\n    ) internal {\n        ownerOf[_market][_card] = _newOwner;\n        uint256 _timeLimit =\n            user[_newOwner][index[_newOwner][_market][_card]].timeHeldLimit;\n        IRCMarket _rcmarket = IRCMarket(_market);\n        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCOrderbook.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [],
                "Type": " Possible locked-ether (funds) Issue in  RCOrderbook.sol ",
                "Description": "\nWhen running the analyzer code, the following functions were found in RCOrderbook.sol to possibly lock funds due to it being a payable function with no withdraw function associated. See Issue #43(https://github.com/code-423n4/2021-06-realitycards-findings/issues/43) for more details.\n\nSplidge (Reality Cards) confirmed initially and then disputed(https://github.com/code-423n4/2021-06-realitycards-findings/issues/43#issuecomment-861332540):\n  I initially confirmed this because we aren't using the native currency on Matic/Polygon. However I think this should be disputed mainly because this function is used to call other functions which might be payable, although I admit currently we don't have payable functions, we might add them in the future.\n This library is used across all our contracts, had we put a payable function in the Treasury for instance, would this be considered a flaw to have this same library imported into the Orderbook?\n\nSplidge (Reality Cards) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/43#issuecomment-861566988):\n  Note that the duplicate issue #51 was submitted by the same user.\n\ndmvt (Judge) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/43#issuecomment-877652563):\n  Agree with the sponsor's explanation, but the issue exists regardless. Adding a way to retrieve locked funds would mitigate the issue.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"hardhat/console.sol\";\nimport \"../interfaces/IRCMarket.sol\";\nimport \"../lib/NativeMetaTransaction.sol\";\nimport \"../interfaces/IRCNftHubL2.sol\";\n\n/// @title Reality Cards NFT Hub- Layer 2 side\n/// @author Andrew Stanger & Daniel Chilvers\ncontract RCNftHubL2 is\n    Ownable,\n    ERC721URIStorage,\n    AccessControl,\n    NativeMetaTransaction,\n    IRCNftHubL2\n{\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can move NFTs\n    mapping(address => bool) public isMarket;\n    /// @dev the market each NFT belongs to, so that it can only be moved in withdraw state\n    mapping(uint256 => address) public override marketTracker;\n\n    /// @dev governance variables\n    address public factoryAddress;\n\n    /// @dev matic mintable asset requirements\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n    mapping(uint256 => bool) public withdrawnTokens;\n    event WithdrawnBatch(address indexed user, uint256[] tokenIds);\n    event TransferWithMetadata(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId,\n        bytes metaData\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _factoryAddress, address childChainManager)\n        ERC721(\"RealityCards\", \"RC\")\n    {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsNftHubL2\", \"1\");\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(DEPOSITOR_ROLE, childChainManager);\n        setFactoryAddress(_factoryAddress);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          ADD MARKETS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can change ownership\n    function addMarket(address _newMarket) external override {\n        require(msgSender() == factoryAddress, \"Not factory\");\n        isMarket[_newMarket] = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          GOVERNANCE             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev address of RC factory contract, so only factory can mint\n    function setFactoryAddress(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        factoryAddress = _newAddress;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        CORE FUNCTIONS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // FACTORY ONLY\n    function mint(\n        address _originalOwner,\n        uint256 _tokenId,\n        string calldata _tokenURI\n    ) external override returns (bool) {\n        require(\n            !withdrawnTokens[_tokenId],\n            \"ChildMintableERC721: TOKEN_EXISTS_ON_ROOT_CHAIN\"\n        );\n        require(msgSender() == factoryAddress, \"Not factory\");\n        _mint(_originalOwner, _tokenId);\n        _setTokenURI(_tokenId, _tokenURI);\n        marketTracker[_tokenId] = _originalOwner;\n        return true;\n    }\n\n    // MARKET ONLY\n    function transferNft(\n        address _currentOwner,\n        address _newOwner,\n        uint256 _tokenId\n    ) external override returns (bool) {\n        require(isMarket[msgSender()], \"Not market\");\n        _transfer(_currentOwner, _newOwner, _tokenId);\n        return true;\n    }\n\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override(ERC721, IRCNftHubL2)\n        returns (address)\n    {\n        return ERC721.ownerOf(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override(ERC721URIStorage, IRCNftHubL2)\n        returns (string memory)\n    {\n        return ERC721URIStorage.tokenURI(tokenId);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MATIC MINTABLE           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function deposit(address user, bytes calldata depositData)\n        external\n        override\n        onlyRole(DEPOSITOR_ROLE)\n    {\n        // deposit single\n        if (depositData.length == 32) {\n            uint256 tokenId = abi.decode(depositData, (uint256));\n            withdrawnTokens[tokenId] = false;\n            _mint(user, tokenId);\n\n            // deposit batch\n        } else {\n            uint256[] memory tokenIds = abi.decode(depositData, (uint256[]));\n            uint256 length = tokenIds.length;\n            for (uint256 i; i < length; i++) {\n                withdrawnTokens[tokenIds[i]] = false;\n                _mint(user, tokenIds[i]);\n            }\n        }\n    }\n\n    function withdraw(uint256 tokenId) external override {\n        require(isMarket[msgSender()], \"Not market\");\n        require(\n            _msgSender() == ownerOf(tokenId),\n            \"ChildMintableERC721: INVALID_TOKEN_OWNER\"\n        );\n        withdrawnTokens[tokenId] = true;\n        _burn(tokenId);\n    }\n\n    function withdrawWithMetadata(uint256 tokenId) external override {\n        require(isMarket[msgSender()], \"Not market\");\n        require(\n            msgSender() == ownerOf(tokenId),\n            \"ChildMintableERC721: INVALID_TOKEN_OWNER\"\n        );\n        withdrawnTokens[tokenId] = true;\n\n        // Encoding metadata associated with tokenId & emitting event\n        emit TransferWithMetadata(\n            ownerOf(tokenId),\n            address(0),\n            tokenId,\n            this.encodeTokenMetadata(tokenId)\n        );\n\n        _burn(tokenId);\n    }\n\n    function encodeTokenMetadata(uint256 tokenId)\n        external\n        view\n        virtual\n        returns (bytes memory)\n    {\n        return abi.encode(tokenURI(tokenId));\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl, ERC721)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IRCNftHubL2).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           OVERRIDES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev ensures NFTs can only be moved when market is resolved\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        IRCMarket market = IRCMarket(marketTracker[tokenId]);\n        require(market.state() == IRCMarket.States.WITHDRAW, \"Incorrect state\");\n        require(ownerOf(tokenId) == msgSender(), \"Not owner\");\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public override {\n        IRCMarket market = IRCMarket(marketTracker[tokenId]);\n        require(market.state() == IRCMarket.States.WITHDRAW, \"Incorrect state\");\n        require(ownerOf(tokenId) == msgSender(), \"Not owner\");\n        _transfer(from, to, tokenId);\n        _data;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public orderbook;\n    /// @dev nfthub instance, to query current card owner\n    IRCNftHubL2 public nfthub;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev address of the Factory so only the Factory can add new markets\n    address public override factoryAddress;\n    /// @dev so only markets can use certain functions\n    mapping(address => bool) public override isMarket;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public marketBalance;\n    /// @dev a quick check if a uesr is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 marketBalanceDiscrepancy;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent any cards for specific market\n    mapping(address => bool) public override marketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            UBER OWNER           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev high level owner who can change the factory address\n    address public override uberOwner;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1000000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /// @notice only allow markets to call these functions\n    modifier onlyMarkets {\n        require(isMarket[msgSender()], \"Not authorised\");\n        _;\n    }\n\n    /// @notice only allow orderbook to call these functions\n    modifier onlyOrderbook {\n        require(msgSender() == address(orderbook), \"Not authorised\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           ADD MARKETS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can move funds from deposits to marketPots and vice versa\n    function addMarket(address _newMarket) external override {\n        require(msgSender() == factoryAddress, \"Not factory\");\n        isMarket[_newMarket] = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyOwner\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyOwner {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental for a specific market\n    function changePauseMarket(address _market) external override onlyOwner {\n        require(isMarket[_market], \"This isn't a market\");\n        marketPaused[_market] = !marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyOwner {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add a user to the whitelist\n    function addToWhitelist(address _user) public override {\n        IRCFactory factory = IRCFactory(factoryAddress);\n        require(factory.isGovernor(msgSender()), \"Not authorised\");\n        isAllowed[_user] = !isAllowed[_user];\n    }\n\n    /// @notice Add multiple users to the whitelist\n    function batchAddToWhitelist(address[] calldata _users) public override {\n        for (uint256 index = 0; index < _users.length; index++) {\n            addToWhitelist(_users[index]);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    function setFactoryAddress(address _newFactory) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newFactory != address(0), \"Must set an address\");\n        factoryAddress = _newFactory;\n    }\n\n    function setOrderbookAddress(address _newOrderbook) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newOrderbook != address(0), \"Must set an address\");\n        orderbook = IRCOrderbook(_newOrderbook);\n    }\n\n    function setNftHubAddress(address _NFTHubAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_NFTHubAddress != address(0), \"Must set an address\");\n        nfthub = IRCNftHubL2(_NFTHubAddress);\n    }\n\n    function setTokenAddress(address _newToken) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    function changeUberOwner(address _newUberOwner) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0), \"Must set an address\");\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract (newRental) or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        public\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(isAllowed[msgSender()], \"Not in whitelist\");\n        }\n        erc20.transferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        if (\n            (user[_user].deposit + _amount) >\n            (user[_user].bidRate / minRentalDayDivisor)\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // stpe 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.transfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            isForeclosed[_msgSender] = true;\n            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(\n                _msgSender\n            );\n            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount) external override {\n        erc20.transferFrom(msgSender(), address(this), _amount);\n        if (_amount > marketBalanceDiscrepancy) {\n            marketBalanceDiscrepancy = 0;\n        } else {\n            marketBalanceDiscrepancy -= _amount;\n        }\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            marketBalanceDiscrepancy += _amount - marketBalance;\n            _amount -= (_amount - marketBalance);\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n\n        return true;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        assert(marketPot[msgSender()] >= _amount);\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        onlyMarkets\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        if (\n            isForeclosed[_user] &&\n            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.transferFrom(_sponsor, address(this), _amount);\n        marketPot[msgSender()] += _amount;\n        totalMarketPots += _amount;\n        return true;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyMarkets\n        returns (bool)\n    {\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        if (user[_user].lastRentCalc == 0) {\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n        return true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice provides the sum total of a users bids accross all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyOrderbook {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !isMarket[_newOwner]\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed =\n                    rentOwedBetweenTimestmaps(\n                        block.timestamp,\n                        _timeOwnershipChanged,\n                        _newPrice\n                    );\n                collectRentUser(_newOwner, block.timestamp);\n\n                // they have enough funds, just collect the extra\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /// @dev called when all a user's bids have been removed, disables foreclosure state\n    function resetUser(address _user) external override onlyOrderbook {\n        isForeclosed[_user] = false;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calcualtion and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calcualtes the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestmaps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the amount of deposit a user is able to withdraw\n    /// @notice ..after considering rent due to be paid\n    /// @param _user the user to query\n    function depositAbleToWithdraw(address _user)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 collection = rentOwedUser(_user, block.timestamp);\n        if (collection >= user[_user].deposit) {\n            return 0;\n        } else {\n            return uint256(user[_user].deposit) - (collection);\n        }\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)\n            //                   = (deposit * 1day) / totalUserDailyRent\n            uint256 timeLeftOfDeposit =\n                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard =\n                user[_user].lastRentCalc + timeLeftOfDeposit;\n\n            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {\n                // calculate how long they can own the new card for\n                uint256 _rentAlreadyOwed =\n                    rentOwedBetweenTimestmaps(\n                        user[_user].lastRentCalc,\n                        _timeOfNewBid,\n                        totalUserDailyRent\n                    );\n                uint256 _depositAtTimeOfNewBid =\n                    user[_user].deposit - _rentAlreadyOwed;\n                uint256 _timeLeftOfDepositWithNewBid =\n                    (_depositAtTimeOfNewBid * 1 days) /\n                        (totalUserDailyRent + _newBid);\n                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            // if no rentals they'll foreclose after the heat death of the universe\n            return type(uint256).max;\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        assert(_timeToCollectTo != 0);\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts =\n                    ((_timeToCollectTo - previousCollectionTime) *\n                        uint256(user[_user].deposit)) / rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepsitLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets availiable balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCNftHubL2.sol",
            "RCTreasury.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-11",
                "Location": [
                    "transferFrom()",
                    "safeTransferFrom()"
                ],
                "Type": " NFT Hub implementation deviates from ERC721 for transfer functions",
                "Description": "\nERC721 standard and implementation allows the use of approved addresses to affect transfers besides the token owners. However, the L2 NFT Hub implementation deviates from ERC721 by ignoring the presence of any approvers in the overriding function implementations of transferFrom() and safeTransferFrom().\n\nThe impact is that the system interactions with NFT platforms may not work if they expect ERC721 adherence. Users who interact via approved addresses will see their transfers failing for their approved addresses.\n\nGiven that the key value proposition of this project is the use of NFTs, the expectation will be that it is fully compatible with ERC721.\n\n",
                "Repair": "Recommend adding support for approval in NFT transfers.\n\nmcplums (Reality Cards) commented(https://github.com/code-423n4/2021-06-realitycards-findings/issues/118#issuecomment-862995040):\n  This is a nice one, I see no reason why we can't implement this\n\nSplidge (Reality Cards) confirmed(https://github.com/code-423n4/2021-06-realitycards-findings/issues/118#issuecomment-863895939):\n  Yes, we will need to add this, although we will need to override the approvals until the market has locked and the cards true owner is discovered.\n\nSplidge (Reality Cards) resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/118#issuecomment-865018341):\n  I've changed from overriding specific functions which could be dangerous if we were to upgrade to an OpenZeppelin implementation that had alternative transfer functions.\n Now we use the _beforeTokenTransfer hook and check that only the factory or the market can do a transfer before the market has entered the withdraw state. Implemented here(https://github.com/RealityCards/RealityCards-Contracts/commit/a628ac8e0132f7ca4159980f791ae820100c0888)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRealitio.sol\";\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    //\u2261\u2261\u2261\u2261\u2261\u2261\u2261 CONTRACT VARIABLES \u2261\u2261\u2261\u2261\u2261\u2261\u2261//\n    IRCTreasury public override treasury;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRealitio public realitio;\n\n    ///// CONTRACT ADDRESSES /////\n    /// @dev reference contract\n    address public referenceContractAddress;\n    /// @dev increments each time a new reference contract is added\n    uint256 public referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(uint256 => address[]) public marketAddresses;\n    mapping(address => bool) public mappingOfMarkets;\n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum tokens that must be sent when creating market which forms iniital pot\n    uint256 public sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public maximumDuration;\n    /// @dev list of governors\n    mapping(address => bool) public governors;\n    /// @dev if false, anyone can create markets\n    bool public marketCreationGovernorsOnly = true;\n    /// @dev if false, anyone can be an affiliate\n    bool public approvedAffilliatesOnly = true;\n    /// @dev if false, anyone can be an artist\n    bool public approvedArtistsOnly = true;\n    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity\n    bool public override trapIfUnapproved = true;\n    /// @dev high level owner who can change the factory address\n    address public uberOwner;\n    /// @dev the maximum number of rent collections to perform in a single transaction\n    uint256 public override maxRentIterations;\n    /// @dev the address of the arbitrator\n    address public arbitrator;\n    /// @dev the time allowed to dispute the oracle answer\n    uint32 public timeout;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public override isMarketApproved;\n    /// @dev allows artist to receive cut of total rent\n    mapping(address => bool) public isArtistApproved;\n    /// @dev allows affiliate to receive cut of total rent\n    mapping(address => bool) public isAffiliateApproved;\n    /// @dev allows card affiliate to receive cut of total rent\n    mapping(address => bool) public isCardAffiliateApproved;\n    /// @dev a limit to the number of NFTs to mint per market\n    uint256 public nftMintingLimit;\n\n    ///// OTHER /////\n    /// @dev counts the total NFTs minted across all events\n    /// @dev ... so the appropriate token id is used when upgrading to mainnet\n    uint256 public totalNftMintCount;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogMarketCreated1(\n        address contractAddress,\n        address treasuryAddress,\n        address nftHubAddress,\n        uint256 referenceContractVersion\n    );\n    event LogMarketCreated2(\n        address contractAddress,\n        uint32 mode,\n        string[] tokenURIs,\n        string ipfsHash,\n        uint32[] timestamps,\n        uint256 totalNftMintCount\n    );\n    event LogMarketApproved(address market, bool hidden);\n    event LogAdvancedWarning(uint256 _newAdvancedWarning);\n    event LogMaximumDuration(uint256 _newMaximumDuration);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev Treasury must be deployed before Factory\n    constructor(\n        IRCTreasury _treasuryAddress,\n        address _realitioAddress,\n        address _arbitratorAddress\n    ) {\n        require(address(_treasuryAddress) != address(0));\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise contract variable\n        treasury = _treasuryAddress;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate\n        setminimumPriceIncreasePercent(10); // 10%\n        setNFTMintingLimit(60); // current gas limit (12.5m) allows for 60 NFTs to be minted\n        setMaxRentIterations(35); // limit appears to be 41, set safe at 35 for now.\n        // oracle\n        setArbitrator(_arbitratorAddress);\n        setRealitioAddress(_realitioAddress);\n        setTimeout(86400); // 24 hours\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          VIEW FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Fetch the address of the most recently created market\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return the address of the most recent market in the given mode\n    function getMostRecentMarket(uint256 _mode)\n        external\n        view\n        returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n    /// @notice Fetch all the market addresses for a given mode\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return an array of all markets in a given mode\n    function getAllMarkets(uint256 _mode)\n        external\n        view\n        returns (address[] memory)\n    {\n        return marketAddresses[_mode];\n    }\n\n    /// @notice Returns the currently set pot distribution\n    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates\n    function getPotDistribution()\n        external\n        view\n        override\n        returns (uint256[5] memory)\n    {\n        return potDistribution;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev include the owner as a governor\n    modifier onlyGovernors() {\n        require(\n            governors[msgSender()] || owner() == msgSender(),\n            \"Not approved\"\n        );\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - OWNER (SETUP)  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n\n    /// @notice where the NFTs live\n    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but\n    /// @dev ... keeping flexible in case returning to previous contract\n    /// @param _newAddress the address to set\n    /// @param _newNftMintCount the number of NFTs this contract has minted, in order to keep them unique\n    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)\n        external\n        onlyOwner\n    {\n        require(address(_newAddress) != address(0));\n        nfthub = _newAddress;\n        totalNftMintCount = _newNftMintCount;\n    }\n\n    /// @notice set the address of the orderbook contract\n    /// @param _newAddress the address to set\n    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {\n        require(address(_newAddress) != address(0));\n        orderbook = _newAddress;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase & pot distribution emitted by Market.\n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice update stakeholder payouts\n    /// @dev in basis points (so 1000 = 100%)\n    /// @param _artistCut The artist that designed the card\n    /// @param _winnerCut Extra cut for the longest owner\n    /// @param _creatorCut The creator of the market\n    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts\n    /// @param _cardAffiliateCut An affiliate cur for specific cards\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) public onlyOwner {\n        require(\n            _artistCut +\n                _winnerCut +\n                _creatorCut +\n                _affiliateCut +\n                _cardAffiliateCut <=\n                1000,\n            \"Cuts too big\"\n        );\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%\n    function setminimumPriceIncreasePercent(uint256 _percentIncrease)\n        public\n        override\n        onlyOwner\n    {\n        minimumPriceIncreasePercent = _percentIncrease;\n    }\n\n    /// @notice A limit to the number of NFTs to mint per market\n    /// @dev to avoid gas limits\n    /// @param _mintLimit the limit to set\n    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {\n        nftMintingLimit = _mintLimit;\n    }\n\n    /// @notice A limit to the number of rent collections per transaction\n    /// @dev to avoid gas limits\n    /// @param _rentLimit the limit to set\n    function setMaxRentIterations(uint256 _rentLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxRentIterations = _rentLimit;\n    }\n\n    /// @notice set the address of the reality.eth contracts\n    /// @param _newAddress the address to set\n    function setRealitioAddress(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @notice address of the arbitrator, in case of continued disputes on reality.eth\n    /// @param _newAddress the address to set\n    function setArbitrator(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        arbitrator = _newAddress;\n    }\n\n    /// @notice set how long reality.eth waits for disputes before finalising\n    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs\n    function setTimeout(uint32 _newTimeout) public onlyOwner {\n        timeout = _newTimeout;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice whether or not only governors can create the market\n    function changeMarketCreationGovernorsOnly() external onlyOwner {\n        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;\n    }\n\n    /// @notice whether or not anyone can be an artist\n    function changeApprovedArtistsOnly() external onlyOwner {\n        approvedArtistsOnly = !approvedArtistsOnly;\n    }\n\n    /// @notice whether or not anyone can be an affiliate\n    function changeApprovedAffilliatesOnly() external onlyOwner {\n        approvedAffilliatesOnly = !approvedAffilliatesOnly;\n    }\n\n    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot\n    /// @param _amount the sponsorship required in wei\n    function setSponsorshipRequired(uint256 _amount) external onlyOwner {\n        sponsorshipRequired = _amount;\n    }\n\n    /// @notice if true, Cards in unapproved markets can't be upgraded\n    function changeTrapCardsIfUnapproved() external onlyOwner {\n        trapIfUnapproved = !trapIfUnapproved;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    /// @param _newAdvancedWarning the warning time to set in seconds\n    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {\n        advancedWarning = _newAdvancedWarning;\n        emit LogAdvancedWarning(_newAdvancedWarning);\n    }\n\n    /// @notice market closing time must be no more than this many seconds in the future\n    /// @param _newMaximumDuration the duration limit to set in seconds\n    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {\n        maximumDuration = _newMaximumDuration;\n        emit LogMaximumDuration(_newMaximumDuration);\n    }\n\n    /// @notice to fetch the owner of the contract\n    /// @dev used to specifiy the Ownable contract instead of the interface\n    function owner()\n        public\n        view\n        override(IRCFactory, Ownable)\n        returns (address)\n    {\n        return Ownable.owner();\n    }\n\n    /// @notice check if an address is a governor\n    /// @param _user the address to query\n    /// @return boolean return if true or false\n    function isGovernor(address _user) external view override returns (bool) {\n        return governors[_user];\n    }\n\n    // EDIT GOVERNORS\n\n    /// @notice add or remove an address from market creator whitelist\n    /// @param _governor the address to change approval for\n    /// @dev recommended to check isGovernor() afterwards to confirm the desired outcome\n    function changeGovernorApproval(address _governor) external onlyOwner {\n        require(_governor != address(0));\n        governors[_governor] = !governors[_governor];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - GOVERNORS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    /// @param _market the market address to change approval for\n    function changeMarketApproval(address _market) external onlyGovernors {\n        require(_market != address(0));\n        // check it's an RC contract\n        IRCMarket _marketToApprove = IRCMarket(_market);\n        assert(_marketToApprove.isMarket());\n        isMarketApproved[_market] = !isMarketApproved[_market];\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /// @notice artistAddress, passed in createMarket, must be approved\n    /// @param _artist the artist address to change approval for\n    function changeArtistApproval(address _artist) external onlyGovernors {\n        require(_artist != address(0));\n        isArtistApproved[_artist] = !isArtistApproved[_artist];\n    }\n\n    /// @notice affiliateAddress, passed in createMarket, must be approved\n    /// @param _affiliate the affiliate address to change approval for\n    function changeAffiliateApproval(address _affiliate)\n        external\n        onlyGovernors\n    {\n        require(_affiliate != address(0));\n        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];\n    }\n\n    /// @notice cardAffiliateAddress, passed in createMarket, must be approved\n    /// @param _affiliate the card affiliate address to change approval for\n    function changeCardAffiliateApproval(address _affiliate)\n        external\n        onlyGovernors\n    {\n        require(_affiliate != address(0));\n        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[\n            _affiliate\n        ];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    /// @notice change the reference contract for the contract logic\n    function setReferenceContractAddress(address _newAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newAddress != address(0));\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        assert(newContractVariable.isMarket());\n        // set\n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion += 1;\n    }\n\n    /// @notice to change or renounce ownership of the uberOwner role\n    function changeUberOwner(address _newUberOwner) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0));\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         MARKET CREATION         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Creates a new market with the given parameters\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    /// @param _sponsorship amount of sponsorship to create the market with\n    /// @return The address of the new market\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address) {\n        address _creator = msgSender();\n\n        // check sponsorship\n        require(\n            _sponsorship >= sponsorshipRequired,\n            \"Insufficient sponsorship\"\n        );\n        treasury.checkSponsorship(_creator, _sponsorship);\n\n        // check stakeholder addresses\n        // artist\n        if (approvedArtistsOnly) {\n            require(\n                isArtistApproved[_artistAddress] ||\n                    _artistAddress == address(0),\n                \"Artist not approved\"\n            );\n        }\n        // affiliate\n        if (approvedAffilliatesOnly) {\n            require(\n                isAffiliateApproved[_affiliateAddress] ||\n                    _affiliateAddress == address(0),\n                \"Affiliate not approved\"\n            );\n            // card affiliates\n            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {\n                require(\n                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||\n                        _cardAffiliateAddresses[i] == address(0),\n                    \"Card affiliate not approved\"\n                );\n            }\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(governors[_creator] || owner() == _creator, \"Not approved\");\n        }\n\n        // check timestamps\n        require(_timestamps.length == 3, \"Incorrect number of array elements\");\n        // check market opening time\n        if (advancedWarning != 0) {\n            require(\n                _timestamps[0] >= block.timestamp,\n                \"Market opening time not set\"\n            );\n            require(\n                _timestamps[0] - advancedWarning > block.timestamp,\n                \"Market opens too soon\"\n            );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(\n                _timestamps[1] < block.timestamp + maximumDuration,\n                \"Market locks too late\"\n            );\n        }\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(\n            _timestamps[1] + (1 weeks) > _timestamps[2] &&\n                _timestamps[1] <= _timestamps[2],\n            \"Oracle resolution time error\"\n        );\n\n        // check the number of NFTs to mint is within limits\n        require(\n            _tokenURIs.length <= nftMintingLimit,\n            \"Too many tokens to mint\"\n        );\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = Clones.clone(referenceContractAddress);\n        emit LogMarketCreated1(\n            _newAddress,\n            address(treasury),\n            address(nfthub),\n            referenceContractVersion\n        );\n        emit LogMarketCreated2(\n            _newAddress,\n            _mode,\n            _tokenURIs,\n            _ipfsHash,\n            _timestamps,\n            totalNftMintCount\n        );\n\n        // tell Treasury, Orderbook, and NFT hub about new market\n        // before initialize as during initialize the market may call the treasury\n        treasury.addMarket(_newAddress);\n        nfthub.addMarket(_newAddress);\n        orderbook.addMarket(\n            _newAddress,\n            _tokenURIs.length,\n            minimumPriceIncreasePercent\n        );\n\n        // update internals\n        marketAddresses[_mode].push(_newAddress);\n        mappingOfMarkets[_newAddress] = true;\n\n        // initialize the market\n        IRCMarket(_newAddress).initialize({\n            _mode: _mode,\n            _timestamps: _timestamps,\n            _numberOfTokens: _tokenURIs.length,\n            _totalNftMintCount: totalNftMintCount,\n            _artistAddress: _artistAddress,\n            _affiliateAddress: _affiliateAddress,\n            _cardAffiliateAddresses: _cardAffiliateAddresses,\n            _marketCreatorAddress: _creator,\n            _realitioQuestion: _realitioQuestion\n        });\n\n        // create the NFTs\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            uint256 _tokenId = i + totalNftMintCount;\n            require(\n                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),\n                \"Nft Minting Failed\"\n            );\n        }\n\n        // increment totalNftMintCount\n        totalNftMintCount = totalNftMintCount + _tokenURIs.length;\n\n        // pay sponsorship, if applicable\n        if (_sponsorship > 0) {\n            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);\n        }\n\n        return _newAddress;\n    }\n\n    /// @dev called by the market upon initialise\n    /// @dev not passed to initialise to avoid stack too deep error\n    function getOracleSettings()\n        external\n        view\n        override\n        returns (\n            IRealitio,\n            address,\n            uint32\n        )\n    {\n        return (realitio, arbitrator, timeout);\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"hardhat/console.sol\";\nimport \"../interfaces/IRCMarket.sol\";\nimport \"../lib/NativeMetaTransaction.sol\";\nimport \"../interfaces/IRCNftHubL2.sol\";\n\n/// @title Reality Cards NFT Hub- Layer 2 side\n/// @author Andrew Stanger & Daniel Chilvers\ncontract RCNftHubL2 is\n    Ownable,\n    ERC721URIStorage,\n    AccessControl,\n    NativeMetaTransaction,\n    IRCNftHubL2\n{\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can move NFTs\n    mapping(address => bool) public isMarket;\n    /// @dev the market each NFT belongs to, so that it can only be moved in withdraw state\n    mapping(uint256 => address) public override marketTracker;\n\n    /// @dev governance variables\n    address public factoryAddress;\n\n    /// @dev matic mintable asset requirements\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n    mapping(uint256 => bool) public withdrawnTokens;\n    event WithdrawnBatch(address indexed user, uint256[] tokenIds);\n    event TransferWithMetadata(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId,\n        bytes metaData\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _factoryAddress, address childChainManager)\n        ERC721(\"RealityCards\", \"RC\")\n    {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsNftHubL2\", \"1\");\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(DEPOSITOR_ROLE, childChainManager);\n        setFactoryAddress(_factoryAddress);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          ADD MARKETS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can change ownership\n    function addMarket(address _newMarket) external override {\n        require(msgSender() == factoryAddress, \"Not factory\");\n        isMarket[_newMarket] = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          GOVERNANCE             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev address of RC factory contract, so only factory can mint\n    function setFactoryAddress(address _newAddress) public onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        factoryAddress = _newAddress;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        CORE FUNCTIONS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // FACTORY ONLY\n    function mint(\n        address _originalOwner,\n        uint256 _tokenId,\n        string calldata _tokenURI\n    ) external override returns (bool) {\n        require(\n            !withdrawnTokens[_tokenId],\n            \"ChildMintableERC721: TOKEN_EXISTS_ON_ROOT_CHAIN\"\n        );\n        require(msgSender() == factoryAddress, \"Not factory\");\n        _mint(_originalOwner, _tokenId);\n        _setTokenURI(_tokenId, _tokenURI);\n        marketTracker[_tokenId] = _originalOwner;\n        return true;\n    }\n\n    // MARKET ONLY\n    function transferNft(\n        address _currentOwner,\n        address _newOwner,\n        uint256 _tokenId\n    ) external override returns (bool) {\n        require(isMarket[msgSender()], \"Not market\");\n        _transfer(_currentOwner, _newOwner, _tokenId);\n        return true;\n    }\n\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override(ERC721, IRCNftHubL2)\n        returns (address)\n    {\n        return ERC721.ownerOf(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override(ERC721URIStorage, IRCNftHubL2)\n        returns (string memory)\n    {\n        return ERC721URIStorage.tokenURI(tokenId);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MATIC MINTABLE           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function deposit(address user, bytes calldata depositData)\n        external\n        override\n        onlyRole(DEPOSITOR_ROLE)\n    {\n        // deposit single\n        if (depositData.length == 32) {\n            uint256 tokenId = abi.decode(depositData, (uint256));\n            withdrawnTokens[tokenId] = false;\n            _mint(user, tokenId);\n\n            // deposit batch\n        } else {\n            uint256[] memory tokenIds = abi.decode(depositData, (uint256[]));\n            uint256 length = tokenIds.length;\n            for (uint256 i; i < length; i++) {\n                withdrawnTokens[tokenIds[i]] = false;\n                _mint(user, tokenIds[i]);\n            }\n        }\n    }\n\n    function withdraw(uint256 tokenId) external override {\n        require(isMarket[msgSender()], \"Not market\");\n        require(\n            _msgSender() == ownerOf(tokenId),\n            \"ChildMintableERC721: INVALID_TOKEN_OWNER\"\n        );\n        withdrawnTokens[tokenId] = true;\n        _burn(tokenId);\n    }\n\n    function withdrawWithMetadata(uint256 tokenId) external override {\n        require(isMarket[msgSender()], \"Not market\");\n        require(\n            msgSender() == ownerOf(tokenId),\n            \"ChildMintableERC721: INVALID_TOKEN_OWNER\"\n        );\n        withdrawnTokens[tokenId] = true;\n\n        // Encoding metadata associated with tokenId & emitting event\n        emit TransferWithMetadata(\n            ownerOf(tokenId),\n            address(0),\n            tokenId,\n            this.encodeTokenMetadata(tokenId)\n        );\n\n        _burn(tokenId);\n    }\n\n    function encodeTokenMetadata(uint256 tokenId)\n        external\n        view\n        virtual\n        returns (bytes memory)\n    {\n        return abi.encode(tokenURI(tokenId));\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl, ERC721)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IRCNftHubL2).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           OVERRIDES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev ensures NFTs can only be moved when market is resolved\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        IRCMarket market = IRCMarket(marketTracker[tokenId]);\n        require(market.state() == IRCMarket.States.WITHDRAW, \"Incorrect state\");\n        require(ownerOf(tokenId) == msgSender(), \"Not owner\");\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public override {\n        IRCMarket market = IRCMarket(marketTracker[tokenId]);\n        require(market.state() == IRCMarket.States.WITHDRAW, \"Incorrect state\");\n        require(ownerOf(tokenId) == msgSender(), \"Not owner\");\n        _transfer(from, to, tokenId);\n        _data;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public orderbook;\n    /// @dev nfthub instance, to query current card owner\n    IRCNftHubL2 public nfthub;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev address of the Factory so only the Factory can add new markets\n    address public override factoryAddress;\n    /// @dev so only markets can use certain functions\n    mapping(address => bool) public override isMarket;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public marketBalance;\n    /// @dev a quick check if a uesr is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 marketBalanceDiscrepancy;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent any cards for specific market\n    mapping(address => bool) public override marketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            UBER OWNER           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev high level owner who can change the factory address\n    address public override uberOwner;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1000000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /// @notice only allow markets to call these functions\n    modifier onlyMarkets {\n        require(isMarket[msgSender()], \"Not authorised\");\n        _;\n    }\n\n    /// @notice only allow orderbook to call these functions\n    modifier onlyOrderbook {\n        require(msgSender() == address(orderbook), \"Not authorised\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           ADD MARKETS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can move funds from deposits to marketPots and vice versa\n    function addMarket(address _newMarket) external override {\n        require(msgSender() == factoryAddress, \"Not factory\");\n        isMarket[_newMarket] = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyOwner\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyOwner {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental for a specific market\n    function changePauseMarket(address _market) external override onlyOwner {\n        require(isMarket[_market], \"This isn't a market\");\n        marketPaused[_market] = !marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyOwner {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add a user to the whitelist\n    function addToWhitelist(address _user) public override {\n        IRCFactory factory = IRCFactory(factoryAddress);\n        require(factory.isGovernor(msgSender()), \"Not authorised\");\n        isAllowed[_user] = !isAllowed[_user];\n    }\n\n    /// @notice Add multiple users to the whitelist\n    function batchAddToWhitelist(address[] calldata _users) public override {\n        for (uint256 index = 0; index < _users.length; index++) {\n            addToWhitelist(_users[index]);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    function setFactoryAddress(address _newFactory) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newFactory != address(0), \"Must set an address\");\n        factoryAddress = _newFactory;\n    }\n\n    function setOrderbookAddress(address _newOrderbook) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newOrderbook != address(0), \"Must set an address\");\n        orderbook = IRCOrderbook(_newOrderbook);\n    }\n\n    function setNftHubAddress(address _NFTHubAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_NFTHubAddress != address(0), \"Must set an address\");\n        nfthub = IRCNftHubL2(_NFTHubAddress);\n    }\n\n    function setTokenAddress(address _newToken) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    function changeUberOwner(address _newUberOwner) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0), \"Must set an address\");\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract (newRental) or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        public\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(isAllowed[msgSender()], \"Not in whitelist\");\n        }\n        erc20.transferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        if (\n            (user[_user].deposit + _amount) >\n            (user[_user].bidRate / minRentalDayDivisor)\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // stpe 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.transfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            isForeclosed[_msgSender] = true;\n            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(\n                _msgSender\n            );\n            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount) external override {\n        erc20.transferFrom(msgSender(), address(this), _amount);\n        if (_amount > marketBalanceDiscrepancy) {\n            marketBalanceDiscrepancy = 0;\n        } else {\n            marketBalanceDiscrepancy -= _amount;\n        }\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            marketBalanceDiscrepancy += _amount - marketBalance;\n            _amount -= (_amount - marketBalance);\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n\n        return true;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        assert(marketPot[msgSender()] >= _amount);\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        onlyMarkets\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        if (\n            isForeclosed[_user] &&\n            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.transferFrom(_sponsor, address(this), _amount);\n        marketPot[msgSender()] += _amount;\n        totalMarketPots += _amount;\n        return true;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyMarkets\n        returns (bool)\n    {\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        if (user[_user].lastRentCalc == 0) {\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n        return true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice provides the sum total of a users bids accross all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyOrderbook {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !isMarket[_newOwner]\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed =\n                    rentOwedBetweenTimestmaps(\n                        block.timestamp,\n                        _timeOwnershipChanged,\n                        _newPrice\n                    );\n                collectRentUser(_newOwner, block.timestamp);\n\n                // they have enough funds, just collect the extra\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /// @dev called when all a user's bids have been removed, disables foreclosure state\n    function resetUser(address _user) external override onlyOrderbook {\n        isForeclosed[_user] = false;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calcualtion and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calcualtes the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestmaps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the amount of deposit a user is able to withdraw\n    /// @notice ..after considering rent due to be paid\n    /// @param _user the user to query\n    function depositAbleToWithdraw(address _user)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 collection = rentOwedUser(_user, block.timestamp);\n        if (collection >= user[_user].deposit) {\n            return 0;\n        } else {\n            return uint256(user[_user].deposit) - (collection);\n        }\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)\n            //                   = (deposit * 1day) / totalUserDailyRent\n            uint256 timeLeftOfDeposit =\n                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard =\n                user[_user].lastRentCalc + timeLeftOfDeposit;\n\n            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {\n                // calculate how long they can own the new card for\n                uint256 _rentAlreadyOwed =\n                    rentOwedBetweenTimestmaps(\n                        user[_user].lastRentCalc,\n                        _timeOfNewBid,\n                        totalUserDailyRent\n                    );\n                uint256 _depositAtTimeOfNewBid =\n                    user[_user].deposit - _rentAlreadyOwed;\n                uint256 _timeLeftOfDepositWithNewBid =\n                    (_depositAtTimeOfNewBid * 1 days) /\n                        (totalUserDailyRent + _newBid);\n                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            // if no rentals they'll foreclose after the heat death of the universe\n            return type(uint256).max;\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        assert(_timeToCollectTo != 0);\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts =\n                    ((_timeToCollectTo - previousCollectionTime) *\n                        uint256(user[_user].deposit)) / rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepsitLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets availiable balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"hardhat/console.sol\";\n\n// this is only for ganache testing. Public chain deployments will use the existing Realitio contracts.\n\ncontract BridgeMockup {\n    address public oracleProxyMainnetAddress;\n    address public oracleProxyXdaiAddress;\n\n    function requireToPassMessage(\n        address _RCProxyAddress,\n        bytes calldata _data,\n        uint256 _gasLimit\n    ) external {\n        _gasLimit;\n        (bool _success, ) = _RCProxyAddress.call{value: (0)}(_data);\n        // this is for a sepcific test where the oracleProxyMainnetAddress is\n        // scrambled intentionally\n        if (\n            0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 !=\n            oracleProxyMainnetAddress\n        ) {\n            require(_success, \"Bridge failed\");\n        }\n    }\n\n    function messageSender() external view returns (address) {\n        // console.log(\"oracleProxyXdaiAddress is\", oracleProxyXdaiAddress);\n        if (msg.sender == oracleProxyMainnetAddress) {\n            return oracleProxyXdaiAddress;\n        } else {\n            return oracleProxyMainnetAddress;\n        }\n    }\n\n    function setProxyL1Address(address _newAddress) external {\n        oracleProxyMainnetAddress = _newAddress;\n    }\n\n    function setProxyL2Address(address _newAddress) external {\n        oracleProxyXdaiAddress = _newAddress;\n    }\n}\n\n\n",
        "CodeNames": [
            "RCFactory.sol",
            "RCNftHubL2.sol",
            "RCTreasury.sol",
            "BridgeMockup.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [
                    "RCNftHubL",
                    "safeTransferFrom",
                    "IERC",
                    "_data"
                ],
                "Type": "  RCNftHubL2.safeTransferFrom  not according to spec",
                "Description": "\nThe RCNftHubL2.safeTransferFrom function does not correctly implement the ERC721 spec:\n When using safeTransferFrom, the token contract checks to see that the receiver is an IERC721Receiver, which implies that it knows how to handle ERC721 tokens. ERC721(https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721-safeTransferFrom)\n\nThis check is not implemented, it just drops the _data argument.\n\nContracts that don't know how to handle ERC721 tokens (are not an IERC721Receiver) can accept them but they should not when using safeTransferFrom according to spec.\n\n",
                "Repair": "Recommend Implementing the IERC721Receiver check in safeTransferFrom.\n\nSplidge (Reality Cards) confirmed and resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/160#issuecomment-865141409):\n  This has been fixed while working on issue #118\n commit here(https://github.com/RealityCards/RealityCards-Contracts/commit/a628ac8e0132f7ca4159980f791ae820100c0888)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\ncontract Migrations {\n    address public owner;\n    uint256 public last_completed_migration;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint256 completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public orderbook;\n    /// @dev nfthub instance, to query current card owner\n    IRCNftHubL2 public nfthub;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev address of the Factory so only the Factory can add new markets\n    address public override factoryAddress;\n    /// @dev so only markets can use certain functions\n    mapping(address => bool) public override isMarket;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public marketBalance;\n    /// @dev a quick check if a uesr is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 marketBalanceDiscrepancy;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent any cards for specific market\n    mapping(address => bool) public override marketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            UBER OWNER           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev high level owner who can change the factory address\n    address public override uberOwner;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1000000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /// @notice only allow markets to call these functions\n    modifier onlyMarkets {\n        require(isMarket[msgSender()], \"Not authorised\");\n        _;\n    }\n\n    /// @notice only allow orderbook to call these functions\n    modifier onlyOrderbook {\n        require(msgSender() == address(orderbook), \"Not authorised\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           ADD MARKETS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can move funds from deposits to marketPots and vice versa\n    function addMarket(address _newMarket) external override {\n        require(msgSender() == factoryAddress, \"Not factory\");\n        isMarket[_newMarket] = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyOwner\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyOwner {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental for a specific market\n    function changePauseMarket(address _market) external override onlyOwner {\n        require(isMarket[_market], \"This isn't a market\");\n        marketPaused[_market] = !marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyOwner {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add a user to the whitelist\n    function addToWhitelist(address _user) public override {\n        IRCFactory factory = IRCFactory(factoryAddress);\n        require(factory.isGovernor(msgSender()), \"Not authorised\");\n        isAllowed[_user] = !isAllowed[_user];\n    }\n\n    /// @notice Add multiple users to the whitelist\n    function batchAddToWhitelist(address[] calldata _users) public override {\n        for (uint256 index = 0; index < _users.length; index++) {\n            addToWhitelist(_users[index]);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    function setFactoryAddress(address _newFactory) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newFactory != address(0), \"Must set an address\");\n        factoryAddress = _newFactory;\n    }\n\n    function setOrderbookAddress(address _newOrderbook) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newOrderbook != address(0), \"Must set an address\");\n        orderbook = IRCOrderbook(_newOrderbook);\n    }\n\n    function setNftHubAddress(address _NFTHubAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_NFTHubAddress != address(0), \"Must set an address\");\n        nfthub = IRCNftHubL2(_NFTHubAddress);\n    }\n\n    function setTokenAddress(address _newToken) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    function changeUberOwner(address _newUberOwner) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0), \"Must set an address\");\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract (newRental) or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        public\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(isAllowed[msgSender()], \"Not in whitelist\");\n        }\n        erc20.transferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        if (\n            (user[_user].deposit + _amount) >\n            (user[_user].bidRate / minRentalDayDivisor)\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // stpe 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.transfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            isForeclosed[_msgSender] = true;\n            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(\n                _msgSender\n            );\n            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount) external override {\n        erc20.transferFrom(msgSender(), address(this), _amount);\n        if (_amount > marketBalanceDiscrepancy) {\n            marketBalanceDiscrepancy = 0;\n        } else {\n            marketBalanceDiscrepancy -= _amount;\n        }\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            marketBalanceDiscrepancy += _amount - marketBalance;\n            _amount -= (_amount - marketBalance);\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n\n        return true;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        assert(marketPot[msgSender()] >= _amount);\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        onlyMarkets\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        if (\n            isForeclosed[_user] &&\n            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.transferFrom(_sponsor, address(this), _amount);\n        marketPot[msgSender()] += _amount;\n        totalMarketPots += _amount;\n        return true;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyMarkets\n        returns (bool)\n    {\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        if (user[_user].lastRentCalc == 0) {\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n        return true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice provides the sum total of a users bids accross all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyOrderbook {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !isMarket[_newOwner]\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed =\n                    rentOwedBetweenTimestmaps(\n                        block.timestamp,\n                        _timeOwnershipChanged,\n                        _newPrice\n                    );\n                collectRentUser(_newOwner, block.timestamp);\n\n                // they have enough funds, just collect the extra\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /// @dev called when all a user's bids have been removed, disables foreclosure state\n    function resetUser(address _user) external override onlyOrderbook {\n        isForeclosed[_user] = false;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calcualtion and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calcualtes the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestmaps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the amount of deposit a user is able to withdraw\n    /// @notice ..after considering rent due to be paid\n    /// @param _user the user to query\n    function depositAbleToWithdraw(address _user)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 collection = rentOwedUser(_user, block.timestamp);\n        if (collection >= user[_user].deposit) {\n            return 0;\n        } else {\n            return uint256(user[_user].deposit) - (collection);\n        }\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)\n            //                   = (deposit * 1day) / totalUserDailyRent\n            uint256 timeLeftOfDeposit =\n                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard =\n                user[_user].lastRentCalc + timeLeftOfDeposit;\n\n            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {\n                // calculate how long they can own the new card for\n                uint256 _rentAlreadyOwed =\n                    rentOwedBetweenTimestmaps(\n                        user[_user].lastRentCalc,\n                        _timeOfNewBid,\n                        totalUserDailyRent\n                    );\n                uint256 _depositAtTimeOfNewBid =\n                    user[_user].deposit - _rentAlreadyOwed;\n                uint256 _timeLeftOfDepositWithNewBid =\n                    (_depositAtTimeOfNewBid * 1 days) /\n                        (totalUserDailyRent + _newBid);\n                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            // if no rentals they'll foreclose after the heat death of the universe\n            return type(uint256).max;\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        assert(_timeToCollectTo != 0);\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts =\n                    ((_timeToCollectTo - previousCollectionTime) *\n                        uint256(user[_user].deposit)) / rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepsitLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets availiable balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRealitio.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // CONTRACT SETUP\n    /// @dev = how many outcomes/teams/NFTs etc\n    uint256 public numberOfCards;\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n    uint256 public constant MIN_RENTAL_VALUE = 1 ether;\n    States public override state;\n    /// @dev type of event.\n    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}\n    Mode public mode;\n    /// @dev so the Factory can check it's a market\n    bool public constant override isMarket = true;\n    /// @dev counts the total NFTs minted across all events at the time market created\n    /// @dev nft tokenId = card Id + totalNftMintCount\n    uint256 public totalNftMintCount;\n\n    // CONTRACT VARIABLES\n    IRCTreasury public treasury;\n    IRCFactory public factory;\n    IRCNftHubL2 public nfthub;\n    IRCOrderbook public orderbook;\n\n    // PRICE, DEPOSITS, RENT\n    /// @dev in wei\n    mapping(uint256 => uint256) public cardPrice;\n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping(address => uint256) public rentCollectedPerUser;\n    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout\n    mapping(uint256 => uint256) public rentCollectedPerCard;\n    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout\n    mapping(address => mapping(uint256 => uint256))\n        public rentCollectedPerUserPerCard;\n    /// @dev an easy way to track the above across all cards\n    uint256 public totalRentCollected;\n    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)\n    mapping(address => uint256) public exitedTimestamp;\n\n    // PARAMETERS\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public minimumPriceIncreasePercent;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public minRentalDayDivisor;\n    /// @dev maximum number of times to calcualte rent in one transaction\n    uint256 public maxRentIterations;\n\n    // TIME\n    /// @dev how many seconds each user has held each card for, for determining winnings\n    mapping(uint256 => mapping(address => uint256)) public timeHeld;\n    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n    mapping(uint256 => uint256) public totalTimeHeld;\n    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n    mapping(uint256 => uint256) public timeLastCollected;\n    /// @dev to track the max timeheld of each card (for giving NFT to winner)\n    mapping(uint256 => uint256) public longestTimeHeld;\n    /// @dev to track who has owned it the most (for giving NFT to winner)\n    mapping(uint256 => address) public longestOwner;\n    /// @dev to track the card timeHeldLimit for the current owner\n    mapping(uint256 => uint256) public cardTimeLimit;\n\n    // TIMESTAMPS\n    /// @dev when the market opens\n    uint32 public marketOpeningTime;\n    /// @dev when the market locks\n    uint32 public override marketLockingTime;\n    /// @dev when the question can be answered on realitio\n    /// @dev only needed for circuit breaker\n    uint32 public oracleResolutionTime;\n\n    // PAYOUT VARIABLES\n    uint256 public winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping(address => bool) public userAlreadyWithdrawn;\n    /// @dev prevent users claiming twice\n    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool\n    /// @dev the artist\n    address public artistAddress;\n    uint256 public artistCut;\n    bool public artistPaid;\n    /// @dev the affiliate\n    address public affiliateAddress;\n    uint256 public affiliateCut;\n    bool public affiliatePaid;\n    /// @dev the winner\n    uint256 public winnerCut;\n    /// @dev the market creator\n    address public marketCreatorAddress;\n    uint256 public creatorCut;\n    bool public creatorPaid;\n    /// @dev card specific recipients\n    address[] public cardAffiliateAddresses;\n    uint256 public cardAffiliateCut;\n    mapping(uint256 => bool) public cardAffiliatePaid;\n\n    // ORACLE VARIABLES\n    bytes32 public questionId;\n    bool public questionFinalised;\n    address public arbitrator;\n    uint32 public timeout;\n    IRealitio public realitio;\n    address public _realitioAddress;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);\n    event LogRentCollection(\n        uint256 rentCollected,\n        uint256 indexed newTimeHeld,\n        uint256 indexed cardId,\n        address indexed owner\n    );\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(\n        address indexed paidTo,\n        uint256 indexed amountPaid\n    );\n    event LogRentReturned(\n        address indexed returnedTo,\n        uint256 indexed amountReturned\n    );\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(\n        address indexed owner,\n        uint256 newLimit,\n        uint256 cardId\n    );\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogNftUpgraded(\n        uint256 indexed currentTokenId,\n        uint256 indexed newTokenId\n    );\n    event LogPayoutDetails(\n        address indexed artistAddress,\n        address marketCreatorAddress,\n        address affiliateAddress,\n        address[] cardAffiliateAddresses,\n        uint256 indexed artistCut,\n        uint256 winnerCut,\n        uint256 creatorCut,\n        uint256 affiliateCut,\n        uint256 cardAffiliateCut\n    );\n    event LogSettings(\n        uint256 indexed minRentalDayDivisor,\n        uint256 indexed minimumPriceIncreasePercent\n    );\n    event LogLongestOwner(uint256 cardId, address longestOwner);\n    event LogQuestionPostedToOracle(\n        address indexed marketAddress,\n        bytes32 indexed questionId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfCards how many Cards in this market\n    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _marketCreatorAddress where to send market creator's cut, if any\n    /// @param _realitioQuestion the question posted to the Oracle\n    function initialize(\n        uint256 _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfCards,\n        uint256 _totalNftMintCount,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion\n    ) external override initializer {\n        assert(_mode <= 2);\n\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsMarket\", \"1\");\n\n        // external contract variables:\n        factory = IRCFactory(msgSender());\n        treasury = factory.treasury();\n        nfthub = factory.nfthub();\n        orderbook = factory.orderbook();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();\n        maxRentIterations = factory.maxRentIterations();\n\n        // initialiiize!\n        winningOutcome = MAX_UINT256; // default invalid\n\n        // assign arguments to public variables\n        mode = Mode(_mode);\n        numberOfCards = _numberOfCards;\n        totalNftMintCount = _totalNftMintCount;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n        (realitio, arbitrator, timeout) = factory.getOracleSettings();\n\n        // reduce artist cut to zero if zero adddress set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero adddress set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array.\n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfCards) {\n            for (uint256 i = 0; i < _numberOfCards; i++) {\n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {\n            winnerCut =\n                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -\n                cardAffiliateCut;\n        }\n\n        // post question to Oracle\n        questionFinalised = false;\n        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);\n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime <= block.timestamp) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(\n            _artistAddress,\n            _marketCreatorAddress,\n            _affiliateAddress,\n            cardAffiliateAddresses,\n            artistCut,\n            winnerCut,\n            creatorCut,\n            affiliateCut,\n            cardAffiliateCut\n        );\n        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            MODIFIERS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {\n            _incrementState();\n        }\n        _;\n    }\n\n    /// @notice automatically locks market if appropriate\n    modifier autoLock() {\n        _;\n        if (marketLockingTime <= block.timestamp) {\n            lockMarket();\n        }\n    }\n\n    /// @dev can only be called by Card owners\n    modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     NFT HUB CONTRACT CALLS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice send NFT to mainnet\n    /// @dev upgrades not possible if market not approved\n    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {\n        _checkState(States.WITHDRAW);\n        require(\n            !factory.trapIfUnapproved() ||\n                factory.isMarketApproved(address(this)),\n            \"Upgrade blocked\"\n        );\n        uint256 _tokenId = _card + totalNftMintCount;\n        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n        nfthub.withdrawWithMetadata(_tokenId);\n        emit LogNftUpgraded(_card, _tokenId);\n    }\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.ownerOf(_tokenId);\n    }\n\n    /// @notice gets tokenURI via their Card Id\n    function tokenURI(uint256 _cardId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.tokenURI(_tokenId);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called internally during contract open state\n    function _transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId\n    ) internal {\n        require(\n            _from != address(0) && _to != address(0),\n            \"Cannot send to/from zero address\"\n        );\n        uint256 _tokenId = _cardId + totalNftMintCount;\n\n        assert(nfthub.transferNft(_from, _to, _tokenId));\n        emit LogNewOwner(_cardId, _to);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called externaly by Orderbook during contract open state\n    function transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external override {\n        require(msgSender() == address(orderbook), \"Not orderbook\");\n        _checkState(States.OPEN);\n        if (_to != _from) {\n            _transferCard(_from, _to, _cardId);\n        }\n        cardTimeLimit[_cardId] = _timeLimit;\n        cardPrice[_cardId] = _price;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        ORACLE FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev called within initializer only\n    function _postQuestionToOracle(\n        string calldata _question,\n        uint32 _oracleResolutionTime\n    ) internal {\n        questionId = realitio.askQuestion(\n            2,\n            _question,\n            arbitrator,\n            timeout,\n            _oracleResolutionTime,\n            0\n        );\n        emit LogQuestionPostedToOracle(address(this), questionId);\n    }\n\n    /// @notice has the oracle finalised\n    function isFinalized() public view returns (bool) {\n        bool _isFinalized = realitio.isFinalized(questionId);\n        return _isFinalized;\n    }\n\n    /// @dev sets the winning outcome\n    /// @dev market.setWinner() will revert if done twice, because wrong state\n    function getWinnerFromOracle() external {\n        require(isFinalized(), \"Oracle not finalised\");\n        // check market state to prevent market closing early\n        require(marketLockingTime <= block.timestamp, \"Market not finished\");\n        questionFinalised = true;\n        bytes32 _winningOutcome = realitio.resultFor(questionId);\n        // call the market\n        setWinner(uint256(_winningOutcome));\n    }\n\n    /// @dev admin override of the oracle\n    function setAmicableResolution(uint256 _winningOutcome) external {\n        require(msgSender() == factory.owner(), \"Not authorised\");\n        questionFinalised = true;\n        setWinner(_winningOutcome);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551  MARKET RESOLUTION FUNCTIONS    \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice checks whether the competition has ended, if so moves to LOCKED state\n    /// @dev can be called by anyone\n    /// @dev public because called within autoLock modifier & setWinner\n    function lockMarket() public {\n        _checkState(States.OPEN);\n        require(\n            marketLockingTime <= block.timestamp,\n            \"Market has not finished\"\n        );\n        // do a final rent collection before the contract is locked down\n\n        if (collectRentAllCards()) {\n            orderbook.closeMarket();\n            _incrementState();\n\n            for (uint256 i; i < numberOfCards; i++) {\n                // bring the cards back to the market so the winners get the satisfcation of claiming them\n                _transferCard(ownerOf(i), address(this), i);\n                emit LogLongestOwner(i, longestOwner[i]);\n            }\n            emit LogContractLocked(true);\n        }\n    }\n\n    /// @notice called by getWinnerFromOracle, sets the winner\n    /// @param _winningOutcome the index of the winning card\n    function setWinner(uint256 _winningOutcome) internal {\n        if (state == States.OPEN) {\n            // change the locking time to allow lockMarket to lock\n            marketLockingTime = SafeCast.toUint32(block.timestamp);\n            lockMarket();\n        }\n        if (state == States.LOCKED) {\n            // get the winner. This will revert if answer is not resolved.\n            winningOutcome = _winningOutcome;\n            _incrementState();\n            emit LogWinnerKnown(winningOutcome);\n        }\n    }\n\n    /// @notice pays out winnings, or returns funds\n    function withdraw() external {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], \"Already withdrawn\");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (totalTimeHeld[winningOutcome] > 0) {\n            _payoutWinnings();\n        } else {\n            _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    /// @param _card the id of the card, the index\n    function claimCard(uint256 _card) external {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(!userAlreadyClaimed[_card][msgSender()], \"Already claimed\");\n        userAlreadyClaimed[_card][msgSender()] = true;\n        require(longestOwner[_card] == msgSender(), \"Not longest owner\");\n        _transferCard(ownerOf(_card), longestOwner[_card], _card);\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer = 0;\n        uint256 _remainingCut =\n            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -\n                winnerCut) - creatorCut;\n        // calculate longest owner's extra winnings, if relevant\n        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {\n            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);\n        }\n        uint256 _remainingPot = 0;\n        if (mode == Mode.SAFE_MODE) {\n            // return all rent paid on winning card\n            _remainingPot =\n                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *\n                    _remainingCut) /\n                (1000);\n            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][\n                winningOutcome\n            ];\n        } else {\n            // calculate normal winnings, if any\n            _remainingPot = (totalRentCollected * _remainingCut) / (1000);\n        }\n        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];\n        uint256 _numerator = _remainingPot * _winnersTimeHeld;\n        _winningsToTransfer =\n            _winningsToTransfer +\n            (_numerator / totalTimeHeld[winningOutcome]);\n        require(_winningsToTransfer > 0, \"Not a winner\");\n        _payout(msgSender(), _winningsToTransfer);\n        emit LogWinningsPaid(msgSender(), _winningsToTransfer);\n    }\n\n    /// @notice returns all funds to users in case of invalid outcome\n    function _returnRent() internal {\n        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)\n        uint256 _remainingCut =\n            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;\n        uint256 _rentCollected = rentCollectedPerUser[msgSender()];\n        require(_rentCollected > 0, \"Paid no rent\");\n        uint256 _rentCollectedAdjusted =\n            (_rentCollected * _remainingCut) / (1000);\n        _payout(msgSender(), _rentCollectedAdjusted);\n        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);\n    }\n\n    /// @notice all payouts happen through here\n    function _payout(address _recipient, uint256 _amount) internal {\n        assert(treasury.payout(_recipient, _amount));\n    }\n\n    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)\n    /// @dev they are not called within setWinner() because of the risk of an\n    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings\n    /// @dev [hangover from when ether was native currency, keeping in case we return to this]\n\n    /// @notice pay artist\n    function payArtist() external {\n        _checkState(States.WITHDRAW);\n        require(!artistPaid, \"Artist already paid\");\n        artistPaid = true;\n        _processStakeholderPayment(artistCut, artistAddress);\n    }\n\n    /// @notice pay market creator\n    function payMarketCreator() external {\n        _checkState(States.WITHDRAW);\n        require(totalTimeHeld[winningOutcome] > 0, \"No winner\");\n        require(!creatorPaid, \"Creator already paid\");\n        creatorPaid = true;\n        _processStakeholderPayment(creatorCut, marketCreatorAddress);\n    }\n\n    /// @notice pay affiliate\n    function payAffiliate() external {\n        _checkState(States.WITHDRAW);\n        require(!affiliatePaid, \"Affiliate already paid\");\n        affiliatePaid = true;\n        _processStakeholderPayment(affiliateCut, affiliateAddress);\n    }\n\n    /// @notice pay card affiliate\n    /// @dev does not call _processStakeholderPayment because it works differently\n    function payCardAffiliate(uint256 _card) external {\n        _checkState(States.WITHDRAW);\n        require(!cardAffiliatePaid[_card], \"Card affiliate already paid\");\n        cardAffiliatePaid[_card] = true;\n        uint256 _cardAffiliatePayment =\n            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);\n        if (_cardAffiliatePayment > 0) {\n            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);\n            emit LogStakeholderPaid(\n                cardAffiliateAddresses[_card],\n                _cardAffiliatePayment\n            );\n        }\n    }\n\n    function _processStakeholderPayment(uint256 _cut, address _recipient)\n        internal\n    {\n        if (_cut > 0) {\n            uint256 _payment = (totalRentCollected * _cut) / (1000);\n            _payout(_recipient, _payment);\n            emit LogStakeholderPaid(_recipient, _payment);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             EXTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev basically functions that have _checkState(States.OPEN) on first line\n\n    /// @notice collects rent for all cards\n    /// @dev cannot be external because it is called within the lockMarket function, therefore public\n    function collectRentAllCards() public override returns (bool) {\n        _checkState(States.OPEN);\n        bool _success = true;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != address(this)) {\n                _success = _collectRent(i);\n            }\n            if (!_success) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice rent every Card at the minimum price\n    /// @param _maxSumOfPrices a limit to the sum of the bids to place\n    function rentAllCards(uint256 _maxSumOfPrices) external {\n        // check that not being front run\n        uint256 _actualSumOfPrices;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);\n        }\n        require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");\n\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint256 _newPrice;\n                if (cardPrice[i] > 0) {\n                    _newPrice =\n                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /\n                        100;\n                } else {\n                    _newPrice = MIN_RENTAL_VALUE;\n                }\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n    /// @notice to rent a Card\n    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate\n    /// @param _newPrice the price to rent the card for\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _startingPosition where to start looking to insert the bid into the orderbook\n    /// @param _card the index of the card to update\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) public autoUnlock() autoLock() {\n        if (state == States.OPEN) {\n            require(_newPrice >= MIN_RENTAL_VALUE, \"Price below min\");\n            require(_card < numberOfCards, \"Card does not exist\");\n\n            address _user = msgSender();\n\n            require(\n                exitedTimestamp[_user] != block.timestamp,\n                \"Cannot lose and re-rent in same block\"\n            );\n            require(\n                !treasury.marketPaused(address(this)) &&\n                    !treasury.globalPause(),\n                \"Rentals are disabled\"\n            );\n            bool _userStillForeclosed = treasury.isForeclosed(_user);\n            if (_userStillForeclosed) {\n                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);\n            }\n            if (!_userStillForeclosed) {\n                if (ownerOf(_card) == _user) {\n                    // the owner may only increase by more than X% or reduce their price\n                    uint256 _requiredPrice =\n                        (cardPrice[_card] *\n                            (minimumPriceIncreasePercent + 100)) / (100);\n                    require(\n                        _newPrice >= _requiredPrice ||\n                            _newPrice < cardPrice[_card],\n                        \"Invalid price\"\n                    );\n                }\n\n                // do some cleaning up before we collect rent or check their bidRate\n                orderbook.removeOldBids(_user);\n\n                _collectRent(_card);\n\n                // check sufficient deposit\n                uint256 _userTotalBidRate =\n                    treasury.userTotalBids(_user) -\n                        (orderbook.getBidValue(_user, _card)) +\n                        _newPrice;\n                require(\n                    treasury.userDeposit(_user) >=\n                        _userTotalBidRate / minRentalDayDivisor,\n                    \"Insufficient deposit\"\n                );\n\n                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n                // replaces _newBid and _updateBid\n                orderbook.addBidToOrderbook(\n                    _user,\n                    _card,\n                    _newPrice,\n                    _timeHeldLimit,\n                    _startingPosition\n                );\n\n                assert(treasury.updateLastRentalTime(_user));\n            }\n        }\n    }\n\n    function _checkTimeHeldLimit(uint256 _timeHeldLimit)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_timeHeldLimit == 0) {\n            return 0;\n        } else {\n            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;\n            require(_timeHeldLimit >= _minRentalTime, \"Limit too low\");\n            return _timeHeldLimit;\n        }\n    }\n\n    /// @notice to change your timeHeldLimit without having to re-rent\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _card the index of the card to update\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external\n    {\n        _checkState(States.OPEN);\n        address _user = msgSender();\n\n        if (_collectRent(_card)) {\n            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);\n\n            if (ownerOf(_card) == _user) {\n                cardTimeLimit[_card] = _timeHeldLimit;\n            }\n\n            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);\n        }\n    }\n\n    /// @notice stop renting all cards\n    function exitAll() external override {\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            exit(i);\n        }\n    }\n\n    /// @notice stop renting a card and/or remove from orderbook\n    /// @dev public because called by exitAll()\n    /// @dev doesn't need to be current owner so user can prevent ownership returning to them\n    /// @dev does not apply minimum rental duration, because it returns ownership to the next user\n    /// @param _card The card index to exit\n    function exit(uint256 _card) public override {\n        _checkState(States.OPEN);\n        address _msgSender = msgSender();\n\n        // block frontrunning attack\n        exitedTimestamp[_msgSender] = block.timestamp;\n\n        // collectRent first\n        _collectRent(_card);\n\n        if (ownerOf(_card) == _msgSender) {\n            // if current owner, find a new one\n            orderbook.findNewOwner(_card, block.timestamp);\n            assert(!orderbook.bidExists(_msgSender, address(this), _card));\n        } else {\n            // if not owner, just delete from orderbook\n            if (orderbook.bidExists(_msgSender, address(this), _card)) {\n                orderbook.removeBidFromOrderbook(_msgSender, _card);\n            }\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by user, sponsor is msgSender\n    function sponsor(uint256 _amount) external override {\n        address _creator = msgSender();\n        treasury.checkSponsorship(_creator, _amount);\n        _sponsor(_creator, _amount);\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n    /// @dev actually processes the sponsorship\n    function _sponsor(address _sponsorAddress, uint256 _amount) internal {\n        _checkNotState(States.LOCKED);\n        _checkNotState(States.WITHDRAW);\n        require(_amount > 0, \"Must send something\");\n        // send tokens to the Treasury\n        require(treasury.sponsor(_sponsorAddress, _amount));\n        totalRentCollected = totalRentCollected + _amount;\n        // just so user can get it back if invalid outcome\n        rentCollectedPerUser[_sponsorAddress] =\n            rentCollectedPerUser[_sponsorAddress] +\n            _amount;\n        // allocate equally to each card, in case card specific affiliates\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            rentCollectedPerCard[i] =\n                rentCollectedPerCard[i] +\n                (_amount / numberOfCards);\n        }\n        emit LogSponsor(_sponsorAddress, _amount);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             INTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice collects rent for a specific card\n    /// @dev also calculates and updates how long the current user has held the card for\n    /// @dev is not a problem if called externally, but making internal over public to save gas\n    function _collectRentAction(uint256 _card)\n        internal\n        returns (bool shouldContinue)\n    {\n        address _user = ownerOf(_card);\n        uint256 _timeOfThisCollection = block.timestamp;\n\n        // don't collect rent beyond the locking time\n        if (marketLockingTime <= block.timestamp) {\n            _timeOfThisCollection = marketLockingTime;\n        }\n\n        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)\n        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)\n        if (\n            _user != address(this) &&\n            timeLastCollected[_card] < _timeOfThisCollection\n        ) {\n            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet\n            uint256 _timeUserForeclosed =\n                treasury.collectRentUser(_user, block.timestamp);\n\n            // Calculate the card timeLimitTimestamp\n            uint256 _cardTimeLimitTimestamp =\n                timeLastCollected[_card] + cardTimeLimit[_card];\n\n            // input bools\n            bool _foreclosed = _timeUserForeclosed != 0;\n            bool _limitHit =\n                cardTimeLimit[_card] != 0 &&\n                    _cardTimeLimitTimestamp < block.timestamp;\n            bool _marketLocked = marketLockingTime <= block.timestamp;\n\n            // outputs\n            bool _newOwner;\n            uint256 _refundTime; // seconds of rent to refund the user\n\n            /* Permutations of the events: Foreclosure, Time limit and Market Locking\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n            \u2502Case       \u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524\n            \u2502Foreclosure\u25020\u25020\u25020\u25020\u25021\u25021\u25021\u25021\u2502\n            \u2502Time Limit \u25020\u25020\u25021\u25021\u25020\u25020\u25021\u25021\u2502\n            \u2502Market Lock\u25020\u25021\u25020\u25021\u25020\u25021\u25020\u25021\u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n            */\n\n            if (!_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 1\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN simple rent collect, same owner\n                _timeOfThisCollection = _timeOfThisCollection;\n                _newOwner = false;\n                _refundTime = 0;\n            } else if (!_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 2\n                // didn't foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN refund rent between locking and now\n                _timeOfThisCollection = marketLockingTime;\n                _newOwner = false;\n                _refundTime = block.timestamp - marketLockingTime;\n            } else if (!_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 3\n                // didn't foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN refund rent between time limit and now\n                _timeOfThisCollection = _cardTimeLimitTimestamp;\n                _newOwner = true;\n                _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n            } else if (!_foreclosed && _limitHit && _marketLocked) {\n                // CASE 4\n                // didn't foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN refund rent between the earliest event and now\n                if (_cardTimeLimitTimestamp < marketLockingTime) {\n                    // time limit hit before market locked\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked before time limit hit\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 5\n                // did foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN rent OK, find new owner\n                _timeOfThisCollection = _timeUserForeclosed;\n                _newOwner = true;\n                _refundTime = 0;\n            } else if (_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 6\n                // did foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN if foreclosed first rent ok, otherwise refund after locking\n                if (_timeUserForeclosed < marketLockingTime) {\n                    // user foreclosed before market locked\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // market locked before user foreclosed\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 7\n                // did foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN if foreclosed first rent ok, otherwise refund after limit\n                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {\n                    // user foreclosed before time limit\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // time limit hit before user foreclosed\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                }\n            } else {\n                // CASE 8\n                // did foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN (\u256f\u00b0\u76ca\u00b0)\u256f\u5f61\u253b\u2501\u253b\n                if (\n                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&\n                    _timeUserForeclosed < marketLockingTime\n                ) {\n                    // user foreclosed first (or at same time as time limit)\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else if (\n                    _cardTimeLimitTimestamp < _timeUserForeclosed &&\n                    _cardTimeLimitTimestamp < marketLockingTime\n                ) {\n                    // time limit hit first\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked first\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = _timeUserForeclosed - marketLockingTime;\n                }\n            }\n            if (_refundTime != 0) {\n                uint256 _refundAmount =\n                    (_refundTime * cardPrice[_card]) / 1 days;\n                treasury.refundUser(_user, _refundAmount);\n            }\n            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens\n\n            if (_newOwner) {\n                orderbook.findNewOwner(_card, _timeOfThisCollection);\n                return true;\n            }\n        } else {\n            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking\n            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental\n            timeLastCollected[_card] = _timeOfThisCollection;\n        }\n        return false;\n    }\n\n    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls\n    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit\n    function _collectRent(uint256 _card)\n        internal\n        returns (bool didUpdateEverything)\n    {\n        uint32 counter = 0;\n        bool shouldContinue = true;\n        while (counter < maxRentIterations && shouldContinue) {\n            shouldContinue = _collectRentAction(_card);\n            counter++;\n        }\n        return !shouldContinue;\n    }\n\n    /// @dev processes actual rent collection and updates the state\n    function _processRentCollection(\n        address _user,\n        uint256 _card,\n        uint256 _timeOfCollection\n    ) internal {\n        uint256 _rentOwed =\n            (cardPrice[_card] *\n                (_timeOfCollection - timeLastCollected[_card])) / 1 days;\n        treasury.payRent(_rentOwed);\n        uint256 _timeHeldToIncrement =\n            (_timeOfCollection - timeLastCollected[_card]);\n\n        // if the user has a timeLimit, adjust it as necessary\n        if (cardTimeLimit[_card] != 0) {\n            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);\n            cardTimeLimit[_card] -= _timeHeldToIncrement;\n        }\n        timeHeld[_card][_user] += _timeHeldToIncrement;\n        totalTimeHeld[_card] += _timeHeldToIncrement;\n        rentCollectedPerUser[_user] += _rentOwed;\n        rentCollectedPerCard[_card] += _rentOwed;\n        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;\n        totalRentCollected += _rentOwed;\n        timeLastCollected[_card] = _timeOfCollection;\n\n        // longest owner tracking\n        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {\n            longestTimeHeld[_card] = timeHeld[_card][_user];\n            longestOwner[_card] = _user;\n        }\n        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);\n    }\n\n    function _checkState(States currentState) internal view {\n        require(state == currentState, \"Incorrect state\");\n    }\n\n    function _checkNotState(States currentState) internal view {\n        require(state != currentState, \"Incorrect state\");\n    }\n\n    /// @dev should only be called thrice\n    function _incrementState() internal {\n        assert(uint256(state) < 4);\n        state = States(uint256(state) + (1));\n        emit LogStateChange(uint256(state));\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        CIRCUIT BREAKER          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev in case Oracle never resolves for any reason\n    /// @dev does not set a winner so same as invalid outcome\n    /// @dev market does not need to be locked, just in case lockMarket bugs out\n    function circuitBreaker() external {\n        require(\n            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),\n            \"Too early\"\n        );\n        _incrementState();\n        orderbook.closeMarket();\n        state = States.WITHDRAW;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "Migrations.sol",
            "RCTreasury.sol",
            "RCMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-16",
                "Location": [
                    "//solidity\nrequire(\n    (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n    \"Limit hit\"\n);\n"
                ],
                "Type": " Deposits can be denied by abusing  maxContractBalance ",
                "Description": "\nThe treasury implements a max contract balance check in the deposit function:\n\nsolidity\nrequire(\n    (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n    \"Limit hit\"\n);\n\nA whale can stop anyone from depositing by front-running a user's deposit with a deposit that pushes the contract balance to the maxContractBalance limit first. The user's deposit will then fail in the check. Afterwards, the whale can withdraw again.\n\n This is not only restricted to whales, miners/users can do the same using same-block cross-transaction flashloans and submitting a (attacker deposit, user deposit, attacker withdraw) flashbundle to a miner. Possibilities like this will only become more prevalent in the future.\n\nAny users can be blocked from depositing which prevents them from renting cards.\nThis allows an attacker to manipulate the outcome of a market in their favor by strategically preventing other competitors to bid on their cards (causing forfeiture due to a low deposit balance).\n\n",
                "Repair": "Recommend removing the contract limit or at least set the limit very high if it keeps happening.\n\n\nmcplums (Reality Cards) acknowledged(https://github.com/code-423n4/2021-06-realitycards-findings/issues/153#issuecomment-862967304):\n  This is a good onebut I don't think we need to make any changes to the contract. We can use it as originally intended, then if it is exploited as above, we can switch to only setting the variable to 0 or maxuint256. So it just acts as a toggle on whether deposits are allowed.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\n\n/// @title Reality Cards Orderbook\n/// @author Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCOrderbook is Ownable, NativeMetaTransaction, IRCOrderbook {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev a record of a users single bid\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 token;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n    /// @dev maps a user address to an array of their bids\n    mapping(address => Bid[]) public user;\n    /// @dev index of a bid record in the user array, User|Market|Token->Index\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        public index;\n\n    /// @dev record of market specific variables\n    struct Market {\n        uint64 mode;\n        uint64 tokenCount;\n        uint64 minimumPriceIncreasePercent;\n        uint64 minimumRentalDuration;\n    }\n    /// @dev map a market address to a market record\n    mapping(address => Market) public market;\n    /// @dev true if the address is a market\n    mapping(address => bool) public isMarket;\n    /// @dev find the current owner of a token in a given market. Market -> Token -> Owner\n    mapping(address => mapping(uint256 => address)) public ownerOf;\n\n    /// @dev an array of closed markets, used to reduce user bid rates\n    address[] public closedMarkets;\n    /// @dev how far through the array a given user is, saves iterating the whole array every time.\n    mapping(address => uint256) public userClosedMarketIndex;\n\n    ///// GOVERNANCE VARIABLES /////\n    /// @dev only allow the uberOwner to call certain functions\n    address public uberOwner;\n    /// @dev the current factory address\n    address public factoryAddress;\n    /// @dev the current treasury address\n    address public treasuryAddress;\n    IRCTreasury public treasury;\n    /// @dev max number of searches to place an order in the book\n    /// @dev current estimates place limit around 2000\n    uint256 public maxSearchIterations = 1000;\n    /// @dev max number of records to delete in one transaction\n    uint256 public maxDeletions = 70;\n    /// @dev number of bids a user should clean when placing a new bid\n    uint256 public cleaningLoops = 2;\n    /// @dev nonce emitted with orderbook insertions, for frontend sorting\n    uint256 public nonce;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          MODIFIERS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice only allow markets to call certain functions\n    modifier onlyMarkets {\n        require(isMarket[msgSender()], \"Not authorised\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev emitted every time an order is added to the orderbook\n    event LogAddToOrderbook(\n        address indexed newOwner,\n        uint256 indexed newPrice,\n        uint256 timeHeldLimit,\n        uint256 nonce,\n        uint256 indexed tokenId,\n        address market\n    );\n    /// @dev emitted when an order is removed from an active market\n    event LogRemoveFromOrderbook(\n        address indexed owner,\n        address indexed market,\n        uint256 indexed tokenId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CONSTRUCTOR             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _factoryAddress, address _treasuryAddress) {\n        factoryAddress = _factoryAddress;\n        treasuryAddress = _treasuryAddress;\n        treasury = IRCTreasury(treasuryAddress);\n        uberOwner = msgSender();\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         GOVERNANCE              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function changeUberOwner(address _newUberOwner) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0));\n        uberOwner = _newUberOwner;\n    }\n\n    function setFactoryAddress(address _newFactory) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newFactory != address(0));\n        factoryAddress = _newFactory;\n    }\n\n    function setLimits(\n        uint256 _deletionLimit,\n        uint256 _cleaningLimit,\n        uint256 _searchLimit\n    ) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        if (_deletionLimit != 0) {\n            maxDeletions = _deletionLimit;\n        }\n        if (_cleaningLimit != 0) {\n            cleaningLoops = _cleaningLimit;\n        }\n        if (_searchLimit != 0) {\n            maxSearchIterations = _searchLimit;\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             INSERTIONS              \u2551\n      \u2551 functions that add to the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice adds a new market to the orderbook\n    function addMarket(\n        address _market,\n        uint256 _cardCount,\n        uint256 _minIncrease\n    ) external override {\n        require(msgSender() == factoryAddress);\n        isMarket[_market] = true;\n        market[_market].tokenCount = SafeCast.toUint64(_cardCount);\n        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(\n            _minIncrease\n        );\n        market[_market].minimumRentalDuration = SafeCast.toUint64(\n            1 days / treasury.minRentalDayDivisor()\n        );\n        for (uint64 i; i < _cardCount; i++) {\n            // create new record for each card that becomes the head&tail of the linked list\n            Bid memory _newBid;\n            _newBid.market = _market;\n            _newBid.token = i;\n            _newBid.prev = _market;\n            _newBid.next = _market;\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = type(uint64).max;\n            index[_market][_market][i] = user[_market].length;\n            user[_market].push(_newBid);\n        }\n    }\n\n    /// @notice adds or updates a bid in the orderbook\n    /// @param _user the user placing the bid\n    /// @param _card the token to place the bid on\n    /// @param _price the price of the new bid\n    /// @param _timeHeldLimit an optional time limit for the bid\n    /// @param _prevUserAddress to help find where to insert the bid\n    function addBidToOrderbook(\n        address _user,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external override onlyMarkets {\n        // each new bid can help clean up some junk\n        cleanWastePile();\n\n        if (user[_user].length == 0 && closedMarkets.length > 0) {\n            //users first bid, skip already closed markets\n            userClosedMarketIndex[_user] = closedMarkets.length - 1;\n        }\n\n        address _market = msgSender();\n        if (_prevUserAddress == address(0)) {\n            _prevUserAddress = _market;\n        } else {\n            require(\n                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]\n                    .price >= _price,\n                \"Location too low\"\n            );\n        }\n        Bid storage _prevUser =\n            user[_prevUserAddress][index[_prevUserAddress][_market][_card]];\n\n        if (bidExists(_user, _market, _card)) {\n            // old bid exists, update it\n            _updateBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        } else {\n            // new bid, add it\n            _newBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        }\n    }\n\n    /// @dev finds the correct location in the orderbook for a given bid\n    /// @dev returns an adjusted (lowered) bid price if necessary.\n    function _searchOrderbook(\n        Bid storage _prevUser,\n        address _market,\n        uint256 _card,\n        uint256 _price\n    ) internal view returns (Bid storage, uint256) {\n        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;\n        Bid storage _nextUser =\n            user[_prevUser.next][index[_prevUser.next][_market][_card]];\n        uint256 _requiredPrice =\n            (_nextUser.price * (_minIncrease + (100))) / (100);\n\n        uint256 i = 0;\n        while (\n            // break loop if match price above AND above price below (so if either is false, continue, hence OR )\n            // if match previous then must be greater than next to continue\n            (_price != _prevUser.price || _price <= _nextUser.price) &&\n            // break loop if price x% above below\n            _price < _requiredPrice &&\n            // break loop if hits max iterations\n            i < maxSearchIterations\n        ) {\n            _prevUser = _nextUser;\n            _nextUser = user[_prevUser.next][\n                index[_prevUser.next][_market][_card]\n            ];\n            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);\n            i++;\n        }\n        require(i < maxSearchIterations, \"Position in orderbook not found\");\n\n        // if previous price is zero it must be the market and this is a new owner\n        // .. then don't reduce their price, we already checked they are 10% higher\n        // .. than the previous owner.\n        if (_prevUser.price != 0 && _prevUser.price < _price) {\n            _price = _prevUser.price;\n        }\n        return (_prevUser, _price);\n    }\n\n    /// @dev add a new bid to the orderbook\n    function _newBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        if (ownerOf[_market][_card] != _market) {\n            (_prevUser, _price) = _searchOrderbook(\n                _prevUser,\n                _market,\n                _card,\n                _price\n            );\n        }\n\n        Bid storage _nextUser =\n            user[_prevUser.next][index[_prevUser.next][_market][_card]];\n\n        // create new record\n        Bid memory _newBid;\n        _newBid.market = _market;\n        _newBid.token = SafeCast.toUint64(_card);\n        _newBid.prev = _nextUser.prev;\n        _newBid.next = _prevUser.next;\n        _newBid.price = SafeCast.toUint128(_price);\n        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // insert in linked list\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n        user[_user].push(_newBid);\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = user[_user].length - (1);\n\n        emit LogAddToOrderbook(\n            _user,\n            _price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _price);\n        if (user[_user][index[_user][_market][_card]].prev == _market) {\n            address _oldOwner = user[_user][index[_user][_market][_card]].next;\n            transferCard(_market, _card, _oldOwner, _user, _price);\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                user[_oldOwner][index[_oldOwner][_market][_card]].price,\n                _price,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @dev updates a bid that is already in the orderbook\n    function _updateBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        // TODO no need to unlink and relink if bid doesn't change position in orderbook\n        // unlink current bid\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n        user[_currUser.next][index[_currUser.next][_market][_card]]\n            .prev = _currUser.prev;\n        user[_currUser.prev][index[_currUser.prev][_market][_card]]\n            .next = _currUser.next;\n        bool _owner = _currUser.prev == _market;\n\n        // find new position\n        (_prevUser, _price) = _searchOrderbook(\n            _prevUser,\n            _market,\n            _card,\n            _price\n        );\n        Bid storage _nextUser =\n            user[_prevUser.next][index[_prevUser.next][_market][_card]];\n\n        // update price, save old price for rental rate adjustment later\n        (_currUser.price, _price) = (\n            SafeCast.toUint128(_price),\n            uint256(_currUser.price)\n        );\n        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // relink bid\n        _currUser.next = _prevUser.next;\n        _currUser.prev = _nextUser.prev;\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n\n        emit LogAddToOrderbook(\n            _user,\n            _currUser.price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _currUser.price);\n        treasury.decreaseBidRate(_user, _price);\n        if (_owner && _currUser.prev == _market) {\n            // if owner before and after, update the price difference\n            transferCard(_market, _card, _user, _user, _currUser.price);\n            treasury.updateRentalRate(\n                _user,\n                _user,\n                _price,\n                _currUser.price,\n                block.timestamp\n            );\n        } else if (_owner && _currUser.prev != _market) {\n            // if owner before and not after, remove the old price\n            address _newOwner =\n                user[_market][index[_market][_market][_card]].next;\n            uint256 _newPrice =\n                user[_newOwner][index[_newOwner][_market][_card]].price;\n            treasury.updateRentalRate(\n                _user,\n                _newOwner,\n                _price,\n                _newPrice,\n                block.timestamp\n            );\n            transferCard(_market, _card, _user, _newOwner, _newPrice);\n        } else if (!_owner && _currUser.prev == _market) {\n            // if not owner before but is owner after, add new price\n            address _oldOwner = _currUser.next;\n            uint256 _oldPrice =\n                user[_oldOwner][index[_oldOwner][_market][_card]].price;\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                _oldPrice,\n                _currUser.price,\n                block.timestamp\n            );\n            transferCard(_market, _card, _oldOwner, _user, _currUser.price);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551                DELETIONS                 \u2551      \n      \u2551 functions that remove from the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice removes a single bid from the orderbook - onlyMarkets\n    function removeBidFromOrderbook(address _user, uint256 _card)\n        public\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        // update rates\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n        treasury.decreaseBidRate(_user, _currUser.price);\n        if (_currUser.prev == _market) {\n            // user is owner, deal with it\n            uint256 _price =\n                user[_currUser.next][index[_currUser.next][_market][_card]]\n                    .price;\n            transferCard(_market, _card, _user, _currUser.next, _price);\n            treasury.updateRentalRate(\n                _user,\n                _currUser.next,\n                _currUser.price,\n                _price,\n                block.timestamp\n            );\n        }\n        // extract from linked list\n        address _tempNext = _currUser.next;\n        address _tempPrev = _currUser.prev;\n        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;\n        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;\n\n        // overwrite array element\n        uint256 _index = index[_user][_market][_card];\n        uint256 _lastRecord = user[_user].length - (1);\n\n        // no point overwriting itself\n        if (_index != _lastRecord) {\n            user[_user][_index] = user[_user][_lastRecord];\n        }\n        user[_user].pop();\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = 0;\n        if (user[_user].length != 0 && _index != _lastRecord) {\n            index[_user][user[_user][_index].market][\n                user[_user][_index].token\n            ] = _index;\n        }\n        emit LogRemoveFromOrderbook(_user, _market, _card);\n    }\n\n    /// @dev removes a single bid from the orderbook, doesn't update ownership\n    function _removeBidFromOrderbookIgnoreOwner(address _user, uint256 _card)\n        internal\n        returns (uint256 _newPrice)\n    {\n        address _market = msgSender();\n        // update rates\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n        treasury.decreaseBidRate(_user, _currUser.price);\n\n        // extract from linked list\n        address _tempNext = _currUser.next;\n        address _tempPrev = _currUser.prev;\n        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;\n        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;\n\n        // return next users price to check they're eligable later\n        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;\n\n        // overwrite array element\n        uint256 _index = index[_user][_market][_card];\n        uint256 _lastRecord = user[_user].length - 1;\n        // no point overwriting itself\n        if (_index != _lastRecord) {\n            user[_user][_index] = user[_user][_lastRecord];\n        }\n        user[_user].pop();\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = 0;\n        if (user[_user].length != 0 && _index != _lastRecord) {\n            index[_user][user[_user][_index].market][\n                user[_user][_index].token\n            ] = _index;\n        }\n        emit LogRemoveFromOrderbook(_user, _market, _card);\n    }\n\n    /// @notice find the next valid owner of a given card - onlyMarkets\n    /// @param _card the token to remove\n    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes\n    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)\n        external\n        override\n        onlyMarkets\n        returns (address _newOwner)\n    {\n        address _market = msgSender();\n        // the market is the head of the list, the next bid is therefore the owner\n        Bid storage _head = user[_market][index[_market][_market][_card]];\n        address _oldOwner = _head.next;\n        uint256 _oldPrice =\n            user[_oldOwner][index[_oldOwner][_market][_card]].price;\n        uint256 minimumTimeToOwnTo =\n            _timeOwnershipChanged + market[_market].minimumRentalDuration;\n        uint256 _newPrice;\n\n        // delete current owner\n        do {\n            _newPrice = _removeBidFromOrderbookIgnoreOwner(_head.next, _card);\n            // delete next bid if foreclosed\n        } while (\n            treasury.foreclosureTimeUser(\n                _head.next,\n                _newPrice,\n                _timeOwnershipChanged\n            ) < minimumTimeToOwnTo\n        );\n\n        // the old owner is dead, long live the new owner\n        _newOwner = user[_market][index[_market][_market][_card]].next;\n        treasury.updateRentalRate(\n            _oldOwner,\n            _newOwner,\n            _oldPrice,\n            _newPrice,\n            _timeOwnershipChanged\n        );\n        transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);\n    }\n\n    /// @notice when a user has foreclosed we can freely delete their bids\n    /// @param _user the user whose bids to start deleting\n    /// @return _userForeclosed if the user doesn't have bids left they are considered not foreclosed anymore\n    function removeUserFromOrderbook(address _user)\n        external\n        override\n        returns (bool _userForeclosed)\n    {\n        require(treasury.isForeclosed(_user), \"User must be foreclosed\");\n        uint256 i = user[_user].length;\n        uint256 _limit = 0;\n        if (i > maxDeletions) {\n            _limit = i - maxDeletions;\n        }\n        address _market = user[_user][i - 1].market;\n        uint256 _card = user[_user][i - 1].token;\n\n        do {\n            i--;\n            index[_user][user[_user][i].market][user[_user][i].token] = 0;\n            address _tempPrev = user[_user][i].prev;\n            address _tempNext = user[_user][i].next;\n\n            // reduce the rentalRate if they are owner\n            if (_tempPrev == user[_user][i].market) {\n                _market = user[_user][i].market;\n                _card = user[_user][i].token;\n                uint256 _price =\n                    user[_tempNext][index[_tempNext][_market][_card]].price;\n                treasury.updateRentalRate(\n                    _user,\n                    _tempNext,\n                    user[_user][i].price,\n                    _price,\n                    block.timestamp\n                );\n                transferCard(_market, _card, _user, _tempNext, _price);\n            }\n\n            treasury.decreaseBidRate(_user, user[_user][i].price);\n\n            user[_tempNext][\n                index[_tempNext][user[_user][i].market][user[_user][i].token]\n            ]\n                .prev = _tempPrev;\n            user[_tempPrev][\n                index[_tempPrev][user[_user][i].market][user[_user][i].token]\n            ]\n                .next = _tempNext;\n            user[_user].pop();\n        } while (user[_user].length > _limit);\n        if (user[_user].length == 0) {\n            treasury.resetUser(_user);\n            _userForeclosed = false;\n        } else {\n            _userForeclosed = true;\n        }\n    }\n\n    /// @notice reduces the rentalRates of the card owners when a market closes\n    /// @dev too many bidders to reduce all bid rates also\n    function closeMarket() external override onlyMarkets {\n        address _market = msgSender();\n        closedMarkets.push(_market);\n\n        for (uint64 i = 0; i < market[_market].tokenCount; i++) {\n            // reduce owners rental rate\n            address _owner = user[_market][index[_market][_market][i]].next;\n            uint256 _price = user[_owner][index[_owner][_market][i]].price;\n            treasury.updateRentalRate(\n                _owner,\n                _market,\n                _price,\n                0,\n                block.timestamp\n            );\n\n            // store first and last bids for later\n            address _firstBid = _owner;\n            address _lastBid = user[_market][index[_market][_market][i]].prev;\n\n            // detach market from rest of list\n            user[_market][index[_market][_market][i]].prev = _market;\n            user[_market][index[_market][_market][i]].next = _market;\n            user[_firstBid][index[_market][_firstBid][i]].prev = address(this);\n            user[_lastBid][index[_market][_lastBid][i]].next = address(this);\n\n            // insert bids in the waste pile\n            Bid memory _newBid;\n            _newBid.market = _market;\n            _newBid.token = i;\n            _newBid.prev = _lastBid;\n            _newBid.next = _firstBid;\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = 0;\n            user[address(this)].push(_newBid);\n        }\n    }\n\n    /// @notice Remove bids in closed markets for a given user\n    /// @notice this can reduce the users bidRate and chance to foreclose\n    /// @param _user the address of the users bids to remove\n    function removeOldBids(address _user) external override {\n        address _market;\n        uint256 _cardCount;\n        uint256 _loopCounter;\n        while (\n            userClosedMarketIndex[_user] < closedMarkets.length &&\n            _loopCounter + _cardCount < maxDeletions\n        ) {\n            _market = closedMarkets[userClosedMarketIndex[_user]];\n            _cardCount = market[_market].tokenCount;\n            for (uint256 i = market[_market].tokenCount; i != 0; ) {\n                i--;\n                if (bidExists(_user, _market, i)) {\n                    // reduce bidRate\n                    uint256 _price =\n                        user[_user][index[_user][_market][i]].price;\n                    treasury.decreaseBidRate(_user, _price);\n\n                    // preserve linked list\n                    address _tempPrev =\n                        user[_user][index[_user][_market][i]].prev;\n                    address _tempNext =\n                        user[_user][index[_user][_market][i]].next;\n\n                    user[_tempNext][index[_tempNext][_market][i]]\n                        .prev = _tempPrev;\n                    user[_tempPrev][index[_tempPrev][_market][i]]\n                        .next = _tempNext;\n\n                    // delete bid\n                    user[_user].pop();\n                    index[_user][_market][i] = 0;\n\n                    // count deletions\n                    _loopCounter++;\n                }\n            }\n            userClosedMarketIndex[_user]++;\n        }\n    }\n\n    /// @dev remove bids in closed markets, not user specific\n    function cleanWastePile() internal {\n        uint256 i;\n        while (i < cleaningLoops && user[address(this)].length > 0) {\n            uint256 _pileHeight = user[address(this)].length - 1;\n\n            if (user[address(this)][_pileHeight].next == address(this)) {\n                user[address(this)].pop();\n            } else {\n                address _market = user[address(this)][_pileHeight].market;\n                uint256 _card = user[address(this)][_pileHeight].token;\n                address _user =\n                    user[address(this)][index[address(this)][_market][_card]]\n                        .next;\n\n                Bid storage _currUser =\n                    user[_user][index[_user][_market][_card]];\n                // extract from linked list\n                address _tempNext = _currUser.next;\n                address _tempPrev = _currUser.prev;\n                user[_tempNext][index[_tempNext][_market][_card]]\n                    .prev = _tempPrev;\n                user[_tempPrev][index[_tempPrev][_market][_card]]\n                    .next = _tempNext;\n\n                // overwrite array element\n                uint256 _index = index[_user][_market][_card];\n                uint256 _lastRecord = user[_user].length - (1);\n                // no point overwriting itself\n                if (_index != _lastRecord) {\n                    user[_user][_index] = user[_user][_lastRecord];\n                }\n                user[_user].pop();\n\n                // update the index to help find the record later\n                index[_user][_market][_card] = 0;\n                if (user[_user].length != 0 && _index != _lastRecord) {\n                    index[_user][user[_user][_index].market][\n                        user[_user][_index].token\n                    ] = _index;\n                }\n            }\n            i++;\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        HELPER FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check if a bid exists\n    /// @param _user the address of the user\n    /// @param _market the address of the market\n    /// @param _card the card index\n    /// @return if the bid exists or not\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) public view override returns (bool) {\n        if (user[_user].length != 0) {\n            //some bids exist\n            if (index[_user][_market][_card] != 0) {\n                // this bid exists\n                return true;\n            } else {\n                // check bid isn't index 0\n                if (\n                    user[_user][0].market == _market &&\n                    user[_user][0].token == _card\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function getBidValue(address _user, uint256 _card)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address _market = msgSender();\n        if (bidExists(_user, _market, _card)) {\n            return user[_user][index[_user][_market][_card]].price;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @dev just to pass old tests, not needed otherwise\n    /// @dev to be deleted once tests updated\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory) {\n        if (bidExists(_user, _market, _card)) {\n            Bid memory _bid = user[_user][index[_user][_market][_card]];\n            return _bid;\n        } else {\n            Bid memory _newBid;\n            _newBid.market = address(0);\n            _newBid.token = SafeCast.toUint64(_card);\n            _newBid.prev = address(0);\n            _newBid.next = address(0);\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = 0;\n            return _newBid;\n        }\n    }\n\n    function getTimeHeldlimit(address _user, uint256 _card)\n        external\n        view\n        override\n        onlyMarkets\n        returns (uint256)\n    {\n        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;\n    }\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeldLimit\n    ) external override onlyMarkets {\n        address _market = msgSender();\n        require(bidExists(_user, _market, _card), \"Bid doesn't exist\");\n        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast\n            .toUint64(_timeHeldLimit);\n    }\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeToReduce\n    ) external override onlyMarkets {\n        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast\n            .toUint64(_timeToReduce);\n    }\n\n    function transferCard(\n        address _market,\n        uint256 _card,\n        address _oldOwner,\n        address _newOwner,\n        uint256 _price\n    ) internal {\n        ownerOf[_market][_card] = _newOwner;\n        uint256 _timeLimit =\n            user[_newOwner][index[_newOwner][_market][_card]].timeHeldLimit;\n        IRCMarket _rcmarket = IRCMarket(_market);\n        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public orderbook;\n    /// @dev nfthub instance, to query current card owner\n    IRCNftHubL2 public nfthub;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev address of the Factory so only the Factory can add new markets\n    address public override factoryAddress;\n    /// @dev so only markets can use certain functions\n    mapping(address => bool) public override isMarket;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public marketBalance;\n    /// @dev a quick check if a uesr is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 marketBalanceDiscrepancy;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent any cards for specific market\n    mapping(address => bool) public override marketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            UBER OWNER           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev high level owner who can change the factory address\n    address public override uberOwner;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msgSender();\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1000000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /// @notice only allow markets to call these functions\n    modifier onlyMarkets {\n        require(isMarket[msgSender()], \"Not authorised\");\n        _;\n    }\n\n    /// @notice only allow orderbook to call these functions\n    modifier onlyOrderbook {\n        require(msgSender() == address(orderbook), \"Not authorised\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           ADD MARKETS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev so only markets can move funds from deposits to marketPots and vice versa\n    function addMarket(address _newMarket) external override {\n        require(msgSender() == factoryAddress, \"Not factory\");\n        isMarket[_newMarket] = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyOwner\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUTOR - PUBLIC  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyOwner\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyOwner {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental for a specific market\n    function changePauseMarket(address _market) external override onlyOwner {\n        require(isMarket[_market], \"This isn't a market\");\n        marketPaused[_market] = !marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyOwner {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add a user to the whitelist\n    function addToWhitelist(address _user) public override {\n        IRCFactory factory = IRCFactory(factoryAddress);\n        require(factory.isGovernor(msgSender()), \"Not authorised\");\n        isAllowed[_user] = !isAllowed[_user];\n    }\n\n    /// @notice Add multiple users to the whitelist\n    function batchAddToWhitelist(address[] calldata _users) public override {\n        for (uint256 index = 0; index < _users.length; index++) {\n            addToWhitelist(_users[index]);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    function setFactoryAddress(address _newFactory) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newFactory != address(0), \"Must set an address\");\n        factoryAddress = _newFactory;\n    }\n\n    function setOrderbookAddress(address _newOrderbook) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newOrderbook != address(0), \"Must set an address\");\n        orderbook = IRCOrderbook(_newOrderbook);\n    }\n\n    function setNftHubAddress(address _NFTHubAddress) external {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_NFTHubAddress != address(0), \"Must set an address\");\n        nfthub = IRCNftHubL2(_NFTHubAddress);\n    }\n\n    function setTokenAddress(address _newToken) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge) public override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    function changeUberOwner(address _newUberOwner) external override {\n        require(msgSender() == uberOwner, \"Extremely Verboten\");\n        require(_newUberOwner != address(0), \"Must set an address\");\n        uberOwner = _newUberOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract (newRental) or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        public\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(isAllowed[msgSender()], \"Not in whitelist\");\n        }\n        erc20.transferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        if (\n            (user[_user].deposit + _amount) >\n            (user[_user].bidRate / minRentalDayDivisor)\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // stpe 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.transfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            isForeclosed[_msgSender] = true;\n            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(\n                _msgSender\n            );\n            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount) external override {\n        erc20.transferFrom(msgSender(), address(this), _amount);\n        if (_amount > marketBalanceDiscrepancy) {\n            marketBalanceDiscrepancy = 0;\n        } else {\n            marketBalanceDiscrepancy -= _amount;\n        }\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            marketBalanceDiscrepancy += _amount - marketBalance;\n            _amount -= (_amount - marketBalance);\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n\n        return true;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        assert(marketPot[msgSender()] >= _amount);\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        onlyMarkets\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        if (\n            isForeclosed[_user] &&\n            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor\n        ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyMarkets\n        returns (bool)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.transferFrom(_sponsor, address(this), _amount);\n        marketPot[msgSender()] += _amount;\n        totalMarketPots += _amount;\n        return true;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyMarkets\n        returns (bool)\n    {\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        if (user[_user].lastRentCalc == 0) {\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n        return true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice provides the sum total of a users bids accross all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyOrderbook {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !isMarket[_newOwner]\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed =\n                    rentOwedBetweenTimestmaps(\n                        block.timestamp,\n                        _timeOwnershipChanged,\n                        _newPrice\n                    );\n                collectRentUser(_newOwner, block.timestamp);\n\n                // they have enough funds, just collect the extra\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyOrderbook\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /// @dev called when all a user's bids have been removed, disables foreclosure state\n    function resetUser(address _user) external override onlyOrderbook {\n        isForeclosed[_user] = false;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calcualtion and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calcualtes the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestmaps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the amount of deposit a user is able to withdraw\n    /// @notice ..after considering rent due to be paid\n    /// @param _user the user to query\n    function depositAbleToWithdraw(address _user)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 collection = rentOwedUser(_user, block.timestamp);\n        if (collection >= user[_user].deposit) {\n            return 0;\n        } else {\n            return uint256(user[_user].deposit) - (collection);\n        }\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)\n            //                   = (deposit * 1day) / totalUserDailyRent\n            uint256 timeLeftOfDeposit =\n                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard =\n                user[_user].lastRentCalc + timeLeftOfDeposit;\n\n            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {\n                // calculate how long they can own the new card for\n                uint256 _rentAlreadyOwed =\n                    rentOwedBetweenTimestmaps(\n                        user[_user].lastRentCalc,\n                        _timeOfNewBid,\n                        totalUserDailyRent\n                    );\n                uint256 _depositAtTimeOfNewBid =\n                    user[_user].deposit - _rentAlreadyOwed;\n                uint256 _timeLeftOfDepositWithNewBid =\n                    (_depositAtTimeOfNewBid * 1 days) /\n                        (totalUserDailyRent + _newBid);\n                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            // if no rentals they'll foreclose after the heat death of the universe\n            return type(uint256).max;\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        assert(_timeToCollectTo != 0);\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts =\n                    ((_timeToCollectTo - previousCollectionTime) *\n                        uint256(user[_user].deposit)) / rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepsitLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets availiable balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCOrderbook.sol",
            "RCTreasury.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-17",
                "Location": [
                    "foreclosureTimeUser",
                    "depositAbleToWithdraw(_user)",
                    "timeLeftOfDeposit",
                    "foreclosureTimeWithoutNewCard"
                ],
                "Type": " Function  foreclosureTimeUser  returns a shorter user's foreclosure time than expected",
                "Description": "\nThe function foreclosureTimeUser of RCTreasury underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.\n\nThe variable timeLeftOfDeposit at line 668 is calculated based on depositAbleToWithdraw(_user), the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable timeLeftOfDeposit indicates the time left of deposit, starting from now. However, at line 672, the foreclosureTimeWithoutNewCard is calculated by timeLeftOfDeposit plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.\n\n",
                "Repair": "Recommend changing depositAbleToWithdraw(_user) at line 669 to user[_user].deposit. Or, change user[_user].lastRentCalc at both line 672 and 678 to block.timestamp.\n\nSplidge (Reality Cards) confirmed and resolved(https://github.com/code-423n4/2021-06-realitycards-findings/issues/171#issuecomment-865843473):\n  phew, this was one to wrap your head around.\n I went with the first recommended mitigation because I believe the second one could causes issues if the user had already foreclosed, depositAbleToWithdraw would return 0 and so foreclosureTimeWithoutNewCard would incorrectly show as block.timestamp. Fix implemented here(https://github.com/RealityCards/RealityCards-Contracts/commit/a160893b17633491c064a6bf05ced72df15390fd)\n\n Really nice spot this one. Many thanks for such an in-depth look into the maths.\n\n\n"
            }
        ]
    }
]