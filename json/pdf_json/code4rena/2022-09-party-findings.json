[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "diff\n--a/sol-tests/party/PartyGovernanceUnit.t.sol\n+++ b/sol-tests/party/PartyGovernanceUnit.t.sol\n@@ -762,6 +762,7 @@ contract PartyGovernanceUnitTest is Test, TestUtils {\n         TestablePartyGovernance gov =\n             _createGovernance(100e18, preciousTokens, preciousTokenIds);\n         address undelegatedVoter = _randomAddress();\n+        address recipient = _randomAddress();\n         // undelegatedVoter has 50/100 intrinsic VP (delegated to no one/self)\n         gov.rawAdjustVotingPower(undelegatedVoter, 50e18, address(0));\n \n@@ -772,38 +773,13 @@ contract PartyGovernanceUnitTest is Test, TestUtils {\n         // Undelegated voter submits proposal.\n         vm.prank(undelegatedVoter);\n         assertEq(gov.propose(proposal, 0), proposalId);\n-\n       // Try to execute proposal (fail).\n       vm.expectRevert(abi.encodeWithSelector(\n           PartyGovernance.BadProposalStatusError.selector,\n           PartyGovernance.ProposalStatus.Voting\n       ));\n       vm.prank(undelegatedVoter);\n       gov.execute(\n           proposalId,\n           proposal,\n           preciousTokens,\n           preciousTokenIds,\n           \"\",\n           \"\"\n       );\n-\n       // Skip past execution delay.\n       skip(defaultGovernanceOpts.executionDelay);\n       // Try again (fail).\n       vm.expectRevert(abi.encodeWithSelector(\n           PartyGovernance.BadProposalStatusError.selector,\n           PartyGovernance.ProposalStatus.Voting\n       ));\n       vm.prank(undelegatedVoter);\n       gov.execute(\n           proposalId,\n           proposal,\n           preciousTokens,\n           preciousTokenIds,\n           \"\",\n           \"\"\n       );\n+        (, PartyGovernance.ProposalStateValues memory valuesPrev) = gov.getProposalStateInfo(proposalId);\n+        assertEq(valuesPrev.votes, 50e18);\n+        gov.transferVotingPower(undelegatedVoter, recipient, 50e18); //Simulate NFT transfer\n+        vm.prank(recipient);\n+        gov.accept(proposalId, 0);\n+        (, PartyGovernance.ProposalStateValues memory valuesAfter) = gov.getProposalStateInfo(proposalId);\n+        assertEq(valuesAfter.votes, 100e18);\n     }\n"
                ],
                "Type": " PartyGovernance: Can vote multiple times by transferring NFT in same block as proposal",
                "Description": "\nPartyGovernanceNFT uses the voting power at the time of proposal when calling accept. The problem with that is that a user can vote, transfer the NFT (and the voting power) to a different wallet, and then vote from this second wallet again during the same block that the proposal was created.\nThis can also be repeated multiple times to get an arbitrarily high voting power and pass every proposal unanimously.\n\nThe consequences of this are very severe. Any user (no matter how small his voting power is) can propose and pass arbitrary proposals animously and therefore steal all assets (including the precious tokens) out of the party.\n\n\nThis diff shows how a user with a voting power of 50/100 gets a voting power of 100/100 by transferring the NFT to a second wallet that he owns and voting from that one:\n\ndiff\n--a/sol-tests/party/PartyGovernanceUnit.t.sol\n+++ b/sol-tests/party/PartyGovernanceUnit.t.sol\n@@ -762,6 +762,7 @@ contract PartyGovernanceUnitTest is Test, TestUtils {\n         TestablePartyGovernance gov =\n             _createGovernance(100e18, preciousTokens, preciousTokenIds);\n         address undelegatedVoter = _randomAddress();\n+        address recipient = _randomAddress();\n         // undelegatedVoter has 50/100 intrinsic VP (delegated to no one/self)\n         gov.rawAdjustVotingPower(undelegatedVoter, 50e18, address(0));\n \n@@ -772,38 +773,13 @@ contract PartyGovernanceUnitTest is Test, TestUtils {\n         // Undelegated voter submits proposal.\n         vm.prank(undelegatedVoter);\n         assertEq(gov.propose(proposal, 0), proposalId);\n-\n       // Try to execute proposal (fail).\n       vm.expectRevert(abi.encodeWithSelector(\n           PartyGovernance.BadProposalStatusError.selector,\n           PartyGovernance.ProposalStatus.Voting\n       ));\n       vm.prank(undelegatedVoter);\n       gov.execute(\n           proposalId,\n           proposal,\n           preciousTokens,\n           preciousTokenIds,\n           \"\",\n           \"\"\n       );\n-\n       // Skip past execution delay.\n       skip(defaultGovernanceOpts.executionDelay);\n       // Try again (fail).\n       vm.expectRevert(abi.encodeWithSelector(\n           PartyGovernance.BadProposalStatusError.selector,\n           PartyGovernance.ProposalStatus.Voting\n       ));\n       vm.prank(undelegatedVoter);\n       gov.execute(\n           proposalId,\n           proposal,\n           preciousTokens,\n           preciousTokenIds,\n           \"\",\n           \"\"\n       );\n+        (, PartyGovernance.ProposalStateValues memory valuesPrev) = gov.getProposalStateInfo(proposalId);\n+        assertEq(valuesPrev.votes, 50e18);\n+        gov.transferVotingPower(undelegatedVoter, recipient, 50e18); //Simulate NFT transfer\n+        vm.prank(recipient);\n+        gov.accept(proposalId, 0);\n+        (, PartyGovernance.ProposalStateValues memory valuesAfter) = gov.getProposalStateInfo(proposalId);\n+        assertEq(valuesAfter.votes, 100e18);\n     }\n\n\n",
                "Repair": "\nYou should query the voting power at values.proposedTime 1. This value is already finalized when the proposal is created and therefore cannot be manipulated by repeatedly transferring the voting power to different wallets.\n\nmerklejerk (PartyDAO) confirmed and commented(https://github.com/code-423n4/2022-09-party-findings/issues/113#issuecomment-1254200841):\n  This is our favorite find and want to call it out specifically. We would consider this critical.\n \n We will implement the suggested fix in this PR and use proposedTime 1 for voting power calculations.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-09-party-findings/issues/113#issuecomment-1262756331):\n  Agree with High risk any user with a non-zero voting power can pass a proposal & steal assets.\n\n0xble (PartyDAO) resolved(https://github.com/code-423n4/2022-09-party-findings/issues/113#issuecomment-1264675378):\n  Resolved: https://github.com/PartyDAO/partybidV2/pull/130\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "diff\n--a/sol-tests/crowdfund/BuyCrowdfund.t.sol\n+++ b/sol-tests/crowdfund/BuyCrowdfund.t.sol\n@@ -36,9 +36,9 @@ contract BuyCrowdfundTest is Test, TestUtils {\n     string defaultSymbol = 'PBID';\n     uint40 defaultDuration = 60 * 60;\n     uint96 defaultMaxPrice = 10e18;\n   address payable defaultSplitRecipient = payable(0);\n+    address payable defaultSplitRecipient = payable(address(this));\n     uint16 defaultSplitBps = 0.1e4;\n   address defaultInitialDelegate;\n+    address defaultInitialDelegate = address(this);\n     IGateKeeper defaultGateKeeper;\n     bytes12 defaultGateKeeperId;\n     Crowdfund.FixedGovernanceOpts defaultGovernanceOpts;\n@@ -78,7 +78,7 @@ contract BuyCrowdfundTest is Test, TestUtils {\n                     maximumPrice: defaultMaxPrice,\n                     splitRecipient: defaultSplitRecipient,\n                     splitBps: defaultSplitBps,\n                   initialContributor: address(this),\n+                    initialContributor: address(0),\n                     initialDelegate: defaultInitialDelegate,\n                     gateKeeper: defaultGateKeeper,\n                     gateKeeperId: defaultGateKeeperId,\n@@ -111,40 +111,26 @@ contract BuyCrowdfundTest is Test, TestUtils {\n     function testHappyPath() public {\n         uint256 tokenId = erc721Vault.mint();\n         // Create a BuyCrowdfund instance.\n       BuyCrowdfund pb = _createCrowdfund(tokenId, 0);\n+        BuyCrowdfund pb = _createCrowdfund(tokenId, 0.25e18);\n         // Contribute and delegate.\n         address payable contributor = _randomAddress();\n         address delegate = _randomAddress();\n         vm.deal(contributor, 1e18);\n         vm.prank(contributor);\n         pb.contribute{ value: contributor.balance }(delegate, \"\");\n       // Buy the token.\n       vm.expectEmit(false, false, false, true);\n       emit MockPartyFactoryCreateParty(\n           address(pb),\n           address(pb),\n           _createExpectedPartyOptions(0.5e18),\n           _toERC721Array(erc721Vault.token()),\n           _toUint256Array(tokenId)\n       );\n       Party party_ = pb.buy(\n           payable(address(erc721Vault)),\n           0.5e18,\n           abi.encodeCall(erc721Vault.claim, (tokenId)),\n           defaultGovernanceOpts\n       );\n       assertEq(address(party), address(party_));\n       // Burn contributor's NFT, mock minting governance tokens and returning\n       // unused contribution.\n       vm.expectEmit(false, false, false, true);\n       emit MockMint(\n           address(pb),\n           contributor,\n           0.5e18,\n           delegate\n       );\n       pb.burn(contributor);\n       assertEq(contributor.balance, 0.5e18);\n+        vm.warp(block.timestamp + defaultDuration + 1);\n+        // The auction was not won, we can now burn all ETH from contributor...\n+        assertEq(address(pb).balance, 1.25e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 1e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.75e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.5e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.25e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0);\n"
                ],
                "Type": " Possibility to burn all ETH in Crowdfund under some circumstances",
                "Description": "\nIf opts.initialContributor is set to address(0) (and opts.initialDelegate is not), there are two problems:\n1.) If the crowdfund succeeds, the initial balance will be lost. It is still accredited to address(0), but it is not retrievable.\n2.) If the crowdfund does not succeed, anyone can completely drain the contract by repeatedly calling burn with address(0). This will always succeed because CrowdfundNFT._burn can be called multiple times for address(0). Every call will cause the initial balance to be burned (transferred to address(0)).\n\nIssue 1 is somewhat problematic, but issue 2 is very problematic, because all funds of a crowdfund are burned and an attacker can specifically set up such a deployment (and the user would not notice anything special, after all these are parameters that the protocol accepts).\n\n\nThis diff illustrates scenario 2, i.e. where a malicious deployer burns all contributions (1 ETH) of contributor. He loses 0.25ETH for the attack, but this could be reduced significantly (with more burn(payable(address(0))) calls:\n\ndiff\n--a/sol-tests/crowdfund/BuyCrowdfund.t.sol\n+++ b/sol-tests/crowdfund/BuyCrowdfund.t.sol\n@@ -36,9 +36,9 @@ contract BuyCrowdfundTest is Test, TestUtils {\n     string defaultSymbol = 'PBID';\n     uint40 defaultDuration = 60 * 60;\n     uint96 defaultMaxPrice = 10e18;\n   address payable defaultSplitRecipient = payable(0);\n+    address payable defaultSplitRecipient = payable(address(this));\n     uint16 defaultSplitBps = 0.1e4;\n   address defaultInitialDelegate;\n+    address defaultInitialDelegate = address(this);\n     IGateKeeper defaultGateKeeper;\n     bytes12 defaultGateKeeperId;\n     Crowdfund.FixedGovernanceOpts defaultGovernanceOpts;\n@@ -78,7 +78,7 @@ contract BuyCrowdfundTest is Test, TestUtils {\n                     maximumPrice: defaultMaxPrice,\n                     splitRecipient: defaultSplitRecipient,\n                     splitBps: defaultSplitBps,\n                   initialContributor: address(this),\n+                    initialContributor: address(0),\n                     initialDelegate: defaultInitialDelegate,\n                     gateKeeper: defaultGateKeeper,\n                     gateKeeperId: defaultGateKeeperId,\n@@ -111,40 +111,26 @@ contract BuyCrowdfundTest is Test, TestUtils {\n     function testHappyPath() public {\n         uint256 tokenId = erc721Vault.mint();\n         // Create a BuyCrowdfund instance.\n       BuyCrowdfund pb = _createCrowdfund(tokenId, 0);\n+        BuyCrowdfund pb = _createCrowdfund(tokenId, 0.25e18);\n         // Contribute and delegate.\n         address payable contributor = _randomAddress();\n         address delegate = _randomAddress();\n         vm.deal(contributor, 1e18);\n         vm.prank(contributor);\n         pb.contribute{ value: contributor.balance }(delegate, \"\");\n       // Buy the token.\n       vm.expectEmit(false, false, false, true);\n       emit MockPartyFactoryCreateParty(\n           address(pb),\n           address(pb),\n           _createExpectedPartyOptions(0.5e18),\n           _toERC721Array(erc721Vault.token()),\n           _toUint256Array(tokenId)\n       );\n       Party party_ = pb.buy(\n           payable(address(erc721Vault)),\n           0.5e18,\n           abi.encodeCall(erc721Vault.claim, (tokenId)),\n           defaultGovernanceOpts\n       );\n       assertEq(address(party), address(party_));\n       // Burn contributor's NFT, mock minting governance tokens and returning\n       // unused contribution.\n       vm.expectEmit(false, false, false, true);\n       emit MockMint(\n           address(pb),\n           contributor,\n           0.5e18,\n           delegate\n       );\n       pb.burn(contributor);\n       assertEq(contributor.balance, 0.5e18);\n+        vm.warp(block.timestamp + defaultDuration + 1);\n+        // The auction was not won, we can now burn all ETH from contributor...\n+        assertEq(address(pb).balance, 1.25e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 1e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.75e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.5e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.25e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0);\n\n\n",
                "Repair": "\nDo not allow an initial contribution when opts.initialContributor is not set.\n\nmerklejerk (PartyDAO) confirmed and commented(https://github.com/code-423n4/2022-09-party-findings/issues/105#issuecomment-1254181677):\n  Excellent catch. We will implement the fix from #238(https://github.com/code-423n4/2022-09-party-findings/issues/238) and prevent minting to address(0).\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-09-party-findings/issues/105#issuecomment-1262738133):\n  Agree with High risk a crowdfund's initial configuration could lead to the loss of user funds.\n\n0xble (PartyDAO) resolved(https://github.com/code-423n4/2022-09-party-findings/issues/105#issuecomment-1264675679):\n  Resolved: https://github.com/PartyDAO/partybidV2/pull/127\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [],
                "Type": " A majority attack can easily bypass Zora auction stage in OpenseaProposal and steal the NFT from the party.",
                "Description": "\nThe PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. One of the main protections is that before listing the NFT on Opensea for a proposal-supplied price, it must first try to be auctioned off on Zora. To move from Zora stage to Opensea stage, _settleZoraAuction() is called when executing ListedOnZora step in ListOnOpenseaProposal.sol. If the function returns false, the next step is executed which lists the item on Opensea. It is assumed that if majority attack proposal reaches this stage, it can steal the NFT for free, because it can list the item for negligible price and immediately purchase it from a contract that executes the Opensea proposal.\n\nIndeed, attacker can always make settleZoraAuction() return false. Looking at  the code:\n\n    try ZORA.endAuction(auctionId) {\n                // Check whether auction cancelled due to a failed transfer during\n                // settlement by seeing if we now possess the NFT.\n                if (token.safeOwnerOf(tokenId) == address(this)) {\n                    emit ZoraAuctionFailed(auctionId);\n                    return false;\n                }\n            } catch (bytes memory errData) {\n\nAs the comment already hints, an auction can be cancelled if the NFT transfer to the bidder fails. This is the relevant AuctionHouse code (endAuction):\n\n    {\n                // transfer the token to the winner and pay out the participants below\n                try IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), auctions[auctionId].bidder, auctions[auctionId].tokenId) {} catch {\n                    _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);\n                    _cancelAuction(auctionId);\n                    return;\n     }\n\nAs most NFTs inherit from OpenZeppelin's ERC721.sol code, safeTransferFrom will run:\n\n        function _safeTransfer(\n            address from,\n            address to,\n            uint256 tokenId,\n            bytes memory data\n        ) internal virtual {\n            _transfer(from, to, tokenId);\n            require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n        }\n\nSo, attacker can bid a very high amount on the NFT to ensure it is the winning bid. When AuctionHouse tries to send the NFT to attacker, the safeTransferFrom will fail because attack will not implement an ERC721Receiver. This will force the AuctionHouse to return the bid amount to the bidder and cancel the auction. Importantly, it will lead to a graceful return from endAuction(), which will make settleZoraAuction() return false and progress to the OpenSea stage.\n\n\nA majority attack can easily bypass Zora auction stage and steal the NFT from the party.\n\n\n1.  Pass a ListOnOpenseaProposal with a tiny list price and execute it\n2.  Create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. Call its bid() function\n3.  Wait for the auction to end ( timeout after the bid() call)\n4.  Create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. Call the attack function.\n\n",
                "Repair": "\n_settleZoraAuction is called from both ListOnZoraProposal and ListOnOpenseaProposal. If the auction was cancelled due to a failed transfer, as is described in the comment, we would like to handle it differently for each proposal type. For ListOnZoraProposal, it should indeed return false, in order to finish executing the proposal and not to hang the engine. For ListOnOpenseaProposal, the desired behavior is to *revert* in the case of a failed transfer. This is because the next stage is risky and defense against the mentioned attack is required. Therefore, pass a revertOnFail flag to _settleZoraAuction, which will be used like so:\n\n    // Check whether auction cancelled due to a failed transfer during\n    // settlement by seeing if we now possess the NFT.\n    if (token.safeOwnerOf(tokenId) == address(this)) {\n    \tif (revertOnFail) {\n    \t\trevert(\"Zora auction failed because of transfer to bidder\")\n    \t}\n               emit ZoraAuctionFailed(auctionId);\n               return false;\n    }\n\nmerklejerk (PartyDAO) confirmed and commented(https://github.com/code-423n4/2022-09-party-findings/issues/264#issuecomment-1255311135):\n  Great find. We will modify _settleZoraAuction() to return some auction status to be communicated up to the Opensea proposal.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-09-party-findings/issues/264#issuecomment-1262795619):\n  TIL. While digging into this I noticed that Zora changed this logic in their V3 implementation, avoiding this scenario but there may be reasons to prefer the auction house contract.\n \n Agree with High risk the auction safeguard can be bypassed, allowing a majority owner to steal from the rest of the party.\n\n0xble (PartyDAO) resolved(https://github.com/code-423n4/2022-09-party-findings/issues/264#issuecomment-1264680120):\n  Resolved: https://github.com/PartyDAO/partybidV2/pull/137\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [],
                "Type": " TokenDistributor: ERC777 tokensToSend hook can be exploited to drain contract",
                "Description": "\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L131\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L386\n\n\nTokenDistributor.createERC20Distribution can be used to create token distributions for ERC777 tokens (which are backwards-compatible with ERC20). However, this introduces a reentrancy vulnerability which allows a party to get the tokens of another party. The problem is the tokensToSend hook which is executed BEFORE balance updates happens (see <https://eips.ethereum.org/EIPS/eip-777). When this hook is executed, token.balanceOf(address(this)) therefore still returns the old value, but _storedBalances[balanceID] was already decreased.\n\n\nParty A and Party B have a balance of 1,000,000 tokens (of some arbitrary ERC777 token) in the distributor. Let's say for the sake of simplicity that both parties only have one user (user A in party A, user B in party B). User A (or rather his smart contract) performs the following attack:\n\n*   He calls claim, which transfers 1,000,000 tokens to his contract address. In _transfer, _storedBalances[balanceId] is decreased by 1,000,000 and therefore now has a value of 1,000,000.\n*   In the tokensToSend hook, he initiates another distribution for his party A by calling PartyGovernance.distribute which calls TokenDistributor.createERC20Distribution (we assume for the sake of simplicity that the party does not have more of these tokens, so the call transfers 0 tokens to the distributor). TokenDistributor.createERC20Distribution passes token.balanceOf(address(this)) to _createDistribution. Note that this is still 2,000,000 because we are in the tokensToSend hook.\n*   The supply of this distribution is calculated as (args.currentTokenBalance _storedBalances[balanceId]) = 2,000,000 1,000,000 = 1,000,000.\n*   When the tokensToSend hook is exited (and the first transfer has finished), he can retrieve the tokens of the second distribution (that was created in the hook) to steal the 1,000,000 tokens of party B.\n\n",
                "Repair": "\nDo not allow reentrancy in these functions.\n\nmerklejerk (PartyDAO) confirmed and commented(https://github.com/code-423n4/2022-09-party-findings/issues/120#issuecomment-1254239231):\n  Very few legitimate ERC777s so we think the probability of this happening to a party is somewhat low. Also, it only impacts distributions for that token. However, we will be implementing a reentrancy guard to fix it.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-09-party-findings/issues/120#issuecomment-1262875715):\n  Agree that it does not seem very probable but if 777 assets are distributed, it does appear to be a way of stealing from other users in the party and therefore High risk.\n\n0xble (PartyDAO) resolved(https://github.com/code-423n4/2022-09-party-findings/issues/120#issuecomment-1264678026):\n  Resolved: https://github.com/PartyDAO/partybidV2/pull/132\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [],
                "Type": " ArbitraryCallsProposal.sol and ListOnOpenseaProposal.sol safeguards can be bypassed by cancelling in-progress proposal allowing the majority to steal NFT",
                "Description": "\nNote: PartyDAO acknowledges that \"canceling an InProgress proposal (mid-step) can leave the governance party in a vulnerable or undesirable state because there is no cleanup logic run during a cancel\" in the \"Known Issues / Topics\" section of the contest readme. I still believe that this vulnerability needs to be mitigated as it can directly lead to loss of user funds.\n\n\nMajority vote can abuse cancel functionality to steal an NFT owned by the party.\n\n\nArbitraryCallsProposal.sol implements the following safeguards for arbitrary proposals that are not unanimous:\n\n1.  Prevents the ownership of any NFT changing during the call. It does this by checking the the ownership of all NFTs before and after the call.\n\n2.  Prevents calls that would change the approval status of any NFT. This is done by disallowing the \"approve\" and \"setApprovalForAll\" function selectors.\n\nAdditionally ListOnOpenseaProposal.sol implements the following safeguards:\n\n1.  NFTs are first listed for auction on Zora so that if they are listed for a very low price then the auction will keep them from being purchased at such a low price.\n\n2.  At the end of the auction the approval is revoked when _cleanUpListing is called.\n\nThese safeguards are ultimately ineffective though. The majority could use the following steps to steal the NFT:\n\n1.  Create ListOnOpenseaProposal with high sell price and short cancel delay\n\n2.  Vote to approve proposal with majority vote\n\n3.  Execute first step of proposal, listing NFT on Zora auction for high price\n\n4.  Wait for Zora auction to end since the auction price is so high that no one will buy it\n\n5.  Execute next step, listing the NFT on Opensea. During this step the contract grants approval of the NFT to the Opensea contract\n\n6.  Wait for cancelDelay to expire\n\n7.  Call PartyGovernance.sol#cancel. This will immediately terminate the Opensea bypassing _cleanUpListing and keeping the approval to the Opensea contract.\n\n8.  Create ArbitraryCallsProposal.sol that lists the NFT on Opensea for virtually nothing. Since only approval selectors have been blacklisted and the NFT does not change ownership, the proposal does not need to be unanimous to execute.\n\n9.  Approve proposal and execute.\n\n10. Buy NFT.\n\n",
                "Repair": "\nWhen a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc.\n\nmerklejerk (PartyDAO) confirmed and commented(https://github.com/code-423n4/2022-09-party-findings/issues/153#issuecomment-1255135044):\n  We will block calls to opensea.validate() in Arbitrary call proposals.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-09-party-findings/issues/153#issuecomment-1262889443):\n  Agree with High risk in this scenario a majority owner could steal the asset from others in the party.\n\n0xble (PartyDAO) resolved(https://github.com/code-423n4/2022-09-party-findings/issues/153#issuecomment-1264688086):\n  Resolved: https://github.com/PartyDAO/partybidV2/pull/139\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [],
                "Type": "  A majority attack can steal precious NFT from the party by crafting and chaining two proposals",
                "Description": "\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L116\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/FractionalizeProposal.sol#L54-L62\n\n\nThe PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. Majority cannot exfiltrate the ETH gained from selling precious NFT via any proposal, and it's impossible to sell NFT for any asset except ETH. If the party were to be compensated via an ERC20 token, majority could pass an ArbitraryCallsProposal to transfer these tokens to an attacker wallet. Unfortunately, FractionalizeProposal is vulnerable to this attack. Attackers could pass two proposals and wait for them to be ready for execution. Firstly, a FractionalizeProposal to fractionalize the NFT and mint totalVotingPower amount of ERC20 tokens of the created vault. Secondly, an ArbitraryCallsProposal to transfer the entire ERC20 token supply to an attacker address. At this point, attacker can call vault.redeem() to burn the outstanding token supply and receive the NFT back.\n\n\nA 51% majority could steal the precious NFT from the party and leave it empty.\n\n\nThe only non-trivial component of this attack is that the created vault, whose tokens we wish to transfer out, has an undetermined address until VAULT_FACTORY.mint() is called, which creates it. The opcode which creates the vault contract is CREATE, which calculates the address with keccak256(VAULT_FACTORY, nonce). Nonce will keep changing while new, unrelated NFTs are fractionalized. The attack needs to prepare both FractionalizedProposal and ArbitraryCallsProposal ahead of time, so that they could be chained immediately, meaning there would be no time for other members to call distribute() on the party, which would store the fractionalized tokens safely in the distributor.\nIn order to solve this chicken and the egg problem, we will use a technique taken from traditional low-level exploitation called heap feng shui.\n\nFirstly, calculate off-chain, the rate new NFTs are fractionalized, and multiple by a safety factor (like 1.2X), and multiply again by the proposal execution delay. This number, added to the current VAULT_FACTORY nonce, will be our target_nonce. Calculate target_vault = keccak256(VAULT_FACTORY, target_nonce), before_target_vault = keccak256(VAULT_FACTORY, target_nonce-1)\n\nFirstly, we will create a contract which has an attack function that:\n\n1.  Loop while before_target_vault != created_vault:\n    \u2022 Mint new dummy attacker_NFT\n    \u2022 created_vault = VAULT_FACTORY.mint(attacker_NFT\u2026)\n2.  Call execute() on the FractionalizedProposal  // We will feed the execute() parameters to the contract in a separate contract setter. Note that this is guaranteed to create target_vault on the correct address.\n3.  Call execute() on the ArbitraryCallsProposal\n\nThen, we propose the two proposals:\n\n1.  Propose a FractionalizedProposal, with any list price and the precious NFT as parameter\n2.  Propose an ArbitraryCallsProposal, with target = target_vault, data = transfer(ATTACKER, totalVotingPower)\n\nThen, we set the execute() parameters passed in step 2 and 3 of the attack contract using the proposalID allocated for them.\n\nThen, we wait for execution delay to finish.\n\nFinally, run the attack() function prepared earlier. This will increment the VAULT_FACTORY nonce until it is the one we count on during the ArbitraryCallsProposal. Pass enough gas to be able to burn enough nonces.\n\nAt this point, attacker has all the vault tokens, so he may call vault.redeem() and receive the precious NFT.\n\n",
                "Repair": "\n1.  Enforce a minimum cooldown between proposals. This will mitigate additional weaknesses of the proposal structure. Here, this will give users the opportunity to call distribute() to put the vault tokens safe in distributor.\n2.  A specific fix here would be to call distribute() at the end of FractionalizeProposal so that there is no window to steal the funds.\n\nmerklejerk (PartyDAO) confirmed and commented(https://github.com/code-423n4/2022-09-party-findings/issues/277#issuecomment-1254233443):\n  Will fix by creating an automatic distribution at the end of a successful fractionalize proposal.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-09-party-findings/issues/277#issuecomment-1263543589):\n  Agree with High risk this scenario allows a majority owner to steal from others in the party.\n\n0xble (PartyDAO) resolved(https://github.com/code-423n4/2022-09-party-findings/issues/277#issuecomment-1264677841):\n  Resolved: https://github.com/PartyDAO/partybidV2/pull/131\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [],
                "Type": " Attacker can DOS private party by donating ETH then calling buy",
                "Description": "\nParty is DOS'd and may potentially lose access to NFT.\n\n\nCrowdfund.sol#L280-L298(https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L280-L298)\n\n    party = party_ = partyFactory\n        .createParty(\n            address(this),\n            Party.PartyOptions({\n                name: name,\n                symbol: symbol,\n                governance: PartyGovernance.GovernanceOpts({\n                    hosts: governanceOpts.hosts,\n                    voteDuration: governanceOpts.voteDuration,\n                    executionDelay: governanceOpts.executionDelay,\n                    passThresholdBps: governanceOpts.passThresholdBps,\n                    totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\n                    feeBps: governanceOpts.feeBps,\n                    feeRecipient: governanceOpts.feeRecipient\n                })\n            }),\n            preciousTokens,\n            preciousTokenIds\n        );\n\nBuyCrowdfundBase.sol#L166-L173(https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L166-L173)\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256)\n    {\n        return settledPrice;\n    }\n\nWhen BuyCrowdFund.sol successfully completes a buy, totalVotingPower is set to _getFinalPrice which in the case of BuyCrowdFundBase.sol returns the price at which the NFT was purchased. totalVotingPower is used by the governance contract to determine the number of votes needed for a proposal to pass. If there are not enough claimable votes to meet that threshold then the party is softlocked because it can't pass any proposals. An attacker could exploit this to DOS even a private party with the following steps:\n\n1.  Wait for party to be filled to just under quorum threshold\n2.  Donate ETH to the crowdfund contract\n3.  Call BuyCrowdFund.sol#buy. Since it is unpermissioned even for parties with a gatekeeper, the call won't revert\n\nSince the voting power for the final amount of ETH cannot be claimed, the party is now softlocked. If emergencyExecuteDisabled is true then the party will be permanantly locked and the NFT would effectively be burned. If emergencyExecuteDisabled is false then users would have to wait for PartyDAO to reclaim the NFT.\n\n",
                "Repair": "\nPermission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper.\n\nmerklejerk (PartyDAO) confirmed and commented(https://github.com/code-423n4/2022-09-party-findings/issues/196#issuecomment-1255178995):\n  Theoretically possible but there doesn't seem to be much upside for the attacker. We do think it's unusual that buy()/bid() can be called by a non-member for a private/gatekept party, so we will add gatekeeping logic there to fix this. We will also cap the callValue (and therefore final price) to totalContributions.\n\n0xble (PartyDAO) resolved(https://github.com/code-423n4/2022-09-party-findings/issues/196#issuecomment-1264679039):\n  Resolved: https://github.com/PartyDAO/partybidV2/pull/133\n\nHardlyDifficult (judge) increased severity to High and commented(https://github.com/code-423n4/2022-09-party-findings/issues/196#issuecomment-1266670432):\n  Although it's without upside, it is a path for the attacker to potentially lock the NFT. Since it can cause a loss of asset for users, this seems to be a High risk issue.\n \n Let me know if I misunderstood.\n\nmerklejerk (PartyDAO) commented(https://github.com/code-423n4/2022-09-party-findings/issues/196#issuecomment-1267180017):\n  ~Don't consider it high because there is a much more straightforward way to softlock a party: contribute normally and don't ever participate in governance.~ Oh nvm, this is the private party one. Yeah I'm fine with high.\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]