[
    {
        "PdfName": "ADAMoracle (Mining)_audit.pdf",
        "Code": [
            "pragma solidity 0.6.12; \n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/math/SafeMath.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \n \ncontract AdamMasterPool is Ownable { \n    using SafeMath for uint256; \n    using SafeERC20 for IERC20; \n \n    // \u7528\u6237\u4fe1\u606f \n    struct UserInfo { \n        uint256 amount; // How many LP tokens the user has provided. \n        uint256 rewardDebt; // Reward debt. See explanation below. \n    } \n \n    // \u6c60\u5b50\u4fe1\u606f \n    struct PoolInfo { \n        IERC20 lpToken; // Address of LP token contract. \n        uint256 lastRewardBlock;  // Last block number that CAKEs distribution occurs. \n        uint256 accAdamPerShare; // Accumulated adam per share \n        uint256 maxStaking; \n        uint256 rewardPerBlock; \n        address[] accounts; \n    } \n \n    // \u6c60\u5b50\u4fe1\u606f\u6570\u7ec4 \n    PoolInfo[] public poolInfo; \n \n    address[] internal totalAccounts; \n \n    mapping (address => bool) internal Wallets; \n \n    // \u6c60\u5b50ID=>\u7528\u6237\u5730\u5740=>\u7528\u6237\u4fe1\u606f \u7684\u6620\u5c04 \n    mapping(uint256 => mapping(address => UserInfo)) public userInfo; \n \n    // The CAKE TOKEN! \n    IERC20 public rewardToken; \n \n    // The block number when ADAM mining starts. \n    uint256 public startBlock; \n \n    // The block number when ADAM mining ends. \n    uint256 public bonusEndBlock; \n \n    uint256 public decimal; \n \n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount); \n    event Harvest(address indexed user, uint256 indexed pid, uint256 amount); \n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount); \n    event EmergencyWithdraw( \n        address indexed user, \n        uint256 indexed pid, \n        uint256 amount \n    ); \n \n    constructor(IERC20 _rewardToken, \n        uint256 _startBlock, \n        uint256 _bonusEndBlock) public  { \n        startBlock = _startBlock; \n        bonusEndBlock = _bonusEndBlock; \n        rewardToken = _rewardToken; \n        decimal = 10**10; \n    } \n \n \n    //add lpToken for pool \n    function add( \n        IERC20 _lpToken, \n        uint256 _maxStaking \n    ) public onlyOwner{ \n        poolInfo.push( \n            PoolInfo({ \n            lpToken: _lpToken, \n            lastRewardBlock: startBlock, \n            accAdamPerShare: 0, \n            maxStaking:_maxStaking, \n            rewardPerBlock:856110000000000000, \n            accounts:totalAccounts \n            }) \n        ); \n \n    } \n \n    // Return reward multiplier over the given _from to _to block. \n    function getMultiplier(uint256 _from, uint256 _to) \n    public \n    view \n    returns (uint256) \n    { \n        if (_to <= bonusEndBlock) { \n            return _to.sub(_from); \n        } else if (_from >= bonusEndBlock) { \n            return 0; \n        } else { \n            return bonusEndBlock.sub(_from); \n        } \n    } \n \n    // Update reward variables of the given pool to be up-to-date. \n    function updatePool(uint256 _pid) internal { \n        PoolInfo storage pool = poolInfo[_pid]; \n        if (block.number <= pool.lastRewardBlock) { \n            return; \n        } \n        uint256 lpSupply = pool.lpToken.balanceOf(address(this)); \n        if (lpSupply == 0) { \n            pool.lastRewardBlock = block.number; \n            return; \n        } \n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); \n        uint256 adamReward = multiplier.mul(pool.rewardPerBlock); \n        pool.accAdamPerShare = pool.accAdamPerShare.add( \n            adamReward.mul(1e12).div(lpSupply) \n        ); \n \n        pool.lastRewardBlock = block.number; \n    } \n \n    // View function to see pending Reward on frontend. \n    function pendingADAM(uint256 _pid, address _user) \n    public \n    view \n    returns (uint256) \n    { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][_user]; \n        uint256 accAdamPerShare = pool.accAdamPerShare; \n        uint256 lpSupply = pool.lpToken.balanceOf(address(this)); \n \n        if (block.number > pool.lastRewardBlock && lpSupply != 0) { \n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); \n            uint256 adamReward = multiplier.mul(pool.rewardPerBlock); \n            accAdamPerShare = accAdamPerShare.add( \n                adamReward.mul(1e12).div(lpSupply) \n            ); \n        } \n        return user.amount.mul(accAdamPerShare).div(1e12).div(decimal).sub(user.rewardDebt); \n    } \n \n \n    // Deposit LP tokens to AdamRewardPool for ADAM allocation. \n    function deposit(uint256 _pid, uint256 _amount) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n \n        updatePool(_pid); \n        if (user.amount > 0) { \n            uint256 pending = \n            user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal).sub( \n                user.rewardDebt \n            ); \n            if (pending > 0) { \n                rewardToken.safeTransfer(address(msg.sender), pending); \n            } \n        } \n \n        if (_amount > 0) { \n            pool.lpToken.safeTransferFrom( \n                address(msg.sender), \n                address(this), \n                _amount \n            ); \n            user.amount = user.amount.add(_amount); \n        } \n        user.rewardDebt = user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal); \n \n        if (contains(msg.sender) == false){ \n            pool.accounts.push(msg.sender); \n            totalAccounts.push(msg.sender); \n            setWallet(msg.sender); \n        } \n \n        emit Deposit(msg.sender, _pid, _amount); \n    } \n \n \n    // harvest ADAM tokens from AdamRewardPool. \n    function harvest(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        require(user.amount >= 0, \"harvest: not good\"); \n        updatePool(_pid); \n        uint256 pending = \n        user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal).sub( \n            user.rewardDebt \n        ); \n        if (pending > 0) { \n            rewardToken.safeTransfer(address(msg.sender), pending); \n        } \n \n        user.rewardDebt = user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal); \n \n        emit Harvest(msg.sender, _pid, pending); \n    } \n \n \n    // Withdraw LP tokens from AdamRewardPool. \n    function exit(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        require(user.amount >= 0, \"withdraw: not good\"); \n        updatePool(_pid); \n        uint256 pending = \n        user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal).sub( \n            user.rewardDebt \n        ); \n        if (pending > 0) { \n            rewardToken.safeTransfer(address(msg.sender), pending); \n        } \n \n        uint256 _amount = user.amount; \n        if (_amount > 0) { \n            user.amount = 0; \n            pool.lpToken.safeTransfer(address(msg.sender), _amount); \n        } \n        user.rewardDebt = user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal); \n \n        emit Withdraw(msg.sender, _pid, _amount); \n    } \n \n    // Withdraw without caring about rewards. EMERGENCY ONLY. \n    function emergencyWithdraw(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        uint256 _amount = user.amount; \n        pool.lpToken.safeTransfer(address(msg.sender), user.amount); \n        user.amount = 0; \n        user.rewardDebt = 0; \n        emit EmergencyWithdraw(msg.sender, _pid, _amount); \n    } \n \n \n    // Withdraw reward. EMERGENCY ONLY. \n    function emergencyRewardWithdraw(uint256 _amount) public onlyOwner { \n        require( \n            _amount < rewardToken.balanceOf(address(this)), \n            \"not enough token\" \n        ); \n \n        rewardToken.safeTransfer(address(msg.sender), _amount); \n    } \n \n    function poolLength() external view returns (uint256) { \n        return poolInfo.length; \n    } \n \n    function setMaxStaking( \n        uint256 _pid, \n        uint256 _maxStaking \n    ) public onlyOwner { \n        poolInfo[_pid].maxStaking = _maxStaking; \n    } \n \n \n    function stopReward() public onlyOwner { \n        bonusEndBlock = block.number; \n    } \n \n    //set bounus end bolck \n    function setBonusEndBlock(uint256 _bonusEndBlock) public onlyOwner { \n        bonusEndBlock = _bonusEndBlock; \n    } \n \n    //set reward per bolck \n    function setRewardPerBlock(uint256 _pid, uint256 _rewardPerBlock) public onlyOwner { \n        PoolInfo storage pool = poolInfo[_pid]; \n        pool.rewardPerBlock = _rewardPerBlock; \n    } \n \n    //get lp token supply \n    function getLpSupply(uint256 _pid)  external view returns (uint256) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        uint256 lpSupply = pool.lpToken.balanceOf(address(this)); \n        return lpSupply; \n    } \n \n    function getBlockNum()  public view onlyOwner returns (uint256) { \n        uint256 blNum = block.number; \n        return blNum; \n    } \n \n    function getAccounts()  public view onlyOwner returns (address[] memory) { \n        return totalAccounts; \n    } \n \n    function getAccountsLength()  public view onlyOwner returns (uint256) { \n        return totalAccounts.length; \n    } \n \n    function getPoolAccounts(uint256 _pid)  public view onlyOwner returns (address[] memory) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        return pool.accounts; \n    } \n \n    function getPoolAccountsLength(uint256 _pid)  public view onlyOwner returns (uint256) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        return pool.accounts.length; \n    } \n \n    function setWallet(address _wallet) internal{ \n        Wallets[_wallet] = true; \n    } \n \n    function contains(address _wallet) internal view returns (bool){ \n        return Wallets[_wallet]; \n    } \n \n} \n \n \n",
            "pragma solidity 0.6.12; \n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/math/SafeMath.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \n \ncontract AdamRewardPool is Ownable { \n    using SafeMath for uint256; \n    using SafeERC20 for IERC20; \n \n    // \u7528\u6237\u4fe1\u606f \n    struct UserInfo { \n        uint256 amount; // How many LP tokens the user has provided. \n        uint256 rewardDebt; // Reward debt. See explanation below. \n    } \n \n    // \u6c60\u5b50\u4fe1\u606f \n    struct PoolInfo { \n        IERC20 lpToken; // Address of LP token contract. \n        uint256 lastRewardBlock;  // Last block number that CAKEs distribution occurs. \n        uint256 accAdamPerShare; // Accumulated adam per share \n        uint256 maxStaking; \n        uint256 lpSupply; \n        uint256 rewardPerBlock; \n        address[] accounts; \n    } \n \n    // \u6c60\u5b50\u4fe1\u606f\u6570\u7ec4 \n    PoolInfo[] public poolInfo; \n \n    address[] internal totalAccounts; \n \n    mapping (address => bool) internal Wallets; \n \n    // \u6c60\u5b50ID=>\u7528\u6237\u5730\u5740=>\u7528\u6237\u4fe1\u606f \u7684\u6620\u5c04 \n    mapping(uint256 => mapping(address => UserInfo)) public userInfo; \n \n    // The CAKE TOKEN! \n    IERC20 public rewardToken; \n \n    // The block number when ADAM mining starts. \n    uint256 public startBlock; \n \n    // The block number when ADAM mining ends. \n    uint256 public bonusEndBlock; \n \n    uint256 public decimal; \n \n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount); \n    event Harvest(address indexed user, uint256 indexed pid, uint256 amount); \n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount); \n    event EmergencyWithdraw( \n        address indexed user, \n        uint256 indexed pid, \n        uint256 amount \n    ); \n \n    constructor(IERC20 _rewardToken, \n        uint256 _startBlock, \n        uint256 _bonusEndBlock) public  { \n        startBlock = _startBlock; \n        bonusEndBlock = _bonusEndBlock; \n        rewardToken = _rewardToken; \n        decimal = 10**10; \n    } \n \n \n    //add lpToken for pool \n    function add( \n        IERC20 _lpToken, \n        uint256 _maxStaking \n    ) public onlyOwner{ \n        poolInfo.push( \n            PoolInfo({ \n            lpToken: _lpToken, \n            lastRewardBlock: startBlock, \n            accAdamPerShare: 0, \n            lpSupply: 0, \n            maxStaking:_maxStaking, \n            rewardPerBlock:85611000000000000, \n            accounts:totalAccounts \n            }) \n        ); \n \n    } \n \n    // Return reward multiplier over the given _from to _to block. \n    function getMultiplier(uint256 _from, uint256 _to) \n    public \n    view \n    returns (uint256) \n    { \n        if (_to <= bonusEndBlock) { \n            return _to.sub(_from); \n        } else if (_from >= bonusEndBlock) { \n            return 0; \n        } else { \n            return bonusEndBlock.sub(_from); \n        } \n    } \n \n    // Update reward variables of the given pool to be up-to-date. \n    function updatePool(uint256 _pid) internal { \n        PoolInfo storage pool = poolInfo[_pid]; \n        if (block.number <= pool.lastRewardBlock) { \n            return; \n        } \n        // uint256 lpSupply = pool.lpToken.balanceOf(address(this)); \n        if (pool.lpSupply == 0) { \n            pool.lastRewardBlock = block.number; \n            return; \n        } \n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); \n        uint256 adamReward = multiplier.mul(pool.rewardPerBlock); \n \n        pool.accAdamPerShare = pool.accAdamPerShare.add( \n            adamReward.mul(1e12).div(pool.lpSupply) \n        ); \n \n \n        pool.lastRewardBlock = block.number; \n    } \n \n    // View function to see pending Reward on frontend. \n    function pendingADAM(uint256 _pid, address _user) \n    public \n    view \n    returns (uint256) \n    { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][_user]; \n        uint256 accAdamPerShare = pool.accAdamPerShare; \n        uint256 adamReward = 0; \n        if (block.number > pool.lastRewardBlock && pool.lpSupply != 0) { \n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); \n            adamReward = multiplier.mul(pool.rewardPerBlock); \n            accAdamPerShare = accAdamPerShare.add( \n                adamReward.mul(1e12).div(pool.lpSupply) \n            ); \n        } \n        return user.amount.mul(accAdamPerShare).div(1e12).div(decimal).sub(user.rewardDebt); \n    } \n \n \n    // Deposit LP tokens to AdamRewardPool for ADAM allocation. \n    function deposit(uint256 _pid, uint256 _amount) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n \n        updatePool(_pid); \n        if (user.amount > 0) { \n            uint256 pending = \n            user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal).sub( \n                user.rewardDebt \n            ); \n            if (pending > 0) { \n                rewardToken.safeTransfer(address(msg.sender), pending); \n            } \n        } \n \n        if (_amount > 0) { \n            pool.lpToken.safeTransferFrom( \n                address(msg.sender), \n                address(this), \n                _amount \n            ); \n            user.amount = user.amount.add(_amount); \n            pool.lpSupply = pool.lpSupply.add(_amount); \n \n        } \n        user.rewardDebt = user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal); \n \n        if (contains(msg.sender) == false){ \n            pool.accounts.push(msg.sender); \n            totalAccounts.push(msg.sender); \n            setWallet(msg.sender); \n        } \n \n        emit Deposit(msg.sender, _pid, _amount); \n    } \n \n \n    // harvest ADAM tokens from AdamRewardPool. \n    function harvest(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        require(user.amount >= 0, \"harvest: not good\"); \n        updatePool(_pid); \n        uint256 pending = \n        user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal).sub( \n            user.rewardDebt \n        ); \n        if (pending > 0) { \n            rewardToken.safeTransfer(address(msg.sender), pending); \n        } \n \n        user.rewardDebt = user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal); \n \n        emit Harvest(msg.sender, _pid, pending); \n    } \n \n \n    // Withdraw LP tokens from AdamRewardPool. \n    function exit(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        require(user.amount >= 0, \"withdraw: not good\"); \n        updatePool(_pid); \n        uint256 pending = \n        user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal).sub( \n            user.rewardDebt \n        ); \n        if (pending > 0) { \n            rewardToken.safeTransfer(address(msg.sender), pending); \n        } \n \n        uint256 _amount = user.amount; \n        if (_amount > 0) { \n            user.amount = 0; \n            pool.lpToken.safeTransfer(address(msg.sender), _amount); \n            pool.lpSupply = pool.lpSupply.sub(_amount); \n        } \n        user.rewardDebt = user.amount.mul(pool.accAdamPerShare).div(1e12).div(decimal); \n \n        emit Withdraw(msg.sender, _pid, _amount); \n    } \n \n    // Withdraw without caring about rewards. EMERGENCY ONLY. \n    function emergencyWithdraw(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        uint256 _amount = user.amount; \n        pool.lpToken.safeTransfer(address(msg.sender), user.amount); \n        user.amount = 0; \n        user.rewardDebt = 0; \n        emit EmergencyWithdraw(msg.sender, _pid, _amount); \n    } \n \n \n    // Withdraw reward. EMERGENCY ONLY. \n    function emergencyRewardWithdraw(uint256 _amount) public onlyOwner { \n        require( \n            _amount < rewardToken.balanceOf(address(this)), \n            \"not enough token\" \n        ); \n \n        rewardToken.safeTransfer(address(msg.sender), _amount); \n    } \n \n    function poolLength() external view returns (uint256) { \n        return poolInfo.length; \n    } \n \n    function setMaxStaking( \n        uint256 _pid, \n        uint256 _maxStaking \n    ) public onlyOwner { \n        poolInfo[_pid].maxStaking = _maxStaking; \n    } \n \n \n    function stopReward() public onlyOwner { \n        bonusEndBlock = block.number; \n    } \n \n    //set bounus end bolck \n    function setBonusEndBlock(uint256 _bonusEndBlock) public onlyOwner { \n        bonusEndBlock = _bonusEndBlock; \n    } \n \n    //set reward per bolck \n    function setRewardPerBlock(uint256 _pid, uint256 _rewardPerBlock) public onlyOwner { \n        PoolInfo storage pool = poolInfo[_pid]; \n        pool.rewardPerBlock = _rewardPerBlock; \n    } \n \n    //get lp token supply \n    function getLpSupply(uint256 _pid)  external view returns (uint256) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        uint256 lpSupply = pool.lpToken.balanceOf(address(this)); \n        return lpSupply; \n    } \n \n \n    function getBlockNum()  public view onlyOwner returns (uint256) { \n        uint256 blNum = block.number; \n        return blNum; \n    } \n \n    function getAccounts()  public view onlyOwner returns (address[] memory) { \n        return totalAccounts; \n    } \n \n    function getAccountsLength()  public view onlyOwner returns (uint256) { \n        return totalAccounts.length; \n    } \n \n    function getPoolAccounts(uint256 _pid)  public view onlyOwner returns (address[] memory) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        return pool.accounts; \n    } \n \n    function getPoolAccountsLength(uint256 _pid)  public view onlyOwner returns (uint256) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        return pool.accounts.length; \n    } \n \n    function setWallet(address _wallet) internal{ \n        Wallets[_wallet] = true; \n    } \n \n    function contains(address _wallet) internal view returns (bool){ \n        return Wallets[_wallet]; \n    } \n \n} \n \n \n"
        ]
    },
    {
        "PdfName": "BALA_audit.pdf",
        "Code": [
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {StableDebtToken} from '../protocol/tokenization/StableDebtToken.sol'; \nimport {VariableDebtToken} from '../protocol/tokenization/VariableDebtToken.sol'; \nimport {LendingRateOracle} from '../mocks/oracle/LendingRateOracle.sol'; \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {StringLib} from './StringLib.sol'; \n \ncontract StableAndVariableTokensHelper is Ownable { \n  address payable private pool; \n  address private addressesProvider; \n  event deployedContracts(address stableToken, address variableToken); \n \n  constructor(address payable _pool, address _addressesProvider) public { \n    pool = _pool; \n    addressesProvider = _addressesProvider; \n  } \n \n  function initDeployment(address[] calldata tokens, string[] calldata symbols) external onlyOwner { \n    require(tokens.length == symbols.length, 'Arrays not same length'); \n    require(pool != address(0), 'Pool can not be zero address'); \n    for (uint256 i = 0; i < tokens.length; i++) { \n      emit deployedContracts(address(new StableDebtToken()), address(new VariableDebtToken())); \n    } \n  } \n \n  function setOracleBorrowRates( \n    address[] calldata assets, \n    uint256[] calldata rates, \n    address oracle \n  ) external onlyOwner { \n    require(assets.length == rates.length, 'Arrays not same length'); \n \n    for (uint256 i = 0; i < assets.length; i++) { \n      // LendingRateOracle owner must be this contract \n      LendingRateOracle(oracle).setMarketBorrowRate(assets[i], rates[i]); \n    } \n  } \n \n  function setOracleOwnership(address oracle, address admin) external onlyOwner { \n    require(admin != address(0), 'owner can not be zero'); \n    require(LendingRateOracle(oracle).owner() == address(this), 'helper is not owner'); \n    LendingRateOracle(oracle).transferOwnership(admin); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nlibrary StringLib { \n  function concat(string memory a, string memory b) internal pure returns (string memory) { \n    return string(abi.encodePacked(a, b)); \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {LendingPool} from '../protocol/lendingpool/LendingPool.sol'; \nimport { \n  LendingPoolAddressesProvider \n} from '../protocol/configuration/LendingPoolAddressesProvider.sol'; \nimport {LendingPoolConfigurator} from '../protocol/lendingpool/LendingPoolConfigurator.sol'; \nimport {AToken} from '../protocol/tokenization/AToken.sol'; \nimport { \n  DefaultReserveInterestRateStrategy \n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol'; \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {StringLib} from './StringLib.sol'; \n \ncontract ATokensAndRatesHelper is Ownable { \n  address payable private pool; \n  address private addressesProvider; \n  address private poolConfigurator; \n  event deployedContracts(address aToken, address strategy); \n \n  struct InitDeploymentInput { \n    address asset; \n    uint256[6] rates; \n  } \n \n  struct ConfigureReserveInput { \n    address asset; \n    uint256 baseLTV; \n    uint256 liquidationThreshold; \n    uint256 liquidationBonus; \n    uint256 reserveFactor; \n    bool stableBorrowingEnabled; \n  } \n \n  constructor( \n    address payable _pool, \n    address _addressesProvider, \n    address _poolConfigurator \n  ) public { \n    pool = _pool; \n    addressesProvider = _addressesProvider; \n    poolConfigurator = _poolConfigurator; \n  } \n \n  function initDeployment(InitDeploymentInput[] calldata inputParams) external onlyOwner { \n    for (uint256 i = 0; i < inputParams.length; i++) { \n      emit deployedContracts( \n        address(new AToken()), \n        address( \n          new DefaultReserveInterestRateStrategy( \n            LendingPoolAddressesProvider(addressesProvider), \n            inputParams[i].rates[0], \n            inputParams[i].rates[1], \n            inputParams[i].rates[2], \n            inputParams[i].rates[3], \n            inputParams[i].rates[4], \n            inputParams[i].rates[5] \n          ) \n        ) \n      ); \n    } \n  } \n \n  function configureReserves(ConfigureReserveInput[] calldata inputParams) external onlyOwner { \n    LendingPoolConfigurator configurator = LendingPoolConfigurator(poolConfigurator); \n    for (uint256 i = 0; i < inputParams.length; i++) { \n      configurator.configureReserveAsCollateral( \n        inputParams[i].asset, \n        inputParams[i].baseLTV, \n        inputParams[i].liquidationThreshold, \n        inputParams[i].liquidationBonus \n      ); \n \n      configurator.enableBorrowingOnReserve( \n        inputParams[i].asset, \n        inputParams[i].stableBorrowingEnabled \n      ); \n      configurator.setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor); \n    } \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol'; \nimport {IInitializableAToken} from './IInitializableAToken.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken { \n  /** \n   * @dev Emitted after the mint action \n   * @param from The address performing the mint \n   * @param value The amount being \n   * @param index The new liquidity index of the reserve \n   **/ \n  event Mint(address indexed from, uint256 value, uint256 index); \n \n  /** \n   * @dev Mints `amount` aTokens to `user` \n   * @param user The address receiving the minted tokens \n   * @param amount The amount of tokens getting minted \n   * @param index The new liquidity index of the reserve \n   * @return `true` if the the previous balance of the user was 0 \n   */ \n  function mint( \n    address user, \n    uint256 amount, \n    uint256 index \n  ) external returns (bool); \n \n  /** \n   * @dev Emitted after aTokens are burned \n   * @param from The owner of the aTokens, getting them burned \n   * @param target The address that will receive the underlying \n   * @param value The amount being burned \n   * @param index The new liquidity index of the reserve \n   **/ \n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index); \n \n  /** \n   * @dev Emitted during the transfer action \n   * @param from The user whose tokens are being transferred \n   * @param to The recipient \n   * @param value The amount being transferred \n   * @param index The new liquidity index of the reserve \n   **/ \n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index); \n \n  /** \n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnder\n   * @param user The owner of the aTokens, getting them burned \n   * @param receiverOfUnderlying The address that will receive the underlying \n   * @param amount The amount being burned \n   * @param index The new liquidity index of the reserve \n   **/ \n  function burn( \n    address user, \n    address receiverOfUnderlying, \n    uint256 amount, \n    uint256 index \n  ) external; \n \n  /** \n   * @dev Mints aTokens to the reserve treasury \n   * @param amount The amount of tokens getting minted \n   * @param index The new liquidity index of the reserve \n   */ \n  function mintToTreasury(uint256 amount, uint256 index) external; \n \n  /** \n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclai\n   * @param from The address getting liquidated, current owner of the aTokens \n   * @param to The recipient \n   * @param value The amount of tokens getting transferred \n   **/ \n  function transferOnLiquidation( \n    address from, \n    address to, \n    uint256 value \n  ) external; \n \n  /** \n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer \n   * assets in borrow(), withdraw() and flashLoan() \n   * @param user The recipient of the underlying \n   * @param amount The amount getting transferred \n   * @return The amount transferred \n   **/ \n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256); \n \n  /** \n   * @dev Invoked to execute actions on the aToken side after a repayment. \n   * @param user The user executing the repayment \n   * @param amount The amount getting repaid \n   **/ \n  function handleRepayment(address user, uint256 amount) external; \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view returns (IAaveIncentivesController); \n \n  /** \n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   **/ \n  function UNDERLYING_ASSET_ADDRESS() external view returns (address); \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol'; \nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IStableDebtToken \n * @notice Defines the interface for the stable debt token \n * @dev It does not inherit from IERC20 to save in code size \n * @author Aave \n **/ \n \ninterface IStableDebtToken is IScaledBalanceToken,IInitializableDebtToken { \n  /** \n   * @dev Emitted when new stable debt is minted \n   * @param user The address of the user who triggered the minting \n   * @param onBehalfOf The recipient of stable debt tokens \n   * @param amount The amount minted \n   * @param currentBalance The current balance of the user \n   * @param balanceIncrease The increase in balance since the last action of the user \n   * @param newRate The rate of the debt after the minting \n   * @param avgStableRate The new average stable rate after the minting \n   * @param newTotalSupply The new total supply of the stable debt token after the action \n   **/ \n  event Mint( \n    address indexed user, \n    address indexed onBehalfOf, \n    uint256 amount, \n    uint256 currentBalance, \n    uint256 balanceIncrease, \n    uint256 newRate, \n    uint256 avgStableRate, \n    uint256 newTotalSupply \n  ); \n \n  /** \n   * @dev Emitted when new stable debt is burned \n   * @param user The address of the user \n   * @param amount The amount being burned \n   * @param currentBalance The current balance of the user \n   * @param balanceIncrease The the increase in balance since the last action of the user \n   * @param avgStableRate The new average stable rate after the burning \n   * @param newTotalSupply The new total supply of the stable debt token after the action \n   **/ \n  event Burn( \n    address indexed user, \n    uint256 amount, \n    uint256 currentBalance, \n    uint256 balanceIncrease, \n    uint256 avgStableRate, \n    uint256 newTotalSupply \n  ); \n \n  /** \n   * @dev Mints debt token to the `onBehalfOf` address. \n   * - The resulting rate is the weighted average between the rate of the new debt \n   * and the rate of the previous debt \n   * @param user The address receiving the borrowed underlying, being the delegatee in case \n   * of credit delegate, or same as `onBehalfOf` otherwise \n   * @param onBehalfOf The address receiving the debt tokens \n   * @param amount The amount of debt tokens to mint \n   * @param rate The rate of the debt being minted \n   **/ \n  function mint( \n    address user, \n    address onBehalfOf, \n    uint256 amount, \n    uint256 rate \n  ) external returns (bool); \n \n  /** \n   * @dev Burns debt of `user` \n   * - The resulting rate is the weighted average between the rate of the new debt \n   * and the rate of the previous debt \n   * @param user The address of the user getting his debt burned \n   * @param amount The amount of debt tokens getting burned \n   **/ \n  function burn(address user, uint256 amount) external; \n \n  /** \n   * @dev Returns the average rate of all the stable rate loans. \n   * @return The average stable rate \n   **/ \n  function getAverageStableRate() external view returns (uint256); \n \n  /** \n   * @dev Returns the stable rate of the user debt \n   * @return The stable rate of the user \n   **/ \n  function getUserStableRate(address user) external view returns (uint256); \n \n  /** \n   * @dev Returns the timestamp of the last update of the user \n   * @return The timestamp \n   **/ \n  function getUserLastUpdated(address user) external view returns (uint40); \n \n  /** \n   * @dev Returns the principal, the total supply and the average stable rate \n   **/ \n  function getSupplyData() \n    external \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint40 \n    ); \n \n  /** \n   * @dev Returns the timestamp of the last update of the total supply \n   * @return The timestamp \n   **/ \n  function getTotalSupplyLastUpdated() external view returns (uint40); \n \n  /** \n   * @dev Returns the total supply and the average stable rate \n   **/ \n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256); \n \n  /** \n   * @dev Returns the principal debt balance of the user \n   * @return The debt balance of the user since the last burn/mint action \n   **/ \n  function principalBalanceOf(address user) external view returns (uint256); \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view returns (IAaveIncentivesController); \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \ninterface ILendingPoolConfigurator { \n  struct InitReserveInput { \n    address aTokenImpl; \n    address stableDebtTokenImpl; \n    address variableDebtTokenImpl; \n    uint8 underlyingAssetDecimals; \n    address interestRateStrategyAddress; \n    address underlyingAsset; \n    address treasury; \n    address incentivesController; \n    string underlyingAssetName; \n    string aTokenName; \n    string aTokenSymbol; \n    string variableDebtTokenName; \n    string variableDebtTokenSymbol; \n    string stableDebtTokenName; \n    string stableDebtTokenSymbol; \n    bytes params; \n  } \n \n  struct UpdateATokenInput { \n    address asset; \n    address treasury; \n    address incentivesController; \n    string name; \n    string symbol; \n    address implementation; \n    bytes params; \n  } \n \n  struct UpdateDebtTokenInput { \n    address asset; \n    address incentivesController; \n    string name; \n    string symbol; \n    address implementation; \n    bytes params; \n  } \n \n  /** \n   * @dev Emitted when a reserve is initialized. \n   * @param asset The address of the underlying asset of the reserve \n   * @param aToken The address of the associated aToken contract \n   * @param stableDebtToken The address of the associated stable rate debt token \n   * @param variableDebtToken The address of the associated variable rate debt token \n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve \n   **/ \n  event ReserveInitialized( \n    address indexed asset, \n    address indexed aToken, \n    address stableDebtToken, \n    address variableDebtToken, \n    address interestRateStrategyAddress \n  ); \n \n  /** \n   * @dev Emitted when borrowing is enabled on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @param stableRateEnabled True if stable rate borrowing is enabled, false otherwise \n   **/ \n  event BorrowingEnabledOnReserve(address indexed asset, bool stableRateEnabled); \n \n  /** \n   * @dev Emitted when borrowing is disabled on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event BorrowingDisabledOnReserve(address indexed asset); \n \n  /** \n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated. \n   * @param asset The address of the underlying asset of the reserve \n   * @param ltv The loan to value of the asset when used as collateral \n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be \n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset \n   **/ \n  event CollateralConfigurationChanged( \n    address indexed asset, \n    uint256 ltv, \n    uint256 liquidationThreshold, \n    uint256 liquidationBonus \n  ); \n \n  /** \n   * @dev Emitted when stable rate borrowing is enabled on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event StableRateEnabledOnReserve(address indexed asset); \n \n  /** \n   * @dev Emitted when stable rate borrowing is disabled on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event StableRateDisabledOnReserve(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve is activated \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event ReserveActivated(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve is deactivated \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event ReserveDeactivated(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve is frozen \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event ReserveFrozen(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve is unfrozen \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event ReserveUnfrozen(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve factor is updated \n   * @param asset The address of the underlying asset of the reserve \n   * @param factor The new reserve factor \n   **/ \n  event ReserveFactorChanged(address indexed asset, uint256 factor); \n \n  /** \n   * @dev Emitted when the reserve decimals are updated \n   * @param asset The address of the underlying asset of the reserve \n   * @param decimals The new decimals \n   **/ \n  event ReserveDecimalsChanged(address indexed asset, uint256 decimals); \n \n  /** \n   * @dev Emitted when a reserve interest strategy contract is updated \n   * @param asset The address of the underlying asset of the reserve \n   * @param strategy The new address of the interest strategy contract \n   **/ \n  event ReserveInterestRateStrategyChanged(address indexed asset, address strategy); \n \n  /** \n   * @dev Emitted when an aToken implementation is upgraded \n   * @param asset The address of the underlying asset of the reserve \n   * @param proxy The aToken proxy address \n   * @param implementation The new aToken implementation \n   **/ \n  event ATokenUpgraded( \n    address indexed asset, \n    address indexed proxy, \n    address indexed implementation \n  ); \n \n  /** \n   * @dev Emitted when the implementation of a stable debt token is upgraded \n   * @param asset The address of the underlying asset of the reserve \n   * @param proxy The stable debt token proxy address \n   * @param implementation The new aToken implementation \n   **/ \n  event StableDebtTokenUpgraded( \n    address indexed asset, \n    address indexed proxy, \n    address indexed implementation \n  ); \n \n  /** \n   * @dev Emitted when the implementation of a variable debt token is upgraded \n   * @param asset The address of the underlying asset of the reserve \n   * @param proxy The variable debt token proxy address \n   * @param implementation The new aToken implementation \n   **/ \n  event VariableDebtTokenUpgraded( \n    address indexed asset, \n    address indexed proxy, \n    address indexed implementation \n  ); \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title LendingPoolAddressesProviderRegistry contract \n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets \n * - Used for indexing purposes of Aave protocol's markets \n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with, \n *   for example with `0` for the Aave main market and `1` for the next created \n * @author Aave \n **/ \ninterface ILendingPoolAddressesProviderRegistry { \n  event AddressesProviderRegistered(address indexed newAddress); \n  event AddressesProviderUnregistered(address indexed newAddress); \n \n  function getAddressesProvidersList() external view returns (address[] memory); \n \n  function getAddressesProviderIdByAddress(address addressesProvider) \n    external \n    view \n    returns (uint256); \n \n  function registerAddressesProvider(address provider, uint256 id) external; \n \n  function unregisterAddressesProvider(address provider) external; \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \ninterface IExchangeAdapter { \n  event Exchange( \n    address indexed from, \n    address indexed to, \n    address indexed platform, \n    uint256 fromAmount, \n    uint256 toAmount \n  ); \n \n  function approveExchange(IERC20[] calldata tokens) external; \n \n  function exchange( \n    address from, \n    address to, \n    uint256 amount, \n    uint256 maxSlippage \n  ) external returns (uint256); \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title IPriceOracleGetter interface \n * @notice Interface for the Aave price oracle. \n **/ \n \ninterface IPriceOracleGetter { \n  /** \n   * @dev returns the asset price in ETH \n   * @param asset the address of the asset \n   * @return the ETH price of the asset \n   **/ \n  function getAssetPrice(address asset) external view returns (uint256); \n} \n",
            "pragma solidity 0.6.12; \n \nimport {ILendingPool} from './ILendingPool.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IInitializableAToken \n * @notice Interface for the initialize function on AToken \n * @author Aave \n **/ \ninterface IInitializableAToken { \n  /** \n   * @dev Emitted when an aToken is initialized \n   * @param underlyingAsset The address of the underlying asset \n   * @param pool The address of the associated lending pool \n   * @param treasury The address of the treasury \n   * @param incentivesController The address of the incentives controller for this aToken \n   * @param aTokenDecimals the decimals of the underlying \n   * @param aTokenName the name of the aToken \n   * @param aTokenSymbol the symbol of the aToken \n   * @param params A set of encoded parameters for additional initialization \n   **/ \n  event Initialized( \n    address indexed underlyingAsset, \n    address indexed pool, \n    address treasury, \n    address incentivesController, \n    uint8 aTokenDecimals, \n    string aTokenName, \n    string aTokenSymbol, \n    bytes params \n  ); \n \n  /** \n   * @dev Initializes the aToken \n   * @param pool The address of the lending pool where this aToken will be used \n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken \n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   * @param incentivesController The smart contract managing potential incentives distribution \n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's \n   * @param aTokenName The name of the aToken \n   * @param aTokenSymbol The symbol of the aToken \n   */ \n  function initialize( \n    ILendingPool pool, \n    address treasury, \n    address underlyingAsset, \n    IAaveIncentivesController incentivesController, \n    uint8 aTokenDecimals, \n    string calldata aTokenName, \n    string calldata aTokenSymbol, \n    bytes calldata params \n  ) external; \n} \n",
            "pragma solidity 0.6.12; \n \ninterface ICreditDelegationToken { \n  event BorrowAllowanceDelegated( \n    address indexed fromUser, \n    address indexed toUser, \n    address asset, \n    uint256 amount \n  ); \n \n  /** \n   * @dev delegates borrowing power to a user on the specific debt token \n   * @param delegatee the address receiving the delegated borrowing power \n   * @param amount the maximum amount being delegated. Delegation will still \n   * respect the liquidation constraints (even if delegated, a delegatee cannot \n   * force a delegator HF to go below 1) \n   **/ \n  function approveDelegation(address delegatee, uint256 amount) external; \n \n  /** \n   * @dev returns the borrow allowance of the user \n   * @param fromUser The user to giving allowance \n   * @param toUser The user to give allowance to \n   * @return the current allowance of toUser \n   **/ \n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256); \n} \n",
            "pragma solidity 0.6.12; \n \n/************ \n@title IPriceOracle interface \n@notice Interface for the Aave price oracle.*/ \ninterface IPriceOracle { \n  /*********** \n    @dev returns the asset price in ETH \n     */ \n  function getAssetPrice(address asset) external view returns (uint256); \n \n  /*********** \n    @dev sets the asset price, in wei \n     */ \n  function setAssetPrice(address asset, uint256 price) external; \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \n \ninterface ILendingPool { \n  /** \n   * @dev Emitted on deposit() \n   * @param reserve The address of the underlying asset of the reserve \n   * @param user The address initiating the deposit \n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens \n   * @param amount The amount deposited \n   * @param referral The referral code used \n   **/ \n  event Deposit( \n    address indexed reserve, \n    address user, \n    address indexed onBehalfOf, \n    uint256 amount, \n    uint16 indexed referral \n  ); \n \n  /** \n   * @dev Emitted on withdraw() \n   * @param reserve The address of the underlyng asset being withdrawn \n   * @param user The address initiating the withdrawal, owner of aTokens \n   * @param to Address that will receive the underlying \n   * @param amount The amount to be withdrawn \n   **/ \n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount); \n \n  /** \n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened \n   * @param reserve The address of the underlying asset being borrowed \n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or j\n   * initiator of the transaction on flashLoan() \n   * @param onBehalfOf The address that will be getting the debt \n   * @param amount The amount borrowed out \n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable \n   * @param borrowRate The numeric rate at which the user has borrowed \n   * @param referral The referral code used \n   **/ \n  event Borrow( \n    address indexed reserve, \n    address user, \n    address indexed onBehalfOf, \n    uint256 amount, \n    uint256 borrowRateMode, \n    uint256 borrowRate, \n    uint16 indexed referral \n  ); \n \n  /** \n   * @dev Emitted on repay() \n   * @param reserve The address of the underlying asset of the reserve \n   * @param user The beneficiary of the repayment, getting his debt reduced \n   * @param repayer The address of the user initiating the repay(), providing the funds \n   * @param amount The amount repaid \n   **/ \n  event Repay( \n    address indexed reserve, \n    address indexed user, \n    address indexed repayer, \n    uint256 amount \n  ); \n \n  /** \n   * @dev Emitted on swapBorrowRateMode() \n   * @param reserve The address of the underlying asset of the reserve \n   * @param user The address of the user swapping his rate mode \n   * @param rateMode The rate mode that the user wants to swap to \n   **/ \n  event Swap(address indexed reserve, address indexed user, uint256 rateMode); \n \n  /** \n   * @dev Emitted on setUserUseReserveAsCollateral() \n   * @param reserve The address of the underlying asset of the reserve \n   * @param user The address of the user enabling the usage as collateral \n   **/ \n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user); \n \n  /** \n   * @dev Emitted on setUserUseReserveAsCollateral() \n   * @param reserve The address of the underlying asset of the reserve \n   * @param user The address of the user enabling the usage as collateral \n   **/ \n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user); \n \n  /** \n   * @dev Emitted on rebalanceStableBorrowRate() \n   * @param reserve The address of the underlying asset of the reserve \n   * @param user The address of the user for which the rebalance has been executed \n   **/ \n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user); \n \n  /** \n   * @dev Emitted on flashLoan() \n   * @param target The address of the flash loan receiver contract \n   * @param initiator The address initiating the flash loan \n   * @param asset The address of the asset being flash borrowed \n   * @param amount The amount flash borrowed \n   * @param premium The fee flash borrowed \n   * @param referralCode The referral code used \n   **/ \n  event FlashLoan( \n    address indexed target, \n    address indexed initiator, \n    address indexed asset, \n    uint256 amount, \n    uint256 premium, \n    uint16 referralCode \n  ); \n \n  /** \n   * @dev Emitted when the pause is triggered. \n   */ \n  event Paused(); \n \n  /** \n   * @dev Emitted when the pause is lifted. \n   */ \n  event Unpaused(); \n \n  /** \n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via \n   * LendingPoolCollateral manager using a DELEGATECALL \n   * This allows to have the events in the generated ABI for LendingPool. \n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as res\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation \n   * @param user The address of the borrower getting liquidated \n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover \n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator \n   * @param liquidator The address of the liquidator \n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` \n   * to receive the underlying collateral asset directly \n   **/ \n  event LiquidationCall( \n    address indexed collateralAsset, \n    address indexed debtAsset, \n    address indexed user, \n    uint256 debtToCover, \n    uint256 liquidatedCollateralAmount, \n    address liquidator, \n    bool receiveAToken \n  ); \n \n  /** \n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared \n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the functio\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated \n   * gets added to the LendingPool ABI \n   * @param reserve The address of the underlying asset of the reserve \n   * @param liquidityRate The new liquidity rate \n   * @param stableBorrowRate The new stable borrow rate \n   * @param variableBorrowRate The new variable borrow rate \n   * @param liquidityIndex The new liquidity index \n   * @param variableBorrowIndex The new variable borrow index \n   **/ \n  event ReserveDataUpdated( \n    address indexed reserve, \n    uint256 liquidityRate, \n    uint256 stableBorrowRate, \n    uint256 variableBorrowRate, \n    uint256 liquidityIndex, \n    uint256 variableBorrowIndex \n  ); \n \n  /** \n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aT\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC \n   * @param asset The address of the underlying asset to deposit \n   * @param amount The amount to be deposited \n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user \n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens \n   *   is a different wallet \n   * @param referralCode Code used to register the integrator originating the operation, for potentia\n   *   0 if the action is executed directly by the user, without any middle-man \n   **/ \n  function deposit( \n    address asset, \n    uint256 amount, \n    address onBehalfOf, \n    uint16 referralCode \n  ) external; \n \n  /** \n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens \n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC \n   * @param asset The address of the underlying asset to withdraw \n   * @param amount The underlying amount to be withdrawn \n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance \n   * @param to Address that will receive the underlying, same as msg.sender if the user \n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a \n   *   different wallet \n   * @return The final amount withdrawn \n   **/ \n  function withdraw( \n    address asset, \n    uint256 amount, \n    address to \n  ) external returns (uint256); \n \n  /** \n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that t\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on t\n   * corresponding debt token (StableDebtToken or VariableDebtToken) \n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in \n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode` \n   * @param asset The address of the underlying asset to borrow \n   * @param amount The amount to be borrowed \n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, \n   * @param referralCode Code used to register the integrator originating the operation, for potentia\n   *   0 if the action is executed directly by the user, without any middle-man \n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the bo\n   * calling the function if he wants to borrow against his own collateral, or the address of the cre\n   * if he has been given credit delegation allowance \n   **/ \n  function borrow( \n    address asset, \n    uint256 amount, \n    uint256 interestRateMode, \n    uint16 referralCode, \n    address onBehalfOf \n  ) external; \n \n  /** \n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens own\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed \n   * @param amount The amount to repay \n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific \n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 f\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the addre\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed \n   * @return The final amount repaid \n   **/ \n  function repay( \n    address asset, \n    uint256 amount, \n    uint256 rateMode, \n    address onBehalfOf \n  ) external returns (uint256); \n \n  /** \n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa \n   * @param asset The address of the underlying asset borrowed \n   * @param rateMode The rate mode that the user wants to swap to \n   **/ \n  function swapBorrowRateMode(address asset, uint256 rateMode) external; \n \n  /** \n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the res\n   * - Users can be rebalanced if the following conditions are satisfied: \n   *     1. Usage ratio is above 95% \n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which me\n   *        borrowed at a stable rate and depositors are not earning enough \n   * @param asset The address of the underlying asset borrowed \n   * @param user The address of the user to be rebalanced \n   **/ \n  function rebalanceStableBorrowRate(address asset, address user) external; \n \n  /** \n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral \n   * @param asset The address of the underlying asset deposited \n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherw\n   **/ \n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external; \n \n  /** \n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 \n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, an\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk \n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as res\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation \n   * @param user The address of the borrower getting liquidated \n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover \n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` \n   * to receive the underlying collateral asset directly \n   **/ \n  function liquidationCall( \n    address collateralAsset, \n    address debtAsset, \n    address user, \n    uint256 debtToCover, \n    bool receiveAToken \n  ) external; \n \n  /** \n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction, \n   * as long as the amount taken plus a fee is returned. \n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must b\n   * For further details please visit https://developers.aave.com \n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashL\n   * @param assets The addresses of the assets being flash-borrowed \n   * @param amounts The amounts amounts being flash-borrowed \n   * @param modes Types of the debt to open if the flash loan is not returned: \n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver \n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` a\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` \n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information \n   * @param referralCode Code used to register the integrator originating the operation, for potentia\n   *   0 if the action is executed directly by the user, without any middle-man \n   **/ \n  function flashLoan( \n    address receiverAddress, \n    address[] calldata assets, \n    uint256[] calldata amounts, \n    uint256[] calldata modes, \n    address onBehalfOf, \n    bytes calldata params, \n    uint16 referralCode \n  ) external; \n \n  /** \n   * @dev Returns the user account data across all the reserves \n   * @param user The address of the user \n   * @return totalCollateralETH the total collateral in ETH of the user \n   * @return totalDebtETH the total debt in ETH of the user \n   * @return availableBorrowsETH the borrowing power left of the user \n   * @return currentLiquidationThreshold the liquidation threshold of the user \n   * @return ltv the loan to value of the user \n   * @return healthFactor the current health factor of the user \n   **/ \n  function getUserAccountData(address user) \n    external \n    view \n    returns ( \n      uint256 totalCollateralETH, \n      uint256 totalDebtETH, \n      uint256 availableBorrowsETH, \n      uint256 currentLiquidationThreshold, \n      uint256 ltv, \n      uint256 healthFactor \n    ); \n \n  function initReserve( \n    address reserve, \n    address aTokenAddress, \n    address stableDebtAddress, \n    address variableDebtAddress, \n    address interestRateStrategyAddress \n  ) external; \n \n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) \n    external; \n \n  function setConfiguration(address reserve, uint256 configuration) external; \n \n  /** \n   * @dev Returns the configuration of the reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @return The configuration of the reserve \n   **/ \n  function getConfiguration(address asset) \n    external \n    view \n    returns (DataTypes.ReserveConfigurationMap memory); \n \n  /** \n   * @dev Returns the configuration of the user across all the reserves \n   * @param user The user address \n   * @return The configuration of the user \n   **/ \n  function getUserConfiguration(address user) \n    external \n    view \n    returns (DataTypes.UserConfigurationMap memory); \n \n  /** \n   * @dev Returns the normalized income normalized income of the reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @return The reserve's normalized income \n   */ \n  function getReserveNormalizedIncome(address asset) external view returns (uint256); \n \n  /** \n   * @dev Returns the normalized variable debt per unit of asset \n   * @param asset The address of the underlying asset of the reserve \n   * @return The reserve normalized variable debt \n   */ \n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256); \n \n  /** \n   * @dev Returns the state and configuration of the reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @return The state of the reserve \n   **/ \n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory); \n \n  function finalizeTransfer( \n    address asset, \n    address from, \n    address to, \n    uint256 amount, \n    uint256 balanceFromAfter, \n    uint256 balanceToBefore \n  ) external; \n \n  function getReservesList() external view returns (address[] memory); \n \n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider); \n \n  function setPause(bool val) external; \n \n  function paused() external view returns (bool); \n} \n",
            "pragma solidity 0.6.12; \n \ninterface IUniswapV2Router02 { \n  function swapExactTokensForTokens( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapTokensForExactTokens( \n    uint256 amountOut, \n    uint256 amountInMax, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function getAmountsOut(uint256 amountIn, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n \n  function getAmountsIn(uint256 amountOut, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title LendingPoolAddressesProvider contract \n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementation\n * - Owned by the Aave Governance \n * @author Aave \n **/ \ninterface ILendingPoolAddressesProvider { \n  event MarketIdSet(string newMarketId); \n  event LendingPoolUpdated(address indexed newAddress); \n  event ConfigurationAdminUpdated(address indexed newAddress); \n  event EmergencyAdminUpdated(address indexed newAddress); \n  event LendingPoolConfiguratorUpdated(address indexed newAddress); \n  event LendingPoolCollateralManagerUpdated(address indexed newAddress); \n  event PriceOracleUpdated(address indexed newAddress); \n  event LendingRateOracleUpdated(address indexed newAddress); \n  event ProxyCreated(bytes32 id, address indexed newAddress); \n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy); \n \n  function getMarketId() external view returns (string memory); \n \n  function setMarketId(string calldata marketId) external; \n \n  function setAddress(bytes32 id, address newAddress) external; \n \n  function setAddressAsProxy(bytes32 id, address impl) external; \n \n  function getAddress(bytes32 id) external view returns (address); \n \n  function getLendingPool() external view returns (address); \n \n  function setLendingPoolImpl(address pool) external; \n \n  function getLendingPoolConfigurator() external view returns (address); \n \n  function setLendingPoolConfiguratorImpl(address configurator) external; \n \n  function getLendingPoolCollateralManager() external view returns (address); \n \n  function setLendingPoolCollateralManager(address manager) external; \n \n  function getPoolAdmin() external view returns (address); \n \n  function setPoolAdmin(address admin) external; \n \n  function getEmergencyAdmin() external view returns (address); \n \n  function setEmergencyAdmin(address admin) external; \n \n  function getPriceOracle() external view returns (address); \n \n  function setPriceOracle(address priceOracle) external; \n \n  function getLendingRateOracle() external view returns (address); \n \n  function setLendingRateOracle(address lendingRateOracle) external; \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \ninterface IAaveIncentivesController { \n  function handleAction( \n    address user, \n    uint256 userBalance, \n    uint256 totalSupply \n  ) external; \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title IDelegationToken \n * @dev Implements an interface for tokens with delegation COMP/UNI compatible \n * @author Aave \n **/ \ninterface IDelegationToken { \n  function delegate(address delegatee) external; \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title IReserveInterestRateStrategyInterface interface \n * @dev Interface for the calculation of the interest rates \n * @author Aave \n */ \ninterface IReserveInterestRateStrategy { \n  function baseVariableBorrowRate() external view returns (uint256); \n \n  function getMaxVariableBorrowRate() external view returns (uint256); \n \n  function calculateInterestRates( \n    address reserve, \n    uint256 availableLiquidity, \n    uint256 totalStableDebt, \n    uint256 totalVariableDebt, \n    uint256 averageStableBorrowRate, \n    uint256 reserveFactor \n  ) \n    external \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256 \n    ); \n \n  function calculateInterestRates( \n    address reserve, \n    address aToken, \n    uint256 liquidityAdded, \n    uint256 liquidityTaken, \n    uint256 totalStableDebt, \n    uint256 totalVariableDebt, \n    uint256 averageStableBorrowRate, \n    uint256 reserveFactor \n  ) \n    external \n    view \n    returns ( \n      uint256 liquidityRate, \n      uint256 stableBorrowRate, \n      uint256 variableBorrowRate \n    ); \n} \n",
            "pragma solidity 0.6.12; \n \ninterface IUniswapExchange { \n  event TokenPurchase( \n    address indexed buyer, \n    uint256 indexed eth_sold, \n    uint256 indexed tokens_bought \n  ); \n  event EthPurchase(address indexed buyer, uint256 indexed tokens_sold, uint256 indexed eth_bought); \n  event AddLiquidity( \n    address indexed provider, \n    uint256 indexed eth_amount, \n    uint256 indexed token_amount \n  ); \n  event RemoveLiquidity( \n    address indexed provider, \n    uint256 indexed eth_amount, \n    uint256 indexed token_amount \n  ); \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title ILendingPoolCollateralManager \n * @author Aave \n * @notice Defines the actions involving management of collateral in the protocol. \n **/ \ninterface ILendingPoolCollateralManager { \n  /** \n   * @dev Emitted when a borrower is liquidated \n   * @param collateral The address of the collateral being liquidated \n   * @param principal The address of the reserve \n   * @param user The address of the user being liquidated \n   * @param debtToCover The total amount liquidated \n   * @param liquidatedCollateralAmount The amount of collateral being liquidated \n   * @param liquidator The address of the liquidator \n   * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise \n   **/ \n  event LiquidationCall( \n    address indexed collateral, \n    address indexed principal, \n    address indexed user, \n    uint256 debtToCover, \n    uint256 liquidatedCollateralAmount, \n    address liquidator, \n    bool receiveAToken \n  ); \n \n  /** \n   * @dev Emitted when a reserve is disabled as collateral for an user \n   * @param reserve The address of the reserve \n   * @param user The address of the user \n   **/ \n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user); \n \n  /** \n   * @dev Emitted when a reserve is enabled as collateral for an user \n   * @param reserve The address of the reserve \n   * @param user The address of the user \n   **/ \n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user); \n \n  /** \n   * @dev Users can invoke this function to liquidate an undercollateralized position. \n   * @param collateral The address of the collateral to liquidated \n   * @param principal The address of the principal reserve \n   * @param user The address of the borrower \n   * @param debtToCover The amount of principal that the liquidator wants to repay \n   * @param receiveAToken true if the liquidators wants to receive the aTokens, false if \n   * he wants to receive the underlying asset directly \n   **/ \n  function liquidationCall( \n    address collateral, \n    address principal, \n    address user, \n    uint256 debtToCover, \n    bool receiveAToken \n  ) external returns (uint256, string memory); \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title ILendingRateOracle interface \n * @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be u\n **/ \n \ninterface ILendingRateOracle { \n  /** \n    @dev returns the market borrow rate in ray \n    **/ \n  function getMarketBorrowRate(address asset) external view returns (uint256); \n \n  /** \n    @dev sets the market borrow rate. Rate value must be in ray \n    **/ \n  function setMarketBorrowRate(address asset, uint256 rate) external; \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol'; \nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IVariableDebtToken \n * @author Aave \n * @notice Defines the basic interface for a variable debt token. \n **/ \ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken { \n  /** \n   * @dev Emitted after the mint action \n   * @param from The address performing the mint \n   * @param onBehalfOf The address of the user on which behalf minting has been performed \n   * @param value The amount to be minted \n   * @param index The last index of the reserve \n   **/ \n  event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index); \n \n  /** \n   * @dev Mints debt token to the `onBehalfOf` address \n   * @param user The address receiving the borrowed underlying, being the delegatee in case \n   * of credit delegate, or same as `onBehalfOf` otherwise \n   * @param onBehalfOf The address receiving the debt tokens \n   * @param amount The amount of debt being minted \n   * @param index The variable debt index of the reserve \n   * @return `true` if the the previous balance of the user is 0 \n   **/ \n  function mint( \n    address user, \n    address onBehalfOf, \n    uint256 amount, \n    uint256 index \n  ) external returns (bool); \n \n  /** \n   * @dev Emitted when variable debt is burnt \n   * @param user The user which debt has been burned \n   * @param amount The amount of debt being burned \n   * @param index The index of the user \n   **/ \n  event Burn(address indexed user, uint256 amount, uint256 index); \n \n  /** \n   * @dev Burns user variable debt \n   * @param user The user which debt is burnt \n   * @param index The variable debt index of the reserve \n   **/ \n  function burn( \n    address user, \n    uint256 amount, \n    uint256 index \n  ) external; \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view returns (IAaveIncentivesController); \n} \n",
            "pragma solidity 0.6.12; \n \nimport {ILendingPool} from './ILendingPool.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IInitializableDebtToken \n * @notice Interface for the initialize function common between debt tokens \n * @author Aave \n **/ \ninterface IInitializableDebtToken { \n  /** \n   * @dev Emitted when a debt token is initialized \n   * @param underlyingAsset The address of the underlying asset \n   * @param pool The address of the associated lending pool \n   * @param incentivesController The address of the incentives controller for this aToken \n   * @param debtTokenDecimals the decimals of the debt token \n   * @param debtTokenName the name of the debt token \n   * @param debtTokenSymbol the symbol of the debt token \n   * @param params A set of encoded parameters for additional initialization \n   **/ \n  event Initialized( \n    address indexed underlyingAsset, \n    address indexed pool, \n    address incentivesController, \n    uint8 debtTokenDecimals, \n    string debtTokenName, \n    string debtTokenSymbol, \n    bytes params \n  ); \n \n  /** \n   * @dev Initializes the debt token. \n   * @param pool The address of the lending pool where this aToken will be used \n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   * @param incentivesController The smart contract managing potential incentives distribution \n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's \n   * @param debtTokenName The name of the token \n   * @param debtTokenSymbol The symbol of the token \n   */ \n  function initialize( \n    ILendingPool pool, \n    address underlyingAsset, \n    IAaveIncentivesController incentivesController, \n    uint8 debtTokenDecimals, \n    string memory debtTokenName, \n    string memory debtTokenSymbol, \n    bytes calldata params \n  ) external; \n} \n",
            "pragma solidity 0.6.12; \n \ninterface IChainlinkAggregator { \n  function latestAnswer() external view returns (int256); \n \n  function latestTimestamp() external view returns (uint256); \n \n  function latestRound() external view returns (uint256); \n \n  function getAnswer(uint256 roundId) external view returns (int256); \n \n  function getTimestamp(uint256 roundId) external view returns (uint256); \n \n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n  event NewRound(uint256 indexed roundId, address indexed startedBy); \n} \n",
            "pragma solidity 0.6.12; \n \ninterface IScaledBalanceToken { \n  /** \n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the \n   * updated stored balance divided by the reserve's liquidity index at the moment of the update \n   * @param user The user whose balance is calculated \n   * @return The scaled balance of the user \n   **/ \n  function scaledBalanceOf(address user) external view returns (uint256); \n \n  /** \n   * @dev Returns the scaled balance of the user and the scaled total supply. \n   * @param user The address of the user \n   * @return The scaled balance of the user \n   * @return The scaled balance and the scaled total supply \n   **/ \n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256); \n \n  /** \n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index) \n   * @return The scaled total supply \n   **/ \n  function scaledTotalSupply() external view returns (uint256); \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \ninterface IERC20WithPermit is IERC20 { \n  function permit( \n    address owner, \n    address spender, \n    uint256 value, \n    uint256 deadline, \n    uint8 v, \n    bytes32 r, \n    bytes32 s \n  ) external; \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol'; \nimport {IUniswapV2Router02} from '../../interfaces/IUniswapV2Router02.sol'; \n \ninterface IBaseUniswapAdapter { \n  event Swapped(address fromAsset, address toAsset, uint256 fromAmount, uint256 receivedAmount); \n \n  struct PermitSignature { \n    uint256 amount; \n    uint256 deadline; \n    uint8 v; \n    bytes32 r; \n    bytes32 s; \n  } \n \n  struct AmountCalc { \n    uint256 calculatedAmount; \n    uint256 relativePrice; \n    uint256 amountInUsd; \n    uint256 amountOutUsd; \n    address[] path; \n  } \n \n  function WETH_ADDRESS() external returns (address); \n \n  function MAX_SLIPPAGE_PERCENT() external returns (uint256); \n \n  function FLASHLOAN_PREMIUM_TOTAL() external returns (uint256); \n \n  function USD_ADDRESS() external returns (address); \n \n  function ORACLE() external returns (IPriceOracleGetter); \n \n  function UNISWAP_ROUTER() external returns (IUniswapV2Router02); \n \n  /** \n   * @dev Given an input asset amount, returns the maximum output amount of the other asset and the p\n   * @param amountIn Amount of reserveIn \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @return uint256 Amount out of the reserveOut \n   * @return uint256 The price of out amount denominated in the reserveIn currency (18 decimals) \n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals) \n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n   * @return address[] The exchange path \n   */ \n  function getAmountsOut( \n    uint256 amountIn, \n    address reserveIn, \n    address reserveOut \n  ) \n    external \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256, \n      address[] memory \n    ); \n \n  /** \n   * @dev Returns the minimum input asset amount required to buy the given output asset amount and th\n   * @param amountOut Amount of reserveOut \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @return uint256 Amount in of the reserveIn \n   * @return uint256 The price of in amount denominated in the reserveOut currency (18 decimals) \n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals) \n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n   * @return address[] The exchange path \n   */ \n  function getAmountsIn( \n    uint256 amountOut, \n    address reserveIn, \n    address reserveOut \n  ) \n    external \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256, \n      address[] memory \n    ); \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {BaseUniswapAdapter} from './BaseUniswapAdapter.sol'; \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \n/** \n * @title UniswapLiquiditySwapAdapter \n * @notice Uniswap V2 Adapter to swap liquidity. \n * @author Aave \n **/ \ncontract UniswapLiquiditySwapAdapter is BaseUniswapAdapter { \n  struct PermitParams { \n    uint256[] amount; \n    uint256[] deadline; \n    uint8[] v; \n    bytes32[] r; \n    bytes32[] s; \n  } \n \n  struct SwapParams { \n    address[] assetToSwapToList; \n    uint256[] minAmountsToReceive; \n    bool[] swapAllBalance; \n    PermitParams permitParams; \n    bool[] useEthPath; \n  } \n \n  constructor( \n    ILendingPoolAddressesProvider addressesProvider, \n    IUniswapV2Router02 uniswapRouter, \n    address wethAddress \n  ) public BaseUniswapAdapter(addressesProvider, uniswapRouter, wethAddress) {} \n \n  /** \n   * @dev Swaps the received reserve amount from the flash loan into the asset specified in the param\n   * The received funds from the swap are then deposited into the protocol on behalf of the user. \n   * The user should give this contract allowance to pull the ATokens in order to withdraw the underly\n   * repay the flash loan. \n   * @param assets Address of asset to be swapped \n   * @param amounts Amount of the asset to be swapped \n   * @param premiums Fee of the flash loan \n   * @param initiator Address of the user \n   * @param params Additional variadic field to include extra params. Expected parameters: \n   *   address[] assetToSwapToList List of the addresses of the reserve to be swapped to and deposite\n   *   uint256[] minAmountsToReceive List of min amounts to be received from the swap \n   *   bool[] swapAllBalance Flag indicating if all the user balance should be swapped \n   *   uint256[] permitAmount List of amounts for the permit signature \n   *   uint256[] deadline List of deadlines for the permit signature \n   *   uint8[] v List of v param for the permit signature \n   *   bytes32[] r List of r param for the permit signature \n   *   bytes32[] s List of s param for the permit signature \n   */ \n  function executeOperation( \n    address[] calldata assets, \n    uint256[] calldata amounts, \n    uint256[] calldata premiums, \n    address initiator, \n    bytes calldata params \n  ) external override returns (bool) { \n    require(msg.sender == address(LENDING_POOL), 'CALLER_MUST_BE_LENDING_POOL'); \n \n    SwapParams memory decodedParams = _decodeParams(params); \n \n    require( \n      assets.length == decodedParams.assetToSwapToList.length && \n        assets.length == decodedParams.minAmountsToReceive.length && \n        assets.length == decodedParams.swapAllBalance.length && \n        assets.length == decodedParams.permitParams.amount.length && \n        assets.length == decodedParams.permitParams.deadline.length && \n        assets.length == decodedParams.permitParams.v.length && \n        assets.length == decodedParams.permitParams.r.length && \n        assets.length == decodedParams.permitParams.s.length && \n        assets.length == decodedParams.useEthPath.length, \n      'INCONSISTENT_PARAMS' \n    ); \n \n    for (uint256 i = 0; i < assets.length; i++) { \n      _swapLiquidity( \n        assets[i], \n        decodedParams.assetToSwapToList[i], \n        amounts[i], \n        premiums[i], \n        initiator, \n        decodedParams.minAmountsToReceive[i], \n        decodedParams.swapAllBalance[i], \n        PermitSignature( \n          decodedParams.permitParams.amount[i], \n          decodedParams.permitParams.deadline[i], \n          decodedParams.permitParams.v[i], \n          decodedParams.permitParams.r[i], \n          decodedParams.permitParams.s[i] \n        ), \n        decodedParams.useEthPath[i] \n      ); \n    } \n \n    return true; \n  } \n \n  struct SwapAndDepositLocalVars { \n    uint256 i; \n    uint256 aTokenInitiatorBalance; \n    uint256 amountToSwap; \n    uint256 receivedAmount; \n    address aToken; \n  } \n \n  /** \n   * @dev Swaps an amount of an asset to another and deposits the new asset amount on behalf of the u\n   * a flash loan. This method can be used when the temporary transfer of the collateral asset to thi\n   * does not affect the user position. \n   * The user should give this contract allowance to pull the ATokens in order to withdraw the underly\n   * perform the swap. \n   * @param assetToSwapFromList List of addresses of the underlying asset to be swap from \n   * @param assetToSwapToList List of addresses of the underlying asset to be swap to and deposited \n   * @param amountToSwapList List of amounts to be swapped. If the amount exceeds the balance, the to\n   * @param minAmountsToReceive List of min amounts to be received from the swap \n   * @param permitParams List of struct containing the permit signatures \n   *   uint256 permitAmount Amount for the permit signature \n   *   uint256 deadline Deadline for the permit signature \n   *   uint8 v param for the permit signature \n   *   bytes32 r param for the permit signature \n   *   bytes32 s param for the permit signature \n   * @param useEthPath true if the swap needs to occur using ETH in the routing, false otherwise \n   */ \n  function swapAndDeposit( \n    address[] calldata assetToSwapFromList, \n    address[] calldata assetToSwapToList, \n    uint256[] calldata amountToSwapList, \n    uint256[] calldata minAmountsToReceive, \n    PermitSignature[] calldata permitParams, \n    bool[] calldata useEthPath \n  ) external { \n    require( \n      assetToSwapFromList.length == assetToSwapToList.length && \n        assetToSwapFromList.length == amountToSwapList.length && \n        assetToSwapFromList.length == minAmountsToReceive.length && \n        assetToSwapFromList.length == permitParams.length, \n      'INCONSISTENT_PARAMS' \n    ); \n \n    SwapAndDepositLocalVars memory vars; \n \n    for (vars.i = 0; vars.i < assetToSwapFromList.length; vars.i++) { \n      vars.aToken = _getReserveData(assetToSwapFromList[vars.i]).aTokenAddress; \n \n      vars.aTokenInitiatorBalance = IERC20(vars.aToken).balanceOf(msg.sender); \n      vars.amountToSwap = amountToSwapList[vars.i] > vars.aTokenInitiatorBalance \n        ? vars.aTokenInitiatorBalance \n        : amountToSwapList[vars.i]; \n \n      _pullAToken( \n        assetToSwapFromList[vars.i], \n        vars.aToken, \n        msg.sender, \n        vars.amountToSwap, \n        permitParams[vars.i] \n      ); \n \n      vars.receivedAmount = _swapExactTokensForTokens( \n        assetToSwapFromList[vars.i], \n        assetToSwapToList[vars.i], \n        vars.amountToSwap, \n        minAmountsToReceive[vars.i], \n        useEthPath[vars.i] \n      ); \n \n      // Deposit new reserve \n      IERC20(assetToSwapToList[vars.i]).safeApprove(address(LENDING_POOL), 0); \n      IERC20(assetToSwapToList[vars.i]).safeApprove(address(LENDING_POOL), vars.receivedAmount); \n      LENDING_POOL.deposit(assetToSwapToList[vars.i], vars.receivedAmount, msg.sender, 0); \n    } \n  } \n \n  /** \n   * @dev Swaps an `amountToSwap` of an asset to another and deposits the funds on behalf of the init\n   * @param assetFrom Address of the underlying asset to be swap from \n   * @param assetTo Address of the underlying asset to be swap to and deposited \n   * @param amount Amount from flash loan \n   * @param premium Premium of the flash loan \n   * @param minAmountToReceive Min amount to be received from the swap \n   * @param swapAllBalance Flag indicating if all the user balance should be swapped \n   * @param permitSignature List of struct containing the permit signature \n   * @param useEthPath true if the swap needs to occur using ETH in the routing, false otherwise \n   */ \n \n  struct SwapLiquidityLocalVars { \n    address aToken; \n    uint256 aTokenInitiatorBalance; \n    uint256 amountToSwap; \n    uint256 receivedAmount; \n    uint256 flashLoanDebt; \n    uint256 amountToPull; \n  } \n \n  function _swapLiquidity( \n    address assetFrom, \n    address assetTo, \n    uint256 amount, \n    uint256 premium, \n    address initiator, \n    uint256 minAmountToReceive, \n    bool swapAllBalance, \n    PermitSignature memory permitSignature, \n    bool useEthPath \n  ) internal { \n    SwapLiquidityLocalVars memory vars; \n \n    vars.aToken = _getReserveData(assetFrom).aTokenAddress; \n \n    vars.aTokenInitiatorBalance = IERC20(vars.aToken).balanceOf(initiator); \n    vars.amountToSwap = swapAllBalance && vars.aTokenInitiatorBalance.sub(premium) <= amount \n      ? vars.aTokenInitiatorBalance.sub(premium) \n      : amount; \n \n    vars.receivedAmount = _swapExactTokensForTokens( \n      assetFrom, \n      assetTo, \n      vars.amountToSwap, \n      minAmountToReceive, \n      useEthPath \n    ); \n \n    // Deposit new reserve \n    IERC20(assetTo).safeApprove(address(LENDING_POOL), 0); \n    IERC20(assetTo).safeApprove(address(LENDING_POOL), vars.receivedAmount); \n    LENDING_POOL.deposit(assetTo, vars.receivedAmount, initiator, 0); \n \n    vars.flashLoanDebt = amount.add(premium); \n    vars.amountToPull = vars.amountToSwap.add(premium); \n \n    _pullAToken(assetFrom, vars.aToken, initiator, vars.amountToPull, permitSignature); \n \n    // Repay flash loan \n    IERC20(assetFrom).safeApprove(address(LENDING_POOL), 0); \n    IERC20(assetFrom).safeApprove(address(LENDING_POOL), vars.flashLoanDebt); \n  } \n \n  /** \n   * @dev Decodes the information encoded in the flash loan params \n   * @param params Additional variadic field to include extra params. Expected parameters: \n   *   address[] assetToSwapToList List of the addresses of the reserve to be swapped to and deposite\n   *   uint256[] minAmountsToReceive List of min amounts to be received from the swap \n   *   bool[] swapAllBalance Flag indicating if all the user balance should be swapped \n   *   uint256[] permitAmount List of amounts for the permit signature \n   *   uint256[] deadline List of deadlines for the permit signature \n   *   uint8[] v List of v param for the permit signature \n   *   bytes32[] r List of r param for the permit signature \n   *   bytes32[] s List of s param for the permit signature \n   *   bool[] useEthPath true if the swap needs to occur using ETH in the routing, false otherwise \n   * @return SwapParams struct containing decoded params \n   */ \n  function _decodeParams(bytes memory params) internal pure returns (SwapParams memory) { \n    ( \n      address[] memory assetToSwapToList, \n      uint256[] memory minAmountsToReceive, \n      bool[] memory swapAllBalance, \n      uint256[] memory permitAmount, \n      uint256[] memory deadline, \n      uint8[] memory v, \n      bytes32[] memory r, \n      bytes32[] memory s, \n      bool[] memory useEthPath \n    ) = \n      abi.decode( \n        params, \n        (address[], uint256[], bool[], uint256[], uint256[], uint8[], bytes32[], bytes32[], bool[]) \n      ); \n \n    return \n      SwapParams( \n        assetToSwapToList, \n        minAmountsToReceive, \n        swapAllBalance, \n        PermitParams(permitAmount, deadline, v, r, s), \n        useEthPath \n      ); \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {BaseUniswapAdapter} from './BaseUniswapAdapter.sol'; \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \n \n/** \n * @title UniswapRepayAdapter \n * @notice Uniswap V2 Adapter to perform a repay of a debt with collateral. \n * @author Aave \n **/ \ncontract UniswapRepayAdapter is BaseUniswapAdapter { \n  struct RepayParams { \n    address collateralAsset; \n    uint256 collateralAmount; \n    uint256 rateMode; \n    PermitSignature permitSignature; \n    bool useEthPath; \n  } \n \n  constructor( \n    ILendingPoolAddressesProvider addressesProvider, \n    IUniswapV2Router02 uniswapRouter, \n    address wethAddress \n  ) public BaseUniswapAdapter(addressesProvider, uniswapRouter, wethAddress) {} \n \n  /** \n   * @dev Uses the received funds from the flash loan to repay a debt on the protocol on behalf of th\n   * the collateral from the user and swaps it to the debt asset to repay the flash loan. \n   * The user should give this contract allowance to pull the ATokens in order to withdraw the underly\n   * and repay the flash loan. \n   * Supports only one asset on the flash loan. \n   * @param assets Address of debt asset \n   * @param amounts Amount of the debt to be repaid \n   * @param premiums Fee of the flash loan \n   * @param initiator Address of the user \n   * @param params Additional variadic field to include extra params. Expected parameters: \n   *   address collateralAsset Address of the reserve to be swapped \n   *   uint256 collateralAmount Amount of reserve to be swapped \n   *   uint256 rateMode Rate modes of the debt to be repaid \n   *   uint256 permitAmount Amount for the permit signature \n   *   uint256 deadline Deadline for the permit signature \n   *   uint8 v V param for the permit signature \n   *   bytes32 r R param for the permit signature \n   *   bytes32 s S param for the permit signature \n   */ \n  function executeOperation( \n    address[] calldata assets, \n    uint256[] calldata amounts, \n    uint256[] calldata premiums, \n    address initiator, \n    bytes calldata params \n  ) external override returns (bool) { \n    require(msg.sender == address(LENDING_POOL), 'CALLER_MUST_BE_LENDING_POOL'); \n \n    RepayParams memory decodedParams = _decodeParams(params); \n \n    _swapAndRepay( \n      decodedParams.collateralAsset, \n      assets[0], \n      amounts[0], \n      decodedParams.collateralAmount, \n      decodedParams.rateMode, \n      initiator, \n      premiums[0], \n      decodedParams.permitSignature, \n      decodedParams.useEthPath \n    ); \n \n    return true; \n  } \n \n  /** \n   * @dev Swaps the user collateral for the debt asset and then repay the debt on the protocol on beh\n   * without using flash loans. This method can be used when the temporary transfer of the collateral \n   * contract does not affect the user position. \n   * The user should give this contract allowance to pull the ATokens in order to withdraw the underly\n   * @param collateralAsset Address of asset to be swapped \n   * @param debtAsset Address of debt asset \n   * @param collateralAmount Amount of the collateral to be swapped \n   * @param debtRepayAmount Amount of the debt to be repaid \n   * @param debtRateMode Rate mode of the debt to be repaid \n   * @param permitSignature struct containing the permit signature \n   * @param useEthPath struct containing the permit signature \n \n   */ \n  function swapAndRepay( \n    address collateralAsset, \n    address debtAsset, \n    uint256 collateralAmount, \n    uint256 debtRepayAmount, \n    uint256 debtRateMode, \n    PermitSignature calldata permitSignature, \n    bool useEthPath \n  ) external { \n    DataTypes.ReserveData memory collateralReserveData = _getReserveData(collateralAsset); \n    DataTypes.ReserveData memory debtReserveData = _getReserveData(debtAsset); \n \n    address debtToken = \n      DataTypes.InterestRateMode(debtRateMode) == DataTypes.InterestRateMode.STABLE \n        ? debtReserveData.stableDebtTokenAddress \n        : debtReserveData.variableDebtTokenAddress; \n \n    uint256 currentDebt = IERC20(debtToken).balanceOf(msg.sender); \n    uint256 amountToRepay = debtRepayAmount <= currentDebt ? debtRepayAmount : currentDebt; \n \n    if (collateralAsset != debtAsset) { \n      uint256 maxCollateralToSwap = collateralAmount; \n      if (amountToRepay < debtRepayAmount) { \n        maxCollateralToSwap = maxCollateralToSwap.mul(amountToRepay).div(debtRepayAmount); \n      } \n \n      // Get exact collateral needed for the swap to avoid leftovers \n      uint256[] memory amounts = \n        _getAmountsIn(collateralAsset, debtAsset, amountToRepay, useEthPath); \n      require(amounts[0] <= maxCollateralToSwap, 'slippage too high'); \n \n      // Pull aTokens from user \n      _pullAToken( \n        collateralAsset, \n        collateralReserveData.aTokenAddress, \n        msg.sender, \n        amounts[0], \n        permitSignature \n      ); \n \n      // Swap collateral for debt asset \n      _swapTokensForExactTokens(collateralAsset, debtAsset, amounts[0], amountToRepay, useEthPath); \n    } else { \n      // Pull aTokens from user \n      _pullAToken( \n        collateralAsset, \n        collateralReserveData.aTokenAddress, \n        msg.sender, \n        amountToRepay, \n        permitSignature \n      ); \n    } \n \n    // Repay debt. Approves 0 first to comply with tokens that implement the anti frontrunning approv\n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), 0); \n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), amountToRepay); \n    LENDING_POOL.repay(debtAsset, amountToRepay, debtRateMode, msg.sender); \n  } \n \n  /** \n   * @dev Perform the repay of the debt, pulls the initiator collateral and swaps to repay the flash \n   * \n   * @param collateralAsset Address of token to be swapped \n   * @param debtAsset Address of debt token to be received from the swap \n   * @param amount Amount of the debt to be repaid \n   * @param collateralAmount Amount of the reserve to be swapped \n   * @param rateMode Rate mode of the debt to be repaid \n   * @param initiator Address of the user \n   * @param premium Fee of the flash loan \n   * @param permitSignature struct containing the permit signature \n   */ \n  function _swapAndRepay( \n    address collateralAsset, \n    address debtAsset, \n    uint256 amount, \n    uint256 collateralAmount, \n    uint256 rateMode, \n    address initiator, \n    uint256 premium, \n    PermitSignature memory permitSignature, \n    bool useEthPath \n  ) internal { \n    DataTypes.ReserveData memory collateralReserveData = _getReserveData(collateralAsset); \n \n    // Repay debt. Approves for 0 first to comply with tokens that implement the anti frontrunning app\n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), 0); \n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), amount); \n    uint256 repaidAmount = IERC20(debtAsset).balanceOf(address(this)); \n    LENDING_POOL.repay(debtAsset, amount, rateMode, initiator); \n    repaidAmount = repaidAmount.sub(IERC20(debtAsset).balanceOf(address(this))); \n \n    if (collateralAsset != debtAsset) { \n      uint256 maxCollateralToSwap = collateralAmount; \n      if (repaidAmount < amount) { \n        maxCollateralToSwap = maxCollateralToSwap.mul(repaidAmount).div(amount); \n      } \n \n      uint256 neededForFlashLoanDebt = repaidAmount.add(premium); \n      uint256[] memory amounts = \n        _getAmountsIn(collateralAsset, debtAsset, neededForFlashLoanDebt, useEthPath); \n      require(amounts[0] <= maxCollateralToSwap, 'slippage too high'); \n \n      // Pull aTokens from user \n      _pullAToken( \n        collateralAsset, \n        collateralReserveData.aTokenAddress, \n        initiator, \n        amounts[0], \n        permitSignature \n      ); \n \n      // Swap collateral asset to the debt asset \n      _swapTokensForExactTokens( \n        collateralAsset, \n        debtAsset, \n        amounts[0], \n        neededForFlashLoanDebt, \n        useEthPath \n      ); \n    } else { \n      // Pull aTokens from user \n      _pullAToken( \n        collateralAsset, \n        collateralReserveData.aTokenAddress, \n        initiator, \n        repaidAmount.add(premium), \n        permitSignature \n      ); \n    } \n \n    // Repay flashloan. Approves for 0 first to comply with tokens that implement the anti frontrunni\n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), 0); \n    IERC20(debtAsset).safeApprove(address(LENDING_POOL), amount.add(premium)); \n  } \n \n  /** \n   * @dev Decodes debt information encoded in the flash loan params \n   * @param params Additional variadic field to include extra params. Expected parameters: \n   *   address collateralAsset Address of the reserve to be swapped \n   *   uint256 collateralAmount Amount of reserve to be swapped \n   *   uint256 rateMode Rate modes of the debt to be repaid \n   *   uint256 permitAmount Amount for the permit signature \n   *   uint256 deadline Deadline for the permit signature \n   *   uint8 v V param for the permit signature \n   *   bytes32 r R param for the permit signature \n   *   bytes32 s S param for the permit signature \n   *   bool useEthPath use WETH path route \n   * @return RepayParams struct containing decoded params \n   */ \n  function _decodeParams(bytes memory params) internal pure returns (RepayParams memory) { \n    ( \n      address collateralAsset, \n      uint256 collateralAmount, \n      uint256 rateMode, \n      uint256 permitAmount, \n      uint256 deadline, \n      uint8 v, \n      bytes32 r, \n      bytes32 s, \n      bool useEthPath \n    ) = \n      abi.decode( \n        params, \n        (address, uint256, uint256, uint256, uint256, uint8, bytes32, bytes32, bool) \n      ); \n \n    return \n      RepayParams( \n        collateralAsset, \n        collateralAmount, \n        rateMode, \n        PermitSignature(permitAmount, deadline, v, r, s), \n        useEthPath \n      ); \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {BaseUniswapAdapter} from './BaseUniswapAdapter.sol'; \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \nimport {Helpers} from '../protocol/libraries/helpers/Helpers.sol'; \nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol'; \nimport {IAToken} from '../interfaces/IAToken.sol'; \nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol'; \n \n/** \n * @title UniswapLiquiditySwapAdapter \n * @notice Uniswap V2 Adapter to swap liquidity. \n * @author Aave \n **/ \ncontract FlashLiquidationAdapter is BaseUniswapAdapter { \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  uint256 internal constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000; \n \n  struct LiquidationParams { \n    address collateralAsset; \n    address borrowedAsset; \n    address user; \n    uint256 debtToCover; \n    bool useEthPath; \n  } \n \n  struct LiquidationCallLocalVars { \n    uint256 initFlashBorrowedBalance; \n    uint256 diffFlashBorrowedBalance; \n    uint256 initCollateralBalance; \n    uint256 diffCollateralBalance; \n    uint256 flashLoanDebt; \n    uint256 soldAmount; \n    uint256 remainingTokens; \n    uint256 borrowedAssetLeftovers; \n  } \n \n  constructor( \n    ILendingPoolAddressesProvider addressesProvider, \n    IUniswapV2Router02 uniswapRouter, \n    address wethAddress \n  ) public BaseUniswapAdapter(addressesProvider, uniswapRouter, wethAddress) {} \n \n  /** \n   * @dev Liquidate a non-healthy position collateral-wise, with a Health Factor below 1, using Flash \n   * - The caller (liquidator) with a flash loan covers `debtToCover` amount of debt of the user gett\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk minus the f\n   * @param assets Address of asset to be swapped \n   * @param amounts Amount of the asset to be swapped \n   * @param premiums Fee of the flash loan \n   * @param initiator Address of the caller \n   * @param params Additional variadic field to include extra params. Expected parameters: \n   *   address collateralAsset The collateral asset to release and will be exchanged to pay the flash \n   *   address borrowedAsset The asset that must be covered \n   *   address user The user address with a Health Factor below 1 \n   *   uint256 debtToCover The amount of debt to cover \n   *   bool useEthPath Use WETH as connector path between the collateralAsset and borrowedAsset at Un\n   */ \n  function executeOperation( \n    address[] calldata assets, \n    uint256[] calldata amounts, \n    uint256[] calldata premiums, \n    address initiator, \n    bytes calldata params \n  ) external override returns (bool) { \n    require(msg.sender == address(LENDING_POOL), 'CALLER_MUST_BE_LENDING_POOL'); \n \n    LiquidationParams memory decodedParams = _decodeParams(params); \n \n    require(assets.length == 1 && assets[0] == decodedParams.borrowedAsset, 'INCONSISTENT_PARAMS'); \n \n    _liquidateAndSwap( \n      decodedParams.collateralAsset, \n      decodedParams.borrowedAsset, \n      decodedParams.user, \n      decodedParams.debtToCover, \n      decodedParams.useEthPath, \n      amounts[0], \n      premiums[0], \n      initiator \n    ); \n \n    return true; \n  } \n \n  /** \n   * @dev \n   * @param collateralAsset The collateral asset to release and will be exchanged to pay the flash lo\n   * @param borrowedAsset The asset that must be covered \n   * @param user The user address with a Health Factor below 1 \n   * @param debtToCover The amount of debt to coverage, can be max(-1) to liquidate all possible debt\n   * @param useEthPath true if the swap needs to occur using ETH in the routing, false otherwise \n   * @param flashBorrowedAmount Amount of asset requested at the flash loan to liquidate the user pos\n   * @param premium Fee of the requested flash loan \n   * @param initiator Address of the caller \n   */ \n  function _liquidateAndSwap( \n    address collateralAsset, \n    address borrowedAsset, \n    address user, \n    uint256 debtToCover, \n    bool useEthPath, \n    uint256 flashBorrowedAmount, \n    uint256 premium, \n    address initiator \n  ) internal { \n    LiquidationCallLocalVars memory vars; \n    vars.initCollateralBalance = IERC20(collateralAsset).balanceOf(address(this)); \n    if (collateralAsset != borrowedAsset) { \n      vars.initFlashBorrowedBalance = IERC20(borrowedAsset).balanceOf(address(this)); \n \n      // Track leftover balance to rescue funds in case of external transfers into this contract \n      vars.borrowedAssetLeftovers = vars.initFlashBorrowedBalance.sub(flashBorrowedAmount); \n    } \n    vars.flashLoanDebt = flashBorrowedAmount.add(premium); \n \n    // Approve LendingPool to use debt token for liquidation \n    IERC20(borrowedAsset).approve(address(LENDING_POOL), debtToCover); \n \n    // Liquidate the user position and release the underlying collateral \n    LENDING_POOL.liquidationCall(collateralAsset, borrowedAsset, user, debtToCover, false); \n \n    // Discover the liquidated tokens \n    uint256 collateralBalanceAfter = IERC20(collateralAsset).balanceOf(address(this)); \n \n    // Track only collateral released, not current asset balance of the contract \n    vars.diffCollateralBalance = collateralBalanceAfter.sub(vars.initCollateralBalance); \n \n    if (collateralAsset != borrowedAsset) { \n      // Discover flash loan balance after the liquidation \n      uint256 flashBorrowedAssetAfter = IERC20(borrowedAsset).balanceOf(address(this)); \n \n      // Use only flash loan borrowed assets, not current asset balance of the contract \n      vars.diffFlashBorrowedBalance = flashBorrowedAssetAfter.sub(vars.borrowedAssetLeftovers); \n \n      // Swap released collateral into the debt asset, to repay the flash loan \n      vars.soldAmount = _swapTokensForExactTokens( \n        collateralAsset, \n        borrowedAsset, \n        vars.diffCollateralBalance, \n        vars.flashLoanDebt.sub(vars.diffFlashBorrowedBalance), \n        useEthPath \n      ); \n      vars.remainingTokens = vars.diffCollateralBalance.sub(vars.soldAmount); \n    } else { \n      vars.remainingTokens = vars.diffCollateralBalance.sub(premium); \n    } \n \n    // Allow repay of flash loan \n    IERC20(borrowedAsset).approve(address(LENDING_POOL), vars.flashLoanDebt); \n \n    // Transfer remaining tokens to initiator \n    if (vars.remainingTokens > 0) { \n      IERC20(collateralAsset).transfer(initiator, vars.remainingTokens); \n    } \n  } \n \n  /** \n   * @dev Decodes the information encoded in the flash loan params \n   * @param params Additional variadic field to include extra params. Expected parameters: \n   *   address collateralAsset The collateral asset to claim \n   *   address borrowedAsset The asset that must be covered and will be exchanged to pay the flash lo\n   *   address user The user address with a Health Factor below 1 \n   *   uint256 debtToCover The amount of debt to cover \n   *   bool useEthPath Use WETH as connector path between the collateralAsset and borrowedAsset at Un\n   * @return LiquidationParams struct containing decoded params \n   */ \n  function _decodeParams(bytes memory params) internal pure returns (LiquidationParams memory) { \n    ( \n      address collateralAsset, \n      address borrowedAsset, \n      address user, \n      uint256 debtToCover, \n      bool useEthPath \n    ) = abi.decode(params, (address, address, address, uint256, bool)); \n \n    return LiquidationParams(collateralAsset, borrowedAsset, user, debtToCover, useEthPath); \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {PercentageMath} from '../protocol/libraries/math/PercentageMath.sol'; \nimport {SafeMath} from '../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol'; \nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol'; \nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol'; \nimport {IERC20WithPermit} from '../interfaces/IERC20WithPermit.sol'; \nimport {FlashLoanReceiverBase} from '../flashloan/base/FlashLoanReceiverBase.sol'; \nimport {IBaseUniswapAdapter} from './interfaces/IBaseUniswapAdapter.sol'; \n \n/** \n * @title BaseUniswapAdapter \n * @notice Implements the logic for performing assets swaps in Uniswap V2 \n * @author Aave \n **/ \nabstract contract BaseUniswapAdapter is FlashLoanReceiverBase, IBaseUniswapAdapter, Ownable { \n  using SafeMath for uint256; \n  using PercentageMath for uint256; \n  using SafeERC20 for IERC20; \n \n  // Max slippage percent allowed \n  uint256 public constant override MAX_SLIPPAGE_PERCENT = 3000; // 30% \n  // FLash Loan fee set in lending pool \n  uint256 public constant override FLASHLOAN_PREMIUM_TOTAL = 9; \n  // USD oracle asset address \n  address public constant override USD_ADDRESS = 0x10F7Fc1F91Ba351f9C629c5947AD69bD03C05b96; \n \n  address public immutable override WETH_ADDRESS; \n  IPriceOracleGetter public immutable override ORACLE; \n  IUniswapV2Router02 public immutable override UNISWAP_ROUTER; \n \n  constructor( \n    ILendingPoolAddressesProvider addressesProvider, \n    IUniswapV2Router02 uniswapRouter, \n    address wethAddress \n  ) public FlashLoanReceiverBase(addressesProvider) { \n    ORACLE = IPriceOracleGetter(addressesProvider.getPriceOracle()); \n    UNISWAP_ROUTER = uniswapRouter; \n    WETH_ADDRESS = wethAddress; \n  } \n \n  /** \n   * @dev Given an input asset amount, returns the maximum output amount of the other asset and the p\n   * @param amountIn Amount of reserveIn \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @return uint256 Amount out of the reserveOut \n   * @return uint256 The price of out amount denominated in the reserveIn currency (18 decimals) \n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals) \n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n   */ \n  function getAmountsOut( \n    uint256 amountIn, \n    address reserveIn, \n    address reserveOut \n  ) \n    external \n    view \n    override \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256, \n      address[] memory \n    ) \n  { \n    AmountCalc memory results = _getAmountsOutData(reserveIn, reserveOut, amountIn); \n \n    return ( \n      results.calculatedAmount, \n      results.relativePrice, \n      results.amountInUsd, \n      results.amountOutUsd, \n      results.path \n    ); \n  } \n \n  /** \n   * @dev Returns the minimum input asset amount required to buy the given output asset amount and th\n   * @param amountOut Amount of reserveOut \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @return uint256 Amount in of the reserveIn \n   * @return uint256 The price of in amount denominated in the reserveOut currency (18 decimals) \n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals) \n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n   */ \n  function getAmountsIn( \n    uint256 amountOut, \n    address reserveIn, \n    address reserveOut \n  ) \n    external \n    view \n    override \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256, \n      address[] memory \n    ) \n  { \n    AmountCalc memory results = _getAmountsInData(reserveIn, reserveOut, amountOut); \n \n    return ( \n      results.calculatedAmount, \n      results.relativePrice, \n      results.amountInUsd, \n      results.amountOutUsd, \n      results.path \n    ); \n  } \n \n  /** \n   * @dev Swaps an exact `amountToSwap` of an asset to another \n   * @param assetToSwapFrom Origin asset \n   * @param assetToSwapTo Destination asset \n   * @param amountToSwap Exact amount of `assetToSwapFrom` to be swapped \n   * @param minAmountOut the min amount of `assetToSwapTo` to be received from the swap \n   * @return the amount received from the swap \n   */ \n  function _swapExactTokensForTokens( \n    address assetToSwapFrom, \n    address assetToSwapTo, \n    uint256 amountToSwap, \n    uint256 minAmountOut, \n    bool useEthPath \n  ) internal returns (uint256) { \n    uint256 fromAssetDecimals = _getDecimals(assetToSwapFrom); \n    uint256 toAssetDecimals = _getDecimals(assetToSwapTo); \n \n    uint256 fromAssetPrice = _getPrice(assetToSwapFrom); \n    uint256 toAssetPrice = _getPrice(assetToSwapTo); \n \n    uint256 expectedMinAmountOut = \n      amountToSwap \n        .mul(fromAssetPrice.mul(10**toAssetDecimals)) \n        .div(toAssetPrice.mul(10**fromAssetDecimals)) \n        .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(MAX_SLIPPAGE_PERCENT)); \n \n    require(expectedMinAmountOut < minAmountOut, 'minAmountOut exceed max slippage'); \n \n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement \n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0); \n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), amountToSwap); \n \n    address[] memory path; \n    if (useEthPath) { \n      path = new address[](3); \n      path[0] = assetToSwapFrom; \n      path[1] = WETH_ADDRESS; \n      path[2] = assetToSwapTo; \n    } else { \n      path = new address[](2); \n      path[0] = assetToSwapFrom; \n      path[1] = assetToSwapTo; \n    } \n    uint256[] memory amounts = \n      UNISWAP_ROUTER.swapExactTokensForTokens( \n        amountToSwap, \n        minAmountOut, \n        path, \n        address(this), \n        block.timestamp \n      ); \n \n    emit Swapped(assetToSwapFrom, assetToSwapTo, amounts[0], amounts[amounts.length - 1]); \n \n    return amounts[amounts.length - 1]; \n  } \n \n  /** \n   * @dev Receive an exact amount `amountToReceive` of `assetToSwapTo` tokens for as few `assetToSwap\n   * possible. \n   * @param assetToSwapFrom Origin asset \n   * @param assetToSwapTo Destination asset \n   * @param maxAmountToSwap Max amount of `assetToSwapFrom` allowed to be swapped \n   * @param amountToReceive Exact amount of `assetToSwapTo` to receive \n   * @return the amount swapped \n   */ \n  function _swapTokensForExactTokens( \n    address assetToSwapFrom, \n    address assetToSwapTo, \n    uint256 maxAmountToSwap, \n    uint256 amountToReceive, \n    bool useEthPath \n  ) internal returns (uint256) { \n    uint256 fromAssetDecimals = _getDecimals(assetToSwapFrom); \n    uint256 toAssetDecimals = _getDecimals(assetToSwapTo); \n \n    uint256 fromAssetPrice = _getPrice(assetToSwapFrom); \n    uint256 toAssetPrice = _getPrice(assetToSwapTo); \n \n    uint256 expectedMaxAmountToSwap = \n      amountToReceive \n        .mul(toAssetPrice.mul(10**fromAssetDecimals)) \n        .div(fromAssetPrice.mul(10**toAssetDecimals)) \n        .percentMul(PercentageMath.PERCENTAGE_FACTOR.add(MAX_SLIPPAGE_PERCENT)); \n \n    require(maxAmountToSwap < expectedMaxAmountToSwap, 'maxAmountToSwap exceed max slippage'); \n \n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement \n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0); \n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), maxAmountToSwap); \n \n    address[] memory path; \n    if (useEthPath) { \n      path = new address[](3); \n      path[0] = assetToSwapFrom; \n      path[1] = WETH_ADDRESS; \n      path[2] = assetToSwapTo; \n    } else { \n      path = new address[](2); \n      path[0] = assetToSwapFrom; \n      path[1] = assetToSwapTo; \n    } \n \n    uint256[] memory amounts = \n      UNISWAP_ROUTER.swapTokensForExactTokens( \n        amountToReceive, \n        maxAmountToSwap, \n        path, \n        address(this), \n        block.timestamp \n      ); \n \n    emit Swapped(assetToSwapFrom, assetToSwapTo, amounts[0], amounts[amounts.length - 1]); \n \n    return amounts[0]; \n  } \n \n  /** \n   * @dev Get the price of the asset from the oracle denominated in eth \n   * @param asset address \n   * @return eth price for the asset \n   */ \n  function _getPrice(address asset) internal view returns (uint256) { \n    return ORACLE.getAssetPrice(asset); \n  } \n \n  /** \n   * @dev Get the decimals of an asset \n   * @return number of decimals of the asset \n   */ \n  function _getDecimals(address asset) internal view returns (uint256) { \n    return IERC20Detailed(asset).decimals(); \n  } \n \n  /** \n   * @dev Get the aToken associated to the asset \n   * @return address of the aToken \n   */ \n  function _getReserveData(address asset) internal view returns (DataTypes.ReserveData memory) { \n    return LENDING_POOL.getReserveData(asset); \n  } \n \n  /** \n   * @dev Pull the ATokens from the user \n   * @param reserve address of the asset \n   * @param reserveAToken address of the aToken of the reserve \n   * @param user address \n   * @param amount of tokens to be transferred to the contract \n   * @param permitSignature struct containing the permit signature \n   */ \n  function _pullAToken( \n    address reserve, \n    address reserveAToken, \n    address user, \n    uint256 amount, \n    PermitSignature memory permitSignature \n  ) internal { \n    if (_usePermit(permitSignature)) { \n      IERC20WithPermit(reserveAToken).permit( \n        user, \n        address(this), \n        permitSignature.amount, \n        permitSignature.deadline, \n        permitSignature.v, \n        permitSignature.r, \n        permitSignature.s \n      ); \n    } \n \n    // transfer from user to adapter \n    IERC20(reserveAToken).safeTransferFrom(user, address(this), amount); \n \n    // withdraw reserve \n    LENDING_POOL.withdraw(reserve, amount, address(this)); \n  } \n \n  /** \n   * @dev Tells if the permit method should be called by inspecting if there is a valid signature. \n   * If signature params are set to 0, then permit won't be called. \n   * @param signature struct containing the permit signature \n   * @return whether or not permit should be called \n   */ \n  function _usePermit(PermitSignature memory signature) internal pure returns (bool) { \n    return \n      !(uint256(signature.deadline) == uint256(signature.v) && uint256(signature.deadline) == 0); \n  } \n \n  /** \n   * @dev Calculates the value denominated in USD \n   * @param reserve Address of the reserve \n   * @param amount Amount of the reserve \n   * @param decimals Decimals of the reserve \n   * @return whether or not permit should be called \n   */ \n  function _calcUsdValue( \n    address reserve, \n    uint256 amount, \n    uint256 decimals \n  ) internal view returns (uint256) { \n    uint256 ethUsdPrice = _getPrice(USD_ADDRESS); \n    uint256 reservePrice = _getPrice(reserve); \n \n    return amount.mul(reservePrice).div(10**decimals).mul(ethUsdPrice).div(10**18); \n  } \n \n  /** \n   * @dev Given an input asset amount, returns the maximum output amount of the other asset \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @param amountIn Amount of reserveIn \n   * @return Struct containing the following information: \n   *   uint256 Amount out of the reserveOut \n   *   uint256 The price of out amount denominated in the reserveIn currency (18 decimals) \n   *   uint256 In amount of reserveIn value denominated in USD (8 decimals) \n   *   uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n   */ \n  function _getAmountsOutData( \n    address reserveIn, \n    address reserveOut, \n    uint256 amountIn \n  ) internal view returns (AmountCalc memory) { \n    // Subtract flash loan fee \n    uint256 finalAmountIn = amountIn.sub(amountIn.mul(FLASHLOAN_PREMIUM_TOTAL).div(10000)); \n \n    if (reserveIn == reserveOut) { \n      uint256 reserveDecimals = _getDecimals(reserveIn); \n      address[] memory path = new address[](1); \n      path[0] = reserveIn; \n \n      return \n        AmountCalc( \n          finalAmountIn, \n          finalAmountIn.mul(10**18).div(amountIn), \n          _calcUsdValue(reserveIn, amountIn, reserveDecimals), \n          _calcUsdValue(reserveIn, finalAmountIn, reserveDecimals), \n          path \n        ); \n    } \n \n    address[] memory simplePath = new address[](2); \n    simplePath[0] = reserveIn; \n    simplePath[1] = reserveOut; \n \n    uint256[] memory amountsWithoutWeth; \n    uint256[] memory amountsWithWeth; \n \n    address[] memory pathWithWeth = new address[](3); \n    if (reserveIn != WETH_ADDRESS && reserveOut != WETH_ADDRESS) { \n      pathWithWeth[0] = reserveIn; \n      pathWithWeth[1] = WETH_ADDRESS; \n      pathWithWeth[2] = reserveOut; \n \n      try UNISWAP_ROUTER.getAmountsOut(finalAmountIn, pathWithWeth) returns ( \n        uint256[] memory resultsWithWeth \n      ) { \n        amountsWithWeth = resultsWithWeth; \n      } catch { \n        amountsWithWeth = new uint256[](3); \n      } \n    } else { \n      amountsWithWeth = new uint256[](3); \n    } \n \n    uint256 bestAmountOut; \n    try UNISWAP_ROUTER.getAmountsOut(finalAmountIn, simplePath) returns ( \n      uint256[] memory resultAmounts \n    ) { \n      amountsWithoutWeth = resultAmounts; \n \n      bestAmountOut = (amountsWithWeth[2] > amountsWithoutWeth[1]) \n        ? amountsWithWeth[2] \n        : amountsWithoutWeth[1]; \n    } catch { \n      amountsWithoutWeth = new uint256[](2); \n      bestAmountOut = amountsWithWeth[2]; \n    } \n \n    uint256 reserveInDecimals = _getDecimals(reserveIn); \n    uint256 reserveOutDecimals = _getDecimals(reserveOut); \n \n    uint256 outPerInPrice = \n      finalAmountIn.mul(10**18).mul(10**reserveOutDecimals).div( \n        bestAmountOut.mul(10**reserveInDecimals) \n      ); \n \n    return \n      AmountCalc( \n        bestAmountOut, \n        outPerInPrice, \n        _calcUsdValue(reserveIn, amountIn, reserveInDecimals), \n        _calcUsdValue(reserveOut, bestAmountOut, reserveOutDecimals), \n        (bestAmountOut == 0) ? new address[](2) : (bestAmountOut == amountsWithoutWeth[1]) \n          ? simplePath \n          : pathWithWeth \n      ); \n  } \n \n  /** \n   * @dev Returns the minimum input asset amount required to buy the given output asset amount \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @param amountOut Amount of reserveOut \n   * @return Struct containing the following information: \n   *   uint256 Amount in of the reserveIn \n   *   uint256 The price of in amount denominated in the reserveOut currency (18 decimals) \n   *   uint256 In amount of reserveIn value denominated in USD (8 decimals) \n   *   uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n   */ \n  function _getAmountsInData( \n    address reserveIn, \n    address reserveOut, \n    uint256 amountOut \n  ) internal view returns (AmountCalc memory) { \n    if (reserveIn == reserveOut) { \n      // Add flash loan fee \n      uint256 amountIn = amountOut.add(amountOut.mul(FLASHLOAN_PREMIUM_TOTAL).div(10000)); \n      uint256 reserveDecimals = _getDecimals(reserveIn); \n      address[] memory path = new address[](1); \n      path[0] = reserveIn; \n \n      return \n        AmountCalc( \n          amountIn, \n          amountOut.mul(10**18).div(amountIn), \n          _calcUsdValue(reserveIn, amountIn, reserveDecimals), \n          _calcUsdValue(reserveIn, amountOut, reserveDecimals), \n          path \n        ); \n    } \n \n    (uint256[] memory amounts, address[] memory path) = \n      _getAmountsInAndPath(reserveIn, reserveOut, amountOut); \n \n    // Add flash loan fee \n    uint256 finalAmountIn = amounts[0].add(amounts[0].mul(FLASHLOAN_PREMIUM_TOTAL).div(10000)); \n \n    uint256 reserveInDecimals = _getDecimals(reserveIn); \n    uint256 reserveOutDecimals = _getDecimals(reserveOut); \n \n    uint256 inPerOutPrice = \n      amountOut.mul(10**18).mul(10**reserveInDecimals).div( \n        finalAmountIn.mul(10**reserveOutDecimals) \n      ); \n \n    return \n      AmountCalc( \n        finalAmountIn, \n        inPerOutPrice, \n        _calcUsdValue(reserveIn, finalAmountIn, reserveInDecimals), \n        _calcUsdValue(reserveOut, amountOut, reserveOutDecimals), \n        path \n      ); \n  } \n \n  /** \n   * @dev Calculates the input asset amount required to buy the given output asset amount \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @param amountOut Amount of reserveOut \n   * @return uint256[] amounts Array containing the amountIn and amountOut for a swap \n   */ \n  function _getAmountsInAndPath( \n    address reserveIn, \n    address reserveOut, \n    uint256 amountOut \n  ) internal view returns (uint256[] memory, address[] memory) { \n    address[] memory simplePath = new address[](2); \n    simplePath[0] = reserveIn; \n    simplePath[1] = reserveOut; \n \n    uint256[] memory amountsWithoutWeth; \n    uint256[] memory amountsWithWeth; \n    address[] memory pathWithWeth = new address[](3); \n \n    if (reserveIn != WETH_ADDRESS && reserveOut != WETH_ADDRESS) { \n      pathWithWeth[0] = reserveIn; \n      pathWithWeth[1] = WETH_ADDRESS; \n      pathWithWeth[2] = reserveOut; \n \n      try UNISWAP_ROUTER.getAmountsIn(amountOut, pathWithWeth) returns ( \n        uint256[] memory resultsWithWeth \n      ) { \n        amountsWithWeth = resultsWithWeth; \n      } catch { \n        amountsWithWeth = new uint256[](3); \n      } \n    } else { \n      amountsWithWeth = new uint256[](3); \n    } \n \n    try UNISWAP_ROUTER.getAmountsIn(amountOut, simplePath) returns ( \n      uint256[] memory resultAmounts \n    ) { \n      amountsWithoutWeth = resultAmounts; \n \n      return \n        (amountsWithWeth[0] < amountsWithoutWeth[0] && amountsWithWeth[0] != 0) \n          ? (amountsWithWeth, pathWithWeth) \n          : (amountsWithoutWeth, simplePath); \n    } catch { \n      return (amountsWithWeth, pathWithWeth); \n    } \n  } \n \n  /** \n   * @dev Calculates the input asset amount required to buy the given output asset amount \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @param amountOut Amount of reserveOut \n   * @return uint256[] amounts Array containing the amountIn and amountOut for a swap \n   */ \n  function _getAmountsIn( \n    address reserveIn, \n    address reserveOut, \n    uint256 amountOut, \n    bool useEthPath \n  ) internal view returns (uint256[] memory) { \n    address[] memory path; \n \n    if (useEthPath) { \n      path = new address[](3); \n      path[0] = reserveIn; \n      path[1] = WETH_ADDRESS; \n      path[2] = reserveOut; \n    } else { \n      path = new address[](2); \n      path[0] = reserveIn; \n      path[1] = reserveOut; \n    } \n \n    return UNISWAP_ROUTER.getAmountsIn(amountOut, path); \n  } \n \n  /** \n   * @dev Emergency rescue for token stucked on this contract, as failsafe mechanism \n   * - Funds should never remain in this contract more time than during transactions \n   * - Only callable by the owner \n   **/ \n  function rescueTokens(IERC20 token) external onlyOwner { \n    token.transfer(owner(), token.balanceOf(address(this))); \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {Address} from '../../dependencies/openzeppelin/contracts/Address.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {IAToken} from '../../interfaces/IAToken.sol'; \nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol'; \nimport {IFlashLoanReceiver} from '../../flashloan/interfaces/IFlashLoanReceiver.sol'; \nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol'; \nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol'; \nimport {Helpers} from '../libraries/helpers/Helpers.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {WadRayMath} from '../libraries/math/WadRayMath.sol'; \nimport {PercentageMath} from '../libraries/math/PercentageMath.sol'; \nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol'; \nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol'; \nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol'; \nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol'; \nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol'; \nimport {DataTypes} from '../libraries/types/DataTypes.sol'; \nimport {LendingPoolStorage} from './LendingPoolStorage.sol'; \n \n/** \n * @title LendingPool contract \n * @dev Main point of interaction with an Aave protocol's market \n * - Users can: \n *   # Deposit \n *   # Withdraw \n *   # Borrow \n *   # Repay \n *   # Swap their loans between variable and stable rate \n *   # Enable/disable their deposits as collateral rebalance stable rate borrow positions \n *   # Liquidate positions \n *   # Execute Flash Loans \n * - To be covered by a proxy contract, owned by the LendingPoolAddressesProvider of the specific mar\n * - All admin functions are callable by the LendingPoolConfigurator contract defined also in the \n *   LendingPoolAddressesProvider \n * @author Aave \n **/ \ncontract LendingPool is VersionedInitializable, ILendingPool, LendingPoolStorage { \n  using SafeMath for uint256; \n  using WadRayMath for uint256; \n  using PercentageMath for uint256; \n  using SafeERC20 for IERC20; \n \n  uint256 public constant LENDINGPOOL_REVISION = 0x2; \n \n  modifier whenNotPaused() { \n    _whenNotPaused(); \n    _; \n  } \n \n  modifier onlyLendingPoolConfigurator() { \n    _onlyLendingPoolConfigurator(); \n    _; \n  } \n \n  function _whenNotPaused() internal view { \n    require(!_paused, Errors.LP_IS_PAUSED); \n  } \n \n  function _onlyLendingPoolConfigurator() internal view { \n    require( \n      _addressesProvider.getLendingPoolConfigurator() == msg.sender, \n      Errors.LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR \n    ); \n  } \n \n  function getRevision() internal pure override returns (uint256) { \n    return LENDINGPOOL_REVISION; \n  } \n \n  /** \n   * @dev Function is invoked by the proxy contract when the LendingPool contract is added to the \n   * LendingPoolAddressesProvider of the market. \n   * - Caching the address of the LendingPoolAddressesProvider in order to reduce gas consumption \n   *   on subsequent operations \n   * @param provider The address of the LendingPoolAddressesProvider \n   **/ \n  function initialize(ILendingPoolAddressesProvider provider) public initializer { \n    _addressesProvider = provider; \n    _maxStableRateBorrowSizePercent = 2500; \n    _flashLoanPremiumTotal = 9; \n    _maxNumberOfReserves = 128; \n  } \n \n  /** \n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aT\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC \n   * @param asset The address of the underlying asset to deposit \n   * @param amount The amount to be deposited \n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user \n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens \n   *   is a different wallet \n   * @param referralCode Code used to register the integrator originating the operation, for potentia\n   *   0 if the action is executed directly by the user, without any middle-man \n   **/ \n  function deposit( \n    address asset, \n    uint256 amount, \n    address onBehalfOf, \n    uint16 referralCode \n  ) external override whenNotPaused { \n    DataTypes.ReserveData storage reserve = _reserves[asset]; \n \n    ValidationLogic.validateDeposit(reserve, amount); \n \n    address aToken = reserve.aTokenAddress; \n \n    reserve.updateState(); \n    reserve.updateInterestRates(asset, aToken, amount, 0); \n \n    IERC20(asset).safeTransferFrom(msg.sender, aToken, amount); \n \n    bool isFirstDeposit = IAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex); \n \n    if (isFirstDeposit) { \n      _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true); \n      emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf); \n    } \n \n    emit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode); \n  } \n \n  /** \n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens \n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC \n   * @param asset The address of the underlying asset to withdraw \n   * @param amount The underlying amount to be withdrawn \n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance \n   * @param to Address that will receive the underlying, same as msg.sender if the user \n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a \n   *   different wallet \n   * @return The final amount withdrawn \n   **/ \n  function withdraw( \n    address asset, \n    uint256 amount, \n    address to \n  ) external override whenNotPaused returns (uint256) { \n    DataTypes.ReserveData storage reserve = _reserves[asset]; \n \n    address aToken = reserve.aTokenAddress; \n \n    uint256 userBalance = IAToken(aToken).balanceOf(msg.sender); \n \n    uint256 amountToWithdraw = amount; \n \n    if (amount == type(uint256).max) { \n      amountToWithdraw = userBalance; \n    } \n \n    ValidationLogic.validateWithdraw( \n      asset, \n      amountToWithdraw, \n      userBalance, \n      _reserves, \n      _usersConfig[msg.sender], \n      _reservesList, \n      _reservesCount, \n      _addressesProvider.getPriceOracle() \n    ); \n \n    reserve.updateState(); \n \n    reserve.updateInterestRates(asset, aToken, 0, amountToWithdraw); \n \n    if (amountToWithdraw == userBalance) { \n      _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false); \n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender); \n    } \n \n    IAToken(aToken).burn(msg.sender, to, amountToWithdraw, reserve.liquidityIndex); \n \n    emit Withdraw(asset, msg.sender, to, amountToWithdraw); \n \n    return amountToWithdraw; \n  } \n \n  /** \n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that t\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on t\n   * corresponding debt token (StableDebtToken or VariableDebtToken) \n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in \n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode` \n   * @param asset The address of the underlying asset to borrow \n   * @param amount The amount to be borrowed \n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, \n   * @param referralCode Code used to register the integrator originating the operation, for potentia\n   *   0 if the action is executed directly by the user, without any middle-man \n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the bo\n   * calling the function if he wants to borrow against his own collateral, or the address of the cre\n   * if he has been given credit delegation allowance \n   **/ \n  function borrow( \n    address asset, \n    uint256 amount, \n    uint256 interestRateMode, \n    uint16 referralCode, \n    address onBehalfOf \n  ) external override whenNotPaused { \n    DataTypes.ReserveData storage reserve = _reserves[asset]; \n \n    _executeBorrow( \n      ExecuteBorrowParams( \n        asset, \n        msg.sender, \n        onBehalfOf, \n        amount, \n        interestRateMode, \n        reserve.aTokenAddress, \n        referralCode, \n        true \n      ) \n    ); \n  } \n \n  /** \n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens own\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed \n   * @param amount The amount to repay \n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific \n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 f\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the addre\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed \n   * @return The final amount repaid \n   **/ \n  function repay( \n    address asset, \n    uint256 amount, \n    uint256 rateMode, \n    address onBehalfOf \n  ) external override whenNotPaused returns (uint256) { \n    DataTypes.ReserveData storage reserve = _reserves[asset]; \n \n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve); \n \n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode); \n \n    ValidationLogic.validateRepay( \n      reserve, \n      amount, \n      interestRateMode, \n      onBehalfOf, \n      stableDebt, \n      variableDebt \n    ); \n \n    uint256 paybackAmount = \n      interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt; \n \n    if (amount < paybackAmount) { \n      paybackAmount = amount; \n    } \n \n    reserve.updateState(); \n \n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) { \n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount); \n    } else { \n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn( \n        onBehalfOf, \n        paybackAmount, \n        reserve.variableBorrowIndex \n      ); \n    } \n \n    address aToken = reserve.aTokenAddress; \n    reserve.updateInterestRates(asset, aToken, paybackAmount, 0); \n \n    if (stableDebt.add(variableDebt).sub(paybackAmount) == 0) { \n      _usersConfig[onBehalfOf].setBorrowing(reserve.id, false); \n    } \n \n    IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount); \n \n    IAToken(aToken).handleRepayment(msg.sender, paybackAmount); \n \n    emit Repay(asset, onBehalfOf, msg.sender, paybackAmount); \n \n    return paybackAmount; \n  } \n \n  /** \n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa \n   * @param asset The address of the underlying asset borrowed \n   * @param rateMode The rate mode that the user wants to swap to \n   **/ \n  function swapBorrowRateMode(address asset, uint256 rateMode) external override whenNotPaused { \n    DataTypes.ReserveData storage reserve = _reserves[asset]; \n \n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserve); \n \n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode); \n \n    ValidationLogic.validateSwapRateMode( \n      reserve, \n      _usersConfig[msg.sender], \n      stableDebt, \n      variableDebt, \n      interestRateMode \n    ); \n \n    reserve.updateState(); \n \n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) { \n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(msg.sender, stableDebt); \n      IVariableDebtToken(reserve.variableDebtTokenAddress).mint( \n        msg.sender, \n        msg.sender, \n        stableDebt, \n        reserve.variableBorrowIndex \n      ); \n    } else { \n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn( \n        msg.sender, \n        variableDebt, \n        reserve.variableBorrowIndex \n      ); \n      IStableDebtToken(reserve.stableDebtTokenAddress).mint( \n        msg.sender, \n        msg.sender, \n        variableDebt, \n        reserve.currentStableBorrowRate \n      ); \n    } \n \n    reserve.updateInterestRates(asset, reserve.aTokenAddress, 0, 0); \n \n    emit Swap(asset, msg.sender, rateMode); \n  } \n \n  /** \n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the res\n   * - Users can be rebalanced if the following conditions are satisfied: \n   *     1. Usage ratio is above 95% \n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which me\n   *        borrowed at a stable rate and depositors are not earning enough \n   * @param asset The address of the underlying asset borrowed \n   * @param user The address of the user to be rebalanced \n   **/ \n  function rebalanceStableBorrowRate(address asset, address user) external override whenNotPaused { \n    DataTypes.ReserveData storage reserve = _reserves[asset]; \n \n    IERC20 stableDebtToken = IERC20(reserve.stableDebtTokenAddress); \n    IERC20 variableDebtToken = IERC20(reserve.variableDebtTokenAddress); \n    address aTokenAddress = reserve.aTokenAddress; \n \n    uint256 stableDebt = IERC20(stableDebtToken).balanceOf(user); \n \n    ValidationLogic.validateRebalanceStableBorrowRate( \n      reserve, \n      asset, \n      stableDebtToken, \n      variableDebtToken, \n      aTokenAddress \n    ); \n \n    reserve.updateState(); \n \n    IStableDebtToken(address(stableDebtToken)).burn(user, stableDebt); \n    IStableDebtToken(address(stableDebtToken)).mint( \n      user, \n      user, \n      stableDebt, \n      reserve.currentStableBorrowRate \n    ); \n \n    reserve.updateInterestRates(asset, aTokenAddress, 0, 0); \n \n    emit RebalanceStableBorrowRate(asset, user); \n  } \n \n  /** \n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral \n   * @param asset The address of the underlying asset deposited \n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherw\n   **/ \n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) \n    external \n    override \n    whenNotPaused \n  { \n    DataTypes.ReserveData storage reserve = _reserves[asset]; \n \n    ValidationLogic.validateSetUseReserveAsCollateral( \n      reserve, \n      asset, \n      useAsCollateral, \n      _reserves, \n      _usersConfig[msg.sender], \n      _reservesList, \n      _reservesCount, \n      _addressesProvider.getPriceOracle() \n    ); \n \n    _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, useAsCollateral); \n \n    if (useAsCollateral) { \n      emit ReserveUsedAsCollateralEnabled(asset, msg.sender); \n    } else { \n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender); \n    } \n  } \n \n  /** \n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 \n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, an\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk \n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as res\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation \n   * @param user The address of the borrower getting liquidated \n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover \n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` \n   * to receive the underlying collateral asset directly \n   **/ \n  function liquidationCall( \n    address collateralAsset, \n    address debtAsset, \n    address user, \n    uint256 debtToCover, \n    bool receiveAToken \n  ) external override whenNotPaused { \n    address collateralManager = _addressesProvider.getLendingPoolCollateralManager(); \n \n    //solium-disable-next-line \n    (bool success, bytes memory result) = \n      collateralManager.delegatecall( \n        abi.encodeWithSignature( \n          'liquidationCall(address,address,address,uint256,bool)', \n          collateralAsset, \n          debtAsset, \n          user, \n          debtToCover, \n          receiveAToken \n        ) \n      ); \n \n    require(success, Errors.LP_LIQUIDATION_CALL_FAILED); \n \n    (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string)); \n \n    require(returnCode == 0, string(abi.encodePacked(returnMessage))); \n  } \n \n  struct FlashLoanLocalVars { \n    IFlashLoanReceiver receiver; \n    address oracle; \n    uint256 i; \n    address currentAsset; \n    address currentATokenAddress; \n    uint256 currentAmount; \n    uint256 currentPremium; \n    uint256 currentAmountPlusPremium; \n    address debtToken; \n  } \n \n  /** \n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction, \n   * as long as the amount taken plus a fee is returned. \n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must b\n   * For further details please visit https://developers.aave.com \n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashL\n   * @param assets The addresses of the assets being flash-borrowed \n   * @param amounts The amounts amounts being flash-borrowed \n   * @param modes Types of the debt to open if the flash loan is not returned: \n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver \n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` a\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` \n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information \n   * @param referralCode Code used to register the integrator originating the operation, for potentia\n   *   0 if the action is executed directly by the user, without any middle-man \n   **/ \n  function flashLoan( \n    address receiverAddress, \n    address[] calldata assets, \n    uint256[] calldata amounts, \n    uint256[] calldata modes, \n    address onBehalfOf, \n    bytes calldata params, \n    uint16 referralCode \n  ) external override whenNotPaused { \n    FlashLoanLocalVars memory vars; \n \n    ValidationLogic.validateFlashloan(assets, amounts); \n \n    address[] memory aTokenAddresses = new address[](assets.length); \n    uint256[] memory premiums = new uint256[](assets.length); \n \n    vars.receiver = IFlashLoanReceiver(receiverAddress); \n \n    for (vars.i = 0; vars.i < assets.length; vars.i++) { \n      aTokenAddresses[vars.i] = _reserves[assets[vars.i]].aTokenAddress; \n \n      premiums[vars.i] = amounts[vars.i].mul(_flashLoanPremiumTotal).div(10000); \n \n      IAToken(aTokenAddresses[vars.i]).transferUnderlyingTo(receiverAddress, amounts[vars.i]); \n    } \n \n    require( \n      vars.receiver.executeOperation(assets, amounts, premiums, msg.sender, params), \n      Errors.LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN \n    ); \n \n    for (vars.i = 0; vars.i < assets.length; vars.i++) { \n      vars.currentAsset = assets[vars.i]; \n      vars.currentAmount = amounts[vars.i]; \n      vars.currentPremium = premiums[vars.i]; \n      vars.currentATokenAddress = aTokenAddresses[vars.i]; \n      vars.currentAmountPlusPremium = vars.currentAmount.add(vars.currentPremium); \n \n      if (DataTypes.InterestRateMode(modes[vars.i]) == DataTypes.InterestRateMode.NONE) { \n        _reserves[vars.currentAsset].updateState(); \n        _reserves[vars.currentAsset].cumulateToLiquidityIndex( \n          IERC20(vars.currentATokenAddress).totalSupply(), \n          vars.currentPremium \n        ); \n        _reserves[vars.currentAsset].updateInterestRates( \n          vars.currentAsset, \n          vars.currentATokenAddress, \n          vars.currentAmountPlusPremium, \n        ); \n \n        IERC20(vars.currentAsset).safeTransferFrom( \n          receiverAddress, \n          vars.currentATokenAddress, \n          vars.currentAmountPlusPremium \n        ); \n      } else { \n        // If the user chose to not return the funds, the system checks if there is enough collateral \n        // eventually opens a debt position \n        _executeBorrow( \n          ExecuteBorrowParams( \n            vars.currentAsset, \n            msg.sender, \n            onBehalfOf, \n            vars.currentAmount, \n            modes[vars.i], \n            vars.currentATokenAddress, \n            referralCode, \n            false \n          ) \n        ); \n      } \n      emit FlashLoan( \n        receiverAddress, \n        msg.sender, \n        vars.currentAsset, \n        vars.currentAmount, \n        vars.currentPremium, \n        referralCode \n      ); \n    } \n  } \n \n  /** \n   * @dev Returns the state and configuration of the reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @return The state of the reserve \n   **/ \n  function getReserveData(address asset) \n    external \n    view \n    override \n    returns (DataTypes.ReserveData memory) \n  { \n    return _reserves[asset]; \n  } \n \n  /** \n   * @dev Returns the user account data across all the reserves \n   * @param user The address of the user \n   * @return totalCollateralETH the total collateral in ETH of the user \n   * @return totalDebtETH the total debt in ETH of the user \n   * @return availableBorrowsETH the borrowing power left of the user \n   * @return currentLiquidationThreshold the liquidation threshold of the user \n   * @return ltv the loan to value of the user \n   * @return healthFactor the current health factor of the user \n   **/ \n  function getUserAccountData(address user) \n    external \n    view \n    override \n    returns ( \n      uint256 totalCollateralETH, \n      uint256 totalDebtETH, \n      uint256 availableBorrowsETH, \n      uint256 currentLiquidationThreshold, \n      uint256 ltv, \n      uint256 healthFactor \n    ) \n  { \n    ( \n      totalCollateralETH, \n      totalDebtETH, \n      ltv, \n      currentLiquidationThreshold, \n      healthFactor \n    ) = GenericLogic.calculateUserAccountData( \n      user, \n      _reserves, \n      _usersConfig[user], \n      _reservesList, \n      _reservesCount, \n      _addressesProvider.getPriceOracle() \n    ); \n \n    availableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH( \n      totalCollateralETH, \n      totalDebtETH, \n      ltv \n    ); \n  } \n \n  /** \n   * @dev Returns the configuration of the reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @return The configuration of the reserve \n   **/ \n  function getConfiguration(address asset) \n    external \n    view \n    override \n    returns (DataTypes.ReserveConfigurationMap memory) \n  { \n    return _reserves[asset].configuration; \n  } \n \n  /** \n   * @dev Returns the configuration of the user across all the reserves \n   * @param user The user address \n   * @return The configuration of the user \n   **/ \n  function getUserConfiguration(address user) \n    external \n    view \n    override \n    returns (DataTypes.UserConfigurationMap memory) \n  { \n    return _usersConfig[user]; \n  } \n \n  /** \n   * @dev Returns the normalized income per unit of asset \n   * @param asset The address of the underlying asset of the reserve \n   * @return The reserve's normalized income \n   */ \n  function getReserveNormalizedIncome(address asset) \n    external \n    view \n    virtual \n    override \n    returns (uint256) \n  { \n    return _reserves[asset].getNormalizedIncome(); \n  } \n \n  /** \n   * @dev Returns the normalized variable debt per unit of asset \n   * @param asset The address of the underlying asset of the reserve \n   * @return The reserve normalized variable debt \n   */ \n  function getReserveNormalizedVariableDebt(address asset) \n    external \n    view \n    override \n    returns (uint256) \n  { \n    return _reserves[asset].getNormalizedDebt(); \n  } \n \n  /** \n   * @dev Returns if the LendingPool is paused \n   */ \n  function paused() external view override returns (bool) { \n    return _paused; \n  } \n \n  /** \n   * @dev Returns the list of the initialized reserves \n   **/ \n  function getReservesList() external view override returns (address[] memory) { \n    address[] memory _activeReserves = new address[](_reservesCount); \n \n    for (uint256 i = 0; i < _reservesCount; i++) { \n      _activeReserves[i] = _reservesList[i]; \n    } \n    return _activeReserves; \n  } \n \n  /** \n   * @dev Returns the cached LendingPoolAddressesProvider connected to this contract \n   **/ \n  function getAddressesProvider() external view override returns (ILendingPoolAddressesProvider) { \n    return _addressesProvider; \n  } \n \n  /** \n   * @dev Returns the percentage of available liquidity that can be borrowed at once at stable rate \n   */ \n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view returns (uint256) { \n    return _maxStableRateBorrowSizePercent; \n  } \n \n  /** \n   * @dev Returns the fee on flash loans  \n   */ \n  function FLASHLOAN_PREMIUM_TOTAL() public view returns (uint256) { \n    return _flashLoanPremiumTotal; \n  } \n \n  /** \n   * @dev Returns the maximum number of reserves supported to be listed in this LendingPool \n   */ \n  function MAX_NUMBER_RESERVES() public view returns (uint256) { \n    return _maxNumberOfReserves; \n  } \n \n  /** \n   * @dev Validates and finalizes an aToken transfer \n   * - Only callable by the overlying aToken of the `asset` \n   * @param asset The address of the underlying asset of the aToken \n   * @param from The user from which the aTokens are transferred \n   * @param to The user receiving the aTokens \n   * @param amount The amount being transferred/withdrawn \n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer \n   * @param balanceToBefore The aToken balance of the `to` user before the transfer \n   */ \n  function finalizeTransfer( \n    address asset, \n    address from, \n    address to, \n    uint256 amount, \n    uint256 balanceFromBefore, \n    uint256 balanceToBefore \n  ) external override whenNotPaused { \n    require(msg.sender == _reserves[asset].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN); \n \n    ValidationLogic.validateTransfer( \n      from, \n      _reserves, \n      _usersConfig[from], \n      _reservesList, \n      _reservesCount, \n      _addressesProvider.getPriceOracle() \n    ); \n \n    uint256 reserveId = _reserves[asset].id; \n \n    if (from != to) { \n      if (balanceFromBefore.sub(amount) == 0) { \n        DataTypes.UserConfigurationMap storage fromConfig = _usersConfig[from]; \n        fromConfig.setUsingAsCollateral(reserveId, false); \n        emit ReserveUsedAsCollateralDisabled(asset, from); \n      } \n \n      if (balanceToBefore == 0 && amount != 0) { \n        DataTypes.UserConfigurationMap storage toConfig = _usersConfig[to]; \n        toConfig.setUsingAsCollateral(reserveId, true); \n        emit ReserveUsedAsCollateralEnabled(asset, to); \n      } \n    } \n  } \n \n  /** \n   * @dev Initializes a reserve, activating it, assigning an aToken and debt tokens and an \n   * interest rate strategy \n   * - Only callable by the LendingPoolConfigurator contract \n   * @param asset The address of the underlying asset of the reserve \n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve \n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param aTokenAddress The address of the VariableDebtToken that will be assigned to the reserve \n   * @param interestRateStrategyAddress The address of the interest rate strategy contract \n   **/ \n  function initReserve( \n    address asset, \n    address aTokenAddress, \n    address stableDebtAddress, \n    address variableDebtAddress, \n    address interestRateStrategyAddress \n  ) external override onlyLendingPoolConfigurator { \n    require(Address.isContract(asset), Errors.LP_NOT_CONTRACT); \n    _reserves[asset].init( \n      aTokenAddress, \n      stableDebtAddress, \n      variableDebtAddress, \n      interestRateStrategyAddress \n    ); \n    _addReserveToList(asset); \n  } \n \n  /** \n   * @dev Updates the address of the interest rate strategy contract \n   * - Only callable by the LendingPoolConfigurator contract \n   * @param asset The address of the underlying asset of the reserve \n   * @param rateStrategyAddress The address of the interest rate strategy contract \n   **/ \n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) \n    external \n    override \n    onlyLendingPoolConfigurator \n  { \n    _reserves[asset].interestRateStrategyAddress = rateStrategyAddress; \n  } \n \n  /** \n   * @dev Sets the configuration bitmap of the reserve as a whole \n   * - Only callable by the LendingPoolConfigurator contract \n   * @param asset The address of the underlying asset of the reserve \n   * @param configuration The new configuration bitmap \n   **/ \n  function setConfiguration(address asset, uint256 configuration) \n    external \n    override \n    onlyLendingPoolConfigurator \n  { \n    _reserves[asset].configuration.data = configuration; \n  } \n \n  /** \n   * @dev Set the _pause state of a reserve \n   * - Only callable by the LendingPoolConfigurator contract \n   * @param val `true` to pause the reserve, `false` to un-pause it \n   */ \n  function setPause(bool val) external override onlyLendingPoolConfigurator { \n    _paused = val; \n    if (_paused) { \n      emit Paused(); \n    } else { \n      emit Unpaused(); \n    } \n  } \n \n  struct ExecuteBorrowParams { \n    address asset; \n    address user; \n    address onBehalfOf; \n    uint256 amount; \n    uint256 interestRateMode; \n    address aTokenAddress; \n    uint16 referralCode; \n    bool releaseUnderlying; \n  } \n \n  function _executeBorrow(ExecuteBorrowParams memory vars) internal { \n    DataTypes.ReserveData storage reserve = _reserves[vars.asset]; \n    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[vars.onBehalfOf]; \n \n    address oracle = _addressesProvider.getPriceOracle(); \n \n    uint256 amountInETH = \n      IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div( \n        10**reserve.configuration.getDecimals() \n      ); \n \n    ValidationLogic.validateBorrow( \n      vars.asset, \n      reserve, \n      vars.onBehalfOf, \n      vars.amount, \n      amountInETH, \n      vars.interestRateMode, \n      _maxStableRateBorrowSizePercent, \n      _reserves, \n      userConfig, \n      _reservesList, \n      _reservesCount, \n      oracle \n    ); \n \n    reserve.updateState(); \n \n    uint256 currentStableRate = 0; \n \n    bool isFirstBorrowing = false; \n    if (DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE) { \n      currentStableRate = reserve.currentStableBorrowRate; \n \n      isFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint( \n        vars.user, \n        vars.onBehalfOf, \n        vars.amount, \n        currentStableRate \n      ); \n    } else { \n      isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint( \n        vars.user, \n        vars.onBehalfOf, \n        vars.amount, \n        reserve.variableBorrowIndex \n      ); \n    } \n \n    if (isFirstBorrowing) { \n      userConfig.setBorrowing(reserve.id, true); \n    } \n \n    reserve.updateInterestRates( \n      vars.asset, \n      vars.aTokenAddress, \n      0, \n      vars.releaseUnderlying ? vars.amount : 0 \n    ); \n \n    if (vars.releaseUnderlying) { \n      IAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount); \n    } \n \n    emit Borrow( \n      vars.asset, \n      vars.user, \n      vars.onBehalfOf, \n      vars.amount, \n      vars.interestRateMode, \n      DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE \n        ? currentStableRate \n        : reserve.currentVariableBorrowRate, \n      vars.referralCode \n    ); \n  } \n \n  function _addReserveToList(address asset) internal { \n    uint256 reservesCount = _reservesCount; \n \n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED); \n \n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset; \n \n    if (!reserveAlreadyAdded) { \n      _reserves[asset].id = uint8(reservesCount); \n      _reservesList[reservesCount] = asset; \n \n      _reservesCount = reservesCount + 1; \n    } \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol'; \nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol'; \nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {DataTypes} from '../libraries/types/DataTypes.sol'; \n \ncontract LendingPoolStorage { \n  using ReserveLogic for DataTypes.ReserveData; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  ILendingPoolAddressesProvider internal _addressesProvider; \n \n  mapping(address => DataTypes.ReserveData) internal _reserves; \n  mapping(address => DataTypes.UserConfigurationMap) internal _usersConfig; \n \n  // the list of the available reserves, structured as a mapping for gas savings reasons \n  mapping(uint256 => address) internal _reservesList; \n \n  uint256 internal _reservesCount; \n \n  bool internal _paused; \n \n  uint256 internal _maxStableRateBorrowSizePercent; \n \n  uint256 internal _flashLoanPremiumTotal; \n \n  uint256 internal _maxNumberOfReserves; \n} \n",
            "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IReserveInterestRateStrategy} from '../../interfaces/IReserveInterestRateStrategy.sol'; \nimport {WadRayMath} from '../libraries/math/WadRayMath.sol'; \nimport {PercentageMath} from '../libraries/math/PercentageMath.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingRateOracle} from '../../interfaces/ILendingRateOracle.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport 'hardhat/console.sol'; \n \n/** \n * @title DefaultReserveInterestRateStrategy contract \n * @notice Implements the calculation of the interest rates depending on the reserve state \n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_UTILIZATION_RATE` \n * point of utilization and another from that one to 100% \n * - An instance of this same contract, can't be used across different Aave markets, due to the cachi\n *   of the LendingPoolAddressesProvider \n * @author Aave \n **/ \ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy { \n  using WadRayMath for uint256; \n  using SafeMath for uint256; \n  using PercentageMath for uint256; \n \n  /** \n   * @dev this constant represents the utilization rate at which the pool aims to obtain most competi\n   * Expressed in ray \n   **/ \n  uint256 public immutable OPTIMAL_UTILIZATION_RATE; \n \n  /** \n   * @dev This constant represents the excess utilization rate above the optimal. It's always equal t\n   * 1-optimal utilization rate. Added as a constant here for gas optimizations. \n   * Expressed in ray \n   **/ \n \n  uint256 public immutable EXCESS_UTILIZATION_RATE; \n \n  ILendingPoolAddressesProvider public immutable addressesProvider; \n \n  // Base variable borrow rate when Utilization rate = 0. Expressed in ray \n  uint256 internal immutable _baseVariableBorrowRate; \n \n  // Slope of the variable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. \n  uint256 internal immutable _variableRateSlope1; \n \n  // Slope of the variable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed \n  uint256 internal immutable _variableRateSlope2; \n \n  // Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Exp\n  uint256 internal immutable _stableRateSlope1; \n \n  // Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed i\n  uint256 internal immutable _stableRateSlope2; \n \n  constructor( \n    ILendingPoolAddressesProvider provider, \n    uint256 optimalUtilizationRate, \n    uint256 baseVariableBorrowRate, \n    uint256 variableRateSlope1, \n    uint256 variableRateSlope2, \n    uint256 stableRateSlope1, \n    uint256 stableRateSlope2 \n  ) public { \n    OPTIMAL_UTILIZATION_RATE = optimalUtilizationRate; \n    EXCESS_UTILIZATION_RATE = WadRayMath.ray().sub(optimalUtilizationRate); \n    addressesProvider = provider; \n    _baseVariableBorrowRate = baseVariableBorrowRate; \n    _variableRateSlope1 = variableRateSlope1; \n    _variableRateSlope2 = variableRateSlope2; \n    _stableRateSlope1 = stableRateSlope1; \n    _stableRateSlope2 = stableRateSlope2; \n  } \n \n  function variableRateSlope1() external view returns (uint256) { \n    return _variableRateSlope1; \n  } \n \n  function variableRateSlope2() external view returns (uint256) { \n    return _variableRateSlope2; \n  } \n \n  function stableRateSlope1() external view returns (uint256) { \n    return _stableRateSlope1; \n  } \n \n  function stableRateSlope2() external view returns (uint256) { \n    return _stableRateSlope2; \n  } \n \n  function baseVariableBorrowRate() external view override returns (uint256) { \n    return _baseVariableBorrowRate; \n  } \n \n  function getMaxVariableBorrowRate() external view override returns (uint256) { \n    return _baseVariableBorrowRate.add(_variableRateSlope1).add(_variableRateSlope2); \n  } \n \n  /** \n   * @dev Calculates the interest rates depending on the reserve's state and configurations \n   * @param reserve The address of the reserve \n   * @param liquidityAdded The liquidity added during the operation \n   * @param liquidityTaken The liquidity taken during the operation \n   * @param totalStableDebt The total borrowed from the reserve a stable rate \n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate \n   * @param averageStableBorrowRate The weighted average of all the stable rate loans \n   * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n   * @return The liquidity rate, the stable borrow rate and the variable borrow rate \n   **/ \n  function calculateInterestRates( \n    address reserve, \n    address aToken, \n    uint256 liquidityAdded, \n    uint256 liquidityTaken, \n    uint256 totalStableDebt, \n    uint256 totalVariableDebt, \n    uint256 averageStableBorrowRate, \n    uint256 reserveFactor \n  ) \n    external \n    view \n    override \n    returns ( \n      uint256, \n      uint256, \n      uint256 \n    ) \n  { \n    uint256 availableLiquidity = IERC20(reserve).balanceOf(aToken); \n    //avoid stack too deep \n    availableLiquidity = availableLiquidity.add(liquidityAdded).sub(liquidityTaken); \n \n    return \n      calculateInterestRates( \n        reserve, \n        availableLiquidity, \n        totalStableDebt, \n        totalVariableDebt, \n        averageStableBorrowRate, \n        reserveFactor \n      ); \n  } \n \n  struct CalcInterestRatesLocalVars { \n    uint256 totalDebt; \n    uint256 currentVariableBorrowRate; \n    uint256 currentStableBorrowRate; \n    uint256 currentLiquidityRate; \n    uint256 utilizationRate; \n  } \n \n  /** \n   * @dev Calculates the interest rates depending on the reserve's state and configurations. \n   * NOTE This function is kept for compatibility with the previous DefaultInterestRateStrategy inter\n   * New protocol implementation uses the new calculateInterestRates() interface \n   * @param reserve The address of the reserve \n   * @param availableLiquidity The liquidity available in the corresponding aToken \n   * @param totalStableDebt The total borrowed from the reserve a stable rate \n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate \n   * @param averageStableBorrowRate The weighted average of all the stable rate loans \n   * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n   * @return The liquidity rate, the stable borrow rate and the variable borrow rate \n   **/ \n  function calculateInterestRates( \n    address reserve, \n    uint256 availableLiquidity, \n    uint256 totalStableDebt, \n    uint256 totalVariableDebt, \n    uint256 averageStableBorrowRate, \n    uint256 reserveFactor \n  ) \n    public \n    view \n    override \n    returns ( \n      uint256, \n      uint256, \n      uint256 \n    ) \n  { \n    CalcInterestRatesLocalVars memory vars; \n \n    vars.totalDebt = totalStableDebt.add(totalVariableDebt); \n    vars.currentVariableBorrowRate = 0; \n    vars.currentStableBorrowRate = 0; \n    vars.currentLiquidityRate = 0; \n \n    vars.utilizationRate = vars.totalDebt == 0 \n      ? 0 \n      : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt)); \n \n    vars.currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle()) \n      .getMarketBorrowRate(reserve); \n \n    if (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) { \n      uint256 excessUtilizationRateRatio = \n        vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(EXCESS_UTILIZATION_RATE); \n \n      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(_stableRateSlope1).add( \n        _stableRateSlope2.rayMul(excessUtilizationRateRatio) \n      ); \n \n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add( \n        _variableRateSlope2.rayMul(excessUtilizationRateRatio) \n      ); \n    } else { \n      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add( \n        _stableRateSlope1.rayMul(vars.utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE)) \n      ); \n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add( \n        vars.utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE) \n      ); \n    } \n \n    vars.currentLiquidityRate = _getOverallBorrowRate( \n      totalStableDebt, \n      totalVariableDebt, \n      vars \n        .currentVariableBorrowRate, \n      averageStableBorrowRate \n    ) \n      .rayMul(vars.utilizationRate) \n      .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor)); \n \n    return ( \n      vars.currentLiquidityRate, \n      vars.currentStableBorrowRate, \n      vars.currentVariableBorrowRate \n    ); \n  } \n \n  /** \n   * @dev Calculates the overall borrow rate as the weighted average between the total variable debt \n   * @param totalStableDebt The total borrowed from the reserve a stable rate \n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate \n   * @param currentVariableBorrowRate The current variable borrow rate of the reserve \n   * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans \n   * @return The weighted averaged borrow rate \n   **/ \n  function _getOverallBorrowRate( \n    uint256 totalStableDebt, \n    uint256 totalVariableDebt, \n    uint256 currentVariableBorrowRate, \n    uint256 currentAverageStableBorrowRate \n  ) internal pure returns (uint256) { \n    uint256 totalDebt = totalStableDebt.add(totalVariableDebt); \n \n    if (totalDebt == 0) return 0; \n \n    uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate); \n \n    uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate); \n \n    uint256 overallBorrowRate = \n      weightedVariableRate.add(weightedStableRate).rayDiv(totalDebt.wadToRay()); \n \n    return overallBorrowRate; \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol'; \nimport { \n  InitializableImmutableAdminUpgradeabilityProxy \n} from '../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol'; \nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {PercentageMath} from '../libraries/math/PercentageMath.sol'; \nimport {DataTypes} from '../libraries/types/DataTypes.sol'; \nimport {IInitializableDebtToken} from '../../interfaces/IInitializableDebtToken.sol'; \nimport {IInitializableAToken} from '../../interfaces/IInitializableAToken.sol'; \nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol'; \nimport {ILendingPoolConfigurator} from '../../interfaces/ILendingPoolConfigurator.sol'; \n \n/** \n * @title LendingPoolConfigurator contract \n * @author Aave \n * @dev Implements the configuration methods for the Aave protocol \n **/ \n \ncontract LendingPoolConfigurator is VersionedInitializable, ILendingPoolConfigurator { \n  using SafeMath for uint256; \n  using PercentageMath for uint256; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n \n  ILendingPoolAddressesProvider internal addressesProvider; \n  ILendingPool internal pool; \n \n  modifier onlyPoolAdmin { \n    require(addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN); \n    _; \n  } \n \n  modifier onlyEmergencyAdmin { \n    require( \n      addressesProvider.getEmergencyAdmin() == msg.sender, \n      Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN \n    ); \n    _; \n  } \n \n  uint256 internal constant CONFIGURATOR_REVISION = 0x1; \n \n  function getRevision() internal pure override returns (uint256) { \n    return CONFIGURATOR_REVISION; \n  } \n \n  function initialize(ILendingPoolAddressesProvider provider) public initializer { \n    addressesProvider = provider; \n    pool = ILendingPool(addressesProvider.getLendingPool()); \n  } \n \n  /** \n   * @dev Initializes reserves in batch \n   **/ \n  function batchInitReserve(InitReserveInput[] calldata input) external onlyPoolAdmin { \n    ILendingPool cachedPool = pool; \n    for (uint256 i = 0; i < input.length; i++) { \n      _initReserve(cachedPool, input[i]); \n    } \n  } \n \n  function _initReserve(ILendingPool pool, InitReserveInput calldata input) internal { \n    address aTokenProxyAddress = \n      _initTokenWithProxy( \n        input.aTokenImpl, \n        abi.encodeWithSelector( \n          IInitializableAToken.initialize.selector, \n          pool, \n          input.treasury, \n          input.underlyingAsset, \n          IAaveIncentivesController(input.incentivesController), \n          input.underlyingAssetDecimals, \n          input.aTokenName, \n          input.aTokenSymbol, \n          input.params \n        ) \n      ); \n \n    address stableDebtTokenProxyAddress = \n      _initTokenWithProxy( \n        input.stableDebtTokenImpl, \n        abi.encodeWithSelector( \n          IInitializableDebtToken.initialize.selector, \n          pool, \n          input.underlyingAsset, \n          IAaveIncentivesController(input.incentivesController), \n          input.underlyingAssetDecimals, \n          input.stableDebtTokenName, \n          input.stableDebtTokenSymbol, \n          input.params \n        ) \n      ); \n \n    address variableDebtTokenProxyAddress = \n      _initTokenWithProxy( \n        input.variableDebtTokenImpl, \n        abi.encodeWithSelector( \n          IInitializableDebtToken.initialize.selector, \n          pool, \n          input.underlyingAsset, \n          IAaveIncentivesController(input.incentivesController), \n          input.underlyingAssetDecimals, \n          input.variableDebtTokenName, \n          input.variableDebtTokenSymbol, \n          input.params \n        ) \n      ); \n \n    pool.initReserve( \n      input.underlyingAsset, \n      aTokenProxyAddress, \n      stableDebtTokenProxyAddress, \n      variableDebtTokenProxyAddress, \n      input.interestRateStrategyAddress \n    ); \n \n    DataTypes.ReserveConfigurationMap memory currentConfig = \n      pool.getConfiguration(input.underlyingAsset); \n \n    currentConfig.setDecimals(input.underlyingAssetDecimals); \n \n    currentConfig.setActive(true); \n    currentConfig.setFrozen(false); \n \n    pool.setConfiguration(input.underlyingAsset, currentConfig.data); \n \n    emit ReserveInitialized( \n      input.underlyingAsset, \n      aTokenProxyAddress, \n      stableDebtTokenProxyAddress, \n      variableDebtTokenProxyAddress, \n      input.interestRateStrategyAddress \n    ); \n  } \n \n  /** \n   * @dev Updates the aToken implementation for the reserve \n   **/ \n  function updateAToken(UpdateATokenInput calldata input) external onlyPoolAdmin { \n    ILendingPool cachedPool = pool; \n \n    DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset); \n \n    (, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory(); \n \n    bytes memory encodedCall = abi.encodeWithSelector( \n        IInitializableAToken.initialize.selector, \n        cachedPool, \n        input.treasury, \n        input.asset, \n        input.incentivesController, \n        decimals, \n        input.name, \n        input.symbol, \n        input.params \n      ); \n \n    _upgradeTokenImplementation( \n      reserveData.aTokenAddress, \n      input.implementation, \n      encodedCall \n    ); \n \n    emit ATokenUpgraded(input.asset, reserveData.aTokenAddress, input.implementation); \n  } \n \n  /** \n   * @dev Updates the stable debt token implementation for the reserve \n   **/ \n  function updateStableDebtToken(UpdateDebtTokenInput calldata input) external onlyPoolAdmin { \n    ILendingPool cachedPool = pool; \n \n    DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset); \n \n    (, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory(); \n \n    bytes memory encodedCall = abi.encodeWithSelector( \n        IInitializableDebtToken.initialize.selector, \n        cachedPool, \n        input.asset, \n        input.incentivesController, \n        decimals, \n        input.name, \n        input.symbol, \n        input.params \n      ); \n \n    _upgradeTokenImplementation( \n      reserveData.stableDebtTokenAddress, \n      input.implementation, \n      encodedCall \n    ); \n \n    emit StableDebtTokenUpgraded( \n      input.asset, \n      reserveData.stableDebtTokenAddress, \n      input.implementation \n    ); \n  } \n \n  /** \n   * @dev Updates the variable debt token implementation for the asset \n   **/ \n  function updateVariableDebtToken(UpdateDebtTokenInput calldata input) \n    external \n    onlyPoolAdmin \n  { \n    ILendingPool cachedPool = pool; \n \n    DataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset); \n \n    (, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory(); \n \n    bytes memory encodedCall = abi.encodeWithSelector( \n        IInitializableDebtToken.initialize.selector, \n        cachedPool, \n        input.asset, \n        input.incentivesController, \n        decimals, \n        input.name, \n        input.symbol, \n        input.params \n      ); \n \n    _upgradeTokenImplementation( \n      reserveData.variableDebtTokenAddress, \n      input.implementation, \n      encodedCall \n    ); \n \n    emit VariableDebtTokenUpgraded( \n      input.asset, \n      reserveData.variableDebtTokenAddress, \n      input.implementation \n    ); \n  } \n \n  /** \n   * @dev Enables borrowing on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @param stableBorrowRateEnabled True if stable borrow rate needs to be enabled by default on this \n   **/ \n  function enableBorrowingOnReserve(address asset, bool stableBorrowRateEnabled) \n    external \n    onlyPoolAdmin \n  { \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    currentConfig.setBorrowingEnabled(true); \n    currentConfig.setStableRateBorrowingEnabled(stableBorrowRateEnabled); \n \n    pool.setConfiguration(asset, currentConfig.data); \n \n    emit BorrowingEnabledOnReserve(asset, stableBorrowRateEnabled); \n  } \n \n  /** \n   * @dev Disables borrowing on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  function disableBorrowingOnReserve(address asset) external onlyPoolAdmin { \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    currentConfig.setBorrowingEnabled(false); \n \n    pool.setConfiguration(asset, currentConfig.data); \n    emit BorrowingDisabledOnReserve(asset); \n  } \n \n  /** \n   * @dev Configures the reserve collateralization parameters \n   * all the values are expressed in percentages with two decimals of precision. A valid value is 100\n   * @param asset The address of the underlying asset of the reserve \n   * @param ltv The loan to value of the asset when used as collateral \n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be \n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset. The values is alw\n   * means the liquidator will receive a 5% bonus \n   **/ \n  function configureReserveAsCollateral( \n    address asset, \n    uint256 ltv, \n    uint256 liquidationThreshold, \n    uint256 liquidationBonus \n  ) external onlyPoolAdmin { \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    //validation of the parameters: the LTV can \n    //only be lower or equal than the liquidation threshold \n    //(otherwise a loan against the asset would cause instantaneous liquidation) \n    require(ltv <= liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION); \n \n    if (liquidationThreshold != 0) { \n      //liquidation bonus must be bigger than 100.00%, otherwise the liquidator would receive less \n      //collateral than needed to cover the debt \n      require( \n        liquidationBonus > PercentageMath.PERCENTAGE_FACTOR, \n        Errors.LPC_INVALID_CONFIGURATION \n      ); \n \n      //if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment \n      //a loan is taken there is enough collateral available to cover the liquidation bonus \n      require( \n        liquidationThreshold.percentMul(liquidationBonus) <= PercentageMath.PERCENTAGE_FACTOR, \n        Errors.LPC_INVALID_CONFIGURATION \n      ); \n    } else { \n      require(liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION); \n      //if the liquidation threshold is being set to 0, \n      // the reserve is being disabled as collateral. To do so, \n      //we need to ensure no liquidity is deposited \n      _checkNoLiquidity(asset); \n    } \n \n    currentConfig.setLtv(ltv); \n    currentConfig.setLiquidationThreshold(liquidationThreshold); \n    currentConfig.setLiquidationBonus(liquidationBonus); \n \n    pool.setConfiguration(asset, currentConfig.data); \n \n    emit CollateralConfigurationChanged(asset, ltv, liquidationThreshold, liquidationBonus); \n  } \n \n  /** \n   * @dev Enable stable rate borrowing on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  function enableReserveStableRate(address asset) external onlyPoolAdmin { \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    currentConfig.setStableRateBorrowingEnabled(true); \n \n    pool.setConfiguration(asset, currentConfig.data); \n \n    emit StableRateEnabledOnReserve(asset); \n  } \n \n  /** \n   * @dev Disable stable rate borrowing on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  function disableReserveStableRate(address asset) external onlyPoolAdmin { \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    currentConfig.setStableRateBorrowingEnabled(false); \n \n    pool.setConfiguration(asset, currentConfig.data); \n \n    emit StableRateDisabledOnReserve(asset); \n  } \n \n  /** \n   * @dev Activates a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  function activateReserve(address asset) external onlyPoolAdmin { \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    currentConfig.setActive(true); \n \n    pool.setConfiguration(asset, currentConfig.data); \n \n    emit ReserveActivated(asset); \n  } \n \n  /** \n   * @dev Deactivates a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  function deactivateReserve(address asset) external onlyPoolAdmin { \n    _checkNoLiquidity(asset); \n \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    currentConfig.setActive(false); \n \n    pool.setConfiguration(asset, currentConfig.data); \n \n    emit ReserveDeactivated(asset); \n  } \n \n  /** \n   * @dev Freezes a reserve. A frozen reserve doesn't allow any new deposit, borrow or rate swap \n   *  but allows repayments, liquidations, rate rebalances and withdrawals \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  function freezeReserve(address asset) external onlyPoolAdmin { \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    currentConfig.setFrozen(true); \n \n    pool.setConfiguration(asset, currentConfig.data); \n \n    emit ReserveFrozen(asset); \n  } \n \n  /** \n   * @dev Unfreezes a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  function unfreezeReserve(address asset) external onlyPoolAdmin { \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    currentConfig.setFrozen(false); \n \n    pool.setConfiguration(asset, currentConfig.data); \n \n    emit ReserveUnfrozen(asset); \n  } \n \n  /** \n   * @dev Updates the reserve factor of a reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @param reserveFactor The new reserve factor of the reserve \n   **/ \n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin { \n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset); \n \n    currentConfig.setReserveFactor(reserveFactor); \n \n    pool.setConfiguration(asset, currentConfig.data); \n \n    emit ReserveFactorChanged(asset, reserveFactor); \n  } \n \n  /** \n   * @dev Sets the interest rate strategy of a reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @param rateStrategyAddress The new address of the interest strategy contract \n   **/ \n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) \n    external \n    onlyPoolAdmin \n  { \n    pool.setReserveInterestRateStrategyAddress(asset, rateStrategyAddress); \n    emit ReserveInterestRateStrategyChanged(asset, rateStrategyAddress); \n  } \n \n  /** \n   * @dev pauses or unpauses all the actions of the protocol, including aToken transfers \n   * @param val true if protocol needs to be paused, false otherwise \n   **/ \n  function setPoolPause(bool val) external onlyEmergencyAdmin { \n    pool.setPause(val); \n  } \n \n  function _initTokenWithProxy(address implementation, bytes memory initParams) \n    internal \n    returns (address) \n  { \n    InitializableImmutableAdminUpgradeabilityProxy proxy = \n      new InitializableImmutableAdminUpgradeabilityProxy(address(this)); \n \n    proxy.initialize(implementation, initParams); \n \n    return address(proxy); \n  } \n \n  function _upgradeTokenImplementation( \n    address proxyAddress, \n    address implementation, \n    bytes memory initParams \n  ) internal { \n    InitializableImmutableAdminUpgradeabilityProxy proxy = \n      InitializableImmutableAdminUpgradeabilityProxy(payable(proxyAddress)); \n \n    proxy.upgradeToAndCall(implementation, initParams); \n  } \n \n  function _checkNoLiquidity(address asset) internal view { \n    DataTypes.ReserveData memory reserveData = pool.getReserveData(asset); \n \n    uint256 availableLiquidity = IERC20Detailed(asset).balanceOf(reserveData.aTokenAddress); \n \n    require( \n      availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, \n      Errors.LPC_RESERVE_LIQUIDITY_NOT_0 \n    ); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts//SafeMath.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts//IERC20.sol'; \nimport {IAToken} from '../../interfaces/IAToken.sol'; \nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol'; \nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol'; \nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol'; \nimport {ILendingPoolCollateralManager} from '../../interfaces/ILendingPoolCollateralManager.sol'; \nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol'; \nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol'; \nimport {Helpers} from '../libraries/helpers/Helpers.sol'; \nimport {WadRayMath} from '../libraries/math/WadRayMath.sol'; \nimport {PercentageMath} from '../libraries/math/PercentageMath.sol'; \nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol'; \nimport {DataTypes} from '../libraries/types/DataTypes.sol'; \nimport {LendingPoolStorage} from './LendingPoolStorage.sol'; \n \n/** \n * @title LendingPoolCollateralManager contract \n * @author Aave \n * @dev Implements actions involving management of collateral in the protocol, the main one being the \n * IMPORTANT This contract will run always via DELEGATECALL, through the LendingPool, so the chain of \n * is the same as the LendingPool, to have compatible storage layouts \n **/ \ncontract LendingPoolCollateralManager is \n  ILendingPoolCollateralManager, \n  VersionedInitializable, \n  LendingPoolStorage \n{ \n  using SafeERC20 for IERC20; \n  using SafeMath for uint256; \n  using WadRayMath for uint256; \n  using PercentageMath for uint256; \n \n  uint256 internal constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000; \n \n  struct LiquidationCallLocalVars { \n    uint256 userCollateralBalance; \n    uint256 userStableDebt; \n    uint256 userVariableDebt; \n    uint256 maxLiquidatableDebt; \n    uint256 actualDebtToLiquidate; \n    uint256 liquidationRatio; \n    uint256 maxAmountCollateralToLiquidate; \n    uint256 userStableRate; \n    uint256 maxCollateralToLiquidate; \n    uint256 debtAmountNeeded; \n    uint256 healthFactor; \n    uint256 liquidatorPreviousATokenBalance; \n    IAToken collateralAtoken; \n    bool isCollateralEnabled; \n    DataTypes.InterestRateMode borrowRateMode; \n    uint256 errorCode; \n    string errorMsg; \n  } \n \n  /** \n   * @dev As thIS contract extends the VersionedInitializable contract to match the state \n   * of the LendingPool contract, the getRevision() function is needed, but the value is not \n   * important, as the initialize() function will never be called here \n   */ \n  function getRevision() internal pure override returns (uint256) { \n    return 0; \n  } \n \n  /** \n   * @dev Function to liquidate a position if its Health Factor drops below 1 \n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, an\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk \n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as res\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation \n   * @param user The address of the borrower getting liquidated \n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover \n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` \n   * to receive the underlying collateral asset directly \n   **/ \n  function liquidationCall( \n    address collateralAsset, \n    address debtAsset, \n    address user, \n    uint256 debtToCover, \n    bool receiveAToken \n  ) external override returns (uint256, string memory) { \n    DataTypes.ReserveData storage collateralReserve = _reserves[collateralAsset]; \n    DataTypes.ReserveData storage debtReserve = _reserves[debtAsset]; \n    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[user]; \n \n    LiquidationCallLocalVars memory vars; \n \n    (, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData( \n      user, \n      _reserves, \n      userConfig, \n      _reservesList, \n      _reservesCount, \n      _addressesProvider.getPriceOracle() \n    ); \n \n    (vars.userStableDebt, vars.userVariableDebt) = Helpers.getUserCurrentDebt(user, debtReserve); \n \n    (vars.errorCode, vars.errorMsg) = ValidationLogic.validateLiquidationCall( \n      collateralReserve, \n      debtReserve, \n      userConfig, \n      vars.healthFactor, \n      vars.userStableDebt, \n      vars.userVariableDebt \n    ); \n \n    if (Errors.CollateralManagerErrors(vars.errorCode) != Errors.CollateralManagerErrors.NO_ERROR) { \n      return (vars.errorCode, vars.errorMsg); \n    } \n \n    vars.collateralAtoken = IAToken(collateralReserve.aTokenAddress); \n \n    vars.userCollateralBalance = vars.collateralAtoken.balanceOf(user); \n \n    vars.maxLiquidatableDebt = vars.userStableDebt.add(vars.userVariableDebt).percentMul( \n      LIQUIDATION_CLOSE_FACTOR_PERCENT \n    ); \n \n    vars.actualDebtToLiquidate = debtToCover > vars.maxLiquidatableDebt \n      ? vars.maxLiquidatableDebt \n      : debtToCover; \n \n    ( \n      vars.maxCollateralToLiquidate, \n      vars.debtAmountNeeded \n    ) = _calculateAvailableCollateralToLiquidate( \n      collateralReserve, \n      debtReserve, \n      collateralAsset, \n      debtAsset, \n      vars.actualDebtToLiquidate, \n      vars.userCollateralBalance \n    ); \n \n    // If debtAmountNeeded < actualDebtToLiquidate, there isn't enough \n    // collateral to cover the actual amount that is being liquidated, hence we liquidate \n    // a smaller amount \n \n    if (vars.debtAmountNeeded < vars.actualDebtToLiquidate) { \n      vars.actualDebtToLiquidate = vars.debtAmountNeeded; \n    } \n \n    // If the liquidator reclaims the underlying asset, we make sure there is enough available liquid\n    // collateral reserve \n    if (!receiveAToken) { \n      uint256 currentAvailableCollateral = \n        IERC20(collateralAsset).balanceOf(address(vars.collateralAtoken)); \n      if (currentAvailableCollateral < vars.maxCollateralToLiquidate) { \n        return ( \n          uint256(Errors.CollateralManagerErrors.NOT_ENOUGH_LIQUIDITY), \n          Errors.LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE \n        ); \n      } \n    } \n \n    debtReserve.updateState(); \n \n    if (vars.userVariableDebt >= vars.actualDebtToLiquidate) { \n      IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn( \n        user, \n        vars.actualDebtToLiquidate, \n        debtReserve.variableBorrowIndex \n      ); \n    } else { \n      // If the user doesn't have variable debt, no need to try to burn variable debt tokens \n      if (vars.userVariableDebt > 0) { \n        IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn( \n          user, \n          vars.userVariableDebt, \n          debtReserve.variableBorrowIndex \n        ); \n      } \n      IStableDebtToken(debtReserve.stableDebtTokenAddress).burn( \n        user, \n        vars.actualDebtToLiquidate.sub(vars.userVariableDebt) \n      ); \n    } \n \n    debtReserve.updateInterestRates( \n      debtAsset, \n      debtReserve.aTokenAddress, \n      vars.actualDebtToLiquidate, \n    ); \n \n    if (receiveAToken) { \n      vars.liquidatorPreviousATokenBalance = IERC20(vars.collateralAtoken).balanceOf(msg.sender); \n      vars.collateralAtoken.transferOnLiquidation(user, msg.sender, vars.maxCollateralToLiquidate); \n \n      if (vars.liquidatorPreviousATokenBalance == 0) { \n        DataTypes.UserConfigurationMap storage liquidatorConfig = _usersConfig[msg.sender]; \n        liquidatorConfig.setUsingAsCollateral(collateralReserve.id, true); \n        emit ReserveUsedAsCollateralEnabled(collateralAsset, msg.sender); \n      } \n    } else { \n      collateralReserve.updateState(); \n      collateralReserve.updateInterestRates( \n        collateralAsset, \n        address(vars.collateralAtoken), \n        0, \n        vars.maxCollateralToLiquidate \n      ); \n \n      // Burn the equivalent amount of aToken, sending the underlying to the liquidator \n      vars.collateralAtoken.burn( \n        user, \n        msg.sender, \n        vars.maxCollateralToLiquidate, \n        collateralReserve.liquidityIndex \n      ); \n    } \n \n    // If the collateral being liquidated is equal to the user balance, \n    // we set the currency as not being used as collateral anymore \n    if (vars.maxCollateralToLiquidate == vars.userCollateralBalance) { \n      userConfig.setUsingAsCollateral(collateralReserve.id, false); \n      emit ReserveUsedAsCollateralDisabled(collateralAsset, user); \n    } \n \n    // Transfers the debt asset being repaid to the aToken, where the liquidity is kept \n    IERC20(debtAsset).safeTransferFrom( \n      msg.sender, \n      debtReserve.aTokenAddress, \n      vars.actualDebtToLiquidate \n    ); \n \n    emit LiquidationCall( \n      collateralAsset, \n      debtAsset, \n      user, \n      vars.actualDebtToLiquidate, \n      vars.maxCollateralToLiquidate, \n      msg.sender, \n      receiveAToken \n    ); \n \n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS); \n  } \n \n  struct AvailableCollateralToLiquidateLocalVars { \n    uint256 userCompoundedBorrowBalance; \n    uint256 liquidationBonus; \n    uint256 collateralPrice; \n    uint256 debtAssetPrice; \n    uint256 maxAmountCollateralToLiquidate; \n    uint256 debtAssetDecimals; \n    uint256 collateralDecimals; \n  } \n \n  /** \n   * @dev Calculates how much of a specific collateral can be liquidated, given \n   * a certain amount of debt asset. \n   * - This function needs to be called after all the checks to validate the liquidation have been pe\n   *   otherwise it might fail. \n   * @param collateralReserve The data of the collateral reserve \n   * @param debtReserve The data of the debt reserve \n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as res\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation \n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover \n   * @param userCollateralBalance The collateral balance for the specific `collateralAsset` of the us\n   * @return collateralAmount: The maximum amount that is possible to liquidate given all the liquida\n   *                           (user balance, close factor) \n   *         debtAmountNeeded: The amount to repay with the liquidation \n   **/ \n  function _calculateAvailableCollateralToLiquidate( \n    DataTypes.ReserveData storage collateralReserve, \n    DataTypes.ReserveData storage debtReserve, \n    address collateralAsset, \n    address debtAsset, \n    uint256 debtToCover, \n    uint256 userCollateralBalance \n  ) internal view returns (uint256, uint256) { \n    uint256 collateralAmount = 0; \n    uint256 debtAmountNeeded = 0; \n    IPriceOracleGetter oracle = IPriceOracleGetter(_addressesProvider.getPriceOracle()); \n \n    AvailableCollateralToLiquidateLocalVars memory vars; \n \n    vars.collateralPrice = oracle.getAssetPrice(collateralAsset); \n    vars.debtAssetPrice = oracle.getAssetPrice(debtAsset); \n \n    (, , vars.liquidationBonus, vars.collateralDecimals, ) = collateralReserve \n      .configuration \n      .getParams(); \n    vars.debtAssetDecimals = debtReserve.configuration.getDecimals(); \n \n    // This is the maximum possible amount of the selected collateral that can be liquidated, given t\n    // max amount of liquidatable debt \n    vars.maxAmountCollateralToLiquidate = vars \n      .debtAssetPrice \n      .mul(debtToCover) \n      .mul(10**vars.collateralDecimals) \n      .percentMul(vars.liquidationBonus) \n      .div(vars.collateralPrice.mul(10**vars.debtAssetDecimals)); \n \n    if (vars.maxAmountCollateralToLiquidate > userCollateralBalance) { \n      collateralAmount = userCollateralBalance; \n      debtAmountNeeded = vars \n        .collateralPrice \n        .mul(collateralAmount) \n        .mul(10**vars.debtAssetDecimals) \n        .div(vars.debtAssetPrice.mul(10**vars.collateralDecimals)) \n        .percentDiv(vars.liquidationBonus); \n    } else { \n      collateralAmount = vars.maxAmountCollateralToLiquidate; \n      debtAmountNeeded = debtToCover; \n    } \n    return (collateralAmount, debtAmountNeeded); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {ILendingPool} from '../../../interfaces/ILendingPool.sol'; \nimport {ICreditDelegationToken} from '../../../interfaces/ICreditDelegationToken.sol'; \nimport { \n  VersionedInitializable \n} from '../../libraries/aave-upgradeability/VersionedInitializable.sol'; \nimport {IncentivizedERC20} from '../IncentivizedERC20.sol'; \nimport {Errors} from '../../libraries/helpers/Errors.sol'; \n \n/** \n * @title DebtTokenBase \n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToke\n * @author Aave \n */ \n \nabstract contract DebtTokenBase is \n  IncentivizedERC20('DEBTTOKEN_IMPL', 'DEBTTOKEN_IMPL', 0), \n  VersionedInitializable, \n  ICreditDelegationToken \n{ \n  mapping(address => mapping(address => uint256)) internal _borrowAllowances; \n \n  /** \n   * @dev Only lending pool can call functions marked by this modifier \n   **/ \n  modifier onlyLendingPool { \n    require(_msgSender() == address(_getLendingPool()), Errors.CT_CALLER_MUST_BE_LENDING_POOL); \n    _; \n  } \n \n  /** \n   * @dev delegates borrowing power to a user on the specific debt token \n   * @param delegatee the address receiving the delegated borrowing power \n   * @param amount the maximum amount being delegated. Delegation will still \n   * respect the liquidation constraints (even if delegated, a delegatee cannot \n   * force a delegator HF to go below 1) \n   **/ \n  function approveDelegation(address delegatee, uint256 amount) external override { \n    _borrowAllowances[_msgSender()][delegatee] = amount; \n    emit BorrowAllowanceDelegated(_msgSender(), delegatee, _getUnderlyingAssetAddress(), amount); \n  } \n \n  /** \n   * @dev returns the borrow allowance of the user \n   * @param fromUser The user to giving allowance \n   * @param toUser The user to give allowance to \n   * @return the current allowance of toUser \n   **/ \n  function borrowAllowance(address fromUser, address toUser) \n    external \n    view \n    override \n    returns (uint256) \n  { \n    return _borrowAllowances[fromUser][toUser]; \n  } \n \n  /** \n   * @dev Being non transferrable, the debt token does not implement any of the \n   * standard ERC20 functions for transfer and allowance. \n   **/ \n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n    recipient; \n    amount; \n    revert('TRANSFER_NOT_SUPPORTED'); \n  } \n \n  function allowance(address owner, address spender) \n    public \n    view \n    virtual \n    override \n    returns (uint256) \n  { \n    owner; \n    spender; \n    revert('ALLOWANCE_NOT_SUPPORTED'); \n  } \n \n  function approve(address spender, uint256 amount) public virtual override returns (bool) { \n    spender; \n    amount; \n    revert('APPROVAL_NOT_SUPPORTED'); \n  } \n \n  function transferFrom( \n    address sender, \n    address recipient, \n    uint256 amount \n  ) public virtual override returns (bool) { \n    sender; \n    recipient; \n    amount; \n    revert('TRANSFER_NOT_SUPPORTED'); \n  } \n \n  function increaseAllowance(address spender, uint256 addedValue) \n    public \n    virtual \n    override \n    returns (bool) \n  { \n    spender; \n    addedValue; \n    revert('ALLOWANCE_NOT_SUPPORTED'); \n  } \n \n  function decreaseAllowance(address spender, uint256 subtractedValue) \n    public \n    virtual \n    override \n    returns (bool) \n  { \n    spender; \n    subtractedValue; \n    revert('ALLOWANCE_NOT_SUPPORTED'); \n  } \n \n  function _decreaseBorrowAllowance( \n    address delegator, \n    address delegatee, \n    uint256 amount \n  ) internal { \n    uint256 newAllowance = \n      _borrowAllowances[delegator][delegatee].sub(amount, Errors.BORROW_ALLOWANCE_NOT_ENOUGH); \n \n    _borrowAllowances[delegator][delegatee] = newAllowance; \n \n    emit BorrowAllowanceDelegated(delegator, delegatee, _getUnderlyingAssetAddress(), newAllowance); \n  } \n \n  function _getUnderlyingAssetAddress() internal view virtual returns (address); \n \n  function _getLendingPool() internal view virtual returns (ILendingPool); \n} \n",
            "pragma solidity 0.6.12; \n \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IDelegationToken} from '../../interfaces/IDelegationToken.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {AToken} from './AToken.sol'; \n \n/** \n * @title Aave AToken enabled to delegate voting power of the underlying asset to a different address\n * @dev The underlying asset needs to be compatible with the COMP delegation interface \n * @author Aave \n */ \ncontract DelegationAwareAToken is AToken { \n  modifier onlyPoolAdmin { \n    require( \n      _msgSender() == ILendingPool(_pool).getAddressesProvider().getPoolAdmin(), \n      Errors.CALLER_NOT_POOL_ADMIN \n    ); \n    _; \n  } \n \n  /** \n   * @dev Delegates voting power of the underlying asset to a `delegatee` address \n   * @param delegatee The address that will receive the delegation \n   **/ \n  function delegateUnderlyingTo(address delegatee) external onlyPoolAdmin { \n    IDelegationToken(_underlyingAsset).delegate(delegatee); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {Context} from '../../dependencies/openzeppelin/contracts/Context.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol'; \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol'; \n \n/** \n * @title ERC20 \n * @notice Basic ERC20 implementation \n * @author Aave, inspired by the Openzeppelin ERC20 implementation \n **/ \nabstract contract IncentivizedERC20 is Context, IERC20, IERC20Detailed { \n  using SafeMath for uint256; \n \n  mapping(address => uint256) internal _balances; \n \n  mapping(address => mapping(address => uint256)) private _allowances; \n  uint256 internal _totalSupply; \n  string private _name; \n  string private _symbol; \n  uint8 private _decimals; \n \n  constructor( \n    string memory name, \n    string memory symbol, \n    uint8 decimals \n  ) public { \n    _name = name; \n    _symbol = symbol; \n    _decimals = decimals; \n  } \n \n  /** \n   * @return The name of the token \n   **/ \n  function name() public view override returns (string memory) { \n    return _name; \n  } \n \n  /** \n   * @return The symbol of the token \n   **/ \n  function symbol() public view override returns (string memory) { \n    return _symbol; \n  } \n \n  /** \n   * @return The decimals of the token \n   **/ \n  function decimals() public view override returns (uint8) { \n    return _decimals; \n  } \n \n  /** \n   * @return The total supply of the token \n   **/ \n  function totalSupply() public view virtual override returns (uint256) { \n    return _totalSupply; \n  } \n \n  /** \n   * @return The balance of the token \n   **/ \n  function balanceOf(address account) public view virtual override returns (uint256) { \n    return _balances[account]; \n  } \n \n  /** \n   * @return Abstract function implemented by the child aToken/debtToken.  \n   * Done this way in order to not break compatibility with previous versions of aTokens/debtTokens \n   **/ \n  function _getIncentivesController() internal view virtual returns(IAaveIncentivesController); \n \n  /** \n   * @dev Executes a transfer of tokens from _msgSender() to recipient \n   * @param recipient The recipient of the tokens \n   * @param amount The amount of tokens being transferred \n   * @return `true` if the transfer succeeds, `false` otherwise \n   **/ \n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n    _transfer(_msgSender(), recipient, amount); \n    emit Transfer(_msgSender(), recipient, amount); \n    return true; \n  } \n \n  /** \n   * @dev Returns the allowance of spender on the tokens owned by owner \n   * @param owner The owner of the tokens \n   * @param spender The user allowed to spend the owner's tokens \n   * @return The amount of owner's tokens spender is allowed to spend \n   **/ \n  function allowance(address owner, address spender) \n    public \n    view \n    virtual \n    override \n    returns (uint256) \n  { \n    return _allowances[owner][spender]; \n  } \n \n  /** \n   * @dev Allows `spender` to spend the tokens owned by _msgSender() \n   * @param spender The user allowed to spend _msgSender() tokens \n   * @return `true` \n   **/ \n  function approve(address spender, uint256 amount) public virtual override returns (bool) { \n    _approve(_msgSender(), spender, amount); \n    return true; \n  } \n \n  /** \n   * @dev Executes a transfer of token from sender to recipient, if _msgSender() is allowed to do so \n   * @param sender The owner of the tokens \n   * @param recipient The recipient of the tokens \n   * @param amount The amount of tokens being transferred \n   * @return `true` if the transfer succeeds, `false` otherwise \n   **/ \n  function transferFrom( \n    address sender, \n    address recipient, \n    uint256 amount \n  ) public virtual override returns (bool) { \n    _transfer(sender, recipient, amount); \n    _approve( \n      sender, \n      _msgSender(), \n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance') \n    ); \n    emit Transfer(sender, recipient, amount); \n    return true; \n  } \n \n  /** \n   * @dev Increases the allowance of spender to spend _msgSender() tokens \n   * @param spender The user allowed to spend on behalf of _msgSender() \n   * @param addedValue The amount being added to the allowance \n   * @return `true` \n   **/ \n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n    return true; \n  } \n \n  /** \n   * @dev Decreases the allowance of spender to spend _msgSender() tokens \n   * @param spender The user allowed to spend on behalf of _msgSender() \n   * @param subtractedValue The amount being subtracted to the allowance \n   * @return `true` \n   **/ \n  function decreaseAllowance(address spender, uint256 subtractedValue) \n    public \n    virtual \n    returns (bool) \n  { \n    _approve( \n      _msgSender(), \n      spender, \n      _allowances[_msgSender()][spender].sub( \n        subtractedValue, \n        'ERC20: decreased allowance below zero' \n      ) \n    ); \n    return true; \n  } \n \n  function _transfer( \n    address sender, \n    address recipient, \n    uint256 amount \n  ) internal virtual { \n    require(sender != address(0), 'ERC20: transfer from the zero address'); \n    require(recipient != address(0), 'ERC20: transfer to the zero address'); \n \n    _beforeTokenTransfer(sender, recipient, amount); \n \n    uint256 oldSenderBalance = _balances[sender]; \n    _balances[sender] = oldSenderBalance.sub(amount, 'ERC20: transfer amount exceeds balance'); \n    uint256 oldRecipientBalance = _balances[recipient]; \n    _balances[recipient] = _balances[recipient].add(amount); \n \n    if (address(_getIncentivesController()) != address(0)) { \n      uint256 currentTotalSupply = _totalSupply; \n      _getIncentivesController().handleAction(sender, currentTotalSupply, oldSenderBalance); \n      if (sender != recipient) { \n        _getIncentivesController().handleAction(recipient, currentTotalSupply, oldRecipientBalance); \n      } \n    } \n  } \n \n  function _mint(address account, uint256 amount) internal virtual { \n    require(account != address(0), 'ERC20: mint to the zero address'); \n \n    _beforeTokenTransfer(address(0), account, amount); \n \n    uint256 oldTotalSupply = _totalSupply; \n    _totalSupply = oldTotalSupply.add(amount); \n \n    uint256 oldAccountBalance = _balances[account]; \n    _balances[account] = oldAccountBalance.add(amount); \n \n    if (address(_getIncentivesController()) != address(0)) { \n      _getIncentivesController().handleAction(account, oldTotalSupply, oldAccountBalance); \n    } \n  } \n \n  function _burn(address account, uint256 amount) internal virtual { \n    require(account != address(0), 'ERC20: burn from the zero address'); \n \n    _beforeTokenTransfer(account, address(0), amount); \n \n    uint256 oldTotalSupply = _totalSupply; \n    _totalSupply = oldTotalSupply.sub(amount); \n \n    uint256 oldAccountBalance = _balances[account]; \n    _balances[account] = oldAccountBalance.sub(amount, 'ERC20: burn amount exceeds balance'); \n \n    if (address(_getIncentivesController()) != address(0)) { \n      _getIncentivesController().handleAction(account, oldTotalSupply, oldAccountBalance); \n    } \n  } \n \n  function _approve( \n    address owner, \n    address spender, \n    uint256 amount \n  ) internal virtual { \n    require(owner != address(0), 'ERC20: approve from the zero address'); \n    require(spender != address(0), 'ERC20: approve to the zero address'); \n \n    _allowances[owner][spender] = amount; \n    emit Approval(owner, spender, amount); \n  } \n \n  function _setName(string memory newName) internal { \n    _name = newName; \n  } \n \n  function _setSymbol(string memory newSymbol) internal { \n    _symbol = newSymbol; \n  } \n \n  function _setDecimals(uint8 newDecimals) internal { \n    _decimals = newDecimals; \n  } \n \n  function _beforeTokenTransfer( \n    address from, \n    address to, \n    uint256 amount \n  ) internal virtual {} \n} \n",
            "pragma solidity 0.6.12; \n \nimport {DebtTokenBase} from './base/DebtTokenBase.sol'; \nimport {MathUtils} from '../libraries/math/MathUtils.sol'; \nimport {WadRayMath} from '../libraries/math/WadRayMath.sol'; \nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \n \n/** \n * @title StableDebtToken \n * @notice Implements a stable debt token to track the borrowing positions of users \n * at stable rate mode \n * @author Aave \n **/ \ncontract StableDebtToken is IStableDebtToken, DebtTokenBase { \n  using WadRayMath for uint256; \n \n  uint256 public constant DEBT_TOKEN_REVISION = 0x1; \n \n  uint256 internal _avgStableRate; \n  mapping(address => uint40) internal _timestamps; \n  mapping(address => uint256) internal _usersStableRate; \n  uint40 internal _totalSupplyTimestamp; \n \n  ILendingPool internal _pool; \n  address internal _underlyingAsset; \n  IAaveIncentivesController internal _incentivesController; \n \n  /** \n   * @dev Initializes the debt token. \n   * @param pool The address of the lending pool where this aToken will be used \n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   * @param incentivesController The smart contract managing potential incentives distribution \n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's \n   * @param debtTokenName The name of the token \n   * @param debtTokenSymbol The symbol of the token \n   */ \n  function initialize( \n    ILendingPool pool, \n    address underlyingAsset, \n    IAaveIncentivesController incentivesController, \n    uint8 debtTokenDecimals, \n    string memory debtTokenName, \n    string memory debtTokenSymbol, \n    bytes calldata params \n  ) public override initializer { \n    _setName(debtTokenName); \n    _setSymbol(debtTokenSymbol); \n    _setDecimals(debtTokenDecimals); \n \n    _pool = pool; \n    _underlyingAsset = underlyingAsset; \n    _incentivesController = incentivesController; \n \n    emit Initialized( \n      underlyingAsset, \n      address(pool), \n      address(incentivesController), \n      debtTokenDecimals, \n      debtTokenName, \n      debtTokenSymbol, \n      params \n    ); \n  } \n \n  /** \n   * @dev Gets the revision of the stable debt token implementation \n   * @return The debt token implementation revision \n   **/ \n  function getRevision() internal pure virtual override returns (uint256) { \n    return DEBT_TOKEN_REVISION; \n  } \n \n  /** \n   * @dev Returns the average stable rate across all the stable rate debt \n   * @return the average stable rate \n   **/ \n  function getAverageStableRate() external view virtual override returns (uint256) { \n    return _avgStableRate; \n  } \n \n  /** \n   * @dev Returns the timestamp of the last user action \n   * @return The last update timestamp \n   **/ \n  function getUserLastUpdated(address user) external view virtual override returns (uint40) { \n    return _timestamps[user]; \n  } \n \n  /** \n   * @dev Returns the stable rate of the user \n   * @param user The address of the user \n   * @return The stable rate of user \n   **/ \n  function getUserStableRate(address user) external view virtual override returns (uint256) { \n    return _usersStableRate[user]; \n  } \n \n  /** \n   * @dev Calculates the current user debt balance \n   * @return The accumulated debt of the user \n   **/ \n  function balanceOf(address account) public view virtual override returns (uint256) { \n    uint256 accountBalance = super.balanceOf(account); \n    uint256 stableRate = _usersStableRate[account]; \n    if (accountBalance == 0) { \n      return 0; \n    } \n    uint256 cumulatedInterest = \n      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]); \n    return accountBalance.rayMul(cumulatedInterest); \n  } \n \n  struct MintLocalVars { \n    uint256 previousSupply; \n    uint256 nextSupply; \n    uint256 amountInRay; \n    uint256 newStableRate; \n    uint256 currentAvgStableRate; \n  } \n \n  /** \n   * @dev Mints debt token to the `onBehalfOf` address. \n   * -  Only callable by the LendingPool \n   * - The resulting rate is the weighted average between the rate of the new debt \n   * and the rate of the previous debt \n   * @param user The address receiving the borrowed underlying, being the delegatee in case \n   * of credit delegate, or same as `onBehalfOf` otherwise \n   * @param onBehalfOf The address receiving the debt tokens \n   * @param amount The amount of debt tokens to mint \n   * @param rate The rate of the debt being minted \n   **/ \n  function mint( \n    address user, \n    address onBehalfOf, \n    uint256 amount, \n    uint256 rate \n  ) external override onlyLendingPool returns (bool) { \n    MintLocalVars memory vars; \n \n    if (user != onBehalfOf) { \n      _decreaseBorrowAllowance(onBehalfOf, user, amount); \n    } \n \n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf); \n \n    vars.previousSupply = totalSupply(); \n    vars.currentAvgStableRate = _avgStableRate; \n    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount); \n \n    vars.amountInRay = amount.wadToRay(); \n \n    vars.newStableRate = _usersStableRate[onBehalfOf] \n      .rayMul(currentBalance.wadToRay()) \n      .add(vars.amountInRay.rayMul(rate)) \n      .rayDiv(currentBalance.add(amount).wadToRay()); \n \n    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW); \n    _usersStableRate[onBehalfOf] = vars.newStableRate; \n \n    //solium-disable-next-line \n    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp); \n \n    // Calculates the updated average stable rate \n    vars.currentAvgStableRate = _avgStableRate = vars \n      .currentAvgStableRate \n      .rayMul(vars.previousSupply.wadToRay()) \n      .add(rate.rayMul(vars.amountInRay)) \n      .rayDiv(vars.nextSupply.wadToRay()); \n \n    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply); \n \n    emit Transfer(address(0), onBehalfOf, amount); \n \n    emit Mint( \n      user, \n      onBehalfOf, \n      amount, \n      currentBalance, \n      balanceIncrease, \n      vars.newStableRate, \n      vars.currentAvgStableRate, \n      vars.nextSupply \n    ); \n \n    return currentBalance == 0; \n  } \n \n  /** \n   * @dev Burns debt of `user` \n   * @param user The address of the user getting his debt burned \n   * @param amount The amount of debt tokens getting burned \n   **/ \n  function burn(address user, uint256 amount) external override onlyLendingPool { \n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user); \n \n    uint256 previousSupply = totalSupply(); \n    uint256 newAvgStableRate = 0; \n    uint256 nextSupply = 0; \n    uint256 userStableRate = _usersStableRate[user]; \n \n    // Since the total supply and each single user debt accrue separately, \n    // there might be accumulation errors so that the last borrower repaying \n    // mght actually try to repay more than the available debt supply. \n    // In this case we simply set the total supply and the avg stable rate to 0 \n    if (previousSupply <= amount) { \n      _avgStableRate = 0; \n      _totalSupply = 0; \n    } else { \n      nextSupply = _totalSupply = previousSupply.sub(amount); \n      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay()); \n      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay()); \n \n      // For the same reason described above, when the last user is repaying it might \n      // happen that user rate * user balance > avg rate * total supply. In that case, \n      // we simply set the avg rate to 0 \n      if (secondTerm >= firstTerm) { \n        newAvgStableRate = _avgStableRate = _totalSupply = 0; \n      } else { \n        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay()); \n      } \n    } \n \n    if (amount == currentBalance) { \n      _usersStableRate[user] = 0; \n      _timestamps[user] = 0; \n    } else { \n      //solium-disable-next-line \n      _timestamps[user] = uint40(block.timestamp); \n    } \n    //solium-disable-next-line \n    _totalSupplyTimestamp = uint40(block.timestamp); \n \n    if (balanceIncrease > amount) { \n      uint256 amountToMint = balanceIncrease.sub(amount); \n      _mint(user, amountToMint, previousSupply); \n      emit Mint( \n        user, \n        user, \n        amountToMint, \n        currentBalance, \n        balanceIncrease, \n        userStableRate, \n        newAvgStableRate, \n        nextSupply \n      ); \n    } else { \n      uint256 amountToBurn = amount.sub(balanceIncrease); \n      _burn(user, amountToBurn, previousSupply); \n      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply); \n    } \n \n    emit Transfer(user, address(0), amount); \n  } \n \n  /** \n   * @dev Calculates the increase in balance since the last user interaction \n   * @param user The address of the user for which the interest is being accumulated \n   * @return The previous principal balance, the new principal balance and the balance increase \n   **/ \n  function _calculateBalanceIncrease(address user) \n    internal \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256 \n    ) \n  { \n    uint256 previousPrincipalBalance = super.balanceOf(user); \n \n    if (previousPrincipalBalance == 0) { \n      return (0, 0, 0); \n    } \n \n    // Calculation of the accrued interest since the last accumulation \n    uint256 balanceIncrease = balanceOf(user).sub(previousPrincipalBalance); \n \n    return ( \n      previousPrincipalBalance, \n      previousPrincipalBalance.add(balanceIncrease), \n      balanceIncrease \n    ); \n  } \n \n  /** \n   * @dev Returns the principal and total supply, the average borrow rate and the last supply update \n   **/ \n  function getSupplyData() \n    public \n    view \n    override \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint40 \n    ) \n  { \n    uint256 avgRate = _avgStableRate; \n    return (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp); \n  } \n \n  /** \n   * @dev Returns the the total supply and the average stable rate \n   **/ \n  function getTotalSupplyAndAvgRate() public view override returns (uint256, uint256) { \n    uint256 avgRate = _avgStableRate; \n    return (_calcTotalSupply(avgRate), avgRate); \n  } \n \n  /** \n   * @dev Returns the total supply \n   **/ \n  function totalSupply() public view override returns (uint256) { \n    return _calcTotalSupply(_avgStableRate); \n  } \n \n  /** \n   * @dev Returns the timestamp at which the total supply was updated \n   **/ \n  function getTotalSupplyLastUpdated() public view override returns (uint40) { \n    return _totalSupplyTimestamp; \n  } \n \n  /** \n   * @dev Returns the principal debt balance of the user from \n   * @param user The user's address \n   * @return The debt balance of the user since the last burn/mint action \n   **/ \n  function principalBalanceOf(address user) external view virtual override returns (uint256) { \n    return super.balanceOf(user); \n  } \n \n  /** \n   * @dev Returns the principal debt balance of the user from \n   * @return The debt balance of the user since the last burn/mint action \n   **/ \n  function scaledBalanceOf(address user) public view virtual override returns (uint256) { \n    return super.balanceOf(user); \n  } \n \n  /** \n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index) \n   * @return the scaled total supply \n   **/ \n  function scaledTotalSupply() public view virtual override returns (uint256) { \n    return super.totalSupply(); \n  } \n \n  /** \n   * @dev Returns the principal balance of the user and principal total supply. \n   * @param user The address of the user \n   * @return The principal balance of the user \n   * @return The principal total supply \n   **/ \n  function getScaledUserBalanceAndSupply(address user) \n    external \n    view \n    override \n    returns (uint256, uint256) \n  { \n    return (super.balanceOf(user), super.totalSupply()); \n  } \n \n  /** \n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   **/ \n  function UNDERLYING_ASSET_ADDRESS() public view returns (address) { \n    return _underlyingAsset; \n  } \n \n  /** \n   * @dev Returns the address of the lending pool where this aToken is used \n   **/ \n  function POOL() public view returns (ILendingPool) { \n    return _pool; \n  } \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view override returns (IAaveIncentivesController) { \n    return _getIncentivesController(); \n  } \n \n  /** \n   * @dev For internal usage in the logic of the parent contracts \n   **/ \n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) { \n    return _incentivesController; \n  } \n \n  /** \n   * @dev For internal usage in the logic of the parent contracts \n   **/ \n  function _getUnderlyingAssetAddress() internal view override returns (address) { \n    return _underlyingAsset; \n  } \n \n  /** \n   * @dev For internal usage in the logic of the parent contracts \n   **/ \n  function _getLendingPool() internal view override returns (ILendingPool) { \n    return _pool; \n  } \n \n  /** \n   * @dev Calculates the total supply \n   * @param avgRate The average rate at which the total supply increases \n   * @return The debt balance of the user since the last burn/mint action \n   **/ \n  function _calcTotalSupply(uint256 avgRate) internal view virtual returns (uint256) { \n    uint256 principalSupply = super.totalSupply(); \n \n    if (principalSupply == 0) { \n      return 0; \n    } \n \n    uint256 cumulatedInterest = \n      MathUtils.calculateCompoundedInterest(avgRate, _totalSupplyTimestamp); \n \n    return principalSupply.rayMul(cumulatedInterest); \n  } \n \n  /** \n   * @dev Mints stable debt tokens to an user \n   * @param account The account receiving the debt tokens \n   * @param amount The amount being minted \n   * @param oldTotalSupply the total supply before the minting event \n   **/ \n  function _mint( \n    address account, \n    uint256 amount, \n    uint256 oldTotalSupply \n  ) internal { \n    uint256 oldAccountBalance = _balances[account]; \n    _balances[account] = oldAccountBalance.add(amount); \n \n    if (address(_incentivesController) != address(0)) { \n      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance); \n    } \n  } \n \n  /** \n   * @dev Burns stable debt tokens of an user \n   * @param account The user getting his debt burned \n   * @param amount The amount being burned \n   * @param oldTotalSupply The total supply before the burning event \n   **/ \n  function _burn( \n    address account, \n    uint256 amount, \n    uint256 oldTotalSupply \n  ) internal { \n    uint256 oldAccountBalance = _balances[account]; \n    _balances[account] = oldAccountBalance.sub(amount, Errors.SDT_BURN_EXCEEDS_BALANCE); \n \n    if (address(_incentivesController) != address(0)) { \n      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance); \n    } \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IAToken} from '../../interfaces/IAToken.sol'; \nimport {WadRayMath} from '../libraries/math/WadRayMath.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol'; \nimport {IncentivizedERC20} from './IncentivizedERC20.sol'; \nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol'; \n \n/** \n * @title Aave ERC20 AToken \n * @dev Implementation of the interest bearing token for the Aave protocol \n * @author Aave \n */ \ncontract AToken is \n  VersionedInitializable, \n  IncentivizedERC20('ATOKEN_IMPL', 'ATOKEN_IMPL', 0), \n  IAToken \n{ \n  using WadRayMath for uint256; \n  using SafeERC20 for IERC20; \n \n  bytes public constant EIP712_REVISION = bytes('1'); \n  bytes32 internal constant EIP712_DOMAIN = \n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'); \n  bytes32 public constant PERMIT_TYPEHASH = \n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'); \n \n  uint256 public constant ATOKEN_REVISION = 0x1; \n \n  /// @dev owner => next valid nonce to submit with permit() \n  mapping(address => uint256) public _nonces; \n \n  bytes32 public DOMAIN_SEPARATOR; \n \n  ILendingPool internal _pool; \n  address internal _treasury; \n  address internal _underlyingAsset; \n  IAaveIncentivesController internal _incentivesController; \n \n  modifier onlyLendingPool { \n    require(_msgSender() == address(_pool), Errors.CT_CALLER_MUST_BE_LENDING_POOL); \n    _; \n  } \n \n  function getRevision() internal pure virtual override returns (uint256) { \n    return ATOKEN_REVISION; \n  } \n \n  /** \n   * @dev Initializes the aToken \n   * @param pool The address of the lending pool where this aToken will be used \n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken \n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   * @param incentivesController The smart contract managing potential incentives distribution \n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's \n   * @param aTokenName The name of the aToken \n   * @param aTokenSymbol The symbol of the aToken \n   */ \n  function initialize( \n    ILendingPool pool, \n    address treasury, \n    address underlyingAsset, \n    IAaveIncentivesController incentivesController, \n    uint8 aTokenDecimals, \n    string calldata aTokenName, \n    string calldata aTokenSymbol, \n    bytes calldata params \n  ) external override initializer { \n    uint256 chainId; \n \n    //solium-disable-next-line \n    assembly { \n      chainId := chainid() \n    } \n \n    DOMAIN_SEPARATOR = keccak256( \n      abi.encode( \n        EIP712_DOMAIN, \n        keccak256(bytes(aTokenName)), \n        keccak256(EIP712_REVISION), \n        chainId, \n        address(this) \n      ) \n    ); \n \n    _setName(aTokenName); \n    _setSymbol(aTokenSymbol); \n    _setDecimals(aTokenDecimals); \n \n    _pool = pool; \n    _treasury = treasury; \n    _underlyingAsset = underlyingAsset; \n    _incentivesController = incentivesController; \n \n    emit Initialized( \n      underlyingAsset, \n      address(pool), \n      treasury, \n      address(incentivesController), \n      aTokenDecimals, \n      aTokenName, \n      aTokenSymbol, \n      params \n    ); \n  } \n \n  /** \n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnder\n   * - Only callable by the LendingPool, as extra state updates there need to be managed \n   * @param user The owner of the aTokens, getting them burned \n   * @param receiverOfUnderlying The address that will receive the underlying \n   * @param amount The amount being burned \n   * @param index The new liquidity index of the reserve \n   **/ \n  function burn( \n    address user, \n    address receiverOfUnderlying, \n    uint256 amount, \n    uint256 index \n  ) external override onlyLendingPool { \n    uint256 amountScaled = amount.rayDiv(index); \n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT); \n    _burn(user, amountScaled); \n \n    IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount); \n \n    emit Transfer(user, address(0), amount); \n    emit Burn(user, receiverOfUnderlying, amount, index); \n  } \n \n  /** \n   * @dev Mints `amount` aTokens to `user` \n   * - Only callable by the LendingPool, as extra state updates there need to be managed \n   * @param user The address receiving the minted tokens \n   * @param amount The amount of tokens getting minted \n   * @param index The new liquidity index of the reserve \n   * @return `true` if the the previous balance of the user was 0 \n   */ \n  function mint( \n    address user, \n    uint256 amount, \n    uint256 index \n  ) external override onlyLendingPool returns (bool) { \n    uint256 previousBalance = super.balanceOf(user); \n \n    uint256 amountScaled = amount.rayDiv(index); \n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT); \n    _mint(user, amountScaled); \n \n    emit Transfer(address(0), user, amount); \n    emit Mint(user, amount, index); \n \n    return previousBalance == 0; \n  } \n \n  /** \n   * @dev Mints aTokens to the reserve treasury \n   * - Only callable by the LendingPool \n   * @param amount The amount of tokens getting minted \n   * @param index The new liquidity index of the reserve \n   */ \n  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendingPool { \n    if (amount == 0) { \n      return; \n    } \n \n    address treasury = _treasury; \n \n    // Compared to the normal mint, we don't check for rounding errors. \n    // The amount to mint can easily be very small since it is a fraction of the interest ccrued. \n    // In that case, the treasury will experience a (very small) loss, but it \n    // wont cause potentially valid transactions to fail. \n    _mint(treasury, amount.rayDiv(index)); \n \n    emit Transfer(address(0), treasury, amount); \n    emit Mint(treasury, amount, index); \n  } \n \n  /** \n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclai\n   * - Only callable by the LendingPool \n   * @param from The address getting liquidated, current owner of the aTokens \n   * @param to The recipient \n   * @param value The amount of tokens getting transferred \n   **/ \n  function transferOnLiquidation( \n    address from, \n    address to, \n    uint256 value \n  ) external override onlyLendingPool { \n    // Being a normal transfer, the Transfer() and BalanceTransfer() are emitted \n    // so no need to emit a specific event here \n    _transfer(from, to, value, false); \n \n    emit Transfer(from, to, value); \n  } \n \n  /** \n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n   * @param user The user whose balance is calculated \n   * @return The balance of the user \n   **/ \n  function balanceOf(address user) \n    public \n    view \n    override(IncentivizedERC20, IERC20) \n    returns (uint256) \n  { \n    return super.balanceOf(user).rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset)); \n  } \n \n  /** \n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the \n   * updated stored balance divided by the reserve's liquidity index at the moment of the update \n   * @param user The user whose balance is calculated \n   * @return The scaled balance of the user \n   **/ \n  function scaledBalanceOf(address user) external view override returns (uint256) { \n    return super.balanceOf(user); \n  } \n \n  /** \n   * @dev Returns the scaled balance of the user and the scaled total supply. \n   * @param user The address of the user \n   * @return The scaled balance of the user \n   * @return The scaled balance and the scaled total supply \n   **/ \n  function getScaledUserBalanceAndSupply(address user) \n    external \n    view \n    override \n    returns (uint256, uint256) \n  { \n    return (super.balanceOf(user), super.totalSupply()); \n  } \n \n  /** \n   * @dev calculates the total supply of the specific aToken \n   * since the balance of every single user increases over time, the total supply \n   * does that too. \n   * @return the current total supply \n   **/ \n  function totalSupply() public view override(IncentivizedERC20, IERC20) returns (uint256) { \n    uint256 currentSupplyScaled = super.totalSupply(); \n \n    if (currentSupplyScaled == 0) { \n      return 0; \n    } \n \n    return currentSupplyScaled.rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset)); \n  } \n \n  /** \n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index) \n   * @return the scaled total supply \n   **/ \n  function scaledTotalSupply() public view virtual override returns (uint256) { \n    return super.totalSupply(); \n  } \n \n  /** \n   * @dev Returns the address of the Aave treasury, receiving the fees on this aToken \n   **/ \n  function RESERVE_TREASURY_ADDRESS() public view returns (address) { \n    return _treasury; \n  } \n \n  /** \n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   **/ \n  function UNDERLYING_ASSET_ADDRESS() public override view returns (address) { \n    return _underlyingAsset; \n  } \n \n  /** \n   * @dev Returns the address of the lending pool where this aToken is used \n   **/ \n  function POOL() public view returns (ILendingPool) { \n    return _pool; \n  } \n \n  /** \n   * @dev For internal usage in the logic of the parent contract IncentivizedERC20 \n   **/ \n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) { \n    return _incentivesController; \n  } \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view override returns (IAaveIncentivesController) { \n    return _getIncentivesController(); \n  } \n \n  /** \n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer \n   * assets in borrow(), withdraw() and flashLoan() \n   * @param target The recipient of the aTokens \n   * @param amount The amount getting transferred \n   * @return The amount transferred \n   **/ \n  function transferUnderlyingTo(address target, uint256 amount) \n    external \n    override \n    onlyLendingPool \n    returns (uint256) \n  { \n    IERC20(_underlyingAsset).safeTransfer(target, amount); \n    return amount; \n  } \n \n  /** \n   * @dev Invoked to execute actions on the aToken side after a repayment. \n   * @param user The user executing the repayment \n   * @param amount The amount getting repaid \n   **/ \n  function handleRepayment(address user, uint256 amount) external override onlyLendingPool {} \n \n  /** \n   * @dev implements the permit function as for \n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md \n   * @param owner The owner of the funds \n   * @param spender The spender \n   * @param value The amount \n   * @param deadline The deadline timestamp, type(uint256).max for max deadline \n   * @param v Signature param \n   * @param s Signature param \n   * @param r Signature param \n   */ \n  function permit( \n    address owner, \n    address spender, \n    uint256 value, \n    uint256 deadline, \n    uint8 v, \n    bytes32 r, \n    bytes32 s \n  ) external { \n    require(owner != address(0), 'INVALID_OWNER'); \n    //solium-disable-next-line \n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION'); \n    uint256 currentValidNonce = _nonces[owner]; \n    bytes32 digest = \n      keccak256( \n        abi.encodePacked( \n          '\\x19\\x01', \n          DOMAIN_SEPARATOR, \n          keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline)) \n        ) \n      ); \n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE'); \n    _nonces[owner] = currentValidNonce.add(1); \n    _approve(owner, spender, value); \n  } \n \n  /** \n   * @dev Transfers the aTokens between two users. Validates the transfer \n   * (ie checks for valid HF after the transfer) if required \n   * @param from The source address \n   * @param to The destination address \n   * @param amount The amount getting transferred \n   * @param validate `true` if the transfer needs to be validated \n   **/ \n  function _transfer( \n    address from, \n    address to, \n    uint256 amount, \n    bool validate \n  ) internal { \n    address underlyingAsset = _underlyingAsset; \n    ILendingPool pool = _pool; \n \n    uint256 index = pool.getReserveNormalizedIncome(underlyingAsset); \n \n    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index); \n    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index); \n \n    super._transfer(from, to, amount.rayDiv(index)); \n \n    if (validate) { \n      pool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore); \n    } \n \n    emit BalanceTransfer(from, to, amount, index); \n  } \n \n  /** \n   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom() \n   * @param from The source address \n   * @param to The destination address \n   * @param amount The amount getting transferred \n   **/ \n  function _transfer( \n    address from, \n    address to, \n    uint256 amount \n  ) internal override { \n    _transfer(from, to, amount, true); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol'; \nimport {WadRayMath} from '../libraries/math/WadRayMath.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {DebtTokenBase} from './base/DebtTokenBase.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol'; \n \n/** \n * @title VariableDebtToken \n * @notice Implements a variable debt token to track the borrowing positions of users \n * at variable rate mode \n * @author Aave \n **/ \ncontract VariableDebtToken is DebtTokenBase, IVariableDebtToken { \n  using WadRayMath for uint256; \n \n  uint256 public constant DEBT_TOKEN_REVISION = 0x1; \n \n  ILendingPool internal _pool; \n  address internal _underlyingAsset; \n  IAaveIncentivesController internal _incentivesController; \n \n  /** \n   * @dev Initializes the debt token. \n   * @param pool The address of the lending pool where this aToken will be used \n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   * @param incentivesController The smart contract managing potential incentives distribution \n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's \n   * @param debtTokenName The name of the token \n   * @param debtTokenSymbol The symbol of the token \n   */ \n  function initialize( \n    ILendingPool pool, \n    address underlyingAsset, \n    IAaveIncentivesController incentivesController, \n    uint8 debtTokenDecimals, \n    string memory debtTokenName, \n    string memory debtTokenSymbol, \n    bytes calldata params \n  ) public override initializer { \n    _setName(debtTokenName); \n    _setSymbol(debtTokenSymbol); \n    _setDecimals(debtTokenDecimals); \n \n    _pool = pool; \n    _underlyingAsset = underlyingAsset; \n    _incentivesController = incentivesController; \n \n    emit Initialized( \n      underlyingAsset, \n      address(pool), \n      address(incentivesController), \n      debtTokenDecimals, \n      debtTokenName, \n      debtTokenSymbol, \n      params \n    ); \n  } \n \n  /** \n   * @dev Gets the revision of the stable debt token implementation \n   * @return The debt token implementation revision \n   **/ \n  function getRevision() internal pure virtual override returns (uint256) { \n    return DEBT_TOKEN_REVISION; \n  } \n \n  /** \n   * @dev Calculates the accumulated debt balance of the user \n   * @return The debt balance of the user \n   **/ \n  function balanceOf(address user) public view virtual override returns (uint256) { \n    uint256 scaledBalance = super.balanceOf(user); \n \n    if (scaledBalance == 0) { \n      return 0; \n    } \n \n    return scaledBalance.rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset)); \n  } \n \n  /** \n   * @dev Mints debt token to the `onBehalfOf` address \n   * -  Only callable by the LendingPool \n   * @param user The address receiving the borrowed underlying, being the delegatee in case \n   * of credit delegate, or same as `onBehalfOf` otherwise \n   * @param onBehalfOf The address receiving the debt tokens \n   * @param amount The amount of debt being minted \n   * @param index The variable debt index of the reserve \n   * @return `true` if the the previous balance of the user is 0 \n   **/ \n  function mint( \n    address user, \n    address onBehalfOf, \n    uint256 amount, \n    uint256 index \n  ) external override onlyLendingPool returns (bool) { \n    if (user != onBehalfOf) { \n      _decreaseBorrowAllowance(onBehalfOf, user, amount); \n    } \n \n    uint256 previousBalance = super.balanceOf(onBehalfOf); \n    uint256 amountScaled = amount.rayDiv(index); \n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT); \n \n    _mint(onBehalfOf, amountScaled); \n \n    emit Transfer(address(0), onBehalfOf, amount); \n    emit Mint(user, onBehalfOf, amount, index); \n \n    return previousBalance == 0; \n  } \n \n  /** \n   * @dev Burns user variable debt \n   * - Only callable by the LendingPool \n   * @param user The user whose debt is getting burned \n   * @param amount The amount getting burned \n   * @param index The variable debt index of the reserve \n   **/ \n  function burn( \n    address user, \n    uint256 amount, \n    uint256 index \n  ) external override onlyLendingPool { \n    uint256 amountScaled = amount.rayDiv(index); \n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT); \n \n    _burn(user, amountScaled); \n \n    emit Transfer(user, address(0), amount); \n    emit Burn(user, amount, index); \n  } \n \n  /** \n   * @dev Returns the principal debt balance of the user from \n   * @return The debt balance of the user since the last burn/mint action \n   **/ \n  function scaledBalanceOf(address user) public view virtual override returns (uint256) { \n    return super.balanceOf(user); \n  } \n \n  /** \n   * @dev Returns the total supply of the variable debt token. Represents the total debt accrued by t\n   * @return The total supply \n   **/ \n  function totalSupply() public view virtual override returns (uint256) { \n    return super.totalSupply().rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset)); \n  } \n \n  /** \n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index) \n   * @return the scaled total supply \n   **/ \n  function scaledTotalSupply() public view virtual override returns (uint256) { \n    return super.totalSupply(); \n  } \n \n  /** \n   * @dev Returns the principal balance of the user and principal total supply. \n   * @param user The address of the user \n   * @return The principal balance of the user \n   * @return The principal total supply \n   **/ \n  function getScaledUserBalanceAndSupply(address user) \n    external \n    view \n    override \n    returns (uint256, uint256) \n  { \n    return (super.balanceOf(user), super.totalSupply()); \n  } \n \n  /** \n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   **/ \n  function UNDERLYING_ASSET_ADDRESS() public view returns (address) { \n    return _underlyingAsset; \n  } \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view override returns (IAaveIncentivesController) { \n    return _getIncentivesController(); \n  } \n \n  /** \n   * @dev Returns the address of the lending pool where this aToken is used \n   **/ \n  function POOL() public view returns (ILendingPool) { \n    return _pool; \n  } \n \n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) { \n    return _incentivesController; \n  } \n \n  function _getUnderlyingAssetAddress() internal view override returns (address) { \n    return _underlyingAsset; \n  } \n \n  function _getLendingPool() internal view override returns (ILendingPool) { \n    return _pool; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title Errors library \n * @author Aave \n * @notice Defines the error messages emitted by the different contracts of the Aave protocol \n * @dev Error messages prefix glossary: \n *  - VL = ValidationLogic \n *  - MATH = Math libraries \n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken) \n *  - AT = AToken \n *  - SDT = StableDebtToken \n *  - VDT = VariableDebtToken \n *  - LP = LendingPool \n *  - LPAPR = LendingPoolAddressesProviderRegistry \n *  - LPC = LendingPoolConfiguration \n *  - RL = ReserveLogic \n *  - LPCM = LendingPoolCollateralManager \n *  - P = Pausable \n */ \nlibrary Errors { \n  //common errors \n  string public constant CALLER_NOT_POOL_ADMIN = '33'; // 'The caller must be the pool admin' \n  string public constant BORROW_ALLOWANCE_NOT_ENOUGH = '59'; // User borrows on behalf, but allowance \n \n  //contract specific errors \n  string public constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0' \n  string public constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve' \n  string public constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve \n  string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = '4'; // 'The current liquidity i\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5'; // 'User cannot withdraw more th\n  string public constant VL_TRANSFER_NOT_ALLOWED = '6'; // 'Transfer cannot be allowed.' \n  string public constant VL_BORROWING_NOT_ENABLED = '7'; // 'Borrowing is not enabled' \n  string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8'; // 'Invalid interest rate mode \n  string public constant VL_COLLATERAL_BALANCE_IS_0 = '9'; // 'The collateral balance is 0' \n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10'; // 'Health factor \n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11'; // 'There is not enough collat\n  string public constant VL_STABLE_BORROWING_NOT_ENABLED = '12'; // stable borrowing not enabled \n  string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13'; // collateral is (mostly) t\n  string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14'; // 'The requested amount \n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = '15'; // 'for repayment of stable debt, the us\n  string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16'; // 'To repay on behalf of a\n  string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17'; // 'User does not have a stable ra\n  string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18'; // 'User does not have a variabl\n  string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19'; // 'The underlying balance \n  string public constant VL_DEPOSIT_ALREADY_IN_USE = '20'; // 'User deposit is already being used as \n  string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = '21'; // 'User does not have any stabl\n  string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22'; // 'Interest rate reba\n  string public constant LP_LIQUIDATION_CALL_FAILED = '23'; // 'Liquidation call failed' \n  string public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = '24'; // 'There is not enough liquidity \n  string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = '25'; // 'The requested amount is too small \n  string public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = '26'; // 'The actual balance of th\n  string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27'; // 'The caller of the functi\n  string public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = '28'; \n  string public constant CT_CALLER_MUST_BE_LENDING_POOL = '29'; // 'The caller of this function must \n  string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = '30'; // 'User cannot give allowance t\n  string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = '31'; // 'Transferred amount needs to be great\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = '32'; // 'Reserve has already been initiali\n  string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34'; // 'The liquidity of the reserve needs t\n  string public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = '35'; // 'The liquidity of the reserve nee\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = '36'; // 'The liquidity of the \n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = '37'; // 'The liquidity of th\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '38'; // 'The liquidity o\n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '39'; // 'The liquidity \n  string public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = '40'; // 'The liquidity of the reserve n\n  string public constant LPC_INVALID_CONFIGURATION = '75'; // 'Invalid risk parameters for the reserv\n  string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = '76'; // 'The caller must be the emergency \n  string public constant LPAPR_PROVIDER_NOT_REGISTERED = '41'; // 'Provider is not registered' \n  string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42'; // 'Health factor is not belo\n  string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43'; // 'The collateral chosen canno\n  string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44'; // 'User did not borrow \n  string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45'; // \"There isn't enough liquid\n  string public constant LPCM_NO_ERRORS = '46'; // 'No errors' \n  string public constant LP_INVALID_FLASHLOAN_MODE = '47'; //Invalid flashloan mode selected \n  string public constant MATH_MULTIPLICATION_OVERFLOW = '48'; \n  string public constant MATH_ADDITION_OVERFLOW = '49'; \n  string public constant MATH_DIVISION_BY_ZERO = '50'; \n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = '51'; //  Liquidity index overflows uint128 \n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52'; //  Variable borrow index overflow\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = '53'; //  Liquidity rate overflows uint128 \n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54'; //  Variable borrow rate overflows \n  string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '55'; //  Stable borrow rate overflows uint\n  string public constant CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint \n  string public constant LP_FAILED_REPAY_WITH_COLLATERAL = '57'; \n  string public constant CT_INVALID_BURN_AMOUNT = '58'; //invalid amount to burn \n  string public constant LP_FAILED_COLLATERAL_SWAP = '60'; \n  string public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = '61'; \n  string public constant LP_REENTRANCY_NOT_ALLOWED = '62'; \n  string public constant LP_CALLER_MUST_BE_AN_ATOKEN = '63'; \n  string public constant LP_IS_PAUSED = '64'; // 'Pool is paused' \n  string public constant LP_NO_MORE_RESERVES_ALLOWED = '65'; \n  string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66'; \n  string public constant RC_INVALID_LTV = '67'; \n  string public constant RC_INVALID_LIQ_THRESHOLD = '68'; \n  string public constant RC_INVALID_LIQ_BONUS = '69'; \n  string public constant RC_INVALID_DECIMALS = '70'; \n  string public constant RC_INVALID_RESERVE_FACTOR = '71'; \n  string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72'; \n  string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73'; \n  string public constant LP_INCONSISTENT_PARAMS_LENGTH = '74'; \n  string public constant UL_INVALID_INDEX = '77'; \n  string public constant LP_NOT_CONTRACT = '78'; \n  string public constant SDT_STABLE_DEBT_OVERFLOW = '79'; \n  string public constant SDT_BURN_EXCEEDS_BALANCE = '80'; \n \n  enum CollateralManagerErrors { \n    NO_ERROR, \n    NO_COLLATERAL_AVAILABLE, \n    COLLATERAL_CANNOT_BE_LIQUIDATED, \n    CURRRENCY_NOT_BORROWED, \n    HEALTH_FACTOR_ABOVE_THRESHOLD, \n    NOT_ENOUGH_LIQUIDITY, \n    NO_ACTIVE_RESERVE, \n    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD, \n    INVALID_EQUAL_ASSETS_TO_SWAP, \n    FROZEN_RESERVE \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title Helpers library \n * @author Aave \n */ \nlibrary Helpers { \n  /** \n   * @dev Fetches the user current stable and variable debt balances \n   * @param user The user address \n   * @param reserve The reserve data object \n   * @return The stable and variable debt balance \n   **/ \n  function getUserCurrentDebt(address user, DataTypes.ReserveData storage reserve) \n    internal \n    view \n    returns (uint256, uint256) \n  { \n    return ( \n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user), \n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user) \n    ); \n  } \n \n  function getUserCurrentDebtMemory(address user, DataTypes.ReserveData memory reserve) \n    internal \n    view \n    returns (uint256, uint256) \n  { \n    return ( \n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user), \n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user) \n    ); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title VersionedInitializable \n * \n * @dev Helper contract to implement initializer functions. To use it, replace \n * the constructor with a function that has the `initializer` modifier. \n * WARNING: Unlike constructors, initializer functions must be manually \n * invoked. This applies both to deploying an Initializable contract, as well \n * as extending an Initializable contract via inheritance. \n * WARNING: When used with inheritance, manual care must be taken to not invoke \n * a parent initializer twice, or ensure that all initializers are idempotent, \n * because this is not dealt with automatically as with constructors. \n * \n * @author Aave, inspired by the OpenZeppelin Initializable contract \n */ \nabstract contract VersionedInitializable { \n  /** \n   * @dev Indicates that the contract has been initialized. \n   */ \n  uint256 private lastInitializedRevision = 0; \n \n  /** \n   * @dev Indicates that the contract is in the process of being initialized. \n   */ \n  bool private initializing; \n \n  /** \n   * @dev Modifier to use in the initializer function of a contract. \n   */ \n  modifier initializer() { \n    uint256 revision = getRevision(); \n    require( \n      initializing || isConstructor() || revision > lastInitializedRevision, \n      'Contract instance has already been initialized' \n    ); \n \n    bool isTopLevelCall = !initializing; \n    if (isTopLevelCall) { \n      initializing = true; \n      lastInitializedRevision = revision; \n    } \n \n    _; \n \n    if (isTopLevelCall) { \n      initializing = false; \n    } \n  } \n \n  /** \n   * @dev returns the revision number of the contract \n   * Needs to be defined in the inherited class as a constant. \n   **/ \n  function getRevision() internal pure virtual returns (uint256); \n \n  /** \n   * @dev Returns true if and only if the function is running in the constructor \n   **/ \n  function isConstructor() private view returns (bool) { \n    // extcodesize checks the size of the code stored in an address, and \n    // address returns the current address. Since the code is still not \n    // deployed when running a constructor, any checks on its code size will \n    // yield zero, making it an effective way to detect if a contract is \n    // under construction or not. \n    uint256 cs; \n    //solium-disable-next-line \n    assembly { \n      cs := extcodesize(address()) \n    } \n    return cs == 0; \n  } \n \n  // Reserved storage space to allow for layout changes in the future. \n  uint256[50] private ______gap; \n} \n",
            "pragma solidity 0.6.12; \n \nimport './BaseImmutableAdminUpgradeabilityProxy.sol'; \nimport '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol'; \n \n/** \n * @title InitializableAdminUpgradeabilityProxy \n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function \n */ \ncontract InitializableImmutableAdminUpgradeabilityProxy is \n  BaseImmutableAdminUpgradeabilityProxy, \n  InitializableUpgradeabilityProxy \n{ \n  constructor(address admin) public BaseImmutableAdminUpgradeabilityProxy(admin) {} \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) { \n    BaseImmutableAdminUpgradeabilityProxy._willFallback(); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title BaseImmutableAdminUpgradeabilityProxy \n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern \n * @dev This contract combines an upgradeability proxy with an authorization \n * mechanism for administrative tasks. The admin role is stored in an immutable, which \n * helps saving transactions costs \n * All external functions in this contract must be guarded by the \n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity \n * feature proposal that would enable this to be done automatically. \n */ \ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy { \n  address immutable ADMIN; \n \n  constructor(address admin) public { \n    ADMIN = admin; \n  } \n \n  modifier ifAdmin() { \n    if (msg.sender == ADMIN) { \n      _; \n    } else { \n      _fallback(); \n    } \n  } \n \n  /** \n   * @return The address of the proxy admin. \n   */ \n  function admin() external ifAdmin returns (address) { \n    return ADMIN; \n  } \n \n  /** \n   * @return The address of the implementation. \n   */ \n  function implementation() external ifAdmin returns (address) { \n    return _implementation(); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy. \n   * Only the admin can call this function. \n   * @param newImplementation Address of the new implementation. \n   */ \n  function upgradeTo(address newImplementation) external ifAdmin { \n    _upgradeTo(newImplementation); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy and call a function \n   * on the new implementation. \n   * This is useful to initialize the proxied contract. \n   * @param newImplementation Address of the new implementation. \n   * @param data Data to send as msg.data in the low level call. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   */ \n  function upgradeToAndCall(address newImplementation, bytes calldata data) \n    external \n    payable \n    ifAdmin \n  { \n    _upgradeTo(newImplementation); \n    (bool success, ) = newImplementation.delegatecall(data); \n    require(success); \n  } \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal virtual override { \n    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin'); \n    super._willFallback(); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \n \n/** \n * @title PercentageMath library \n * @author Aave \n * @notice Provides functions to perform percentage calculations \n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is in\n * @dev Operations are rounded half up \n **/ \n \nlibrary PercentageMath { \n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals \n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2; \n \n  /** \n   * @dev Executes a percentage multiplication \n   * @param value The value of which the percentage needs to be calculated \n   * @param percentage The percentage of the value to be calculated \n   * @return The percentage of value \n   **/ \n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) { \n    if (value == 0 || percentage == 0) { \n      return 0; \n    } \n \n    require( \n      value <= (type(uint256).max - HALF_PERCENT) / percentage, \n      Errors.MATH_MULTIPLICATION_OVERFLOW \n    ); \n \n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR; \n  } \n \n  /** \n   * @dev Executes a percentage division \n   * @param value The value of which the percentage needs to be calculated \n   * @param percentage The percentage of the value to be calculated \n   * @return The value divided the percentage \n   **/ \n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) { \n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO); \n    uint256 halfPercentage = percentage / 2; \n \n    require( \n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, \n      Errors.MATH_MULTIPLICATION_OVERFLOW \n    ); \n \n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \n \n/** \n * @title WadRayMath library \n * @author Aave \n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (d\n **/ \n \nlibrary WadRayMath { \n  uint256 internal constant WAD = 1e18; \n  uint256 internal constant halfWAD = WAD / 2; \n \n  uint256 internal constant RAY = 1e27; \n  uint256 internal constant halfRAY = RAY / 2; \n \n  uint256 internal constant WAD_RAY_RATIO = 1e9; \n \n  /** \n   * @return One ray, 1e27 \n   **/ \n  function ray() internal pure returns (uint256) { \n    return RAY; \n  } \n \n  /** \n   * @return One wad, 1e18 \n   **/ \n \n  function wad() internal pure returns (uint256) { \n    return WAD; \n  } \n \n  /** \n   * @return Half ray, 1e27/2 \n   **/ \n  function halfRay() internal pure returns (uint256) { \n    return halfRAY; \n  } \n \n  /** \n   * @return Half ray, 1e18/2 \n   **/ \n  function halfWad() internal pure returns (uint256) { \n    return halfWAD; \n  } \n \n  /** \n   * @dev Multiplies two wad, rounding half up to the nearest wad \n   * @param a Wad \n   * @param b Wad \n   * @return The result of a*b, in wad \n   **/ \n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) { \n    if (a == 0 || b == 0) { \n      return 0; \n    } \n \n    require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * b + halfWAD) / WAD; \n  } \n \n  /** \n   * @dev Divides two wad, rounding half up to the nearest wad \n   * @param a Wad \n   * @param b Wad \n   * @return The result of a/b, in wad \n   **/ \n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) { \n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO); \n    uint256 halfB = b / 2; \n \n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * WAD + halfB) / b; \n  } \n \n  /** \n   * @dev Multiplies two ray, rounding half up to the nearest ray \n   * @param a Ray \n   * @param b Ray \n   * @return The result of a*b, in ray \n   **/ \n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) { \n    if (a == 0 || b == 0) { \n      return 0; \n    } \n \n    require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * b + halfRAY) / RAY; \n  } \n \n  /** \n   * @dev Divides two ray, rounding half up to the nearest ray \n   * @param a Ray \n   * @param b Ray \n   * @return The result of a/b, in ray \n   **/ \n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) { \n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO); \n    uint256 halfB = b / 2; \n \n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * RAY + halfB) / b; \n  } \n \n  /** \n   * @dev Casts ray down to wad \n   * @param a Ray \n   * @return a casted to wad, rounded half up to the nearest wad \n   **/ \n  function rayToWad(uint256 a) internal pure returns (uint256) { \n    uint256 halfRatio = WAD_RAY_RATIO / 2; \n    uint256 result = halfRatio + a; \n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW); \n \n    return result / WAD_RAY_RATIO; \n  } \n \n  /** \n   * @dev Converts wad up to ray \n   * @param a Wad \n   * @return a converted in ray \n   **/ \n  function wadToRay(uint256 a) internal pure returns (uint256) { \n    uint256 result = a * WAD_RAY_RATIO; \n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW); \n    return result; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {WadRayMath} from './WadRayMath.sol'; \n \nlibrary MathUtils { \n  using SafeMath for uint256; \n  using WadRayMath for uint256; \n \n  /// @dev Ignoring leap years \n  uint256 internal constant SECONDS_PER_YEAR = 365 days; \n \n  /** \n   * @dev Function to calculate the interest accumulated using a linear interest rate formula \n   * @param rate The interest rate, in ray \n   * @param lastUpdateTimestamp The timestamp of the last update of the interest \n   * @return The interest rate linearly accumulated during the timeDelta, in ray \n   **/ \n \n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) \n    internal \n    view \n    returns (uint256) \n  { \n    //solium-disable-next-line \n    uint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp)); \n \n    return (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray()); \n  } \n \n  /** \n   * @dev Function to calculate the interest using a compounded interest rate formula \n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation: \n   * \n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3... \n   * \n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the ad\n   * The whitepaper contains reference to the approximation and a table showing the margin of error p\n   * \n   * @param rate The interest rate, in ray \n   * @param lastUpdateTimestamp The timestamp of the last update of the interest \n   * @return The interest rate compounded during the timeDelta, in ray \n   **/ \n  function calculateCompoundedInterest( \n    uint256 rate, \n    uint40 lastUpdateTimestamp, \n    uint256 currentTimestamp \n  ) internal pure returns (uint256) { \n    //solium-disable-next-line \n    uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp)); \n \n    if (exp == 0) { \n      return WadRayMath.ray(); \n    } \n \n    uint256 expMinusOne = exp - 1; \n \n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0; \n \n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR; \n \n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond); \n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond); \n \n    uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2; \n    uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6; \n \n    return WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm); \n  } \n \n  /** \n   * @dev Calculates the compounded interest between the timestamp of the last update and the current \n   * @param rate The interest rate (in ray) \n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calcul\n   **/ \n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) \n    internal \n    view \n    returns (uint256) \n  { \n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp); \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {ReserveLogic} from './ReserveLogic.sol'; \nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol'; \nimport {UserConfiguration} from '../configuration/UserConfiguration.sol'; \nimport {WadRayMath} from '../math/WadRayMath.sol'; \nimport {PercentageMath} from '../math/PercentageMath.sol'; \nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title GenericLogic library \n * @author Aave \n * @title Implements protocol-level logic to calculate and validate the state of a user \n */ \nlibrary GenericLogic { \n  using ReserveLogic for DataTypes.ReserveData; \n  using SafeMath for uint256; \n  using WadRayMath for uint256; \n  using PercentageMath for uint256; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether; \n \n  struct balanceDecreaseAllowedLocalVars { \n    uint256 decimals; \n    uint256 liquidationThreshold; \n    uint256 totalCollateralInETH; \n    uint256 totalDebtInETH; \n    uint256 avgLiquidationThreshold; \n    uint256 amountToDecreaseInETH; \n    uint256 collateralBalanceAfterDecrease; \n    uint256 liquidationThresholdAfterDecrease; \n    uint256 healthFactorAfterDecrease; \n    bool reserveUsageAsCollateralEnabled; \n  } \n \n  /** \n   * @dev Checks if a specific balance decrease is allowed \n   * (i.e. doesn't bring the user borrow position health factor under HEALTH_FACTOR_LIQUIDATION_THRES\n   * @param asset The address of the underlying asset of the reserve \n   * @param user The address of the user \n   * @param amount The amount to decrease \n   * @param reservesData The data of all the reserves \n   * @param userConfig The user configuration \n   * @param reserves The list of all the active reserves \n   * @param oracle The address of the oracle contract \n   * @return true if the decrease of the balance is allowed \n   **/ \n  function balanceDecreaseAllowed( \n    address asset, \n    address user, \n    uint256 amount, \n    mapping(address => DataTypes.ReserveData) storage reservesData, \n    DataTypes.UserConfigurationMap calldata userConfig, \n    mapping(uint256 => address) storage reserves, \n    uint256 reservesCount, \n    address oracle \n  ) external view returns (bool) { \n    if (!userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral(reservesData[asset].id)) { \n      return true; \n    } \n \n    balanceDecreaseAllowedLocalVars memory vars; \n \n    (, vars.liquidationThreshold, , vars.decimals, ) = reservesData[asset] \n      .configuration \n      .getParams(); \n \n    if (vars.liquidationThreshold == 0) { \n      return true; \n    } \n \n    ( \n      vars.totalCollateralInETH, \n      vars.totalDebtInETH, \n      , \n      vars.avgLiquidationThreshold, \n \n    ) = calculateUserAccountData(user, reservesData, userConfig, reserves, reservesCount, oracle); \n \n    if (vars.totalDebtInETH == 0) { \n      return true; \n    } \n \n    vars.amountToDecreaseInETH = IPriceOracleGetter(oracle).getAssetPrice(asset).mul(amount).div( \n      10**vars.decimals \n    ); \n \n    vars.collateralBalanceAfterDecrease = vars.totalCollateralInETH.sub(vars.amountToDecreaseInETH); \n \n    //if there is a borrow, there can't be 0 collateral \n    if (vars.collateralBalanceAfterDecrease == 0) { \n      return false; \n    } \n \n    vars.liquidationThresholdAfterDecrease = vars \n      .totalCollateralInETH \n      .mul(vars.avgLiquidationThreshold) \n      .sub(vars.amountToDecreaseInETH.mul(vars.liquidationThreshold)) \n      .div(vars.collateralBalanceAfterDecrease); \n \n    uint256 healthFactorAfterDecrease = \n      calculateHealthFactorFromBalances( \n        vars.collateralBalanceAfterDecrease, \n        vars.totalDebtInETH, \n        vars.liquidationThresholdAfterDecrease \n      ); \n \n    return healthFactorAfterDecrease >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD; \n  } \n \n  struct CalculateUserAccountDataVars { \n    uint256 reserveUnitPrice; \n    uint256 tokenUnit; \n    uint256 compoundedLiquidityBalance; \n    uint256 compoundedBorrowBalance; \n    uint256 decimals; \n    uint256 ltv; \n    uint256 liquidationThreshold; \n    uint256 i; \n    uint256 healthFactor; \n    uint256 totalCollateralInETH; \n    uint256 totalDebtInETH; \n    uint256 avgLtv; \n    uint256 avgLiquidationThreshold; \n    uint256 reservesLength; \n    bool healthFactorBelowThreshold; \n    address currentReserveAddress; \n    bool usageAsCollateralEnabled; \n    bool userUsesReserveAsCollateral; \n  } \n \n  /** \n   * @dev Calculates the user data across the reserves. \n   * this includes the total liquidity/collateral/borrow balances in ETH, \n   * the average Loan To Value, the average Liquidation Ratio, and the Health factor. \n   * @param user The address of the user \n   * @param reservesData Data of all the reserves \n   * @param userConfig The configuration of the user \n   * @param reserves The list of the available reserves \n   * @param oracle The price oracle address \n   * @return The total collateral and total debt of the user in ETH, the avg ltv, liquidation thresho\n   **/ \n  function calculateUserAccountData( \n    address user, \n    mapping(address => DataTypes.ReserveData) storage reservesData, \n    DataTypes.UserConfigurationMap memory userConfig, \n    mapping(uint256 => address) storage reserves, \n    uint256 reservesCount, \n    address oracle \n  ) \n    internal \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256, \n      uint256 \n    ) \n  { \n    CalculateUserAccountDataVars memory vars; \n \n    if (userConfig.isEmpty()) { \n      return (0, 0, 0, 0, uint256(-1)); \n    } \n    for (vars.i = 0; vars.i < reservesCount; vars.i++) { \n      if (!userConfig.isUsingAsCollateralOrBorrowing(vars.i)) { \n        continue; \n      } \n \n      vars.currentReserveAddress = reserves[vars.i]; \n      DataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress]; \n \n      (vars.ltv, vars.liquidationThreshold, , vars.decimals, ) = currentReserve \n        .configuration \n        .getParams(); \n \n      vars.tokenUnit = 10**vars.decimals; \n      vars.reserveUnitPrice = IPriceOracleGetter(oracle).getAssetPrice(vars.currentReserveAddress); \n \n      if (vars.liquidationThreshold != 0 && userConfig.isUsingAsCollateral(vars.i)) { \n        vars.compoundedLiquidityBalance = IERC20(currentReserve.aTokenAddress).balanceOf(user); \n \n        uint256 liquidityBalanceETH = \n          vars.reserveUnitPrice.mul(vars.compoundedLiquidityBalance).div(vars.tokenUnit); \n \n        vars.totalCollateralInETH = vars.totalCollateralInETH.add(liquidityBalanceETH); \n \n        vars.avgLtv = vars.avgLtv.add(liquidityBalanceETH.mul(vars.ltv)); \n        vars.avgLiquidationThreshold = vars.avgLiquidationThreshold.add( \n          liquidityBalanceETH.mul(vars.liquidationThreshold) \n        ); \n      } \n \n      if (userConfig.isBorrowing(vars.i)) { \n        vars.compoundedBorrowBalance = IERC20(currentReserve.stableDebtTokenAddress).balanceOf( \n          user \n        ); \n        vars.compoundedBorrowBalance = vars.compoundedBorrowBalance.add( \n          IERC20(currentReserve.variableDebtTokenAddress).balanceOf(user) \n        ); \n \n        vars.totalDebtInETH = vars.totalDebtInETH.add( \n          vars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit) \n        ); \n      } \n    } \n \n    vars.avgLtv = vars.totalCollateralInETH > 0 ? vars.avgLtv.div(vars.totalCollateralInETH) : 0; \n    vars.avgLiquidationThreshold = vars.totalCollateralInETH > 0 \n      ? vars.avgLiquidationThreshold.div(vars.totalCollateralInETH) \n      : 0; \n \n    vars.healthFactor = calculateHealthFactorFromBalances( \n      vars.totalCollateralInETH, \n      vars.totalDebtInETH, \n      vars.avgLiquidationThreshold \n    ); \n    return ( \n      vars.totalCollateralInETH, \n      vars.totalDebtInETH, \n      vars.avgLtv, \n      vars.avgLiquidationThreshold, \n      vars.healthFactor \n    ); \n  } \n \n  /** \n   * @dev Calculates the health factor from the corresponding balances \n   * @param totalCollateralInETH The total collateral in ETH \n   * @param totalDebtInETH The total debt in ETH \n   * @param liquidationThreshold The avg liquidation threshold \n   * @return The health factor calculated from the balances provided \n   **/ \n  function calculateHealthFactorFromBalances( \n    uint256 totalCollateralInETH, \n    uint256 totalDebtInETH, \n    uint256 liquidationThreshold \n  ) internal pure returns (uint256) { \n    if (totalDebtInETH == 0) return uint256(-1); \n \n    return (totalCollateralInETH.percentMul(liquidationThreshold)).wadDiv(totalDebtInETH); \n  } \n \n  /** \n   * @dev Calculates the equivalent amount in ETH that an user can borrow, depending on the available \n   * average Loan To Value \n   * @param totalCollateralInETH The total collateral in ETH \n   * @param totalDebtInETH The total borrow balance \n   * @param ltv The average loan to value \n   * @return the amount available to borrow in ETH for the user \n   **/ \n \n  function calculateAvailableBorrowsETH( \n    uint256 totalCollateralInETH, \n    uint256 totalDebtInETH, \n    uint256 ltv \n  ) internal pure returns (uint256) { \n    uint256 availableBorrowsETH = totalCollateralInETH.percentMul(ltv); \n \n    if (availableBorrowsETH < totalDebtInETH) { \n      return 0; \n    } \n \n    availableBorrowsETH = availableBorrowsETH.sub(totalDebtInETH); \n    return availableBorrowsETH; \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {ReserveLogic} from './ReserveLogic.sol'; \nimport {GenericLogic} from './GenericLogic.sol'; \nimport {WadRayMath} from '../math/WadRayMath.sol'; \nimport {PercentageMath} from '../math/PercentageMath.sol'; \nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol'; \nimport {UserConfiguration} from '../configuration/UserConfiguration.sol'; \nimport {Errors} from '../helpers/Errors.sol'; \nimport {Helpers} from '../helpers/Helpers.sol'; \nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title ReserveLogic library \n * @author Aave \n * @notice Implements functions to validate the different actions of the protocol \n */ \nlibrary ValidationLogic { \n  using ReserveLogic for DataTypes.ReserveData; \n  using SafeMath for uint256; \n  using WadRayMath for uint256; \n  using PercentageMath for uint256; \n  using SafeERC20 for IERC20; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000; \n  uint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95% \n \n  /** \n   * @dev Validates a deposit action \n   * @param reserve The reserve object on which the user is depositing \n   * @param amount The amount to be deposited \n   */ \n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view { \n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags(); \n \n    require(amount != 0, Errors.VL_INVALID_AMOUNT); \n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE); \n    require(!isFrozen, Errors.VL_RESERVE_FROZEN); \n  } \n \n  /** \n   * @dev Validates a withdraw action \n   * @param reserveAddress The address of the reserve \n   * @param amount The amount to be withdrawn \n   * @param userBalance The balance of the user \n   * @param reservesData The reserves state \n   * @param userConfig The user configuration \n   * @param reserves The addresses of the reserves \n   * @param reservesCount The number of reserves \n   * @param oracle The price oracle \n   */ \n  function validateWithdraw( \n    address reserveAddress, \n    uint256 amount, \n    uint256 userBalance, \n    mapping(address => DataTypes.ReserveData) storage reservesData, \n    DataTypes.UserConfigurationMap storage userConfig, \n    mapping(uint256 => address) storage reserves, \n    uint256 reservesCount, \n    address oracle \n  ) external view { \n    require(amount != 0, Errors.VL_INVALID_AMOUNT); \n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE); \n \n    (bool isActive, , , ) = reservesData[reserveAddress].configuration.getFlags(); \n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE); \n \n    require( \n      GenericLogic.balanceDecreaseAllowed( \n        reserveAddress, \n        msg.sender, \n        amount, \n        reservesData, \n        userConfig, \n        reserves, \n        reservesCount, \n        oracle \n      ), \n      Errors.VL_TRANSFER_NOT_ALLOWED \n    ); \n  } \n \n  struct ValidateBorrowLocalVars { \n    uint256 currentLtv; \n    uint256 currentLiquidationThreshold; \n    uint256 amountOfCollateralNeededETH; \n    uint256 userCollateralBalanceETH; \n    uint256 userBorrowBalanceETH; \n    uint256 availableLiquidity; \n    uint256 healthFactor; \n    bool isActive; \n    bool isFrozen; \n    bool borrowingEnabled; \n    bool stableRateBorrowingEnabled; \n  } \n \n  /** \n   * @dev Validates a borrow action \n   * @param asset The address of the asset to borrow \n   * @param reserve The reserve state from which the user is borrowing \n   * @param userAddress The address of the user \n   * @param amount The amount to be borrowed \n   * @param amountInETH The amount to be borrowed, in ETH \n   * @param interestRateMode The interest rate mode at which the user is borrowing \n   * @param maxStableLoanPercent The max amount of the liquidity that can be borrowed at stable rate, \n   * @param reservesData The state of all the reserves \n   * @param userConfig The state of the user for the specific reserve \n   * @param reserves The addresses of all the active reserves \n   * @param oracle The price oracle \n   */ \n \n  function validateBorrow( \n    address asset, \n    DataTypes.ReserveData storage reserve, \n    address userAddress, \n    uint256 amount, \n    uint256 amountInETH, \n    uint256 interestRateMode, \n    uint256 maxStableLoanPercent, \n    mapping(address => DataTypes.ReserveData) storage reservesData, \n    DataTypes.UserConfigurationMap storage userConfig, \n    mapping(uint256 => address) storage reserves, \n    uint256 reservesCount, \n    address oracle \n  ) external view { \n    ValidateBorrowLocalVars memory vars; \n \n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserve \n      .configuration \n      .getFlags(); \n \n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE); \n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN); \n    require(amount != 0, Errors.VL_INVALID_AMOUNT); \n \n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED); \n \n    //validate interest rate mode \n    require( \n      uint256(DataTypes.InterestRateMode.VARIABLE) == interestRateMode || \n        uint256(DataTypes.InterestRateMode.STABLE) == interestRateMode, \n      Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED \n    ); \n \n    ( \n      vars.userCollateralBalanceETH, \n      vars.userBorrowBalanceETH, \n      vars.currentLtv, \n      vars.currentLiquidationThreshold, \n      vars.healthFactor \n    ) = GenericLogic.calculateUserAccountData( \n      userAddress, \n      reservesData, \n      userConfig, \n      reserves, \n      reservesCount, \n      oracle \n    ); \n \n    require(vars.userCollateralBalanceETH > 0, Errors.VL_COLLATERAL_BALANCE_IS_0); \n \n    require( \n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD, \n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD \n    ); \n \n    //add the current already borrowed amount to the amount requested to calculate the total collater\n    vars.amountOfCollateralNeededETH = vars.userBorrowBalanceETH.add(amountInETH).percentDiv( \n      vars.currentLtv \n    ); //LTV is calculated in percentage \n \n    require( \n      vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH, \n      Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW \n    ); \n \n    /** \n     * Following conditions need to be met if the user is borrowing at a stable rate: \n     * 1. Reserve must be enabled for stable rate borrowing \n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency \n     *    they are borrowing, to prevent abuses. \n     * 3. Users will be able to borrow only a portion of the total available liquidity \n     **/ \n \n    if (interestRateMode == uint256(DataTypes.InterestRateMode.STABLE)) { \n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve \n \n      require(vars.stableRateBorrowingEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED); \n \n      require( \n        !userConfig.isUsingAsCollateral(reserve.id) || \n          reserve.configuration.getLtv() == 0 || \n          amount > IERC20(reserve.aTokenAddress).balanceOf(userAddress), \n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY \n      ); \n \n      vars.availableLiquidity = IERC20(asset).balanceOf(reserve.aTokenAddress); \n \n      //calculate the max available loan size in stable rate mode as a percentage of the \n      //available liquidity \n      uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent); \n \n      require(amount <= maxLoanSizeStable, Errors.VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE); \n    } \n  } \n \n  /** \n   * @dev Validates a repay action \n   * @param reserve The reserve state from which the user is repaying \n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1) \n   * @param onBehalfOf The address of the user msg.sender is repaying for \n   * @param stableDebt The borrow balance of the user \n   * @param variableDebt The borrow balance of the user \n   */ \n  function validateRepay( \n    DataTypes.ReserveData storage reserve, \n    uint256 amountSent, \n    DataTypes.InterestRateMode rateMode, \n    address onBehalfOf, \n    uint256 stableDebt, \n    uint256 variableDebt \n  ) external view { \n    bool isActive = reserve.configuration.getActive(); \n \n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE); \n \n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT); \n \n    require( \n      (stableDebt > 0 && \n        DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE) || \n        (variableDebt > 0 && \n          DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.VARIABLE), \n      Errors.VL_NO_DEBT_OF_SELECTED_TYPE \n    ); \n \n    require( \n      amountSent != uint256(-1) || msg.sender == onBehalfOf, \n      Errors.VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF \n    ); \n  } \n \n  /** \n   * @dev Validates a swap of borrow rate mode. \n   * @param reserve The reserve state on which the user is swapping the rate \n   * @param userConfig The user reserves configuration \n   * @param stableDebt The stable debt of the user \n   * @param variableDebt The variable debt of the user \n   * @param currentRateMode The rate mode of the borrow \n   */ \n  function validateSwapRateMode( \n    DataTypes.ReserveData storage reserve, \n    DataTypes.UserConfigurationMap storage userConfig, \n    uint256 stableDebt, \n    uint256 variableDebt, \n    DataTypes.InterestRateMode currentRateMode \n  ) external view { \n    (bool isActive, bool isFrozen, , bool stableRateEnabled) = reserve.configuration.getFlags(); \n \n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE); \n    require(!isFrozen, Errors.VL_RESERVE_FROZEN); \n \n    if (currentRateMode == DataTypes.InterestRateMode.STABLE) { \n      require(stableDebt > 0, Errors.VL_NO_STABLE_RATE_LOAN_IN_RESERVE); \n    } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) { \n      require(variableDebt > 0, Errors.VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE); \n      /** \n       * user wants to swap to stable, before swapping we need to ensure that \n       * 1. stable borrow rate is enabled on the reserve \n       * 2. user is not trying to abuse the reserve by depositing \n       * more collateral than he is borrowing, artificially lowering \n       * the interest rate, borrowing at variable, and switching to stable \n       **/ \n      require(stableRateEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED); \n \n      require( \n        !userConfig.isUsingAsCollateral(reserve.id) || \n          reserve.configuration.getLtv() == 0 || \n          stableDebt.add(variableDebt) > IERC20(reserve.aTokenAddress).balanceOf(msg.sender), \n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY \n      ); \n    } else { \n      revert(Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED); \n    } \n  } \n \n  /** \n   * @dev Validates a stable borrow rate rebalance action \n   * @param reserve The reserve state on which the user is getting rebalanced \n   * @param reserveAddress The address of the reserve \n   * @param stableDebtToken The stable debt token instance \n   * @param variableDebtToken The variable debt token instance \n   * @param aTokenAddress The address of the aToken contract \n   */ \n  function validateRebalanceStableBorrowRate( \n    DataTypes.ReserveData storage reserve, \n    address reserveAddress, \n    IERC20 stableDebtToken, \n    IERC20 variableDebtToken, \n    address aTokenAddress \n  ) external view { \n    (bool isActive, , , ) = reserve.configuration.getFlags(); \n \n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE); \n \n    //if the usage ratio is below 95%, no rebalances are needed \n    uint256 totalDebt = \n      stableDebtToken.totalSupply().add(variableDebtToken.totalSupply()).wadToRay(); \n    uint256 availableLiquidity = IERC20(reserveAddress).balanceOf(aTokenAddress).wadToRay(); \n    uint256 usageRatio = totalDebt == 0 ? 0 : totalDebt.rayDiv(availableLiquidity.add(totalDebt)); \n \n    //if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage, \n    //then we allow rebalancing of the stable rate positions. \n \n    uint256 currentLiquidityRate = reserve.currentLiquidityRate; \n    uint256 maxVariableBorrowRate = \n      IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).getMaxVariableBorrowRate(); \n \n    require( \n      usageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD && \n        currentLiquidityRate <= \n        maxVariableBorrowRate.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD), \n      Errors.LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET \n    ); \n  } \n \n  /** \n   * @dev Validates the action of setting an asset as collateral \n   * @param reserve The state of the reserve that the user is enabling or disabling as collateral \n   * @param reserveAddress The address of the reserve \n   * @param reservesData The data of all the reserves \n   * @param userConfig The state of the user for the specific reserve \n   * @param reserves The addresses of all the active reserves \n   * @param oracle The price oracle \n   */ \n  function validateSetUseReserveAsCollateral( \n    DataTypes.ReserveData storage reserve, \n    address reserveAddress, \n    bool useAsCollateral, \n    mapping(address => DataTypes.ReserveData) storage reservesData, \n    DataTypes.UserConfigurationMap storage userConfig, \n    mapping(uint256 => address) storage reserves, \n    uint256 reservesCount, \n    address oracle \n  ) external view { \n    uint256 underlyingBalance = IERC20(reserve.aTokenAddress).balanceOf(msg.sender); \n \n    require(underlyingBalance > 0, Errors.VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0); \n \n    require( \n      useAsCollateral || \n        GenericLogic.balanceDecreaseAllowed( \n          reserveAddress, \n          msg.sender, \n          underlyingBalance, \n          reservesData, \n          userConfig, \n          reserves, \n          reservesCount, \n          oracle \n        ), \n      Errors.VL_DEPOSIT_ALREADY_IN_USE \n    ); \n  } \n \n  /** \n   * @dev Validates a flashloan action \n   * @param assets The assets being flashborrowed \n   * @param amounts The amounts for each asset being borrowed \n   **/ \n  function validateFlashloan(address[] memory assets, uint256[] memory amounts) internal pure { \n    require(assets.length == amounts.length, Errors.VL_INCONSISTENT_FLASHLOAN_PARAMS); \n  } \n \n  /** \n   * @dev Validates the liquidation action \n   * @param collateralReserve The reserve data of the collateral \n   * @param principalReserve The reserve data of the principal \n   * @param userConfig The user configuration \n   * @param userHealthFactor The user's health factor \n   * @param userStableDebt Total stable debt balance of the user \n   * @param userVariableDebt Total variable debt balance of the user \n   **/ \n  function validateLiquidationCall( \n    DataTypes.ReserveData storage collateralReserve, \n    DataTypes.ReserveData storage principalReserve, \n    DataTypes.UserConfigurationMap storage userConfig, \n    uint256 userHealthFactor, \n    uint256 userStableDebt, \n    uint256 userVariableDebt \n  ) internal view returns (uint256, string memory) { \n    if ( \n      !collateralReserve.configuration.getActive() || !principalReserve.configuration.getActive() \n    ) { \n      return ( \n        uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE), \n        Errors.VL_NO_ACTIVE_RESERVE \n      ); \n    } \n \n    if (userHealthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD) { \n      return ( \n        uint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_ABOVE_THRESHOLD), \n        Errors.LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD \n      ); \n    } \n \n    bool isCollateralEnabled = \n      collateralReserve.configuration.getLiquidationThreshold() > 0 && \n        userConfig.isUsingAsCollateral(collateralReserve.id); \n \n    //if collateral isn't enabled as collateral by user, it cannot be liquidated \n    if (!isCollateralEnabled) { \n      return ( \n        uint256(Errors.CollateralManagerErrors.COLLATERAL_CANNOT_BE_LIQUIDATED), \n        Errors.LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED \n      ); \n    } \n \n    if (userStableDebt == 0 && userVariableDebt == 0) { \n      return ( \n        uint256(Errors.CollateralManagerErrors.CURRRENCY_NOT_BORROWED), \n        Errors.LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER \n      ); \n    } \n \n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS); \n  } \n \n  /** \n   * @dev Validates an aToken transfer \n   * @param from The user from which the aTokens are being transferred \n   * @param reservesData The state of all the reserves \n   * @param userConfig The state of the user for the specific reserve \n   * @param reserves The addresses of all the active reserves \n   * @param oracle The price oracle \n   */ \n  function validateTransfer( \n    address from, \n    mapping(address => DataTypes.ReserveData) storage reservesData, \n    DataTypes.UserConfigurationMap storage userConfig, \n    mapping(uint256 => address) storage reserves, \n    uint256 reservesCount, \n    address oracle \n  ) internal view { \n    (, , , , uint256 healthFactor) = \n      GenericLogic.calculateUserAccountData( \n        from, \n        reservesData, \n        userConfig, \n        reserves, \n        reservesCount, \n        oracle \n      ); \n \n    require( \n      healthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD, \n      Errors.VL_TRANSFER_NOT_ALLOWED \n    ); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {IAToken} from '../../../interfaces/IAToken.sol'; \nimport {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol'; \nimport {IVariableDebtToken} from '../../../interfaces/IVariableDebtToken.sol'; \nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol'; \nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol'; \nimport {MathUtils} from '../math/MathUtils.sol'; \nimport {WadRayMath} from '../math/WadRayMath.sol'; \nimport {PercentageMath} from '../math/PercentageMath.sol'; \nimport {Errors} from '../helpers/Errors.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title ReserveLogic library \n * @author Aave \n * @notice Implements the logic to update the reserves state \n */ \nlibrary ReserveLogic { \n  using SafeMath for uint256; \n  using WadRayMath for uint256; \n  using PercentageMath for uint256; \n  using SafeERC20 for IERC20; \n \n  /** \n   * @dev Emitted when the state of a reserve is updated \n   * @param asset The address of the underlying asset of the reserve \n   * @param liquidityRate The new liquidity rate \n   * @param stableBorrowRate The new stable borrow rate \n   * @param variableBorrowRate The new variable borrow rate \n   * @param liquidityIndex The new liquidity index \n   * @param variableBorrowIndex The new variable borrow index \n   **/ \n  event ReserveDataUpdated( \n    address indexed asset, \n    uint256 liquidityRate, \n    uint256 stableBorrowRate, \n    uint256 variableBorrowRate, \n    uint256 liquidityIndex, \n    uint256 variableBorrowIndex \n  ); \n \n  using ReserveLogic for DataTypes.ReserveData; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n \n  /** \n   * @dev Returns the ongoing normalized income for the reserve \n   * A value of 1e27 means there is no income. As time passes, the income is accrued \n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued \n   * @param reserve The reserve object \n   * @return the normalized income. expressed in ray \n   **/ \n  function getNormalizedIncome(DataTypes.ReserveData storage reserve) \n    internal \n    view \n    returns (uint256) \n  { \n    uint40 timestamp = reserve.lastUpdateTimestamp; \n \n    //solium-disable-next-line \n    if (timestamp == uint40(block.timestamp)) { \n      //if the index was updated in the same block, no need to perform any calculation \n      return reserve.liquidityIndex; \n    } \n \n    uint256 cumulated = \n      MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul( \n        reserve.liquidityIndex \n      ); \n \n    return cumulated; \n  } \n \n  /** \n   * @dev Returns the ongoing normalized variable debt for the reserve \n   * A value of 1e27 means there is no debt. As time passes, the income is accrued \n   * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumula\n   * @param reserve The reserve object \n   * @return The normalized variable debt. expressed in ray \n   **/ \n  function getNormalizedDebt(DataTypes.ReserveData storage reserve) \n    internal \n    view \n    returns (uint256) \n  { \n    uint40 timestamp = reserve.lastUpdateTimestamp; \n \n    //solium-disable-next-line \n    if (timestamp == uint40(block.timestamp)) { \n      //if the index was updated in the same block, no need to perform any calculation \n      return reserve.variableBorrowIndex; \n    } \n \n    uint256 cumulated = \n      MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul( \n        reserve.variableBorrowIndex \n      ); \n \n    return cumulated; \n  } \n \n  /** \n   * @dev Updates the liquidity cumulative index and the variable borrow index. \n   * @param reserve the reserve object \n   **/ \n  function updateState(DataTypes.ReserveData storage reserve) internal { \n    uint256 scaledVariableDebt = \n      IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply(); \n    uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex; \n    uint256 previousLiquidityIndex = reserve.liquidityIndex; \n    uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp; \n \n    (uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) = \n      _updateIndexes( \n        reserve, \n        scaledVariableDebt, \n        previousLiquidityIndex, \n        previousVariableBorrowIndex, \n        lastUpdatedTimestamp \n      ); \n \n    _mintToTreasury( \n      reserve, \n      scaledVariableDebt, \n      previousVariableBorrowIndex, \n      newLiquidityIndex, \n      newVariableBorrowIndex, \n      lastUpdatedTimestamp \n    ); \n  } \n \n  /** \n   * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. U\n   * the flashloan fee to the reserve, and spread it between all the depositors \n   * @param reserve The reserve object \n   * @param totalLiquidity The total liquidity available in the reserve \n   * @param amount The amount to accomulate \n   **/ \n  function cumulateToLiquidityIndex( \n    DataTypes.ReserveData storage reserve, \n    uint256 totalLiquidity, \n    uint256 amount \n  ) internal { \n    uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay()); \n \n    uint256 result = amountToLiquidityRatio.add(WadRayMath.ray()); \n \n    result = result.rayMul(reserve.liquidityIndex); \n    require(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW); \n \n    reserve.liquidityIndex = uint128(result); \n  } \n \n  /** \n   * @dev Initializes a reserve \n   * @param reserve The reserve object \n   * @param aTokenAddress The address of the overlying atoken contract \n   * @param interestRateStrategyAddress The address of the interest rate strategy contract \n   **/ \n  function init( \n    DataTypes.ReserveData storage reserve, \n    address aTokenAddress, \n    address stableDebtTokenAddress, \n    address variableDebtTokenAddress, \n    address interestRateStrategyAddress \n  ) external { \n    require(reserve.aTokenAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED); \n \n    reserve.liquidityIndex = uint128(WadRayMath.ray()); \n    reserve.variableBorrowIndex = uint128(WadRayMath.ray()); \n    reserve.aTokenAddress = aTokenAddress; \n    reserve.stableDebtTokenAddress = stableDebtTokenAddress; \n    reserve.variableDebtTokenAddress = variableDebtTokenAddress; \n    reserve.interestRateStrategyAddress = interestRateStrategyAddress; \n  } \n \n  struct UpdateInterestRatesLocalVars { \n    address stableDebtTokenAddress; \n    uint256 availableLiquidity; \n    uint256 totalStableDebt; \n    uint256 newLiquidityRate; \n    uint256 newStableRate; \n    uint256 newVariableRate; \n    uint256 avgStableRate; \n    uint256 totalVariableDebt; \n  } \n \n  /** \n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the cu\n   * @param reserve The address of the reserve to be updated \n   * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the pr\n   * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow) \n   **/ \n  function updateInterestRates( \n    DataTypes.ReserveData storage reserve, \n    address reserveAddress, \n    address aTokenAddress, \n    uint256 liquidityAdded, \n    uint256 liquidityTaken \n  ) internal { \n    UpdateInterestRatesLocalVars memory vars; \n \n    vars.stableDebtTokenAddress = reserve.stableDebtTokenAddress; \n \n    (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress) \n      .getTotalSupplyAndAvgRate(); \n \n    //calculates the total variable debt locally using the scaled total supply instead \n    //of totalSupply(), as it's noticeably cheaper. Also, the index has been \n    //updated by the previous updateState() call \n    vars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress) \n      .scaledTotalSupply() \n      .rayMul(reserve.variableBorrowIndex); \n \n    ( \n      vars.newLiquidityRate, \n      vars.newStableRate, \n      vars.newVariableRate \n    ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates( \n      reserveAddress, \n      aTokenAddress, \n      liquidityAdded, \n      liquidityTaken, \n      vars.totalStableDebt, \n      vars.totalVariableDebt, \n      vars.avgStableRate, \n      reserve.configuration.getReserveFactor() \n    ); \n    require(vars.newLiquidityRate <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW); \n    require(vars.newStableRate <= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW); \n    require(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW); \n \n    reserve.currentLiquidityRate = uint128(vars.newLiquidityRate); \n    reserve.currentStableBorrowRate = uint128(vars.newStableRate); \n    reserve.currentVariableBorrowRate = uint128(vars.newVariableRate); \n \n    emit ReserveDataUpdated( \n      reserveAddress, \n      vars.newLiquidityRate, \n      vars.newStableRate, \n      vars.newVariableRate, \n      reserve.liquidityIndex, \n      reserve.variableBorrowIndex \n    ); \n  } \n \n  struct MintToTreasuryLocalVars { \n    uint256 currentStableDebt; \n    uint256 principalStableDebt; \n    uint256 previousStableDebt; \n    uint256 currentVariableDebt; \n    uint256 previousVariableDebt; \n    uint256 avgStableRate; \n    uint256 cumulatedStableInterest; \n    uint256 totalDebtAccrued; \n    uint256 amountToMint; \n    uint256 reserveFactor; \n    uint40 stableSupplyUpdatedTimestamp; \n  } \n \n  /** \n   * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFacto\n   * specific asset. \n   * @param reserve The reserve reserve to be updated \n   * @param scaledVariableDebt The current scaled total variable debt \n   * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the \n   * @param newLiquidityIndex The new liquidity index \n   * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the inter\n   **/ \n  function _mintToTreasury( \n    DataTypes.ReserveData storage reserve, \n    uint256 scaledVariableDebt, \n    uint256 previousVariableBorrowIndex, \n    uint256 newLiquidityIndex, \n    uint256 newVariableBorrowIndex, \n    uint40 timestamp \n  ) internal { \n    MintToTreasuryLocalVars memory vars; \n \n    vars.reserveFactor = reserve.configuration.getReserveFactor(); \n \n    if (vars.reserveFactor == 0) { \n      return; \n    } \n \n    //fetching the principal, total stable debt and the avg stable rate \n    ( \n      vars.principalStableDebt, \n      vars.currentStableDebt, \n      vars.avgStableRate, \n      vars.stableSupplyUpdatedTimestamp \n    ) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData(); \n \n    //calculate the last principal variable debt \n    vars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex); \n \n    //calculate the new total supply after accumulation of the index \n    vars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex); \n \n    //calculate the stable debt until the last timestamp update \n    vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest( \n      vars.avgStableRate, \n      vars.stableSupplyUpdatedTimestamp, \n      timestamp \n    ); \n \n    vars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest); \n \n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update \n    vars.totalDebtAccrued = vars \n      .currentVariableDebt \n      .add(vars.currentStableDebt) \n      .sub(vars.previousVariableDebt) \n      .sub(vars.previousStableDebt); \n \n    vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor); \n \n    if (vars.amountToMint != 0) { \n      IAToken(reserve.aTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex); \n    } \n  } \n \n  /** \n   * @dev Updates the reserve indexes and the timestamp of the update \n   * @param reserve The reserve reserve to be updated \n   * @param scaledVariableDebt The scaled variable debt \n   * @param liquidityIndex The last stored liquidity index \n   * @param variableBorrowIndex The last stored variable borrow index \n   **/ \n  function _updateIndexes( \n    DataTypes.ReserveData storage reserve, \n    uint256 scaledVariableDebt, \n    uint256 liquidityIndex, \n    uint256 variableBorrowIndex, \n    uint40 timestamp \n  ) internal returns (uint256, uint256) { \n    uint256 currentLiquidityRate = reserve.currentLiquidityRate; \n \n    uint256 newLiquidityIndex = liquidityIndex; \n    uint256 newVariableBorrowIndex = variableBorrowIndex; \n \n    //only cumulating if there is any income being produced \n    if (currentLiquidityRate > 0) { \n      uint256 cumulatedLiquidityInterest = \n        MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp); \n      newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex); \n      require(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW); \n \n      reserve.liquidityIndex = uint128(newLiquidityIndex); \n \n      //as the liquidity rate might come only from stable rate loans, we need to ensure \n      //that there is actual variable debt before accumulating \n      if (scaledVariableDebt != 0) { \n        uint256 cumulatedVariableBorrowInterest = \n          MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp); \n        newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex); \n        require( \n          newVariableBorrowIndex <= type(uint128).max, \n          Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW \n        ); \n        reserve.variableBorrowIndex = uint128(newVariableBorrowIndex); \n      } \n    } \n \n    //solium-disable-next-line \n    reserve.lastUpdateTimestamp = uint40(block.timestamp); \n    return (newLiquidityIndex, newVariableBorrowIndex); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nlibrary DataTypes { \n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties\n  struct ReserveData { \n    //stores the reserve configuration \n    ReserveConfigurationMap configuration; \n    //the liquidity index. Expressed in ray \n    uint128 liquidityIndex; \n    //variable borrow index. Expressed in ray \n    uint128 variableBorrowIndex; \n    //the current supply rate. Expressed in ray \n    uint128 currentLiquidityRate; \n    //the current variable borrow rate. Expressed in ray \n    uint128 currentVariableBorrowRate; \n    //the current stable borrow rate. Expressed in ray \n    uint128 currentStableBorrowRate; \n    uint40 lastUpdateTimestamp; \n    //tokens addresses \n    address aTokenAddress; \n    address stableDebtTokenAddress; \n    address variableDebtTokenAddress; \n    //address of the interest rate strategy \n    address interestRateStrategyAddress; \n    //the id of the reserve. Represents the position in the list of the active reserves \n    uint8 id; \n  } \n \n  struct ReserveConfigurationMap { \n    //bit 0-15: LTV \n    //bit 16-31: Liq. threshold \n    //bit 32-47: Liq. bonus \n    //bit 48-55: Decimals \n    //bit 56: Reserve is active \n    //bit 57: reserve is frozen \n    //bit 58: borrowing is enabled \n    //bit 59: stable rate borrowing enabled \n    //bit 60-63: reserved \n    //bit 64-79: reserve factor \n    uint256 data; \n  } \n \n  struct UserConfigurationMap { \n    uint256 data; \n  } \n \n  enum InterestRateMode {NONE, STABLE, VARIABLE} \n} \n",
            "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title UserConfiguration library \n * @author Aave \n * @notice Implements the bitmap logic to handle the user configuration \n */ \nlibrary UserConfiguration { \n  uint256 internal constant BORROWING_MASK = \n    0x5555555555555555555555555555555555555555555555555555555555555555; \n \n  /** \n   * @dev Sets if the user is borrowing the reserve identified by reserveIndex \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @param borrowing True if the user is borrowing the reserve, false otherwise \n   **/ \n  function setBorrowing( \n    DataTypes.UserConfigurationMap storage self, \n    uint256 reserveIndex, \n    bool borrowing \n  ) internal { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    self.data = \n      (self.data & ~(1 << (reserveIndex * 2))) | \n      (uint256(borrowing ? 1 : 0) << (reserveIndex * 2)); \n  } \n \n  /** \n   * @dev Sets if the user is using as collateral the reserve identified by reserveIndex \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise \n   **/ \n  function setUsingAsCollateral( \n    DataTypes.UserConfigurationMap storage self, \n    uint256 reserveIndex, \n    bool usingAsCollateral \n  ) internal { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    self.data = \n      (self.data & ~(1 << (reserveIndex * 2 + 1))) | \n      (uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1)); \n  } \n \n  /** \n   * @dev Used to validate if a user has been using the reserve for borrowing or as collateral \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwis\n   **/ \n  function isUsingAsCollateralOrBorrowing( \n    DataTypes.UserConfigurationMap memory self, \n    uint256 reserveIndex \n  ) internal pure returns (bool) { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    return (self.data >> (reserveIndex * 2)) & 3 != 0; \n  } \n \n  /** \n   * @dev Used to validate if a user has been using the reserve for borrowing \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @return True if the user has been using a reserve for borrowing, false otherwise \n   **/ \n  function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex) \n    internal \n    pure \n    returns (bool) \n  { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    return (self.data >> (reserveIndex * 2)) & 1 != 0; \n  } \n \n  /** \n   * @dev Used to validate if a user has been using the reserve as collateral \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @return True if the user has been using a reserve as collateral, false otherwise \n   **/ \n  function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex) \n    internal \n    pure \n    returns (bool) \n  { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    return (self.data >> (reserveIndex * 2 + 1)) & 1 != 0; \n  } \n \n  /** \n   * @dev Used to validate if a user has been borrowing from any reserve \n   * @param self The configuration object \n   * @return True if the user has been borrowing any reserve, false otherwise \n   **/ \n  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) { \n    return self.data & BORROWING_MASK != 0; \n  } \n \n  /** \n   * @dev Used to validate if a user has not been using any reserve \n   * @param self The configuration object \n   * @return True if the user has been borrowing any reserve, false otherwise \n   **/ \n  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) { \n    return self.data == 0; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title ReserveConfiguration library \n * @author Aave \n * @notice Implements the bitmap logic to handle the reserve configuration \n */ \nlibrary ReserveConfiguration { \n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEF\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDF\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBF\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7F\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFF\n \n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed \n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16; \n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32; \n  uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48; \n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56; \n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57; \n  uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58; \n  uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59; \n  uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64; \n \n  uint256 constant MAX_VALID_LTV = 65535; \n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535; \n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535; \n  uint256 constant MAX_VALID_DECIMALS = 255; \n  uint256 constant MAX_VALID_RESERVE_FACTOR = 65535; \n \n  /** \n   * @dev Sets the Loan to Value of the reserve \n   * @param self The reserve configuration \n   * @param ltv the new ltv \n   **/ \n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure { \n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV); \n \n    self.data = (self.data & LTV_MASK) | ltv; \n  } \n \n  /** \n   * @dev Gets the Loan to Value of the reserve \n   * @param self The reserve configuration \n   * @return The loan to value \n   **/ \n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) { \n    return self.data & ~LTV_MASK; \n  } \n \n  /** \n   * @dev Sets the liquidation threshold of the reserve \n   * @param self The reserve configuration \n   * @param threshold The new liquidation threshold \n   **/ \n  function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) \n    internal \n    pure \n  { \n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD); \n \n    self.data = \n      (self.data & LIQUIDATION_THRESHOLD_MASK) | \n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION); \n  } \n \n  /** \n   * @dev Gets the liquidation threshold of the reserve \n   * @param self The reserve configuration \n   * @return The liquidation threshold \n   **/ \n  function getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self) \n    internal \n    view \n    returns (uint256) \n  { \n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION; \n  } \n \n  /** \n   * @dev Sets the liquidation bonus of the reserve \n   * @param self The reserve configuration \n   * @param bonus The new liquidation bonus \n   **/ \n  function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) \n    internal \n    pure \n  { \n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS); \n \n    self.data = \n      (self.data & LIQUIDATION_BONUS_MASK) | \n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION); \n  } \n \n  /** \n   * @dev Gets the liquidation bonus of the reserve \n   * @param self The reserve configuration \n   * @return The liquidation bonus \n   **/ \n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self) \n    internal \n    view \n    returns (uint256) \n  { \n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION; \n  } \n \n  /** \n   * @dev Sets the decimals of the underlying asset of the reserve \n   * @param self The reserve configuration \n   * @param decimals The decimals \n   **/ \n  function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) \n    internal \n    pure \n  { \n    require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS); \n \n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION); \n  } \n \n  /** \n   * @dev Gets the decimals of the underlying asset of the reserve \n   * @param self The reserve configuration \n   * @return The decimals of the asset \n   **/ \n  function getDecimals(DataTypes.ReserveConfigurationMap storage self) \n    internal \n    view \n    returns (uint256) \n  { \n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION; \n  } \n \n  /** \n   * @dev Sets the active state of the reserve \n   * @param self The reserve configuration \n   * @param active The active state \n   **/ \n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure { \n    self.data = \n      (self.data & ACTIVE_MASK) | \n      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION); \n  } \n \n  /** \n   * @dev Gets the active state of the reserve \n   * @param self The reserve configuration \n   * @return The active state \n   **/ \n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) { \n    return (self.data & ~ACTIVE_MASK) != 0; \n  } \n \n  /** \n   * @dev Sets the frozen state of the reserve \n   * @param self The reserve configuration \n   * @param frozen The frozen state \n   **/ \n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure { \n    self.data = \n      (self.data & FROZEN_MASK) | \n      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION); \n  } \n \n  /** \n   * @dev Gets the frozen state of the reserve \n   * @param self The reserve configuration \n   * @return The frozen state \n   **/ \n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) { \n    return (self.data & ~FROZEN_MASK) != 0; \n  } \n \n  /** \n   * @dev Enables or disables borrowing on the reserve \n   * @param self The reserve configuration \n   * @param enabled True if the borrowing needs to be enabled, false otherwise \n   **/ \n  function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) \n    internal \n    pure \n  { \n    self.data = \n      (self.data & BORROWING_MASK) | \n      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION); \n  } \n \n  /** \n   * @dev Gets the borrowing state of the reserve \n   * @param self The reserve configuration \n   * @return The borrowing state \n   **/ \n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) \n    internal \n    view \n    returns (bool) \n  { \n    return (self.data & ~BORROWING_MASK) != 0; \n  } \n \n  /** \n   * @dev Enables or disables stable rate borrowing on the reserve \n   * @param self The reserve configuration \n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise \n   **/ \n  function setStableRateBorrowingEnabled( \n    DataTypes.ReserveConfigurationMap memory self, \n    bool enabled \n  ) internal pure { \n    self.data = \n      (self.data & STABLE_BORROWING_MASK) | \n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION); \n  } \n \n  /** \n   * @dev Gets the stable rate borrowing state of the reserve \n   * @param self The reserve configuration \n   * @return The stable rate borrowing state \n   **/ \n  function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) \n    internal \n    view \n    returns (bool) \n  { \n    return (self.data & ~STABLE_BORROWING_MASK) != 0; \n  } \n \n  /** \n   * @dev Sets the reserve factor of the reserve \n   * @param self The reserve configuration \n   * @param reserveFactor The reserve factor \n   **/ \n  function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) \n    internal \n    pure \n  { \n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR); \n \n    self.data = \n      (self.data & RESERVE_FACTOR_MASK) | \n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION); \n  } \n \n  /** \n   * @dev Gets the reserve factor of the reserve \n   * @param self The reserve configuration \n   * @return The reserve factor \n   **/ \n  function getReserveFactor(DataTypes.ReserveConfigurationMap storage self) \n    internal \n    view \n    returns (uint256) \n  { \n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION; \n  } \n \n  /** \n   * @dev Gets the configuration flags of the reserve \n   * @param self The reserve configuration \n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enab\n   **/ \n  function getFlags(DataTypes.ReserveConfigurationMap storage self) \n    internal \n    view \n    returns ( \n      bool, \n      bool, \n      bool, \n      bool \n    ) \n  { \n    uint256 dataLocal = self.data; \n \n    return ( \n      (dataLocal & ~ACTIVE_MASK) != 0, \n      (dataLocal & ~FROZEN_MASK) != 0, \n      (dataLocal & ~BORROWING_MASK) != 0, \n      (dataLocal & ~STABLE_BORROWING_MASK) != 0 \n    ); \n  } \n \n  /** \n   * @dev Gets the configuration paramters of the reserve \n   * @param self The reserve configuration \n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve \n   **/ \n  function getParams(DataTypes.ReserveConfigurationMap storage self) \n    internal \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256, \n      uint256 \n    ) \n  { \n    uint256 dataLocal = self.data; \n \n    return ( \n      dataLocal & ~LTV_MASK, \n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION, \n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION, \n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION, \n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION \n    ); \n  } \n \n  /** \n   * @dev Gets the configuration paramters of the reserve from a memory object \n   * @param self The reserve configuration \n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve \n   **/ \n  function getParamsMemory(DataTypes.ReserveConfigurationMap memory self) \n    internal \n    pure \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256, \n      uint256 \n    ) \n  { \n    return ( \n      self.data & ~LTV_MASK, \n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION, \n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION, \n      (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION, \n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION \n    ); \n  } \n \n  /** \n   * @dev Gets the configuration flags of the reserve from a memory object \n   * @param self The reserve configuration \n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enab\n   **/ \n  function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self) \n    internal \n    pure \n    returns ( \n      bool, \n      bool, \n      bool, \n      bool \n    ) \n  { \n    return ( \n      (self.data & ~ACTIVE_MASK) != 0, \n      (self.data & ~FROZEN_MASK) != 0, \n      (self.data & ~BORROWING_MASK) != 0, \n      (self.data & ~STABLE_BORROWING_MASK) != 0 \n    ); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol'; \n \n// Prettier ignore to prevent buidler flatter bug \n// prettier-ignore \nimport {InitializableImmutableAdminUpgradeabilityProxy} from '../libraries/aave-upgradeability/Initia\n \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \n \n/** \n * @title LendingPoolAddressesProvider contract \n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementation\n * - Owned by the Aave Governance \n * @author Aave \n **/ \ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider { \n  string private _marketId; \n  mapping(bytes32 => address) private _addresses; \n \n  bytes32 private constant LENDING_POOL = 'LENDING_POOL'; \n  bytes32 private constant LENDING_POOL_CONFIGURATOR = 'LENDING_POOL_CONFIGURATOR'; \n  bytes32 private constant POOL_ADMIN = 'POOL_ADMIN'; \n  bytes32 private constant EMERGENCY_ADMIN = 'EMERGENCY_ADMIN'; \n  bytes32 private constant LENDING_POOL_COLLATERAL_MANAGER = 'COLLATERAL_MANAGER'; \n  bytes32 private constant PRICE_ORACLE = 'PRICE_ORACLE'; \n  bytes32 private constant LENDING_RATE_ORACLE = 'LENDING_RATE_ORACLE'; \n \n  constructor(string memory marketId) public { \n    _setMarketId(marketId); \n  } \n \n  /** \n   * @dev Returns the id of the Aave market to which this contracts points to \n   * @return The market id \n   **/ \n  function getMarketId() external view override returns (string memory) { \n    return _marketId; \n  } \n \n  /** \n   * @dev Allows to set the market which this LendingPoolAddressesProvider represents \n   * @param marketId The market id \n   */ \n  function setMarketId(string memory marketId) external override onlyOwner { \n    _setMarketId(marketId); \n  } \n \n  /** \n   * @dev General function to update the implementation of a proxy registered with \n   * certain `id`. If there is no proxy registered, it will instantiate one and \n   * set as implementation the `implementationAddress` \n   * IMPORTANT Use this function carefully, only for ids that don't have an explicit \n   * setter function, in order to avoid unexpected consequences \n   * @param id The id \n   * @param implementationAddress The address of the new implementation \n   */ \n  function setAddressAsProxy(bytes32 id, address implementationAddress) \n    external \n    override \n    onlyOwner \n  { \n    _updateImpl(id, implementationAddress); \n    emit AddressSet(id, implementationAddress, true); \n  } \n \n  /** \n   * @dev Sets an address for an id replacing the address saved in the addresses map \n   * IMPORTANT Use this function carefully, as it will do a hard replacement \n   * @param id The id \n   * @param newAddress The address to set \n   */ \n  function setAddress(bytes32 id, address newAddress) external override onlyOwner { \n    _addresses[id] = newAddress; \n    emit AddressSet(id, newAddress, false); \n  } \n \n  /** \n   * @dev Returns an address by id \n   * @return The address \n   */ \n  function getAddress(bytes32 id) public view override returns (address) { \n    return _addresses[id]; \n  } \n \n  /** \n   * @dev Returns the address of the LendingPool proxy \n   * @return The LendingPool proxy address \n   **/ \n  function getLendingPool() external view override returns (address) { \n    return getAddress(LENDING_POOL); \n  } \n \n  /** \n   * @dev Updates the implementation of the LendingPool, or creates the proxy \n   * setting the new `pool` implementation on the first time calling it \n   * @param pool The new LendingPool implementation \n   **/ \n  function setLendingPoolImpl(address pool) external override onlyOwner { \n    _updateImpl(LENDING_POOL, pool); \n    emit LendingPoolUpdated(pool); \n  } \n \n  /** \n   * @dev Returns the address of the LendingPoolConfigurator proxy \n   * @return The LendingPoolConfigurator proxy address \n   **/ \n  function getLendingPoolConfigurator() external view override returns (address) { \n    return getAddress(LENDING_POOL_CONFIGURATOR); \n  } \n \n  /** \n   * @dev Updates the implementation of the LendingPoolConfigurator, or creates the proxy \n   * setting the new `configurator` implementation on the first time calling it \n   * @param configurator The new LendingPoolConfigurator implementation \n   **/ \n  function setLendingPoolConfiguratorImpl(address configurator) external override onlyOwner { \n    _updateImpl(LENDING_POOL_CONFIGURATOR, configurator); \n    emit LendingPoolConfiguratorUpdated(configurator); \n  } \n \n  /** \n   * @dev Returns the address of the LendingPoolCollateralManager. Since the manager is used \n   * through delegateCall within the LendingPool contract, the proxy contract pattern does not work p\n   * the addresses are changed directly \n   * @return The address of the LendingPoolCollateralManager \n   **/ \n \n  function getLendingPoolCollateralManager() external view override returns (address) { \n    return getAddress(LENDING_POOL_COLLATERAL_MANAGER); \n  } \n \n  /** \n   * @dev Updates the address of the LendingPoolCollateralManager \n   * @param manager The new LendingPoolCollateralManager address \n   **/ \n  function setLendingPoolCollateralManager(address manager) external override onlyOwner { \n    _addresses[LENDING_POOL_COLLATERAL_MANAGER] = manager; \n    emit LendingPoolCollateralManagerUpdated(manager); \n  } \n \n  /** \n   * @dev The functions below are getters/setters of addresses that are outside the context \n   * of the protocol hence the upgradable proxy pattern is not used \n   **/ \n \n  function getPoolAdmin() external view override returns (address) { \n    return getAddress(POOL_ADMIN); \n  } \n \n  function setPoolAdmin(address admin) external override onlyOwner { \n    _addresses[POOL_ADMIN] = admin; \n    emit ConfigurationAdminUpdated(admin); \n  } \n \n  function getEmergencyAdmin() external view override returns (address) { \n    return getAddress(EMERGENCY_ADMIN); \n  } \n \n  function setEmergencyAdmin(address emergencyAdmin) external override onlyOwner { \n    _addresses[EMERGENCY_ADMIN] = emergencyAdmin; \n    emit EmergencyAdminUpdated(emergencyAdmin); \n  } \n \n  function getPriceOracle() external view override returns (address) { \n    return getAddress(PRICE_ORACLE); \n  } \n \n  function setPriceOracle(address priceOracle) external override onlyOwner { \n    _addresses[PRICE_ORACLE] = priceOracle; \n    emit PriceOracleUpdated(priceOracle); \n  } \n \n  function getLendingRateOracle() external view override returns (address) { \n    return getAddress(LENDING_RATE_ORACLE); \n  } \n \n  function setLendingRateOracle(address lendingRateOracle) external override onlyOwner { \n    _addresses[LENDING_RATE_ORACLE] = lendingRateOracle; \n    emit LendingRateOracleUpdated(lendingRateOracle); \n  } \n \n  /** \n   * @dev Internal function to update the implementation of a specific proxied component of the proto\n   * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress` \n   *   as implementation and calls the initialize() function on the proxy \n   * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\n   *   calls the initialize() function via upgradeToAndCall() in the proxy \n   * @param id The id of the proxy to be updated \n   * @param newAddress The address of the new implementation \n   **/ \n  function _updateImpl(bytes32 id, address newAddress) internal { \n    address payable proxyAddress = payable(_addresses[id]); \n \n    InitializableImmutableAdminUpgradeabilityProxy proxy = \n      InitializableImmutableAdminUpgradeabilityProxy(proxyAddress); \n    bytes memory params = abi.encodeWithSignature('initialize(address)', address(this)); \n \n    if (proxyAddress == address(0)) { \n      proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this)); \n      proxy.initialize(newAddress, params); \n      _addresses[id] = address(proxy); \n      emit ProxyCreated(id, address(proxy)); \n    } else { \n      proxy.upgradeToAndCall(newAddress, params); \n    } \n  } \n \n  function _setMarketId(string memory marketId) internal { \n    _marketId = marketId; \n    emit MarketIdSet(marketId); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport { \n  ILendingPoolAddressesProviderRegistry \n} from '../../interfaces/ILendingPoolAddressesProviderRegistry.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \n \n/** \n * @title LendingPoolAddressesProviderRegistry contract \n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets \n * - Used for indexing purposes of Aave protocol's markets \n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with, \n *   for example with `0` for the Aave main market and `1` for the next created \n * @author Aave \n **/ \ncontract LendingPoolAddressesProviderRegistry is Ownable, ILendingPoolAddressesProviderRegistry { \n  mapping(address => uint256) private _addressesProviders; \n  address[] private _addressesProvidersList; \n \n  /** \n   * @dev Returns the list of registered addresses provider \n   * @return The list of addresses provider, potentially containing address(0) elements \n   **/ \n  function getAddressesProvidersList() external view override returns (address[] memory) { \n    address[] memory addressesProvidersList = _addressesProvidersList; \n \n    uint256 maxLength = addressesProvidersList.length; \n \n    address[] memory activeProviders = new address[](maxLength); \n \n    for (uint256 i = 0; i < maxLength; i++) { \n      if (_addressesProviders[addressesProvidersList[i]] > 0) { \n        activeProviders[i] = addressesProvidersList[i]; \n      } \n    } \n \n    return activeProviders; \n  } \n \n  /** \n   * @dev Registers an addresses provider \n   * @param provider The address of the new LendingPoolAddressesProvider \n   * @param id The id for the new LendingPoolAddressesProvider, referring to the market it belongs to\n   **/ \n  function registerAddressesProvider(address provider, uint256 id) external override onlyOwner { \n    require(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID); \n \n    _addressesProviders[provider] = id; \n    _addToAddressesProvidersList(provider); \n    emit AddressesProviderRegistered(provider); \n  } \n \n  /** \n   * @dev Removes a LendingPoolAddressesProvider from the list of registered addresses provider \n   * @param provider The LendingPoolAddressesProvider address \n   **/ \n  function unregisterAddressesProvider(address provider) external override onlyOwner { \n    require(_addressesProviders[provider] > 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED); \n    _addressesProviders[provider] = 0; \n    emit AddressesProviderUnregistered(provider); \n  } \n \n  /** \n   * @dev Returns the id on a registered LendingPoolAddressesProvider \n   * @return The id or 0 if the LendingPoolAddressesProvider is not registered \n   */ \n  function getAddressesProviderIdByAddress(address addressesProvider) \n    external \n    view \n    override \n    returns (uint256) \n  { \n    return _addressesProviders[addressesProvider]; \n  } \n \n  function _addToAddressesProvidersList(address provider) internal { \n    uint256 providersCount = _addressesProvidersList.length; \n \n    for (uint256 i = 0; i < providersCount; i++) { \n      if (_addressesProvidersList[i] == provider) { \n        return; \n      } \n    } \n \n    _addressesProvidersList.push(provider); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport './UpgradeabilityProxy.sol'; \n \n/** \n * @title BaseAdminUpgradeabilityProxy \n * @dev This contract combines an upgradeability proxy with an authorization \n * mechanism for administrative tasks. \n * All external functions in this contract must be guarded by the \n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity \n * feature proposal that would enable this to be done automatically. \n */ \ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy { \n  /** \n   * @dev Emitted when the administration has been transferred. \n   * @param previousAdmin Address of the previous admin. \n   * @param newAdmin Address of the new admin. \n   */ \n  event AdminChanged(address previousAdmin, address newAdmin); \n \n  /** \n   * @dev Storage slot with the admin of the contract. \n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n   * validated in the constructor. \n   */ \n  bytes32 internal constant ADMIN_SLOT = \n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103; \n \n  /** \n   * @dev Modifier to check whether the `msg.sender` is the admin. \n   * If it is, it will run the function. Otherwise, it will delegate the call \n   * to the implementation. \n   */ \n  modifier ifAdmin() { \n    if (msg.sender == _admin()) { \n      _; \n    } else { \n      _fallback(); \n    } \n  } \n \n  /** \n   * @return The address of the proxy admin. \n   */ \n  function admin() external ifAdmin returns (address) { \n    return _admin(); \n  } \n \n  /** \n   * @return The address of the implementation. \n   */ \n  function implementation() external ifAdmin returns (address) { \n    return _implementation(); \n  } \n \n  /** \n   * @dev Changes the admin of the proxy. \n   * Only the current admin can call this function. \n   * @param newAdmin Address to transfer proxy administration to. \n   */ \n  function changeAdmin(address newAdmin) external ifAdmin { \n    require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address'); \n    emit AdminChanged(_admin(), newAdmin); \n    _setAdmin(newAdmin); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy. \n   * Only the admin can call this function. \n   * @param newImplementation Address of the new implementation. \n   */ \n  function upgradeTo(address newImplementation) external ifAdmin { \n    _upgradeTo(newImplementation); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy and call a function \n   * on the new implementation. \n   * This is useful to initialize the proxied contract. \n   * @param newImplementation Address of the new implementation. \n   * @param data Data to send as msg.data in the low level call. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   */ \n  function upgradeToAndCall(address newImplementation, bytes calldata data) \n    external \n    payable \n    ifAdmin \n  { \n    _upgradeTo(newImplementation); \n    (bool success, ) = newImplementation.delegatecall(data); \n    require(success); \n  } \n \n  /** \n   * @return adm The admin slot. \n   */ \n  function _admin() internal view returns (address adm) { \n    bytes32 slot = ADMIN_SLOT; \n    //solium-disable-next-line \n    assembly { \n      adm := sload(slot) \n    } \n  } \n \n  /** \n   * @dev Sets the address of the proxy admin. \n   * @param newAdmin Address of the new proxy admin. \n   */ \n  function _setAdmin(address newAdmin) internal { \n    bytes32 slot = ADMIN_SLOT; \n    //solium-disable-next-line \n    assembly { \n      sstore(slot, newAdmin) \n    } \n  } \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal virtual override { \n    require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin'); \n    super._willFallback(); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport './BaseAdminUpgradeabilityProxy.sol'; \nimport './InitializableUpgradeabilityProxy.sol'; \n \n/** \n * @title InitializableAdminUpgradeabilityProxy \n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \n * initializing the implementation, admin, and init data. \n */ \ncontract InitializableAdminUpgradeabilityProxy is \n  BaseAdminUpgradeabilityProxy, \n  InitializableUpgradeabilityProxy \n{ \n  /** \n   * Contract initializer. \n   * @param logic address of the initial implementation. \n   * @param admin Address of the proxy administrator. \n   * @param data Data to send as msg.data to the implementation to initialize the proxied contract. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   * This parameter is optional, if no data is given the initialization call to proxied contract will \n   */ \n  function initialize( \n    address logic, \n    address admin, \n    bytes memory data \n  ) public payable { \n    require(_implementation() == address(0)); \n    InitializableUpgradeabilityProxy.initialize(logic, data); \n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)); \n    _setAdmin(admin); \n  } \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) { \n    BaseAdminUpgradeabilityProxy._willFallback(); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport './Proxy.sol'; \nimport '../contracts/Address.sol'; \n \n/** \n * @title BaseUpgradeabilityProxy \n * @dev This contract implements a proxy that allows to change the \n * implementation address to which it will delegate. \n * Such a change is called an implementation upgrade. \n */ \ncontract BaseUpgradeabilityProxy is Proxy { \n  /** \n   * @dev Emitted when the implementation is upgraded. \n   * @param implementation Address of the new implementation. \n   */ \n  event Upgraded(address indexed implementation); \n \n  /** \n   * @dev Storage slot with the address of the current implementation. \n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is \n   * validated in the constructor. \n   */ \n  bytes32 internal constant IMPLEMENTATION_SLOT = \n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; \n \n  /** \n   * @dev Returns the current implementation. \n   * @return impl Address of the current implementation \n   */ \n  function _implementation() internal view override returns (address impl) { \n    bytes32 slot = IMPLEMENTATION_SLOT; \n    //solium-disable-next-line \n    assembly { \n      impl := sload(slot) \n    } \n  } \n \n  /** \n   * @dev Upgrades the proxy to a new implementation. \n   * @param newImplementation Address of the new implementation. \n   */ \n  function _upgradeTo(address newImplementation) internal { \n    _setImplementation(newImplementation); \n    emit Upgraded(newImplementation); \n  } \n \n  /** \n   * @dev Sets the implementation address of the proxy. \n   * @param newImplementation Address of the new implementation. \n   */ \n  function _setImplementation(address newImplementation) internal { \n    require( \n      Address.isContract(newImplementation), \n      'Cannot set a proxy implementation to a non-contract address' \n    ); \n \n    bytes32 slot = IMPLEMENTATION_SLOT; \n \n    //solium-disable-next-line \n    assembly { \n      sstore(slot, newImplementation) \n    } \n  } \n} \n",
            "pragma solidity ^0.6.0; \n \n/** \n * @title Proxy \n * @dev Implements delegation of calls to other contracts, with proper \n * forwarding of return values and bubbling of failures. \n * It defines a fallback function that delegates all calls to the address \n * returned by the abstract _implementation() internal function. \n */ \nabstract contract Proxy { \n  /** \n   * @dev Fallback function. \n   * Implemented entirely in `_fallback`. \n   */ \n  fallback() external payable { \n    _fallback(); \n  } \n \n  /** \n   * @return The Address of the implementation. \n   */ \n  function _implementation() internal view virtual returns (address); \n \n  /** \n   * @dev Delegates execution to an implementation contract. \n   * This is a low level function that doesn't return to its internal call site. \n   * It will return to the external caller whatever the implementation returns. \n   * @param implementation Address to delegate. \n   */ \n  function _delegate(address implementation) internal { \n    //solium-disable-next-line \n    assembly { \n      // Copy msg.data. We take full control of memory in this inline assembly \n      // block because it will not return to Solidity code. We overwrite the \n      // Solidity scratch pad at memory position 0. \n      calldatacopy(0, 0, calldatasize()) \n \n      // Call the implementation. \n      // out and outsize are 0 because we don't know the size yet. \n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n      // Copy the returned data. \n      returndatacopy(0, 0, returndatasize()) \n \n      switch result \n        // delegatecall returns 0 on error. \n        case 0 { \n          revert(0, returndatasize()) \n        } \n        default { \n          return(0, returndatasize()) \n        } \n    } \n  } \n \n  /** \n   * @dev Function that is run as the first thing in the fallback function. \n   * Can be redefined in derived contracts to add functionality. \n   * Redefinitions must call super._willFallback(). \n   */ \n  function _willFallback() internal virtual {} \n \n  /** \n   * @dev fallback implementation. \n   * Extracted to enable manual triggering. \n   */ \n  function _fallback() internal { \n    _willFallback(); \n    _delegate(_implementation()); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport './BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title InitializableUpgradeabilityProxy \n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing \n * implementation and init data. \n */ \ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy { \n  /** \n   * @dev Contract initializer. \n   * @param _logic Address of the initial implementation. \n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   * This parameter is optional, if no data is given the initialization call to proxied contract will \n   */ \n  function initialize(address _logic, bytes memory _data) public payable { \n    require(_implementation() == address(0)); \n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)); \n    _setImplementation(_logic); \n    if (_data.length > 0) { \n      (bool success, ) = _logic.delegatecall(_data); \n      require(success); \n    } \n  } \n} \n",
            "pragma solidity >=0.4.24 <0.7.0; \n \n/** \n * @title Initializable \n * \n * @dev Helper contract to support initializer functions. To use it, replace \n * the constructor with a function that has the `initializer` modifier. \n * WARNING: Unlike constructors, initializer functions must be manually \n * invoked. This applies both to deploying an Initializable contract, as well \n * as extending an Initializable contract via inheritance. \n * WARNING: When used with inheritance, manual care must be taken to not invoke \n * a parent initializer twice, or ensure that all initializers are idempotent, \n * because this is not dealt with automatically as with constructors. \n */ \ncontract Initializable { \n  /** \n   * @dev Indicates that the contract has been initialized. \n   */ \n  bool private initialized; \n \n  /** \n   * @dev Indicates that the contract is in the process of being initialized. \n   */ \n  bool private initializing; \n \n  /** \n   * @dev Modifier to use in the initializer function of a contract. \n   */ \n  modifier initializer() { \n    require( \n      initializing || isConstructor() || !initialized, \n      'Contract instance has already been initialized' \n    ); \n \n    bool isTopLevelCall = !initializing; \n    if (isTopLevelCall) { \n      initializing = true; \n      initialized = true; \n    } \n \n    _; \n \n    if (isTopLevelCall) { \n      initializing = false; \n    } \n  } \n \n  /// @dev Returns true if and only if the function is running in the constructor \n  function isConstructor() private view returns (bool) { \n    // extcodesize checks the size of the code stored in an address, and \n    // address returns the current address. Since the code is still not \n    // deployed when running a constructor, any checks on its code size will \n    // yield zero, making it an effective way to detect if a contract is \n    // under construction or not. \n    uint256 cs; \n    //solium-disable-next-line \n    assembly { \n      cs := extcodesize(address()) \n    } \n    return cs == 0; \n  } \n \n  // Reserved storage space to allow for layout changes in the future. \n  uint256[50] private ______gap; \n} \n",
            "pragma solidity 0.6.12; \n \nimport './BaseAdminUpgradeabilityProxy.sol'; \n \n/** \n * @title AdminUpgradeabilityProxy \n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n * initializing the implementation, admin, and init data. \n */ \ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy { \n  /** \n   * Contract constructor. \n   * @param _logic address of the initial implementation. \n   * @param _admin Address of the proxy administrator. \n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   * This parameter is optional, if no data is given the initialization call to proxied contract will \n   */ \n  constructor( \n    address _logic, \n    address _admin, \n    bytes memory _data \n  ) public payable UpgradeabilityProxy(_logic, _data) { \n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)); \n    _setAdmin(_admin); \n  } \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) { \n    BaseAdminUpgradeabilityProxy._willFallback(); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport './BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title UpgradeabilityProxy \n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing \n * implementation and init data. \n */ \ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy { \n  /** \n   * @dev Contract constructor. \n   * @param _logic Address of the initial implementation. \n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   * This parameter is optional, if no data is given the initialization call to proxied contract will \n   */ \n  constructor(address _logic, bytes memory _data) public payable { \n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)); \n    _setImplementation(_logic); \n    if (_data.length > 0) { \n      (bool success, ) = _logic.delegatecall(_data); \n      require(success); \n    } \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IERC20} from './IERC20.sol'; \n \ninterface IERC20Detailed is IERC20 { \n  function name() external view returns (string memory); \n \n  function symbol() external view returns (string memory); \n \n  function decimals() external view returns (uint8); \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n  /** \n   * @dev Returns the amount of tokens in existence. \n   */ \n  function totalSupply() external view returns (uint256); \n \n  /** \n   * @dev Returns the amount of tokens owned by `account`. \n   */ \n  function balanceOf(address account) external view returns (uint256); \n \n  /** \n   * @dev Moves `amount` tokens from the caller's account to `recipient`. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * Emits a {Transfer} event. \n   */ \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Returns the remaining number of tokens that `spender` will be \n   * allowed to spend on behalf of `owner` through {transferFrom}. This is \n   * zero by default. \n   * \n   * This value changes when {approve} or {transferFrom} are called. \n   */ \n  function allowance(address owner, address spender) external view returns (uint256); \n \n  /** \n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * IMPORTANT: Beware that changing an allowance with this method brings the risk \n   * that someone may use both the old and the new allowance by unfortunate \n   * transaction ordering. One possible solution to mitigate this race \n   * condition is to first reduce the spender's allowance to 0 and set the \n   * desired value afterwards: \n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n   * \n   * Emits an {Approval} event. \n   */ \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Moves `amount` tokens from `sender` to `recipient` using the \n   * allowance mechanism. `amount` is then deducted from the caller's \n   * allowance. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * Emits a {Transfer} event. \n   */ \n  function transferFrom( \n    address sender, \n    address recipient, \n    uint256 amount \n  ) external returns (bool); \n \n  /** \n   * @dev Emitted when `value` tokens are moved from one account (`from`) to \n   * another (`to`). \n   * \n   * Note that `value` may be zero. \n   */ \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  /** \n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n   * a call to {approve}. `value` is the new allowance. \n   */ \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n",
            "pragma solidity ^0.6.0; \n \nimport './Context.sol'; \nimport './IERC20.sol'; \nimport './SafeMath.sol'; \nimport './Address.sol'; \n \n/** \n * @dev Implementation of the {IERC20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of ERC20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IERC20-approve}. \n */ \ncontract ERC20 is Context, IERC20 { \n  using SafeMath for uint256; \n  using Address for address; \n \n  mapping(address => uint256) private _balances; \n \n  mapping(address => mapping(address => uint256)) private _allowances; \n \n  uint256 private _totalSupply; \n \n  string private _name; \n  string private _symbol; \n  uint8 private _decimals; \n \n  /** \n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n   * a default value of 18. \n   * \n   * To select a different value for {decimals}, use {_setupDecimals}. \n   * \n   * All three of these values are immutable: they can only be set once during \n   * construction. \n   */ \n  constructor(string memory name, string memory symbol) public { \n    _name = name; \n    _symbol = symbol; \n    _decimals = 18; \n  } \n \n  /** \n   * @dev Returns the name of the token. \n   */ \n  function name() public view returns (string memory) { \n    return _name; \n  } \n \n  /** \n   * @dev Returns the symbol of the token, usually a shorter version of the \n   * name. \n   */ \n  function symbol() public view returns (string memory) { \n    return _symbol; \n  } \n \n  /** \n   * @dev Returns the number of decimals used to get its user representation. \n   * For example, if `decimals` equals `2`, a balance of `505` tokens should \n   * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n   * \n   * Tokens usually opt for a value of 18, imitating the relationship between \n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is \n   * called. \n   * \n   * NOTE: This information is only used for _display_ purposes: it in \n   * no way affects any of the arithmetic of the contract, including \n   * {IERC20-balanceOf} and {IERC20-transfer}. \n   */ \n  function decimals() public view returns (uint8) { \n    return _decimals; \n  } \n \n  /** \n   * @dev See {IERC20-totalSupply}. \n   */ \n  function totalSupply() public view override returns (uint256) { \n    return _totalSupply; \n  } \n \n  /** \n   * @dev See {IERC20-balanceOf}. \n   */ \n  function balanceOf(address account) public view override returns (uint256) { \n    return _balances[account]; \n  } \n \n  /** \n   * @dev See {IERC20-transfer}. \n   * \n   * Requirements: \n   * \n   * - `recipient` cannot be the zero address. \n   * - the caller must have a balance of at least `amount`. \n   */ \n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n    _transfer(_msgSender(), recipient, amount); \n    return true; \n  } \n \n  /** \n   * @dev See {IERC20-allowance}. \n   */ \n  function allowance(address owner, address spender) \n    public \n    view \n    virtual \n    override \n    returns (uint256) \n  { \n    return _allowances[owner][spender]; \n  } \n \n  /** \n   * @dev See {IERC20-approve}. \n   * \n   * Requirements: \n   * \n   * - `spender` cannot be the zero address. \n   */ \n  function approve(address spender, uint256 amount) public virtual override returns (bool) { \n    _approve(_msgSender(), spender, amount); \n    return true; \n  } \n \n  /** \n   * @dev See {IERC20-transferFrom}. \n   * \n   * Emits an {Approval} event indicating the updated allowance. This is not \n   * required by the EIP. See the note at the beginning of {ERC20}; \n   * \n   * Requirements: \n   * - `sender` and `recipient` cannot be the zero address. \n   * - `sender` must have a balance of at least `amount`. \n   * - the caller must have allowance for ``sender``'s tokens of at least \n   * `amount`. \n   */ \n  function transferFrom( \n    address sender, \n    address recipient, \n    uint256 amount \n  ) public virtual override returns (bool) { \n    _transfer(sender, recipient, amount); \n    _approve( \n      sender, \n      _msgSender(), \n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance') \n    ); \n    return true; \n  } \n \n  /** \n   * @dev Atomically increases the allowance granted to `spender` by the caller. \n   * \n   * This is an alternative to {approve} that can be used as a mitigation for \n   * problems described in {IERC20-approve}. \n   * \n   * Emits an {Approval} event indicating the updated allowance. \n   * \n   * Requirements: \n   * \n   * - `spender` cannot be the zero address. \n   */ \n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n    return true; \n  } \n \n  /** \n   * @dev Atomically decreases the allowance granted to `spender` by the caller. \n   * \n   * This is an alternative to {approve} that can be used as a mitigation for \n   * problems described in {IERC20-approve}. \n   * \n   * Emits an {Approval} event indicating the updated allowance. \n   * \n   * Requirements: \n   * \n   * - `spender` cannot be the zero address. \n   * - `spender` must have allowance for the caller of at least \n   * `subtractedValue`. \n   */ \n  function decreaseAllowance(address spender, uint256 subtractedValue) \n    public \n    virtual \n    returns (bool) \n  { \n    _approve( \n      _msgSender(), \n      spender, \n      _allowances[_msgSender()][spender].sub( \n        subtractedValue, \n        'ERC20: decreased allowance below zero' \n      ) \n    ); \n    return true; \n  } \n \n  /** \n   * @dev Moves tokens `amount` from `sender` to `recipient`. \n   * \n   * This is internal function is equivalent to {transfer}, and can be used to \n   * e.g. implement automatic token fees, slashing mechanisms, etc. \n   * \n   * Emits a {Transfer} event. \n   * \n   * Requirements: \n   * \n   * - `sender` cannot be the zero address. \n   * - `recipient` cannot be the zero address. \n   * - `sender` must have a balance of at least `amount`. \n   */ \n  function _transfer( \n    address sender, \n    address recipient, \n    uint256 amount \n  ) internal virtual { \n    require(sender != address(0), 'ERC20: transfer from the zero address'); \n    require(recipient != address(0), 'ERC20: transfer to the zero address'); \n \n    _beforeTokenTransfer(sender, recipient, amount); \n \n    _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance'); \n    _balances[recipient] = _balances[recipient].add(amount); \n    emit Transfer(sender, recipient, amount); \n  } \n \n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n   * the total supply. \n   * \n   * Emits a {Transfer} event with `from` set to the zero address. \n   * \n   * Requirements \n   * \n   * - `to` cannot be the zero address. \n   */ \n  function _mint(address account, uint256 amount) internal virtual { \n    require(account != address(0), 'ERC20: mint to the zero address'); \n \n    _beforeTokenTransfer(address(0), account, amount); \n \n    _totalSupply = _totalSupply.add(amount); \n    _balances[account] = _balances[account].add(amount); \n    emit Transfer(address(0), account, amount); \n  } \n \n  /** \n   * @dev Destroys `amount` tokens from `account`, reducing the \n   * total supply. \n   * \n   * Emits a {Transfer} event with `to` set to the zero address. \n   * \n   * Requirements \n   * \n   * - `account` cannot be the zero address. \n   * - `account` must have at least `amount` tokens. \n   */ \n  function _burn(address account, uint256 amount) internal virtual { \n    require(account != address(0), 'ERC20: burn from the zero address'); \n \n    _beforeTokenTransfer(account, address(0), amount); \n \n    _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance'); \n    _totalSupply = _totalSupply.sub(amount); \n    emit Transfer(account, address(0), amount); \n  } \n \n  /** \n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens. \n   * \n   * This is internal function is equivalent to `approve`, and can be used to \n   * e.g. set automatic allowances for certain subsystems, etc. \n   * \n   * Emits an {Approval} event. \n   * \n   * Requirements: \n   * \n   * - `owner` cannot be the zero address. \n   * - `spender` cannot be the zero address. \n   */ \n  function _approve( \n    address owner, \n    address spender, \n    uint256 amount \n  ) internal virtual { \n    require(owner != address(0), 'ERC20: approve from the zero address'); \n    require(spender != address(0), 'ERC20: approve to the zero address'); \n \n    _allowances[owner][spender] = amount; \n    emit Approval(owner, spender, amount); \n  } \n \n  /** \n   * @dev Sets {decimals} to a value other than the default one of 18. \n   * \n   * WARNING: This function should only be called from the constructor. Most \n   * applications that interact with token contracts will not expect \n   * {decimals} to ever change, and may work incorrectly if it does. \n   */ \n  function _setupDecimals(uint8 decimals_) internal { \n    _decimals = decimals_; \n  } \n \n  /** \n   * @dev Hook that is called before any transfer of tokens. This includes \n   * minting and burning. \n   * \n   * Calling conditions: \n   * \n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n   * will be to transferred to `to`. \n   * - when `from` is zero, `amount` tokens will be minted for `to`. \n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n   * - `from` and `to` are never both zero. \n   * \n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]. \n   */ \n  function _beforeTokenTransfer( \n    address from, \n    address to, \n    uint256 amount \n  ) internal virtual {} \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n  /** \n   * @dev Returns true if `account` is a contract. \n   * \n   * [IMPORTANT] \n   * ==== \n   * It is unsafe to assume that an address for which this function returns \n   * false is an externally-owned account (EOA) and not a contract. \n   * \n   * Among others, `isContract` will return false for the following \n   * types of addresses: \n   * \n   *  - an externally-owned account \n   *  - a contract in construction \n   *  - an address where a contract will be created \n   *  - an address where a contract lived, but was destroyed \n   * ==== \n   */ \n  function isContract(address account) internal view returns (bool) { \n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts \n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned \n    // for accounts without code, i.e. `keccak256('')` \n    bytes32 codehash; \n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; \n    // solhint-disable-next-line no-inline-assembly \n    assembly { \n      codehash := extcodehash(account) \n    } \n    return (codehash != accountHash && codehash != 0x0); \n  } \n \n  /** \n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n   * `recipient`, forwarding all available gas and reverting on errors. \n   * \n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n   * of certain opcodes, possibly making contracts go over the 2300 gas limit \n   * imposed by `transfer`, making them unable to receive funds via \n   * `transfer`. {sendValue} removes this limitation. \n   * \n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n   * \n   * IMPORTANT: because control is transferred to `recipient`, care must be \n   * taken to not create reentrancy vulnerabilities. Consider using \n   * {ReentrancyGuard} or the \n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-i\n   */ \n  function sendValue(address payable recipient, uint256 amount) internal { \n    require(address(this).balance >= amount, 'Address: insufficient balance'); \n \n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n    (bool success, ) = recipient.call{value: amount}(''); \n    require(success, 'Address: unable to send value, recipient may have reverted'); \n  } \n} \n \n",
            "pragma solidity ^0.6.0; \n \nimport './Context.sol'; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \ncontract Ownable is Context { \n  address private _owner; \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  /** \n   * @dev Initializes the contract setting the deployer as the initial owner. \n   */ \n  constructor() internal { \n    address msgSender = _msgSender(); \n    _owner = msgSender; \n    emit OwnershipTransferred(address(0), msgSender); \n  } \n \n  /** \n   * @dev Returns the address of the current owner. \n   */ \n  function owner() public view returns (address) { \n    return _owner; \n  } \n \n  /** \n   * @dev Throws if called by any account other than the owner. \n   */ \n  modifier onlyOwner() { \n    require(_owner == _msgSender(), 'Ownable: caller is not the owner'); \n    _; \n  } \n \n  /** \n   * @dev Leaves the contract without owner. It will not be possible to call \n   * `onlyOwner` functions anymore. Can only be called by the current owner. \n   * \n   * NOTE: Renouncing ownership will leave the contract without an owner, \n   * thereby removing any functionality that is only available to the owner. \n   */ \n  function renounceOwnership() public virtual onlyOwner { \n    emit OwnershipTransferred(_owner, address(0)); \n    _owner = address(0); \n  } \n \n  /** \n   * @dev Transfers ownership of the contract to a new account (`newOwner`). \n   * Can only be called by the current owner. \n   */ \n  function transferOwnership(address newOwner) public virtual onlyOwner { \n    require(newOwner != address(0), 'Ownable: new owner is the zero address'); \n    emit OwnershipTransferred(_owner, newOwner); \n    _owner = newOwner; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n  /** \n   * @dev Returns the addition of two unsigned integers, reverting on \n   * overflow. \n   * \n   * Counterpart to Solidity's `+` operator. \n   * \n   * Requirements: \n   * - Addition cannot overflow. \n   */ \n  function add(uint256 a, uint256 b) internal pure returns (uint256) { \n    uint256 c = a + b; \n    require(c >= a, 'SafeMath: addition overflow'); \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the subtraction of two unsigned integers, reverting on \n   * overflow (when the result is negative). \n   * \n   * Counterpart to Solidity's `-` operator. \n   * \n   * Requirements: \n   * - Subtraction cannot overflow. \n   */ \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n    return sub(a, b, 'SafeMath: subtraction overflow'); \n  } \n \n  /** \n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n   * overflow (when the result is negative). \n   * \n   * Counterpart to Solidity's `-` operator. \n   * \n   * Requirements: \n   * - Subtraction cannot overflow. \n   */ \n  function sub( \n    uint256 a, \n    uint256 b, \n    string memory errorMessage \n  ) internal pure returns (uint256) { \n    require(b <= a, errorMessage); \n    uint256 c = a - b; \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the multiplication of two unsigned integers, reverting on \n   * overflow. \n   * \n   * Counterpart to Solidity's `*` operator. \n   * \n   * Requirements: \n   * - Multiplication cannot overflow. \n   */ \n  function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n    // benefit is lost if 'b' is also tested. \n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n    if (a == 0) { \n      return 0; \n    } \n \n    uint256 c = a * b; \n    require(c / a == b, 'SafeMath: multiplication overflow'); \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the integer division of two unsigned integers. Reverts on \n   * division by zero. The result is rounded towards zero. \n   * \n   * Counterpart to Solidity's `/` operator. Note: this function uses a \n   * `revert` opcode (which leaves remaining gas untouched) while Solidity \n   * uses an invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function div(uint256 a, uint256 b) internal pure returns (uint256) { \n    return div(a, b, 'SafeMath: division by zero'); \n  } \n \n  /** \n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on \n   * division by zero. The result is rounded towards zero. \n   * \n   * Counterpart to Solidity's `/` operator. Note: this function uses a \n   * `revert` opcode (which leaves remaining gas untouched) while Solidity \n   * uses an invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function div( \n    uint256 a, \n    uint256 b, \n    string memory errorMessage \n  ) internal pure returns (uint256) { \n    // Solidity only automatically asserts when dividing by 0 \n    require(b > 0, errorMessage); \n    uint256 c = a / b; \n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n   * Reverts when dividing by zero. \n   * \n   * Counterpart to Solidity's `%` operator. This function uses a `revert` \n   * opcode (which leaves remaining gas untouched) while Solidity uses an \n   * invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n    return mod(a, b, 'SafeMath: modulo by zero'); \n  } \n \n  /** \n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n   * Reverts with custom message when dividing by zero. \n   * \n   * Counterpart to Solidity's `%` operator. This function uses a `revert` \n   * opcode (which leaves remaining gas untouched) while Solidity uses an \n   * invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function mod( \n    uint256 a, \n    uint256 b, \n    string memory errorMessage \n  ) internal pure returns (uint256) { \n    require(b != 0, errorMessage); \n    return a % b; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n  function _msgSender() internal view virtual returns (address payable) { \n    return msg.sender; \n  } \n \n  function _msgData() internal view virtual returns (bytes memory) { \n    this; // silence state mutability warning without generating bytecode - see https://github.com/et\n    return msg.data; \n  } \n} \n \n",
            "pragma solidity 0.6.12; \n \nimport {IERC20} from './IERC20.sol'; \nimport {SafeMath} from './SafeMath.sol'; \nimport {Address} from './Address.sol'; \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n  using SafeMath for uint256; \n  using Address for address; \n \n  function safeTransfer( \n    IERC20 token, \n    address to, \n    uint256 value \n  ) internal { \n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n  } \n \n  function safeTransferFrom( \n    IERC20 token, \n    address from, \n    address to, \n    uint256 value \n  ) internal { \n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value)); \n  } \n \n  function safeApprove( \n    IERC20 token, \n    address spender, \n    uint256 value \n  ) internal { \n    require( \n      (value == 0) || (token.allowance(address(this), spender) == 0), \n      'SafeERC20: approve from non-zero to non-zero allowance' \n    ); \n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n  } \n \n  function callOptionalReturn(IERC20 token, bytes memory data) private { \n    require(address(token).isContract(), 'SafeERC20: call to non-contract'); \n \n    // solhint-disable-next-line avoid-low-level-calls \n    (bool success, bytes memory returndata) = address(token).call(data); \n    require(success, 'SafeERC20: low-level call failed'); \n \n    if (returndata.length > 0) { \n      // Return data is optional \n      // solhint-disable-next-line max-line-length \n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed'); \n    } \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \n \n/** \n * @title IFlashLoanReceiver interface \n * @notice Interface for the Aave fee IFlashLoanReceiver. \n * @author Aave \n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract \n **/ \ninterface IFlashLoanReceiver { \n  function executeOperation( \n    address[] calldata assets, \n    uint256[] calldata amounts, \n    uint256[] calldata premiums, \n    address initiator, \n    bytes calldata params \n  ) external returns (bool); \n \n  function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider); \n \n  function LENDING_POOL() external view returns (ILendingPool); \n} \n",
            "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {IFlashLoanReceiver} from '../interfaces/IFlashLoanReceiver.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \n \nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver { \n  using SafeERC20 for IERC20; \n  using SafeMath for uint256; \n \n  ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER; \n  ILendingPool public immutable override LENDING_POOL; \n \n  constructor(ILendingPoolAddressesProvider provider) public { \n    ADDRESSES_PROVIDER = provider; \n    LENDING_POOL = ILendingPool(provider.getLendingPool()); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \ncontract IERC20DetailedBytes { \n  bytes32 public name; \n  bytes32 public symbol; \n  uint256 public decimals; \n} \n",
            "pragma solidity >=0.6.2; \n \nimport './IUniswapV2Router01.sol'; \n \ninterface IUniswapV2Router02 is IUniswapV2Router01 { \n  function removeLiquidityETHSupportingFeeOnTransferTokens( \n    address token, \n    uint256 liquidity, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline \n  ) external returns (uint256 amountETH); \n \n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n    address token, \n    uint256 liquidity, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline, \n    bool approveMax, \n    uint8 v, \n    bytes32 r, \n    bytes32 s \n  ) external returns (uint256 amountETH); \n \n  function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external; \n \n  function swapExactETHForTokensSupportingFeeOnTransferTokens( \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external payable; \n \n  function swapExactTokensForETHSupportingFeeOnTransferTokens( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external; \n} \n",
            "pragma solidity >=0.6.2; \n \ninterface IUniswapV2Router01 { \n  function factory() external pure returns (address); \n \n  function WETH() external pure returns (address); \n \n  function addLiquidity( \n    address tokenA, \n    address tokenB, \n    uint256 amountADesired, \n    uint256 amountBDesired, \n    uint256 amountAMin, \n    uint256 amountBMin, \n    address to, \n    uint256 deadline \n  ) \n    external \n    returns ( \n      uint256 amountA, \n      uint256 amountB, \n      uint256 liquidity \n    ); \n \n  function addLiquidityETH( \n    address token, \n    uint256 amountTokenDesired, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline \n  ) \n    external \n    payable \n    returns ( \n      uint256 amountToken, \n      uint256 amountETH, \n      uint256 liquidity \n    ); \n \n  function removeLiquidity( \n    address tokenA, \n    address tokenB, \n    uint256 liquidity, \n    uint256 amountAMin, \n    uint256 amountBMin, \n    address to, \n    uint256 deadline \n  ) external returns (uint256 amountA, uint256 amountB); \n \n  function removeLiquidityETH( \n    address token, \n    uint256 liquidity, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline \n  ) external returns (uint256 amountToken, uint256 amountETH); \n \n  function removeLiquidityWithPermit( \n    address tokenA, \n    address tokenB, \n    uint256 liquidity, \n    uint256 amountAMin, \n    uint256 amountBMin, \n    address to, \n    uint256 deadline, \n    bool approveMax, \n    uint8 v, \n    bytes32 r, \n    bytes32 s \n  ) external returns (uint256 amountA, uint256 amountB); \n \n  function removeLiquidityETHWithPermit( \n    address token, \n    uint256 liquidity, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline, \n    bool approveMax, \n    uint8 v, \n    bytes32 r, \n    bytes32 s \n  ) external returns (uint256 amountToken, uint256 amountETH); \n \n  function swapExactTokensForTokens( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapTokensForExactTokens( \n    uint256 amountOut, \n    uint256 amountInMax, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapExactETHForTokens( \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external payable returns (uint256[] memory amounts); \n \n  function swapTokensForExactETH( \n    uint256 amountOut, \n    uint256 amountInMax, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapExactTokensForETH( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapETHForExactTokens( \n    uint256 amountOut, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external payable returns (uint256[] memory amounts); \n \n  function quote( \n    uint256 amountA, \n    uint256 reserveA, \n    uint256 reserveB \n  ) external pure returns (uint256 amountB); \n \n  function getAmountOut( \n    uint256 amountIn, \n    uint256 reserveIn, \n    uint256 reserveOut \n  ) external pure returns (uint256 amountOut); \n \n  function getAmountIn( \n    uint256 amountOut, \n    uint256 reserveIn, \n    uint256 reserveOut \n  ) external pure returns (uint256 amountIn); \n \n  function getAmountsOut(uint256 amountIn, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n \n  function getAmountsIn(uint256 amountOut, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n} \n",
            "pragma solidity 0.6.12; \n \ninterface IWETH { \n  function deposit() external payable; \n \n  function withdraw(uint256) external; \n \n  function approve(address guy, uint256 wad) external returns (bool); \n \n  function transferFrom( \n    address src, \n    address dst, \n    uint256 wad \n  ) external returns (bool); \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \n \ninterface IUiPoolDataProvider { \n  struct AggregatedReserveData { \n    address underlyingAsset; \n    string name; \n    string symbol; \n    uint256 decimals; \n    uint256 baseLTVasCollateral; \n    uint256 reserveLiquidationThreshold; \n    uint256 reserveLiquidationBonus; \n    uint256 reserveFactor; \n    bool usageAsCollateralEnabled; \n    bool borrowingEnabled; \n    bool stableBorrowRateEnabled; \n    bool isActive; \n    bool isFrozen; \n    // base data \n    uint128 liquidityIndex; \n    uint128 variableBorrowIndex; \n    uint128 liquidityRate; \n    uint128 variableBorrowRate; \n    uint128 stableBorrowRate; \n    uint40 lastUpdateTimestamp; \n    address aTokenAddress; \n    address stableDebtTokenAddress; \n    address variableDebtTokenAddress; \n    address interestRateStrategyAddress; \n    // \n    uint256 availableLiquidity; \n    uint256 totalPrincipalStableDebt; \n    uint256 averageStableRate; \n    uint256 stableDebtLastUpdateTimestamp; \n    uint256 totalScaledVariableDebt; \n    uint256 priceInEth; \n    uint256 variableRateSlope1; \n    uint256 variableRateSlope2; \n    uint256 stableRateSlope1; \n    uint256 stableRateSlope2; \n  } \n  // \n  //  struct ReserveData { \n  //    uint256 averageStableBorrowRate; \n  //    uint256 totalLiquidity; \n  //  } \n \n  struct UserReserveData { \n    address underlyingAsset; \n    uint256 scaledATokenBalance; \n    bool usageAsCollateralEnabledOnUser; \n    uint256 stableBorrowRate; \n    uint256 scaledVariableDebt; \n    uint256 principalStableDebt; \n    uint256 stableBorrowLastUpdateTimestamp; \n  } \n \n  // \n  //  struct ATokenSupplyData { \n  //    string name; \n  //    string symbol; \n  //    uint8 decimals; \n  //    uint256 totalSupply; \n  //    address aTokenAddress; \n  //  } \n \n  function getReservesData(ILendingPoolAddressesProvider provider, address user) \n    external \n    view \n    returns ( \n      AggregatedReserveData[] memory, \n      UserReserveData[] memory, \n      uint256 \n    ); \n \n  //  function getUserReservesData(ILendingPoolAddressesProvider provider, address user) \n  //    external \n  //    view \n  //    returns (UserReserveData[] memory); \n  // \n  //  function getAllATokenSupply(ILendingPoolAddressesProvider provider) \n  //    external \n  //    view \n  //    returns (ATokenSupplyData[] memory); \n  // \n  //  function getATokenSupply(address[] calldata aTokens) \n  //    external \n  //    view \n  //    returns (ATokenSupplyData[] memory); \n} \n",
            "pragma solidity 0.6.12; \n \ninterface IWETHGateway { \n  function depositETH( \n    address lendingPool, \n    address onBehalfOf, \n    uint16 referralCode \n  ) external payable; \n \n  function withdrawETH( \n    address lendingPool, \n    uint256 amount, \n    address onBehalfOf \n  ) external; \n \n  function repayETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 rateMode, \n    address onBehalfOf \n  ) external payable; \n \n  function borrowETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 interesRateMode, \n    uint16 referralCode \n  ) external; \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol'; \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {IUiPoolDataProvider} from './interfaces/IUiPoolDataProvider.sol'; \nimport {ILendingPool} from '../interfaces/ILendingPool.sol'; \nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol'; \nimport {IAToken} from '../interfaces/IAToken.sol'; \nimport {IVariableDebtToken} from '../interfaces/IVariableDebtToken.sol'; \nimport {IStableDebtToken} from '../interfaces/IStableDebtToken.sol'; \nimport {WadRayMath} from '../protocol/libraries/math/WadRayMath.sol'; \nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol'; \nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \nimport { \n  DefaultReserveInterestRateStrategy \n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol'; \n \ncontract UiPoolDataProvider is IUiPoolDataProvider { \n  using WadRayMath for uint256; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  address public constant MOCK_USD_ADDRESS = 0x10F7Fc1F91Ba351f9C629c5947AD69bD03C05b96; \n \n  function getInterestRateStrategySlopes(DefaultReserveInterestRateStrategy interestRateStrategy) \n    internal \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256 \n    ) \n  { \n    return ( \n      interestRateStrategy.variableRateSlope1(), \n      interestRateStrategy.variableRateSlope2(), \n      interestRateStrategy.stableRateSlope1(), \n      interestRateStrategy.stableRateSlope2() \n    ); \n  } \n \n  function getReservesData(ILendingPoolAddressesProvider provider, address user) \n    external \n    view \n    override \n    returns ( \n      AggregatedReserveData[] memory, \n      UserReserveData[] memory, \n      uint256 \n    ) \n  { \n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool()); \n    IPriceOracleGetter oracle = IPriceOracleGetter(provider.getPriceOracle()); \n    address[] memory reserves = lendingPool.getReservesList(); \n    DataTypes.UserConfigurationMap memory userConfig = lendingPool.getUserConfiguration(user); \n \n    AggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length); \n    UserReserveData[] memory userReservesData = \n      new UserReserveData[](user != address(0) ? reserves.length : 0); \n \n    for (uint256 i = 0; i < reserves.length; i++) { \n      AggregatedReserveData memory reserveData = reservesData[i]; \n      reserveData.underlyingAsset = reserves[i]; \n \n      // reserve current state \n      DataTypes.ReserveData memory baseData = \n        lendingPool.getReserveData(reserveData.underlyingAsset); \n      reserveData.liquidityIndex = baseData.liquidityIndex; \n      reserveData.variableBorrowIndex = baseData.variableBorrowIndex; \n      reserveData.liquidityRate = baseData.currentLiquidityRate; \n      reserveData.variableBorrowRate = baseData.currentVariableBorrowRate; \n      reserveData.stableBorrowRate = baseData.currentStableBorrowRate; \n      reserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp; \n      reserveData.aTokenAddress = baseData.aTokenAddress; \n      reserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress; \n      reserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress; \n      reserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress; \n      reserveData.priceInEth = oracle.getAssetPrice(reserveData.underlyingAsset); \n \n      reserveData.availableLiquidity = IERC20Detailed(reserveData.underlyingAsset).balanceOf( \n        reserveData.aTokenAddress \n      ); \n      ( \n        reserveData.totalPrincipalStableDebt, \n        , \n        reserveData.averageStableRate, \n        reserveData.stableDebtLastUpdateTimestamp \n      ) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData(); \n      reserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress) \n        .scaledTotalSupply(); \n \n      // reserve configuration \n \n      // we're getting this info from the aToken, because some of assets can be not compliant with ET\n      reserveData.symbol = IERC20Detailed(reserveData.aTokenAddress).symbol(); \n      reserveData.name = ''; \n \n      ( \n        reserveData.baseLTVasCollateral, \n        reserveData.reserveLiquidationThreshold, \n        reserveData.reserveLiquidationBonus, \n        reserveData.decimals, \n        reserveData.reserveFactor \n      ) = baseData.configuration.getParamsMemory(); \n      ( \n        reserveData.isActive, \n        reserveData.isFrozen, \n        reserveData.borrowingEnabled, \n        reserveData.stableBorrowRateEnabled \n      ) = baseData.configuration.getFlagsMemory(); \n      reserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0; \n      ( \n        reserveData.variableRateSlope1, \n        reserveData.variableRateSlope2, \n        reserveData.stableRateSlope1, \n        reserveData.stableRateSlope2 \n      ) = getInterestRateStrategySlopes( \n        DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress) \n      ); \n \n      if (user != address(0)) { \n        // user reserve data \n        userReservesData[i].underlyingAsset = reserveData.underlyingAsset; \n        userReservesData[i].scaledATokenBalance = IAToken(reserveData.aTokenAddress) \n          .scaledBalanceOf(user); \n        userReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i); \n \n        if (userConfig.isBorrowing(i)) { \n          userReservesData[i].scaledVariableDebt = IVariableDebtToken( \n            reserveData \n              .variableDebtTokenAddress \n          ) \n            .scaledBalanceOf(user); \n          userReservesData[i].principalStableDebt = IStableDebtToken( \n            reserveData \n              .stableDebtTokenAddress \n          ) \n            .principalBalanceOf(user); \n          if (userReservesData[i].principalStableDebt != 0) { \n            userReservesData[i].stableBorrowRate = IStableDebtToken( \n              reserveData \n                .stableDebtTokenAddress \n            ) \n              .getUserStableRate(user); \n            userReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken( \n              reserveData \n                .stableDebtTokenAddress \n            ) \n              .getUserLastUpdated(user); \n          } \n        } \n      } \n    } \n    return (reservesData, userReservesData, oracle.getAssetPrice(MOCK_USD_ADDRESS)); \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol'; \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../interfaces/ILendingPool.sol'; \nimport {IStableDebtToken} from '../interfaces/IStableDebtToken.sol'; \nimport {IVariableDebtToken} from '../interfaces/IVariableDebtToken.sol'; \nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol'; \nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \n \ncontract AaveProtocolDataProvider { \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  address constant MKR = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2; \n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; \n \n  struct TokenData { \n    string symbol; \n    address tokenAddress; \n  } \n \n  ILendingPoolAddressesProvider public immutable ADDRESSES_PROVIDER; \n \n  constructor(ILendingPoolAddressesProvider addressesProvider) public { \n    ADDRESSES_PROVIDER = addressesProvider; \n  } \n \n  function getAllReservesTokens() external view returns (TokenData[] memory) { \n    ILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool()); \n    address[] memory reserves = pool.getReservesList(); \n    TokenData[] memory reservesTokens = new TokenData[](reserves.length); \n    for (uint256 i = 0; i < reserves.length; i++) { \n      if (reserves[i] == MKR) { \n        reservesTokens[i] = TokenData({symbol: 'MKR', tokenAddress: reserves[i]}); \n        continue; \n      } \n      if (reserves[i] == ETH) { \n        reservesTokens[i] = TokenData({symbol: 'ETH', tokenAddress: reserves[i]}); \n        continue; \n      } \n      reservesTokens[i] = TokenData({ \n        symbol: IERC20Detailed(reserves[i]).symbol(), \n        tokenAddress: reserves[i] \n      }); \n    } \n    return reservesTokens; \n  } \n \n  function getAllATokens() external view returns (TokenData[] memory) { \n    ILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool()); \n    address[] memory reserves = pool.getReservesList(); \n    TokenData[] memory aTokens = new TokenData[](reserves.length); \n    for (uint256 i = 0; i < reserves.length; i++) { \n      DataTypes.ReserveData memory reserveData = pool.getReserveData(reserves[i]); \n      aTokens[i] = TokenData({ \n        symbol: IERC20Detailed(reserveData.aTokenAddress).symbol(), \n        tokenAddress: reserveData.aTokenAddress \n      }); \n    } \n    return aTokens; \n  } \n \n  function getReserveConfigurationData(address asset) \n    external \n    view \n    returns ( \n      uint256 decimals, \n      uint256 ltv, \n      uint256 liquidationThreshold, \n      uint256 liquidationBonus, \n      uint256 reserveFactor, \n      bool usageAsCollateralEnabled, \n      bool borrowingEnabled, \n      bool stableBorrowRateEnabled, \n      bool isActive, \n      bool isFrozen \n    ) \n  { \n    DataTypes.ReserveConfigurationMap memory configuration = \n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getConfiguration(asset); \n \n    (ltv, liquidationThreshold, liquidationBonus, decimals, reserveFactor) = configuration \n      .getParamsMemory(); \n \n    (isActive, isFrozen, borrowingEnabled, stableBorrowRateEnabled) = configuration \n      .getFlagsMemory(); \n \n    usageAsCollateralEnabled = liquidationThreshold > 0; \n  } \n \n  function getReserveData(address asset) \n    external \n    view \n    returns ( \n      uint256 availableLiquidity, \n      uint256 totalStableDebt, \n      uint256 totalVariableDebt, \n      uint256 liquidityRate, \n      uint256 variableBorrowRate, \n      uint256 stableBorrowRate, \n      uint256 averageStableBorrowRate, \n      uint256 liquidityIndex, \n      uint256 variableBorrowIndex, \n      uint40 lastUpdateTimestamp \n    ) \n  { \n    DataTypes.ReserveData memory reserve = \n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset); \n \n    return ( \n      IERC20Detailed(asset).balanceOf(reserve.aTokenAddress), \n      IERC20Detailed(reserve.stableDebtTokenAddress).totalSupply(), \n      IERC20Detailed(reserve.variableDebtTokenAddress).totalSupply(), \n      reserve.currentLiquidityRate, \n      reserve.currentVariableBorrowRate, \n      reserve.currentStableBorrowRate, \n      IStableDebtToken(reserve.stableDebtTokenAddress).getAverageStableRate(), \n      reserve.liquidityIndex, \n      reserve.variableBorrowIndex, \n      reserve.lastUpdateTimestamp \n    ); \n  } \n \n  function getUserReserveData(address asset, address user) \n    external \n    view \n    returns ( \n      uint256 currentATokenBalance, \n      uint256 currentStableDebt, \n      uint256 currentVariableDebt, \n      uint256 principalStableDebt, \n      uint256 scaledVariableDebt, \n      uint256 stableBorrowRate, \n      uint256 liquidityRate, \n      uint40 stableRateLastUpdated, \n      bool usageAsCollateralEnabled \n    ) \n  { \n    DataTypes.ReserveData memory reserve = \n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset); \n \n    DataTypes.UserConfigurationMap memory userConfig = \n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getUserConfiguration(user); \n \n    currentATokenBalance = IERC20Detailed(reserve.aTokenAddress).balanceOf(user); \n    currentVariableDebt = IERC20Detailed(reserve.variableDebtTokenAddress).balanceOf(user); \n    currentStableDebt = IERC20Detailed(reserve.stableDebtTokenAddress).balanceOf(user); \n    principalStableDebt = IStableDebtToken(reserve.stableDebtTokenAddress).principalBalanceOf(user); \n    scaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user); \n    liquidityRate = reserve.currentLiquidityRate; \n    stableBorrowRate = IStableDebtToken(reserve.stableDebtTokenAddress).getUserStableRate(user); \n    stableRateLastUpdated = IStableDebtToken(reserve.stableDebtTokenAddress).getUserLastUpdated( \n      user \n    ); \n    usageAsCollateralEnabled = userConfig.isUsingAsCollateral(reserve.id); \n  } \n \n  function getReserveTokensAddresses(address asset) \n    external \n    view \n    returns ( \n      address aTokenAddress, \n      address stableDebtTokenAddress, \n      address variableDebtTokenAddress \n    ) \n  { \n    DataTypes.ReserveData memory reserve = \n      ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset); \n \n    return ( \n      reserve.aTokenAddress, \n      reserve.stableDebtTokenAddress, \n      reserve.variableDebtTokenAddress \n    ); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol'; \nimport {IChainlinkAggregator} from '../interfaces/IChainlinkAggregator.sol'; \nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol'; \n \n/// @title AaveOracle \n/// @author Aave \n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Agg\n///         smart contracts as primary option \n/// - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallbackOra\n/// - Owned by the Aave governance system, allowed to add sources for assets, replace them \n///   and change the fallbackOracle \ncontract AaveOracle is IPriceOracleGetter, Ownable { \n  using SafeERC20 for IERC20; \n \n  event AssetSourceUpdated(address indexed asset, address indexed source); \n  event FallbackOracleUpdated(address indexed fallbackOracle); \n \n  mapping(address => IChainlinkAggregator) private assetsSources; \n  IPriceOracleGetter private _fallbackOracle; \n \n  /// @notice Constructor \n  /// @param assets The addresses of the assets \n  /// @param sources The address of the source of each asset \n  /// @param fallbackOracle The address of the fallback oracle to use if the data of an \n  ///        aggregator is not consistent \n  constructor( \n    address[] memory assets, \n    address[] memory sources, \n    address fallbackOracle \n  ) public { \n    _setFallbackOracle(fallbackOracle); \n    _setAssetsSources(assets, sources); \n  } \n \n  /// @notice External function called by the Aave governance to set or replace sources of assets \n  /// @param assets The addresses of the assets \n  /// @param sources The address of the source of each asset \n  function setAssetSources(address[] calldata assets, address[] calldata sources) \n    external \n    onlyOwner \n  { \n    _setAssetsSources(assets, sources); \n  } \n \n  /// @notice Sets the fallbackOracle \n  /// - Callable only by the Aave governance \n  /// @param fallbackOracle The address of the fallbackOracle \n  function setFallbackOracle(address fallbackOracle) external onlyOwner { \n    _setFallbackOracle(fallbackOracle); \n  } \n \n  /// @notice Internal function to set the sources for each asset \n  /// @param assets The addresses of the assets \n  /// @param sources The address of the source of each asset \n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal { \n    require(assets.length == sources.length, 'INCONSISTENT_PARAMS_LENGTH'); \n    for (uint256 i = 0; i < assets.length; i++) { \n      assetsSources[assets[i]] = IChainlinkAggregator(sources[i]); \n      emit AssetSourceUpdated(assets[i], sources[i]); \n    } \n  } \n \n  /// @notice Internal function to set the fallbackOracle \n  /// @param fallbackOracle The address of the fallbackOracle \n  function _setFallbackOracle(address fallbackOracle) internal { \n    _fallbackOracle = IPriceOracleGetter(fallbackOracle); \n    emit FallbackOracleUpdated(fallbackOracle); \n  } \n \n  /// @notice Gets an asset price by address \n  /// @param asset The asset address \n  function getAssetPrice(address asset) public view override returns (uint256) { \n    IChainlinkAggregator source = assetsSources[asset]; \n \n    if (address(source) == address(0)) { \n      return _fallbackOracle.getAssetPrice(asset); \n    } else { \n      int256 price = IChainlinkAggregator(source).latestAnswer(); \n      if (price > 0) { \n        return uint256(price); \n      } else { \n        return _fallbackOracle.getAssetPrice(asset); \n      } \n    } \n  } \n \n  /// @notice Gets a list of prices from a list of assets addresses \n  /// @param assets The list of assets addresses \n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory) { \n    uint256[] memory prices = new uint256[](assets.length); \n    for (uint256 i = 0; i < assets.length; i++) { \n      prices[i] = getAssetPrice(assets[i]); \n    } \n    return prices; \n  } \n \n  /// @notice Gets the address of the source for an asset address \n  /// @param asset The address of the asset \n  /// @return address The address of the source \n  function getSourceOfAsset(address asset) external view returns (address) { \n    return address(assetsSources[asset]); \n  } \n \n  /// @notice Gets the address of the fallback oracle \n  /// @return address The addres of the fallback oracle \n  function getFallbackOracle() external view returns (address) { \n    return address(_fallbackOracle); \n  } \n} \n",
            "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {IWETH} from './interfaces/IWETH.sol'; \nimport {IWETHGateway} from './interfaces/IWETHGateway.sol'; \nimport {ILendingPool} from '../interfaces/ILendingPool.sol'; \nimport {IAToken} from '../interfaces/IAToken.sol'; \nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol'; \nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol'; \nimport {Helpers} from '../protocol/libraries/helpers/Helpers.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \n \ncontract WETHGateway is IWETHGateway, Ownable { \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  IWETH internal immutable WETH; \n \n  /** \n   * @dev Sets the WETH address and the LendingPoolAddressesProvider address. Infinite approves lendi\n   * @param weth Address of the Wrapped Ether contract \n   **/ \n  constructor(address weth) public { \n    WETH = IWETH(weth); \n  } \n \n  function authorizeLendingPool(address lendingPool) external onlyOwner { \n    WETH.approve(lendingPool, uint256(-1)); \n  } \n \n  /** \n   * @dev deposits WETH into the reserve, using native ETH. A corresponding amount of the overlying a\n   * is minted. \n   * @param lendingPool address of the targeted underlying lending pool \n   * @param onBehalfOf address of the user who will receive the aTokens representing the deposit \n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards\n   **/ \n  function depositETH( \n    address lendingPool, \n    address onBehalfOf, \n    uint16 referralCode \n  ) external payable override { \n    WETH.deposit{value: msg.value}(); \n    ILendingPool(lendingPool).deposit(address(WETH), msg.value, onBehalfOf, referralCode); \n  } \n \n  /** \n   * @dev withdraws the WETH _reserves of msg.sender. \n   * @param lendingPool address of the targeted underlying lending pool \n   * @param amount amount of aWETH to withdraw and receive native ETH \n   * @param to address of the user who will receive native ETH \n   */ \n  function withdrawETH( \n    address lendingPool, \n    uint256 amount, \n    address to \n  ) external override { \n    IAToken aWETH = IAToken(ILendingPool(lendingPool).getReserveData(address(WETH)).aTokenAddress); \n    uint256 userBalance = aWETH.balanceOf(msg.sender); \n    uint256 amountToWithdraw = amount; \n \n    // if amount is equal to uint(-1), the user wants to redeem everything \n    if (amount == type(uint256).max) { \n      amountToWithdraw = userBalance; \n    } \n    aWETH.transferFrom(msg.sender, address(this), amountToWithdraw); \n    ILendingPool(lendingPool).withdraw(address(WETH), amountToWithdraw, address(this)); \n    WETH.withdraw(amountToWithdraw); \n    _safeTransferETH(to, amountToWithdraw); \n  } \n \n  /** \n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if \n   * @param lendingPool address of the targeted underlying lending pool \n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything \n   * @param rateMode the rate mode to repay \n   * @param onBehalfOf the address for which msg.sender is repaying \n   */ \n  function repayETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 rateMode, \n    address onBehalfOf \n  ) external payable override { \n    (uint256 stableDebt, uint256 variableDebt) = \n      Helpers.getUserCurrentDebtMemory( \n        onBehalfOf, \n        ILendingPool(lendingPool).getReserveData(address(WETH)) \n      ); \n \n    uint256 paybackAmount = \n      DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE \n        ? stableDebt \n        : variableDebt; \n \n    if (amount < paybackAmount) { \n      paybackAmount = amount; \n    } \n    require(msg.value >= paybackAmount, 'msg.value is less than repayment amount'); \n    WETH.deposit{value: paybackAmount}(); \n    ILendingPool(lendingPool).repay(address(WETH), msg.value, rateMode, onBehalfOf); \n \n    // refund remaining dust eth \n    if (msg.value > paybackAmount) _safeTransferETH(msg.sender, msg.value - paybackAmount); \n  } \n \n  /** \n   * @dev borrow WETH, unwraps to ETH and send both the ETH and DebtTokens to msg.sender, via `approv\n   * @param lendingPool address of the targeted underlying lending pool \n   * @param amount the amount of ETH to borrow \n   * @param interesRateMode the interest rate mode \n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards\n   */ \n  function borrowETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 interesRateMode, \n    uint16 referralCode \n  ) external override { \n    ILendingPool(lendingPool).borrow( \n      address(WETH), \n      amount, \n      interesRateMode, \n      referralCode, \n      msg.sender \n    ); \n    WETH.withdraw(amount); \n    _safeTransferETH(msg.sender, amount); \n  } \n \n  /** \n   * @dev transfer ETH to an address, revert if it fails. \n   * @param to recipient of the transfer \n   * @param value the amount to send \n   */ \n  function _safeTransferETH(address to, uint256 value) internal { \n    (bool success, ) = to.call{value: value}(new bytes(0)); \n    require(success, 'ETH_TRANSFER_FAILED'); \n  } \n \n  /** \n   * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due \n   * direct transfers to the contract address. \n   * @param token token to transfer \n   * @param to recipient of the transfer \n   * @param amount amount to send \n   */ \n  function emergencyTokenTransfer( \n    address token, \n    address to, \n    uint256 amount \n  ) external onlyOwner { \n    IERC20(token).transfer(to, amount); \n  } \n \n  /** \n   * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck \n   * due selfdestructs or transfer ether to pre-computated contract address before deployment. \n   * @param to recipient of the transfer \n   * @param amount amount to send \n   */ \n  function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner { \n    _safeTransferETH(to, amount); \n  } \n \n  /** \n   * @dev Get WETH address used by WETHGateway \n   */ \n  function getWETHAddress() external view returns (address) { \n    return address(WETH); \n  } \n \n  /** \n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether t\n   */ \n  receive() external payable { \n    require(msg.sender == address(WETH), 'Receive not allowed'); \n  } \n \n  /** \n   * @dev Revert fallback calls \n   */ \n  fallback() external payable { \n    revert('Fallback not allowed'); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \npragma experimental ABIEncoderV2; \n \nimport {Address} from '../dependencies/openzeppelin/contracts/Address.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../interfaces/ILendingPool.sol'; \nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \n \n/** \n * @title WalletBalanceProvider contract \n * @author Aave, influenced by https://github.com/wbobeirne/eth-balance-checker/blob/master/contracts\n * @notice Implements a logic of getting multiple tokens balance for one user address \n * @dev NOTE: THIS CONTRACT IS NOT USED WITHIN THE AAVE PROTOCOL. It's an accessory contract used to \n * towards the blockchain from the Aave backend. \n **/ \ncontract WalletBalanceProvider { \n  using Address for address payable; \n  using Address for address; \n  using SafeERC20 for IERC20; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n \n  address constant MOCK_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; \n \n  /** \n    @dev Fallback function, don't accept any ETH \n    **/ \n  receive() external payable { \n    //only contracts can send ETH to the core \n    require(msg.sender.isContract(), '22'); \n  } \n \n  /** \n    @dev Check the token balance of a wallet in a token contract \n \n    Returns the balance of the token for user. Avoids possible errors: \n      - return 0 on non-contract address \n    **/ \n  function balanceOf(address user, address token) public view returns (uint256) { \n    if (token == MOCK_ETH_ADDRESS) { \n      return user.balance; // ETH balance \n      // check if token is actually a contract \n    } else if (token.isContract()) { \n      return IERC20(token).balanceOf(user); \n    } \n    revert('INVALID_TOKEN'); \n  } \n \n  /** \n   * @notice Fetches, for a list of _users and _tokens (ETH included with mock address), the balances\n   * @param users The list of users \n   * @param tokens The list of tokens \n   * @return And array with the concatenation of, for each user, his/her balances \n   **/ \n  function batchBalanceOf(address[] calldata users, address[] calldata tokens) \n    external \n    view \n    returns (uint256[] memory) \n  { \n    uint256[] memory balances = new uint256[](users.length * tokens.length); \n \n    for (uint256 i = 0; i < users.length; i++) { \n      for (uint256 j = 0; j < tokens.length; j++) { \n        balances[i * tokens.length + j] = balanceOf(users[i], tokens[j]); \n      } \n    } \n \n    return balances; \n  } \n \n  /** \n    @dev provides balances of user wallet for all reserves available on the pool \n    */ \n  function getUserWalletBalances(address provider, address user) \n    external \n    view \n    returns (address[] memory, uint256[] memory) \n  { \n    ILendingPool pool = ILendingPool(ILendingPoolAddressesProvider(provider).getLendingPool()); \n \n    address[] memory reserves = pool.getReservesList(); \n    address[] memory reservesWithEth = new address[](reserves.length + 1); \n    for (uint256 i = 0; i < reserves.length; i++) { \n      reservesWithEth[i] = reserves[i]; \n    } \n    reservesWithEth[reserves.length] = MOCK_ETH_ADDRESS; \n \n    uint256[] memory balances = new uint256[](reservesWithEth.length); \n \n    for (uint256 j = 0; j < reserves.length; j++) { \n      DataTypes.ReserveConfigurationMap memory configuration = \n        pool.getConfiguration(reservesWithEth[j]); \n \n      (bool isActive, , , ) = configuration.getFlagsMemory(); \n \n      if (!isActive) { \n        balances[j] = 0; \n        continue; \n      } \n      balances[j] = balanceOf(user, reservesWithEth[j]); \n    } \n    balances[reserves.length] = balanceOf(user, MOCK_ETH_ADDRESS); \n \n    return (reservesWithEth, balances); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {VariableDebtToken} from '../../protocol/tokenization/VariableDebtToken.sol'; \n \ncontract MockVariableDebtToken is VariableDebtToken { \n  function getRevision() internal pure override returns (uint256) { \n    return 0x2; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {StableDebtToken} from '../../protocol/tokenization/StableDebtToken.sol'; \n \ncontract MockStableDebtToken is StableDebtToken { \n  function getRevision() internal pure override returns (uint256) { \n    return 0x2; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {AToken} from '../../protocol/tokenization/AToken.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol'; \n \ncontract MockAToken is AToken { \n  function getRevision() internal pure override returns (uint256) { \n    return 0x2; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \ncontract SelfdestructTransfer { \n  function destroyAndTransfer(address payable to) external payable { \n    selfdestruct(to); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol'; \n \n/** \n * @title ERC20Mintable \n * @dev ERC20 minting logic \n */ \ncontract MintableDelegationERC20 is ERC20 { \n  address public delegatee; \n \n  constructor( \n    string memory name, \n    string memory symbol, \n    uint8 decimals \n  ) public ERC20(name, symbol) { \n    _setupDecimals(decimals); \n  } \n \n  /** \n   * @dev Function to mint tokensp \n   * @param value The amount of tokens to mint. \n   * @return A boolean that indicates if the operation was successful. \n   */ \n  function mint(uint256 value) public returns (bool) { \n    _mint(msg.sender, value); \n    return true; \n  } \n \n  function delegate(address delegateeAddress) external { \n    delegatee = delegateeAddress; \n  } \n} \n",
            "pragma solidity >=0.4.22 <=0.6.12; \n \nimport {WETH9} from '../dependencies/weth/WETH9.sol'; \n \ncontract WETH9Mocked is WETH9 { \n  // Mint not backed by Ether: only for testing purposes \n  function mint(uint256 value) public returns (bool) { \n    balanceOf[msg.sender] += value; \n    emit Transfer(address(0), msg.sender, value); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol'; \n \n/** \n * @title ERC20Mintable \n * @dev ERC20 minting logic \n */ \ncontract MintableERC20 is ERC20 { \n  constructor( \n    string memory name, \n    string memory symbol, \n    uint8 decimals \n  ) public ERC20(name, symbol) { \n    _setupDecimals(decimals); \n  } \n \n  /** \n   * @dev Function to mint tokens \n   * @param value The amount of tokens to mint. \n   * @return A boolean that indicates if the operation was successful. \n   */ \n  function mint(uint256 value) public returns (bool) { \n    _mint(_msgSender(), value); \n    return true; \n  } \n} \n// Copyright (C) 2015, 2016, 2017 Dapphub \n \n// This program is free software: you can redistribute it and/or modify \n// it under the terms of the GNU General Public License as published by \n// the Free Software Foundation, either version 3 of the License, or \n// (at your option) any later version. \n \n// This program is distributed in the hope that it will be useful, \n// but WITHOUT ANY WARRANTY; without even the implied warranty of \n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \n// GNU General Public License for more details. \n \n// You should have received a copy of the GNU General Public License \n// along with this program.  If not, see <http://www.gnu.org/licenses/>. \n \n",
            "pragma solidity >=0.4.22 <=0.6.12; \n \ncontract WETH9 { \n  string public name = 'Wrapped Ether'; \n  string public symbol = 'WETH'; \n  uint8 public decimals = 18; \n \n  event Approval(address indexed src, address indexed guy, uint256 wad); \n  event Transfer(address indexed src, address indexed dst, uint256 wad); \n  event Deposit(address indexed dst, uint256 wad); \n  event Withdrawal(address indexed src, uint256 wad); \n \n  mapping(address => uint256) public balanceOf; \n  mapping(address => mapping(address => uint256)) public allowance; \n \n  receive() external payable { \n    deposit(); \n  } \n \n  function deposit() public payable { \n    balanceOf[msg.sender] += msg.value; \n    emit Deposit(msg.sender, msg.value); \n  } \n \n  function withdraw(uint256 wad) public { \n    require(balanceOf[msg.sender] >= wad); \n    balanceOf[msg.sender] -= wad; \n    msg.sender.transfer(wad); \n    emit Withdrawal(msg.sender, wad); \n  } \n \n  function totalSupply() public view returns (uint256) { \n    return address(this).balance; \n  } \n \n  function approve(address guy, uint256 wad) public returns (bool) { \n    allowance[msg.sender][guy] = wad; \n    emit Approval(msg.sender, guy, wad); \n    return true; \n  } \n \n  function transfer(address dst, uint256 wad) public returns (bool) { \n    return transferFrom(msg.sender, dst, wad); \n  } \n \n  function transferFrom( \n    address src, \n    address dst, \n    uint256 wad \n  ) public returns (bool) { \n    require(balanceOf[src] >= wad); \n \n    if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) { \n      require(allowance[src][msg.sender] >= wad); \n      allowance[src][msg.sender] -= wad; \n    } \n \n    balanceOf[src] -= wad; \n    balanceOf[dst] += wad; \n \n    emit Transfer(src, dst, wad); \n \n    return true; \n  } \n} \n \n/* \n                    GNU GENERAL PUBLIC LICENSE \n                       Version 3, 29 June 2007 \n \n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/> \n Everyone is permitted to copy and distribute verbatim copies \n of this license document, but changing it is not allowed. \n \n                            Preamble \n \n  The GNU General Public License is a free, copyleft license for \nsoftware and other kinds of works. \n \n  The licenses for most software and other practical works are designed \nto take away your freedom to share and change the works.  By contrast, \nthe GNU General Public License is intended to guarantee your freedom to \nshare and change all versions of a program--to make sure it remains free \nsoftware for all its users.  We, the Free Software Foundation, use the \nGNU General Public License for most of our software; it applies also to \nany other work released this way by its authors.  You can apply it to \nyour programs, too. \n \n  When we speak of free software, we are referring to freedom, not \nprice.  Our General Public Licenses are designed to make sure that you \nhave the freedom to distribute copies of free software (and charge for \nthem if you wish), that you receive source code or can get it if you \nwant it, that you can change the software or use pieces of it in new \nfree programs, and that you know you can do these things. \n \n  To protect your rights, we need to prevent others from denying you \nthese rights or asking you to surrender the rights.  Therefore, you have \ncertain responsibilities if you distribute copies of the software, or if \nyou modify it: responsibilities to respect the freedom of others. \n \n  For example, if you distribute copies of such a program, whether \ngratis or for a fee, you must pass on to the recipients the same \nfreedoms that you received.  You must make sure that they, too, receive \nor can get the source code.  And you must show them these terms so they \nknow their rights. \n \n  Developers that use the GNU GPL protect your rights with two steps: \n(1) assert copyright on the software, and (2) offer you this License \ngiving you legal permission to copy, distribute and/or modify it. \n \n  For the developers' and authors' protection, the GPL clearly explains \nthat there is no warranty for this free software.  For both users' and \nauthors' sake, the GPL requires that modified versions be marked as \nchanged, so that their problems will not be attributed erroneously to \nauthors of previous versions. \n \n  Some devices are designed to deny users access to install or run \nmodified versions of the software inside them, although the manufacturer \ncan do so.  This is fundamentally incompatible with the aim of \nprotecting users' freedom to change the software.  The systematic \npattern of such abuse occurs in the area of products for individuals to \nuse, which is precisely where it is most unacceptable.  Therefore, we \nhave designed this version of the GPL to prohibit the practice for those \nproducts.  If such problems arise substantially in other domains, we \nstand ready to extend this provision to those domains in future versions \nof the GPL, as needed to protect the freedom of users. \n \n  Finally, every program is threatened constantly by software patents. \nStates should not allow patents to restrict development and use of \nsoftware on general-purpose computers, but in those that do, we wish to \navoid the special danger that patents applied to a free program could \nmake it effectively proprietary.  To prevent this, the GPL assures that \npatents cannot be used to render the program non-free. \n \n  The precise terms and conditions for copying, distribution and \nmodification follow. \n \n                       TERMS AND CONDITIONS \n \n  0. Definitions. \n \n  \"This License\" refers to version 3 of the GNU General Public License. \n \n  \"Copyright\" also means copyright-like laws that apply to other kinds of \nworks, such as semiconductor masks. \n \n  \"The Program\" refers to any copyrightable work licensed under this \nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and \n\"recipients\" may be individuals or organizations. \n \n  To \"modify\" a work means to copy from or adapt all or part of the work \nin a fashion requiring copyright permission, other than the making of an \nexact copy.  The resulting work is called a \"modified version\" of the \nearlier work or a work \"based on\" the earlier work. \n \n  A \"covered work\" means either the unmodified Program or a work based \non the Program. \n \n  To \"propagate\" a work means to do anything with it that, without \npermission, would make you directly or secondarily liable for \ninfringement under applicable copyright law, except executing it on a \ncomputer or modifying a private copy.  Propagation includes copying, \ndistribution (with or without modification), making available to the \npublic, and in some countries other activities as well. \n \n  To \"convey\" a work means any kind of propagation that enables other \nparties to make or receive copies.  Mere interaction with a user through \na computer network, with no transfer of a copy, is not conveying. \n \n  An interactive user interface displays \"Appropriate Legal Notices\" \nto the extent that it includes a convenient and prominently visible \nfeature that (1) displays an appropriate copyright notice, and (2) \ntells the user that there is no warranty for the work (except to the \nextent that warranties are provided), that licensees may convey the \nwork under this License, and how to view a copy of this License.  If \nthe interface presents a list of user commands or options, such as a \nmenu, a prominent item in the list meets this criterion. \n \n  1. Source Code. \n \n  The \"source code\" for a work means the preferred form of the work \nfor making modifications to it.  \"Object code\" means any non-source \nform of a work. \n \n  A \"Standard Interface\" means an interface that either is an official \nstandard defined by a recognized standards body, or, in the case of \ninterfaces specified for a particular programming language, one that \nis widely used among developers working in that language. \n \n  The \"System Libraries\" of an executable work include anything, other \nthan the work as a whole, that (a) is included in the normal form of \npackaging a Major Component, but which is not part of that Major \nComponent, and (b) serves only to enable use of the work with that \nMajor Component, or to implement a Standard Interface for which an \nimplementation is available to the public in source code form.  A \n\"Major Component\", in this context, means a major essential component \n(kernel, window system, and so on) of the specific operating system \n(if any) on which the executable work runs, or a compiler used to \nproduce the work, or an object code interpreter used to run it. \n \n  The \"Corresponding Source\" for a work in object code form means all \nthe source code needed to generate, install, and (for an executable \nwork) run the object code and to modify the work, including scripts to \ncontrol those activities.  However, it does not include the work's \nSystem Libraries, or general-purpose tools or generally available free \nprograms which are used unmodified in performing those activities but \nwhich are not part of the work.  For example, Corresponding Source \nincludes interface definition files associated with source files for \nthe work, and the source code for shared libraries and dynamically \nlinked subprograms that the work is specifically designed to require, \nsuch as by intimate data communication or control flow between those \nsubprograms and other parts of the work. \n \n  The Corresponding Source need not include anything that users \ncan regenerate automatically from other parts of the Corresponding \nSource. \n \n  The Corresponding Source for a work in source code form is that \nsame work. \n \n  2. Basic Permissions. \n \n  All rights granted under this License are granted for the term of \ncopyright on the Program, and are irrevocable provided the stated \nconditions are met.  This License explicitly affirms your unlimited \npermission to run the unmodified Program.  The output from running a \ncovered work is covered by this License only if the output, given its \ncontent, constitutes a covered work.  This License acknowledges your \nrights of fair use or other equivalent, as provided by copyright law. \n \n  You may make, run and propagate covered works that you do not \nconvey, without conditions so long as your license otherwise remains \nin force.  You may convey covered works to others for the sole purpose \nof having them make modifications exclusively for you, or provide you \nwith facilities for running those works, provided that you comply with \nthe terms of this License in conveying all material for which you do \nnot control copyright.  Those thus making or running the covered works \nfor you must do so exclusively on your behalf, under your direction \nand control, on terms that prohibit them from making any copies of \nyour copyrighted material outside their relationship with you. \n \n  Conveying under any other circumstances is permitted solely under \nthe conditions stated below.  Sublicensing is not allowed; section 10 \nmakes it unnecessary. \n \n  3. Protecting Users' Legal Rights From Anti-Circumvention Law. \n \n  No covered work shall be deemed part of an effective technological \nmeasure under any applicable law fulfilling obligations under article \n11 of the WIPO copyright treaty adopted on 20 December 1996, or \nsimilar laws prohibiting or restricting circumvention of such \nmeasures. \n \n  When you convey a covered work, you waive any legal power to forbid \ncircumvention of technological measures to the extent such circumvention \nis effected by exercising rights under this License with respect to \nthe covered work, and you disclaim any intention to limit operation or \nmodification of the work as a means of enforcing, against the work's \nusers, your or third parties' legal rights to forbid circumvention of \ntechnological measures. \n \n  4. Conveying Verbatim Copies. \n \n  You may convey verbatim copies of the Program's source code as you \nreceive it, in any medium, provided that you conspicuously and \nappropriately publish on each copy an appropriate copyright notice; \nkeep intact all notices stating that this License and any \nnon-permissive terms added in accord with section 7 apply to the code; \nkeep intact all notices of the absence of any warranty; and give all \nrecipients a copy of this License along with the Program. \n \n  You may charge any price or no price for each copy that you convey, \nand you may offer support or warranty protection for a fee. \n \n  5. Conveying Modified Source Versions. \n \n  You may convey a work based on the Program, or the modifications to \nproduce it from the Program, in the form of source code under the \nterms of section 4, provided that you also meet all of these conditions: \n \n    a) The work must carry prominent notices stating that you modified \n    it, and giving a relevant date. \n \n    b) The work must carry prominent notices stating that it is \n    released under this License and any conditions added under section \n    7.  This requirement modifies the requirement in section 4 to \n    \"keep intact all notices\". \n \n    c) You must license the entire work, as a whole, under this \n    License to anyone who comes into possession of a copy.  This \n    License will therefore apply, along with any applicable section 7 \n    additional terms, to the whole of the work, and all its parts, \n    regardless of how they are packaged.  This License gives no \n    permission to license the work in any other way, but it does not \n    invalidate such permission if you have separately received it. \n \n    d) If the work has interactive user interfaces, each must display \n    Appropriate Legal Notices; however, if the Program has interactive \n    interfaces that do not display Appropriate Legal Notices, your \n    work need not make them do so. \n \n  A compilation of a covered work with other separate and independent \nworks, which are not by their nature extensions of the covered work, \nand which are not combined with it such as to form a larger program, \nin or on a volume of a storage or distribution medium, is called an \n\"aggregate\" if the compilation and its resulting copyright are not \nused to limit the access or legal rights of the compilation's users \nbeyond what the individual works permit.  Inclusion of a covered work \nin an aggregate does not cause this License to apply to the other \nparts of the aggregate. \n \n  6. Conveying Non-Source Forms. \n \n  You may convey a covered work in object code form under the terms \nof sections 4 and 5, provided that you also convey the \nmachine-readable Corresponding Source under the terms of this License, \nin one of these ways: \n \n    a) Convey the object code in, or embodied in, a physical product \n    (including a physical distribution medium), accompanied by the \n    Corresponding Source fixed on a durable physical medium \n    customarily used for software interchange. \n \n    b) Convey the object code in, or embodied in, a physical product \n    (including a physical distribution medium), accompanied by a \n    written offer, valid for at least three years and valid for as \n    long as you offer spare parts or customer support for that product \n    model, to give anyone who possesses the object code either (1) a \n    copy of the Corresponding Source for all the software in the \n    product that is covered by this License, on a durable physical \n    medium customarily used for software interchange, for a price no \n    more than your reasonable cost of physically performing this \n    conveying of source, or (2) access to copy the \n    Corresponding Source from a network server at no charge. \n \n    c) Convey individual copies of the object code with a copy of the \n    written offer to provide the Corresponding Source.  This \n    alternative is allowed only occasionally and noncommercially, and \n    only if you received the object code with such an offer, in accord \n    with subsection 6b. \n \n    d) Convey the object code by offering access from a designated \n    place (gratis or for a charge), and offer equivalent access to the \n    Corresponding Source in the same way through the same place at no \n    further charge.  You need not require recipients to copy the \n    Corresponding Source along with the object code.  If the place to \n    copy the object code is a network server, the Corresponding Source \n    may be on a different server (operated by you or a third party) \n    that supports equivalent copying facilities, provided you maintain \n    clear directions next to the object code saying where to find the \n    Corresponding Source.  Regardless of what server hosts the \n    Corresponding Source, you remain obligated to ensure that it is \n    available for as long as needed to satisfy these requirements. \n \n    e) Convey the object code using peer-to-peer transmission, provided \n    you inform other peers where the object code and Corresponding \n    Source of the work are being offered to the general public at no \n    charge under subsection 6d. \n \n  A separable portion of the object code, whose source code is excluded \nfrom the Corresponding Source as a System Library, need not be \nincluded in conveying the object code work. \n \n  A \"User Product\" is either (1) a \"consumer product\", which means any \ntangible personal property which is normally used for personal, family, \nor household purposes, or (2) anything designed or sold for incorporation \ninto a dwelling.  In determining whether a product is a consumer product, \ndoubtful cases shall be resolved in favor of coverage.  For a particular \nproduct received by a particular user, \"normally used\" refers to a \ntypical or common use of that class of product, regardless of the status \nof the particular user or of the way in which the particular user \nactually uses, or expects or is expected to use, the product.  A product \nis a consumer product regardless of whether the product has substantial \ncommercial, industrial or non-consumer uses, unless such uses represent \nthe only significant mode of use of the product. \n \n  \"Installation Information\" for a User Product means any methods, \nprocedures, authorization keys, or other information required to install \nand execute modified versions of a covered work in that User Product from \na modified version of its Corresponding Source.  The information must \nsuffice to ensure that the continued functioning of the modified object \ncode is in no case prevented or interfered with solely because \nmodification has been made. \n \n  If you convey an object code work under this section in, or with, or \nspecifically for use in, a User Product, and the conveying occurs as \npart of a transaction in which the right of possession and use of the \nUser Product is transferred to the recipient in perpetuity or for a \nfixed term (regardless of how the transaction is characterized), the \nCorresponding Source conveyed under this section must be accompanied \nby the Installation Information.  But this requirement does not apply \nif neither you nor any third party retains the ability to install \nmodified object code on the User Product (for example, the work has \nbeen installed in ROM). \n \n  The requirement to provide Installation Information does not include a \nrequirement to continue to provide support service, warranty, or updates \nfor a work that has been modified or installed by the recipient, or for \nthe User Product in which it has been modified or installed.  Access to a \nnetwork may be denied when the modification itself materially and \nadversely affects the operation of the network or violates the rules and \nprotocols for communication across the network. \n \n  Corresponding Source conveyed, and Installation Information provided, \nin accord with this section must be in a format that is publicly \ndocumented (and with an implementation available to the public in \nsource code form), and must require no special password or key for \nunpacking, reading or copying. \n \n  7. Additional Terms. \n \n  \"Additional permissions\" are terms that supplement the terms of this \nLicense by making exceptions from one or more of its conditions. \nAdditional permissions that are applicable to the entire Program shall \nbe treated as though they were included in this License, to the extent \nthat they are valid under applicable law.  If additional permissions \napply only to part of the Program, that part may be used separately \nunder those permissions, but the entire Program remains governed by \nthis License without regard to the additional permissions. \n \n  When you convey a copy of a covered work, you may at your option \nremove any additional permissions from that copy, or from any part of \nit.  (Additional permissions may be written to require their own \nremoval in certain cases when you modify the work.)  You may place \nadditional permissions on material, added by you to a covered work, \nfor which you have or can give appropriate copyright permission. \n \n  Notwithstanding any other provision of this License, for material you \nadd to a covered work, you may (if authorized by the copyright holders of \nthat material) supplement the terms of this License with terms: \n \n    a) Disclaiming warranty or limiting liability differently from the \n    terms of sections 15 and 16 of this License; or \n \n    b) Requiring preservation of specified reasonable legal notices or \n    author attributions in that material or in the Appropriate Legal \n    Notices displayed by works containing it; or \n \n    c) Prohibiting misrepresentation of the origin of that material, or \n    requiring that modified versions of such material be marked in \n    reasonable ways as different from the original version; or \n \n    d) Limiting the use for publicity purposes of names of licensors or \n    authors of the material; or \n \n    e) Declining to grant rights under trademark law for use of some \n    trade names, trademarks, or service marks; or \n \n    f) Requiring indemnification of licensors and authors of that \n    material by anyone who conveys the material (or modified versions of \n    it) with contractual assumptions of liability to the recipient, for \n    any liability that these contractual assumptions directly impose on \n    those licensors and authors. \n \n  All other non-permissive additional terms are considered \"further \nrestrictions\" within the meaning of section 10.  If the Program as you \nreceived it, or any part of it, contains a notice stating that it is \ngoverned by this License along with a term that is a further \nrestriction, you may remove that term.  If a license document contains \na further restriction but permits relicensing or conveying under this \nLicense, you may add to a covered work material governed by the terms \nof that license document, provided that the further restriction does \nnot survive such relicensing or conveying. \n \n  If you add terms to a covered work in accord with this section, you \nmust place, in the relevant source files, a statement of the \nadditional terms that apply to those files, or a notice indicating \nwhere to find the applicable terms. \n \n  Additional terms, permissive or non-permissive, may be stated in the \nform of a separately written license, or stated as exceptions; \nthe above requirements apply either way. \n \n  8. Termination. \n \n  You may not propagate or modify a covered work except as expressly \nprovided under this License.  Any attempt otherwise to propagate or \nmodify it is void, and will automatically terminate your rights under \nthis License (including any patent licenses granted under the third \nparagraph of section 11). \n \n  However, if you cease all violation of this License, then your \nlicense from a particular copyright holder is reinstated (a) \nprovisionally, unless and until the copyright holder explicitly and \nfinally terminates your license, and (b) permanently, if the copyright \nholder fails to notify you of the violation by some reasonable means \nprior to 60 days after the cessation. \n \n  Moreover, your license from a particular copyright holder is \nreinstated permanently if the copyright holder notifies you of the \nviolation by some reasonable means, this is the first time you have \nreceived notice of violation of this License (for any work) from that \ncopyright holder, and you cure the violation prior to 30 days after \nyour receipt of the notice. \n \n  Termination of your rights under this section does not terminate the \nlicenses of parties who have received copies or rights from you under \nthis License.  If your rights have been terminated and not permanently \nreinstated, you do not qualify to receive new licenses for the same \nmaterial under section 10. \n \n  9. Acceptance Not Required for Having Copies. \n \n  You are not required to accept this License in order to receive or \nrun a copy of the Program.  Ancillary propagation of a covered work \noccurring solely as a consequence of using peer-to-peer transmission \nto receive a copy likewise does not require acceptance.  However, \nnothing other than this License grants you permission to propagate or \nmodify any covered work.  These actions infringe copyright if you do \nnot accept this License.  Therefore, by modifying or propagating a \ncovered work, you indicate your acceptance of this License to do so. \n \n  10. Automatic Licensing of Downstream Recipients. \n \n  Each time you convey a covered work, the recipient automatically \nreceives a license from the original licensors, to run, modify and \npropagate that work, subject to this License.  You are not responsible \nfor enforcing compliance by third parties with this License. \n \n  An \"entity transaction\" is a transaction transferring control of an \norganization, or substantially all assets of one, or subdividing an \norganization, or merging organizations.  If propagation of a covered \nwork results from an entity transaction, each party to that \ntransaction who receives a copy of the work also receives whatever \nlicenses to the work the party's predecessor in interest had or could \ngive under the previous paragraph, plus a right to possession of the \nCorresponding Source of the work from the predecessor in interest, if \nthe predecessor has it or can get it with reasonable efforts. \n \n  You may not impose any further restrictions on the exercise of the \nrights granted or affirmed under this License.  For example, you may \nnot impose a license fee, royalty, or other charge for exercise of \nrights granted under this License, and you may not initiate litigation \n(including a cross-claim or counterclaim in a lawsuit) alleging that \nany patent claim is infringed by making, using, selling, offering for \nsale, or importing the Program or any portion of it. \n \n  11. Patents. \n \n  A \"contributor\" is a copyright holder who authorizes use under this \nLicense of the Program or a work on which the Program is based.  The \nwork thus licensed is called the contributor's \"contributor version\". \n \n  A contributor's \"essential patent claims\" are all patent claims \nowned or controlled by the contributor, whether already acquired or \nhereafter acquired, that would be infringed by some manner, permitted \nby this License, of making, using, or selling its contributor version, \nbut do not include claims that would be infringed only as a \nconsequence of further modification of the contributor version.  For \npurposes of this definition, \"control\" includes the right to grant \npatent sublicenses in a manner consistent with the requirements of \nthis License. \n \n  Each contributor grants you a non-exclusive, worldwide, royalty-free \npatent license under the contributor's essential patent claims, to \nmake, use, sell, offer for sale, import and otherwise run, modify and \npropagate the contents of its contributor version. \n \n  In the following three paragraphs, a \"patent license\" is any express \nagreement or commitment, however denominated, not to enforce a patent \n(such as an express permission to practice a patent or covenant not to \nsue for patent infringement).  To \"grant\" such a patent license to a \nparty means to make such an agreement or commitment not to enforce a \npatent against the party. \n \n  If you convey a covered work, knowingly relying on a patent license, \nand the Corresponding Source of the work is not available for anyone \nto copy, free of charge and under the terms of this License, through a \npublicly available network server or other readily accessible means, \nthen you must either (1) cause the Corresponding Source to be so \navailable, or (2) arrange to deprive yourself of the benefit of the \npatent license for this particular work, or (3) arrange, in a manner \nconsistent with the requirements of this License, to extend the patent \nlicense to downstream recipients.  \"Knowingly relying\" means you have \nactual knowledge that, but for the patent license, your conveying the \ncovered work in a country, or your recipient's use of the covered work \nin a country, would infringe one or more identifiable patents in that \ncountry that you have reason to believe are valid. \n \n  If, pursuant to or in connection with a single transaction or \narrangement, you convey, or propagate by procuring conveyance of, a \ncovered work, and grant a patent license to some of the parties \nreceiving the covered work authorizing them to use, propagate, modify \nor convey a specific copy of the covered work, then the patent license \nyou grant is automatically extended to all recipients of the covered \nwork and works based on it. \n \n  A patent license is \"discriminatory\" if it does not include within \nthe scope of its coverage, prohibits the exercise of, or is \nconditioned on the non-exercise of one or more of the rights that are \nspecifically granted under this License.  You may not convey a covered \nwork if you are a party to an arrangement with a third party that is \nin the business of distributing software, under which you make payment \nto the third party based on the extent of your activity of conveying \nthe work, and under which the third party grants, to any of the \nparties who would receive the covered work from you, a discriminatory \npatent license (a) in connection with copies of the covered work \nconveyed by you (or copies made from those copies), or (b) primarily \nfor and in connection with specific products or compilations that \ncontain the covered work, unless you entered into that arrangement, \nor that patent license was granted, prior to 28 March 2007. \n \n  Nothing in this License shall be construed as excluding or limiting \nany implied license or other defenses to infringement that may \notherwise be available to you under applicable patent law. \n \n  12. No Surrender of Others' Freedom. \n \n  If conditions are imposed on you (whether by court order, agreement or \notherwise) that contradict the conditions of this License, they do not \nexcuse you from the conditions of this License.  If you cannot convey a \ncovered work so as to satisfy simultaneously your obligations under this \nLicense and any other pertinent obligations, then as a consequence you may \nnot convey it at all.  For example, if you agree to terms that obligate you \nto collect a royalty for further conveying from those to whom you convey \nthe Program, the only way you could satisfy both those terms and this \nLicense would be to refrain entirely from conveying the Program. \n \n  13. Use with the GNU Affero General Public License. \n \n  Notwithstanding any other provision of this License, you have \npermission to link or combine any covered work with a work licensed \nunder version 3 of the GNU Affero General Public License into a single \ncombined work, and to convey the resulting work.  The terms of this \nLicense will continue to apply to the part which is the covered work, \nbut the special requirements of the GNU Affero General Public License, \nsection 13, concerning interaction through a network will apply to the \ncombination as such. \n \n  14. Revised Versions of this License. \n \n  The Free Software Foundation may publish revised and/or new versions of \nthe GNU General Public License from time to time.  Such new versions will \nbe similar in spirit to the present version, but may differ in detail to \naddress new problems or concerns. \n \n  Each version is given a distinguishing version number.  If the \nProgram specifies that a certain numbered version of the GNU General \nPublic License \"or any later version\" applies to it, you have the \noption of following the terms and conditions either of that numbered \nversion or of any later version published by the Free Software \nFoundation.  If the Program does not specify a version number of the \nGNU General Public License, you may choose any version ever published \nby the Free Software Foundation. \n \n  If the Program specifies that a proxy can decide which future \nversions of the GNU General Public License can be used, that proxy's \npublic statement of acceptance of a version permanently authorizes you \nto choose that version for the Program. \n \n  Later license versions may give you additional or different \npermissions.  However, no additional obligations are imposed on any \nauthor or copyright holder as a result of your choosing to follow a \nlater version. \n \n  15. Disclaimer of Warranty. \n \n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY \nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT \nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY \nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, \nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR \nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM \nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF \nALL NECESSARY SERVICING, REPAIR OR CORRECTION. \n \n  16. Limitation of Liability. \n \n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING \nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS \nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY \nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE \nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF \nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD \nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), \nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF \nSUCH DAMAGES. \n \n  17. Interpretation of Sections 15 and 16. \n \n  If the disclaimer of warranty and limitation of liability provided \nabove cannot be given local legal effect according to their terms, \nreviewing courts shall apply local law that most closely approximates \nan absolute waiver of all civil liability in connection with the \nProgram, unless a warranty or assumption of liability accompanies a \ncopy of the Program in return for a fee. \n \n                     END OF TERMS AND CONDITIONS \n \n            How to Apply These Terms to Your New Programs \n \n  If you develop a new program, and you want it to be of the greatest \npossible use to the public, the best way to achieve this is to make it \nfree software which everyone can redistribute and change under these terms. \n \n  To do so, attach the following notices to the program.  It is safest \nto attach them to the start of each source file to most effectively \nstate the exclusion of warranty; and each file should have at least \nthe \"copyright\" line and a pointer to where the full notice is found. \n \n    <one line to give the program's name and a brief idea of what it does.> \n    Copyright (C) <year>  <name of author> \n \n    This program is free software: you can redistribute it and/or modify \n    it under the terms of the GNU General Public License as published by \n    the Free Software Foundation, either version 3 of the License, or \n    (at your option) any later version. \n \n    This program is distributed in the hope that it will be useful, \n    but WITHOUT ANY WARRANTY; without even the implied warranty of \n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \n    GNU General Public License for more details. \n \n    You should have received a copy of the GNU General Public License \n    along with this program.  If not, see <http://www.gnu.org/licenses/>. \n \nAlso add information on how to contact you by electronic and paper mail. \n \n  If the program does terminal interaction, make it output a short \nnotice like this when it starts in an interactive mode: \n \n    <program>  Copyright (C) <year>  <name of author> \n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. \n    This is free software, and you are welcome to redistribute it \n    under certain conditions; type `show c' for details. \n \nThe hypothetical commands `show w' and `show c' should show the appropriate \nparts of the General Public License.  Of course, your program's commands \nmight be different; for a GUI interface, you would use an \"about box\". \n \n  You should also get your employer (if you work as a programmer) or school, \nif any, to sign a \"copyright disclaimer\" for the program, if necessary. \nFor more information on this, and how to apply and follow the GNU GPL, see \n<http://www.gnu.org/licenses/>. \n \n  The GNU General Public License does not permit incorporating your program \ninto proprietary programs.  If your program is a subroutine library, you \nmay consider it more useful to permit linking proprietary applications with \nthe library.  If this is what you want to do, use the GNU Lesser General \nPublic License instead of this License.  But first, please read \n<http://www.gnu.org/philosophy/why-not-lgpl.html>. \n \n*/ \n",
            "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {FlashLoanReceiverBase} from '../../flashloan/base/FlashLoanReceiverBase.sol'; \nimport {MintableERC20} from '../tokens/MintableERC20.sol'; \nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \n \ncontract MockFlashLoanReceiver is FlashLoanReceiverBase { \n  using SafeERC20 for IERC20; \n \n  ILendingPoolAddressesProvider internal _provider; \n \n  event ExecutedWithFail(address[] _assets, uint256[] _amounts, uint256[] _premiums); \n  event ExecutedWithSuccess(address[] _assets, uint256[] _amounts, uint256[] _premiums); \n \n  bool _failExecution; \n  uint256 _amountToApprove; \n  bool _simulateEOA; \n \n  constructor(ILendingPoolAddressesProvider provider) public FlashLoanReceiverBase(provider) {} \n \n  function setFailExecutionTransfer(bool fail) public { \n    _failExecution = fail; \n  } \n \n  function setAmountToApprove(uint256 amountToApprove) public { \n    _amountToApprove = amountToApprove; \n  } \n \n  function setSimulateEOA(bool flag) public { \n    _simulateEOA = flag; \n  } \n \n  function amountToApprove() public view returns (uint256) { \n    return _amountToApprove; \n  } \n \n  function simulateEOA() public view returns (bool) { \n    return _simulateEOA; \n  } \n \n  function executeOperation( \n    address[] memory assets, \n    uint256[] memory amounts, \n    uint256[] memory premiums, \n    address initiator, \n    bytes memory params \n  ) public override returns (bool) { \n    params; \n    initiator; \n \n    if (_failExecution) { \n      emit ExecutedWithFail(assets, amounts, premiums); \n      return !_simulateEOA; \n    } \n \n    for (uint256 i = 0; i < assets.length; i++) { \n      //mint to this contract the specific amount \n      MintableERC20 token = MintableERC20(assets[i]); \n \n      //check the contract has the specified balance \n      require( \n        amounts[i] <= IERC20(assets[i]).balanceOf(address(this)), \n        'Invalid balance for the contract' \n      ); \n \n      uint256 amountToReturn = \n        (_amountToApprove != 0) ? _amountToApprove : amounts[i].add(premiums[i]); \n      //execution does not fail - mint tokens and return them to the _destination \n \n      token.mint(premiums[i]); \n \n      IERC20(assets[i]).approve(address(LENDING_POOL), amountToReturn); \n    } \n \n    emit ExecutedWithSuccess(assets, amounts, premiums); \n \n    return true; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IUniswapV2Router02} from '../../interfaces/IUniswapV2Router02.sol'; \nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; \nimport {MintableERC20} from '../tokens/MintableERC20.sol'; \n \ncontract MockUniswapV2Router02 is IUniswapV2Router02 { \n  mapping(address => uint256) internal _amountToReturn; \n  mapping(address => uint256) internal _amountToSwap; \n  mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsIn; \n  mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsOut; \n  uint256 internal defaultMockValue; \n \n  function setAmountToReturn(address reserve, uint256 amount) public { \n    _amountToReturn[reserve] = amount; \n  } \n \n  function setAmountToSwap(address reserve, uint256 amount) public { \n    _amountToSwap[reserve] = amount; \n  } \n \n  function swapExactTokensForTokens( \n    uint256 amountIn, \n    uint256, /* amountOutMin */ \n    address[] calldata path, \n    address to, \n    uint256 /* deadline */ \n  ) external override returns (uint256[] memory amounts) { \n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn); \n \n    MintableERC20(path[1]).mint(_amountToReturn[path[0]]); \n    IERC20(path[1]).transfer(to, _amountToReturn[path[0]]); \n \n    amounts = new uint256[](path.length); \n    amounts[0] = amountIn; \n    amounts[1] = _amountToReturn[path[0]]; \n  } \n \n  function swapTokensForExactTokens( \n    uint256 amountOut, \n    uint256, /* amountInMax */ \n    address[] calldata path, \n    address to, \n    uint256 /* deadline */ \n  ) external override returns (uint256[] memory amounts) { \n    IERC20(path[0]).transferFrom(msg.sender, address(this), _amountToSwap[path[0]]); \n \n    MintableERC20(path[1]).mint(amountOut); \n    IERC20(path[1]).transfer(to, amountOut); \n \n    amounts = new uint256[](path.length); \n    amounts[0] = _amountToSwap[path[0]]; \n    amounts[1] = amountOut; \n  } \n \n  function setAmountOut( \n    uint256 amountIn, \n    address reserveIn, \n    address reserveOut, \n    uint256 amountOut \n  ) public { \n    _amountsOut[reserveIn][reserveOut][amountIn] = amountOut; \n  } \n \n  function setAmountIn( \n    uint256 amountOut, \n    address reserveIn, \n    address reserveOut, \n    uint256 amountIn \n  ) public { \n    _amountsIn[reserveIn][reserveOut][amountOut] = amountIn; \n  } \n \n  function setDefaultMockValue(uint256 value) public { \n    defaultMockValue = value; \n  } \n \n  function getAmountsOut(uint256 amountIn, address[] calldata path) \n    external \n    view \n    override \n    returns (uint256[] memory) \n  { \n    uint256[] memory amounts = new uint256[](path.length); \n    amounts[0] = amountIn; \n    amounts[1] = _amountsOut[path[0]][path[1]][amountIn] > 0 \n      ? _amountsOut[path[0]][path[1]][amountIn] \n      : defaultMockValue; \n    return amounts; \n  } \n \n  function getAmountsIn(uint256 amountOut, address[] calldata path) \n    external \n    view \n    override \n    returns (uint256[] memory) \n  { \n    uint256[] memory amounts = new uint256[](path.length); \n    amounts[0] = _amountsIn[path[0]][path[1]][amountOut] > 0 \n      ? _amountsIn[path[0]][path[1]][amountOut] \n      : defaultMockValue; \n    amounts[1] = amountOut; \n    return amounts; \n  } \n} \n",
            "pragma solidity 0.6.12; \n \ncontract MockAggregator { \n  int256 private _latestAnswer; \n \n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n \n  constructor(int256 _initialAnswer) public { \n    _latestAnswer = _initialAnswer; \n    emit AnswerUpdated(_initialAnswer, 0, now); \n  } \n \n  function latestAnswer() external view returns (int256) { \n    return _latestAnswer; \n  } \n \n  function getTokenType() external view returns (uint256) { \n    return 1; \n  } \n \n  // function getSubTokens() external view returns (address[] memory) { \n  // TODO: implement mock for when multiple subtokens. Maybe we need to create diff mock contract \n  // to call it from the migration for this case?? \n  // } \n} \n",
            "pragma solidity 0.6.12; \n \nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol'; \n \ncontract PriceOracle is IPriceOracle { \n  mapping(address => uint256) prices; \n  uint256 ethPriceUsd; \n \n  event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp); \n  event EthPriceUpdated(uint256 _price, uint256 timestamp); \n \n  function getAssetPrice(address _asset) external view override returns (uint256) { \n    return prices[_asset]; \n  } \n \n  function setAssetPrice(address _asset, uint256 _price) external override { \n    prices[_asset] = _price; \n    emit AssetPriceUpdated(_asset, _price, block.timestamp); \n  } \n \n  function getEthUsdPrice() external view returns (uint256) { \n    return ethPriceUsd; \n  } \n \n  function setEthUsdPrice(uint256 _price) external { \n    ethPriceUsd = _price; \n    emit EthPriceUpdated(_price, block.timestamp); \n  } \n} \n",
            "pragma solidity 0.6.12; \n \ninterface ChainlinkUSDETHOracleI { \n  event AnswerUpdated(int256 indexed current, uint256 indexed answerId); \n} \n",
            "pragma solidity 0.6.12; \n \ninterface IExtendedPriceAggregator { \n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n \n  function getToken() external view returns (address); \n \n  function getTokenType() external view returns (uint256); \n \n  function getPlatformId() external view returns (uint256); \n \n  function getSubTokens() external view returns (address[] memory); \n \n  function latestAnswer() external view returns (int256); \n} \n",
            "pragma solidity 0.6.12; \n \nimport {ILendingRateOracle} from '../../interfaces/ILendingRateOracle.sol'; \nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol'; \n \ncontract LendingRateOracle is ILendingRateOracle, Ownable { \n  mapping(address => uint256) borrowRates; \n  mapping(address => uint256) liquidityRates; \n  function getMarketBorrowRate(address _asset) external view override returns (uint256) {\n    return borrowRates[_asset];\n  }\n  function setMarketBorrowRate(address _asset, uint256 _rate) external override onlyOwner {\n    borrowRates[_asset] = _rate;\n  }\n  function getMarketLiquidityRate(address _asset) external view returns (uint256) {\n    return liquidityRates[_asset];\n  }\n  function setMarketLiquidityRate(address _asset, uint256 _rate) external onlyOwner {\n    liquidityRates[_asset] = _rate;\n  }\n}\n",
            "pragma solidity 0.6.12;\n  interface GenericOracleI {\n    // ganache\n    event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp);\n    event EthPriceUpdated(uint256 _price, uint256 timestamp);\n    // kovan\n    event ProphecySubmitted(\n    address indexed _sybil,\n    address indexed _asset,\n    uint96 _sybilProphecy,\n    uint96 _oracleProphecy\n  );\n  function getAssetPrice(address _asset) external view returns (uint256);\n  function getEthUsdPrice() external view returns (uint256);\n}\n",
            "pragma solidity 0.6.12; \n \ninterface GenericOracleI { \n  // ganache \n  event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp); \n  event EthPriceUpdated(uint256 _price, uint256 timestamp); \n \n  // kovan \n  event ProphecySubmitted( \n    address indexed _sybil, \n    address indexed _asset, \n    uint96 _sybilProphecy, \n    uint96 _oracleProphecy \n  ); \n \n  function getAssetPrice(address _asset) external view returns (uint256); \n \n  function getEthUsdPrice() external view returns (uint256); \n} \n \nAnalysis of audit results\nRe-Entrancy\nArithmetic Over/Under Flows\n"
        ]
    },
    {
        "PdfName": "Balincer Token (BLCR)_audit.pdf",
        "Code": [
            "pragma solidity ^0.5.17; \n// pragma experimental ABIEncoderV2; \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * SafeMath restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \n \nlibrary SafeMath { \n    function trx(uint256 a) internal pure returns (uint256) { \n        assert(a > 0); \n        uint256 c = a * 1000000; \n        assert(a == 0 || c / a == 1000000); \n        return c; \n    } \n \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a * b; \n        assert(a == 0 || c / a == b); \n        return c; \n    } \n \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        // assert(b > 0); // Solidity automatically throws when dividing by 0 \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n        return c; \n    } \n \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        assert(b <= a); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's - operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        assert(c >= a); \n        return c; \n    } \n \n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) { \n        return ((a + m - 1) / m) * m; \n    } \n \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b != 0, \"mod zero\"); \n        return a % b; \n    } \n \n    function min(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a > b ? b : a; \n    } \n \n    function sq(uint256 x) internal pure returns (uint256) \n    { \n        return (mul(x, x)); \n    } \n \n    function sqrt(uint256 x) internal pure returns (uint256 y) \n    { \n        uint256 z = ((add(x, 1)) / 2); \n        y = x; \n        while (z < y) \n        { \n            y = z; \n            z = ((add((x / z), z)) / 2); \n        } \n    } \n \n    function pwr(uint256 x, uint256 y) internal pure returns (uint256) \n    { \n        if (x == 0) return (0); \n        else if (y == 0) return (1); \n        else { \n            uint256 z = x; \n            for (uint256 i = 1; i < y; i++) z = mul(z, x); \n            return (z); \n        } \n    } \n} \n \ncontract BalincerToken { \n    /// @notice EIP-20 token name for this token \n    string public constant name = \"Balincer Token\"; \n    /// @notice EIP-20 token symbol for this token \n    string public constant symbol = \"BLCR\"; \n    /// @notice EIP-20 token decimals for this token \n    uint8 public constant decimals = 18; \n    /// @notice Total number of tokens in circulation \n    uint256 public totalSupply = 100_000_000e18; \n    /// @notice Allowance amounts on behalf of others \n    mapping(address => mapping(address => uint96)) internal allowances; \n    /// @notice Official record of token balances for each account \n    mapping(address => uint96) internal balances; \n    /// @notice A record of each accounts delegate \n    mapping(address => address) public delegates; \n    /// @notice A checkpoint for marking number of votes from a given block \n    struct Checkpoint { \n        uint32 fromBlock; \n        uint96 votes; \n    } \n    /// @notice A record of votes checkpoints for each account, by index \n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints; \n    /// @notice The number of checkpoints for each account \n    mapping(address => uint32) public numCheckpoints; \n    /// @notice The EIP-712 typehash for the contract's domain \n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,add\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract \n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 non\n    /// @notice The EIP-712 typehash for the permit struct used by the contract \n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 \n    /// @notice A record of states for signing / validating signatures \n    mapping(address => uint256) public nonces; \n    /// @notice An event thats emitted when an account changes its delegate \n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed to\n    /// @notice An event thats emitted when a delegate account's vote balance changes \n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance)\n    /// @notice The standard EIP-20 transfer event \n    event Transfer(address indexed from, address indexed to, uint256 amount); \n    /// @notice The standard EIP-20 approval event \n    event Approval(address indexed owner, address indexed spender, uint256 amount); \n    /** \n     * @notice Construct a new Ba token \n     * @param account The initial account to grant all the tokens \n     */ \n    constructor(address account) public { \n        balances[account] = uint96(totalSupply); \n        emit Transfer(address(0), account, totalSupply); \n    } \n    /** \n     * @notice Get the number of tokens spender is approved to spend on behalf of account \n     * @param account The address of the account holding the funds \n     * @param spender The address of the account spending the funds \n     * @return The number of tokens approved \n     */ \n    function allowance(address account, address spender) external view returns (uint256) { \n        return allowances[account][spender]; \n    } \n \n    /** \n     * @notice Approve spender to transfer up to amount from src \n     * @dev This will overwrite the approval amount for spender \n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) \n     * @param spender The address of the account which may transfer tokens \n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite) \n     * @return Whether or not the approval succeeded \n     */ \n    function approve(address spender, uint256 rawAmount) external returns (bool) { \n        uint96 amount; \n        if (rawAmount == uint256(-1)) { \n            amount = uint96(-1); \n        } else { \n            amount = safe96(rawAmount, \"Ba::approve: amount exceeds 96 bits\"); \n        } \n        allowances[msg.sender][spender] = amount; \n        emit Approval(msg.sender, spender, amount); \n        return true; \n    } \n \n    /** \n     * @notice Triggers an approval from owner to spends \n     * @param owner The address to approve from \n     * @param spender The address to be approved \n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite) \n     * @param deadline The time at which to expire the signature \n     * @param v The recovery byte of the signature \n     * @param r Half of the ECDSA signature pair \n     * @param s Half of the ECDSA signature pair \n     */ \n    function permit(address owner, address spender, uint256 rawAmount, uint256 deadline, uint8 v, byt\n        uint96 amount; \n        if (rawAmount == uint256(-1)) { \n            amount = uint96(-1); \n        } else { \n            amount = safe96(rawAmount, \"Ba::permit: amount exceeds 96 bits\"); \n        } \n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getCh\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)); \n        address signatory = ecrecover(digest, v, r, s); \n        require(signatory != address(0), \"Ba::permit: invalid signature\"); \n        require(signatory == owner, \"Ba::permit: unauthorized\"); \n        require(now <= deadline, \"Ba::permit: signature expired\"); \n        allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @notice Get the number of tokens held by the account \n     * @param account The address of the account to get the balance of \n     * @return The number of tokens held \n     */ \n    function balanceOf(address account) external view returns (uint256) { \n        return balances[account]; \n    } \n \n    /** \n     * @notice Transfer amount tokens from msg.sender to dst \n     * @param dst The address of the destination account \n     * @param rawAmount The number of tokens to transfer \n     * @return Whether or not the transfer succeeded \n     */ \n    function transfer(address dst, uint256 rawAmount) external returns (bool) { \n        uint96 amount = safe96(rawAmount, \"Ba::transfer: amount exceeds 96 bits\"); \n        _transferTokens(msg.sender, dst, amount); \n        return true; \n    } \n \n    /** \n     * @notice Transfer amount tokens from src to dst \n     * @param src The address of the source account \n     * @param dst The address of the destination account \n     * @param rawAmount The number of tokens to transfer \n     * @return Whether or not the transfer succeeded \n     */ \n    function transferFrom(address src, address dst, uint256 rawAmount) external returns (bool) { \n        address spender = msg.sender; \n        uint96 spenderAllowance = allowances[src][spender]; \n        uint96 amount = safe96(rawAmount, \"Ba::approve: amount exceeds 96 bits\"); \n        if (spender != src && spenderAllowance != uint96(-1)) { \n            uint96 newAllowance = sub96(spenderAllowance, amount, \"Ba::transferFrom: transfer amount \n            allowances[src][spender] = newAllowance; \n            emit Approval(src, spender, newAllowance); \n        } \n        _transferTokens(src, dst, amount); \n        return true; \n    } \n \n    /** \n     * @notice Delegate votes from msg.sender to delegatee \n     * @param delegatee The address to delegate votes to \n     */ \n    function delegate(address delegatee) public { \n        return _delegate(msg.sender, delegatee); \n    } \n \n    /** \n     * @notice Delegates votes from signatory to delegatee \n     * @param delegatee The address to delegate votes to \n     * @param nonce The contract state required to match the signature \n     * @param expiry The time at which to expire the signature \n     * @param v The recovery byte of the signature \n     * @param r Half of the ECDSA signature pair \n     * @param s Half of the ECDSA signature pair \n     */ \n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, byte\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getCh\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)); \n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)); \n        address signatory = ecrecover(digest, v, r, s); \n        require(signatory != address(0), \"Ba::delegateBySig: invalid signature\"); \n        require(nonce == nonces[signatory]++, \"Ba::delegateBySig: invalid nonce\"); \n        require(now <= expiry, \"Ba::delegateBySig: signature expired\"); \n        return _delegate(signatory, delegatee); \n    } \n \n    /** \n     * @notice Gets the current votes balance for account \n     * @param account The address to get votes balance \n     * @return The number of current votes for account \n     */ \n    function getCurrentVotes(address account) external view returns (uint96) { \n        uint32 nCheckpoints = numCheckpoints[account]; \n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0; \n    } \n \n    /** \n     * @notice Determine the prior number of votes for an account as of a block number \n     * @dev Block number must be a finalized block or else this function will revert to prevent misin\n     * @param account The address of the account to check \n     * @param blockNumber The block number to get the vote balance at \n     * @return The number of votes the account had as of the given block \n     */ \n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) { \n        require(blockNumber < block.number, \"Ba::getPriorVotes: not yet determined\"); \n        uint32 nCheckpoints = numCheckpoints[account]; \n        if (nCheckpoints == 0) {return 0;} \n        // First check most recent balance \n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) { return checkpoints[acc\n        // Next check implicit zero balance \n        if (checkpoints[account][0].fromBlock > blockNumber) { return 0;} \n        uint32 lower = 0; \n        uint32 upper = nCheckpoints - 1; \n        while (upper > lower) { \n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow \n            Checkpoint memory cp = checkpoints[account][center]; \n            if (cp.fromBlock == blockNumber) { \n                return cp.votes; \n            } else if (cp.fromBlock < blockNumber) { \n                lower = center; \n            } else { \n                upper = center - 1; \n            } \n        } \n        return checkpoints[account][lower].votes; \n    } \n \n    function _delegate(address delegator, address delegatee) internal { \n        address currentDelegate = delegates[delegator]; \n        uint96 delegatorBalance = balances[delegator]; \n        delegates[delegator] = delegatee; \n        emit DelegateChanged(delegator, currentDelegate, delegatee); \n        _moveDelegates(currentDelegate, delegatee, delegatorBalance); \n    } \n \n    function _transferTokens(address src, address dst, uint96 amount) internal { \n        require(src != address(0), \"Ba::_transferTokens: cannot transfer from the zero address\"); \n        require(dst != address(0), \"Ba::_transferTokens: cannot transfer to the zero address\"); \n        balances[src] = sub96(balances[src], amount, \"Ba::_transferTokens: transfer amount exceeds ba\n        balances[dst] = add96(balances[dst], amount, \"Ba::_transferTokens: transfer amount overflows\"\n        emit Transfer(src, dst, amount); \n        _moveDelegates(delegates[src], delegates[dst], amount); \n    } \n \n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal { \n        if (srcRep != dstRep && amount > 0) { \n            if (srcRep != address(0)) { \n                uint32 srcRepNum = numCheckpoints[srcRep]; \n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0; \n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Ba::_moveVotes: vote amount underflows\" \n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew); \n            } \n \n            if (dstRep != address(0)) { \n                uint32 dstRepNum = numCheckpoints[dstRep]; \n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0; \n                uint96 dstRepNew = add96(dstRepOld, amount, \"Ba::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew); \n            } \n        } \n    } \n \n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVote\n        uint32 blockNumber = safe32(block.number, \"Ba::_writeCheckpoint: block number exceeds 32 bits\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) { \n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes; \n        } else { \n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes); \n            numCheckpoints[delegatee] = nCheckpoints + 1; \n        } \n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes); \n    } \n \n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) { \n        require(n < 2**32, errorMessage); \n        return uint32(n); \n    } \n \n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) { \n        require(n < 2**96, errorMessage); \n        return uint96(n); \n"
        ]
    },
    {
        "PdfName": "BIB META NFT_audit.pdf",
        "Code": [
            "pragma solidity >=0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/utils/Address.sol\"; \nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol'; \nimport {SafeMath} from \"../libs/SafeMath.sol\"; \nimport {SafeCast} from \"../libs/SafeCast.sol\"; \nimport {IComposedSoccerStarNft} from \"../interfaces/IComposedSoccerStarNft.sol\"; \nimport {ISoccerStarNft} from \"../interfaces/ISoccerStarNft.sol\"; \n \ncontract ComposedSoccerStarNft is IComposedSoccerStarNft, Ownable { \n    using SafeMath for uint; \n \n    address constant public BLOCK_HOLE = address(0x0000000000000000000000000000000000000001); \n \n    ISoccerStarNft public tokenContract; \n    IERC20 public bibContract; \n    IERC20 public busdContract; \n    IUniswapV2Router02 public router; \n \n    // fill with default \n    uint[12] public feeRates = [360000,  730000,    1200000, 2200000, \n                      1800000, 3650000,   6000000, 11000000, \n                      9000000, 18250000,  30000000, 55000000]; \n \n    address public treasury; \n \n    uint constant public MAX_STARLEVEL = 4; \n    uint constant public STARLEVEL_RANGE = 4; \n    uint constant public ORACLE_PRECISION = 1e18; \n \n    event TokenContractChanged(address sender, address oldValue, address newValue); \n    event BIBContractChanged(address sender, address oldValue, address newValue); \n    event BUSDContractChanged(address sender, address oldValue, address newValue); \n    event TreasuryChanged(address sender, address oldValue, address newValue); \n    event SwapRouterChanged(address sender, address oldValue, address newValue); \n    event FeeRateChanged(address sender, uint[12] oldValue, uint[12] newValue); \n \n    constructor( \n    address _tokenContract, \n    address _bibContract, \n    address _busdContract, \n    address _treasury, \n    address _router \n    ){ \n        tokenContract = ISoccerStarNft(_tokenContract); \n        bibContract = IERC20(_bibContract); \n        busdContract = IERC20(_busdContract); \n        treasury = _treasury; \n        router = IUniswapV2Router02(_router); \n    } \n \n    function setTokenContract(address _tokenContract) public onlyOwner{ \n        require(address(0) != _tokenContract, \"INVLID_ADDRESS\"); \n        emit TokenContractChanged(msg.sender, address(tokenContract), _tokenContract); \n        tokenContract = ISoccerStarNft(_tokenContract); \n    } \n \n    function setBIBContract(address _bibContract) public onlyOwner{ \n        require(address(0) != _bibContract, \"INVLID_ADDRESS\"); \n        emit BIBContractChanged(msg.sender, address(bibContract), _bibContract); \n        bibContract = IERC20(_bibContract); \n    } \n \n    function setTreasury(address _treasury) public onlyOwner{ \n        require(address(0) != _treasury, \"INVLID_ADDRESS\"); \n        emit TreasuryChanged(msg.sender, treasury, _treasury); \n        treasury = _treasury; \n    } \n \n    function setSwapRouter(address _router) public onlyOwner{ \n        require(address(0) != _router, \"INVLID_ADDRESS\"); \n        emit SwapRouterChanged(msg.sender, address(router), _router); \n        router = IUniswapV2Router02(_router); \n    } \n \n    function setBUSDContract(address _busdContract) public onlyOwner{ \n        require(address(0) != _busdContract, \"INVLID_ADDRESS\"); \n        emit BUSDContractChanged(msg.sender, address(busdContract), _busdContract); \n        busdContract = IERC20(_busdContract); \n    } \n \n    function configFeeRate(uint[12] memory _feeRates) public onlyOwner{ \n        require(_feeRates.length == feeRates.length, \"INVLID_FEERATES\"); \n        emit FeeRateChanged(msg.sender, feeRates, _feeRates); \n        for(uint i = 0; i < _feeRates.length; i++){ \n            feeRates[i] = _feeRates[i]; \n        } \n    } \n \n    function compose( \n    uint[] memory tokenIds, \n    ComposeMode mode,  \n    uint extralToken,  \n    PayMethod payMethod \n    ) public override{ \n        require(4 == tokenIds.length, \"NEED_FOUR_TOKENS\"); \n        require(validToken(tokenIds[0], tokenIds), \"NEED_SAME_TOKEN_PROPER\"); \n        require(validStarLevel(tokenIds[0]), \"NEED_LOWER_STARLEVEL\"); \n \n        // valid owner ship \n        validOwnership(tokenIds); \n \n        // burn all \n        for(uint i = 0; i < tokenIds.length; i++){ \n            IERC721(address(tokenContract)).transferFrom(msg.sender, BLOCK_HOLE, tokenIds[i]); \n        } \n \n        // compose new \n        ISoccerStarNft.SoccerStar memory soccerStar = tokenContract.getCardProperty(tokenIds[0]); \n \n        uint payAmount = 0; \n        if(ComposeMode.COMPOSE_NORMAL == mode) { \n            require(msg.sender == IERC721(address(tokenContract)).ownerOf(extralToken), \"TOKEN_NOT_BE\n            // burn the extral \n            IERC721(address(tokenContract)).transferFrom(msg.sender, BLOCK_HOLE, extralToken); \n        } else { \n            payAmount = caculateBurnAmount(soccerStar.starLevel, soccerStar.gradient); \n            if(PayMethod.PAY_BIB == payMethod){ \n                bibContract.transferFrom(msg.sender, BLOCK_HOLE, payAmount); \n            } else { \n                payAmount = caculateBUSDAmount(payAmount); \n                busdContract.transferFrom(msg.sender, treasury, payAmount); \n            } \n        } \n \n        uint newToken = tokenContract.protocolMint(); \n        tokenContract.protocolBind(newToken, soccerStar); \n        IERC721(address(tokenContract)).transferFrom(address(this), msg.sender, newToken); \n        emit Composed(msg.sender, tokenIds, extralToken,newToken, mode, payMethod, payAmount); \n    } \n \n    function caculateBurnAmount(uint starLevel, uint gradient) public view returns(uint){ \n        uint decimals = IERC20Metadata(address(bibContract)).decimals(); \n        return feeRates[(starLevel - 1) * STARLEVEL_RANGE + (gradient - 1)].exp(decimals); \n    } \n \n    function caculateBUSDAmount(uint bibAmount) public view returns(uint){ \n        // the price has ORACLE_PRECISION \n        address[] memory path = new address[](2); \n        path[0] = address(bibContract); \n        path[1] = address(busdContract); \n        return router.getAmountsOut(bibAmount, path)[1]; \n    } \n \n    function validOwnership(uint[] memory tokensToValid) internal view { \n        for(uint i = 0; i < tokensToValid.length; i++){ \n            require(msg.sender == IERC721(address(tokenContract)).ownerOf(tokensToValid[i]), \"TOKEN_N\n        } \n    } \n \n    function validStarLevel(uint tokenId) internal view returns(bool){ \n        return tokenContract.getCardProperty(tokenId).starLevel < MAX_STARLEVEL; \n    } \n \n    function validToken(uint base, uint[] memory tokensToValid) internal view returns(bool){ \n        if(0 == tokensToValid.length){ \n            return false; \n        } \n \n        ISoccerStarNft.SoccerStar memory baseProperty = tokenContract.getCardProperty(base); \n        for(uint i = 0; i < tokensToValid.length; i++){ \n            if(!cmpProperty(baseProperty, tokenContract.getCardProperty(tokensToValid[i]))){ \n                return false; \n            } \n        } \n        return true; \n    } \n \n    function cmpProperty ( \n    ISoccerStarNft.SoccerStar memory a,  \n    ISoccerStarNft.SoccerStar memory b) internal pure returns(bool){ \n        return keccak256(bytes(a.name)) == keccak256(bytes(b.name)) \n        && keccak256(bytes(a.country)) == keccak256(bytes(b.country)) \n        && keccak256(bytes(a.position)) == keccak256(bytes(b.position)) \n        && a.gradient == b.gradient; \n    } \n} \n \n \n \n//SPDX-License-Identifier: MIT \n \n",
            "pragma solidity >=0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/utils/Address.sol\"; \nimport {SafeMath} from \"../libs/SafeMath.sol\"; \nimport {SafeCast} from \"../libs/SafeCast.sol\"; \nimport {ISoccerStarNft} from \"../interfaces/ISoccerStarNft.sol\"; \nimport {ISoccerStarNftMarket} from \"../interfaces/ISoccerStarNftMarket.sol\"; \nimport {IFeeCollector} from \"../interfaces/IFeeCollector.sol\"; \n \ncontract SoccerStarNftMarket is ISoccerStarNftMarket, Ownable{ \n    using SafeMath for uint; \n \n    address public treasury; \n \n    IERC20 public bibContract; \n    IERC20 public busdContract; \n    ISoccerStarNft public tokenContract; \n    IFeeCollector feeCollector; \n \n    event TokenContractChanged(address sender, address oldValue, address newValue); \n    event BIBContractChanged(address sender, address oldValue, address newValue); \n    event BUSDContractChanged(address sender, address oldValue, address newValue); \n    event FeeRatioChanged(address sender, uint oldValue, uint newValue); \n    event RoyaltyRatioChanged(address sender, uint oldValue, uint newValue); \n    event FeeCollectorChanged(address sender, address oldValue, address newValue); \n \n    uint public nextOrderIndex; \n    uint public nextOfferIndex; \n \n    uint public feeRatio = 25; \n    uint public royaltyRatio = 75; \n    uint public constant FEE_RATIO_DIV = 1000; \n \n    // orders in the market \n    uint[] public orders; \n    // fast index from order id to order \n    mapping(uint=>Order) public orderTb; \n    // orders belong to the specfic owner \n    mapping(address=>uint[]) public userOrderTb; \n    //  offers of the order \n    mapping(uint=>uint[]) public orderOfferTb; \n    // fast index from offer id to offer \n    mapping(uint=>Offer) public offerTb; \n \n    constructor( \n    address _treasury, \n    address _tokenContract, \n    address _bibContract, \n    address _busdContract \n    ){ \n        treasury = _treasury; \n        tokenContract = ISoccerStarNft(_tokenContract); \n        bibContract = IERC20(_bibContract); \n        busdContract = IERC20(_busdContract); \n    } \n \n    function getBlockTime() public override view returns(uint){ \n        return block.timestamp; \n    } \n \n    function setTokenContract(address _tokenContract) public onlyOwner{ \n        require(address(0) != _tokenContract, \"INVALID_ADDRESS\"); \n        emit TokenContractChanged(msg.sender, address(tokenContract), _tokenContract); \n        tokenContract = ISoccerStarNft(_tokenContract); \n    } \n \n    function setBIBContract(address _bibContract) public onlyOwner{ \n        require(address(0) != _bibContract, \"INVALID_ADDRESS\"); \n        emit BIBContractChanged(msg.sender, address(bibContract), _bibContract); \n        bibContract = IERC20(_bibContract); \n    } \n \n    function setBUSDContract(address _busdContract) public onlyOwner{ \n        require(address(0) != _busdContract, \"INVALID_ADDRESS\"); \n        emit BUSDContractChanged(msg.sender, address(busdContract), _busdContract); \n        busdContract = IERC20(_busdContract); \n    } \n \n    function setFeeCollector(address _feeCollector) public onlyOwner{ \n        require(address(0) != _feeCollector, \"INVALID_ADDRESS\"); \n        emit FeeCollectorChanged(msg.sender, address(feeCollector), _feeCollector); \n        feeCollector = IFeeCollector(_feeCollector); \n    } \n \n    function setFeeRatio(uint _feeRatio) public override onlyOwner{ \n        require(_feeRatio <= FEE_RATIO_DIV, \"INVALID_RATIO\"); \n        emit FeeRatioChanged(msg.sender,feeRatio, _feeRatio); \n        feeRatio = _feeRatio; \n    } \n \n   function setRoyaltyRatio(uint _royaltyRatio) override public onlyOwner { \n       require(_royaltyRatio <= FEE_RATIO_DIV, \"INVALID_ROYALTY_RATIO\"); \n       emit RoyaltyRatioChanged(msg.sender, royaltyRatio, _royaltyRatio); \n       royaltyRatio = _royaltyRatio; \n   } \n \n    // user create a order \n    function openOrder(address issuer, uint tokenId, PayMethod payMethod, uint price, uint expiration\n        require(address(0) != issuer, \"INVALID_ISSURE\"); \n        require(expiration > block.timestamp, \"EXPIRATION_TOO_SMALL\"); \n        require(price > 0, \"PRICE_NOT_BE_ZEROR\"); \n        require(msg.sender == IERC721(address(issuer)).ownerOf(tokenId),  \n        \"TOKEN_NOT_BELLONG_TO_SENDER\"); \n \n        // delegate token to protocol \n        IERC721(address(issuer)).transferFrom(msg.sender, address(this), tokenId); \n \n        // record order \n        Order memory order = Order({ \n            issuer: issuer, \n            orderId: nextOrderIndex++, \n            tokenId: tokenId, \n            owner: msg.sender, \n            payMethod: payMethod, \n            price: price, \n            expiration: expiration \n        }); \n \n        orders.push(order.orderId); \n        userOrderTb[msg.sender].push(order.orderId); \n        orderTb[order.orderId] = order; \n \n        emit OpenOrder(issuer, msg.sender, order.orderId, tokenId, payMethod, price, expiration); \n    } \n \n    // get orders by page \n    function getUserOrdersByPage(address user, uint pageSt, uint pageSz)  \n    public view override returns(Order[] memory){ \n        uint[] storage _orders= userOrderTb[user]; \n        Order[] memory ret; \n \n        if(pageSt < _orders.length){ \n            uint end = pageSt + pageSz; \n            end = end > _orders.length ? _orders.length : end; \n            ret =  new Order[](end - pageSt); \n            for(uint i = 0;pageSt < end; i++){ \n                ret[i] = orderTb[_orders[pageSt]]; \n                pageSt++; \n            }  \n        } \n \n        return ret; \n    } \n \n    function getOrdersByPage(uint pageSt, uint pageSz)  \n    public view override returns(Order[] memory){ \n        Order[] memory ret; \n \n        if(pageSt < orders.length){ \n            uint end = pageSt + pageSz; \n            end = end > orders.length ? orders.length : end; \n            ret =  new Order[](end - pageSt); \n            for(uint i = 0;pageSt < end; i++){ \n                ret[i] = orderTb[orders[pageSt]]; \n                pageSt++; \n            }  \n        } \n \n        return ret; \n    } \n \n    function getOrderOffersByPage(uint orderId, uint pageSt, uint pageSz)  \n    public view  override returns(Offer[] memory){ \n        uint[] storage offers = orderOfferTb[orderId]; \n        Offer[] memory ret; \n \n        if(pageSt < offers.length){ \n            uint end = pageSt + pageSz; \n            end = end > offers.length ? offers.length : end; \n            ret =  new Offer[](end - pageSt); \n            for(uint i = 0;pageSt < end; i++){ \n                ret[i] = offerTb[offers[pageSt]]; \n                pageSt++; \n            }  \n        } \n \n        return ret; \n    } \n \n    function caculateFees(uint amount) view public returns(uint, uint ){ \n        // caculate owner fee + taker fee \n        return (amount.mul(feeRatio).div(FEE_RATIO_DIV), amount.mul(royaltyRatio).div(FEE_RATIO_DIV))\n    } \n \n    // Owner accept the price \n    function collectFeeWhenBuyerAsMaker(PayMethod payMethod, uint fees) internal { \n        if(payMethod == PayMethod.PAY_BNB) { \n            if(address(0) != address(feeCollector)) { \n                payable(address(feeCollector)).transfer(fees); \n                feeCollector.handleCollectBNB(fees); \n            } else { \n                payable(address(treasury)).transfer(fees); \n            } \n        } else if(payMethod == PayMethod.PAY_BUSD) { \n            if(address(0) != address(feeCollector)) { \n                busdContract.transfer(address(feeCollector), fees); \n                feeCollector.handleCollectBUSD(fees); \n            } else { \n                busdContract.transfer(treasury, fees); \n            } \n        } else { \n            if(address(0) != address(feeCollector)) { \n                bibContract.transfer(address(feeCollector), fees); \n                feeCollector.handleCollectBIB(fees); \n            } else { \n                bibContract.transfer(treasury, fees); \n            } \n        } \n    } \n \n    // Buyer accept the price \n    function collectFeeWhenSellerAsMaker(PayMethod payMethod, uint fees) internal { \n        if(payMethod == PayMethod.PAY_BNB) { \n            if(address(0) != address(feeCollector)) { \n                payable(address(feeCollector)).transfer(fees); \n                feeCollector.handleCollectBNB(fees); \n            } else { \n                payable(address(treasury)).transfer(fees); \n            } \n        } else if(payMethod == PayMethod.PAY_BUSD) { \n            if(address(0) != address(feeCollector)) { \n                busdContract.transferFrom(msg.sender, address(feeCollector), fees); \n                feeCollector.handleCollectBUSD(fees); \n            } else { \n                busdContract.transferFrom(msg.sender, treasury, fees); \n            } \n        } else { \n            if(address(0) != address(feeCollector)) { \n                bibContract.transferFrom(msg.sender, address(feeCollector), fees); \n                feeCollector.handleCollectBIB(fees); \n            } else { \n                bibContract.transferFrom(msg.sender, treasury, fees); \n            } \n        } \n    } \n \n    // Buyer accept the price and makes a deal with the sepcific order \n    function acceptOffer(uint orderId) public  override payable { \n        Order storage order = orderTb[orderId]; \n        require(address(0) != order.issuer,\"INVALID_ORDER\"); \n        require(msg.sender != order.owner, \"SHOULD_NOT_BE_ORDER_OWNER\"); \n        require(order.expiration > block.timestamp, \"ORDER_EXPIRED\"); \n \n        // caculate fees \n        (uint txFee, uint royaltyFee )= caculateFees(order.price); \n        uint fees = txFee.add(royaltyFee); \n        uint amount = order.price.sub(txFee).sub(fees); \n \n        // fee + royalty goese to BIB treasury \n        if(order.payMethod == PayMethod.PAY_BNB){ \n            require(msg.value >= order.price, \"INSUFFICIENT_FUNDS\"); \n            payable(address(order.owner)).transfer(amount); \n \n            collectFeeWhenSellerAsMaker(PayMethod.PAY_BNB, fees); \n \n            // refunds \n            if(msg.value > order.price){ \n                payable(address(msg.sender)).transfer(msg.value.sub(order.price)); \n            } \n        } else if(order.payMethod == PayMethod.PAY_BUSD){ \n            busdContract.transferFrom(msg.sender, order.owner, amount); \n \n            collectFeeWhenSellerAsMaker(PayMethod.PAY_BUSD, fees); \n        } else { \n            bibContract.transferFrom(msg.sender, order.owner, amount); \n \n            collectFeeWhenSellerAsMaker(PayMethod.PAY_BIB, fees); \n        } \n \n        // send token  \n        IERC721(address(order.issuer)).transferFrom(address(this), msg.sender, order.tokenId); \n \n        emit AcceptOffer( \n                msg.sender,  \n                order.owner, \n                msg.sender, \n                fees, \n                orderId, \n                0, \n                order.payMethod,  \n                order.price); \n \n        // refund commodity and currency \n        acceptAndRefundOffer(order, orderOfferTb[orderId], orderOfferTb[orderId].length); \n \n        // close order \n        _closeOrder(orderId); \n    } \n \n    // Owner accept the offer and make a deal \n    function acceptOffer(uint orderId, uint offerId) public  override payable{ \n        Order storage order = orderTb[orderId]; \n        require(address(0) != order.issuer,\"INVALID_ORDER\"); \n        require(msg.sender == order.owner, \"SHOULD_BE_ORDER_OWNER\"); \n        require(order.expiration > block.timestamp, \"ORDER_EXPIRED\"); \n \n        Offer storage offer = offerTb[offerId]; \n        require(address(0) != offer.buyer, \"INVALID_OFFER_ID\"); \n        require(offer.expiration > block.timestamp, \"OFFER_EXPIRED\"); \n \n        // caculate sales \n       (uint txFee, uint royaltyFee )= caculateFees(offer.bid); \n        uint fees = txFee.add(royaltyFee); \n        uint amount = offer.bid.sub(txFee).sub(royaltyFee); \n \n        // fee + royalty goese to BIB treasury \n        if(order.payMethod == PayMethod.PAY_BNB){ \n            payable(address(order.owner)).transfer(amount); \n            collectFeeWhenBuyerAsMaker(PayMethod.PAY_BNB, fees); \n        } else if(order.payMethod == PayMethod.PAY_BUSD){ \n            busdContract.transfer(order.owner, amount); \n            collectFeeWhenBuyerAsMaker(PayMethod.PAY_BUSD, fees); \n        } else { \n            bibContract.transfer(order.owner, amount); \n            collectFeeWhenBuyerAsMaker(PayMethod.PAY_BIB, fees); \n        } \n \n        // send token  \n        IERC721(address(order.issuer)).transferFrom(address(this), offer.buyer, order.tokenId); \n \n        emit AcceptOffer( \n                msg.sender,  \n                offer.buyer, \n                order.owner, \n                fees, \n                orderId, \n                offerId, \n                order.payMethod,  \n                offer.bid); \n \n        // refund commodity and currency \n        acceptAndRefundOffer(order, orderOfferTb[orderId], offerId); \n \n        // close order \n        _closeOrder(orderId); \n    } \n \n    // Owner updates order price \n    function updateOrderPrice(uint orderId, uint price) public override payable{ \n        Order storage order = orderTb[orderId]; \n        require(address(0) != order.issuer,\"INVALID_ORDER\"); \n        require(msg.sender == order.owner, \"SHOULD_BE_ORDER_OWNER\"); \n        require(order.expiration > block.timestamp, \"ORDER_EXPIRED\"); \n        require(price > 0, \"PRICE_LTE_ZERO\"); \n \n        emit UpdateOrderPrice(msg.sender, orderId, order.price, price); \n        order.price = price; \n    } \n \n    function _closeOrder(uint orderId) internal { \n        Order storage order = orderTb[orderId]; \n        require(address(0) != order.issuer,\"INVALID_ORDER\"); \n \n        uint indexToRm = orders.length; \n        for(uint i = 0; i < orders.length; i++){ \n           if(orderTb[orders[i]].orderId == orderId){ \n                indexToRm = i; \n           } \n        } \n        require(indexToRm < orders.length, \"ORDER_NOT_EXIST\"); \n        for(uint i = indexToRm; i < orders.length - 1; i++){ \n            orders[i] = orders[i+1]; \n        } \n        orders.pop(); \n \n        uint[] storage userOrders = userOrderTb[order.owner]; \n        indexToRm = userOrders.length; \n        for(uint i = 0; i < userOrders.length; i++){ \n           if(orderTb[userOrders[i]].orderId == orderId){ \n                indexToRm = i; \n           } \n        } \n        require(indexToRm < userOrders.length, \"ORDER_NOT_EXIST\"); \n        for(uint i = indexToRm; i < userOrders.length - 1; i++){ \n            userOrders[i] = userOrders[i+1]; \n        } \n        userOrders.pop(); \n \n        uint[] memory offerIds = orderOfferTb[orderId]; \n        for(uint i = 0; i < offerIds.length; i++){ \n            delete offerTb[offerIds[i]]; \n        } \n        delete orderOfferTb[orderId]; \n \n        delete orderTb[orderId]; \n \n        emit CloseOrder(msg.sender, orderId); \n    } \n \n    function acceptAndRefundOffer(Order storage order, uint[] storage offers, uint acceptOfferId) int\n        for(uint i = 0; i < offers.length; i++){ \n            Offer storage offer = offerTb[offers[i]]; \n \n            if(acceptOfferId == offer.offerId) { \n                continue; \n            } \n \n            if(order.payMethod == PayMethod.PAY_BNB){ \n                payable(address(offer.buyer)).transfer(offer.bid); \n            } else if(order.payMethod == PayMethod.PAY_BUSD){ \n                busdContract.transfer(offer.buyer, offer.bid); \n            } else { \n                bibContract.transfer(offer.buyer, offer.bid); \n            } \n        } \n    } \n \n    // Owner close the specific order if not dealed \n    function closeOrder(uint orderId) public override{ \n        Order storage order = orderTb[orderId]; \n        require(address(0) != order.issuer,\"INVALID_ORDER\"); \n        require(msg.sender == order.owner, \"SHOULD_BE_ORDER_OWNER\"); \n \n        // refund commodity and currency \n        acceptAndRefundOffer(order, orderOfferTb[orderId], orderOfferTb[orderId].length); \n \n        IERC721(address(tokenContract)).transferFrom(address(this), order.owner, order.tokenId); \n \n        _closeOrder(orderId); \n    } \n \n    // Buyer make a offer to the specific order \n    function makeOffer(uint orderId, uint price, uint expiration) public override payable{ \n        Order storage order = orderTb[orderId]; \n        require(address(0) != order.issuer,\"INVALID_ORDER\"); \n        require(msg.sender != order.owner, \"CANT_MAKE_OFFER_WITH_SELF\"); \n        require(expiration > block.timestamp, \"EXPIRATION_TOOL_SMALL\"); \n        require(price > 0, \"PRICE_NOT_BE_ZEROR\"); \n \n        // check if has made offer before \n        uint[] storage offers = orderOfferTb[orderId]; \n        for(uint i = 0; i < offers.length; i++){ \n            if(offerTb[offers[i]].buyer == msg.sender){ \n                revert(\"HAS_MADE_OFFER\"); \n            } \n        } \n \n        if(order.payMethod == PayMethod.PAY_BNB){ \n            require(msg.value >= price, \"INSUFFICIENT_FUNDS\"); \n            // refunds \n            if(msg.value > order.price){ \n                payable(address(msg.sender)).transfer(msg.value.sub(price)); \n            } \n        } else if(order.payMethod == PayMethod.PAY_BUSD){ \n            busdContract.transferFrom(msg.sender, address(this), price); \n        } else { \n            bibContract.transferFrom(msg.sender, address(this), price); \n        } \n \n        Offer memory offer = Offer({ \n            offerId: nextOfferIndex, \n            buyer: msg.sender, \n            bid: price, \n            expiration: expiration \n        }); \n \n        orderOfferTb[orderId].push(offer.offerId); \n        offerTb[nextOfferIndex] = offer; \n \n        emit MakeOffer(msg.sender,  order.owner, orderId, nextOfferIndex++, price, expiration); \n    } \n \n    // Buyer udpate offer bid price \n    function updateOffer(uint orderId, uint offerId, uint price) public override payable{ \n        Order storage order = orderTb[orderId]; \n        require(address(0) != order.issuer,\"INVALID_ORDER\"); \n        require(order.expiration > block.timestamp, \"ORDER_EXPIRED\"); \n \n        Offer storage offer = offerTb[offerId]; \n        require(msg.sender == offer.buyer, \"INVALID_OFFER_ID\"); \n        require(offer.expiration > block.timestamp, \"OFFER_EXPIRED\"); \n        require(price > 0, \"PRICE_NOT_BE_ZEROR\"); \n \n        uint delt  = 0; \n        if(offer.bid > price){ \n            delt = offer.bid.sub(price); \n            if(order.payMethod == PayMethod.PAY_BNB){ \n                payable(address(offer.buyer)).transfer(delt); \n            } else if(order.payMethod == PayMethod.PAY_BUSD){ \n                busdContract.transfer(offer.buyer, delt); \n            } else { \n                bibContract.transfer(offer.buyer, delt); \n            } \n        } else { \n            delt = price.sub(offer.bid); \n            if(order.payMethod == PayMethod.PAY_BNB){ \n                require(msg.value >= delt, \"INSUFFICIENT_FUNDS\"); \n                // refunds \n                if(msg.value > delt){ \n                    payable(address(msg.sender)).transfer(msg.value.sub(delt)); \n                } \n            } else if(order.payMethod == PayMethod.PAY_BUSD){ \n                busdContract.transferFrom(msg.sender, address(this), delt); \n            } else { \n                bibContract.transferFrom(msg.sender, address(this), delt); \n            } \n        } \n \n        emit UpdateOfferPrice(msg.sender, orderId, offerId, offer.bid, price); \n \n        offer.bid = price; \n    } \n \n    // Buyer cancle the specific order \n    function cancelOffer(uint orderId, uint offerId) public override{ \n        Order storage order = orderTb[orderId]; \n        require(address(0) != order.issuer,\"INVALID_ORDER\"); \n \n        Offer storage offer = offerTb[offerId]; \n        require(msg.sender == offer.buyer, \"SHOULD_BE_BUYER\"); \n \n        if(order.payMethod == PayMethod.PAY_BNB){ \n            payable(address(offer.buyer)).transfer(offer.bid); \n        } else if(order.payMethod == PayMethod.PAY_BUSD){ \n            busdContract.transfer(offer.buyer, offer.bid); \n        } else { \n            bibContract.transfer(offer.buyer, offer.bid); \n        } \n \n        uint[] storage offers = orderOfferTb[orderId]; \n        uint indexToRm = offers.length; \n        for(uint i = 0; i < offers.length; i++){ \n           if(offerTb[offers[i]].offerId == offerId){ \n                indexToRm = i; \n           } \n        } \n        require(indexToRm < offers.length, \"OFFER_NOT_EXIST\"); \n        for(uint i = indexToRm; i < offers.length - 1; i++){ \n            offers[i] = offers[i+1]; \n        } \n        offers.pop(); \n        delete offerTb[offerId]; \n \n        emit CancelOffer(msg.sender, orderId, offerId); \n    } \n} \n \n \n",
            "pragma solidity >=0.8.0; \n \nimport {SafeMath} from \"../libs/SafeMath.sol\"; \nimport {SafeCast} from \"../libs/SafeCast.sol\"; \nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport {Ownable} from  \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport {IRewardDistributor} from \"../interfaces/IRewardDistributor.sol\"; \n \ncontract FeeCollector is  Ownable { \n    using SafeMath for uint; \n    using SafeCast for uint; \n \n    uint totalBNBRecieved; \n    uint totalBUSDRecieved; \n    uint totalBIBRecieved; \n \n    mapping(address=>bool) protocolAddress; \n \n    uint public vaultRatio; \n    uint public constant FEE_RATIO_DIV = 1000; \n \n    IRewardDistributor rewardDistributor; \n    address vault; \n \n    IERC20 bibToken; \n    IERC20 busdToken; \n \n    enum TokenType{ \n        TOKEN_TYPE_ETH, \n        TOKEN_TYPE_BIB, \n        TOKEN_TYPE_BUSD \n    }  \n \n    event VaultChanged(address sender, address oldValue, address newValue); \n    event BIBContractChanged(address sender, address oldValue, address newValue); \n    event BUSDContractChanged(address sender, address oldValue, address newValue); \n    event VaultRatioChanged(address sender, uint oldValue, uint newValue); \n    event RewardDistributorChanged(address sender, address oldValue, address newValue); \n    event HandleCollect(address sender, uint vault, uint reward, TokenType tokenType); \n \n    constructor( \n        address _vault, \n        address _bibToken, \n        address _busdToken, \n        address _rewardDistributor \n        ){ \n        vault = _vault; \n        bibToken = IERC20(_bibToken); \n        busdToken = IERC20(_busdToken); \n        rewardDistributor = IRewardDistributor(_rewardDistributor); \n    } \n \n    function setBIBContract(address _bibToken) public onlyOwner{ \n        require(address(0) != _bibToken, \"INVALID_ADDRESS\"); \n        emit BIBContractChanged(msg.sender, address(bibToken), _bibToken); \n        bibToken = IERC20(_bibToken); \n    } \n \n    function setRewardDistributor(address _rewardDistributor) public onlyOwner{ \n        require(address(0) != _rewardDistributor, \"INVALID_ADDRESS\"); \n        emit RewardDistributorChanged(msg.sender, address(rewardDistributor), _rewardDistributor); \n        rewardDistributor = IRewardDistributor(_rewardDistributor); \n    } \n \n    function setBUSDContract(address _busdToken) public onlyOwner{ \n        require(address(0) != _busdToken, \"INVALID_ADDRESS\"); \n        emit BUSDContractChanged(msg.sender, address(busdToken), _busdToken); \n        busdToken = IERC20(_busdToken); \n    } \n \n    function setVault(address _vault) public onlyOwner{ \n        require(address(0) != _vault, \"INVALID_ADDRESS\"); \n        emit VaultChanged(msg.sender, address(vault), _vault); \n        vault = _vault; \n    } \n \n    function setVaultRatio(uint _vaultRatio) public onlyOwner{ \n        require(_vaultRatio <= FEE_RATIO_DIV, \"INVALID_RATIO\"); \n        emit VaultRatioChanged(msg.sender, vaultRatio, _vaultRatio); \n        vaultRatio = _vaultRatio; \n    } \n \n    function addProtocolAdress(address protocolAddr) public onlyOwner{ \n        protocolAddress[protocolAddr] = true; \n    } \n \n    function removeProtocolAddress(address protocolAddr) public onlyOwner{ \n        delete protocolAddress[protocolAddr]; \n    } \n \n    function isProtocolAddress(address protocolAddr) public view returns(bool){ \n        return protocolAddress[protocolAddr]; \n    } \n \n    modifier onlyProtocolAddress(){ \n        require(protocolAddress[msg.sender], \"ONLY_PROTOCOL_ADDRESS_CAN_CALL\"); \n        _; \n    } \n \n    function caculateFees(uint amount) public pure  returns(uint, uint){ \n        uint vaultPart =  amount.mul(FEE_RATIO_DIV).div(FEE_RATIO_DIV); \n        return (vaultPart, amount.sub(vaultPart)); \n    } \n \n    function distributeFees() public onlyOwner(){ \n        handleCollectBIB(bibToken.balanceOf(address(this))); \n        handleCollectBUSD(busdToken.balanceOf(address(this))); \n        handleCollectBNB(address(this).balance); \n    } \n \n    function handleCollectBIB(uint amount) public onlyProtocolAddress{ \n        if(address(0) != address(rewardDistributor) && address(0) != vault){ \n            (uint vaultPart, uint rewardPart) = caculateFees(amount); \n            bibToken.transfer(vault, vaultPart); \n            bibToken.transfer(address(rewardDistributor), rewardPart); \n            rewardDistributor.distributeBIBReward(amount); \n            emit HandleCollect(msg.sender, vaultPart, rewardPart, TokenType.TOKEN_TYPE_BIB); \n        } \n    } \n \n    function handleCollectBUSD(uint amount) public onlyProtocolAddress{ \n        if(address(0) != address(rewardDistributor) && address(0) != vault){ \n            (uint vaultPart, uint rewardPart) = caculateFees(amount); \n            busdToken.transfer(vault, vaultPart); \n            busdToken.transfer(address(rewardDistributor), rewardPart); \n            rewardDistributor.distributeBUSDReward(amount); \n            emit HandleCollect(msg.sender, vaultPart, rewardPart, TokenType.TOKEN_TYPE_BUSD); \n        } \n    } \n \n    function handleCollectBNB(uint amount) public onlyProtocolAddress{ \n        if(address(0) != address(rewardDistributor) && address(0) != vault){ \n            (uint vaultPart, uint rewardPart) = caculateFees(amount); \n            payable(vault).transfer(vaultPart); \n            rewardDistributor.distributeETHReward{value:rewardPart}(amount); \n            emit HandleCollect(msg.sender, vaultPart, rewardPart, TokenType.TOKEN_TYPE_BUSD); \n        } \n    } \n} \n \n \n \n",
            "pragma solidity >=0.8.0; \n \nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/utils/Strings.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol'; \nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\"; \nimport \"../interfaces/ISoccerStarNft.sol\"; \nimport \"erc721a/contracts/ERC721A.sol\"; \nimport {SafeMath} from \"../libs/SafeMath.sol\"; \n \ncontract SoccerStarNft is  \nISoccerStarNft,  \nERC721A,  \nOwnable { \n    using Strings for uint; \n    using SafeMath for uint; \n \n    IERC20 public bibContract; \n    IERC20 public busdContract; \n    IUniswapV2Router02 public router; \n \n    //URI of the NFTs when revealed \n    string public baseURI; \n    //URI of the NFTs when not revealed \n    string public notRevealedURI; \n    //The extension of the file containing the Metadatas of the NFTs \n    string public constant BASE_EXTENSION = \".json\"; \n \n    //Are the NFTs revealed yet ? \n    bool public revealed = false; \n \n    uint constant public ORACLE_PRECISION = 1e18; \n \n    address constant public BLACK_HOLE = 0x0000000000000000000000000000000000000001; \n \n    uint public maxMintSupply; \n \n    uint constant public PRE_SELL_ROUND  = 0; \n    uint constant public PUB_SELL_ROUND1 = 1; \n    uint constant public PUB_SELL_ROUND2 = 2; \n    uint constant public PUB_SELL_ROUND3 = 3; \n    uint constant public PUB_SELL_ROUND4 = 4; \n    uint constant public PUB_SELL_ROUND5 = 5; \n    uint constant public MAX_ROUND = PUB_SELL_ROUND5; \n \n    event BIBContractChanged(address sender, address oldValue, address newValue); \n    event BUSDContractChanged(address sender, address oldValue, address newValue); \n    event TreasuryChanged(address sender, address oldValue, address newValue); \n    event SwapRouterChanged(address sender, address oldValue, address newValue); \n    event ComposerChanged(address sender, address oldValue, address newValue); \n    event SellTimeChanged(address sender, uint oldValue, uint newValue); \n    event Changed(address sender, uint oldValue, uint newValue); \n    event UpdateStarLevel(address sender, uint oldValue, uint newValue); \n \n    address public treasury; \n \n    uint256 public maxPubicsaleUserMintAmount; \n \n    uint constant public MAX_PROPERTY_VALUE = 4; \n \n    mapping(uint256 => bool) public isOwnerMint; // if the NFT was freely minted by owner \n    mapping(uint256 => SoccerStar) public cardProperty; \n \n    // round->boxType->price \n    mapping(uint=>mapping(BlindBoxesType=>uint)) public mintPriceTb; \n    // round->boxType->amount \n    mapping(uint=>mapping(BlindBoxesType=>uint)) public maxAmountTb; \n    // round->boxType->maxAmount \n    mapping(uint=>mapping(BlindBoxesType=>uint)) public mintAmountTb; \n    mapping(address=>mapping(uint=>uint))        public mintAmountPerAddrTb; \n    mapping(uint=>TimeInfo) public timeInfoTb; \n \n    mapping(address=>bool) public allowProtocolToCallTb; \n    mapping(address=>bool) public allowToCallTb; \n \n    struct QuotaTracker { \n        uint quota; \n        uint used; \n    } \n \n    // track busd quota per public round \n    mapping(uint=>QuotaTracker) public busdQuotaPerPubRoundTb; \n \n    // track user quota at pre-round \n    mapping(address=>QuotaTracker) public userQutaPreRoundTb; \n \n    constructor(uint _maxMintSupply,  \n    address _bibContract, \n    address _busdContract, \n    address _treasury, \n    address _router)ERC721A(\"BIBMetaSuperstar\", \"BMSTAR\"){ \n        maxMintSupply = _maxMintSupply; \n        bibContract = IERC20(_bibContract); \n        busdContract = IERC20(_busdContract); \n        treasury = _treasury; \n        router = IUniswapV2Router02(_router); \n \n        maxPubicsaleUserMintAmount = 10; \n        revealed = false; \n    } \n \n    function setAllowProtocolToCall(address _protAddr, bool value)  \n    public onlyOwner{ \n        allowProtocolToCallTb[_protAddr] = value; \n    } \n \n    modifier onlyAllowProtocolToCall() { \n        require(allowProtocolToCallTb[msg.sender], \"ONLY_PROTOCOL_CALL\"); \n        _; \n    } \n \n    function setAllowToCall(address _caller, bool value) public onlyOwner{ \n        allowToCallTb[_caller] = value; \n    } \n \n    modifier onlyAllowToCall(){ \n          require(allowToCallTb[msg.sender] || msg.sender == owner(), \"ONLY_PERMIT_CALLER\"); \n        _; \n    } \n \n    function  getRemainingAmount(uint round, BlindBoxesType boxType) \n    public view returns(uint){ \n        return maxAmountTb[round][boxType].sub(mintAmountTb[round][boxType]); \n    } \n \n    function setBIBContract(address _bibContract) public onlyOwner{ \n        require(address(0) != _bibContract, \"INVLID_ADDRESS\"); \n        emit BIBContractChanged(msg.sender, address(bibContract), _bibContract); \n        bibContract = IERC20(_bibContract); \n    } \n \n    function setTreasury(address _treasury) public onlyOwner{ \n        require(address(0) != _treasury, \"INVLID_ADDRESS\"); \n        emit TreasuryChanged(msg.sender, treasury, _treasury); \n        treasury = _treasury; \n    } \n \n    function setSwapRouter(address _router) public onlyOwner{ \n        require(address(0) != _router, \"INVLID_ADDRESS\"); \n        emit SwapRouterChanged(msg.sender, address(router), _router); \n        router = IUniswapV2Router02(_router); \n    } \n \n    function setBUSDContract(address _busdContract) public onlyOwner{ \n        require(address(0) != _busdContract, \"INVLID_ADDRESS\"); \n        emit BUSDContractChanged(msg.sender, address(busdContract), _busdContract); \n        busdContract = IERC20(_busdContract); \n    } \n \n    function caculateBUSDAmount(uint bibAmount) public view returns(uint){ \n        // the price has ORACLE_PRECISION \n        address[] memory path = new address[](2); \n        path[0] = address(bibContract); \n        path[1] = address(busdContract); \n        return router.getAmountsOut(bibAmount, path)[1]; \n    } \n \n   // only allow protocol related contract to mint \n    function protocolMint()  \n    public override onlyAllowProtocolToCall returns(uint tokenId){ \n        tokenId = _nextTokenId(); \n        _mint(msg.sender, 1); \n        require(msg.sender == ownerOf(tokenId), \"PROTOCOL_MINT_FAILED\"); \n    } \n \n    // only allow protocol related contract to mint to burn \n    function protocolBurn(uint tokenId)  \n    public override onlyAllowProtocolToCall { \n        require(msg.sender == ownerOf(tokenId), \"TOKEN_NOT_BELLONG_TO_CALLER\"); \n        _burn(tokenId); \n        require(msg.sender != ownerOf(tokenId), \"PROTOCOL_BRUN_FAILED\"); \n    } \n \n    // only allow protocol related contract to bind star property \n    function protocolBind(uint tokenId, SoccerStar memory soccerStar)  \n    public override onlyAllowProtocolToCall { \n        require(msg.sender == ownerOf(tokenId), \"TOKEN_NOT_BELLONG_TO_CALLER\"); \n        require(cardProperty[tokenId].starLevel == 0, \"TOKEN_REVEALED\"); \n        cardProperty[tokenId] = soccerStar; \n    } \n \n    function addUserQuotaPreRoundBatch(address[] memory users, uint[] memory quotas) \n    public override onlyAllowToCall { \n        require(users.length == quotas.length, \"SHOULD_BE_SAME_LENGTH\"); \n        for(uint i = 0; i < users.length; i++){ \n            userQutaPreRoundTb[users[i]].quota = quotas[i]; \n        } \n    } \n \n    function setUserQuotaPreRound(address user, uint quota)  \n    public override onlyAllowToCall { \n        userQutaPreRoundTb[user].quota = quota; \n    } \n \n    function getUserQuotaPreRound(address user) public override view returns(uint){ \n        return userQutaPreRoundTb[user].quota; \n    } \n \n    function getUserRemainningQuotaPreRound(address user) public view override returns(uint){ \n        return userQutaPreRoundTb[user].quota.sub(userQutaPreRoundTb[user].used); \n    } \n \n    function setBUSDQuotaPerPubRound(uint round, uint quota)  \n    public override onlyAllowToCall { \n        require(isPublicRound(round), \"NOT_PUBLIC_ROUND\"); \n        busdQuotaPerPubRoundTb[round].quota = quota; \n    } \n \n    function getBUSDQuotaPerPubRound(uint round) public view override returns(uint){ \n        require(isPublicRound(round), \"NOT_PUBLIC_ROUND\"); \n        return busdQuotaPerPubRoundTb[round].quota; \n    } \n \n    function getBUSDUsedQuotaPerPubRound(uint round) public view override returns(uint){ \n        require(isPublicRound(round), \"NOT_PUBLIC_ROUND\"); \n        return busdQuotaPerPubRoundTb[round].used; \n    } \n \n    function getBUSDRemainningQuotaPerPubRound(uint round) public view returns(uint){ \n        require(isPublicRound(round), \"NOT_PUBLIC_ROUND\"); \n        return busdQuotaPerPubRoundTb[round].quota.sub(busdQuotaPerPubRoundTb[round].used); \n    } \n \n    function setMaxMintAmount(uint round, BlindBoxesType boxType, uint amount)  \n    public onlyAllowToCall{ \n        maxAmountTb[round][boxType] = amount; \n    } \n \n    function getMaxMintAmount(uint round, BlindBoxesType boxType) public view returns(uint){ \n        return maxAmountTb[round][boxType]; \n    } \n \n    function setSellTime(uint round, uint _startTime, uint _endTime, uint _revealTime)  \n    public onlyAllowToCall { \n        require(round <= MAX_ROUND, \"INVLID_ROUND\"); \n        require(_startTime >= block.timestamp, \"INVLID_START_TIME\"); \n        require(_endTime >= _startTime, \"INVLID_END_TIME\"); \n        require(_revealTime >= _endTime, \"INVLID_END_TIME\"); \n \n        timeInfoTb[round] = TimeInfo({ \n            startTime: _startTime, \n            endTime: _endTime, \n            revealTime: _revealTime \n        }); \n    } \n \n    function getSellTime(uint round) public view returns (uint){ \n        return timeInfoTb[round].startTime; \n    } \n \n    function setMaxMintSupply(uint _maxMintSupply) public onlyAllowToCall{ \n        maxMintSupply = _maxMintSupply; \n    } \n \n    function getMaxMintSupply() public view returns(uint){ \n        return maxMintSupply; \n    } \n \n    function setMaxAmountPerAddress(uint _amount)  \n    public onlyAllowToCall{ \n        maxPubicsaleUserMintAmount = _amount; \n    } \n \n    function getMaxAmountPerAddress() public view returns(uint){ \n        return maxPubicsaleUserMintAmount; \n    } \n \n    function setMintPrice(uint round, uint256 _mintPrice, BlindBoxesType boxType)  \n    public onlyAllowToCall { \n        require(round<= MAX_ROUND, \"INVLID_ROUND\"); \n        mintPriceTb[round][boxType] = _mintPrice; \n    } \n \n    function getMintPrice(uint round, BlindBoxesType boxType) public view returns(uint){ \n        return mintPriceTb[round][boxType]; \n    } \n \n    function setBaseURI(string memory uri) external onlyAllowToCall { \n        baseURI = uri; \n    } \n \n     /** \n    * @notice Allows to set the revealed variable to true \n    **/ \n    function reveal(bool _revealed)  \n    external onlyAllowToCall { \n        revealed = _revealed; \n    } \n \n    function getCardProperty(uint256 tokenId) public view override \n    returns(SoccerStar memory){ \n        return cardProperty[tokenId]; \n    } \n \n   function updateProperty(uint[] memory tokenIds, SoccerStar[] memory _soccerStars) \n        external \n        onlyAllowToCall{ \n        require(tokenIds.length == _soccerStars.length, \"NEED_SAME_LENGTH\"); \n        for(uint i = 0; i < _soccerStars.length; i++){ \n            cardProperty[tokenIds[i]] = _soccerStars[i]; \n            require(cardProperty[tokenIds[i]].starLevel != 0, \"INVALID_PROPERTY\"); \n        } \n    } \n \n    function isRoundOpen(uint round) public view returns(bool){ \n        TimeInfo storage timeInfo = timeInfoTb[round];  \n        return (currentTime() >= timeInfo.startTime)  \n        && (currentTime() <= timeInfo.endTime); \n    } \n \n    function preSellMint(uint256 quantity) \n        external \n        payable{ \n        require(isRoundOpen(PRE_SELL_ROUND), \"PRE_SELL_ROUND_NOT_OPENED\"); \n        require(getUserRemainningQuotaPreRound(msg.sender) >= quantity, \"USER_HAS_NO_QUOTA\"); \n        require( \n           getRemainingAmount(PRE_SELL_ROUND,BlindBoxesType.presale) >=  quantity, \n            \"EXCEED_MAX_MINT_AMOUNT\" \n        ); \n \n        // burn bib tokens \n        uint sales = quantity.mul(getMintPrice(PRE_SELL_ROUND, BlindBoxesType.presale)); \n        bibContract.transferFrom(msg.sender, BLACK_HOLE, sales); \n \n        _safeMint(msg.sender, quantity); \n \n        mintAmountTb[PRE_SELL_ROUND][BlindBoxesType.presale] = mintAmountTb[PRE_SELL_ROUND][BlindBoxe\n \n        // deducate user presell quota \n        userQutaPreRoundTb[msg.sender].used = userQutaPreRoundTb[msg.sender].used.add(quantity); \n \n        emit Mint(msg.sender,  \n        PRE_SELL_ROUND, \n        BlindBoxesType.presale,  \n        _nextTokenId().sub(quantity),  \n        quantity, \n        PayMethod.PAY_BIB, \n        sales); \n    } \n \n    function isPublicRound(uint round) public pure returns(bool){ \n        return (round >= PUB_SELL_ROUND1) && (round <= PUB_SELL_ROUND5); \n    } \n \n    function getPubicRoundMintAmountByUser(address user, uint round) public view returns(uint){ \n        return mintAmountPerAddrTb[user][round]; \n    } \n \n    function publicSellMint( \n    uint round,  \n    BlindBoxesType boxType,  \n    uint256 quantity,  \n    PayMethod payMethod) public { \n        require(isPublicRound(round), \"NOT_PUBLIC_ROUND_NUM\"); \n        require(isRoundOpen(round), \"ROUND_NOT_OPEN\"); \n        require(boxType != BlindBoxesType.presale, \"PRESALE_BOX_NOT_ALLOWED\"); \n \n        // check constraint per address  \n        require(getPubicRoundMintAmountByUser(msg.sender, round).add(quantity) <= getMaxAmountPerAddr\n                \"EXCEED_ADDRESS_MAX_MINT_AMOUNT\"); \n        // check constraint per round && box type  \n        require(getRemainingAmount(round, boxType) >=  quantity, \n                \"EXCEED_MAX_MINT_AMOUNT\"); \n \n        uint sales = quantity.mul(getMintPrice(round, boxType)); \n        if(payMethod == PayMethod.PAY_BIB){ \n            // burn out bib \n            bibContract.transferFrom(msg.sender, BLACK_HOLE, sales); \n        } else { \n            //check BUSD quota \n            require(getBUSDRemainningQuotaPerPubRound(round) >= quantity, \"EXCEED_MAX_BUSD_QUOTA\"); \n            sales = caculateBUSDAmount(sales); \n \n            // transfer to treasury \n            busdContract.transferFrom(msg.sender, treasury, sales); \n \n            // update used quota \n            busdQuotaPerPubRoundTb[round].used = busdQuotaPerPubRoundTb[round].used.add(quantity); \n        } \n        _safeMint(msg.sender, quantity); \n \n        mintAmountTb[round][boxType] = mintAmountTb[round][boxType].add(quantity); \n        mintAmountPerAddrTb[msg.sender][round] = mintAmountPerAddrTb[msg.sender][round].add(quantity)\n \n        emit Mint(msg.sender,  \n        round, \n        boxType,  \n        _nextTokenId().sub(quantity),  \n        quantity, \n        payMethod, \n        sales); \n     } \n \n    function ownerMint(uint256 quantity) external onlyOwner { \n        require( \n            _totalMinted() + quantity <= getMaxMintSupply(), \n            \"MAX_SUPPLY_REACHED\" \n        ); \n \n         _safeMint(msg.sender, quantity); \n \n        for (uint256 i = _nextTokenId() - quantity; i < _nextTokenId(); i++) { \n            isOwnerMint[i] = true; \n        } \n \n        emit Mint(msg.sender, \n        PRE_SELL_ROUND,  \n        BlindBoxesType.presale,  \n        _nextTokenId().sub(quantity),  \n        quantity, \n        PayMethod.PAY_BIB, \n        0); \n    } \n \n    function currentTime() public view returns(uint) { \n        return block.timestamp; \n    } \n \n    function _startTokenId() internal view virtual override returns (uint256) { \n        return 1; \n    } \n \n    function tokenURI(uint _nftId) public view override(ERC721A) returns (string memory) { \n        require(_exists(_nftId), \"This NFT doesn't exist.\"); \n        if(revealed == false) { \n            return notRevealedURI; \n        } \n \n        string memory currentBaseURI = _baseURI(); \n        return  \n            bytes(currentBaseURI).length > 0  \n            ? string(abi.encodePacked(currentBaseURI, _nftId.toString(), BASE_EXTENSION)) \n            : \"\"; \n    } \n \n    function _baseURI() internal view override returns (string memory) { \n        return baseURI; \n    } \n \n    function setNotRevealURI(string memory _notRevealedURI) external onlyOwner { \n        notRevealedURI = _notRevealedURI; \n    } \n} \n \n \n//SPDX-License-Identifier: MIT \n \n",
            "pragma solidity >=0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/utils/Address.sol\"; \nimport {SafeMath} from \"../libs/SafeMath.sol\"; \nimport {SafeCast} from \"../libs/SafeCast.sol\"; \nimport {ISoccerStarNft} from \"../interfaces/ISoccerStarNft.sol\"; \nimport {IStakedSoccerStarNft} from \"../interfaces/IStakedSoccerStarNft.sol\"; \n \ncontract StakedSoccerStarNft is IStakedSoccerStarNft, Ownable { \n    using SafeMath for uint; \n    using SafeCast for uint; \n \n    event FrozenDurationChanged(uint oldValue, uint newValue); \n    event RewardPeriodChanged(uint oldValue, uint newValue); \n    event RewardStartChanged(uint oldValue, uint newValue); \n    event RewardContractChanged(address oldValue, address newValue); \n    event NftContractChanged(address oldValue, address newValue); \n \n    IERC20 public rewardContract; \n    IERC721 public nftContract; \n \n    int constant public INVLID_ROUND = -1; \n    uint public rewardPeriod = 1 days; \n    uint public frozenDuration = 7 days; \n    uint public rewardStart; \n    uint public totalStaked; \n    uint public totalPower; \n \n    DepositInfo[] public depositInfos; \n \n    mapping(address=>UserStakedInfo[]) public stakedInfos; \n \n    // Keep a fast index to avoid too many times of loop \n    mapping(uint=>UserStakedInfo) public tokenToUserStakedInfo; \n \n    constructor( \n        address _rewardContract, \n        address _nftContract, \n        uint _rewardPeriod, \n        uint _rewardStart \n        ){ \n        rewardContract = IERC20(_rewardContract); \n        nftContract = IERC721(_nftContract); \n        rewardPeriod = _rewardPeriod; \n        rewardStart = _rewardStart; \n    } \n \n    modifier onlyContract(address cntr) { \n        require(address(0) != cntr, \"INVALID_ADDRESS\"); \n        require(Address.isContract(cntr), \"NOT_CONTRACT\"); \n        _; \n    } \n \n    modifier onlyStarted(){ \n        require(isStakedStart(), \"REWARD_NOT_START\"); \n        _; \n    } \n \n    modifier ownToken(uint tokenId){ \n        require(msg.sender == nftContract.ownerOf(tokenId), \"TOKEN_NOT_BELONG_TO_SENDER\"); \n        _; \n    } \n \n    // check if staked start \n    function isStakedStart() public view returns(bool){ \n        return rewardStart <= block.timestamp; \n    } \n \n   function setFrozenDuration(uint newValue) public onlyOwner { \n        emit FrozenDurationChanged(frozenDuration, newValue); \n        frozenDuration = newValue; \n    } \n \n    function setRewardPeroid(uint newValue) public onlyOwner { \n        require(newValue >= 1 days,  \"REWARD_PERIOD_TOO_SHORT\"); \n        emit RewardPeriodChanged(rewardPeriod, newValue); \n        rewardPeriod = newValue; \n    } \n \n    function setRewardStart(uint newValue) public onlyOwner { \n        require(newValue >= block.timestamp, \"REWARD_START_LESS_THAN_CURRENT\"); \n        emit RewardStartChanged(rewardStart, newValue); \n        rewardStart = newValue; \n    } \n \n    function setRewardContract(address newValue) public onlyOwner onlyContract(newValue){ \n        emit RewardContractChanged(address(rewardContract), newValue); \n        rewardContract = IERC20(newValue); \n    } \n \n    function setNftContract(address newValue) public onlyOwner onlyContract(newValue){ \n        emit NftContractChanged(address(nftContract), newValue); \n        nftContract = IERC721(newValue); \n    } \n \n      // deposit a specified funds to pool \n    function deposit(uint amount) public override onlyStarted{ \n        require(amount > 0, \"AMOUNT_TOOL_SMALL\"); \n \n        (bool hasRound, uint round, DepositInfo memory roundInfo) = checkAndGetRound(); \n        if(!hasRound || (round > roundInfo.round)){ \n            // close old  \n            if(hasRound){ \n                closeRound(); \n            } \n \n            DepositInfo memory depositInfo = DepositInfo({ \n                round:round, \n                totalDeposit:amount, \n                totalStaked:0, \n                totalPower:0, \n                totalClaimed:0 \n            }); \n            depositInfos.push(depositInfo); \n        }else { \n            roundInfo.totalDeposit += amount; \n            depositInfos[depositInfos.length - 1] = roundInfo; \n        } \n \n        rewardContract.transferFrom(msg.sender, address(this), amount); \n \n        emit Deposit(msg.sender, round, amount); \n    }  \n \n    function getCurrentRound() public view override onlyStarted returns(uint round){ \n        return block.timestamp.sub(rewardStart).div(rewardPeriod); \n    } \n \n    function checkAndGetRound() public view  returns(bool, uint, DepositInfo memory){ \n        DepositInfo memory roundInfo; \n        if(depositInfos.length <= 0){ \n            return (false, 0, roundInfo); \n        } \n        uint round = getCurrentRound(); \n        roundInfo = depositInfos[depositInfos.length - 1]; \n        require(round >= roundInfo.round, \"INVALID_ROUND\"); \n        return (true, round, roundInfo); \n    } \n \n    // close a reward period \n    function closeRound() public onlyStarted override{ \n        (bool hasRound, uint round, DepositInfo memory roundInfo) = checkAndGetRound(); \n        if(hasRound && (round > roundInfo.round) ){ \n            // finalize total amount \n            roundInfo.totalStaked = totalStaked; \n            roundInfo.totalPower = totalPower; \n            depositInfos[depositInfos.length - 1] = roundInfo; \n \n            emit CloseRound( \n            msg.sender,  \n            roundInfo.round,  \n            roundInfo.totalDeposit,  \n            roundInfo.totalStaked, \n            roundInfo.totalPower \n            ); \n        } \n    } \n \n    // check is the specified token is staked \n    function isStaked(uint tokenId) public view override returns(bool){ \n        // give that the token id start with 1 \n        return tokenToUserStakedInfo[tokenId].tokenId == tokenId  \n        && tokenToUserStakedInfo[tokenId].unfrozenTime == 0; \n    } \n \n    // Check if is the specified token is staking \n    function isStaking(uint tokenId) public view override returns(bool){ \n        return (tokenToUserStakedInfo[tokenId].tokenId == tokenId); \n    } \n \n    // Check if the specified token is unfreezing \n    function isUnfreezing(uint tokenId) public view override returns(bool){ \n        uint unfrozenTime = tokenToUserStakedInfo[tokenId].unfrozenTime; \n        return (unfrozenTime > 0 \n        && block.timestamp <=  unfrozenTime); \n    } \n \n    // Check if the specified token is withdrawable \n    function isWithdrawAble(uint tokenId) public view override returns(bool){ \n        uint unfrozenTime = tokenToUserStakedInfo[tokenId].unfrozenTime; \n        return (unfrozenTime > 0 && block.timestamp >  unfrozenTime); \n    } \n \n    // user staken one or more nft card to safty module \n    function stake(uint tokenId) public override onlyStarted ownToken(tokenId){ \n        require(!isStaking(tokenId), \"TOKEN_STAKING\"); \n \n        // check if need to close the old round \n        closeRound(); \n \n        totalStaked++; \n        totalPower += getTokenPower(tokenId); \n \n        UserStakedInfo memory userStakedInfo = UserStakedInfo({ \n            tokenId: tokenId, \n            round: getCurrentRound(), \n            unfrozenTime: 0, \n            claimedRound: INVLID_ROUND \n        }); \n        stakedInfos[msg.sender].push(userStakedInfo); \n        tokenToUserStakedInfo[tokenId] = userStakedInfo; \n \n        nftContract.transferFrom(msg.sender, address(this), tokenId); \n \n        emit Stake(msg.sender, tokenId); \n    } \n \n    function getTokenPower(uint tokenId) public view returns(uint power){ \n        ISoccerStarNft.SoccerStar memory cardInfo = ISoccerStarNft(address(nftContract)).getCardPrope\n        require(cardInfo.starLevel > 0, \"CARD_UNREAL\"); \n        // The power equation: power = gradient * 10 ^ (starLevel -1) \n        return cardInfo.gradient.exp(cardInfo.starLevel.sub(1)); \n    } \n \n    // user redeem one or more nft cards \n    function redeem(uint tokenId) public override onlyStarted ownToken(tokenId){ \n        require(isStaked(tokenId), \"TOKEN_NOT_STAKED\"); \n \n        // check if need to close the old round \n        closeRound(); \n \n        // claim all rewards \n        claimRewards(); \n \n        // update global data \n        totalPower -= getTokenPower(tokenId); \n        totalStaked--; \n \n        // update fast index \n        tokenToUserStakedInfo[tokenId].unfrozenTime = block.timestamp + frozenDuration; \n \n        UserStakedInfo[] storage userStakedInfos = stakedInfos[msg.sender]; \n        uint indexToRm = userStakedInfos.length; \n        for(uint i = 0; i < userStakedInfos.length; i++){ \n           if(userStakedInfos[i].tokenId == tokenId){ \n                indexToRm = i; \n           } \n        } \n        require(indexToRm < userStakedInfos.length, \"TOKEN_NOT_EXIST\"); \n        // delete from index \n        for(uint i = indexToRm; i < userStakedInfos.length - 1; i++){ \n            userStakedInfos[i] = userStakedInfos[i+1]; \n        } \n        userStakedInfos.pop(); \n \n        emit Redeem(msg.sender, tokenId); \n    } \n \n    // withdraw token after the unfrozen period \n    function withdraw(uint tokenId) public override onlyStarted ownToken(tokenId){ \n        require(isWithdrawAble(tokenId), \"TOKEN_NOT_WITHDRAWABLE\"); \n \n        // check if need to close the old round \n        closeRound(); \n \n        // delete from the fast index \n        delete tokenToUserStakedInfo[tokenId]; \n \n        nftContract.transferFrom(address(this), msg.sender, tokenId); \n \n        emit Withdraw(msg.sender, tokenId); \n    } \n \n    function getUnClaimedRewardsByToken(uint tokenId) public view override returns(uint){ \n        if(!isStaked(tokenId)){ \n            return 0; \n        } \n \n        if( 0 == depositInfos.length){ \n            return 0; \n        } \n \n        uint curRound = getCurrentRound(); \n        uint totalRewards = 0; \n \n        UserStakedInfo storage userStakedInfo = tokenToUserStakedInfo[tokenId]; \n        if(curRound != userStakedInfo.round){ \n \n            // walk through from the last to the frist \n            for(uint j = depositInfos.length - 1; j >= 0; ){ \n \n                DepositInfo storage depositInfo = depositInfos[j]; \n \n                if(depositInfo.round != curRound){ \n                    if(depositInfo.round.toInt() == userStakedInfo.claimedRound){ \n                        break; \n                    } \n \n                    if(depositInfo.totalPower > 0 \n                    && depositInfo.totalDeposit > 0){ \n                        totalRewards += depositInfo.totalDeposit.mul(getTokenPower(userStakedInfo.tok\n                    } \n                } \n \n                // avoid overflow \n                if(j > 0){ \n                    j--; \n                } else { \n                    break; \n                } \n            } \n        } \n        return totalRewards; \n    } \n \n        // Get unclaimed rewards by a set of the specified tokens \n    function getUnClaimedRewardsByTokens(uint[] memory tokenIds) public view override returns(uint[] \n        uint[] memory rewards = new uint[](tokenIds.length); \n        for(uint i = 0; i < tokenIds.length; i++){ \n            rewards[i] = getUnClaimedRewardsByToken(tokenIds[i]); \n        } \n        return rewards; \n    } \n \n    function getUnClaimedRewards(address user) public override view returns(uint amount){ \n        uint totalRewards = 0; \n \n        // go through to accurate the rewards \n        UserStakedInfo[] storage userStakedInfos = stakedInfos[user]; \n        for(uint i = 0; i < userStakedInfos.length; i++){ \n            totalRewards += getUnClaimedRewardsByToken(userStakedInfos[i].tokenId); \n        } \n \n        return totalRewards; \n    } \n \n    // Get unclaimed rewards  \n    function getAndMarkUnClaimedRewards(address user, bool markClaim) \n     internal returns(uint amount){ \n        uint totalRewards = 0; \n        uint curRound = getCurrentRound(); \n \n        if(0 == depositInfos.length){ \n            return 0; \n        } \n \n        // go through to accurate the rewards \n        UserStakedInfo[] storage userStakedInfos = stakedInfos[user]; \n        for(uint i = 0; i < userStakedInfos.length; i++){ \n \n            UserStakedInfo storage userStakedInfo = userStakedInfos[i]; \n \n            int tailRound = INVLID_ROUND; \n \n            if(curRound != userStakedInfo.round){ \n \n                // walk through from the last to the frist \n                for(uint j = depositInfos.length - 1; j >= 0; ){ \n \n                    DepositInfo storage depositInfo = depositInfos[j]; \n \n                    if(depositInfo.round != curRound){ \n \n                        if(depositInfo.round.toInt() == userStakedInfo.claimedRound){ \n                            break; \n                        } \n \n                        // record the tail round \n                        if(tailRound == INVLID_ROUND){ \n                            tailRound = depositInfo.round.toInt(); \n                        } \n \n                        if(depositInfo.totalPower > 0 \n                        && depositInfo.totalDeposit > 0){ \n                            uint share = depositInfo.totalDeposit \n                            .mul(getTokenPower(userStakedInfo.tokenId)) \n                            .div(depositInfo.totalPower); \n \n                            if(markClaim){ \n                                depositInfo.totalClaimed = depositInfo.totalClaimed.add(share); \n                            } \n                            totalRewards += share; \n                        } \n                    } \n \n                    // avoid overflow \n                    if(j > 0){ \n                        j--; \n                    } else { \n                        break; \n                    } \n                } \n \n                if(markClaim){ \n                    userStakedInfo.claimedRound = tailRound; \n                } \n            } \n        } \n \n        return totalRewards; \n    } \n \n    // Claim rewards \n    function claimRewards() public onlyStarted override{ \n        // close round \n        closeRound(); \n \n        uint unClaimedRewards = getAndMarkUnClaimedRewards(msg.sender, true); \n        rewardContract.transfer(msg.sender, unClaimedRewards); \n \n        emit ClaimReward(msg.sender,  unClaimedRewards); \n    } \n \n    // Get staked info \n    function getDepositInfo() public view override returns(DepositInfo[] memory){ \n        return depositInfos; \n    } \n \n    // Get deposit info by page \n    function getDepositInfoByPage(uint pageSt, uint pageSz) public view override \n     returns(DepositInfo[] memory ){ \n        DepositInfo[] memory retDepositInfos; \n        if(pageSt < depositInfos.length){ \n"
        ]
    },
    {
        "PdfName": "BIBToken (BIB) Token_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \nimport \"../interface/ITokenDividendTracker.sol\"; \nimport \"../interface/FreezeTokenInterface.sol\"; \nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol'; \nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol'; \nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\"; \n \ncontract BIBToken is Initializable, ERC20Upgradeable, PausableUpgradeable, OwnableUpgradeable { \n    using SafeMath for uint256; \n    mapping(address => bool) public admin; \n \n    IUniswapV2Router02 public uniswapV2Router; \n    FreezeTokenInterface public freezeToken; \n    address public uniswapV2Pair; \n    address public constant deadAddress = 0x000000000000000000000000000000000000dEaD; \n    address public rewardToken; //rewardToken \n    address public router; \n \n    uint public rewardFee = 6; \n    uint public blackholeFee = 1; \n    uint public liquidityFee = 3; \n \n    bool private swapping; \n \n    ITokenDividendTracker public dividendTracker; \n    address public w0; \n    address public tokenOwner; \n    address public w1; \n    address public w2; \n    address public w3; \n    address public w4; \n    address public w5; \n    address public w6;  \n    address public w7; \n    uint public decimalVal = 1e18; \n \n    uint256 public maxSellTransactionAmount = 10_000_000_000_000 * decimalVal; \n    uint256 public swapTokensAtAmount = 1000_000_000 * decimalVal; \n \n    bool public swapEnabled; \n \n    uint256 initialSupply = 100_000_000_000 * decimalVal; \n \n    // use by default 300,000 gas to process auto-claiming dividends \n    uint256 public gasForProcessing = 300000; \n    bool public allowTransfer; \n \n    mapping(address => bool) public isFromWhiteList; \n    mapping(address => bool) public isToWhiteList; \n    mapping(address => bool) public noProcessList; \n    address private canStopAntibotMeasures; \n    uint256 public antibotEndTime; \n \n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses \n    // could be subject to a maximum transfer amount \n    mapping (address => bool) public automatedMarketMakerPairs; \n \n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress); \n \n    event ExcludeFromFees(address indexed account, bool isExcluded, bool isFrom); \n \n    event NoProcessList(address indexed account, bool noProcess); \n \n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value); \n \n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue); \n    event SwapTokensAtAmountUpdated(uint256 indexed newValue, uint256 indexed oldValue); \n \n    event SwapAndLiquify( \n        uint256 tokensSwapped, \n        uint256 ethReceived, \n        uint256 tokensIntoLiqudity \n    ); \n \n    event SendDividends( \n        uint256 tokensSwapped, \n        uint256 amount \n    ); \n \n    event ProcessedDividendTracker( \n        uint256 iterations, \n        uint256 claims, \n        uint256 lastProcessedIndex, \n        bool indexed automatic, \n        uint256 gas, \n        address indexed processor \n    ); \n \n    function initialize( \n        address _dividendTracker,  \n        address _router, \n        address _rewardToken \n        ) initializer public { \n        tokenOwner = msg.sender; \n        __ERC20_init(\"BIBToken\", \"BIB\"); \n        _mint(tokenOwner, initialSupply); \n        __Pausable_init(); \n        __Ownable_init(); \n \n        require(address(0) != _rewardToken, \"INVLID_REWARD_TOKEN\"); \n        require(address(0) != _dividendTracker, \"INVLID_DIVIDENTTRACKER\"); \n        require(address(0) != _router, \"INVLID_ROUTER\"); \n \n        rewardToken = _rewardToken; \n        dividendTracker = ITokenDividendTracker(_dividendTracker); \n        require(dividendTracker.controller() == address(this), \"Token: The new dividend tracker must \n \n        router = _router; \n \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router); \n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()) \n            .createPair(address(this), _uniswapV2Router.WETH()); \n        uniswapV2Router = _uniswapV2Router; \n        uniswapV2Pair = _uniswapV2Pair; \n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true); \n \n        // exclude from receiving dividends \n        dividendTracker.excludeFromDividends(address(dividendTracker)); \n        dividendTracker.excludeFromDividends(address(this)); \n        dividendTracker.excludeFromDividends(owner()); \n        dividendTracker.excludeFromDividends(deadAddress); \n \n        // exclude from paying fees or having max transaction amount \n        setFeeWhiteList(owner(), true, true); \n        setFeeWhiteList(address(this), true, true); \n        setFeeWhiteList(_uniswapV2Pair, true, true); \n        setFeeWhiteList(deadAddress, true, false); \n \n        swapEnabled = true; \n    } \n \n    function pause() public onlyOwner { \n        _pause(); \n    } \n \n    function unpause() public onlyOwner { \n        _unpause(); \n    } \n \n    function initAddress( \n        address _w1, \n        address _w2, \n        address _w3, \n        address _w4, \n        address _w0, \n        address _w5, \n        address _w6, \n        address _w7) public onlyOwner { \n        require(_w1 != address(0), \"_w1 is not the zero address\"); \n        require(_w2 != address(0), \"_w2 is not the zero address\"); \n        require(_w3 != address(0), \"_w2 is not the zero address\"); \n        require(_w4 != address(0), \"_w4 is not the zero address\"); \n        require(_w0 != address(0), \"_w0 is not the zero address\"); \n        require(_w5 != address(0), \"_w5 is not the zero address\"); \n        require(_w6 != address(0), \"_w6 is not the zero address\"); \n        require(_w7 != address(0), \"_w7 is not the zero address\"); \n \n        w1 = _w1; \n        w2 = _w2; \n        w3 = _w3; \n        w4 = _w4; \n        w0 = _w0; \n        w5 = _w5; \n        w6 = _w6; \n        w7 = _w7; \n        dividendTracker.excludeFromDividends(address(w1)); \n        dividendTracker.excludeFromDividends(address(w2)); \n        dividendTracker.excludeFromDividends(address(w3)); \n        dividendTracker.excludeFromDividends(address(w4)); \n        dividendTracker.excludeFromDividends(address(w0)); \n        dividendTracker.excludeFromDividends(address(w5)); \n        dividendTracker.excludeFromDividends(address(w6)); \n        dividendTracker.excludeFromDividends(address(w7)); \n    } \n \n    receive() external payable {} \n \n    function release() public onlyOwner { \n        transfer(w1,(initialSupply.mul(15).div(100)));  \n        transfer(w2,(initialSupply.mul(25).div(100)));  \n        transfer(w3,(initialSupply.mul(15).div(100))); \n        transfer(w4,(initialSupply.mul(2).div(100))); \n        transfer(w0,(initialSupply.mul(3).div(100)));  \n        transfer(w5,(initialSupply.mul(9).div(100))); \n        transfer(w6,(initialSupply.mul(16).div(100))); \n        transfer(w7,(initialSupply.mul(15).div(100))); \n    } \n \n    function addExcludeFromDividends(address[] memory addrs) public onlyOwner { \n        for (uint256 i = 0; i < addrs.length; i++) { \n            dividendTracker.excludeFromDividends(addrs[i]); \n        } \n    } \n \n    function updateUniswapV2Router(address newAddress) public onlyOwner { \n        require(!isContract(newAddress), \"newAddress is contract address\"); \n        require(newAddress != address(uniswapV2Router), \"Token: The router already has that address\")\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router)); \n        uniswapV2Router = IUniswapV2Router02(newAddress); \n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()) \n            .createPair(address(this), uniswapV2Router.WETH()); \n    } \n \n    function isContract(address addr) public view returns (bool) { \n        uint size; \n        assembly { size := extcodesize(addr) } \n        return size > 0; \n    } \n \n    function setFeeWhiteList(address account, bool excluded, bool isFrom) public onlyOwner { \n        if (isFrom) { \n            require(isFromWhiteList[account] != excluded, \"Token: Account is already the value of 'ex\n            isFromWhiteList[account] = excluded; \n        } else { \n            require(isToWhiteList[account] != excluded, \"Token: Account is already the value of 'excl\n            isToWhiteList[account] = excluded; \n        } \n        emit ExcludeFromFees(account, excluded, isFrom); \n    } \n \n    function setMultipleWhiteList(address[] calldata accounts, bool excluded, bool isFrom) public onl\n        for(uint256 i = 0; i < accounts.length; i++) { \n            setFeeWhiteList(accounts[i], excluded, isFrom); \n        } \n    } \n \n    function setNoProcessList(address account, bool noProcess) public onlyOwner { \n        require(noProcessList[account] != noProcess, \"Token: Account is already the value of 'noProce\n        noProcessList[account] = noProcess; \n        emit NoProcessList(account, noProcess); \n    } \n \n    function setMultipleNoProcessList(address[] calldata accounts, bool noProcess) public onlyOwner {\n        for(uint256 i = 0; i < accounts.length; i++) { \n            setNoProcessList(accounts[i], noProcess); \n        } \n    } \n \n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner { \n        require(pair != uniswapV2Pair, \"Token: The PancakeSwap pair cannot be removed from automatedM\n        _setAutomatedMarketMakerPair(pair, value); \n    } \n \n    function _setAutomatedMarketMakerPair(address pair, bool value) private { \n        require(automatedMarketMakerPairs[pair] != value, \"Token: Automated market maker pair is alre\n        automatedMarketMakerPairs[pair] = value; \n \n        if(value) { \n            dividendTracker.excludeFromDividends(pair); \n        } \n \n        emit SetAutomatedMarketMakerPair(pair, value); \n    } \n \n    function updateGasForProcessing(uint256 newValue) public onlyOwner { \n        require(newValue != gasForProcessing, \"Token: Cannot update gasForProcessing to same value\");\n        emit GasForProcessingUpdated(newValue, gasForProcessing); \n        gasForProcessing = newValue; \n    } \n \n    function updateSwapTokensAtAmount(uint256 newValue) public onlyOwner { \n        require(newValue != swapTokensAtAmount, \"Token: Cannot update swapTokensAtAmount to same valu\n        emit SwapTokensAtAmountUpdated(newValue, swapTokensAtAmount); \n        swapTokensAtAmount = newValue; \n    } \n \n    function setSellFee(uint16 _rewardfee, uint16 _blackhole, uint16 _liquidity) external onlyOwner {\n        rewardFee = _rewardfee; \n        blackholeFee = _blackhole; \n        liquidityFee = _liquidity; \n        require(rewardFee + blackholeFee + liquidityFee <= 10, \"INVALID_FEE_RATIO\"); \n    } \n \n    function updateClaimWait(uint256 claimWait) external onlyOwner { \n        dividendTracker.updateClaimWait(claimWait); \n    } \n \n    function getAccountDividendsInfo(address account) \n    external view returns ( \n        address, \n        int256, \n        int256, \n        uint256, \n        uint256, \n        uint256, \n        uint256, \n        uint256) { \n        return dividendTracker.getAccount(account); \n    } \n \n    function getAccountDividendsInfoAtIndex(uint256 index) \n    external view returns ( \n        address, \n        int256, \n        int256, \n        uint256, \n        uint256, \n        uint256, \n        uint256, \n        uint256) { \n        return dividendTracker.getAccountAtIndex(index); \n    } \n \n    function processDividendTracker(uint256 gas) external onlyOwner { \n    (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas); \n        emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\n    } \n \n    function claim() external { \n        dividendTracker.processAccount(payable(msg.sender), false); \n    } \n \n    function getLastProcessedIndex() external view returns(uint256) { \n        return dividendTracker.getLastProcessedIndex(); \n    } \n \n    function getNumberOfDividendTokenHolders() external view returns(uint256) { \n        return dividendTracker.getNumberOfTokenHolders(); \n    } \n \n    function setW0(address w) external onlyOwner{ \n        require(w != address(0), \"w is not the zero address\"); \n        w0 = payable(w); \n    } \n \n    function setW1Address(address w) public onlyOwner { \n        require(w != address(0), \"w is not the zero address\"); \n        w1 = w; \n    } \n \n    function setW2Address(address w) public onlyOwner { \n        require(w != address(0), \"w is not the zero address\"); \n        w2 = w; \n    } \n \n    function setW3Address(address w) public onlyOwner { \n        require(w != address(0), \"w is not the zero address\"); \n        w3 = w; \n    } \n \n    function setW4Address(address w) public onlyOwner { \n        require(w != address(0), \"w is not the zero address\"); \n        w4 = w; \n    } \n \n    function setW5Address(address w) public onlyOwner { \n        require(w != address(0), \"w is not the zero address\"); \n        w5 = w; \n    } \n \n    function setW6Address(address w) public onlyOwner { \n        require(w != address(0), \"w is not the zero address\"); \n        w6 = w; \n    } \n \n    function setW7Address(address w) public onlyOwner { \n        require(w != address(0), \"w is not the zero address\"); \n        w7 = w; \n    } \n \n    function setFreezeTokenAddress(address _freezeToken) public onlyOwner { \n        require(_freezeToken != address(0), \"_freezeToken is not the zero address\"); \n        freezeToken = FreezeTokenInterface(_freezeToken); \n    } \n \n    function setSwapEnabled(bool value) external onlyOwner{ \n        swapEnabled = value; \n    } \n \n    function setAllowTransfer(bool value) external onlyOwner{ \n        allowTransfer = value; \n    } \n \n    function _checkFreezeAmount(address account, uint256 transferAmount) internal view returns(bool) \n        if (address(freezeToken) == address(0)) { \n            return true; \n        } \n        uint256 freezeAmount = freezeToken.getFreezeAmount(account); \n        return balanceOf(account) - freezeAmount >= transferAmount; \n    } \n \n    function _transfer( \n    address from, \n    address to, \n    uint256 amount \n    ) internal override { \n        require(allowTransfer, \"ERC20: unable to transfer\"); \n        require(from != address(0), \"ERC20: transfer from the zero address\"); \n        require(to != address(0), \"ERC20: transfer to the zero address\"); \n        require (_checkFreezeAmount(from, amount), \"Not enough available balance\"); \n \n        // forbiden bot \n        if (from != owner() && to != owner() && (block.timestamp <= antibotEndTime || antibotEndTime \n            require (to == canStopAntibotMeasures, \"Timerr: Bots can't stop antibot measures\"); \n            if (antibotEndTime == 0) \n                antibotEndTime = block.timestamp + 3; \n        } \n \n        if(amount == 0) { \n            super._transfer(from, to, 0); \n            return; \n        } \n \n        // Check max wallet \n        if (from != owner() && to != uniswapV2Pair){ \n            require (balanceOf(to) + amount <= maxSellTransactionAmount, \" Receiver's wallet balance \n        } \n \n        // check if have sufficient balance \n        uint256 contractTokenBalance = balanceOf(address(this)); \n        bool canSwap = contractTokenBalance >= swapTokensAtAmount; \n        if(swapEnabled && !swapping && !noProcessList[to] && canSwap) { \n            swapping = true; \n            contractTokenBalance = swapTokensAtAmount; \n \n            // part goes to liquadation pool \n            uint256 swapTokens = contractTokenBalance.mul( \n                liquidityFee).div(liquidityFee.add(rewardFee)); \n            swapAndLiquify(swapTokens); \n \n            // part gose to dividens pool \n            swapAndSendDividends(contractTokenBalance.sub(swapTokens)); \n \n            swapping = false; \n        } \n \n        bool takeFee = !swapping; \n \n        // if any account belongs to _isExcludedFromFee account then remove the fee \n        if(isFromWhiteList[from] || isToWhiteList[to]) { \n            takeFee = false; \n        } \n \n        if(takeFee) { \n            uint256 fees = amount.mul(liquidityFee.add(rewardFee)).div(100); \n            uint256 burned = amount.mul(blackholeFee).div(100); \n            amount = amount.sub(fees).sub(burned); \n            super._transfer(from, deadAddress, burned); \n            super._transfer(from, address(this), fees); \n        } \n \n        super._transfer(from, to, amount); \n \n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {} \n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {} \n \n        if(!swapping && !noProcessList[to]) { \n            uint256 gas = gasForProcessing; \n \n            try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 las\n                emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.o\n            }  \n            catch {} \n        } \n    } \n \n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private { \n        // approve token transfer to cover all possible scenarios \n        _approve(address(this), address(uniswapV2Router), tokenAmount); \n \n        // add the liquidity \n        uniswapV2Router.addLiquidityETH{value: ethAmount}( \n            address(this), \n            tokenAmount, \n            0, // slippage is unavoidable \n            0, // slippage is unavoidable \n            deadAddress, \n            block.timestamp \n        ); \n    } \n \n    function swapAndLiquify(uint256 tokens) private{ \n        // split the contract balance into halves, \n        uint256 half = tokens.div(2); \n        uint256 otherHalf = tokens.sub(half); \n        uint256 initialBalance = address(this).balance;//address(this)?? \n \n        // swap tokens for rewardToken \n        swapTokensForEth(half); // <- this breaks the rewardToken -> HATE swap when swap+liquify is t\n \n        // how much rewardToken did we just swap into? \n        uint256 newBalance = address(this).balance.sub(initialBalance); \n \n        // add liquidity to uniswap \n        addLiquidity(otherHalf, newBalance); \n \n        emit SwapAndLiquify(half, newBalance, otherHalf); \n    } \n \n    function swapTokensForEth(uint256 tokenAmount) private { \n        // generate the uniswap pair path of token -> weth \n        address[] memory path = new address[](2); \n        path[0] = address(this); \n        path[1] = uniswapV2Router.WETH(); \n \n        _approve(address(this), address(uniswapV2Router), tokenAmount); \n \n        // make the swap \n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens( \n            tokenAmount, \n            0, // accept any amount of ETH \n            path, \n            address(this), \n            block.timestamp \n        ); \n    } \n \n    function swapTokensForBusd(uint256 tokenAmount) private { \n        address[] memory path = new address[](3); \n        path[0] = address(this); \n        path[1] = uniswapV2Router.WETH(); \n        path[2] = rewardToken; \n \n        _approve(address(this), address(uniswapV2Router), tokenAmount); \n \n        // make the swap \n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens( \n            tokenAmount, \n            0, \n            path, \n            address(this), \n            block.timestamp \n        ); \n    } \n \n    function setAntiBotStopAddress (address account) external onlyOwner { \n        require (account != address(0)); \n        canStopAntibotMeasures = account; \n    } \n \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal whenNotPaused ov\n        super._beforeTokenTransfer(from, to, amount); \n    } \n \n    function swapAndSendDividends(uint256 tokens) private{ \n        swapTokensForBusd(tokens); \n        uint256 dividends = IERC20(rewardToken).balanceOf(address(this)); \n        bool success = IERC20(rewardToken).transfer(address(dividendTracker), dividends); \n \n        if (success) { \n            dividendTracker.distributeDividends(dividends); \n            emit SendDividends(tokens, dividends); \n        } \n    } \n} \n \n",
            "pragma solidity ^0.8.0; \nimport \"@openzeppelin/contracts/finance/VestingWallet.sol\"; \n \ncontract VestingToken is VestingWallet{ \n    constructor( \n        address beneficiaryAddress, \n        uint64 startTimestamp, \n        uint64 durationSeconds \n    ) VestingWallet(beneficiaryAddress, startTimestamp, durationSeconds){} \n \n    receive() external payable override { \n        revert(\"UNSUPPORTED_OP\"); \n    } \n \n    function release() public override { \n        revert(\"UNSUPPORTED_OP\"); \n    } \n} \nAnalysis of audit results\n"
        ]
    },
    {
        "PdfName": "BOT (BOT) Token_audit.pdf",
        "Code": [
            "pragma solidity 0.8.6; \n \ninterface IERC20 { \n \nSummary of audit results\n    function totalSupply() external view returns (uint256); \n \n    /** \n        * @dev Returns the amount of tokens owned by `account`. \n        */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n        * @dev Moves `amount` tokens from the caller's account to `recipient`. \n        * \n        * Returns a boolean value indicating whether the operation succeeded. \n        * \n        * Emits a {Transfer} event. \n        */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n        * @dev Returns the remaining number of tokens that `spender` will be \n        * allowed to spend on behalf of `owner` through {transferFrom}. This is \n        * zero by default. \n        * \n        * This value changes when {approve} or {transferFrom} are called. \n        */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n        * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n        * \n        * Returns a boolean value indicating whether the operation succeeded. \n        * \n        * IMPORTANT: Beware that changing an allowance with this method brings the risk \n        * that someone may use both the old and the new allowance by unfortunate \n        * transaction ordering. One possible solution to mitigate this race \n        * condition is to first reduce the spender's allowance to 0 and set the \n        * desired value afterwards: \n        * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n        * \n        * Emits an {Approval} event. \n        */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n        * @dev Moves `amount` tokens from `sender` to `recipient` using the \n        * allowance mechanism. `amount` is then deducted from the caller's \n        * allowance. \n        * \n        * Returns a boolean value indicating whether the operation succeeded. \n        * \n        * Emits a {Transfer} event. \n        */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n        * @dev Emitted when `value` tokens are moved from one account (`from`) to \n        * another (`to`). \n        * \n        * Note that `value` may be zero. \n        */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n        * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n        * a call to {approve}. `value` is the new allowance. \n        */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n/** \n    * @dev Wrappers over Solidity's arithmetic operations with added overflow \n    * checks. \n    * \n    * Arithmetic operations in Solidity wrap on overflow. This can easily result \n    * in bugs, because programmers usually assume that an overflow raises an \n    * error, which is the standard behavior in high level programming languages. \n    * `SafeMath` restores this intuition by reverting the transaction when an \n    * operation overflows. \n    * \n    * Using this library instead of the unchecked operations eliminates an entire \n    * class of bugs, so it's recommended to use it always. \n    */ \n \nlibrary SafeMath { \n    /** \n        * @dev Returns the addition of two unsigned integers, reverting on \n        * overflow. \n        * \n        * Counterpart to Solidity's `+` operator. \n        * \n        * Requirements: \n        * \n        * - Addition cannot overflow. \n        */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    /** \n        * @dev Returns the subtraction of two unsigned integers, reverting on \n        * overflow (when the result is negative). \n        * \n        * Counterpart to Solidity's `-` operator. \n        * \n        * Requirements: \n        * \n        * - Subtraction cannot overflow. \n        */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    /** \n        * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n        * overflow (when the result is negative). \n        * \n        * Counterpart to Solidity's `-` operator. \n        * \n        * Requirements: \n        * \n        * - Subtraction cannot overflow. \n        */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n        * @dev Returns the multiplication of two unsigned integers, reverting on \n        * overflow. \n        * \n        * Counterpart to Solidity's `*` operator. \n        * \n        * Requirements: \n        * \n        * - Multiplication cannot overflow. \n        */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    /** \n        * @dev Returns the integer division of two unsigned integers. Reverts on \n        * division by zero. The result is rounded towards zero. \n        * \n        * Counterpart to Solidity's `/` operator. Note: this function uses a \n        * `revert` opcode (which leaves remaining gas untouched) while Solidity \n        * uses an invalid opcode to revert (consuming all remaining gas). \n        * \n        * Requirements: \n        * \n        * - The divisor cannot be zero. \n        */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    /** \n        * @dev Returns the integer division of two unsigned integers. Reverts with custom message on \n        * division by zero. The result is rounded towards zero. \n        * \n        * Counterpart to Solidity's `/` operator. Note: this function uses a \n        * `revert` opcode (which leaves remaining gas untouched) while Solidity \n        * uses an invalid opcode to revert (consuming all remaining gas). \n        * \n        * Requirements: \n        * \n        * - The divisor cannot be zero. \n        */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n        * Reverts when dividing by zero. \n        * \n        * Counterpart to Solidity's `%` operator. This function uses a `revert` \n        * opcode (which leaves remaining gas untouched) while Solidity uses an \n        * invalid opcode to revert (consuming all remaining gas). \n        * \n        * Requirements: \n        * \n        * - The divisor cannot be zero. \n        */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    /** \n        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n        * Reverts with custom message when dividing by zero. \n        * \n        * Counterpart to Solidity's `%` operator. This function uses a `revert` \n        * opcode (which leaves remaining gas untouched) while Solidity uses an \n        * invalid opcode to revert (consuming all remaining gas). \n        * \n        * Requirements: \n        * \n        * - The divisor cannot be zero. \n        */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n} \n \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return payable(address(msg.sender)); \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n/** \n    * @dev Collection of functions related to the address type \n    */ \nlibrary Address { \n    /** \n        * @dev Returns true if `account` is a contract. \n        * \n        * [IMPORTANT] \n        * ==== \n        * It is unsafe to assume that an address for which this function returns \n        * false is an externally-owned account (EOA) and not a contract. \n        * \n        * Among others, `isContract` will return false for the following \n        * types of addresses: \n        * \n        *  - an externally-owned account \n        *  - a contract in construction \n        *  - an address where a contract will be created \n        *  - an address where a contract lived, but was destroyed \n        * ==== \n        */ \n    function isContract(address account) internal view returns (bool) { \n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts \n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned \n        // for accounts without code, i.e. `keccak256('')` \n        bytes32 codehash; \n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { codehash := extcodehash(account) } \n        return (codehash != accountHash && codehash != 0x0); \n    } \n \n    /** \n        * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n        * `recipient`, forwarding all available gas and reverting on errors. \n        * \n        * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n        * of certain opcodes, possibly making contracts go over the 2300 gas limit \n        * imposed by `transfer`, making them unable to receive funds via \n        * `transfer`. {sendValue} removes this limitation. \n        * \n        * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n        * \n        * IMPORTANT: because control is transferred to `recipient`, care must be \n        * taken to not create reentrancy vulnerabilities. Consider using \n        * {ReentrancyGuard} or the \n        * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effe\n        */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n        * @dev Performs a Solidity function call using a low level `call`. A \n        * plain`call` is an unsafe replacement for a function call: use this \n        * function instead. \n        * \n        * If `target` reverts with a revert reason, it is bubbled up by this \n        * function (like regular Solidity function calls). \n        * \n        * Returns the raw returned data. To convert to the expected return value, \n        * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi\n        * \n        * Requirements: \n        * \n        * - `target` must be a contract. \n        * - calling `target` with `data` must not revert. \n        * \n        * _Available since v3.1._ \n        */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n        return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n        * `errorMessage` as a fallback revert reason when `target` reverts. \n        * \n        * _Available since v3.1._ \n        */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return _functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n        * but also transferring `value` wei to `target`. \n        * \n        * Requirements: \n        * \n        * - the calling contract must have an ETH balance of at least `value`. \n        * - the called Solidity function must be `payable`. \n        * \n        * _Available since v3.1._ \n        */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n        * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithV\n        * with `errorMessage` as a fallback revert reason when `target` reverts. \n        * \n        * _Available since v3.1._ \n        */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        return _functionCallWithValue(target, data, value, errorMessage); \n    } \n \n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memor\n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data); \n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n/** \n    * @title SafeERC20 \n    * @dev Wrappers around ERC20 operations that throw on failure (when the token \n    * contract returns false). Tokens that return no value (and instead revert or \n    * throw on failure) are also supported, non-reverting calls are assumed to be \n    * successful. \n    * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n    * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n    */ \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n        * @dev Deprecated. This function has issues similar to the ones found in \n        * {IERC20-approve}, and its usage is discouraged. \n        * \n        * Whenever possible, use {safeIncreaseAllowance} and \n        * {safeDecreaseAllowance} instead. \n        */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n        * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relax\n        * on the return value: the return value is optional (but if data is returned, it must not be \n        * @param token The token targeted by the call. \n        * @param data The call data (encoded using abi.encode or one of its variants). \n        */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n/** \n    * @dev Contract module which provides a basic access control mechanism, where \n    * there is an account (an owner) that can be granted exclusive access to \n    * specific functions. \n    * \n    * By default, the owner account will be the one that deploys the contract. This \n    * can later be changed with {transferOwnership}. \n    * \n    * This module is used through inheritance. It will make available the modifier \n    * `onlyOwner`, which can be applied to your functions to restrict their use to \n    * the owner. \n    */ \nabstract contract Ownable is Context { \n    address private _owner; \n    address private _previousOwner; \n    uint256 private _lockTime; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n        * @dev Initializes the contract setting the deployer as the initial owner. \n        */ \n    constructor ()  { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n        * @dev Returns the address of the current owner. \n        */ \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n        * @dev Throws if called by any account other than the owner. \n        */ \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n        /** \n        * @dev Leaves the contract without owner. It will not be possible to call \n        * `onlyOwner` functions anymore. Can only be called by the current owner. \n        * \n        * NOTE: Renouncing ownership will leave the contract without an owner, \n        * thereby removing any functionality that is only available to the owner. \n        */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n        * @dev Transfers ownership of the contract to a new account (`newOwner`). \n        * Can only be called by the current owner. \n        */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n \n    function geUnlockTime() public view returns (uint256) { \n        return _lockTime; \n    } \n \n    //Locks the contract for owner for the amount of time provided \n    function lock(uint256 time) public virtual onlyOwner { \n        _previousOwner = _owner; \n        _owner = address(0); \n        _lockTime = block.timestamp + time; \n        emit OwnershipTransferred(_owner, address(0)); \n    } \n \n    //Unlocks the contract for owner when _lockTime is exceeds \n    function unlock() public virtual { \n        require(_previousOwner == msg.sender, \"You don't have permission to unlock the token contract\n        require(block.timestamp > _lockTime , \"Contract is locked until 7 days\"); \n        emit OwnershipTransferred(_owner, _previousOwner); \n        _owner = _previousOwner; \n    } \n} \n \n// pragma solidity >=0.5.0; \n \ninterface IUniswapV2Factory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n} \n \n \n \n// pragma solidity >=0.6.2; \n \ninterface IUniswapV2Router01 { \n    function factory() external pure returns (address); \n    function WETH() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityETH( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityETH( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountETH); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityETHWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountETH); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadl\n        external \n        payable \n        returns (uint[] memory amounts); \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline\n        external \n        payable \n        returns (uint[] memory amounts); \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n} \n \n \n \n// pragma solidity >=0.6.2; \n \ninterface IUniswapV2Router02 is IUniswapV2Router01 { \n    function removeLiquidityETHSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountETH); \n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountETH); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForETHSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n} \n \n \ncontract Token is Context, IERC20, Ownable { \n    using SafeMath for uint256; \n    using Address for address; \n    using SafeERC20 for IERC20; \n \n    address dead = 0x000000000000000000000000000000000000dEaD; \n \n    uint8 public maxLiqFee = 10; \n    uint8 public maxTaxFee = 10; \n    uint8 public maxBurnFee = 10; \n    uint8 public maxWalletFee = 10; \n    uint8 public maxBuybackFee = 10; \n    uint8 public minMxTxPercentage = 1; \n    uint8 public minMxWalletPercentage = 1; \n \n    mapping (address => uint256) private _rOwned; \n    mapping (address => uint256) private _tOwned; \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    mapping (address => bool) private _isExcludedFromFee; \n \n    mapping (address => bool) private _isExcluded; \n    address[] private _excluded; \n \n    address public router = 0x10ED43C718714eb63d5aA57B78B54704E256024E; \n    //address public router = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1; \n \n    uint256 private constant MAX = ~uint256(0); \n    uint256 public _tTotal; \n    uint256 private _rTotal; \n    uint256 private _tFeeTotal; \n \n    bool public mintedByMudra = true; \n \n    string public _name; \n    string public _symbol; \n    uint8 private _decimals; \n \n    uint8 public _taxFee = 0; \n    uint8 private _previousTaxFee = _taxFee; \n \n    uint8 public _liquidityFee = 0; \n    uint8 private _previousLiquidityFee = _liquidityFee; \n \n    uint8 public _burnFee = 0; \n    uint8 private _previousBurnFee = _burnFee; \n \n    uint8 public _walletFee = 0; \n    uint8 private _previousWalletFee = _walletFee; \n \n    uint8 public _buybackFee = 0; \n    uint8 private _previousBuybackFee = _buybackFee; \n \n    IUniswapV2Router02 public immutable pcsV2Router; \n    address public immutable pcsV2Pair; \n    address payable public feeWallet; \n \n    bool inSwapAndLiquify; \n    bool public swapAndLiquifyEnabled = true;     \n \n    uint256 public _maxTxAmount; \n    uint256 public _maxWalletAmount; \n    uint256 public numTokensSellToAddToLiquidity;     \n    uint256 private buyBackUpperLimit = 1 * 10**18; \n \n    event SwapAndLiquifyEnabledUpdated(bool enabled); \n    event SwapAndLiquify( \n        uint256 tokensSwapped, \n        uint256 ethReceived, \n        uint256 tokensIntoLiqudity \n    ); \n \n    modifier lockTheSwap { \n        inSwapAndLiquify = true; \n        _; \n        inSwapAndLiquify = false; \n    } \n \n    constructor (address tokenOwner,string memory tokenName, \n        string memory tokenSymbol, uint8 decimal, uint256 amountOfTokenWei, \n        uint8 setMxTxPer, uint8 setMxWalletPer, \n        address payable _feeWallet \n        )  { \n \n        _name = tokenName; \n        _symbol = tokenSymbol; \n        _decimals = decimal; \n        _tTotal = amountOfTokenWei; \n        _rTotal = (MAX - (MAX % _tTotal)); \n \n        _rOwned[tokenOwner] = _rTotal; \n \n        feeWallet = _feeWallet; \n \n \n        _maxTxAmount = _tTotal.mul(setMxTxPer).div( \n            10**2 \n        ); \n        _maxWalletAmount = _tTotal.mul(setMxWalletPer).div( \n            10**2 \n        ); \n \n        numTokensSellToAddToLiquidity = amountOfTokenWei.mul(1).div(1000); \n \n        IUniswapV2Router02 _pcsV2Router = IUniswapV2Router02(router); \n            // Create a uniswap pair for this new token \n        pcsV2Pair = IUniswapV2Factory(_pcsV2Router.factory()) \n            .createPair(address(this), _pcsV2Router.WETH()); \n \n        // set the rest of the contract variables \n        pcsV2Router = _pcsV2Router; \n \n        _isExcludedFromFee[tokenOwner] = true; \n        _isExcludedFromFee[address(this)] = true; \n \n        emit Transfer(address(0), tokenOwner, _tTotal); \n    } \n \n    function name() public view returns (string memory) { \n        return _name; \n    } \n \n    function symbol() public view returns (string memory) { \n        return _symbol; \n    } \n \n    function decimals() public view returns (uint8) { \n        return _decimals; \n    } \n \n    function totalSupply() public view override returns (uint256) { \n        return _tTotal; \n    } \n \n    function balanceOf(address account) public view override returns (uint256) { \n        if (_isExcluded[account]) return _tOwned[account]; \n        return tokenFromReflection(_rOwned[account]); \n    } \n \n    function transfer(address recipient, uint256 amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    function allowance(address owner, address spender) public view override returns (uint256) { \n        return _allowances[owner][spender]; \n    } \n \n    function approve(address spender, uint256 amount) public override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    function transferFrom(address sender, address recipient, uint256 amount) public override returns \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    function isExcludedFromReward(address account) public view returns (bool) { \n        return _isExcluded[account]; \n    } \n \n    function totalFees() public view returns (uint256) { \n        return _tFeeTotal; \n    } \n \n    function deliver(uint256 tAmount) public { \n        address sender = _msgSender(); \n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\"); \n        (uint256 rAmount,,,,,) = _getValues(tAmount); \n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _rTotal = _rTotal.sub(rAmount); \n        _tFeeTotal = _tFeeTotal.add(tAmount); \n    } \n \n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256\n        require(tAmount <= _tTotal, \"Amt must be less than supply\"); \n        if (!deductTransferFee) { \n            (uint256 rAmount,,,,,) = _getValues(tAmount); \n            return rAmount; \n        } else { \n            (,uint256 rTransferAmount,,,,) = _getValues(tAmount); \n            return rTransferAmount; \n        } \n    } \n \n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) { \n        require(rAmount <= _rTotal, \"Amt must be less than tot refl\"); \n        uint256 currentRate =  _getRate(); \n        return rAmount.div(currentRate); \n    } \n \n    function excludeFromReward(address account) public onlyOwner() { \n        require(!_isExcluded[account], \"Account is already excluded from reward\"); \n        if(_rOwned[account] > 0) { \n            _tOwned[account] = tokenFromReflection(_rOwned[account]); \n        } \n        _isExcluded[account] = true; \n        _excluded.push(account); \n    } \n \n    function includeInReward(address account) external onlyOwner() { \n        require(_isExcluded[account], \"Already excluded\"); \n        for (uint256 i = 0; i < _excluded.length; i++) { \n            if (_excluded[i] == account) { \n                _excluded[i] = _excluded[_excluded.length - 1]; \n                _tOwned[account] = 0; \n                _isExcluded[account] = false; \n                _excluded.pop(); \n                break; \n            } \n        } \n    } \n \n \n    function excludeFromFee(address account) public onlyOwner { \n        _isExcludedFromFee[account] = true; \n    } \n \n    function includeInFee(address account) public onlyOwner { \n        _isExcludedFromFee[account] = false; \n    } \n \n    function setAllFeePercent(uint8 taxFee, uint8 liquidityFee, uint8 burnFee, uint8 walletFee, uint8 \n        require(taxFee >= 0 && taxFee <=maxTaxFee,\"TF err\"); \n        require(liquidityFee >= 0 && liquidityFee <=maxLiqFee,\"LF err\"); \n        require(burnFee >= 0 && burnFee <=maxBurnFee,\"BF err\"); \n        require(walletFee >= 0 && walletFee <=maxWalletFee,\"WF err\"); \n        require(buybackFee >= 0 && buybackFee <=maxBuybackFee,\"BBF err\"); \n        _taxFee = taxFee; \n        _liquidityFee = liquidityFee; \n        _burnFee = burnFee; \n        _buybackFee = buybackFee; \n        _walletFee = walletFee; \n    } \n \n    function buyBackUpperLimitAmount() public view returns (uint256) { \n        return buyBackUpperLimit; \n    } \n \n    function setBuybackUpperLimit(uint256 buyBackLimit) external onlyOwner() { \n        buyBackUpperLimit = buyBackLimit * 10**18; \n    } \n \n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() { \n        require(maxTxPercent >= minMxTxPercentage && maxTxPercent <=100,\"err\"); \n        _maxTxAmount = _tTotal.mul(maxTxPercent).div( \n            10**2 \n        ); \n    } \n \n    function setMaxWalletPercent(uint256 maxWalletPercent) external onlyOwner() { \n        require(maxWalletPercent >= minMxWalletPercentage && maxWalletPercent <=100,\"err\"); \n        _maxWalletAmount = _tTotal.mul(maxWalletPercent).div( \n            10**2 \n        ); \n    } \n \n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner { \n        swapAndLiquifyEnabled = _enabled; \n        emit SwapAndLiquifyEnabledUpdated(_enabled); \n    } \n \n    function setFeeWallet(address payable newFeeWallet) external onlyOwner { \n        require(newFeeWallet != address(0), \"ZERO ADDRESS\"); \n        feeWallet = newFeeWallet; \n    } \n \n \n        //to recieve ETH from pcsV2Router when swaping \n    receive() external payable {} \n \n    function _reflectFee(uint256 rFee, uint256 tFee) private { \n        _rTotal = _rTotal.sub(rFee); \n        _tFeeTotal = _tFeeTotal.add(tFee); \n    } \n \n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, ui\n        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount); \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquid\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity); \n    } \n \n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) { \n        uint256 tFee = calculateTaxFee(tAmount); \n        uint256 tLiquidity = calculateLiquidityFee(tAmount); \n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity); \n        return (tTransferAmount, tFee, tLiquidity); \n    } \n \n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) priv\n        uint256 rAmount = tAmount.mul(currentRate); \n        uint256 rFee = tFee.mul(currentRate); \n        uint256 rLiquidity = tLiquidity.mul(currentRate); \n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity); \n        return (rAmount, rTransferAmount, rFee); \n    } \n \n    function _getRate() private view returns(uint256) { \n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply(); \n        return rSupply.div(tSupply); \n    } \n \n    function _getCurrentSupply() private view returns(uint256, uint256) { \n        uint256 rSupply = _rTotal; \n        uint256 tSupply = _tTotal;       \n        for (uint256 i = 0; i < _excluded.length; i++) { \n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]); \n            tSupply = tSupply.sub(_tOwned[_excluded[i]]); \n        } \n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal); \n        return (rSupply, tSupply); \n    } \n \n    function _takeLiquidity(uint256 tLiquidity) private { \n        uint256 currentRate =  _getRate(); \n        uint256 rLiquidity = tLiquidity.mul(currentRate); \n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity); \n        if(_isExcluded[address(this)]) \n            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity); \n    } \n \n    function calculateTaxFee(uint256 _amount) private view returns (uint256) { \n        return _amount.mul(_taxFee).div( \n            10**2 \n        ); \n    } \n \n    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) { \n        return _amount.mul(_liquidityFee + _burnFee + _walletFee + _buybackFee).div( \n            10**2 \n        ); \n    } \n \n    function removeAllFee() private { \n        if(_taxFee == 0 && _liquidityFee == 0 && _burnFee == 0 && _walletFee == 0 && _buybackFee == 0\n \n        _previousTaxFee = _taxFee; \n        _previousLiquidityFee = _liquidityFee; \n        _previousBurnFee = _burnFee; \n        _previousWalletFee = _walletFee; \n        _previousBuybackFee = _buybackFee; \n \n        _taxFee = 0; \n        _liquidityFee = 0; \n        _burnFee = 0; \n        _walletFee = 0; \n        _buybackFee = 0; \n    } \n \n    function restoreAllFee() private { \n        _taxFee = _previousTaxFee; \n        _liquidityFee = _previousLiquidityFee; \n        _burnFee = _previousBurnFee; \n        _walletFee = _previousWalletFee; \n        _buybackFee = _previousBuybackFee; \n    } \n \n    function isExcludedFromFee(address account) public view returns(bool) { \n        return _isExcludedFromFee[account]; \n    } \n \n    function _approve(address owner, address spender, uint256 amount) private { \n        require(owner != address(0), \"ERC20: approve from zero address\"); \n        require(spender != address(0), \"ERC20: approve to zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    function _transfer( \n        address from, \n        address to, \n        uint256 amount \n    ) private { \n        require(from != address(0), \"ERC20: transfer from zero address\"); \n        require(to != address(0), \"ERC20: transfer to zero address\"); \n        require(amount > 0, \"Transfer amount must be greater than zero\"); \n        if(from != owner() && to != owner()) \n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\"); \n \n        if(from != owner() && to != owner() && to != address(0) && to != dead && to != pcsV2Pair){ \n            uint256 contractBalanceRecepient = balanceOf(to); \n            require(contractBalanceRecepient + amount <= _maxWalletAmount, \"Exceeds maximum wallet am\n        } \n        // is the token balance of this contract address over the min number of \n        // tokens that we need to initiate a swap + liquidity lock? \n        // also, don't get caught in a circular liquidity event. \n        // also, don't swap & liquify if sender is uniswap pair. \n        uint256 contractTokenBalance = balanceOf(address(this)); \n \n        if(contractTokenBalance >= _maxTxAmount) \n        { \n            contractTokenBalance = _maxTxAmount; \n        } \n \n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity; \n        if ( \n            !inSwapAndLiquify && \n            to == pcsV2Pair && \n            swapAndLiquifyEnabled \n        ) { \n            if(overMinTokenBalance){ \n                contractTokenBalance = numTokensSellToAddToLiquidity; \n                //add liquidity \n                swapAndLiquify(contractTokenBalance); \n            } \n            if(_buybackFee !=0){ \n                uint256 balance = address(this).balance; \n                if (balance > uint256(1 * 10**18)) { \n \n                    if (balance > buyBackUpperLimit) \n                        balance = buyBackUpperLimit; \n \n                    buyBackTokens(balance.div(100)); \n                } \n            } \n \n        } \n \n \n        //indicates if fee should be deducted from transfer \n        bool takeFee = true; \n \n        //if any account belongs to _isExcludedFromFee account then remove the fee \n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){ \n            takeFee = false; \n        } \n \n        //transfer amount, it will take tax, burn, liquidity fee \n        _tokenTransfer(from,to,amount,takeFee); \n    } \n \n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap { \n        //This needs to be distributed among burn, wallet and liquidity \n        //burn \n        uint8 totFee  = _burnFee + _walletFee + _liquidityFee + _buybackFee;  \n        uint256 spentAmount = 0; \n        uint256 totSpentAmount = 0; \n        if(_burnFee != 0){ \n            spentAmount  = contractTokenBalance.div(totFee).mul(_burnFee); \n            _tokenTransferNoFee(address(this), dead, spentAmount); \n            totSpentAmount = spentAmount; \n        } \n \n        if(_walletFee != 0){ \n            spentAmount = contractTokenBalance.div(totFee).mul(_walletFee); \n            _tokenTransferNoFee(address(this), feeWallet, spentAmount); \n            totSpentAmount = totSpentAmount + spentAmount; \n        } \n \n        if(_buybackFee != 0){ \n            spentAmount = contractTokenBalance.div(totFee).mul(_buybackFee); \n            swapTokensForBNB(spentAmount); \n            totSpentAmount = totSpentAmount + spentAmount; \n        } \n \n        if(_liquidityFee != 0){ \n            contractTokenBalance = contractTokenBalance.sub(totSpentAmount); \n \n            // split the contract balance into halves \n            uint256 half = contractTokenBalance.div(2); \n            uint256 otherHalf = contractTokenBalance.sub(half); \n \n            // capture the contract's current ETH balance. \n            // this is so that we can capture exactly the amount of ETH that the \n            // swap creates, and not make the liquidity event include any ETH that \n            // has been manually sent to the contract \n            uint256 initialBalance = address(this).balance; \n \n            // swap tokens for ETH \n            swapTokensForBNB(half); // <- this breaks the ETH -> HATE swap when swap+liquify is trigg\n \n            // how much ETH did we just swap into? \n            uint256 newBalance = address(this).balance.sub(initialBalance); \n \n            // add liquidity to uniswap \n            addLiquidity(otherHalf, newBalance); \n \n            emit SwapAndLiquify(half, newBalance, otherHalf); \n        } \n \n    } \n \n    function buyBackTokens(uint256 amount) private lockTheSwap { \n        if (amount > 0) { \n            swapBNBForTokens(amount); \n        } \n    } \n \n    function swapTokensForBNB(uint256 tokenAmount) private { \n        // generate the uniswap pair path of token -> weth \n        address[] memory path = new address[](2); \n        path[0] = address(this); \n        path[1] = pcsV2Router.WETH(); \n \n        _approve(address(this), address(pcsV2Router), tokenAmount); \n \n        // make the swap \n        pcsV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens( \n            tokenAmount, \n            0, // accept any amount of ETH \n            path, \n            address(this), \n            block.timestamp \n        ); \n    } \n \n    function swapBNBForTokens(uint256 amount) private { \n        // generate the uniswap pair path of token -> weth \n        address[] memory path = new address[](2); \n        path[0] = pcsV2Router.WETH(); \n        path[1] = address(this); \n \n      // make the swap \n        pcsV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}( \n            0, // accept any amount of Tokens \n            path, \n            dead, // Burn address \n            block.timestamp.add(300) \n        );         \n    } \n \n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private { \n        // approve token transfer to cover all possible scenarios \n        _approve(address(this), address(pcsV2Router), tokenAmount); \n \n        // add the liquidity \n        pcsV2Router.addLiquidityETH{value: ethAmount}( \n            address(this), \n            tokenAmount, \n            0, // slippage is unavoidable \n            0, // slippage is unavoidable \n            dead, \n            block.timestamp \n        ); \n    } \n \n    //this method is responsible for taking all fee, if takeFee is true \n    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n        if(!takeFee) \n            removeAllFee(); \n \n        if (_isExcluded[sender] && !_isExcluded[recipient]) { \n            _transferFromExcluded(sender, recipient, amount); \n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n            _transferToExcluded(sender, recipient, amount); \n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n            _transferStandard(sender, recipient, amount); \n        } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n            _transferBothExcluded(sender, recipient, amount); \n        } else { \n            _transferStandard(sender, recipient, amount); \n        } \n \n        if(!takeFee) \n            restoreAllFee(); \n    } \n \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFe\n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n        _takeLiquidity(tLiquidity); \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    } \n \n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFe\n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);            \n        _takeLiquidity(tLiquidity); \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    } \n \n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFe\n        _tOwned[sender] = _tOwned[sender].sub(tAmount); \n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);    \n        _takeLiquidity(tLiquidity); \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    } \n \n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFe\n        _tOwned[sender] = _tOwned[sender].sub(tAmount); \n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);         \n        _takeLiquidity(tLiquidity); \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    } \n \n    function _tokenTransferNoFee(address sender, address recipient, uint256 amount) private { \n        uint256 currentRate =  _getRate();   \n        uint256 rAmount = amount.mul(currentRate);    \n \n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rAmount);  \n \n        if (_isExcluded[sender]) { \n            _tOwned[sender] = _tOwned[sender].sub(amount); \n        }  \n        if (_isExcluded[recipient]) { \n            _tOwned[recipient] = _tOwned[recipient].add(amount); \n        }  \n        emit Transfer(sender, recipient, amount); \n    } \n \n    function recoverBEP20(address tokenAddress, uint256 tokenAmount) public onlyOwner { \n        // do not allow recovering self token \n        require(tokenAddress != address(this), \"Self withdraw\"); \n"
        ]
    },
    {
        "PdfName": "Compound Farm_audit.pdf",
        "Code": [
            "pragma solidity ^0.7.0; \n \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n//  \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n//  \n/** \n * @dev Library for managing \n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive \n * types. \n * \n * Sets have the following properties: \n * \n * - Elements are added, removed, and checked for existence in constant time \n * (O(1)). \n * - Elements are enumerated in O(n). No guarantees are made on the ordering. \n * \n * \n * contract Example { \n *     // Add the library methods \n *     using EnumerableSet for EnumerableSet.AddressSet; \n * \n *     // Declare a set state variable \n *     EnumerableSet.AddressSet private mySet; \n * } \n *  \n * \n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) \n * and `uint256` (`UintSet`) are supported. \n */ \nlibrary EnumerableSet { \n    // To implement this library for multiple types with as little code \n    // repetition as possible, we write it in terms of a generic Set type with \n    // bytes32 values. \n    // The Set implementation uses private functions, and user-facing \n    // implementations (such as AddressSet) are just wrappers around the \n    // underlying Set. \n    // This means that we can only create new EnumerableSets for types that fit \n    // in bytes32. \n \n    struct Set { \n        // Storage of set values \n        bytes32[] _values; \n \n        // Position of the value in the `values` array, plus 1 because index 0 \n        // means a value is not in the set. \n        mapping (bytes32 => uint256) _indexes; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function _add(Set storage set, bytes32 value) private returns (bool) { \n        if (!_contains(set, value)) { \n            set._values.push(value); \n            // The value is stored at length-1, but we add 1 to all indexes \n            // and use 0 as a sentinel value \n            set._indexes[value] = set._values.length; \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function _remove(Set storage set, bytes32 value) private returns (bool) { \n        // We read and store the value's index to prevent multiple reads from the same storage slot \n        uint256 valueIndex = set._indexes[value]; \n \n        if (valueIndex != 0) { // Equivalent to contains(set, value) \n            // To delete an element from the _values array in O(1), we swap the element to delete wit\n            // the array, and then remove the last element (sometimes called as 'swap and pop'). \n            // This modifies the order of the array, as noted in {at}. \n \n            uint256 toDeleteIndex = valueIndex - 1; \n            uint256 lastIndex = set._values.length - 1; \n \n            // When the value to delete is the last one, the swap operation is unnecessary. However, \n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' stateme\n \n            bytes32 lastvalue = set._values[lastIndex]; \n \n            // Move the last value to the index where the value to delete is \n            set._values[toDeleteIndex] = lastvalue; \n            // Update the index for the moved value \n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based \n \n            // Delete the slot where the moved value was stored \n            set._values.pop(); \n \n            // Delete the index for the deleted slot \n            delete set._indexes[value]; \n \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function _contains(Set storage set, bytes32 value) private view returns (bool) { \n        return set._indexes[value] != 0; \n    } \n \n    /** \n     * @dev Returns the number of values on the set. O(1). \n     */ \n    function _length(Set storage set) private view returns (uint256) { \n        return set._values.length; \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function _at(Set storage set, uint256 index) private view returns (bytes32) { \n        require(set._values.length > index, \"EnumerableSet: index out of bounds\"); \n        return set._values[index]; \n    } \n \n    // Bytes32Set \n \n    struct Bytes32Set { \n        Set _inner; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) { \n        return _add(set._inner, value); \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) { \n        return _remove(set._inner, value); \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) { \n        return _contains(set._inner, value); \n    } \n \n    /** \n     * @dev Returns the number of values in the set. O(1). \n     */ \n    function length(Bytes32Set storage set) internal view returns (uint256) { \n        return _length(set._inner); \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) { \n        return _at(set._inner, index); \n    } \n \n    // AddressSet \n \n    struct AddressSet { \n        Set _inner; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function add(AddressSet storage set, address value) internal returns (bool) { \n        return _add(set._inner, bytes32(uint256(uint160(value)))); \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function remove(AddressSet storage set, address value) internal returns (bool) { \n        return _remove(set._inner, bytes32(uint256(uint160(value)))); \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function contains(AddressSet storage set, address value) internal view returns (bool) { \n        return _contains(set._inner, bytes32(uint256(uint160(value)))); \n    } \n \n    /** \n     * @dev Returns the number of values in the set. O(1). \n     */ \n    function length(AddressSet storage set) internal view returns (uint256) { \n        return _length(set._inner); \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function at(AddressSet storage set, uint256 index) internal view returns (address) { \n        return address(uint160(uint256(_at(set._inner, index)))); \n    } \n \n \n    // UintSet \n \n    struct UintSet { \n        Set _inner; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function add(UintSet storage set, uint256 value) internal returns (bool) { \n        return _add(set._inner, bytes32(value)); \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function remove(UintSet storage set, uint256 value) internal returns (bool) { \n        return _remove(set._inner, bytes32(value)); \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function contains(UintSet storage set, uint256 value) internal view returns (bool) { \n        return _contains(set._inner, bytes32(value)); \n    } \n \n    /** \n     * @dev Returns the number of values on the set. O(1). \n     */ \n    function length(UintSet storage set) internal view returns (uint256) { \n        return _length(set._inner); \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function at(UintSet storage set, uint256 index) internal view returns (uint256) { \n        return uint256(_at(set._inner, index)); \n    } \n} \n \n//  \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n//  \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n//  \n/** \n * @dev Implementation of the {IERC20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of ERC20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IERC20-approve}. \n */ \ncontract ERC20 is Context, IERC20 { \n    using SafeMath for uint256; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n     * a default value of 18. \n     * \n     * To select a different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    constructor (string memory name_, string memory symbol_) public { \n        _name = name_; \n        _symbol = symbol_; \n        _decimals = 18; \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public view virtual returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public view virtual returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a balance of `505` tokens should \n     * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a value of 18, imitating the relationship between \n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is \n     * called. \n     * \n     * NOTE: This information is only used for _display_ purposes: it in \n     * no way affects any of the arithmetic of the contract, including \n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */ \n    function decimals() public view virtual returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */ \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */ \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function allowance(address owner, address spender) public view virtual override returns (uint256) \n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {ERC20}. \n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the total supply. \n     * \n     * Emits a {Transfer} event with `from` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `to` cannot be the zero address. \n     */ \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens. \n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Sets {decimals} to a value other than the default one of 18. \n     * \n     * WARNING: This function should only be called from the constructor. Most \n     * applications that interact with token contracts will not expect \n     * {decimals} to ever change, and may work incorrectly if it does. \n     */ \n    function _setupDecimals(uint8 decimals_) internal virtual { \n        _decimals = decimals_; \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * will be to transferred to `to`. \n     * - when `from` is zero, `amount` tokens will be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n     * - `from` and `to` are never both zero. \n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n} \n \n//  \nabstract contract DelegateERC20 is ERC20 { \n    using SafeMath for uint256; \n \n    mapping (address => address) internal _delegates; \n \n    /// @notice A checkpoint for marking number of votes from a given block \n    struct Checkpoint { \n        uint32 fromBlock; \n        uint256 votes; \n    } \n \n    /// @notice A record of votes checkpoints for each account, by index \n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints; \n \n    /// @notice The number of checkpoints for each account \n    mapping (address => uint32) public numCheckpoints; \n \n    /// @notice The EIP-712 typehash for the contract's domain \n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,add\n \n    /// @notice The EIP-712 typehash for the delegation struct used by the contract \n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 non\n \n    /// @notice A record of states for signing / validating signatures \n    mapping (address => uint) public nonces; \n \n \n    // support delegates mint \n    function _mint(address account, uint256 amount) internal override virtual { \n        super._mint(account, amount); \n \n        // add delegates to the minter \n        _moveDelegates(address(0), _delegates[account], amount); \n    } \n \n \n    function _transfer(address sender, address recipient, uint256 amount) internal override virtual { \n        super._transfer(sender, recipient, amount); \n        _moveDelegates(_delegates[sender], _delegates[recipient], amount); \n    } \n \n \n    /** \n    * @notice Delegate votes from `msg.sender` to `delegatee` \n    * @param delegatee The address to delegate votes to \n    */ \n    function delegate(address delegatee) external { \n        return _delegate(msg.sender, delegatee); \n    } \n \n    /** \n     * @notice Delegates votes from signatory to `delegatee` \n     * @param delegatee The address to delegate votes to \n     * @param nonce The contract state required to match the signature \n     * @param expiry The time at which to expire the signature \n     * @param v The recovery byte of the signature \n     * @param r Half of the ECDSA signature pair \n     * @param s Half of the ECDSA signature pair \n     */ \n    function delegateBySig( \n        address delegatee, \n        uint nonce, \n        uint expiry, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) \n    external \n    { \n        bytes32 domainSeparator = keccak256( \n            abi.encode( \n                DOMAIN_TYPEHASH, \n                keccak256(bytes(name())), \n                getChainId(), \n                address(this) \n            ) \n        ); \n \n        bytes32 structHash = keccak256( \n            abi.encode( \n                DELEGATION_TYPEHASH, \n                delegatee, \n                nonce, \n                expiry \n            ) \n        ); \n \n        bytes32 digest = keccak256( \n            abi.encodePacked( \n                \"\\x19\\x01\", \n                domainSeparator, \n                structHash \n            ) \n        ); \n \n        address signatory = ecrecover(digest, v, r, s); \n        require(signatory != address(0), \"CMPToken::delegateBySig: invalid signature\"); \n        require(nonce == nonces[signatory]++, \"CMPToken::delegateBySig: invalid nonce\"); \n        require(block.timestamp <= expiry, \"CMPToken::delegateBySig: signature expired\"); \n        return _delegate(signatory, delegatee); \n    } \n \n    /** \n     * @notice Gets the current votes balance for `account` \n     * @param account The address to get votes balance \n     * @return The number of current votes for `account` \n     */ \n    function getCurrentVotes(address account) \n    external \n    view \n    returns (uint256) \n    { \n        uint32 nCheckpoints = numCheckpoints[account]; \n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0; \n    } \n \n    /** \n     * @notice Determine the prior number of votes for an account as of a block number \n     * @dev Block number must be a finalized block or else this function will revert to prevent misin\n     * @param account The address of the account to check \n     * @param blockNumber The block number to get the vote balance at \n     * @return The number of votes the account had as of the given block \n     */ \n    function getPriorVotes(address account, uint blockNumber) \n    external \n    view \n    returns (uint256) \n    { \n        require(blockNumber < block.number, \"CMPToken::getPriorVotes: not yet determined\"); \n \n        uint32 nCheckpoints = numCheckpoints[account]; \n        if (nCheckpoints == 0) { \n            return 0; \n        } \n \n        // First check most recent balance \n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) { \n            return checkpoints[account][nCheckpoints - 1].votes; \n        } \n \n        // Next check implicit zero balance \n        if (checkpoints[account][0].fromBlock > blockNumber) { \n            return 0; \n        } \n \n        uint32 lower = 0; \n        uint32 upper = nCheckpoints - 1; \n        while (upper > lower) { \n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow \n            Checkpoint memory cp = checkpoints[account][center]; \n            if (cp.fromBlock == blockNumber) { \n                return cp.votes; \n            } else if (cp.fromBlock < blockNumber) { \n                lower = center; \n            } else { \n                upper = center - 1; \n            } \n        } \n        return checkpoints[account][lower].votes; \n    } \n \n    function _delegate(address delegator, address delegatee) \n    internal \n    { \n        address currentDelegate = _delegates[delegator]; \n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying balances (not scale\n        _delegates[delegator] = delegatee; \n \n        _moveDelegates(currentDelegate, delegatee, delegatorBalance); \n \n        emit DelegateChanged(delegator, currentDelegate, delegatee); \n    } \n \n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal { \n        if (srcRep != dstRep && amount > 0) { \n            if (srcRep != address(0)) { \n                // decrease old representative \n                uint32 srcRepNum = numCheckpoints[srcRep]; \n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0; \n                uint256 srcRepNew = srcRepOld.sub(amount); \n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew); \n            } \n \n            if (dstRep != address(0)) { \n                // increase new representative \n                uint32 dstRepNum = numCheckpoints[dstRep]; \n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0; \n                uint256 dstRepNew = dstRepOld.add(amount); \n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew); \n            } \n        } \n    } \n \n    function _writeCheckpoint( \n        address delegatee, \n        uint32 nCheckpoints, \n        uint256 oldVotes, \n        uint256 newVotes \n    ) \n    internal \n    { \n        uint32 blockNumber = safe32(block.number, \"CMPToken::_writeCheckpoint: block number exceeds 3\n \n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) { \n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes; \n        } else { \n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes); \n            numCheckpoints[delegatee] = nCheckpoints + 1; \n        } \n \n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes); \n    } \n \n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) { \n        require(n < 2**32, errorMessage); \n        return uint32(n); \n    } \n \n    function getChainId() internal pure returns (uint) { \n        uint256 chainId; \n        assembly { chainId := chainid() } \n \n        return chainId; \n    } \n \n    /// @notice An event thats emitted when an account changes its delegate \n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed to\n \n    /// @notice An event thats emitted when a delegate account's vote balance changes \n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance); \n \n} \n \n \ncontract CMPToken is DelegateERC20, Ownable { \n    using SafeMath for uint256; \n \n    uint256 private constant preMineSupply = 10000000 * 1e18; \n    uint256 private constant maxSupply = 200000000 * 1e18;     // the total supply \n \n    using EnumerableSet for EnumerableSet.AddressSet; \n    EnumerableSet.AddressSet private _minters; \n \n    constructor() public ERC20(\"Compound Farming Token\", \"CMP\"){ \n        _mint(msg.sender, preMineSupply); \n    } \n \n    // mint with max supply \n    function mint(address _to, uint256 _amount) public onlyMinter returns (bool) { \n        if (_amount.add(totalSupply()) > maxSupply) { \n            return false; \n        } \n        _mint(_to, _amount); \n        return true; \n    } \n \n    function addMinter(address _addMinter) public onlyOwner returns (bool) { \n        require(_addMinter != address(0), \"CMPToken: _addMinter is the zero address\"); \n        return EnumerableSet.add(_minters, _addMinter); \n    } \n \n    function delMinter(address _delMinter) public onlyOwner returns (bool) { \n        require(_delMinter != address(0), \"CMPToken: _delMinter is the zero address\"); \n        return EnumerableSet.remove(_minters, _delMinter); \n    } \n \nFarm.sol\n    function getMinterLength() public view returns (uint256) { \n        return EnumerableSet.length(_minters); \n    } \n \n    function isMinter(address account) public view returns (bool) { \n        return EnumerableSet.contains(_minters, account); \n    } \n \n    function getMinter(uint256 _index) public view onlyOwner returns (address){ \n        require(_index <= getMinterLength() - 1, \"CMPToken: index out of bounds\"); \n        return EnumerableSet.at(_minters, _index); \n    } \n \n    // modifier for mint function \n    modifier onlyMinter() { \n        require(isMinter(msg.sender), \"caller is not the minter\"); \n        _; \n    } \n}\n",
            "pragma solidity ^0.7.0; \n \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n//  \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n//  \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n//  \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n//  \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n//  \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n//  \n/** \n * @dev Contract module that helps prevent reentrant calls to a function. \n * \n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier \n * available, which can be applied to functions to make sure there are no nested \n * (reentrant) calls to them. \n * \n * Note that because there is a single `nonReentrant` guard, functions marked as \n * `nonReentrant` may not call one another. This can be worked around by making \n * those functions `private`, and then adding `external` `nonReentrant` entry \n * points to them. \n * \n * TIP: If you would like to learn more about reentrancy and alternative ways \n * to protect against it, check out our blog post \n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. \n */ \nabstract contract ReentrancyGuard { \n    // Booleans are more expensive than uint256 or any type that takes up a full \n    // word because each write operation emits an extra SLOAD to first read the \n    // slot's contents, replace the bits taken up by the boolean, and then write \n    // back. This is the compiler's defense against contract upgrades and \n    // pointer aliasing, and it cannot be disabled. \n \n    // The values being non-zero value makes deployment a bit more expensive, \n    // but in exchange the refund on every call to nonReentrant will be lower in \n    // amount. Since refunds are capped to a percentage of the total \n    // transaction's gas, it is best to keep them low in cases like this one, to \n    // increase the likelihood of the full refund coming into effect. \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    constructor () internal { \n        _status = _NOT_ENTERED; \n    } \n \n    /** \n     * @dev Prevents a contract from calling itself, directly or indirectly. \n     * Calling a `nonReentrant` function from another `nonReentrant` \n     * function is not supported. It is possible to prevent this from happening \n     * by making the `nonReentrant` function external, and make it call a \n     * `private` function that does the actual work. \n     */ \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n} \n \n//  \n/** \n * @dev Library for managing \n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive \n * types. \n * \n * Sets have the following properties: \n * \n * - Elements are added, removed, and checked for existence in constant time \n * (O(1)). \n * - Elements are enumerated in O(n). No guarantees are made on the ordering. \n * \n *  \n * contract Example { \n *     // Add the library methods \n *     using EnumerableSet for EnumerableSet.AddressSet; \n * \n *     // Declare a set state variable \n *     EnumerableSet.AddressSet private mySet; \n * } \n *  \n * \n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) \n * and `uint256` (`UintSet`) are supported. \n */ \nlibrary EnumerableSet { \n    // To implement this library for multiple types with as little code \n    // repetition as possible, we write it in terms of a generic Set type with \n    // bytes32 values. \n    // The Set implementation uses private functions, and user-facing \n    // implementations (such as AddressSet) are just wrappers around the \n    // underlying Set. \n    // This means that we can only create new EnumerableSets for types that fit \n    // in bytes32. \n \n    struct Set { \n        // Storage of set values \n        bytes32[] _values; \n \n        // Position of the value in the `values` array, plus 1 because index 0 \n        // means a value is not in the set. \n        mapping (bytes32 => uint256) _indexes; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function _add(Set storage set, bytes32 value) private returns (bool) { \n        if (!_contains(set, value)) { \n            set._values.push(value); \n            // The value is stored at length-1, but we add 1 to all indexes \n            // and use 0 as a sentinel value \n            set._indexes[value] = set._values.length; \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function _remove(Set storage set, bytes32 value) private returns (bool) { \n        // We read and store the value's index to prevent multiple reads from the same storage slot \n        uint256 valueIndex = set._indexes[value]; \n \n        if (valueIndex != 0) { // Equivalent to contains(set, value) \n            // To delete an element from the _values array in O(1), we swap the element to delete wit\n            // the array, and then remove the last element (sometimes called as 'swap and pop'). \n            // This modifies the order of the array, as noted in {at}. \n \n            uint256 toDeleteIndex = valueIndex - 1; \n            uint256 lastIndex = set._values.length - 1; \n \n            // When the value to delete is the last one, the swap operation is unnecessary. However, \n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' stateme\n \n            bytes32 lastvalue = set._values[lastIndex]; \n \n            // Move the last value to the index where the value to delete is \n            set._values[toDeleteIndex] = lastvalue; \n            // Update the index for the moved value \n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based \n \n            // Delete the slot where the moved value was stored \n            set._values.pop(); \n \n            // Delete the index for the deleted slot \n            delete set._indexes[value]; \n \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function _contains(Set storage set, bytes32 value) private view returns (bool) { \n        return set._indexes[value] != 0; \n    } \n \n    /** \n     * @dev Returns the number of values on the set. O(1). \n     */ \n    function _length(Set storage set) private view returns (uint256) { \n        return set._values.length; \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function _at(Set storage set, uint256 index) private view returns (bytes32) { \n        require(set._values.length > index, \"EnumerableSet: index out of bounds\"); \n        return set._values[index]; \n    } \n \n    // Bytes32Set \n \n    struct Bytes32Set { \n        Set _inner; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) { \n        return _add(set._inner, value); \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) { \n        return _remove(set._inner, value); \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) { \n        return _contains(set._inner, value); \n    } \n \n    /** \n     * @dev Returns the number of values in the set. O(1). \n     */ \n    function length(Bytes32Set storage set) internal view returns (uint256) { \n        return _length(set._inner); \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) { \n        return _at(set._inner, index); \n    } \n \n    // AddressSet \n \n    struct AddressSet { \n        Set _inner; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function add(AddressSet storage set, address value) internal returns (bool) { \n        return _add(set._inner, bytes32(uint256(uint160(value)))); \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function remove(AddressSet storage set, address value) internal returns (bool) { \n        return _remove(set._inner, bytes32(uint256(uint160(value)))); \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function contains(AddressSet storage set, address value) internal view returns (bool) { \n        return _contains(set._inner, bytes32(uint256(uint160(value)))); \n    } \n \n    /** \n     * @dev Returns the number of values in the set. O(1). \n     */ \n    function length(AddressSet storage set) internal view returns (uint256) { \n        return _length(set._inner); \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function at(AddressSet storage set, uint256 index) internal view returns (address) { \n        return address(uint160(uint256(_at(set._inner, index)))); \n    } \n \n \n    // UintSet \n \n    struct UintSet { \n        Set _inner; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function add(UintSet storage set, uint256 value) internal returns (bool) { \n        return _add(set._inner, bytes32(value)); \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function remove(UintSet storage set, uint256 value) internal returns (bool) { \n        return _remove(set._inner, bytes32(value)); \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function contains(UintSet storage set, uint256 value) internal view returns (bool) { \n        return _contains(set._inner, bytes32(value)); \n    } \n \n    /** \n     * @dev Returns the number of values on the set. O(1). \n     */ \n    function length(UintSet storage set) internal view returns (uint256) { \n        return _length(set._inner); \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function at(UintSet storage set, uint256 index) internal view returns (uint256) { \n        return uint256(_at(set._inner, index)); \n    } \n} \n \n//  \n/** \n * @dev Implementation of the {IERC20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of ERC20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IERC20-approve}. \n */ \ncontract ERC20 is Context, IERC20 { \n    using SafeMath for uint256; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n     * a default value of 18. \n     * \n     * To select a different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    constructor (string memory name_, string memory symbol_) public { \n        _name = name_; \n        _symbol = symbol_; \n        _decimals = 18; \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public view virtual returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public view virtual returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a balance of `505` tokens should \n     * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a value of 18, imitating the relationship between \n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is \n     * called. \n     * \n     * NOTE: This information is only used for _display_ purposes: it in \n     * no way affects any of the arithmetic of the contract, including \n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */ \n    function decimals() public view virtual returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */ \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */ \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function allowance(address owner, address spender) public view virtual override returns (uint256) \n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {ERC20}. \n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the total supply. \n     * \n     * Emits a {Transfer} event with `from` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `to` cannot be the zero address. \n     */ \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens. \n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Sets {decimals} to a value other than the default one of 18. \n     * \n     * WARNING: This function should only be called from the constructor. Most \n     * applications that interact with token contracts will not expect \n     * {decimals} to ever change, and may work incorrectly if it does. \n     */ \n    function _setupDecimals(uint8 decimals_) internal virtual { \n        _decimals = decimals_; \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * will be to transferred to `to`. \n     * - when `from` is zero, `amount` tokens will be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n     * - `from` and `to` are never both zero. \n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n} \n \n//  \nabstract contract DelegateERC20 is ERC20 { \n    using SafeMath for uint256; \n \n    mapping (address => address) internal _delegates; \n \n    /// @notice A checkpoint for marking number of votes from a given block \n    struct Checkpoint { \n        uint32 fromBlock; \n        uint256 votes; \n    } \n \n    /// @notice A record of votes checkpoints for each account, by index \n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints; \n \n    /// @notice The number of checkpoints for each account \n    mapping (address => uint32) public numCheckpoints; \n \n    /// @notice The EIP-712 typehash for the contract's domain \n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,add\n \n    /// @notice The EIP-712 typehash for the delegation struct used by the contract \n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 non\n \n    /// @notice A record of states for signing / validating signatures \n    mapping (address => uint) public nonces; \n \n \n    // support delegates mint \n    function _mint(address account, uint256 amount) internal override virtual { \n        super._mint(account, amount); \n \n        // add delegates to the minter \n        _moveDelegates(address(0), _delegates[account], amount); \n    } \n \n \n    function _transfer(address sender, address recipient, uint256 amount) internal override virtual { \n        super._transfer(sender, recipient, amount); \n        _moveDelegates(_delegates[sender], _delegates[recipient], amount); \n    } \n \n \n    /** \n    * @notice Delegate votes from `msg.sender` to `delegatee` \n    * @param delegatee The address to delegate votes to \n    */ \n    function delegate(address delegatee) external { \n        return _delegate(msg.sender, delegatee); \n    } \n \n    /** \n     * @notice Delegates votes from signatory to `delegatee` \n     * @param delegatee The address to delegate votes to \n     * @param nonce The contract state required to match the signature \n     * @param expiry The time at which to expire the signature \n     * @param v The recovery byte of the signature \n     * @param r Half of the ECDSA signature pair \n     * @param s Half of the ECDSA signature pair \n     */ \n    function delegateBySig( \n        address delegatee, \n        uint nonce, \n        uint expiry, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) \n    external \n    { \n        bytes32 domainSeparator = keccak256( \n            abi.encode( \n                DOMAIN_TYPEHASH, \n                keccak256(bytes(name())), \n                getChainId(), \n                address(this) \n            ) \n        ); \n \n        bytes32 structHash = keccak256( \n            abi.encode( \n                DELEGATION_TYPEHASH, \n                delegatee, \n                nonce, \n                expiry \n            ) \n        ); \n \n        bytes32 digest = keccak256( \n            abi.encodePacked( \n                \"\\x19\\x01\", \n                domainSeparator, \n                structHash \n            ) \n        ); \n \n        address signatory = ecrecover(digest, v, r, s); \n        require(signatory != address(0), \"CMPToken::delegateBySig: invalid signature\"); \n        require(nonce == nonces[signatory]++, \"CMPToken::delegateBySig: invalid nonce\"); \n        require(block.timestamp <= expiry, \"CMPToken::delegateBySig: signature expired\"); \n        return _delegate(signatory, delegatee); \n    } \n \n    /** \n     * @notice Gets the current votes balance for `account` \n     * @param account The address to get votes balance \n     * @return The number of current votes for `account` \n     */ \n    function getCurrentVotes(address account) \n    external \n    view \n    returns (uint256) \n    { \n        uint32 nCheckpoints = numCheckpoints[account]; \n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0; \n    } \n \n    /** \n     * @notice Determine the prior number of votes for an account as of a block number \n     * @dev Block number must be a finalized block or else this function will revert to prevent misin\n     * @param account The address of the account to check \n     * @param blockNumber The block number to get the vote balance at \n     * @return The number of votes the account had as of the given block \n     */ \n    function getPriorVotes(address account, uint blockNumber) \n    external \n    view \n    returns (uint256) \n    { \n        require(blockNumber < block.number, \"CMPToken::getPriorVotes: not yet determined\"); \n \n        uint32 nCheckpoints = numCheckpoints[account]; \n        if (nCheckpoints == 0) { \n            return 0; \n        } \n \n        // First check most recent balance \n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) { \n            return checkpoints[account][nCheckpoints - 1].votes; \n        } \n \n        // Next check implicit zero balance \n        if (checkpoints[account][0].fromBlock > blockNumber) { \n            return 0; \n        } \n \n        uint32 lower = 0; \n        uint32 upper = nCheckpoints - 1; \n        while (upper > lower) { \n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow \n            Checkpoint memory cp = checkpoints[account][center]; \n            if (cp.fromBlock == blockNumber) { \n                return cp.votes; \n            } else if (cp.fromBlock < blockNumber) { \n                lower = center; \n            } else { \n                upper = center - 1; \n            } \n        } \n        return checkpoints[account][lower].votes; \n    } \n \n    function _delegate(address delegator, address delegatee) \n    internal \n    { \n        address currentDelegate = _delegates[delegator]; \n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying balances (not scale\n        _delegates[delegator] = delegatee; \n \n        _moveDelegates(currentDelegate, delegatee, delegatorBalance); \n \n        emit DelegateChanged(delegator, currentDelegate, delegatee); \n    } \n \n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal { \n        if (srcRep != dstRep && amount > 0) { \n            if (srcRep != address(0)) { \n                // decrease old representative \n                uint32 srcRepNum = numCheckpoints[srcRep]; \n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0; \n                uint256 srcRepNew = srcRepOld.sub(amount); \n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew); \n            } \n \n            if (dstRep != address(0)) { \n                // increase new representative \n                uint32 dstRepNum = numCheckpoints[dstRep]; \n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0; \n                uint256 dstRepNew = dstRepOld.add(amount); \n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew); \n            } \n        } \n    } \n \n    function _writeCheckpoint( \n        address delegatee, \n        uint32 nCheckpoints, \n        uint256 oldVotes, \n        uint256 newVotes \n    ) \n    internal \n    { \n        uint32 blockNumber = safe32(block.number, \"CMPToken::_writeCheckpoint: block number exceeds 3\n \n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) { \n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes; \n        } else { \n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes); \n            numCheckpoints[delegatee] = nCheckpoints + 1; \n        } \n \n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes); \n    } \n \n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) { \n        require(n < 2**32, errorMessage); \n        return uint32(n); \n    } \n \n    function getChainId() internal pure returns (uint) { \n        uint256 chainId; \n        assembly { chainId := chainid() } \n \n        return chainId; \n    } \n \n    /// @notice An event thats emitted when an account changes its delegate \n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed to\n \n    /// @notice An event thats emitted when a delegate account's vote balance changes \n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance); \n \n} \n \n//  \ncontract CMPToken is DelegateERC20, Ownable { \n    using SafeMath for uint256; \n \n    uint256 private constant preMineSupply = 10000000 * 1e18; \n    uint256 private constant maxSupply = 200000000 * 1e18;     // the total supply \n \n    using EnumerableSet for EnumerableSet.AddressSet; \n    EnumerableSet.AddressSet private _minters; \n \n    constructor() public ERC20(\"Compound Farming Token\", \"CMP\"){ \n        _mint(msg.sender, preMineSupply); \n    } \n \n    // mint with max supply \n    function mint(address _to, uint256 _amount) public onlyMinter returns (bool) { \n        if (_amount.add(totalSupply()) > maxSupply) { \n            return false; \n        } \n        _mint(_to, _amount); \n        return true; \n    } \n \n    function addMinter(address _addMinter) public onlyOwner returns (bool) { \n        require(_addMinter != address(0), \"CMPToken: _addMinter is the zero address\"); \n        return EnumerableSet.add(_minters, _addMinter); \n    } \n \n    function delMinter(address _delMinter) public onlyOwner returns (bool) { \n        require(_delMinter != address(0), \"CMPToken: _delMinter is the zero address\"); \n        return EnumerableSet.remove(_minters, _delMinter); \n    } \n \n    function getMinterLength() public view returns (uint256) { \n        return EnumerableSet.length(_minters); \n    } \n \n    function isMinter(address account) public view returns (bool) { \n        return EnumerableSet.contains(_minters, account); \n    } \n \n    function getMinter(uint256 _index) public view onlyOwner returns (address){ \n        require(_index <= getMinterLength() - 1, \"CMPToken: index out of bounds\"); \n        return EnumerableSet.at(_minters, _index); \n    } \n \n    // modifier for mint function \n    modifier onlyMinter() { \n        require(isMinter(msg.sender), \"caller is not the minter\"); \n        _; \n    } \n} \n \n//  \n// For interacting with our own strategy \ninterface IStrategy { \n    // Total want tokens managed by stratfegy \n    function wantLockedTotal() external view returns (uint256); \n \n    // Sum of all shares of users to wantLockedTotal \n    function sharesTotal() external view returns (uint256); \n \n    // Main want token compounding function \n    function earn() external; \n \n    // Transfer want tokens autoFarm -> strategy \n    function deposit(address _userAddress, uint256 _wantAmt) \n        external \n        returns (uint256); \n \n    // Transfer want tokens strategy -> autoFarm \n    function withdraw(address _userAddress, uint256 _wantAmt) \n        external \n        returns (uint256); \n \n    function inCaseTokensGetStuck( \n        address _token, \n        uint256 _amount, \n        address _to \n    ) external; \n} \n \ncontract Farm is Ownable, ReentrancyGuard { \n    using SafeMath for uint256; \n    using SafeERC20 for IERC20; \n \n    // Info of each user. \n    struct UserInfo { \n        uint256 shares; // How many LP tokens the user has provided. \n        uint256 rewardDebt; // Reward debt. See explanation below. \n \n        // We do some fancy math here. Basically, any point in time, the amount of CMP  \n        // entitled to a user but is pending to be distributed is: \n        // \n        //   amount = user.shares / sharesTotal * wantLockedTotal \n        //   pending reward = (amount * pool.accCmpPerShare) - user.rewardDebt \n        // \n        // Whenever a user deposits or withdraws want tokens to a pool. Here's what happens: \n        //   1. The pool's `accCmpPerShare` (and `lastRewardBlock`) gets updated. \n        //   2. User receives the pending reward sent to his/her address. \n        //   3. User's `amount` gets updated. \n        //   4. User's `rewardDebt` gets updated. \n    } \n \n    struct PoolInfo { \n        IERC20 want; // Address of the want token. \n        uint256 allocPoint; // How many allocation points assigned to this pool. CMP to distribute pe\n        uint256 lastRewardBlock; // Last block number that CMP distribution occurs. \n        uint256 accCmpPerShare; // Accumulated CMP per share, times 1e12. See below. \n        address strat; // Strategy address that will auto compound want tokens \n    } \n \n    IERC20 public cmp; \n \n    uint256 public ownerCMPReward = 187500; // 15/80=18.75% \n \n    uint256 public CMPMaxSupply = 190000000 * 1e18; \n    // uint256 public cmpPerBlock = 338 * 1e16; // CMP tokens created per block \n    uint256 public cmpPerBlock = 3780 * 1e16; \n    uint256 public startBlock = uint256(-1); // default value, will be overwritten by deploy \n \n    PoolInfo[] public poolInfo; // Info of each pool. \n    mapping(uint256 => mapping(address => UserInfo)) public userInfo; // Info of each user that stake\n    uint256 public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation \n    uint256 public halvingPeriod = 0; \n \n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount); \n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount); \n    event EmergencyWithdraw( \n        address indexed user, \n        uint256 indexed pid, \n        uint256 amount \n    ); \n \n    constructor( \n        CMPToken _cmp, \n        uint256 _startBlock \n    ) public { \n        cmp = _cmp; \n        startBlock = _startBlock; \n    } \n \n    function setHalvingPeriod(uint256 _block) public onlyOwner { \n        halvingPeriod = _block; \n    } \n \n    // Set the number of mdx produced by each block \n    function setMdxPerBlock(uint256 _cmpPerBlock) public onlyOwner { \n        massUpdatePools(); \n        cmpPerBlock = _cmpPerBlock; \n    } \n \n    function poolLength() external view returns (uint256) { \n        return poolInfo.length; \n    } \n \n    // Add a new lp to the pool. Can only be called by the owner. \n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do. (Only if \n    function add( \n        uint256 _allocPoint, \n        IERC20 _want, \n        bool _withUpdate, \n        address _strat \n    ) public onlyOwner { \n        if (_withUpdate) { \n            massUpdatePools(); \n        } \n        uint256 lastRewardBlock = \n            block.number > startBlock ? block.number : startBlock; \n        totalAllocPoint = totalAllocPoint.add(_allocPoint); \n        poolInfo.push( \n            PoolInfo({ \n                want: _want, \n                allocPoint: _allocPoint, \n                lastRewardBlock: lastRewardBlock, \n                accCmpPerShare: 0, \n                strat: _strat \n            }) \n        ); \n    } \n \n    // Update the given pool's CPM allocation point. Can only be called by the owner. \n    function set( \n        uint256 _pid, \n        uint256 _allocPoint, \n        bool _withUpdate \n    ) public onlyOwner { \n        if (_withUpdate) { \n            massUpdatePools(); \n        } \n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( \n            _allocPoint \n        ); \n        poolInfo[_pid].allocPoint = _allocPoint; \n    } \n \n    function phase(uint256 blockNumber) public view returns (uint256) { \n        if (halvingPeriod == 0) { \n            return 0; \n        } \n        if (blockNumber > startBlock) { \n            return (blockNumber.sub(startBlock).sub(1)).div(halvingPeriod); \n        } \n        return 0; \n    } \n \n    function reward(uint256 blockNumber) public view returns (uint256) { \n        uint256 _phase = phase(blockNumber); \n        return cmpPerBlock.div(2 ** _phase); \n    } \n \n    // Return reward multiplier over the given _from to _to block. \n    function getMultiplier(uint256 _from, uint256 _to) \n        public \n        view \n        returns (uint256) \n    { \n        if (cmp.totalSupply() >= CMPMaxSupply) { \n            return 0; \n        } \n        return _to.sub(_from); \n    } \n \n    // View function to see pending CMP on frontend. \n    function pendingCMP(uint256 _pid, address _user) \n        external \n        view \n        returns (uint256) \n    { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][_user]; \n        uint256 accCmpPerShare = pool.accCmpPerShare; \n        uint256 sharesTotal = IStrategy(pool.strat).sharesTotal(); \n        if (block.number > pool.lastRewardBlock && sharesTotal != 0) { \n            uint256 multiplier = \n                getMultiplier(pool.lastRewardBlock, block.number); \n            uint256 cmpReward = \n                multiplier.mul(reward(block.number)).mul(pool.allocPoint).div( \n                    totalAllocPoint \n                ); \n            accCmpPerShare = accCmpPerShare.add( \n                cmpReward.mul(1e12).div(sharesTotal) \n            ); \n        } \n        return user.shares.mul(accCmpPerShare).div(1e12).sub(user.rewardDebt); \n    } \n \n    // View function to see staked Want tokens on frontend. \n    function stakedWantTokens(uint256 _pid, address _user) \n        external \n        view \n        returns (uint256) \n    { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][_user]; \n \n        uint256 sharesTotal = IStrategy(pool.strat).sharesTotal(); \n        uint256 wantLockedTotal = \n            IStrategy(poolInfo[_pid].strat).wantLockedTotal(); \n        if (sharesTotal == 0) { \n            return 0; \n        } \n        return user.shares.mul(wantLockedTotal).div(sharesTotal); \n    } \n \n    // Update reward variables for all pools. Be careful of gas spending! \n    function massUpdatePools() public onlyOwner{ \n        uint256 length = poolInfo.length; \n        for (uint256 pid = 0; pid < length; ++pid) { \n            updatePool(pid); \n        } \n    } \n \n    // Update reward variables of the given pool to be up-to-date. \n    function updatePool(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        if (block.number <= pool.lastRewardBlock) { \n            return; \n        } \n        uint256 sharesTotal = IStrategy(pool.strat).sharesTotal(); \n        if (sharesTotal == 0) { \n            pool.lastRewardBlock = block.number; \n            return; \n        } \n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); \n        if (multiplier <= 0) { \n            return; \n        } \n        uint256 cmpReward = \n            multiplier.mul(reward(block.number)).mul(pool.allocPoint).div( \n                totalAllocPoint \n            ); \n \n        CMPToken(address(cmp)).mint( \n            owner(), \n            cmpReward.mul(ownerCMPReward).div(1000000) \n        ); \n        CMPToken(address(cmp)).mint(address(this), cmpReward); \n \n        pool.accCmpPerShare = pool.accCmpPerShare.add( \n            cmpReward.mul(1e12).div(sharesTotal) \n        ); \n        pool.lastRewardBlock = block.number; \n    } \n \n    // Want tokens moved from user -> CMPFarm (CMP allocation) -> Strat (compounding) \n    function deposit(uint256 _pid, uint256 _wantAmt) public nonReentrant { \n        updatePool(_pid); \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n \n        if (user.shares > 0) { \n            uint256 pending = \n                user.shares.mul(pool.accCmpPerShare).div(1e12).sub( \n                    user.rewardDebt \n                ); \n            if (pending > 0) { \n                safeCMPTransfer(msg.sender, pending); \n            } \n        } \n        if (_wantAmt > 0) { \n            pool.want.safeTransferFrom( \n                address(msg.sender), \n                address(this), \n                _wantAmt \n            ); \n \n            pool.want.safeIncreaseAllowance(pool.strat, _wantAmt); \n            uint256 sharesAdded = \n                IStrategy(poolInfo[_pid].strat).deposit(msg.sender, _wantAmt); \n            user.shares = user.shares.add(sharesAdded); \n        } \n        user.rewardDebt = user.shares.mul(pool.accCmpPerShare).div(1e12); \n        emit Deposit(msg.sender, _pid, _wantAmt); \n    } \n \n    // Withdraw LP tokens from MasterChef. \n    function withdraw(uint256 _pid, uint256 _wantAmt) public nonReentrant { \n        updatePool(_pid); \n \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n \n        uint256 wantLockedTotal = \n            IStrategy(poolInfo[_pid].strat).wantLockedTotal(); \n        uint256 sharesTotal = IStrategy(poolInfo[_pid].strat).sharesTotal(); \n \n        require(user.shares > 0, \"user.shares is 0\"); \n        require(sharesTotal > 0, \"sharesTotal is 0\"); \n \n        // Withdraw pending CMP \n        uint256 pending = \n            user.shares.mul(pool.accCmpPerShare).div(1e12).sub( \n                user.rewardDebt \n            ); \n        if (pending > 0) { \n            safeCMPTransfer(msg.sender, pending); \n        } \n \n        // Withdraw want tokens \n        uint256 amount = user.shares.mul(wantLockedTotal).div(sharesTotal); \n        if (_wantAmt > amount) { \n            _wantAmt = amount; \n        } \n        if (_wantAmt > 0) { \n            uint256 sharesRemoved = \n                IStrategy(poolInfo[_pid].strat).withdraw(msg.sender, _wantAmt); \nStratX_MDEX.sol\n \n            if (sharesRemoved > user.shares) { \n                user.shares = 0; \n            } else { \n                user.shares = user.shares.sub(sharesRemoved); \n            } \n \n            uint256 wantBal = IERC20(pool.want).balanceOf(address(this)); \n            if (wantBal < _wantAmt) { \n                _wantAmt = wantBal; \n            } \n            pool.want.safeTransfer(address(msg.sender), _wantAmt); \n        } \n        user.rewardDebt = user.shares.mul(pool.accCmpPerShare).div(1e12); \n        emit Withdraw(msg.sender, _pid, _wantAmt); \n    } \n \n    // Withdraw without caring about rewards. EMERGENCY ONLY. \n    function emergencyWithdraw(uint256 _pid) public nonReentrant { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n \n        uint256 wantLockedTotal = \n            IStrategy(poolInfo[_pid].strat).wantLockedTotal(); \n        uint256 sharesTotal = IStrategy(poolInfo[_pid].strat).sharesTotal(); \n        uint256 amount = user.shares.mul(wantLockedTotal).div(sharesTotal); \n \n        IStrategy(poolInfo[_pid].strat).withdraw(msg.sender, amount); \n \n        pool.want.safeTransfer(address(msg.sender), amount); \n        emit EmergencyWithdraw(msg.sender, _pid, amount); \n        user.shares = 0; \n        user.rewardDebt = 0; \n    } \n \n    // Safe CMP transfer function, just in case if rounding error causes pool to not have enough \n    function safeCMPTransfer(address _to, uint256 _CMPAmt) internal { \n        uint256 CMPBal = cmp.balanceOf(address(this)); \n        if (_CMPAmt > CMPBal) { \n            cmp.transfer(_to, CMPBal); \n        } else { \n            cmp.transfer(_to, _CMPAmt); \n        } \n    } \n \n    function inCaseTokensGetStuck(address _token, uint256 _amount) \n        public \n        onlyOwner \n    { \n        IERC20(_token).safeTransfer(msg.sender, _amount); \n    } \n} \n",
            "pragma solidity ^0.7.0; \n \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n//  \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n//  \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n//  \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n//  \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n//  \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n//  \n/** \n * @dev Contract module that helps prevent reentrant calls to a function. \n * \n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier \n * available, which can be applied to functions to make sure there are no nested \n * (reentrant) calls to them. \n * \n * Note that because there is a single `nonReentrant` guard, functions marked as \n * `nonReentrant` may not call one another. This can be worked around by making \n * those functions `private`, and then adding `external` `nonReentrant` entry \n * points to them. \n * \n * TIP: If you would like to learn more about reentrancy and alternative ways \n * to protect against it, check out our blog post \n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. \n */ \nabstract contract ReentrancyGuard { \n    // Booleans are more expensive than uint256 or any type that takes up a full \n    // word because each write operation emits an extra SLOAD to first read the \n    // slot's contents, replace the bits taken up by the boolean, and then write \n    // back. This is the compiler's defense against contract upgrades and \n    // pointer aliasing, and it cannot be disabled. \n \n    // The values being non-zero value makes deployment a bit more expensive, \n    // but in exchange the refund on every call to nonReentrant will be lower in \n    // amount. Since refunds are capped to a percentage of the total \n    // transaction's gas, it is best to keep them low in cases like this one, to \n    // increase the likelihood of the full refund coming into effect. \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    constructor () internal { \n        _status = _NOT_ENTERED; \n    } \n \n    /** \n     * @dev Prevents a contract from calling itself, directly or indirectly. \n     * Calling a `nonReentrant` function from another `nonReentrant` \n     * function is not supported. It is possible to prevent this from happening \n     * by making the `nonReentrant` function external, and make it call a \n     * `private` function that does the actual work. \n     */ \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n} \n \n//  \n/** \n * @dev Contract module which allows children to implement an emergency stop \n * mechanism that can be triggered by an authorized account. \n * \n * This module is used through inheritance. It will make available the \n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to \n * the functions of your contract. Note that they will not be pausable by \n * simply including this module, only once the modifiers are put in place. \n */ \nabstract contract Pausable is Context { \n    /** \n     * @dev Emitted when the pause is triggered by `account`. \n     */ \n    event Paused(address account); \n \n    /** \n     * @dev Emitted when the pause is lifted by `account`. \n     */ \n    event Unpaused(address account); \n \n    bool private _paused; \n \n    /** \n     * @dev Initializes the contract in unpaused state. \n     */ \n    constructor () internal { \n        _paused = false; \n    } \n \n    /** \n     * @dev Returns true if the contract is paused, and false otherwise. \n     */ \n    function paused() public view virtual returns (bool) { \n        return _paused; \n    } \n \n    /** \n     * @dev Modifier to make a function callable only when the contract is not paused. \n     * \n     * Requirements: \n     * \n     * - The contract must not be paused. \n     */ \n    modifier whenNotPaused() { \n        require(!paused(), \"Pausable: paused\"); \n        _; \n    } \n \n    /** \n     * @dev Modifier to make a function callable only when the contract is paused. \n     * \n     * Requirements: \n     * \n     * - The contract must be paused. \n     */ \n    modifier whenPaused() { \n        require(paused(), \"Pausable: not paused\"); \n        _; \n    } \n \n    /** \n     * @dev Triggers stopped state. \n     * \n     * Requirements: \n     * \n     * - The contract must not be paused. \n     */ \n    function _pause() internal virtual whenNotPaused { \n        _paused = true; \n        emit Paused(_msgSender()); \n    } \n \n    /** \n     * @dev Returns to normal state. \n     * \n     * Requirements: \n     * \n     * - The contract must be paused. \n     */ \n    function _unpause() internal virtual whenPaused { \n        _paused = false; \n        emit Unpaused(_msgSender()); \n    } \n} \n \n//  \n/** \n * @dev Library for managing \n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive \n * types. \n * \n * Sets have the following properties: \n * \n * - Elements are added, removed, and checked for existence in constant time \n * (O(1)). \n * - Elements are enumerated in O(n). No guarantees are made on the ordering. \n * \n *  \n * contract Example { \n *     // Add the library methods \n *     using EnumerableSet for EnumerableSet.AddressSet; \n * \n *     // Declare a set state variable \n *     EnumerableSet.AddressSet private mySet; \n * } \n *  \n * \n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) \n * and `uint256` (`UintSet`) are supported. \n */ \nlibrary EnumerableSet { \n    // To implement this library for multiple types with as little code \n    // repetition as possible, we write it in terms of a generic Set type with \n    // bytes32 values. \n    // The Set implementation uses private functions, and user-facing \n    // implementations (such as AddressSet) are just wrappers around the \n    // underlying Set. \n    // This means that we can only create new EnumerableSets for types that fit \n    // in bytes32. \n \n    struct Set { \n        // Storage of set values \n        bytes32[] _values; \n \n        // Position of the value in the `values` array, plus 1 because index 0 \n        // means a value is not in the set. \n        mapping (bytes32 => uint256) _indexes; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function _add(Set storage set, bytes32 value) private returns (bool) { \n        if (!_contains(set, value)) { \n            set._values.push(value); \n            // The value is stored at length-1, but we add 1 to all indexes \n            // and use 0 as a sentinel value \n            set._indexes[value] = set._values.length; \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function _remove(Set storage set, bytes32 value) private returns (bool) { \n        // We read and store the value's index to prevent multiple reads from the same storage slot \n        uint256 valueIndex = set._indexes[value]; \n \n        if (valueIndex != 0) { // Equivalent to contains(set, value) \n            // To delete an element from the _values array in O(1), we swap the element to delete wit\n            // the array, and then remove the last element (sometimes called as 'swap and pop'). \n            // This modifies the order of the array, as noted in {at}. \n \n            uint256 toDeleteIndex = valueIndex - 1; \n            uint256 lastIndex = set._values.length - 1; \n \n            // When the value to delete is the last one, the swap operation is unnecessary. However, \n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' stateme\n \n            bytes32 lastvalue = set._values[lastIndex]; \n \n            // Move the last value to the index where the value to delete is \n            set._values[toDeleteIndex] = lastvalue; \n            // Update the index for the moved value \n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based \n \n            // Delete the slot where the moved value was stored \n            set._values.pop(); \n \n            // Delete the index for the deleted slot \n            delete set._indexes[value]; \n \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function _contains(Set storage set, bytes32 value) private view returns (bool) { \n        return set._indexes[value] != 0; \n    } \n \n    /** \n     * @dev Returns the number of values on the set. O(1). \n     */ \n    function _length(Set storage set) private view returns (uint256) { \n        return set._values.length; \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function _at(Set storage set, uint256 index) private view returns (bytes32) { \n        require(set._values.length > index, \"EnumerableSet: index out of bounds\"); \n        return set._values[index]; \n    } \n \n    // Bytes32Set \n \n    struct Bytes32Set { \n        Set _inner; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) { \n        return _add(set._inner, value); \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) { \n        return _remove(set._inner, value); \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) { \n        return _contains(set._inner, value); \n    } \n \n    /** \n     * @dev Returns the number of values in the set. O(1). \n     */ \n    function length(Bytes32Set storage set) internal view returns (uint256) { \n        return _length(set._inner); \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) { \n        return _at(set._inner, index); \n    } \n \n    // AddressSet \n \n    struct AddressSet { \n        Set _inner; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function add(AddressSet storage set, address value) internal returns (bool) { \n        return _add(set._inner, bytes32(uint256(uint160(value)))); \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function remove(AddressSet storage set, address value) internal returns (bool) { \n        return _remove(set._inner, bytes32(uint256(uint160(value)))); \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function contains(AddressSet storage set, address value) internal view returns (bool) { \n        return _contains(set._inner, bytes32(uint256(uint160(value)))); \n    } \n \n    /** \n     * @dev Returns the number of values in the set. O(1). \n     */ \n    function length(AddressSet storage set) internal view returns (uint256) { \n        return _length(set._inner); \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function at(AddressSet storage set, uint256 index) internal view returns (address) { \n        return address(uint160(uint256(_at(set._inner, index)))); \n    } \n \n \n    // UintSet \n \n    struct UintSet { \n        Set _inner; \n    } \n \n    /** \n     * @dev Add a value to a set. O(1). \n     * \n     * Returns true if the value was added to the set, that is if it was not \n     * already present. \n     */ \n    function add(UintSet storage set, uint256 value) internal returns (bool) { \n        return _add(set._inner, bytes32(value)); \n    } \n \n    /** \n     * @dev Removes a value from a set. O(1). \n     * \n     * Returns true if the value was removed from the set, that is if it was \n     * present. \n     */ \n    function remove(UintSet storage set, uint256 value) internal returns (bool) { \n        return _remove(set._inner, bytes32(value)); \n    } \n \n    /** \n     * @dev Returns true if the value is in the set. O(1). \n     */ \n    function contains(UintSet storage set, uint256 value) internal view returns (bool) { \n        return _contains(set._inner, bytes32(value)); \n    } \n \n    /** \n     * @dev Returns the number of values on the set. O(1). \n     */ \n    function length(UintSet storage set) internal view returns (uint256) { \n        return _length(set._inner); \n    } \n \n   /** \n    * @dev Returns the value stored at position `index` in the set. O(1). \n    * \n    * Note that there are no guarantees on the ordering of values inside the \n    * array, and it may change when more values are added or removed. \n    * \n    * Requirements: \n    * \n    * - `index` must be strictly less than {length}. \n    */ \n    function at(UintSet storage set, uint256 index) internal view returns (uint256) { \n        return uint256(_at(set._inner, index)); \n    } \n} \n \n//  \ninterface IPancakeswapFarm { \n    function poolLength() external view returns (uint256); \n \n    function userInfo() external view returns (uint256); \n \n    // Return reward multiplier over the given _from to _to block. \n    function getMultiplier(uint256 _from, uint256 _to) \n        external \n        view \n        returns (uint256); \n \n    // View function to see pending CAKEs on frontend. \n    function pendingCake(uint256 _pid, address _user) \n        external \n        view \n        returns (uint256); \n \n    // Deposit LP tokens to MasterChef for CAKE allocation. \n    function deposit(uint256 _pid, uint256 _amount) external; \n \n    // Withdraw LP tokens from MasterChef. \n    function withdraw(uint256 _pid, uint256 _amount) external; \n \n    // Stake CAKE tokens to MasterChef \n    function enterStaking(uint256 _amount) external; \n \n    // Withdraw CAKE tokens from STAKING. \n    function leaveStaking(uint256 _amount) external; \n \n    // Withdraw without caring about rewards. EMERGENCY ONLY. \n    function emergencyWithdraw(uint256 _pid) external; \n} \n \ninterface IPancakeRouter01 { \n    function factory() external pure returns (address); \n \n    function WETH() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 amountADesired, \n        uint256 amountBDesired, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to, \n        uint256 deadline \n    ) \n        external \n        returns ( \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ); \n \n    function addLiquidityETH( \n        address token, \n        uint256 amountTokenDesired, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline \n    ) \n        external \n        payable \n        returns ( \n            uint256 amountToken, \n            uint256 amountETH, \n            uint256 liquidity \n        ); \n \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 liquidity, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to, \n        uint256 deadline \n    ) external returns (uint256 amountA, uint256 amountB); \n \n    function removeLiquidityETH( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline \n    ) external returns (uint256 amountToken, uint256 amountETH); \n \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint256 liquidity, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to, \n        uint256 deadline, \n        bool approveMax, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external returns (uint256 amountA, uint256 amountB); \n \n    function removeLiquidityETHWithPermit( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline, \n        bool approveMax, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external returns (uint256 amountToken, uint256 amountETH); \n \n    function swapExactTokensForTokens( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external returns (uint256[] memory amounts); \n \n    function swapTokensForExactTokens( \n        uint256 amountOut, \n        uint256 amountInMax, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external returns (uint256[] memory amounts); \n \n    function swapExactETHForTokens( \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external payable returns (uint256[] memory amounts); \n \n    function swapTokensForExactETH( \n        uint256 amountOut, \n        uint256 amountInMax, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external returns (uint256[] memory amounts); \n \n    function swapExactTokensForETH( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external returns (uint256[] memory amounts); \n \n    function swapETHForExactTokens( \n        uint256 amountOut, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external payable returns (uint256[] memory amounts); \n \n    function quote( \n        uint256 amountA, \n        uint256 reserveA, \n        uint256 reserveB \n    ) external pure returns (uint256 amountB); \n \n    function getAmountOut( \n        uint256 amountIn, \n        uint256 reserveIn, \n        uint256 reserveOut \n    ) external pure returns (uint256 amountOut); \n \n    function getAmountIn( \n        uint256 amountOut, \n        uint256 reserveIn, \n        uint256 reserveOut \n    ) external pure returns (uint256 amountIn); \n \n    function getAmountsOut(uint256 amountIn, address[] calldata path) \n        external \n        view \n        returns (uint256[] memory amounts); \n \n    function getAmountsIn(uint256 amountOut, address[] calldata path) \n        external \n        view \n        returns (uint256[] memory amounts); \n} \n \ninterface IPancakeRouter02 is IPancakeRouter01 { \n    function removeLiquidityETHSupportingFeeOnTransferTokens( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline \n    ) external returns (uint256 amountETH); \n \n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline, \n        bool approveMax, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external returns (uint256 amountETH); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external; \n \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external payable; \n \n    function swapExactTokensForETHSupportingFeeOnTransferTokens( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external; \n} \n \ninterface IMDEXSwapMining { \n    function takerWithdraw() external; \n} \n \ninterface IWBNB is IERC20 { \n    function deposit() external payable; \n \n    function withdraw(uint256 wad) external; \n} \n \nabstract contract StratX is Ownable, ReentrancyGuard, Pausable { \n    // Maximises yields in pancakeswap \n \n    using SafeMath for uint256; \n    using SafeERC20 for IERC20; \n \n    bool public isCAKEStaking; // only for staking CAKE using pancakeswap's native CAKE staking contr\n    bool public isAutoComp; // this vault is purely for staking. eg. WBNB-AUTO staking vault. \n \n    address public farmContractAddress; // address of farm, eg, PCS, Thugs etc. \n    uint256 public pid; // pid of pool in farmContractAddress \n    address public wantAddress; \n    address public token0Address; \n    address public token1Address; \n    address public earnedAddress; \n    address public uniRouterAddress; // uniswap, pancakeswap etc \n \n    address public wbnbAddress; \n    address public autoFarmAddress; \n    address public CMPAddress; \n    address public govAddress; // timelock contract \n    bool public onlyGov = true; \n \n    uint256 public lastEarnBlock = 0; \n    uint256 public wantLockedTotal = 0; \n    uint256 public sharesTotal = 0; \n \n    uint256 public controllerFee = 160; // 70; \n    uint256 public constant controllerFeeMax = 10000; // 100 = 1% \n    uint256 public constant controllerFeeUL = 500; \n \n    uint256 public buyBackRate = 0; // 250; \n    uint256 public constant buyBackRateMax = 10000; // 100 = 1% \n    uint256 public constant buyBackRateUL = 800; \n    address public buyBackAddress = 0x3b5F91311d4c6165236565987B348327027ae007; \n    address public rewardsAddress; \n \n    uint256 public entranceFeeFactor = 9990; // < 0.1% entrance fee - goes to pool + prevents front-r\n    uint256 public constant entranceFeeFactorMax = 10000; \n    uint256 public constant entranceFeeFactorLL = 9950; // 0.5% is the max entrance fee settable. LL \n \n    uint256 public withdrawFeeFactor = 10000; // 0.1% withdraw fee - goes to pool \n    uint256 public constant withdrawFeeFactorMax = 10000; \n    uint256 public constant withdrawFeeFactorLL = 9950; // 0.5% is the max withdraw fee settable. LL \n \n    uint256 public slippageFactor = 950; // 5% default slippage tolerance \n    uint256 public constant slippageFactorUL = 995; \n \n    address[] public earnedToCMPPath; \n    address[] public earnedToToken0Path; \n    address[] public earnedToToken1Path; \n    address[] public token0ToEarnedPath; \n    address[] public token1ToEarnedPath; \n    address[] public earnedToWantPath; \n \n    event SetSettings( \n        uint256 _entranceFeeFactor, \n        uint256 _withdrawFeeFactor, \n        uint256 _controllerFee, \n        uint256 _buyBackRate, \n        uint256 _slippageFactor \n    ); \n \n    event SetGov(address _govAddress); \n    event SetOnlyGov(bool _onlyGov); \n    event SetUniRouterAddress(address _uniRouterAddress); \n    event SetBuyBackAddress(address _buyBackAddress); \n    event SetRewardsAddress(address _rewardsAddress); \n \n    modifier onlyAllowGov() { \n        require(msg.sender == govAddress, \"!gov\"); \n        _; \n    } \n \n    // Receives new deposits from user \n    function deposit(address _userAddress, uint256 _wantAmt) \n        public \n        virtual \n        onlyOwner \n        nonReentrant \n        whenNotPaused \n        returns (uint256) \n    { \n        IERC20(wantAddress).safeTransferFrom( \n            address(msg.sender), \n            address(this), \n            _wantAmt \n        ); \n \n        uint256 sharesAdded = _wantAmt; \n        if (wantLockedTotal > 0 && sharesTotal > 0) { \n            sharesAdded = _wantAmt \n                .mul(sharesTotal) \n                .mul(entranceFeeFactor) \n                .div(wantLockedTotal) \n                .div(entranceFeeFactorMax); \n        } \n        sharesTotal = sharesTotal.add(sharesAdded); \n \n        if (isAutoComp) { \n            _farm(); \n        } else { \n            wantLockedTotal = wantLockedTotal.add(_wantAmt); \n        } \n \n        return sharesAdded; \n    } \n \n    function farm() public virtual nonReentrant { \n        _farm(); \n    } \n \n    function _farm() internal virtual { \n        require(isAutoComp, \"!isAutoComp\"); \n        uint256 wantAmt = IERC20(wantAddress).balanceOf(address(this)); \n        wantLockedTotal = wantLockedTotal.add(wantAmt); \n        IERC20(wantAddress).safeIncreaseAllowance(farmContractAddress, wantAmt); \n \n        if (isCAKEStaking) { \n            IPancakeswapFarm(farmContractAddress).enterStaking(wantAmt); // Just for CAKE staking, we \n        } else { \n            IPancakeswapFarm(farmContractAddress).deposit(pid, wantAmt); \n        } \n    } \n \n    function _unfarm(uint256 _wantAmt) internal virtual { \n        if (isCAKEStaking) { \n            IPancakeswapFarm(farmContractAddress).leaveStaking(_wantAmt); // Just for CAKE staking, w\n        } else { \n            IPancakeswapFarm(farmContractAddress).withdraw(pid, _wantAmt); \n        } \n    } \n \n    function withdraw(address _userAddress, uint256 _wantAmt) \n        public \n        virtual \n        onlyOwner \n        nonReentrant \n        returns (uint256) \n    { \n        require(_wantAmt > 0, \"_wantAmt <= 0\"); \n \n        uint256 sharesRemoved = _wantAmt.mul(sharesTotal).div(wantLockedTotal); \n        if (sharesRemoved > sharesTotal) { \n            sharesRemoved = sharesTotal; \n        } \n        sharesTotal = sharesTotal.sub(sharesRemoved); \n \n        if (withdrawFeeFactor < withdrawFeeFactorMax) { \n            _wantAmt = _wantAmt.mul(withdrawFeeFactor).div( \n                withdrawFeeFactorMax \n            ); \n        } \n \n        if (isAutoComp) { \n            _unfarm(_wantAmt); \n        } \n \n        uint256 wantAmt = IERC20(wantAddress).balanceOf(address(this)); \n        if (_wantAmt > wantAmt) { \n            _wantAmt = wantAmt; \n        } \n \n        if (wantLockedTotal < _wantAmt) { \n            _wantAmt = wantLockedTotal; \n        } \n \n        wantLockedTotal = wantLockedTotal.sub(_wantAmt); \n \n        IERC20(wantAddress).safeTransfer(autoFarmAddress, _wantAmt); \n \n        return sharesRemoved; \n    } \n \n    // 1. Harvest farm tokens \n    // 2. Converts farm tokens into want tokens \n    // 3. Deposits want tokens \n \n    function earn() public virtual nonReentrant whenNotPaused { \n        require(isAutoComp, \"!isAutoComp\"); \n        if (onlyGov) { \n            require(msg.sender == govAddress, \"!gov\"); \n        } \n \n        // Harvest farm tokens \n        _unfarm(0); \n \n        if (earnedAddress == wbnbAddress) { \n            _wrapBNB(); \n        } \n \n        // Converts farm tokens into want tokens \n        uint256 earnedAmt = IERC20(earnedAddress).balanceOf(address(this)); \n \n        earnedAmt = distributeFees(earnedAmt); \n        earnedAmt = buyBack(earnedAmt); \n \n        if (isCAKEStaking) { \n            lastEarnBlock = block.number; \n            _farm(); \n            return; \n        } \n \n        IERC20(earnedAddress).safeApprove(uniRouterAddress, 0); \n        IERC20(earnedAddress).safeIncreaseAllowance( \n            uniRouterAddress, \n            earnedAmt \n        ); \n \n        // single coin \n        if(token0Address == address(0x0) || token1Address == address(0x0)){ \n            // earned is the same as want, do nothing \n            // earned is different from want, swap to want \n            if(earnedAddress != wantAddress) { \n                // otherwise need to conver the earned to want token \n                _safeSwap( \n                    uniRouterAddress, \n                    earnedAmt, \n                    slippageFactor, \n                    earnedToWantPath, \n                    address(this), \n                    block.timestamp.add(600) \n                ); \n            } \n \n            lastEarnBlock = block.number; \n            _farm(); \n            return; \n        } \n \n        // LP coin \n \n        if (earnedAddress != token0Address) { \n            // Swap half earned to token0 \n            _safeSwap( \n                uniRouterAddress, \n                earnedAmt.div(2), \n                slippageFactor, \n                earnedToToken0Path, \n                address(this), \n                block.timestamp.add(600) \n            ); \n        } \n \n        if (earnedAddress != token1Address) { \n            // Swap half earned to token1 \n            _safeSwap( \n                uniRouterAddress, \n                earnedAmt.div(2), \n                slippageFactor, \n                earnedToToken1Path, \n                address(this), \n                block.timestamp.add(600) \n            ); \n        } \n \n        // Get want tokens, ie. add liquidity \n        uint256 token0Amt = IERC20(token0Address).balanceOf(address(this)); \n        uint256 token1Amt = IERC20(token1Address).balanceOf(address(this)); \n        if (token0Amt > 0 && token1Amt > 0) { \n            IERC20(token0Address).safeIncreaseAllowance( \n                uniRouterAddress, \n                token0Amt \n            ); \n            IERC20(token1Address).safeIncreaseAllowance( \n                uniRouterAddress, \n                token1Amt \n            ); \n            IPancakeRouter02(uniRouterAddress).addLiquidity( \n                token0Address, \n                token1Address, \n                token0Amt, \n                token1Amt, \n                0, \n                0, \n                address(this), \n                block.timestamp.add(600) \n            ); \n        } \n \n        lastEarnBlock = block.number; \n \n        _farm(); \n    } \n \n    function buyBack(uint256 _earnedAmt) internal virtual returns (uint256) { \n        if (buyBackRate <= 0) { \n            return _earnedAmt; \n        } \n \n        uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); \n \n        if (earnedAddress == CMPAddress) { \n            IERC20(earnedAddress).safeTransfer(buyBackAddress, buyBackAmt); \n        } else { \n            IERC20(earnedAddress).safeIncreaseAllowance( \n                uniRouterAddress, \n                buyBackAmt \n            ); \n \n            _safeSwap( \n                uniRouterAddress, \n                buyBackAmt, \n                slippageFactor, \n                earnedToCMPPath, \n                buyBackAddress, \n                block.timestamp.add(600) \n            ); \n        } \n \n        return _earnedAmt.sub(buyBackAmt); \n    } \n \n    function distributeFees(uint256 _earnedAmt) \n        internal \n        virtual \n        returns (uint256) \n    { \n        if (_earnedAmt > 0) { \n            // Performance fee \n            if (controllerFee > 0) { \n                uint256 fee = \n                    _earnedAmt.mul(controllerFee).div(controllerFeeMax); \n                IERC20(earnedAddress).safeTransfer(rewardsAddress, fee); \n                _earnedAmt = _earnedAmt.sub(fee); \n            } \n        } \n \n        return _earnedAmt; \n    } \n \n    function convertDustToEarned() public virtual whenNotPaused { \n        require(isAutoComp, \"!isAutoComp\"); \n        require(!isCAKEStaking, \"isCAKEStaking\"); \n \n        // Converts dust tokens into earned tokens, which will be reinvested on the next earn(). \n \n        // Converts token0 dust (if any) to earned tokens \n        uint256 token0Amt = IERC20(token0Address).balanceOf(address(this)); \n        if (token0Address != earnedAddress && token0Amt > 0) { \n            IERC20(token0Address).safeIncreaseAllowance( \n                uniRouterAddress, \n                token0Amt \n            ); \n \n            // Swap all dust tokens to earned tokens \n            _safeSwap( \n                uniRouterAddress, \n                token0Amt, \n                slippageFactor, \n                token0ToEarnedPath, \n                address(this), \n                block.timestamp.add(600) \n            ); \n        } \n \n        // Converts token1 dust (if any) to earned tokens \n        uint256 token1Amt = IERC20(token1Address).balanceOf(address(this)); \n        if (token1Address != earnedAddress && token1Amt > 0) { \n            IERC20(token1Address).safeIncreaseAllowance( \n                uniRouterAddress, \n                token1Amt \n            ); \n \n            // Swap all dust tokens to earned tokens \n            _safeSwap( \n                uniRouterAddress, \n                token1Amt, \n                slippageFactor, \n                token1ToEarnedPath, \n                address(this), \n                block.timestamp.add(600) \n            ); \n        } \n    } \n \n    function pause() public virtual onlyAllowGov { \n        _pause(); \n    } \n \n    function unpause() public virtual onlyAllowGov { \n        _unpause(); \n    } \n \n    function setSettings( \n        uint256 _entranceFeeFactor, \n        uint256 _withdrawFeeFactor, \n        uint256 _controllerFee, \n        uint256 _buyBackRate, \n        uint256 _slippageFactor \n    ) public virtual onlyAllowGov { \n        require( \n            _entranceFeeFactor >= entranceFeeFactorLL, \n            \"_entranceFeeFactor too low\" \n        ); \n        require( \n            _entranceFeeFactor <= entranceFeeFactorMax, \n            \"_entranceFeeFactor too high\" \n        ); \n        entranceFeeFactor = _entranceFeeFactor; \n \n        require( \n            _withdrawFeeFactor >= withdrawFeeFactorLL, \n            \"_withdrawFeeFactor too low\" \n        ); \n        require( \n            _withdrawFeeFactor <= withdrawFeeFactorMax, \n            \"_withdrawFeeFactor too high\" \n        ); \n        withdrawFeeFactor = _withdrawFeeFactor; \n \n        require(_controllerFee <= controllerFeeUL, \"_controllerFee too high\"); \n        controllerFee = _controllerFee; \n \n        require(_buyBackRate <= buyBackRateUL, \"_buyBackRate too high\"); \n        buyBackRate = _buyBackRate; \n \n        require( \n            _slippageFactor <= slippageFactorUL, \n            \"_slippageFactor too high\" \n        ); \n        slippageFactor = _slippageFactor; \n \n        emit SetSettings( \n            _entranceFeeFactor, \n            _withdrawFeeFactor, \n            _controllerFee, \n            _buyBackRate, \n            _slippageFactor \n        ); \n    } \n \n    function setGov(address _govAddress) public virtual onlyAllowGov { \n        govAddress = _govAddress; \n        emit SetGov(_govAddress); \n    } \n \n    function setOnlyGov(bool _onlyGov) public virtual onlyAllowGov { \n        onlyGov = _onlyGov; \n        emit SetOnlyGov(_onlyGov); \n    } \n \n    function setUniRouterAddress(address _uniRouterAddress) \n        public \n        virtual \n        onlyAllowGov \n    { \n        uniRouterAddress = _uniRouterAddress; \n        emit SetUniRouterAddress(_uniRouterAddress); \n    } \n \n    function setBuyBackAddress(address _buyBackAddress) \n        public \n        virtual \n        onlyAllowGov \n    { \n        buyBackAddress = _buyBackAddress; \n        emit SetBuyBackAddress(_buyBackAddress); \n    } \n \n    function setRewardsAddress(address _rewardsAddress) \n        public \n        virtual \n        onlyAllowGov \n    { \n        rewardsAddress = _rewardsAddress; \n        emit SetRewardsAddress(_rewardsAddress); \n    } \n \n    function inCaseTokensGetStuck( \n        address _token, \n        uint256 _amount, \n        address _to \n    ) public virtual onlyAllowGov { \n        require(_token != earnedAddress, \"!safe\"); \n        require(_token != wantAddress, \"!safe\"); \n        IERC20(_token).safeTransfer(_to, _amount); \n    } \n \n    function _wrapBNB() internal virtual { \n        // BNB -> WBNB \n        uint256 bnbBal = address(this).balance; \n        if (bnbBal > 0) { \n            IWBNB(wbnbAddress).deposit{value: bnbBal}(); // BNB -> WBNB \n        } \n    } \n \n    function wrapBNB() public virtual onlyAllowGov { \n        _wrapBNB(); \n    } \n \n    function _safeSwap( \n        address _uniRouterAddress, \n        uint256 _amountIn, \n        uint256 _slippageFactor, \n        address[] memory _path, \n        address _to, \n        uint256 _deadline \n    ) internal virtual { \n        uint256[] memory amounts = \n            IPancakeRouter02(_uniRouterAddress).getAmountsOut(_amountIn, _path); \n        uint256 amountOut = amounts[amounts.length.sub(1)]; \n \n        IPancakeRouter02(_uniRouterAddress) \n            .swapExactTokensForTokensSupportingFeeOnTransferTokens( \n            _amountIn, \n            amountOut.mul(_slippageFactor).div(1000), \n            _path, \n            _to, \n            _deadline \n        ); \n    } \n} \n \ncontract StratX_MDEX is StratX { \n    using SafeMath for uint256; \n    using SafeERC20 for IERC20; \n \n    address public MDXAddress; \n    address public MDEXSwapMiningAddress; \n    address[] public MDXToEarnedPath; \n \n    constructor( \n        address[] memory _addresses, \n        uint256 _pid, \n        bool _isCAKEStaking, \n        bool _isAutoComp, \n        address[] memory _earnedToCMPPath, \n        address[] memory _earnedToToken0Path, \n        address[] memory _earnedToToken1Path, \n        address[] memory _token0ToEarnedPath, \n        address[] memory _token1ToEarnedPath, \n        address[] memory _earnedToWantPath, \n        uint256 _controllerFee, \n        uint256 _buyBackRate, \n        uint256 _entranceFeeFactor, \n        uint256 _withdrawFeeFactor, \n        address[] memory _MDXToEarnedPath \n    ) public { \n        wbnbAddress = _addresses[0]; \n        govAddress = _addresses[1]; \n        autoFarmAddress = _addresses[2]; \n        CMPAddress = _addresses[3]; \n \n        wantAddress = _addresses[4]; \n        token0Address = _addresses[5]; \n        token1Address = _addresses[6]; \n        earnedAddress = _addresses[7]; \n \n        farmContractAddress = _addresses[8]; \n        pid = _pid; \n        isCAKEStaking = _isCAKEStaking; \n        isAutoComp = _isAutoComp; \n \n        uniRouterAddress = _addresses[9]; \n        earnedToCMPPath = _earnedToCMPPath; \n        earnedToToken0Path = _earnedToToken0Path; \n        earnedToToken1Path = _earnedToToken1Path; \n        token0ToEarnedPath = _token0ToEarnedPath; \n        token1ToEarnedPath = _token1ToEarnedPath; \n        earnedToWantPath = _earnedToWantPath; \n \n        controllerFee = _controllerFee; \n        rewardsAddress = _addresses[10]; \n        buyBackRate = _buyBackRate; \n        buyBackAddress = _addresses[11]; \n        entranceFeeFactor = _entranceFeeFactor; \n        withdrawFeeFactor = _withdrawFeeFactor; \n \n        MDXAddress = _addresses[12]; \n        MDEXSwapMiningAddress = _addresses[13]; \n        MDXToEarnedPath = _MDXToEarnedPath; \n \n        transferOwnership(autoFarmAddress); \n    } \n \n    // Claim trade mining rewards \n    function claimTradeMiningReward() public { \n        require(msg.sender == govAddress, \"Not authorised\"); \n        IMDEXSwapMining(MDEXSwapMiningAddress).takerWithdraw(); \n        _convertMDXToEarned(); \n    } \n \n    function _convertMDXToEarned() internal { \n        // Converts MDX (if any) to earned tokens \n        uint256 MDXAmt = IERC20(MDXAddress).balanceOf(address(this)); \n        if (MDXAddress != earnedAddress && MDXAmt > 0) { \n            IERC20(MDXAddress).safeIncreaseAllowance(uniRouterAddress, MDXAmt); \n            // Swap all dust tokens to earned tokens \n            _safeSwap( \n                uniRouterAddress, \n                MDXAmt, \n                slippageFactor, \n                MDXToEarnedPath, \n                address(this), \n                block.timestamp.add(600) \n            ); \n        } \n"
        ]
    },
    {
        "PdfName": "Corite Token_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \n/** \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes calldata) { \n        return msg.data; \n    } \n} \n \n \n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.3 \n \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor() { \n        _setOwner(_msgSender()); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        _setOwner(address(0)); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        _setOwner(newOwner); \n    } \n \n    function _setOwner(address newOwner) private { \n        address oldOwner = _owner; \n        _owner = newOwner; \n        emit OwnershipTransferred(oldOwner, newOwner); \n    } \n} \n \n \n// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.3.3 \n \n",
            "pragma solidity ^0.8.0; \n \n// CAUTION \n// This version of SafeMath should only be used with Solidity 0.8 or later, \n// because it relies on the compiler's built in overflow checks. \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations. \n * \n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler \n * now has built in overflow checking. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            uint256 c = a + b; \n            if (c < a) return (false, 0); \n            return (true, c); \n        } \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b > a) return (false, 0); \n            return (true, a - b); \n        } \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n            // benefit is lost if 'b' is also tested. \n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n            if (a == 0) return (true, 0); \n            uint256 c = a * b; \n            if (c / a != b) return (false, 0); \n            return (true, c); \n        } \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b == 0) return (false, 0); \n            return (true, a / b); \n        } \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b == 0) return (false, 0); \n            return (true, a % b); \n        } \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a + b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a * b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b <= a, errorMessage); \n            return a - b; \n        } \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b > 0, errorMessage); \n            return a / b; \n        } \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b > 0, errorMessage); \n            return a % b; \n        } \n    } \n} \n \n \n// File contracts/IBep20.sol \n \n",
            "pragma solidity 0.8.10; \n \ninterface IBEP20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the token decimals. \n     */ \n    function decimals() external view returns (uint8); \n \n    /** \n     * @dev Returns the token symbol. \n     */ \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the token name. \n     */ \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the bep token owner. \n     */ \n    function getOwner() external view returns (address); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address _owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File contracts/Token.sol \n \n",
            "pragma solidity 0.8.10; \n \n \n \ncontract CoriteToken is Context, IBEP20, Ownable { \n  using SafeMath for uint256; \n \n  mapping (address => uint256) private _balances; \n \n  mapping (address => mapping (address => uint256)) private _allowances; \n \n  event TransferToNative(address indexed from, bytes32 indexed to, uint256 value); \n  event TransferFromNative(address indexed to, bytes32 indexed refID, uint256 value); \n \n  uint256 private _totalSupply; \n  uint8 private _decimals; \n  string private _symbol; \n  string private _name; \n \n  constructor(uint256 theTotalSupply, address owner) { \n    _name = \"CO\"; \n    _symbol = \"CO\"; \n    _decimals = 6; \n    _totalSupply = theTotalSupply; \n    _balances[owner] = theTotalSupply; \n    emit Transfer(address(0), owner, _totalSupply); \n \n    transferOwnership(owner); \n  } \n \n  /** \n   * @dev Returns the bep token owner. \n   */ \n  function getOwner() override external view returns (address) { \n    return owner(); \n  } \n \n  /** \n   * @dev Returns the token decimals. \n   */ \n  function decimals() override external view returns (uint8) { \n    return _decimals; \n  } \n \n  /** \n   * @dev Returns the token symbol. \n   */ \n  function symbol() override external view returns (string memory) { \n    return _symbol; \n  } \n \n  /** \n  * @dev Returns the token name. \n  */ \n  function name() override external view returns (string memory) { \n    return _name; \n  } \n \n  /** \n   * @dev See {BEP20-totalSupply}. \n   */ \n  function totalSupply() override external view returns (uint256) { \n    return _totalSupply; \n  } \n \n  /** \n   * @dev See {BEP20-balanceOf}. \n   */ \n  function balanceOf(address account) override external view returns (uint256) { \n    return _balances[account]; \n  } \n \n  /** \n   * @dev See {BEP20-transfer}. \n   * \n   * Requirements: \n   * \n   * - `recipient` cannot be the zero address. \n   * - the caller must have a balance of at least `amount`. \n   */ \n  function transfer(address recipient, uint256 amount) override external returns (bool) { \n    _transfer(_msgSender(), recipient, amount); \n    return true; \n  } \n \n  /** \n   * @dev See {BEP20-allowance}. \n   */ \n  function allowance(address owner, address spender) override external view returns (uint256) { \n    return _allowances[owner][spender]; \n  } \n \n  /** \n   * @dev See {BEP20-approve}. \n   * \n   * Requirements: \n   * \n   * - `spender` cannot be the zero address. \n   */ \n  function approve(address spender, uint256 amount) override external returns (bool) { \n    _approve(_msgSender(), spender, amount); \n    return true; \n  } \n \n  /** \n   * @dev See {BEP20-transferFrom}. \n   * \n   * Emits an {Approval} event indicating the updated allowance. This is not \n   * required by the EIP. See the note at the beginning of {BEP20}; \n   * \n   * Requirements: \n   * - `sender` and `recipient` cannot be the zero address. \n   * - `sender` must have a balance of at least `amount`. \n   * - the caller must have allowance for `sender`'s tokens of at least \n   * `amount`. \n   */ \n  function transferFrom(address sender, address recipient, uint256 amount) override external returns \n    _transfer(sender, recipient, amount); \n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amo\n    return true; \n  } \n \n  /** \n   * @dev Atomically increases the allowance granted to `spender` by the caller. \n   * \n   * This is an alternative to {approve} that can be used as a mitigation for \n   * problems described in {BEP20-approve}. \n   * \n   * Emits an {Approval} event indicating the updated allowance. \n   * \n   * Requirements: \n   * \n   * - `spender` cannot be the zero address. \n   */ \n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) { \n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n    return true; \n  } \n \n  /** \n   * @dev Atomically decreases the allowance granted to `spender` by the caller. \n   * \n   * This is an alternative to {approve} that can be used as a mitigation for \n   * problems described in {BEP20-approve}. \n   * \n   * Emits an {Approval} event indicating the updated allowance. \n   * \n   * Requirements: \n   * \n   * - `spender` cannot be the zero address. \n   * - `spender` must have allowance for the caller of at least \n   * `subtractedValue`. \n   */ \n  function decreaseAllowance(address spender, uint256 subtractedValue)  public returns (bool) { \n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: d\n    return true; \n  } \n \n  /** \n   * @dev Moves tokens `amount` from `sender` to `recipient`. \n   * \n   * This is internal function is equivalent to {transfer}, and can be used to \n   * e.g. implement automatic token fees, slashing mechanisms, etc. \n   * \n   * Emits a {Transfer} event. \n   * \n   * Requirements: \n   * \n   * - `sender` cannot be the zero address. \n   * - `recipient` cannot be the zero address. \n   * - `sender` must have a balance of at least `amount`. \n   */ \n  function _transfer(address sender, address recipient, uint256 amount) internal { \n    require(sender != address(0), \"BEP20: transfer from the zero address\"); \n    require(recipient != address(0), \"BEP20: transfer to the zero address\"); \n \n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\"); \n    _balances[recipient] = _balances[recipient].add(amount); \n    emit Transfer(sender, recipient, amount); \n  } \n \n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n   * the total supply. \n   * \n   * Emits a {Transfer} event with `from` set to the zero address. \n   * \n   * Requirements \n   * \n   * - `to` cannot be the zero address. \n   */ \n  function _mint(address account, uint256 amount) internal { \n    require(account != address(0), \"BEP20: mint to the zero address\"); \n \n    _totalSupply = _totalSupply.add(amount); \n    _balances[account] = _balances[account].add(amount); \n    emit Transfer(address(0), account, amount); \n  } \n \n    /** \n     * @dev Burns a specific amount of tokens and emit transfer event for native chain \n     * @param to The address to transfer to in the native chain. \n     * @param value The amount of token to be burned. \n     */ \n    function transferToNative(bytes32 to, uint256 value) public { \n        _burn(msg.sender, value); \n        emit TransferToNative(msg.sender, to, value); \n    } \n \n    /** \n     * @dev Function to mint tokens \n     * @param to The address that will receive the minted tokens. \n     * @param value The amount of tokens to mint. \n     * @param refID identifier of a transfer on source chain, if any \n     * @return A boolean that indicates if the operation was successful. \n     */ \n    function transferFromNative(address to, uint256 value, bytes32 refID) public onlyOwner returns (b\n        _mint(to, value); \n        emit TransferFromNative(to, refID, value); \n        return true; \n    } \n \n  /** \n   * @dev Destroys `amount` tokens from `account`, reducing the \n   * total supply. \n   * \n   * Emits a {Transfer} event with `to` set to the zero address. \n   * \n   * Requirements \n   * \n   * - `account` cannot be the zero address. \n   * - `account` must have at least `amount` tokens. \n   */ \n  function _burn(address account, uint256 amount) internal { \n    require(account != address(0), \"BEP20: burn from the zero address\"); \n \n    _balances[account] = _balances[account].sub(amount, \"BEP20: burn amount exceeds balance\"); \n    _totalSupply = _totalSupply.sub(amount); \n    emit Transfer(account, address(0), amount); \n  } \n \n  /** \n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens. \n   * \n   * This is internal function is equivalent to `approve`, and can be used to \n   * e.g. set automatic allowances for certain subsystems, etc. \n   * \n   * Emits an {Approval} event. \n   * \n   * Requirements: \n   * \n   * - `owner` cannot be the zero address. \n   * - `spender` cannot be the zero address. \n   */ \n  function _approve(address owner, address spender, uint256 amount) internal { \n    require(owner != address(0), \"BEP20: approve from the zero address\"); \n    require(spender != address(0), \"BEP20: approve to the zero address\"); \n \n    _allowances[owner][spender] = amount; \n    emit Approval(owner, spender, amount); \n  } \n \n  /** \n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted \n   * from the caller's allowance. \n   * \n   * See {_burn} and {_approve}. \n   */ \n  function _burnFrom(address account, uint256 amount) internal { \n"
        ]
    },
    {
        "PdfName": "DEFED_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \nimport \"./interfaces/IUserProxyFactory.sol\"; \nimport \"./UserProxy.sol\"; \n \ncontract UserProxyFactory is IUserProxyFactory { \n    mapping(address => address) public override getProxy; \n \n    // // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContrac\n    // bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b1\n \n    // keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"); \n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = \n    0x91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a2766; \n \n    bytes32 public DOMAIN_SEPARATOR; \n    string public constant name = \"User Proxy Factory V1\"; \n    string public constant VERSION = \"1\"; \n \n    constructor() { \n        // uint chainId; \n        // assembly { \n        //     chainId := chainid() \n        // } \n        DOMAIN_SEPARATOR = keccak256( \n            abi.encode( \n                DOMAIN_SEPARATOR_TYPEHASH, \n                keccak256(bytes(name)), \n                keccak256(bytes(VERSION)), \n                address(this) \n            ) \n        ); \n    } \n \n    function createProxy(address owner) \n    external \n    override \n    returns (address proxy) \n    { \n        require(owner != address(0), \"ZERO_ADDRESS\"); \n        require(getProxy[owner] == address(0), \"PROXY_EXISTS\"); \n        bytes memory bytecode = proxyCreationCode(); \n        bytes32 salt = keccak256(abi.encodePacked(address(this), owner)); \n        assembly { \n            proxy := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        getProxy[owner] = proxy; \n        IUserProxy(proxy).initialize(owner, DOMAIN_SEPARATOR); \n        emit ProxyCreated(owner, proxy); \n    } \n \n    function proxyRuntimeCode() public pure returns (bytes memory) { \n        return type(UserProxy).runtimeCode; \n    } \n \n    function proxyCreationCode() public pure returns (bytes memory) { \n        return type(UserProxy).creationCode; \n    } \n \n    function proxyCreationCodeHash() public pure returns (bytes32) { \n        return keccak256(proxyCreationCode()); \n    } \n} \n \n \n",
            "pragma solidity ^0.8.0; \n \nimport \"./libraries/SafeMath.sol\"; \nimport \"./libraries/Address.sol\"; \nimport \"./libraries/Context.sol\"; \nimport \"./interfaces/IVToken.sol\"; \nimport \"./interfaces/IVTokenFactory.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \n \ncontract VToken is IVToken, Context, IERC20 { \n    address public factory; \n    address public override ETHToken; \n    using SafeMath for uint256; \n    using Address for address; \n    mapping(address => uint256) private _balances; \n    mapping(address => mapping(address => uint256)) private _allowances; \n    uint256 private _totalSupply; \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n    event Mint(address indexed from, uint256 value); \n    event Burn(address indexed from, uint256 value); \n \n    constructor() { \n        factory = msg.sender; \n    } \n \n    function initialize( \n        address token, \n        string memory tokenName, \n        string memory tokenSymbol, \n        uint8 tokenDecimals \n    ) external override { \n        require(msg.sender == factory, \"FORBIDDEN\"); \n        require(token != address(0)); \n        ETHToken = token; \n        _name = tokenName; \n        _symbol = tokenSymbol; \n        _decimals = tokenDecimals; \n    } \n \n    uint256 private unlocked = 1; \n    modifier lock() { \n        require(unlocked == 1, \"LOCKED\"); \n        unlocked = 0; \n        _; \n        unlocked = 1; \n    } \n \n    bytes4 private constant SELECTOR = \n    bytes4(keccak256(bytes(\"transfer(address,uint256)\"))); \n \n    function _safeTransfer( \n        address token, \n        address to, \n        uint256 value \n    ) private { \n        (bool success, bytes memory data) = token.call( \n            abi.encodeWithSelector(SELECTOR, to, value) \n        ); \n        require( \n            success && (data.length == 0 || abi.decode(data, (bool))), \n            \"TRANSFER_FAILED\" \n        ); \n    } \n \n    function mint(address spender, uint256 amount) external override { \n        require( \n            IVTokenFactory(factory).bridgeControl() == msg.sender, \n            \"Ownable: caller is not the owner\" \n        ); \n        _mint(spender, amount); \n        emit Mint(spender, amount); \n    } \n \n    function burn(address spender, uint256 amount) external override { \n        require( \n            IVTokenFactory(factory).bridgeControl() == msg.sender, \n            \"Ownable: caller is not the owner\" \n        ); \n        _burn(spender, amount); \n        emit Burn(spender, amount); \n    } \n \n    function name() public view returns (string memory) { \n        return _name; \n    } \n \n    function symbol() public view returns (string memory) { \n        return _symbol; \n    } \n \n    function decimals() public view override returns (uint8) { \n        return _decimals; \n    } \n \n    function totalSupply() public view override returns (uint256) { \n        return _totalSupply; \n    } \n \n    function balanceOf(address account) public view override returns (uint256) { \n        return _balances[account]; \n    } \n \n    function transfer(address recipient, uint256 amount) \n    public \n    virtual \n    override \n    returns (bool) \n    { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    function allowance(address owner, address spender) \n    public \n    view \n    virtual \n    override \n    returns (uint256) \n    { \n        return _allowances[owner][spender]; \n    } \n \n    function approve(address spender, uint256 amount) \n    public \n    virtual \n    override \n    returns (bool) \n    { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) public virtual override returns (bool) { \n        _transfer(sender, recipient, amount); \n        _approve( \n            sender, \n            _msgSender(), \n            _allowances[sender][_msgSender()].sub( \n                amount, \n                \"ERC20: transfer amount exceeds allowance\" \n            ) \n        ); \n        return true; \n    } \n \n    function increaseAllowance(address spender, uint256 addedValue) \n    public \n    virtual \n    returns (bool) \n    { \n        _approve( \n            _msgSender(), \n            spender, \n            _allowances[_msgSender()][spender].add(addedValue) \n        ); \n        return true; \n    } \n \n    function decreaseAllowance(address spender, uint256 subtractedValue) \n    public \n    virtual \n    returns (bool) \n    { \n        _approve( \n            _msgSender(), \n            spender, \n            _allowances[_msgSender()][spender].sub( \n                subtractedValue, \n                \"ERC20: decreased allowance below zero\" \n            ) \n        ); \n        return true; \n    } \n \n    function _transfer( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub( \n            amount, \n            \"ERC20: transfer amount exceeds balance\" \n        ); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub( \n            amount, \n            \"ERC20: burn amount exceeds balance\" \n        ); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    function _approve( \n        address owner, \n        address spender, \n        uint256 amount \n    ) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    function _setupDecimals(uint8 decimals_) internal { \n        _decimals = decimals_; \n    } \n \n    function _beforeTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual {} \n} \n \n \n",
            "pragma solidity ^0.8.0; \n \nimport \"./interfaces/IVTokenFactory.sol\"; \nimport \"./VToken.sol\"; \nimport \"./libraries/Ownable.sol\"; \n \ncontract VTokenFactory is IVTokenFactory, Ownable { \n    mapping(address => address) public override getVToken; \n    address public override bridgeControl; \n \n    function createVToken( \n        address token, \n        string memory tokenName, \n        string memory tokenSymbol, \n        uint8 tokenDecimals \n    ) public override onlyOwner returns (address vToken) { \n        require(bridgeControl != address(0), \"ZERO_ADDRESS\"); \n        require(token != address(0), \"ZERO_ADDRESS\"); \n        require(getVToken[token] == address(0), \"VTOKEN_EXISTS\"); \n        bytes memory bytecode = creationCode(); \n        bytes32 salt = keccak256(abi.encodePacked(address(this), token)); \n        assembly { \n            vToken := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        getVToken[token] = vToken; \n        VToken(vToken).initialize(token, tokenName, tokenSymbol, tokenDecimals); \n        emit VTokenCreated(token, vToken); \n    } \n \n    function setBridgeControl(address _bridgeControl) \n    public \n    override \n    onlyOwner \n    { \n        require(_bridgeControl != address(0)); \n        bridgeControl = _bridgeControl; \n    } \n \n    function runtimeCode() public pure returns (bytes memory) { \n        return type(VToken).runtimeCode; \n    } \n \n    function creationCode() public pure returns (bytes memory) { \n        return type(VToken).creationCode; \n    } \n \n    function creationCodeHash() public pure returns (bytes32) { \n        return keccak256(creationCode()); \n    } \n} \n \n \n",
            "pragma solidity 0.8.0; \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \n \n/** \n * @notice implementation of the DEFED token contract \n * @author DEFED \n */ \ncontract DefeToken is ERC20 { \n    string internal constant NAME = \"DEFE Token\"; \n    string internal constant SYMBOL = \"DEFE\"; \n \n    uint256 internal constant TOTAL_SUPPLY = 1e28; \n \n    constructor(address misc) public ERC20(NAME, SYMBOL) { \n        _mint(misc, TOTAL_SUPPLY); \n    } \n} \n \n \n",
            "pragma solidity ^0.8.0; \n \nimport \"./interfaces/IUserProxy.sol\"; \nimport \"./libraries/ECDSA.sol\"; \nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\"; \n \ncontract UserProxy is IUserProxy { \n    mapping(uint256 => bool) public nonces; \n \n    // keccak256(\"ExecTransaction(address to,uint256 value,bytes data,uint8 operation,uint256 nonce)\"\n    bytes32 internal constant EXEC_TX_TYPEHASH = \n    0xa609e999e2804ed92314c0c662cfdb3c1d8107df2fb6f2e4039093f20d5e6250; \n    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1) \n    bytes32 internal constant ADMIN_SLOT = \n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103; \n    // bytes32(uint256(keccak256('eip1967.proxy.domain')) - 1) \n    bytes32 internal constant DOMAIN_SLOT = \n    0x5d29634e15c15fa29be556decae8ee5a34c9fee5f209623aed08a64bf865b694; \n \n    function initialize(address _owner, bytes32 _DOMAIN_SEPARATOR) \n    external \n    override \n    { \n        require(owner() == address(0), \"initialize error\"); \n        require(_owner != address(0), \"ERC1967: new owner is the zero address\"); \n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = _owner; \n        StorageSlot.getBytes32Slot(DOMAIN_SLOT).value = _DOMAIN_SEPARATOR; \n    } \n \n    function owner() public view override returns (address) { \n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value; \n    } \n \n    function domain() public view returns (bytes32) { \n        return StorageSlot.getBytes32Slot(DOMAIN_SLOT).value; \n    } \n \n    function execTransaction( \n        address to, \n        uint256 value, \n        bytes calldata data, \n        Operation operation, \n        uint256 nonce, \n        bytes memory signature \n    ) external override { \n        require(!nonces[nonce], \"nonce had used\"); \n        nonces[nonce] = true; \n        bytes32 digest = keccak256( \n            abi.encodePacked( \n                \"\\x19\\x01\", \n                domain(), \n                keccak256( \n                    abi.encode( \n                        EXEC_TX_TYPEHASH, \n                        to, \n                        value, \n                        keccak256(data), \n                        operation, \n                        nonce \n                    ) \n                ) \n            ) \n        ); \n        address recoveredAddress = ECDSA.recover(digest, signature); \n        require( \n            recoveredAddress != address(0) && recoveredAddress == owner(), \n            \"ECDSA: invalid signature\" \n        ); \n        execute(to, value, data, operation); \n    } \n \n    receive() external payable {} \n \n    fallback() external payable {} \n \n    function execTransaction( \n        address to, \n        uint256 value, \n        bytes calldata data, \n        Operation operation \n    ) external override { \n        require(msg.sender == owner(), \"ECDSA: invalid signature\"); \n        execute(to, value, data, operation); \n    } \n \n    function execute( \n        address to, \n        uint256 value, \n        bytes memory data, \n        Operation operation \n    ) internal { \n        if (operation == Operation.DelegateCall) { \n            assembly { \n                let result := delegatecall( \n                gas(), \n                to, \n                add(data, 0x20), \n                mload(data), \n                0, \n                ) \n                returndatacopy(0, 0, returndatasize()) \n                switch result \n                case 0 { \n                    revert(0, returndatasize()) \n                } \n                default { \n                    return(0, returndatasize()) \n                } \n            } \n        } else { \n            assembly { \n                let result := call( \n                gas(), \n                to, \n                value, \n                add(data, 0x20), \n                mload(data), \n                0, \n                ) \n                returndatacopy(0, 0, returndatasize()) \n                switch result \n                case 0 { \n                    revert(0, returndatasize()) \n                } \n                default { \n                    return(0, returndatasize()) \n                } \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity ^0.8.0; \npragma experimental ABIEncoderV2; \n \nimport \"./interfaces/IUserProxy.sol\"; \nimport \"./interfaces/IUserProxyFactory.sol\"; \nimport \"./interfaces/IVTokenFactory.sol\"; \nimport \"./interfaces/IVToken.sol\"; \nimport \"./interfaces/ILendingPool.sol\"; \nimport \"./libraries/Ownable.sol\"; \nimport \"./interfaces/IBridgeFeeController.sol\"; \nimport \"./interfaces/IIncentivesController.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \n \ninterface IVeDEFE { \n    struct LockedBalance { \n        int256 amount; \n        uint256 end; \n    } \n \n    function createLockFor( \n        address _beneficiary, \n        uint256 _value, \n        uint256 _unlockTime \n    ) external; \n \n    function increaseAmountFor(address _beneficiary, uint256 _value) external; \n \n    function getLocked(address _addr) \n    external \n    view \n    returns (LockedBalance memory); \n} \n \ncontract BridgeControl is Ownable { \n    using SafeERC20 for IERC20; \n    address public proxyFactory; \n    address public vTokenFactory; \n    address public lendingPool; \n    address public virtualDefedToken; \n    address public bridgeFeeController; \n    address public veDEFE; \n    mapping(bytes32 => bool) transactions; \n \n    event TransferToEthereum( \n        address indexed fromEthAdr, \n        address indexed toEthAdr, \n        address indexed toProxyAdr, \n        address token, \n        address vToken, \n        uint256 value, \n        uint256 action \n    ); \n    event TransferFromEthereum( \n        address indexed fromEthAdr, \n        address indexed fromProxyAdr, \n        address token, \n        address vToken, \n        uint256 value, \n        bytes32 transactionId \n    ); \n    event TransferFromEthereumForDeposit( \n        address indexed fromEthAdr, \n        address indexed fromProxyAdr, \n        address token, \n        address vToken, \n        uint256 value, \n        bytes32 transactionId \n    ); \n    event TransferFromEthereumForRepay( \n        address indexed fromEthAdr, \n        address indexed fromProxyAdr, \n        address token, \n        address vToken, \n        uint256 value, \n        bytes32 transactionId \n    ); \n    event lockFromEthereumLog( \n        address indexed fromEthAdr, \n        address indexed fromProxyAdr, \n        address virtualDefedToken, \n        uint256 value, \n        uint256 time, \n        bytes32 transactionId \n    ); \n    event BridgeFeeLog( \n        address indexed fromUserProxy, \n        address token, \n        uint256 fee \n    ); \n \n    constructor( \n        address _proxyFactory, \n        address _vTokenFactory, \n        address _lendingPool, \n        address _bridgeFeeController \n    ) { \n        require(_proxyFactory != address(0)); \n        require(_vTokenFactory != address(0)); \n        require(_lendingPool != address(0)); \n        require(_bridgeFeeController != address(0)); \n        proxyFactory = _proxyFactory; \n        vTokenFactory = _vTokenFactory; \n        lendingPool = _lendingPool; \n        bridgeFeeController = _bridgeFeeController; \n    } \n \n    function setVirtualDefedToken(address _virtualDefedToken, address _veDEFE) \n    external \n    onlyOwner \n    { \n        require(_virtualDefedToken != address(0)); \n        require(_veDEFE != address(0)); \n        virtualDefedToken = _virtualDefedToken; \n        veDEFE = _veDEFE; \n    } \n \n    function turnOutToken(address token, uint256 amount) public onlyOwner { \n        IERC20(token).safeTransfer(msg.sender, amount); \n    } \n \n    function transferToEthereum( \n        address from, \n        address vToken, \n        address to, \n        uint256 amount, \n        uint256 action \n    ) external { \n        address fromEthAddr = IUserProxy(from).owner(); \n        address toEthAddr = IUserProxy(to).owner(); \n        require(fromEthAddr != address(0), \"from PROXY_EXISTS\"); \n        require(toEthAddr != address(0), \"to PROXY_EXISTS\"); \n        address token = IVToken(vToken).ETHToken(); \n        require(token != address(0), \"unknow token\"); \n        (uint256 fee, address bridgeFeeVault) = IBridgeFeeController( \n            bridgeFeeController \n        ).getBridgeFee(vToken, amount); \n        if (fee > 0) { \n            IERC20(vToken).safeTransfer(bridgeFeeVault, fee); \n            emit BridgeFeeLog(from, vToken, fee); \n        } \n        uint256 targetAmount = amount - fee; \n        IVToken(vToken).burn(address(this), targetAmount); \n        emit TransferToEthereum( \n            fromEthAddr, \n            toEthAddr, \n            to, \n            token, \n            vToken, \n            targetAmount, \n            action \n        ); \n    } \n \n    function transferFromEthereumForDeposit( \n        bytes32 transactionId, \n        address token, \n        address to, \n        uint256 amount \n    ) public onlyOwner { \n        require(!transactions[transactionId], \"transactionId already exec\"); \n        transactions[transactionId] = true; \n \n        address vToken = IVTokenFactory(vTokenFactory).getVToken(token); \n        require(vToken != address(0), \"unknow token\"); \n        address proxyAddr = IUserProxyFactory(proxyFactory).getProxy(to); \n        if (proxyAddr == address(0)) { \n            proxyAddr = IUserProxyFactory(proxyFactory).createProxy(to); \n        } \n        IVToken(vToken).mint(address(this), amount); \n        IERC20(vToken).approve(lendingPool, amount); \n        ILendingPool(lendingPool).deposit(vToken, amount, proxyAddr, 0); \n        emit TransferFromEthereumForDeposit( \n            to, \n            proxyAddr, \n            token, \n            vToken, \n            amount, \n            transactionId \n        ); \n    } \n \n    function transferFromEthereumForRepay( \n        bytes32 transactionId, \n        address token, \n        address to, \n        uint256 amount, \n        uint256 rateMode \n    ) public onlyOwner { \n        require(!transactions[transactionId], \"transactionId already exec\"); \n        transactions[transactionId] = true; \n \n        address vToken = IVTokenFactory(vTokenFactory).getVToken(token); \n        require(vToken != address(0), \"unknow token\"); \n        address proxyAddr = IUserProxyFactory(proxyFactory).getProxy(to); \n        if (proxyAddr == address(0)) { \n            proxyAddr = IUserProxyFactory(proxyFactory).createProxy(to); \n        } \n        IVToken(vToken).mint(address(this), amount); \n        IERC20(vToken).approve(lendingPool, amount); \n        ILendingPool(lendingPool).repay(vToken, amount, rateMode, proxyAddr); \n        uint256 balanceAfterRepay = IERC20(vToken).balanceOf(address(this)); \n        if (balanceAfterRepay > 0) { \n            ILendingPool(lendingPool).deposit( \n                vToken, \n                balanceAfterRepay, \n                proxyAddr, \n            ); \n        } \n        emit TransferFromEthereumForRepay( \n            to, \n            proxyAddr, \n            token, \n            vToken, \n            amount, \n            transactionId \n        ); \n    } \n \n    function transferFromEthereum( \n        bytes32 transactionId, \n        address token, \n        address to, \n        uint256 amount \n    ) public onlyOwner { \n        require(!transactions[transactionId], \"transactionId already exec\"); \n        transactions[transactionId] = true; \n \n        address vToken = IVTokenFactory(vTokenFactory).getVToken(token); \n        require(vToken != address(0), \"unknow token\"); \n        address proxyAddr = IUserProxyFactory(proxyFactory).getProxy(to); \n        if (proxyAddr == address(0)) { \n            proxyAddr = IUserProxyFactory(proxyFactory).createProxy(to); \n        } \n        IVToken(vToken).mint(proxyAddr, amount); \n        emit TransferFromEthereum( \n            to, \n            proxyAddr, \n            token, \n            vToken, \n            amount, \n            transactionId \n        ); \n    } \n \n    function lockFromEthereum( \n        bytes32 transactionId, \n        address user, \n        uint256 amount, \n        uint256 time \n    ) public onlyOwner { \n        require(!transactions[transactionId], \"transactionId already exec\"); \n        transactions[transactionId] = true; \n \n        address proxyAddr = IUserProxyFactory(proxyFactory).getProxy(user); \n        if (proxyAddr == address(0)) { \n            proxyAddr = IUserProxyFactory(proxyFactory).createProxy(user); \n        } \n        lockDefe(proxyAddr, amount, time); \n        emit lockFromEthereumLog( \n            user, \n            proxyAddr, \n            virtualDefedToken, \n            amount, \n            time, \n            transactionId \n        ); \n    } \n \n    function lockDefe( \n        address proxyAddr, \n        uint256 amount, \n        uint256 time \n    ) internal { \n        IVeDEFE.LockedBalance memory locked = IVeDEFE(veDEFE).getLocked( \n            proxyAddr \n        ); \n        IERC20(virtualDefedToken).approve(veDEFE, amount); \n        if (locked.amount == 0) { \n            IVeDEFE(veDEFE).createLockFor(proxyAddr, amount, time); \n        } else { \n            IVeDEFE(veDEFE).increaseAmountFor(proxyAddr, amount); \n        } \n    } \n} \n \n \n",
            "pragma solidity ^0.8.0; \npragma experimental ABIEncoderV2; \n \nimport \"./interfaces/IUserProxyFactory.sol\"; \nimport \"./interfaces/IUserProxy.sol\"; \nimport \"./interfaces/IVTokenFactory.sol\"; \nimport \"./interfaces/ILendingPool.sol\"; \nimport \"./interfaces/IBridgeControl.sol\"; \nimport \"./interfaces/ITokenController.sol\"; \nimport \"./interfaces/INetworkFeeController.sol\"; \nimport \"./interfaces/IIncentivesController.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \n \ncontract TokenController { \n    using SafeERC20 for IERC20; \n    struct Params { \n        address lendingPool; \n        address bridgeControl; \n        address vTokenFactory; \n        address proxyFactory; \n        address networkFeeController; \n    } \n    mapping(address => Params) public addressParams; \n \n    event BorrowToEthereum(address asset, uint256 value, address toEthAdr); \n \n    event Borrow(address asset, uint256 value, address toEthAdr); \n \n    event Repay(address asset, uint256 value, uint256 rateMode); \n \n    event WithdrawToEthereum(address asset, uint256 value, address toEthAdr); \n \n    event Transfer(address asset, uint256 value, address toEthAdr); \n \n    event TransferToEthereum(address asset, uint256 value, address toEthAdr); \n \n    event TransferCredit( \n        address asset, \n        uint256 value, \n        address toEthAdr, \n        uint256 interestRateMode, \n        uint16 referralCode \n    ); \n \n    event TransferCreditToEthereum( \n        address asset, \n        uint256 value, \n        address toEthAdr, \n        uint256 interestRateMode, \n        uint16 referralCode \n    ); \n \n    event NetworkFeeLog( \n        address fromUserProxy, \n        address token, \n        uint256 fee, \n        uint256 action \n    ); \n \n    constructor( \n        address _lendingPOOL, \n        address _bridgeControl, \n        address _vTokenFactory, \n        address _proxyFactory, \n        address _networkFeeController \n    ) { \n        address tokenController = address(this); \n        addressParams[tokenController].lendingPool = _lendingPOOL; \n        addressParams[tokenController].bridgeControl = _bridgeControl; \n        addressParams[tokenController].vTokenFactory = _vTokenFactory; \n        addressParams[tokenController].proxyFactory = _proxyFactory; \n        addressParams[tokenController] \n        .networkFeeController = _networkFeeController; \n    } \n \n    function withdrawToEthereum( \n        address tokenController, \n        address asset, \n        uint256 amount \n    ) public { \n        bytes4 method = bytes4( \n            keccak256(\"withdrawToEthereum(address,address,uint256)\") \n        ); \n        Params memory params = TokenController(tokenController).getParams(); \n        address vToken = IVTokenFactory(params.vTokenFactory).getVToken(asset); \n        address ethUser = IUserProxy(address(this)).owner(); \n        require(vToken != address(0), \"unknow token\"); \n        ILendingPool(params.lendingPool).withdraw( \n            vToken, \n            amount, \n            address(this) \n        ); \n        (uint256 fee, address networkFeeVault) = INetworkFeeController( \n            params.networkFeeController \n        ).getNetworkFee(ethUser, method, vToken, amount); \n        if (fee > 0) { \n            IERC20(vToken).safeTransfer(networkFeeVault, fee); \n            emit NetworkFeeLog(address(this), vToken, fee, 1); \n        } \n        uint256 targetAmount = amount - fee; \n        IERC20(vToken).safeTransfer(params.bridgeControl, targetAmount); \n        IBridgeControl(params.bridgeControl).transferToEthereum( \n            address(this), \n            vToken, \n            address(this), \n            targetAmount, \n        ); \n        emit WithdrawToEthereum(asset, targetAmount, ethUser); \n    } \n \n    function borrowToEthereum( \n        address tokenController, \n        address asset, \n        uint256 amount, \n        uint256 interestRateMode, \n        uint16 referralCode \n    ) public { \n        bytes4 method = bytes4( \n            keccak256( \n                \"borrowToEthereum(address,address,uint256,uint256,uint16)\" \n            ) \n        ); \n        Params memory params = TokenController(tokenController).getParams(); \n        address vToken = IVTokenFactory(params.vTokenFactory).getVToken(asset); \n        require(vToken != address(0), \"unknow token\"); \n        address ethUser = IUserProxy(address(this)).owner(); \n        ILendingPool(params.lendingPool).borrow( \n            vToken, \n            amount, \n            interestRateMode, \n            referralCode, \n            address(this) \n        ); \n        (uint256 fee, address networkFeeVault) = INetworkFeeController( \n            params.networkFeeController \n        ).getNetworkFee(ethUser, method, vToken, amount); \n        if (fee > 0) { \n            IERC20(vToken).safeTransfer(networkFeeVault, fee); \n            emit NetworkFeeLog(address(this), vToken, fee, 2); \n        } \n        uint256 targetAmount = amount - fee; \n        IERC20(vToken).safeTransfer(params.bridgeControl, targetAmount); \n        IBridgeControl(params.bridgeControl).transferToEthereum( \n            address(this), \n            vToken, \n            address(this), \n            targetAmount, \n        ); \n        emit BorrowToEthereum(asset, targetAmount, ethUser); \n    } \n \n    function borrow( \n        address tokenController, \n        address asset, \n        uint256 amount, \n        uint256 interestRateMode, \n        uint16 referralCode \n    ) public { \n        bytes4 method = bytes4( \n            keccak256(\"borrow(address,address,uint256,uint256,uint16)\") \n        ); \n        Params memory params = TokenController(tokenController).getParams(); \n        address vToken = IVTokenFactory(params.vTokenFactory).getVToken(asset); \n        require(vToken != address(0), \"unknow token\"); \n        address ethUser = IUserProxy(address(this)).owner(); \n        ILendingPool(params.lendingPool).borrow( \n            vToken, \n            amount, \n            interestRateMode, \n            referralCode, \n            address(this) \n        ); \n        (uint256 fee, address networkFeeVault) = INetworkFeeController( \n            params.networkFeeController \n        ).getNetworkFee(ethUser, method, vToken, amount); \n        if (fee > 0) { \n            IERC20(vToken).safeTransfer(networkFeeVault, fee); \n            emit NetworkFeeLog(address(this), vToken, fee, 3); \n        } \n        uint256 targetAmount = amount - fee; \n        IERC20(vToken).approve(params.lendingPool, targetAmount); \n        ILendingPool(params.lendingPool).deposit( \n            vToken, \n            targetAmount, \n            address(this), \n            referralCode \n        ); \n        emit Borrow(asset, targetAmount, ethUser); \n    } \n \n    function transfer( \n        address tokenController, \n        address asset, \n        uint256 amount, \n        address to \n    ) public { \n        bytes4 method = bytes4( \n            keccak256(\"transfer(address,address,uint256,address)\") \n        ); \n        Params memory params = TokenController(tokenController).getParams(); \n        address vToken = IVTokenFactory(params.vTokenFactory).getVToken(asset); \n        require(vToken != address(0), \"unknow token\"); \n        address proxyAddr = IUserProxyFactory(params.proxyFactory).getProxy(to); \n        if (proxyAddr == address(0)) { \n            proxyAddr = IUserProxyFactory(params.proxyFactory).createProxy(to); \n        } \n        address ethUser = IUserProxy(address(this)).owner(); \n        (uint256 fee, address networkFeeVault) = INetworkFeeController( \n            params.networkFeeController \n        ).getNetworkFee(ethUser, method, vToken, amount); \n        if (fee > 0) { \n            ILendingPool(params.lendingPool).withdraw( \n                vToken, \n                fee, \n                networkFeeVault \n            ); \n            emit NetworkFeeLog(address(this), vToken, fee, 4); \n        } \n        uint256 targetAmount = amount - fee; \n        (, , , , , , , address aToken, , , , ) = ILendingPool( \n            params.lendingPool \n        ).getReserveData(vToken); \n        IERC20(aToken).safeTransfer(proxyAddr, targetAmount); \n        emit Transfer(asset, targetAmount, to); \n    } \n \n    function transferToEthereum( \n        address tokenController, \n        address asset, \n        uint256 amount, \n        address to \n    ) public { \n        bytes4 method = bytes4( \n            keccak256(\"transferToEthereum(address,address,uint256,address)\") \n        ); \n        Params memory params = TokenController(tokenController).getParams(); \n        address vToken = IVTokenFactory(params.vTokenFactory).getVToken(asset); \n        require(vToken != address(0), \"unknow token\"); \n        address proxyAddr = IUserProxyFactory(params.proxyFactory).getProxy(to); \n        if (proxyAddr == address(0)) { \n            proxyAddr = IUserProxyFactory(params.proxyFactory).createProxy(to); \n        } \n        address ethUser = IUserProxy(address(this)).owner(); \n        ILendingPool(params.lendingPool).withdraw( \n            vToken, \n            amount, \n            address(this) \n        ); \n        (uint256 fee, address networkFeeVault) = INetworkFeeController( \n            params.networkFeeController \n        ).getNetworkFee(ethUser, method, vToken, amount); \n        if (fee > 0) { \n            IERC20(vToken).safeTransfer(networkFeeVault, fee); \n            emit NetworkFeeLog(address(this), vToken, fee, 5); \n        } \n        uint256 targetAmount = amount - fee; \n        IERC20(vToken).safeTransfer(params.bridgeControl, targetAmount); \n        IBridgeControl(params.bridgeControl).transferToEthereum( \n            address(this), \n            vToken, \n            proxyAddr, \n            targetAmount, \n        ); \n        emit TransferToEthereum(asset, targetAmount, to); \n    } \n \n    function transferCredit( \n        address tokenController, \n        address asset, \n        uint256 amount, \n        address to, \n        uint256 interestRateMode, \n        uint16 referralCode \n    ) public { \n        bytes4 method = bytes4( \n            keccak256( \n                \"transferCredit(address,address,uint256,address,uint256,uint16)\" \n            ) \n        ); \n        Params memory params = TokenController(tokenController).getParams(); \n        address vToken = IVTokenFactory(params.vTokenFactory).getVToken(asset); \n        require(vToken != address(0), \"unknow token\"); \n        address proxyAddr = IUserProxyFactory(params.proxyFactory).getProxy(to); \n        address ethUser = IUserProxy(address(this)).owner(); \n        if (proxyAddr == address(0)) { \n            proxyAddr = IUserProxyFactory(params.proxyFactory).createProxy(to); \n        } \n        ILendingPool(params.lendingPool).borrow( \n            vToken, \n            amount, \n            interestRateMode, \n            referralCode, \n            address(this) \n        ); \n        (uint256 fee, address networkFeeVault) = INetworkFeeController( \n            params.networkFeeController \n        ).getNetworkFee(ethUser, method, vToken, amount); \n        if (fee > 0) { \n            IERC20(vToken).safeTransfer(networkFeeVault, fee); \n            emit NetworkFeeLog(address(this), vToken, fee, 6); \n        } \n        uint256 targetAmount = amount - fee; \n        IERC20(vToken).approve(params.lendingPool, targetAmount); \n        ILendingPool(params.lendingPool).deposit( \n            vToken, \n            targetAmount, \n            proxyAddr, \n            referralCode \n        ); \n        emit TransferCredit( \n            asset, \n            targetAmount, \n            to, \n            interestRateMode, \n            referralCode \n        ); \n    } \n \n    function transferCreditToEthereum( \n        address tokenController, \n        address asset, \n        uint256 amount, \n        address to, \n        uint256 interestRateMode, \n        uint16 referralCode \n    ) public { \n        bytes4 method = bytes4( \n            keccak256( \n                \"transferCreditToEthereum(address,address,uint256,address,uint256,uint16)\" \n            ) \n        ); \n        Params memory params = TokenController(tokenController).getParams(); \n        address vToken = IVTokenFactory(params.vTokenFactory).getVToken(asset); \n        require(vToken != address(0), \"unknow token\"); \n        address proxyAddr = IUserProxyFactory(params.proxyFactory).getProxy(to); \n        address ethUser = IUserProxy(address(this)).owner(); \n        if (proxyAddr == address(0)) { \n            proxyAddr = IUserProxyFactory(params.proxyFactory).createProxy(to); \n        } \n        ILendingPool(params.lendingPool).borrow( \n            vToken, \n            amount, \n            interestRateMode, \n            referralCode, \n            address(this) \n        ); \n        (uint256 fee, address networkFeeVault) = INetworkFeeController( \n            params.networkFeeController \n        ).getNetworkFee(ethUser, method, vToken, amount); \n        if (fee > 0) { \n            IERC20(vToken).safeTransfer(networkFeeVault, fee); \n            emit NetworkFeeLog(address(this), vToken, fee, 7); \n        } \n        uint256 targetAmount = amount - fee; \n        IERC20(vToken).safeTransfer(params.bridgeControl, targetAmount); \n        IBridgeControl(params.bridgeControl).transferToEthereum( \n            address(this), \n            vToken, \n            proxyAddr, \n            targetAmount, \n        ); \n        emit TransferCreditToEthereum( \n            asset, \n            targetAmount, \n            to, \n            interestRateMode, \n            referralCode \n        ); \n    } \n \n    function repay( \n        address tokenController, \n        address asset, \n        uint256 amount, \n        uint256 rateMode \n    ) public { \n        bytes4 method = bytes4( \n            keccak256(\"repay(address,address,uint256,uint256)\") \n        ); \n        Params memory params = TokenController(tokenController).getParams(); \n        address vToken = IVTokenFactory(params.vTokenFactory).getVToken(asset); \n        require(vToken != address(0), \"unknow token\"); \n        ILendingPool(params.lendingPool).withdraw( \n            vToken, \n            amount, \n            address(this) \n        ); \n        address ethUser = IUserProxy(address(this)).owner(); \n        (uint256 fee, address networkFeeVault) = INetworkFeeController( \n            params.networkFeeController \n        ).getNetworkFee(ethUser, method, vToken, amount); \n        if (fee > 0) { \n            IERC20(vToken).safeTransfer(networkFeeVault, fee); \n            emit NetworkFeeLog(address(this), vToken, fee, 8); \n        } \n        uint256 targetAmount = amount - fee; \n        ILendingPool(params.lendingPool).repay( \n            vToken, \n            targetAmount, \n            rateMode, \n            address(this) \n        ); \n        uint256 balanceAfterRepay = IERC20(vToken).balanceOf(address(this)); \n        if (balanceAfterRepay != 0) { \n            ILendingPool(params.lendingPool).deposit( \n                vToken, \n                balanceAfterRepay, \n                address(this), \n            ); \n        } \n        emit Repay(asset, targetAmount, rateMode); \n    } \n \n    function getParams() external view returns (Params memory) { \n        return addressParams[address(this)]; \n    } \n} \n \n \n",
            "pragma solidity ^0.8.0; \npragma experimental ABIEncoderV2; \n \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \n \ninterface IWETH { \n    function deposit() external payable; \n \n    function withdraw(uint256) external; \n} \n \ninterface IERC721 { \n    function mint(address to) external; \n} \n \ncontract AssetManagement is Ownable { \n    using SafeERC20 for IERC20; \n    mapping(address => bool) public activeTokens; \n    address[] private contracts; \n    mapping(address => bool) public deposited; \n    mapping(bytes32 => bool) transactions; \n    address public WETH; \n    address public BANKCARDNFT; \n    uint256 public lastTokenId; \n \n    event Deposit(address sender, address token, uint256 value); \n    event DepositForRepay(address sender, address token, uint256 value); \n    event Widthdraw( \n        address reciver, \n        address token, \n        uint256 value, \n        string action, \n        bytes32 transactionId \n    ); \n    event WidthdrawETH( \n        address reciver, \n        uint256 value, \n        string action, \n        bytes32 transactionId \n    ); \n    event ActiveToken(address token); \n    event PauseToken(address token); \n    event ChangeSigner(address signer, bool flag); \n    event FeeChange(uint256 fee); \n \n    constructor(address _weth, address _bankCardNFT) { \n        require(_weth != address(0)); \n        require(_bankCardNFT != address(0)); \n        activeTokens[_weth] = true; \n        contracts.push(_weth); \n        WETH = _weth; \n        BANKCARDNFT = _bankCardNFT; \n    } \n \n    function deposit(address token, uint256 amount) external { \n        require(amount > 0, \"Deposit: amount can not be 0\"); \n        if (!deposited[msg.sender]) { \n            deposited[msg.sender] = true; \n            _mintNFT(msg.sender); \n        } \n        require(activeTokens[token], \"Deposit: token not support\"); \n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount); \n        emit Deposit(msg.sender, token, amount); \n    } \n \n    function depositForRepay(address token, uint256 amount) external { \n        require(amount > 0, \"DepositForRepay: amount can not be 0\"); \n        if (!deposited[msg.sender]) { \n            deposited[msg.sender] = true; \n            _mintNFT(msg.sender); \n        } \n        require(activeTokens[token], \"DepositForRepay: token not support\"); \n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount); \n        emit DepositForRepay(msg.sender, token, amount); \n    } \n \n    function depositETHForRepay() external payable { \n        require(msg.value > 0, \"DepositETHForRepay: amount  zero\"); \n        if (!deposited[msg.sender]) { \n            deposited[msg.sender] = true; \n            _mintNFT(msg.sender); \n        } \n        IWETH(WETH).deposit{value: msg.value}(); \n        emit DepositForRepay(msg.sender, WETH, msg.value); \n    } \n \n    function depositETH() external payable { \n        require(msg.value > 0, \"DepositETH: amount  zero\"); \n        if (!deposited[msg.sender]) { \n            deposited[msg.sender] = true; \n            _mintNFT(msg.sender); \n        } \n        IWETH(WETH).deposit{value: msg.value}(); \n        emit Deposit(msg.sender, WETH, msg.value); \n    } \n \n    function withdraw( \n        bytes32 transactionId, \n        address token, \n        address to, \n        uint256 amount, \n        string memory action \n    ) public onlyOwner { \n        require(!transactions[transactionId], \"repeat transactionId \"); \n        transactions[transactionId] = true; \n        IERC20(token).safeTransfer(to, amount); \n        emit Widthdraw(to, token, amount, action, transactionId); \n    } \n \n    function withdrawETH( \n        bytes32 transactionId, \n        address to, \n        uint256 amount, \n        string memory action \n    ) public onlyOwner { \n        require(!transactions[transactionId], \"repeat transactionId \"); \n        transactions[transactionId] = true; \n        IWETH(WETH).withdraw(amount); \n        _safeTransferETH(to, amount); \n        emit WidthdrawETH(to, amount, action, transactionId); \n    } \n \n    function activeToken(address token) external onlyOwner { \n        require(!activeTokens[token], \"AddToken: token already supported\"); \n        contracts.push(token); \n        activeTokens[token] = true; \n        emit ActiveToken(token); \n    } \n \n    function pauseToken(address token) external onlyOwner { \n        require(activeTokens[token], \"PauseToken: token not active\"); \n        activeTokens[token] = false; \n        emit PauseToken(token); \n    } \n \n    function supportTokens() public view returns (address[] memory) { \n        return contracts; \n    } \n \n    function userWalletBalance(address user) \n    public \n    view \n    returns ( \n        address[] memory, \n        uint256[] memory, \n        uint256 \n    ) \n    { \n        uint256[] memory balances = new uint256[](contracts.length); \n        for (uint256 i = 0; i < contracts.length; i++) { \n            balances[i] = IERC20(contracts[i]).balanceOf(user); \n        } \n        uint256 ETHBalance = user.balance; \n        return (contracts, balances, ETHBalance); \n    } \n \n    function _safeTransferETH(address to, uint256 value) internal { \n        (bool success, ) = to.call{value: value}(new bytes(0)); \n        require(success, \"ETH_TRANSFER_FAILED\"); \n    } \n \n    function _mintNFT(address to) internal { \n        IERC721(BANKCARDNFT).mint(to); \n    } \n \n    fallback() external payable { \n        revert(\"Fallback not allowed\"); \n    } \n \n    /** \n     * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether \n"
        ]
    },
    {
        "PdfName": "DeFiFox_audit(1).pdf",
        "Code": [
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using AddressUpgradeable for address; \n \n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n// solhint-disable-next-line compiler-version \n",
            "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface IActionTrigger { \n    function getATPoolInfo(uint256 _pid) external view \n        returns (address lpToken, uint256 allocRate, uint256 totalAmount); \n    function getATUserAmount(uint256 _pid, address _account) external view \n        returns (uint256 acctAmount); \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n    function getPoolInfo(uint256 _pid) external view \n        returns (address callFrom, uint256 callId, address rewardToken); \n    function mintRewards(uint256 _callId) external; \n    function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n    function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n    function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n    function onAcionClaim(uint256 _callId, address _account) external; \n    function onAcionEmergency(uint256 _callId, address _account) external; \n    function onAcionUpdate(uint256 _callId) external; \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IClaimFromBank { \n    function claimFromBank(address _account, uint256[] memory _pidlist) external returns (uint256 val\n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Implementation of the {IERC20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of ERC20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IERC20-approve}. \n */ \ncontract ERC20 is Context, IERC20 { \n    using SafeMath for uint256; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n     * a default value of 18. \n     * \n     * To select a different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    constructor (string memory name_, string memory symbol_) public { \n        _name = name_; \n        _symbol = symbol_; \n        _decimals = 18; \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public view virtual returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public view virtual returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a balance of `505` tokens should \n     * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a value of 18, imitating the relationship between \n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is \n     * called. \n     * \n     * NOTE: This information is only used for _display_ purposes: it in \n     * no way affects any of the arithmetic of the contract, including \n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */ \n    function decimals() public view virtual returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */ \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */ \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function allowance(address owner, address spender) public view virtual override returns (uint256)\n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {ERC20}. \n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the total supply. \n     * \n     * Emits a {Transfer} event with `from` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `to` cannot be the zero address. \n     */ \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens. \n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Sets {decimals} to a value other than the default one of 18. \n     * \n     * WARNING: This function should only be called from the constructor. Most \n     * applications that interact with token contracts will not expect \n     * {decimals} to ever change, and may work incorrectly if it does. \n     */ \n    function _setupDecimals(uint8 decimals_) internal virtual { \n        _decimals = decimals_; \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * will be to transferred to `to`. \n     * - when `from` is zero, `amount` tokens will be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n     * - `from` and `to` are never both zero. \n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Extension of {ERC20} that adds a cap to the supply of tokens. \n */ \nabstract contract ERC20Capped is ERC20 { \n    using SafeMath for uint256; \n \n    uint256 private _cap; \n \n    /** \n     * @dev Sets the value of the `cap`. This value is immutable, it can only be \n     * set once during construction. \n     */ \n    constructor (uint256 cap_) internal { \n        require(cap_ > 0, \"ERC20Capped: cap is 0\"); \n        _cap = cap_; \n    } \n \n    /** \n     * @dev Returns the cap on the token's total supply. \n     */ \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_beforeTokenTransfer}. \n     * \n     * Requirements: \n     * \n     * - minted tokens must not cause the total supply to go over the cap. \n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override\n        super._beforeTokenTransfer(from, to, amount); \n \n        if (from == address(0)) { // When minting tokens \n            require(totalSupply().add(amount) <= cap(), \"ERC20Capped: cap exceeded\"); \n        } \n    } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface IRewardsToken { \n    function mint(address _account, uint256 _amount) external; \n    function burn(uint256 _amount) external; \n \n    function setMintWhitelist(address _account, bool _enabled) external; \n    function checkWhitelist(address _account) external view returns (bool); \n} \n \n",
            "pragma solidity 0.6.12; \n \n \n \ncontract DFOXToken is ERC20Capped, Ownable, IRewardsToken { \n    constructor ( \n            string memory _name, \n            string memory _symbol, \n            uint256 _totalSupply \n        ) public ERC20Capped(_totalSupply) ERC20(_name, _symbol) { \n    } \n \n    mapping(address => bool) public mintWhitelist; \n \n    function setMintWhitelist(address _account, bool _enabled) external override onlyOwner { \n        mintWhitelist[_account] = _enabled; \n    } \n \n    function checkWhitelist(address _account) external override view returns (bool) { \n        return mintWhitelist[_account]; \n    } \n \n    function mint(address _account, uint256 _amount) external override { \n        require(mintWhitelist[msg.sender], 'not allow'); \n        _mint(_account, _amount); \n    } \n \n    function burn(uint256 _amount) external override onlyOwner { \n        _burn(msg.sender, _amount); \n    } \n} \n \n \n \n",
            "pragma solidity 0.6.12; \n \n \n \n// Note that it's ownable and the owner wields tremendous power. The ownership \n// will be transferred to a governance smart contract once Token is sufficiently \n// distributed and the community can show to govern itself. \n// \n// Have fun reading it. Hopefully it's bug-free. God bless. \ncontract DFOXPools is OwnableUpgradeable, IActionTrigger, IClaimFromBank { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    // Info of each user. \n    struct UserInfo { \n        uint256 amount;         // How many LP tokens the user has provided. \n        uint256 rewardDebt;     // Reward debt. See explanation below. \n        uint256 rewardRemain;   // Remain rewards \n        // \n        // We do some fancy math here. Basically, any point in time, the amount of Token \n        // entitled to a user but is pending to be distributed is: \n        // \n        //   pending reward = (user.amount * pool.accRewardPerShare) + user.rewardRemain - user.rewar\n        // \n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens: \n        //   1. The pool's `accRewardPerShare` (and `lastRewardBlock`) gets updated. \n        //   2. User calc the pending rewards and record at rewardRemain. \n        //   3. User's `amount` gets updated. \n        //   4. User's `rewardDebt` gets updated. \n    } \n \n    // Info of each pool. \n    struct PoolInfo { \n        address lpToken;             // Address of LP token contract. \n        uint256 allocPoint;         // How many allocation points assigned to this pool. Token to dis\n        uint256 lastRewardBlock;    // Last block number that Token distribution occurs. \n        uint256 accRewardPerShare;  // Accumulated Token per share, times 1e18. See below. \n        uint256 totalAmount;        // Total amount of current pool deposit. \n    } \n \n    // The FOX TOKEN! \n    DFOXToken public rewardToken; \n    // FOX tokens created per block. \n    uint256 public rewardPerBlock; \n    address public devaddr; \n \n    // Info of each pool. \n    PoolInfo[] public poolInfo; \n    // Info of each user that stakes LP tokens. \n    mapping (uint256 => mapping (address => UserInfo)) public userInfo; \n    // Total allocation points. Must be the sum of all allocation points in all pools. \n    uint256 public totalAllocPoint = 0; \n    // The block number when reward Token mining starts. \n    uint256 public startBlock; \n    // The extend Pool \n    address public extendPool; \n \n    // block hacker user to deposit \n    mapping (address => bool) public depositBlacklist; \n    // block hacker user to restricted reward \n    mapping (address => uint256) public rewardRestricted; \n    // enable pool emergency withdraw \n    mapping (uint256 => bool) public emergencyWithdrawEnabled; \n    // allow bank proxy claim \n    address public bank; \n \n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount); \n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount); \n    event Claim(address indexed user, uint256 indexed pid, uint256 amount); \n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount); \n \n    function initialize( \n        address _bank, \n        address _rewardToken, \n        uint256 _rewardPerBlock, \n        address _devaddr, \n        uint256 _startBlock) public initializer { \n        __Ownable_init(); \n \n        bank = _bank; \n        rewardToken = DFOXToken(_rewardToken); \n        startBlock = _startBlock; \n        devaddr = _devaddr; \n        rewardPerBlock = _rewardPerBlock; \n    } \n \n    function poolLength() external view returns (uint256) { \n        return poolInfo.length; \n    } \n \n    function getATPoolInfo(uint256 _pid) external override view \n        returns (address lpToken, uint256 allocRate, uint256 totalAmount) { \n        lpToken = poolInfo[_pid].lpToken; \n        totalAmount = poolInfo[_pid].totalAmount; \n        if(totalAllocPoint > 0) { \n            allocRate = poolInfo[_pid].allocPoint.mul(1e9).div(totalAllocPoint); \n        }else{ \n            allocRate = 1e9; \n        } \n    } \n \n    function getATUserAmount(uint256 _pid, address _account) external override view \n        returns (uint256 acctAmount) { \n        acctAmount = userInfo[_pid][_account].amount; \n    } \n \n    // Add a new lp to the pool. Can only be called by the owner. \n    function add(uint256 _allocPoint, address _lpToken) public onlyOwner { \n        massUpdatePools(); \n        require(IERC20Upgradeable(_lpToken).totalSupply() >= 0, 'error lptoken address'); \n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; \n        poolInfo.push(PoolInfo({ \n            lpToken: _lpToken, \n            allocPoint: _allocPoint, \n            lastRewardBlock: lastRewardBlock, \n            accRewardPerShare: 0, \n            totalAmount: 0 \n        })); \n        totalAllocPoint = totalAllocPoint.add(_allocPoint); \n    } \n \n    // Set the number of reward produced by each block \n    function setRewardPerBlock(uint256 _rewardPerBlock) external onlyOwner { \n        massUpdatePools(); \n        rewardPerBlock = _rewardPerBlock; \n    } \n \n    function setExtendPool(address _extendPool) external onlyOwner { \n        extendPool = _extendPool; \n    } \n \n    // Update the given pool's Token allocation point. Can only be called by the owner. \n    function setAllocPoint(uint256 _pid, uint256 _allocPoint) external onlyOwner { \n        massUpdatePools(); \n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); \n        poolInfo[_pid].allocPoint = _allocPoint; \n    } \n \n    // Update dev address by the previous one \n    function setDevAddress(address _devaddr) external { \n        require(msg.sender == devaddr, \"only dev caller\"); \n        devaddr = _devaddr; \n    } \n \n    function setPoolStartBlock(uint256 _pid, uint256 _startBlock) external onlyOwner { \n        PoolInfo storage pool = poolInfo[_pid]; \n        require(block.number < pool.lastRewardBlock, 'set too late'); \n        require(_startBlock  > block.number, 'startBlock error'); \n        poolInfo[_pid].lastRewardBlock = _startBlock; \n    } \n \n    // block hacker user to deposit \n    function setBlacklist(address _hacker, bool _set) external onlyOwner { \n        depositBlacklist[_hacker] = _set; \n    } \n \n    function setEmergencyWithdrawEnabled(uint256 _pid, bool _set) external onlyOwner { \n        emergencyWithdrawEnabled[_pid] = _set; \n    } \n \n    // block hacker user to restricted reward \n    function setRewardRestricted(address _hacker, uint256 _rate) external onlyOwner { \n        require(_rate <= 1e9, 'max is 1e9'); \n        rewardRestricted[_hacker] = _rate; \n    } \n \n    // Return reward multiplier over the given _from to _to block. \n    function getBlocksReward(uint256 _from, uint256 _to) public view returns (uint256 value) { \n        require(_from <= _to, 'getBlocksReward error'); \n        if (_to < startBlock) { \n            return 0; \n        } \n        if (_from < startBlock && _to >= startBlock) { \n            value = getBlocksReward(startBlock, _to); \n        } else { \n            value = _to.sub(_from).mul(rewardPerBlock); \n        } \n    } \n \n    // View function to see pending Tokens on frontend. \n    function pendingRewards(uint256 _pid, address _user) public view returns (uint256 value) { \n        value = totalRewards(_pid, _user) \n                    .add(userInfo[_pid][_user].rewardRemain) \n                    .sub(userInfo[_pid][_user].rewardDebt); \n    } \n \n    function totalRewards(uint256 _pid, address _user) public view returns (uint256 value) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        uint256 accRewardPerShare = pool.accRewardPerShare; \n        if (block.number > pool.lastRewardBlock && pool.totalAmount != 0) { \n            uint256 poolReward = getBlocksReward(pool.lastRewardBlock, block.number) \n                                    .mul(pool.allocPoint).div(totalAllocPoint); \n            accRewardPerShare = accRewardPerShare.add(poolReward.mul(1e18).div(pool.totalAmount)); \n        } \n        value = userInfo[_pid][_user].amount.mul(accRewardPerShare).div(1e18); \n    } \n \n    // Update reward variables for all pools. Be careful of gas spending! \n    function massUpdatePools() public { \n        uint256 length = poolInfo.length; \n        for (uint256 pid = 0; pid < length; ++pid) { \n            updatePool(pid); \n        } \n    } \n \n    // Update reward variables of the given pool to be up-to-date. \n    function updatePool(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        if (pool.allocPoint == 0 || pool.totalAmount == 0) { \n            pool.lastRewardBlock = block.number; \n            return; \n        } \n        if (block.number <= pool.lastRewardBlock) { \n            return; \n        } \n        uint256 poolReward = getBlocksReward(pool.lastRewardBlock, block.number) \n                                .mul(pool.allocPoint).div(totalAllocPoint); \n        if (poolReward > 0) { \n            rewardToken.mint(address(this), poolReward); \n            rewardToken.mint(devaddr, poolReward.mul(100).div(750)); \n            pool.accRewardPerShare = pool.accRewardPerShare.add(poolReward.mul(1e18).div(pool.totalAm\n        } \n        pool.lastRewardBlock = block.number; \n \n        if(extendPool != address(0)) { \n            IActionPools(extendPool).onAcionUpdate(_pid); \n        } \n    } \n \n    // Deposit LP tokens to MasterChef for Token allocation. \n    function deposit(uint256 _pid, uint256 _amount) external { \n        require(!depositBlacklist[msg.sender], 'user in blacklist'); \n        updatePool(_pid); \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        if (user.amount > 0) { \n            user.rewardRemain = pendingRewards(_pid, msg.sender); \n        } \n        uint256 amountOld = user.amount; \n        if(_amount > 0) { \n            IERC20Upgradeable(pool.lpToken).safeTransferFrom(address(msg.sender), address(this), _amo\n            user.amount = user.amount.add(_amount); \n            pool.totalAmount = pool.totalAmount.add(_amount); \n        } \n        user.rewardDebt = totalRewards(_pid, msg.sender); \n        emit Deposit(msg.sender, _pid, _amount); \n \n        if(extendPool != address(0)) { \n            IActionPools(extendPool).onAcionIn(_pid, msg.sender, amountOld, user.amount); \n        } \n    } \n \n    // Withdraw LP tokens from StarPool. \n    function withdraw(uint256 _pid, uint256 _amount) external { \n        updatePool(_pid); \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        require(user.amount >= _amount, \"withdraw: not good\"); \n        user.rewardRemain = pendingRewards(_pid, msg.sender); \n        uint256 amountOld = user.amount; \n        if(_amount > 0) { \n            user.amount = user.amount.sub(_amount); \n            pool.totalAmount = pool.totalAmount.sub(_amount); \n            IERC20Upgradeable(pool.lpToken).safeTransfer(address(msg.sender), _amount); \n        } \n        user.rewardDebt = totalRewards(_pid, msg.sender); \n        emit Withdraw(msg.sender, _pid, _amount); \n \n        if(extendPool != address(0)) { \n            IActionPools(extendPool).onAcionOut(_pid, msg.sender, amountOld, user.amount); \n        } \n    } \n \n    function claim(uint256 _pid) public returns (uint256 value) { \n        _claim(_pid, msg.sender); \n    } \n \n    function _claim(uint256 _pid, address _account) internal returns (uint256 value) { \n        updatePool(_pid); \n        value = pendingRewards(_pid, _account); \n        if (value > 0) { \n            userInfo[_pid][_account].rewardRemain = 0; \n            if(rewardRestricted[_account] > 0) { \n                value = value.sub(value.mul(rewardRestricted[_account]).div(1e9)); \n            } \n            value = safeTokenTransfer(_account, value); \n            userInfo[_pid][_account].rewardDebt = totalRewards(_pid, _account); \n        } \n \n        emit Claim(_account, _pid, value); \n \n        if(extendPool != address(0)) { \n            IActionPools(extendPool).onAcionClaim(_pid, _account); \n        } \n    } \n \n    function claimFromBank(address _account, uint256[] memory _pidlist) \n        external override returns (uint256 value) { \n        require(bank==msg.sender, 'only call from bank'); \n        for (uint256 piid = 0; piid < _pidlist.length; ++piid) { \n            value = value.add(_claim(_pidlist[piid], _account)); \n        } \n    } \n \n    function claimAll() external returns (uint256 value) { \n        uint256 length = poolInfo.length; \n        for (uint256 pid = 0; pid < length; ++pid) { \n            claim(pid); \n        } \n    } \n \n    // Withdraw without caring about rewards. EMERGENCY ONLY. \n    function emergencyWithdraw(uint256 _pid) external { \n        require(emergencyWithdrawEnabled[_pid], 'not allowed'); \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        uint256 amount = user.amount; \n        user.amount = 0; \n        user.rewardDebt = 0; \nMultiSourceOracle::TransparentUpgradeableProxy.sol\n        user.rewardRemain = 0; \n        pool.totalAmount = pool.totalAmount.sub(amount); \n        IERC20Upgradeable(pool.lpToken).safeTransfer(address(msg.sender), amount); \n        emit EmergencyWithdraw(msg.sender, _pid, amount); \n \n        if(extendPool != address(0)) { \n            IActionPools(extendPool).onAcionEmergency(_pid, msg.sender); \n        } \n    } \n \n    // Safe Token transfer function, just in case if rounding error causes pool to not have enough To\n    function safeTokenTransfer(address _to, uint256 _amount) internal returns (uint256 value) { \n        uint256 balance = rewardToken.balanceOf(address(this)); \n        value = _amount > balance ? balance : _amount; \n        if ( value > 0 ) { \n            rewardToken.transfer(_to, value); \n        } \n    } \n \n    // If the user transfers TH to contract, it will revert \n    receive() external payable { \n        revert(); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev This abstract contract provides a  fallback function that delegates all calls to an\n * instruction `delegatecall`. We refer to the  second contract as the\n * be specified by overriding the  virtual {_implementation} function. \n * \n * Additionally, delegation to the  implementation can be triggered manually through \n * different contract through the  {_delegate} function. \n * \n * The success and return data of the  delegated call will  b\n */  \nabstract contract Proxy { \n    /** \n     * @dev Delegates the  current call to `implementation`. \n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _delegate(address implementation) internal virtual { \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            // Copy msg.data. We take full control of memory in this inline assembly \n            // block because it will not return to Solidity code. We overwrite the \n            // Solidity scratch pad at memory position 0. \n            calldatacopy(0, 0, calldatasize()) \n \n            // Call the implementation. \n            // out and outsize are 0 because we don't know the size yet. \n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n            // Copy the returned data. \n            returndatacopy(0, 0, returndatasize()) \n \n            switch result \n            // delegatecall returns 0 on error. \n            case 0 { revert(0, returndatasize()) } \n            default { return(0, returndatasize()) } \n        } \n    } \n \n    /** \n     * @dev This is a  virtual function that should  be override\n     * and {_fallback} should  delegate. \n     */  \n    function _implementation() internal view virtual returns (address); \n \n    /** \n     * @dev Delegates the  current call to the  address return\n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _fallback() internal virtual { \n        _beforeFallback(); \n        _delegate(_implementation()); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * function in the  contract matches the  call data. \n     */  \n    fallback () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * is empty. \n     */  \n    receive () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Hook that is called before falling back to the  implementation. Can happen a\n     * call, or as part of the  Solidity `fallback` or `receive` functions. \n     * \n     * If overriden should  call `super._beforeFallback()`. \n     */  \n    function _beforeFallback() internal virtual { \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the  address type \n */  \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain`call` is an  unsafe replacement for a  function call: \n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an  upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so  that it doesn't\n * implementation behind the  proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an  externally up\n * {TransparentUpgradeableProxy}. \n */  \ncontract UpgradeableProxy is Proxy { \n    /** \n     * @dev Initializes the  upgradeable proxy with an  initial i\n     * \n     * If `_data` is nonempty, it's used as data in a  delegate call to `_logic`. This \n     * function call, and allows initializating the  storage of the\n     */  \n    constructor(address _logic, bytes memory _data) public payable { \n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n        _setImplementation(_logic); \n        if(_data.length > 0) { \n            Address.functionDelegateCall(_logic, _data); \n        } \n    } \n \n    /** \n     * @dev Emitted when the  implementation is upgraded. \n     */  \n    event Upgraded(address indexed implementation); \n \n    /** \n     * @dev Storage slot with the  address of the  current imp\n     * This is the  keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n     * validated in the  constructor. \n     */  \n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n    /** \n     * @dev Returns the  current implementation address. \n     */  \n    function _implementation() internal view virtual override returns (address impl) { \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            impl := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Upgrades the  proxy to a  new implementation. \n     * \n     * Emits an  {Upgraded} event. \n     */  \n    function _upgradeTo(address newImplementation) internal virtual { \n        _setImplementation(newImplementation); \n        emit Upgraded(newImplementation); \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 implemen\n     */  \n    function _setImplementation(address newImplementation) private { \n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newImplementation) \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \nSafeBoxFox::TransparentUpgradeableProxy.sol\n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev This abstract contract provides a  fallback function that delegates all calls to an\n * instruction `delegatecall`. We refer to the  second contract as the\n * be specified by overriding the  virtual {_implementation} function. \n * \n * Additionally, delegation to the  implementation can be triggered manually through \n * different contract through the  {_delegate} function. \n * \n * The success and return data of the  delegated call will  b\n */  \nabstract contract Proxy { \n    /** \n     * @dev Delegates the  current call to `implementation`. \n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _delegate(address implementation) internal virtual { \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            // Copy msg.data. We take full control of memory in this inline assembly \n            // block because it will not return to Solidity code. We overwrite the \n            // Solidity scratch pad at memory position 0. \n            calldatacopy(0, 0, calldatasize()) \n \n            // Call the implementation. \n            // out and outsize are 0 because we don't know the size yet. \n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n            // Copy the returned data. \n            returndatacopy(0, 0, returndatasize()) \n \n            switch result \n            // delegatecall returns 0 on error. \n            case 0 { revert(0, returndatasize()) } \n            default { return(0, returndatasize()) } \n        } \n    } \n \n    /** \n     * @dev This is a  virtual function that should  be override\n     * and {_fallback} should  delegate. \n     */  \n    function _implementation() internal view virtual returns (address); \n \n    /** \n     * @dev Delegates the  current call to the  address return\n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _fallback() internal virtual { \n        _beforeFallback(); \n        _delegate(_implementation()); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * function in the  contract matches the  call data. \n     */  \n    fallback () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * is empty. \n     */  \n    receive () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Hook that is called before falling back to the  implementation. Can happen a\n     * call, or as part of the  Solidity `fallback` or `receive` functions. \n     * \n     * If overriden should  call `super._beforeFallback()`. \n     */  \n    function _beforeFallback() internal virtual { \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the  address type \n */  \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain`call` is an  unsafe replacement for a  function call: \n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an  upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so  that it doesn't\n * implementation behind the  proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an  externally up\n * {TransparentUpgradeableProxy}. \n */  \ncontract UpgradeableProxy is Proxy { \n    /** \n     * @dev Initializes the  upgradeable proxy with an  initial i\n     * \n     * If `_data` is nonempty, it's used as data in a  delegate call to `_logic`. This \n     * function call, and allows initializating the  storage of the\n     */  \n    constructor(address _logic, bytes memory _data) public payable { \n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n        _setImplementation(_logic); \n        if(_data.length > 0) { \n            Address.functionDelegateCall(_logic, _data); \n        } \n    } \n \n    /** \n     * @dev Emitted when the  implementation is upgraded. \n     */  \n    event Upgraded(address indexed implementation); \n \n    /** \n     * @dev Storage slot with the  address of the  current imp\n     * This is the  keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n     * validated in the  constructor. \n     */  \n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n    /** \n     * @dev Returns the  current implementation address. \n     */  \n    function _implementation() internal view virtual override returns (address impl) { \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            impl := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Upgrades the  proxy to a  new implementation. \n     * \n     * Emits an  {Upgraded} event. \n     */  \n    function _upgradeTo(address newImplementation) internal virtual { \n        _setImplementation(newImplementation); \n        emit Upgraded(newImplementation); \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 implemen\n     */  \n    function _setImplementation(address newImplementation) private { \n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newImplementation) \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \nMultiSourceOracle.sol\n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n// solhint-disable-next-line compiler-version \n",
            "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface ICTokenInterface { \n \n  function isCToken() external view returns (bool); \n \n  // function decimals() external returns (uint8); \n \n  function underlying() external view returns (address); \n \n  // function mint(uint mintAmount) external returns (uint); \n \n  // function redeem(uint redeemTokens) external returns (uint); \n \n  // function balanceOf(address user) external view returns (uint); \n \n  // function borrowBalanceCurrent(address account) external returns (uint); \n \n  // function borrowBalanceStored(address account) external view returns (uint); \n \n  // function borrow(uint borrowAmount) external returns (uint); \n \n  // function repayBorrow(uint repayAmount) external returns (uint); \n  // function transfer(address dst, uint amount) external returns (bool); \n  // function transferFrom(address src, address dst, uint amount) external returns (bool); \n  // function approve(address spender, uint amount) external returns (bool); \n  // function allowance(address owner, address spender) external view returns (uint); \n  // function balanceOf(address owner) external view returns (uint); \n  function balanceOfUnderlying(address owner) external view returns (uint); \n  function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint); \n  function borrowRatePerBlock() external view returns (uint); \n  function supplyRatePerBlock() external view returns (uint); \n  function totalBorrowsCurrent() external returns (uint); \n  function borrowBalanceCurrent(address account) external returns (uint); \n  function borrowBalanceStored(address account) external view returns (uint); \n  function exchangeRateCurrent() external returns (uint); \n  function exchangeRateStored() external view returns (uint); \n  function getCash() external view returns (uint); \n  function accrueInterest() external returns (uint); \n  function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint); \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface ITokenOracle { \n    function getPrice(address _token) external view returns (int); \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \n \ncontract MultiSourceOracle is OwnableUpgradeable, ITokenOracle { \n    using SafeMathUpgradeable for uint256; \n \n    struct PriceData { \n        uint price; \n        uint lastUpdate; \n    } \n \n    bool public constant isPriceOracle = true; \n    mapping(address => bool) public opers; \n    mapping(address => address) public priceFeeds; \n    mapping(address => PriceData) public store; \n \n    event PriceUpdate(address indexed _token, uint price); \n    event PriceFeed(address indexed _token, address _feed); \n \n    constructor() public { \n    } \n \n    function initialize() public initializer { \n        __Ownable_init(); \n        opers[msg.sender] = true; \n    } \n \n    function setPriceOperator(address _oper, bool _enable) public onlyOwner { \n        opers[_oper] = _enable; \n    } \n \n    function setFeeds(address[] memory _tokens, address[] memory _feeds) public onlyOwner { \n        require(_tokens.length == _feeds.length, 'bad token length'); \n        for (uint idx = 0; idx < _tokens.length; idx++) { \n            address token0 = _tokens[idx]; \n            address feed = _feeds[idx]; \n            emit PriceFeed(token0, feed); \n            require(ITokenOracle(feed).getPrice(token0) > 0, 'token no price'); \n            priceFeeds[token0] = feed; \n        } \n    } \n \n    /// @dev Set the prices of the token token pairs. Must be called by the oper. \n    // price (scaled by 1e18). \n    function setPrices( \n        address[] memory tokens, \n        uint[] memory prices \n    ) external { \n        require(opers[msg.sender], 'only oper'); \n        require(tokens.length == prices.length, 'bad token length'); \n        for (uint idx = 0; idx < tokens.length; idx++) { \n            address token0 = tokens[idx]; \n            uint price = prices[idx]; \n            store[token0] = PriceData({price: price, lastUpdate: now}); \n            emit PriceUpdate(token0, price); \n        } \nStrategyV2Pair::TransparentUpgradeableProxy.sol\n    } \n \n    function getPrice(address _token) public override view returns (int) { \n        address feed = priceFeeds[_token]; \n        if(feed != address(0)) { \n            return ITokenOracle(feed).getPrice(_token); \n        } \n        require(store[_token].price >= 0, 'price to lower'); \n        return int(store[_token].price); \n    } \n \n \n    /** \n      * @notice Get the underlying price of a cToken asset \n      * @param cToken The cToken to get the underlying price of \n      * @return The underlying asset price mantissa (scaled by 1e18). \n      *  Zero means the price is unavailable. \n      */ \n    function getUnderlyingPrice(address cToken) external view returns (uint) { \n        address token = ICTokenInterface(cToken).underlying(); \n        int price = getPrice(token); \n        require(price >= 0, 'price to lower'); \n        return uint(price).mul(uint(1e18).div(1e8)); \n    } \n}\n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev This abstract contract provides a  fallback function that delegates all calls to an\n * instruction `delegatecall`. We refer to the  second contract as the\n * be specified by overriding the  virtual {_implementation} function. \n * \n * Additionally, delegation to the  implementation can be triggered manually through \n * different contract through the  {_delegate} function. \n * \n * The success and return data of the  delegated call will  b\n */  \nabstract contract Proxy { \n    /** \n     * @dev Delegates the  current call to `implementation`. \n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _delegate(address implementation) internal virtual { \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            // Copy msg.data. We take full control of memory in this inline assembly \n            // block because it will not return to Solidity code. We overwrite the \n            // Solidity scratch pad at memory position 0. \n            calldatacopy(0, 0, calldatasize()) \n \n            // Call the implementation. \n            // out and outsize are 0 because we don't know the size yet. \n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n            // Copy the returned data. \n            returndatacopy(0, 0, returndatasize()) \n \n            switch result \n            // delegatecall returns 0 on error. \n            case 0 { revert(0, returndatasize()) } \n            default { return(0, returndatasize()) } \n        } \n    } \n \n    /** \n     * @dev This is a  virtual function that should  be override\n     * and {_fallback} should  delegate. \n     */  \n    function _implementation() internal view virtual returns (address); \n \n    /** \n     * @dev Delegates the  current call to the  address return\n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _fallback() internal virtual { \n        _beforeFallback(); \n        _delegate(_implementation()); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * function in the  contract matches the  call data. \n     */  \n    fallback () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * is empty. \n     */  \n    receive () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Hook that is called before falling back to the  implementation. Can happen a\n     * call, or as part of the  Solidity `fallback` or `receive` functions. \n     * \n     * If overriden should  call `super._beforeFallback()`. \n     */  \n    function _beforeFallback() internal virtual { \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the  address type \n */  \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain`call` is an  unsafe replacement for a  function call: \n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an  upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so  that it doesn't\n * implementation behind the  proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an  externally up\n * {TransparentUpgradeableProxy}. \n */  \ncontract UpgradeableProxy is Proxy { \n    /** \n     * @dev Initializes the  upgradeable proxy with an  initial i\n     * \n     * If `_data` is nonempty, it's used as data in a  delegate call to `_logic`. This \n     * function call, and allows initializating the  storage of the\n     */  \n    constructor(address _logic, bytes memory _data) public payable { \n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n        _setImplementation(_logic); \n        if(_data.length > 0) { \n            Address.functionDelegateCall(_logic, _data); \n        } \n    } \n \n    /** \n     * @dev Emitted when the  implementation is upgraded. \n     */  \n    event Upgraded(address indexed implementation); \n \n    /** \n     * @dev Storage slot with the  address of the  current imp\n     * This is the  keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n     * validated in the  constructor. \n     */  \n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n    /** \n     * @dev Returns the  current implementation address. \n     */  \n    function _implementation() internal view virtual override returns (address impl) { \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            impl := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Upgrades the  proxy to a  new implementation. \n     * \n     * Emits an  {Upgraded} event. \n     */  \n    function _upgradeTo(address newImplementation) internal virtual { \n        _setImplementation(newImplementation); \n        emit Upgraded(newImplementation); \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 implemen\n     */  \n    function _setImplementation(address newImplementation) private { \n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newImplementation) \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \nSafeBoxFox.sol\n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using AddressUpgradeable for address; \n \n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n// solhint-disable-next-line compiler-version \n",
            "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Implementation of the {IERC20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of ERC20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IERC20-approve}. \n */ \ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n     * a default value of 18. \n     * \n     * To select a different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer { \n        __Context_init_unchained(); \n        __ERC20_init_unchained(name_, symbol_); \n    } \n \n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer \n        _name = name_; \n        _symbol = symbol_; \n        _decimals = 18; \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public view virtual returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public view virtual returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a balance of `505` tokens should \n     * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a value of 18, imitating the relationship between \n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is \n     * called. \n     * \n     * NOTE: This information is only used for _display_ purposes: it in \n     * no way affects any of the arithmetic of the contract, including \n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */ \n    function decimals() public view virtual returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */ \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */ \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function allowance(address owner, address spender) public view virtual override returns (uint256)\n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {ERC20}. \n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the total supply. \n     * \n     * Emits a {Transfer} event with `from` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `to` cannot be the zero address. \n     */ \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens. \n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Sets {decimals} to a value other than the default one of 18. \n     * \n     * WARNING: This function should only be called from the constructor. Most \n     * applications that interact with token contracts will not expect \n     * {decimals} to ever change, and may work incorrectly if it does. \n     */ \n    function _setupDecimals(uint8 decimals_) internal virtual { \n        _decimals = decimals_; \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * will be to transferred to `to`. \n     * - when `from` is zero, `amount` tokens will be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n     * - `from` and `to` are never both zero. \n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n    uint256[44] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module that helps prevent reentrant calls to a function. \n * \n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier \n * available, which can be applied to functions to make sure there are no nested \n * (reentrant) calls to them. \n * \n * Note that because there is a single `nonReentrant` guard, functions marked as \n * `nonReentrant` may not call one another. This can be worked around by making \n * those functions `private`, and then adding `external` `nonReentrant` entry \n * points to them. \n * \n * TIP: If you would like to learn more about reentrancy and alternative ways \n * to protect against it, check out our blog post \n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. \n */ \nabstract contract ReentrancyGuardUpgradeable is Initializable { \n    // Booleans are more expensive than uint256 or any type that takes up a full \n    // word because each write operation emits an extra SLOAD to first read the \n    // slot's contents, replace the bits taken up by the boolean, and then write \n    // back. This is the compiler's defense against contract upgrades and \n    // pointer aliasing, and it cannot be disabled. \n \n    // The values being non-zero value makes deployment a bit more expensive, \n    // but in exchange the refund on every call to nonReentrant will be lower in \n    // amount. Since refunds are capped to a percentage of the total \n    // transaction's gas, it is best to keep them low in cases like this one, to \n    // increase the likelihood of the full refund coming into effect. \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    function __ReentrancyGuard_init() internal initializer { \n        __ReentrancyGuard_init_unchained(); \n    } \n \n    function __ReentrancyGuard_init_unchained() internal initializer { \n        _status = _NOT_ENTERED; \n    } \n \n    /** \n     * @dev Prevents a contract from calling itself, directly or indirectly. \n     * Calling a `nonReentrant` function from another `nonReentrant` \n     * function is not supported. It is possible to prevent this from happening \n     * by making the `nonReentrant` function external, and make it call a \n     * `private` function that does the actual work. \n     */ \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n    uint256[49] private __gap; \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface ISafeBox { \n \n    function bank() external view returns(address); \n \n    function token() external view returns(address); \n \n    function getSource() external view returns (string memory); \n \n    function supplyRatePerBlock() external view returns (uint256); \n    function borrowRatePerBlock() external view returns (uint256); \n \n    function getBorrowInfo(uint256 _bid) external view \n            returns (address owner, uint256 amount, address strategy, uint256 pid); \n    function getBorrowId(address _strategy, uint256 _pid, address _account) external view returns (ui\n    function getBorrowId(address _strategy, uint256 _pid, address _account, bool _add) external retur\n    function getDepositTotal() external view returns (uint256); \n    function getBorrowTotal() external view returns (uint256); \n    // function getBorrowAmount(address _account) external view returns (uint256 value); \n    function getBaseTokenPerLPToken() external view returns (uint256); \n \n    function deposit(uint256 _value) external; \n    function withdraw(uint256 _value) external; \n \n    function emergencyWithdraw() external; \n    function emergencyRepay(uint256 _bid) external; \n \n    function borrowInfoLength() external view returns (uint256); \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external; \n    function repay(uint256 _bid, uint256 _value) external; \n    function claim(uint256 _tTokenAmount) external; \n \n    function update() external; \n    function mintDonate(uint256 _value) external; \n \n    function pendingSupplyAmount(address _account) external view returns (uint256 value); \n    function pendingBorrowAmount(uint256 _bid) external view returns (uint256 value); \n    function pendingBorrowRewards(uint256 _bid) external view returns (uint256 value); \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface ICompActionTrigger { \n    function getCATPoolInfo(uint256 _pid) external view \n        returns (address lpToken, uint256 allocRate, uint256 totalPoints, uint256 totalAmount); \n    function getCATUserAmount(uint256 _pid, address _account) external view \n        returns (uint256 points); \n} \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n    function getPoolInfo(uint256 _pid) external view \n        returns (address callFrom, uint256 callId, address rewardToken); \n    function mintRewards(uint256 _callId) external; \n    function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n    function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n    function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n    function onAcionClaim(uint256 _callId, address _account) external; \n    function onAcionEmergency(uint256 _callId, address _account) external; \n    function onAcionUpdate(uint256 _callId) external; \n} \n",
            "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n  using SafeMathUpgradeable for uint256; \n \n  function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n    vr = v1 > v2 ? v2 : v1; \n  } \n \n  function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n    vr = v1 > v2 ? v1.sub(v2) : 0; \n  } \n \n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/A\n  function sqrt(uint256 x) internal pure returns (uint256) { \n    if (x == 0) return 0; \n    uint256 xx = x; \n    uint256 r = 1; \n \n    if (xx >= 0x100000000000000000000000000000000) { \n      xx >>= 128; \n      r <<= 64; \n    } \n \n    if (xx >= 0x10000000000000000) { \n      xx >>= 64; \n      r <<= 32; \n    } \n    if (xx >= 0x100000000) { \n      xx >>= 32; \n      r <<= 16; \n    } \n    if (xx >= 0x10000) { \n      xx >>= 16; \n      r <<= 8; \n    } \n    if (xx >= 0x100) { \n      xx >>= 8; \n      r <<= 4; \n    } \n    if (xx >= 0x10) { \n      xx >>= 4; \n      r <<= 2; \n    } \n    if (xx >= 0x8) { \n      r <<= 1; \n    } \n \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; // Seven iterations should be enough \n    uint256 r1 = x / r; \n    return (r < r1 ? r : r1); \n  } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface IErc20Interface { \n \n    /*** User Interface ***/ \n    function underlying() external view returns (address); \n \n    function mint(uint mintAmount) external returns (uint);  // \n    function redeem(uint redeemTokens) external returns (uint); \n    function redeemUnderlying(uint redeemAmount) external returns (uint); \n    function borrow(uint borrowAmount) external returns (uint); \n    function repayBorrow(uint repayAmount) external returns (uint); \n    // function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); \n    // function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) \n \n} \n",
            "pragma solidity 0.6.12; \n \ninterface ICTokenInterface { \n \n  function isCToken() external view returns (bool); \n \n  // function decimals() external returns (uint8); \n \n  function underlying() external view returns (address); \n \n  // function mint(uint mintAmount) external returns (uint); \n \n  // function redeem(uint redeemTokens) external returns (uint); \n \n  // function balanceOf(address user) external view returns (uint); \n \n  // function borrowBalanceCurrent(address account) external returns (uint); \n \n  // function borrowBalanceStored(address account) external view returns (uint); \n \n  // function borrow(uint borrowAmount) external returns (uint); \n \n  // function repayBorrow(uint repayAmount) external returns (uint); \n  // function transfer(address dst, uint amount) external returns (bool); \n  // function transferFrom(address src, address dst, uint amount) external returns (bool); \n  // function approve(address spender, uint amount) external returns (bool); \n  // function allowance(address owner, address spender) external view returns (uint); \n  // function balanceOf(address owner) external view returns (uint); \n  function balanceOfUnderlying(address owner) external view returns (uint); \n  function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint); \n  function borrowRatePerBlock() external view returns (uint); \n  function supplyRatePerBlock() external view returns (uint); \n  function totalBorrowsCurrent() external returns (uint); \n  function borrowBalanceCurrent(address account) external returns (uint); \n  function borrowBalanceStored(address account) external view returns (uint); \n  function exchangeRateCurrent() external returns (uint); \n  function exchangeRateStored() external view returns (uint); \n  function getCash() external view returns (uint); \n  function accrueInterest() external returns (uint); \n  function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint); \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \n \n// Safebox vault, deposit, withdrawal, borrowing, repayment \ncontract SafeBoxFoxCTokenImpl is ERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    IErc20Interface public eToken; \n    ICTokenInterface public cToken; \n \n    function __SafeBoxFoxCTokenImpl__init(address _cToken) public initializer { \n        __ERC20_init(string(abi.encodePacked(\"d \", ERC20Upgradeable(IErc20Interface(_cToken).underlyi\n            string(abi.encodePacked(\"d\", ERC20Upgradeable(IErc20Interface(_cToken).underlying()).symb\n        _setupDecimals(ERC20Upgradeable(_cToken).decimals()); \n        eToken = IErc20Interface(_cToken); \n        cToken = ICTokenInterface(_cToken); \n        require(cToken.isCToken(), 'not ctoken address'); \n        IERC20Upgradeable(baseToken()).approve(_cToken, uint256(-1)); \n    } \n \n    function baseToken() public virtual view returns (address) { \n        return eToken.underlying(); \n    } \n \n    function ctokenSupplyRatePerBlock() public virtual view returns (uint256) { \n        return cToken.supplyRatePerBlock(); \n    } \n \n    function ctokenBorrowRatePerBlock() public virtual view returns (uint256) { \n        return cToken.borrowRatePerBlock(); \n    } \n \n    function call_balanceOf(address _token, address _account) public virtual view returns (uint256 ba\n        balance = IERC20Upgradeable(_token).balanceOf(_account); \n    } \n \n    function call_balanceOfCToken_this() public virtual view returns (uint256 balance) { \n        balance = call_balanceOf(address(cToken), address(this)); \n    } \n \n    function call_balanceOfBaseToken_this() public virtual returns (uint256) { \n        return call_balanceOfCToken_this().mul(cToken.exchangeRateCurrent()).div(1e18); \n    } \n \n    function call_borrowBalanceCurrent_this() public virtual returns (uint256) { \n        return cToken.borrowBalanceCurrent(address(this)); \n    } \n \n    function getBaseTokenPerCToken() public virtual view returns (uint256) { \n        return cToken.exchangeRateStored(); \n    } \n \n    // deposit \n    function ctokenDeposit(uint256 _value) internal virtual returns (uint256 lpAmount) { \n        uint256 cBalanceBefore = call_balanceOf(address(cToken), address(this)); \n        require(eToken.mint(uint256(_value)) == 0, 'deposit token error'); \n        uint256 cBalanceAfter = call_balanceOf(address(cToken), address(this)); \n        lpAmount = cBalanceAfter.sub(cBalanceBefore); \n    } \n \n    function ctokenWithdraw(uint256 _lpAmount) internal virtual returns (uint256 value) { \n        uint256 cBalanceBefore = call_balanceOf(baseToken(), address(this)); \n        require(eToken.redeem(_lpAmount) == 0, 'withdraw supply ctoken error'); \n        uint256 cBalanceAfter = call_balanceOf(baseToken(), address(this)); \n        value = cBalanceAfter.sub(cBalanceBefore); \n    } \n \n    function ctokenClaim(uint256 _lpAmount) internal virtual returns (uint256 value) { \n        value = ctokenWithdraw(_lpAmount); \n    } \n \n    function ctokenBorrow(uint256 _value) internal virtual returns (uint256 value) { \n        uint256 cBalanceBefore = call_balanceOf(baseToken(), address(this)); \n        require(eToken.borrow(_value) == 0, 'borrow ubalance error'); \n        uint256 cBalanceAfter = call_balanceOf(baseToken(), address(this)); \n        value = cBalanceAfter.sub(cBalanceBefore); \n    } \n \n    function ctokenRepayBorrow(uint256 _value) internal virtual { \n        require(eToken.repayBorrow(_value) == 0, 'repayBorrow ubalance error'); \n    } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \n \n \ncontract SafeBoxFoxCToken is SafeBoxFoxCTokenImpl, ReentrancyGuardUpgradeable, OwnableUpgradeable, IC\n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    struct BorrowInfo { \n        address strategy;      // borrow from strategy \n        uint256 pid;           // borrow to pool \n        address owner;         // borrower \n        uint256 amount;        // borrow amount \n        uint256 bPoints;       // borrow proportion \n    } \n \n    // supply manager \n    uint256 public accDebtPerSupply;    // platform debt is shared to each supply lptoken \n \n    // borrow manager \n    BorrowInfo[] public borrowInfo;     // borrow order info \n    mapping(address => mapping(address => mapping(uint256 => uint256))) public borrowIndex;   // _acc\n    mapping(address => uint256) public  accountBorrowPoints;   // _account,  amount \n    uint256 public lastBorrowCurrent;   // last settlement for \n \n    uint256 public borrowTotalPoints;          // total of user bPoints \n    uint256 public borrowTotalAmountWithPlatform;  // total of user borrows and interests and platfor\n    uint256 public borrowTotalAmount;          // total of user borrows and interests \n    uint256 public borrowTotal;                // total of user borrows \n \n    uint256 public borrowLimitRate;    // borrow limit,  max = borrowTotal * borrowLimitRate / 1e9, d\n    uint256 public borrowMinAmount;          // borrow min amount limit \n \n    mapping(address => bool) public blacklist;  // deposit blacklist \n    bool public depositEnabled; \n    bool public emergencyRepayEnabled; \n    bool public emergencyWithdrawEnabled; \n \n    address public override bank;       // borrow can from bank only \n    address public override token;      // deposit and borrow token \n \n    address public compActionPool;          // action pool for borrow rewards \n    uint256 public CTOKEN_BORROW;  // action pool borrow action id \n \n    uint256 public optimalUtilizationRate1;  // Lending rate 1, ideal 1e9, default = 60% \n    uint256 public optimalUtilizationRate2;  // Lending rate 2, ideal 1e9, default = 70% \n    uint256 public stableRateSlope1;         // loan interest times in max borrow rate 1 \n    uint256 public stableRateSlope2;        // loan interest times in max borrow rate 2 \n \n    address public devAddr; \n \n    event SafeBoxDeposit(address indexed user, uint256 amount); \n    event SafeBoxWithdraw(address indexed user, uint256 amount); \n    event SafeBoxClaim(address indexed user, uint256 amount); \n \n    event SetBlacklist(address indexed _account, bool _newset); \n    event SetBorrowLimitRate(uint256 oldRate, uint256 newRate); \n    event SetOptimalUtilizationRate(uint256 oldV1, uint256 oldV2, uint256 newV1, uint256 newV2); \n    event SetStableRateSlope(uint256 oldV1, uint256 oldV2, uint256 newV1, uint256 newV2); \n \n    function __SafeBoxFoxCToken_init(address _bank, address _cToken, address _devAddr) public initial\n        __Ownable_init(); \n        __ReentrancyGuard_init(); \n \n        __SafeBoxFoxCTokenImpl__init(_cToken); \n \n        CTOKEN_BORROW = 1;  // action pool borrow action id \n        devAddr = _devAddr; \n \n        optimalUtilizationRate1 = 1e9;  // Lending rate 1, ideal 1e9, default = 60% \n        optimalUtilizationRate2 = 1e9;  // Lending rate 2, ideal 1e9, default = 70% \n        stableRateSlope1 = 1e9;         // loan interest times in max borrow rate 1 \n        stableRateSlope2 = 1e9;         // loan interest times in max borrow rate 2 \n \n        depositEnabled = true; \n        borrowLimitRate = 7.5e8; \n \n        token = baseToken(); \n        require(IERC20Upgradeable(token).totalSupply() >= 0, 'token error'); \n        bank = _bank; \n \n        // 0 id  Occupied,  Available bid never be zero \n        borrowInfo.push(BorrowInfo(address(0), 0, address(0), 0, 0)); \n    } \n \n    modifier onlyBank() { \n        require(bank == msg.sender, 'borrow only from bank'); \n        _; \n    } \n \n    // link to actionpool , for borrower s allowance \n    function getCATPoolInfo(uint256 _pid) external virtual override view \n        returns (address lpToken, uint256 allocRate, uint256 totalPoints, uint256 totalAmount) { \n            _pid; \n            lpToken = token; \n            allocRate = 5e8; // never use \n            totalPoints = borrowTotalPoints; \n            totalAmount = borrowTotalAmountWithPlatform; \n    } \n \n    function getCATUserAmount(uint256 _pid, address _account) external virtual override view \n        returns (uint256 acctPoints) { \n            _pid; \n            acctPoints = accountBorrowPoints[_account]; \n    } \n \n    function getSource() external virtual override view returns (string memory) { \n        return 'dfox'; \n    } \n \n    // blacklist \n    function setBlacklist(address _account, bool _newset) external onlyOwner { \n        blacklist[_account] = _newset; \n        emit SetBlacklist(_account, _newset); \n    } \n \n    function setCompAcionPool(address _compActionPool) public onlyOwner { \n        compActionPool = _compActionPool; \n    } \n \n    function setDevAddr(address _devAddr) public { \n        require(devAddr == msg.sender, 'wu?'); \n        devAddr = _devAddr; \n    } \n \n    function setBorrowLimitRate(uint256 _borrowLimitRate) external onlyOwner { \n        require(_borrowLimitRate <= 1e9, 'rate too high'); \n        emit SetBorrowLimitRate(borrowLimitRate, _borrowLimitRate); \n        borrowLimitRate = _borrowLimitRate; \n    } \n \n    function setBorrowMinAmount(uint256 _borrowMinAmount) external onlyOwner { \n        borrowMinAmount = _borrowMinAmount; \n    } \n \n    function setEmergencyRepay(bool _emergencyRepayEnabled) external onlyOwner { \n        emergencyRepayEnabled = _emergencyRepayEnabled; \n    } \n \n    function setEmergencyWithdraw(bool _emergencyWithdrawEnabled) external onlyOwner { \n        emergencyWithdrawEnabled = _emergencyWithdrawEnabled; \n    } \n \n    // for platform borrow interest rate \n    function setOptimalUtilizationRate(uint256 _optimalUtilizationRate1, uint256 _optimalUtilizationR\n        require(_optimalUtilizationRate1 <= 1e9 && \n                _optimalUtilizationRate2 <= 1e9 && \n                _optimalUtilizationRate1 < _optimalUtilizationRate2 \n                , 'rate set error'); \n        emit SetOptimalUtilizationRate(optimalUtilizationRate1, optimalUtilizationRate2, _optimalUtil\n        optimalUtilizationRate1 = _optimalUtilizationRate1; \n        optimalUtilizationRate2 = _optimalUtilizationRate2; \n    } \n \n    function setStableRateSlope(uint256 _stableRateSlope1, uint256 _stableRateSlope2) external onlyOw\n        require(_stableRateSlope1 <= 1e4*1e9 && _stableRateSlope1 >= 1e9 && \n                 _stableRateSlope2 <= 1e4*1e9 && _stableRateSlope2 >= 1e9 , 'rate set error'); \n        emit SetStableRateSlope(stableRateSlope1, stableRateSlope2, _stableRateSlope1, _stableRateSlo\n        stableRateSlope1 = _stableRateSlope1; \n        stableRateSlope2 = _stableRateSlope2; \n    } \n \n    function supplyRatePerBlock() external override view returns (uint256) { \n        return ctokenSupplyRatePerBlock(); \n    } \n \n    function borrowRatePerBlock() external override view returns (uint256) { \n        return ctokenBorrowRatePerBlock().mul(getBorrowFactorPrewiew()).div(1e9); \n    } \n \n    function borrowInfoLength() external override view returns (uint256) { \n        return borrowInfo.length.sub(1); \n    } \n \n    function getBorrowInfo(uint256 _bid) external override view \n        returns (address owner, uint256 amount, address strategy, uint256 pid) { \n \n        strategy = borrowInfo[_bid].strategy; \n        pid = borrowInfo[_bid].pid; \n        owner = borrowInfo[_bid].owner; \n        amount = borrowInfo[_bid].amount; \n    } \n \n    function getBorrowFactorPrewiew() public virtual view returns (uint256) { \n        return _getBorrowFactor(getDepositTotal()); \n    } \n \n    function getBorrowFactor() public virtual returns (uint256) { \n        return _getBorrowFactor(call_balanceOfBaseToken_this()); \n    } \n \n    function _getBorrowFactor(uint256 supplyAmount) internal virtual view returns (uint256 value) { \n        if(supplyAmount <= 0) { \n            return uint256(1e9); \n        } \n        uint256 borrowRate = getBorrowTotal().mul(1e9).div(supplyAmount); \n        if(borrowRate <= optimalUtilizationRate1) { \n            return uint256(1e9); \n        } \n        uint256 value1 = stableRateSlope1.sub(1e9).mul(borrowRate.sub(optimalUtilizationRate1)) \n                    .div(uint256(1e9).sub(optimalUtilizationRate1)) \n                    .add(uint256(1e9)); \n        if(borrowRate <= optimalUtilizationRate2) { \n            value = value1; \n            return value; \n        } \n        uint256 value2 = stableRateSlope2.sub(1e9).mul(borrowRate.sub(optimalUtilizationRate2)) \n                    .div(uint256(1e9).sub(optimalUtilizationRate2)) \n                    .add(uint256(1e9)); \n        value = value2 > value1 ? value2 : value1; \n    } \n \n    function getBorrowTotal() public virtual override view returns (uint256) { \n        return borrowTotalAmountWithPlatform; \n    } \n \n    function getDepositTotal() public virtual override view returns (uint256) { \n        return totalSupply().mul(getBaseTokenPerLPToken()).div(1e18); \n    } \n \n    function getBaseTokenPerLPToken() public virtual override view returns (uint256) { \n        return getBaseTokenPerCToken(); \n    } \n \n    function pendingSupplyAmount(address _account) external virtual override view returns (uint256 va\n        value = call_balanceOf(address(this), _account).mul(getBaseTokenPerLPToken()).div(1e18); \n    } \n \n    function pendingBorrowAmount(uint256 _bid) public virtual override view returns (uint256 value) {\n        value = borrowInfo[_bid].amount; \n    } \n \n    // borrow interest, the sum of filda interest and platform interest \n    function pendingBorrowRewards(uint256 _bid) public virtual override view returns (uint256 value) \n        if(borrowTotalPoints <= 0) { \n            return 0; \n        } \n        value = borrowInfo[_bid].bPoints.mul(borrowTotalAmountWithPlatform).div(borrowTotalPoints); \n        value = TenMath.safeSub(value, borrowInfo[_bid].amount); \n    } \n \n    // deposit \n    function deposit(uint256 _value) external virtual override nonReentrant { \n        update(); \n        IERC20Upgradeable(token).safeTransferFrom(msg.sender, address(this), _value); \n        _deposit(msg.sender, _value); \n    } \n \n    function _deposit(address _account, uint256 _value) internal returns (uint256) { \n        require(depositEnabled, 'safebox closed'); \n        require(!blacklist[_account], 'address in blacklist'); \n        // token held in contract \n        uint256 balanceInput = call_balanceOf(token, address(this)); \n        require(balanceInput > 0 &&  balanceInput >= _value, 'where s token?'); \n \n        // update booking, mintValue is number of deposit credentials \n        uint256 mintValue = ctokenDeposit(_value); \n        if(mintValue > 0) { \n            _mint(_account, mintValue); \n        } \n        emit SafeBoxDeposit(_account, mintValue); \n        return mintValue; \n    } \n \n    function withdraw(uint256 _tTokenAmount) external virtual override nonReentrant { \n        update(); \n        _withdraw(msg.sender, _tTokenAmount); \n    } \n \n    function _withdraw(address _account, uint256 _tTokenAmount) internal returns (uint256) { \n        // withdraw if lptokens value is not up borrowLimitRate \n        if(_tTokenAmount > balanceOf(_account)) { \n            _tTokenAmount = balanceOf(_account); \n        } \n        uint256 maxBorrowAmount = call_balanceOfCToken_this().sub(_tTokenAmount) \n                                    .mul(getBaseTokenPerLPToken()).div(1e18) \n                                    .mul(borrowLimitRate).div(1e9); \n        require(maxBorrowAmount >= borrowTotalAmountWithPlatform, 'no money to withdraw'); \n \n        _burn(_account, uint256(_tTokenAmount)); \n \n        if(accDebtPerSupply > 0) { \n            // If platform loss, the loss will be shared by supply \n            uint256 debtAmount = _tTokenAmount.mul(accDebtPerSupply).div(1e18); \n            require(_tTokenAmount >= debtAmount, 'debt too much'); \n            _tTokenAmount = _tTokenAmount.sub(debtAmount); \n        } \n \n        ctokenWithdraw(_tTokenAmount); \n        tokenSafeTransfer(address(token), _account); \n        emit SafeBoxWithdraw(_account, _tTokenAmount); \n        return _tTokenAmount; \n    } \n \n    function claim(uint256 _value) external virtual override nonReentrant { \n        update(); \n        _claim(msg.sender, uint256(_value)); \n    } \n \n    function _claim(address _account, uint256 _value) internal { \n        emit SafeBoxClaim(_account, _value); \n    } \n \n    function getBorrowId(address _strategy, uint256 _pid, address _account) \n        public virtual override view returns (uint256 borrowId) { \n        borrowId = borrowIndex[_account][_strategy][_pid]; \n    } \n \n    function getBorrowId(address _strategy, uint256 _pid, address _account, bool _add) \n        external virtual override onlyBank returns (uint256 borrowId) { \n \n        require(_strategy != address(0), 'borrowid _strategy error'); \n        require(_account != address(0), 'borrowid _account error'); \n        borrowId = getBorrowId(_strategy, _pid, _account); \n        if(borrowId == 0 && _add) { \n            borrowInfo.push(BorrowInfo(_strategy, _pid, _account, 0, 0)); \n            borrowId = borrowInfo.length.sub(1); \n            borrowIndex[_account][_strategy][_pid] = borrowId; \n        } \n        require(borrowId > 0, 'not found borrowId'); \n    } \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external virtual override onlyBank { \n        update(); \n        _borrow(_bid, _value, _to); \n    } \n \n    function _borrow(uint256 _bid, uint256 _value, address _to) internal { \n        // withdraw if lptokens value is not up borrowLimitRate \n        uint256 maxBorrowAmount = call_balanceOfCToken_this() \n                                    .mul(getBaseTokenPerLPToken()).div(1e18) \n                                    .mul(borrowLimitRate).div(1e9); \n        require(maxBorrowAmount >= borrowTotalAmountWithPlatform.add(_value), 'no money to borrow'); \n        require(_value >= borrowMinAmount, 'borrow amount too low'); \n \n        BorrowInfo storage borrowCurrent = borrowInfo[_bid]; \n \n        // borrow \n        uint256 ubalance = ctokenBorrow(_value); \n        require(ubalance == _value, 'token borrow error'); \n \n        tokenSafeTransfer(address(token), _to); \n \n        // booking \n        uint256 addPoint = _value; \n        if(borrowTotalPoints > 0) { \n            addPoint = _value.mul(borrowTotalPoints).div(borrowTotalAmountWithPlatform); \n        } \n \n        borrowCurrent.bPoints = borrowCurrent.bPoints.add(addPoint); \n        borrowTotalPoints = borrowTotalPoints.add(addPoint); \n        borrowTotalAmountWithPlatform = borrowTotalAmountWithPlatform.add(_value); \n        lastBorrowCurrent = call_borrowBalanceCurrent_this(); \n \n        borrowCurrent.amount = borrowCurrent.amount.add(_value); \n        borrowTotal = borrowTotal.add(_value); \n        borrowTotalAmount = borrowTotalAmount.add(_value); \n \n        // notify for action pool \n        uint256 accountBorrowPointsOld = accountBorrowPoints[borrowCurrent.owner]; \n        accountBorrowPoints[borrowCurrent.owner] = accountBorrowPoints[borrowCurrent.owner].add(addPo\n \n        if(compActionPool != address(0) && addPoint > 0) { \n            IActionPools(compActionPool).onAcionIn(CTOKEN_BORROW, borrowCurrent.owner, \n                    accountBorrowPointsOld, accountBorrowPoints[borrowCurrent.owner]); \n        } \n        return ; \n    } \n \n    function repay(uint256 _bid, uint256 _value) external virtual override { \n        update(); \n        _repay(_bid, _value); \n    } \n \n    function _repay(uint256 _bid, uint256 _value) internal { \n        BorrowInfo storage borrowCurrent = borrowInfo[_bid]; \n \n        uint256 removedPoints; \n        if(_value >= pendingBorrowRewards(_bid).add(borrowCurrent.amount)) { \n            removedPoints = borrowCurrent.bPoints; \n        }else{ \n            removedPoints = _value.mul(borrowTotalPoints).div(borrowTotalAmountWithPlatform); \n            removedPoints = TenMath.min(removedPoints, borrowCurrent.bPoints); \n        } \n \n        // booking \n        uint256 userAmount = removedPoints.mul(borrowCurrent.amount).div(borrowCurrent.bPoints); // t\n        uint256 repayAmount = removedPoints.mul(borrowTotalAmount).div(borrowTotalPoints); // to repay\n        uint256 platformAmount = TenMath.safeSub(removedPoints.mul(borrowTotalAmountWithPlatform).div\n                                 repayAmount);  // platform interest \n \n        borrowCurrent.bPoints = TenMath.safeSub(borrowCurrent.bPoints, removedPoints); \n        borrowTotalPoints = TenMath.safeSub(borrowTotalPoints, removedPoints); \n        borrowTotalAmountWithPlatform = TenMath.safeSub(borrowTotalAmountWithPlatform, repayAmount.ad\n        lastBorrowCurrent = call_borrowBalanceCurrent_this(); \n \n        borrowCurrent.amount = TenMath.safeSub(borrowCurrent.amount, userAmount); \n        borrowTotal = TenMath.safeSub(borrowTotal, userAmount); \n        borrowTotalAmount = TenMath.safeSub(borrowTotalAmount, repayAmount); \n \n        // platform interest \n        if(platformAmount > 0 && devAddr != address(0)) { \n            IERC20Upgradeable(token).safeTransfer(devAddr, platformAmount); \n        } \n \n        // repay resize \n        uint256 restRepayAmount = 0; \n        if(repayAmount > lastBorrowCurrent) { \n            restRepayAmount = repayAmount.sub(lastBorrowCurrent); \n        } \n \n        // repay borrow \n        repayAmount = TenMath.min(repayAmount, lastBorrowCurrent); \n \n        ctokenRepayBorrow(repayAmount); \n        lastBorrowCurrent = call_borrowBalanceCurrent_this(); \n \n        // return of the rest \n        if(restRepayAmount > 0) { \n            tokenSafeTransferAmount(token, restRepayAmount, owner()); \n        } \n        tokenSafeTransfer(token, msg.sender); \n \n        // notify for action pool \n        uint256 accountBorrowPointsOld = accountBorrowPoints[borrowCurrent.owner]; \n        accountBorrowPoints[borrowCurrent.owner] = TenMath.safeSub(accountBorrowPoints[borrowCurrent.\n \n        if(compActionPool != address(0) && removedPoints > 0) { \n            IActionPools(compActionPool).onAcionOut(CTOKEN_BORROW, borrowCurrent.owner, \n                    accountBorrowPointsOld, accountBorrowPoints[borrowCurrent.owner]); \n        } \n        return ; \n    } \n \n    function emergencyWithdraw() external virtual override nonReentrant { \n        require(emergencyWithdrawEnabled, 'not in emergency'); \n \n        uint256 withdrawAmount = call_balanceOf(address(this), msg.sender); \n        _burn(msg.sender, withdrawAmount); \n \n        if(accDebtPerSupply > 0) { \n            // If platform loss, the loss will be shared by supply \n            uint256 debtAmount = withdrawAmount.mul(accDebtPerSupply).div(1e18); \n            require(withdrawAmount >= debtAmount, 'debt too much'); \n            withdrawAmount = withdrawAmount.sub(debtAmount); \n        } \n \n        // withdraw ctoken \n        ctokenWithdraw(withdrawAmount); \n \n        tokenSafeTransfer(address(token), msg.sender); \n    } \n \n    function emergencyRepay(uint256 _bid) external virtual override nonReentrant { \n        require(emergencyRepayEnabled, 'not in emergency'); \n        // in emergency mode , only repay loan \n        BorrowInfo storage borrowCurrent = borrowInfo[_bid]; \n \n        uint256 repayAmount = borrowCurrent.amount; \n \n        IERC20Upgradeable(baseToken()).safeTransferFrom(msg.sender, address(this), repayAmount); \n        ctokenRepayBorrow(repayAmount); \n \n        uint256 accountBorrowPointsOld = accountBorrowPoints[borrowCurrent.owner]; \n        accountBorrowPoints[borrowCurrent.owner] = TenMath.safeSub(accountBorrowPoints[borrowCurrent.\n \n        // booking \n        borrowTotal = TenMath.safeSub(borrowTotal, repayAmount); \n        borrowTotalPoints = TenMath.safeSub(borrowTotalPoints, borrowCurrent.bPoints); \n        borrowTotalAmount = TenMath.safeSub(borrowTotalAmount, repayAmount); \n        borrowTotalAmountWithPlatform = TenMath.safeSub(borrowTotalAmountWithPlatform, repayAmount); \n        borrowCurrent.amount = 0; \n        borrowCurrent.bPoints = 0; \n        lastBorrowCurrent = call_borrowBalanceCurrent_this(); \n    } \n \n    function update() public virtual override { \n        _update(); \n    } \n \n    function _update() internal { \n        // update borrow interest \n        uint256 lastBorrowCurrentNow = call_borrowBalanceCurrent_this(); \n        if(lastBorrowCurrentNow != lastBorrowCurrent && borrowTotal > 0) { \n            if(lastBorrowCurrentNow >= lastBorrowCurrent) { \n                // booking \n                uint256 newDebtAmount1 = lastBorrowCurrentNow.sub(lastBorrowCurrent); \n                uint256 newDebtAmount2 = newDebtAmount1.mul(getBorrowFactor()).div(1e9); \n                borrowTotalAmount = borrowTotalAmount.add(newDebtAmount1); \n                borrowTotalAmountWithPlatform = borrowTotalAmountWithPlatform.add(newDebtAmount2); \n            } \n            lastBorrowCurrent = lastBorrowCurrentNow; \n        } \n \n        // manage ctoken amount \n        uint256 uCTokenTotalAmount = call_balanceOfCToken_this(); \n        if(uCTokenTotalAmount >= totalSupply()) { \n            // The platform has no debt \n            accDebtPerSupply = 0; \n        } \n        if(totalSupply() > 0 && accDebtPerSupply > 0) { \n            // The platform has debt, uCTokenTotalAmount will be totalSupply() \n            uCTokenTotalAmount = uCTokenTotalAmount.add(accDebtPerSupply.mul(totalSupply()).div(1e18)\n        } \n        if(uCTokenTotalAmount < totalSupply()) { \n            // totalSupply() != 0  new debt divided equally \n            accDebtPerSupply = accDebtPerSupply.add(totalSupply().sub(uCTokenTotalAmount).mul(1e18).d\n        } else if(uCTokenTotalAmount > totalSupply() && accDebtPerSupply > 0) { \n            // reduce debt divided equally \n            uint256 accDebtReduce = uCTokenTotalAmount.sub(totalSupply()).mul(1e18).div(totalSupply()\n            accDebtReduce = TenMath.min(accDebtReduce, accDebtPerSupply); \n            accDebtPerSupply = accDebtPerSupply.sub(accDebtReduce); \n        } \n \n        if(compActionPool != address(0)) { \n            IActionPools(compActionPool).onAcionUpdate(CTOKEN_BORROW); \n        } \n    } \n \n    function mintDonate(uint256 _value) public virtual override nonReentrant { \n        IERC20Upgradeable(token).safeTransferFrom(msg.sender, address(this), _value); \n        ctokenDeposit(_value); \n        update(); \n    } \n \n    function tokenSafeTransfer(address _token, address _to) internal { \n        uint256 value = IERC20Upgradeable(_token).balanceOf(address(this)); \n        if(value > 0) { \n            IERC20Upgradeable(_token).transfer(_to, value); \n        } \n    } \n \n    function tokenSafeTransferAmount(address _token, uint256 _want, address _to) internal { \n        uint256 value = IERC20Upgradeable(_token).balanceOf(address(this)); \n        value = TenMath.min(value, _want); \n        if(value > 0) { \n            IERC20Upgradeable(_token).transfer(_to, value); \n        } \n    } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \n \n \n \n// Distribution of BOO Compound token \ncontract SafeBoxFox is SafeBoxFoxCToken { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    IERC20Upgradeable public REWARDS_TOKEN; \n \n    uint256 public lastRewardsTokenBlock;        // rewards update \n \n    address public actionPoolRewards;            // address for action pool \n    uint256 public poolDepositId;               // poolid of depositor s token rewards in action pool\n    uint256 public poolBorrowId;                // poolid of borrower s token rewards in action pool \n \n    uint256 public REWARDS_DEPOSIT_CALLID;      // depositinfo callid for action callback \n    uint256 public REWARDS_BORROW_CALLID;       // borrowinfo callid for comp action callback \n \n    event SetRewardsDepositPool(address _actionPoolRewards, uint256 _piddeposit); \n    event SetRewardsBorrowPool(address _compActionPool, uint256 _pidborrow); \n \n    function initialize(address _bank, address _cToken, address _devAddr) public initializer { \n        __Ownable_init(); \n \n        __SafeBoxFoxCToken_init(_bank, _cToken, _devAddr); \n \n        REWARDS_TOKEN = IERC20Upgradeable(0); \n        REWARDS_DEPOSIT_CALLID = 16; \n        REWARDS_BORROW_CALLID = 18; \n    } \n \n    function update() public virtual override { \n        _update(); \n        updatetoken(); \n    } \n \n    // mint rewards for supplies to action pools \n    function setRewardsDepositPool(address _actionPoolRewards, uint256 _piddeposit) public onlyOwner \n        actionPoolRewards = _actionPoolRewards; \n        poolDepositId = _piddeposit; \n        emit SetRewardsDepositPool(_actionPoolRewards, _piddeposit); \n    } \n \n    // mint rewards for borrows to comp action pools \n    function setRewardsBorrowPool(uint256 _pidborrow) public onlyOwner { \n        _checkActionPool(compActionPool, _pidborrow, REWARDS_BORROW_CALLID); \n        poolBorrowId = _pidborrow; \n        emit SetRewardsBorrowPool(compActionPool, _pidborrow); \n    } \n \n    function _checkActionPool(address _actionPool, uint256 _pid, uint256 _rewardscallid) internal vie\n        (address callFrom, uint256 callId, address rewardToken) \n            = IActionPools(_actionPool).getPoolInfo(_pid); \n        require(callFrom == address(this), 'call from error'); \n        require(callId == _rewardscallid, 'callid error'); \n    } \n \n    function deposit(uint256 _value) external virtual override nonReentrant { \n        update(); \n        IERC20Upgradeable(token).safeTransferFrom(msg.sender, address(this), _value); \n        _deposit(msg.sender, _value); \n    } \n \n    function withdraw(uint256 _tTokenAmount) external virtual override nonReentrant { \n        update(); \n        _withdraw(msg.sender, _tTokenAmount); \n    } \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external virtual override onlyBank { \n        update(); \n        address owner = borrowInfo[_bid].owner; \nTimelock.sol\n        uint256 accountBorrowPointsOld = accountBorrowPoints[owner]; \n        _borrow(_bid, _value, _to); \n \n        if(compActionPool != address(0) && _value > 0) { \n            IActionPools(compActionPool).onAcionIn(REWARDS_BORROW_CALLID, owner, \n                    accountBorrowPointsOld, accountBorrowPoints[owner]); \n        } \n    } \n \n    function repay(uint256 _bid, uint256 _value) external virtual override { \n        update(); \n        address owner = borrowInfo[_bid].owner; \n        uint256 accountBorrowPointsOld = accountBorrowPoints[owner]; \n        _repay(_bid, _value); \n \n        if(compActionPool != address(0) && _value > 0) { \n            IActionPools(compActionPool).onAcionOut(REWARDS_BORROW_CALLID, owner, \n                    accountBorrowPointsOld, accountBorrowPoints[owner]); \n        } \n    } \n \n    function updatetoken() public { \n        if(lastRewardsTokenBlock == block.number) { \n            return ; \n        } \n        lastRewardsTokenBlock = block.number; \n    } \n \n    function claim(uint256 _value) external virtual override nonReentrant { \n        update(); \n        _claim(msg.sender, _value); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \ncontract Timelock { \n    using SafeMath for uint; \n \n    event NewAdmin(address indexed newAdmin); \n    event NewPendingAdmin(address indexed newPendingAdmin); \n    event NewDelay(uint indexed newDelay); \n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signat\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signa\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signatu\n \n    uint public constant GRACE_PERIOD = 14 days; \n    uint public constant MINIMUM_DELAY = 2 days; \n    uint public constant MAXIMUM_DELAY = 30 days; \n \n    address public admin; \n    address public pendingAdmin; \n    uint public delay; \n \n    mapping (bytes32 => bool) public queuedTransactions; \n \n \n    constructor(address admin_, uint delay_) public { \n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\"); \n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n \n        admin = admin_; \n        delay = delay_; \n    } \n \n    receive() external payable { } \n \n    function setDelay(uint delay_) public { \n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\"); \n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\"); \n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_; \n \n        emit NewDelay(delay); \n    } \n \n    function acceptAdmin() public { \n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\n        admin = msg.sender; \n        pendingAdmin = address(0); \n \n        emit NewAdmin(admin); \n    } \n \n    function setPendingAdmin(address pendingAdmin_) public { \n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock\n        pendingAdmin = pendingAdmin_; \n \n        emit NewPendingAdmin(pendingAdmin); \n    } \n \n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, \n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\"); \n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated executi\n \n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); \n        queuedTransactions[txHash] = true; \n \n        emit QueueTransaction(txHash, target, value, signature, data, eta); \n        return txHash; \n    } \n \n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\"); \n \n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); \n        queuedTransactions[txHash] = false; \n \nStrategyV2PairHelper.sol\n        emit CancelTransaction(txHash, target, value, signature, data, eta); \n    } \n \n    function executeTransaction(address target, uint value, string memory signature, bytes memory dat\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\"); \n \n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); \n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been qu\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpass\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transact\n \n        queuedTransactions[txHash] = false; \n \n        bytes memory callData; \n \n        if (bytes(signature).length == 0) { \n            callData = data; \n        } else { \n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data); \n        } \n \n        // solium-disable-next-line security/no-call-value \n        (bool success, bytes memory returnData) = target.call{value: value}(callData); \n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\"); \n \n        emit ExecuteTransaction(txHash, target, value, signature, data, eta); \n \n        return returnData; \n    } \n \n    function getBlockTimestamp() internal view returns (uint) { \n        // solium-disable-next-line security/no-block-members \n        return block.timestamp; \n    } \n}\n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using AddressUpgradeable for address; \n \n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface ISafeBox { \n \n    function bank() external view returns(address); \n \n    function token() external view returns(address); \n \n    function getSource() external view returns (string memory); \n \n    function supplyRatePerBlock() external view returns (uint256); \n    function borrowRatePerBlock() external view returns (uint256); \n \n    function getBorrowInfo(uint256 _bid) external view \n            returns (address owner, uint256 amount, address strategy, uint256 pid); \n    function getBorrowId(address _strategy, uint256 _pid, address _account) external view returns (ui\n    function getBorrowId(address _strategy, uint256 _pid, address _account, bool _add) external retur\n    function getDepositTotal() external view returns (uint256); \n    function getBorrowTotal() external view returns (uint256); \n    // function getBorrowAmount(address _account) external view returns (uint256 value); \n    function getBaseTokenPerLPToken() external view returns (uint256); \n \n    function deposit(uint256 _value) external; \n    function withdraw(uint256 _value) external; \n \n    function emergencyWithdraw() external; \n    function emergencyRepay(uint256 _bid) external; \n \n    function borrowInfoLength() external view returns (uint256); \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external; \n    function repay(uint256 _bid, uint256 _value) external; \n    function claim(uint256 _tTokenAmount) external; \n \n    function update() external; \n    function mintDonate(uint256 _value) external; \n \n    function pendingSupplyAmount(address _account) external view returns (uint256 value); \n    function pendingBorrowAmount(uint256 _bid) external view returns (uint256 value); \n    function pendingBorrowRewards(uint256 _bid) external view returns (uint256 value); \n} \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n    function getPoolInfo(uint256 _pid) external view \n        returns (address callFrom, uint256 callId, address rewardToken); \n    function mintRewards(uint256 _callId) external; \n    function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n    function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n    function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n    function onAcionClaim(uint256 _callId, address _account) external; \n    function onAcionEmergency(uint256 _callId, address _account) external; \n    function onAcionUpdate(uint256 _callId) external; \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface ITenBankHall { \n    function makeBorrowFrom(uint256 _pid, address _account, address _debtFrom, uint256 _value) extern\n} \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface ITenBankHallV2 is ITenBankHall { \n    function boxInfo(uint256 _boxid) external view returns (address); \n    function boxIndex(address _boxaddr) external view returns (uint256); \n    function boxlisted(address _boxaddr) external view returns (bool); \n \n    function strategyInfo(uint256 _sid) external view returns (bool, address, uint256); \n    function strategyIndex(address _strategy, uint256 _sid) external view returns (uint256); \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IPriceChecker { \n    function getPriceSlippage(address _lptoken) external view returns (uint256); \n    function checkLPTokenPriceLimit(address _lptoken, bool _largeType) external view returns (bool); \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IStrategyLink { \n \n    event StrategyDeposit(address indexed strategy, uint256 indexed pid, address indexed user, uint25\n    event StrategyBorrow(address indexed strategy, uint256 indexed pid, address indexed user, uint256 \n    event StrategyWithdraw(address indexed strategy, uint256 indexed pid, address indexed user, uint2\n    event StrategyLiquidation(address indexed strategy, uint256 indexed pid, address indexed user, ui\n \n    function bank() external view returns(address); \n    function getSource() external view returns (string memory); \n    function userInfo(uint256 _pid, address _account) external view returns (uint256,uint256,address,\n    function getPoolInfo(uint256 _pid) external view  returns(address[] memory collateralToken, addre\n    function getBorrowInfo(uint256 _pid, address _account) external view returns (address borrowFrom, \n    function getBorrowAmount(uint256 _pid, address _account) external view returns (uint256 value); \n    function getBorrowAmountInBaseToken(uint256 _pid, address _account) external view returns (uint25\n    function getDepositAmount(uint256 _pid, address _account) external view returns (uint256 amount);\n \n    function getPoolCollateralToken(uint256 _pid) external view returns (address[] memory collateralT\n    function getPoollpToken(uint256 _pid) external view returns (address lpToken); \n    function getBaseToken(uint256 _pid) external view returns (address baseToken); \n \n    function poolLength() external view returns (uint256); \n \n    function pendingRewards(uint256 _pid, address _account) external view returns (uint256 value); \n    function pendingLPAmount(uint256 _pid, address _account) external view returns (uint256 value); \n \n    // function massUpdatePools(uint256 _start, uint256 _end) external; \n    function updatePool(uint256 _pid, uint256 _desirePrice, uint256 _slippage) external; \n \n    function deposit(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint256 _de\n    function depositLPToken(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint\n \n    function withdraw(uint256 _pid, address _account, uint256 _rate, address _toToken, uint256 _desir\n    function withdrawLPToken(uint256 _pid, address _account, uint256 _rate, uint256 _desirePrice, uin\n \n    function emergencyWithdraw(uint256 _pid, address _account, uint256 _desirePrice, uint256 _slippag\n \n    function liquidation(uint256 _pid, address _account, address _hunter, uint256 _maxDebt) external;\n    function repayBorrow(uint256 _pid, address _account, uint256 _rate, bool _force) external; \n} \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IStrategyV2Pair is IStrategyLink { \n \n    event AddPool(uint256 _pid, uint256 _poolId, address lpToken, address _baseToken); \n    event SetMiniRewardAmount(uint256 _pid, uint256 _miniRewardAmount); \n    event SetPoolImpl(address _oldv, address _new); \n    event SetComponents(address _compActionPool, address _buyback, address _priceChecker, address _co\n    event SetPoolConfig(uint256 _pid, string _key, uint256 _value); \n \n    event StrategyBorrow2(address indexed strategy, uint256 indexed pid, address user, address indexe\n    event StrategyRepayBorrow2(address indexed strategy, uint256 indexed pid, address user, address i\n    event StrategyLiquidation2(address indexed strategy, uint256 indexed pid, address user, uint256 l\n \n    function getBorrowInfo(uint256 _pid, address _account, uint256 _bindex) \n        external view returns (address borrowFrom, uint256 bid, uint256 amount); \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IStrategyV2PairHelper { \n} \n",
            "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n  using SafeMathUpgradeable for uint256; \n \n  function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n    vr = v1 > v2 ? v2 : v1; \n  } \n \n  function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n    vr = v1 > v2 ? v1.sub(v2) : 0; \n  } \n \n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/\n  function sqrt(uint256 x) internal pure returns (uint256) { \n    if (x == 0) return 0; \n    uint256 xx = x; \n    uint256 r = 1; \n \n    if (xx >= 0x100000000000000000000000000000000) { \n      xx >>= 128; \n      r <<= 64; \n    } \n \n    if (xx >= 0x10000000000000000) { \n      xx >>= 64; \n      r <<= 32; \n    } \n    if (xx >= 0x100000000) { \n      xx >>= 32; \n      r <<= 16; \n    } \n    if (xx >= 0x10000) { \n      xx >>= 16; \n      r <<= 8; \n    } \n    if (xx >= 0x100) { \n      xx >>= 8; \n      r <<= 4; \n    } \n    if (xx >= 0x10) { \n      xx >>= 4; \n      r <<= 2; \n    } \n    if (xx >= 0x8) { \n      r <<= 1; \n    } \n \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; // Seven iterations should be enough \n    uint256 r1 = x / r; \n    return (r < r1 ? r : r1); \n  } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IStrategyConfig { \n    // event \n    event SetFeeGather(address _feeGatherOld, address _feeGather); \n    event SetReservedGather(address _old, address _new); \n    event SetBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor); \n    event SetLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor); \n    event SetFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor); \n    event SetDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee); \n    event SetWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee); \n    event SetRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee); \n    event SetClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee); \n    event SetLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee); \n \n    // factor \n    function getBorrowFactor(address _strategy, uint256 _poolid) external view returns (uint256); \n    function setBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor) external; \n \n    function getLiquidationFactor(address _strategy, uint256 _poolid) external view returns (uint256)\n    function setLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor) ext\n \n    function getFarmPoolFactor(address _strategy, uint256 _poolid) external view returns (uint256 val\n    function setFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor) external;\n \n    // fee manager \n    function getDepositFee(address _strategy, uint256 _poolid) external view returns (address, uint25\n    function setDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee) external; \n \n    function getWithdrawFee(address _strategy, uint256 _poolid) external view returns (address, uint2\n    function setWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee) external; \n \n    function getRefundFee(address _strategy, uint256 _poolid) external view returns (address, uint256\n    function setRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee) external; \n \n    function getClaimFee(address _strategy, uint256 _poolid) external view returns (address, uint256)\n    function setClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee) external; \n \n    function getLiquidationFee(address _strategy, uint256 _poolid) external view returns (address, ui\n    function setLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee) external;\n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IStrategyV2SwapPool { \n \n    function setStrategy(address _strategy) external; \n \n    // get strategy \n    function getName() external view returns (string memory); \n \n    // swap functions \n    function getPair(address _t0, address _t1) external view returns (address pairs); \n    function getReserves(address _lpToken) external view returns (uint256 a, uint256 b); \n    function getToken01(address _pairs) external view returns (address token0, address token1); \n    function getAmountOut(address _tokenIn, address _tokenOut, uint256 _amountOut) external view retu\n    function getAmountIn(address _tokenIn, uint256 _amountIn, address _tokenOut) external view return\n    function getLPTokenAmountInBaseToken(address _lpToken, uint256 _lpTokenAmount, address _baseToken\n    function swapTokenTo(address _tokenIn, uint256 _amountIn, address _tokenOut, address _toAddress) \n \n    function optimalBorrowAmount(address _lpToken, uint256 _amount0, uint256 _amount1) external view \n    function optimalDepositAmount(address lpToken, uint amtA, uint amtB) external view returns (uint \n \n    // pool functions \n    function getDepositToken(uint256 _poolId) external view returns (address lpToken); \n    function getRewardToken(uint256 _poolId) external view returns (address rewardToken); \n    function getPending(uint256 _poolId) external view returns (uint256 rewards); \n    function deposit(uint256 _poolId, bool _autoPool) external returns (uint256 liquidity); \n    function withdraw(uint256 _poolId, uint256 _liquidity, bool _autoPool) external returns (uint256 \n    function claim(uint256 _poolId) external returns (uint256 rewards); \n    function extraRewards() external returns (address token, uint256 rewards); \n} \n \n",
            "pragma solidity 0.6.12; \n \n \n \ncontract StrategyV2Data { \n \n    // Info of each user. \n    struct UserInfo { \n        uint256 lpAmount;       // deposit lptoken amount \n        uint256 lpPoints;       // deposit proportion \n        address[] borrowFrom;   // borrowFrom \n        uint256[] bids; \n    } \n \n    // Info of each pool. \n    struct PoolInfo { \n        address[] collateralToken;      // collateral Token list, last must be baseToken \n        address baseToken;              // baseToken can be borrowed \n        address lpToken;                // lptoken to deposit \n        uint256 poolId;                 // poolid for mdex pools \n        uint256 lastRewardsBlock;       // \n        uint256 totalPoints;            // total of user lpPoints \n        uint256 totalLPAmount;          // total of user lpAmount \n        uint256 totalLPReinvest;        // total of lptoken amount with totalLPAmount and reinvest re\n        uint256 miniRewardAmount;       // \n    } \n \n    // Info of each pool. \n    PoolInfo[] public poolInfo; \n    // Info of each user that stakes LP tokens. \n    mapping (uint256 => mapping (address => UserInfo)) public userInfo2; \n \n    address public _bank;                // address of bank \n    address public _this; \n    address public helperImpl; \n \n    IStrategyConfig public sconfig; \n    mapping (uint256 => mapping (string => uint256)) public poolConfig; \n \n    IStrategyV2SwapPool public swapPoolImpl; \n \n    address public devAddr; \n    IPriceChecker public priceChecker; \n    IActionPools public compActionPool;     // address of comp action pool \n \n    mapping(address=>bool) public whitelist; \n    uint256[39] private __gap; \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \n \n \n// Borrow and Repay \ncontract StrategyV2PairHelper is StrategyV2Data, IStrategyV2PairHelper { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    // check limit \n    function checkAddPoolLimit(uint256 _pid) external view { \n        PoolInfo memory pool = poolInfo[_pid]; \n        require(pool.collateralToken[0] == pool.baseToken || \n                pool.collateralToken[1] == pool.baseToken, \n                'baseToken not in pair'); \n        require(swapPoolImpl.getDepositToken(pool.poolId) == pool.lpToken, 'lptoken error'); \n    } \n \n    function checkDepositLimit(uint256 _pid, address _account, uint256 _orginSwapRate) external view \n        _account; \n        require(address(sconfig) != address(0), 'not config'); \n        uint256 farmLimit = sconfig.getFarmPoolFactor(_this, _pid); \n        if(farmLimit > 0) { \n            require(poolInfo[_pid].totalLPReinvest <= farmLimit, 'pool invest limit'); \n        } \n \n        (uint256 res0, uint256 res1) = swapPoolImpl.getReserves(poolInfo[_pid].lpToken); \n        uint256 curSwapRate = res0.mul(1e18).div(res1); \n        uint256 slippage = poolConfig[_pid][string('deposit_slippage')]; \n        require(slippage > 0, 'deposit_slippage == 0'); \n        uint256 swapSlippage = _orginSwapRate.mul(1e9).div(curSwapRate); \n        require(swapSlippage < slippage.add(1e9) && \n                swapSlippage > uint256(1e9).sub(slippage), 'pool slippage over'); \n    } \n \n    function checkLiquidationLimit(uint256 _pid, address _account, bool liqucheck) external view { \n        require(address(sconfig) != address(0), 'not config liquidation'); \n \n        uint256 liquRate = sconfig.getLiquidationFactor(_this, _pid); \n        uint256 borrowAmount = IStrategyV2Pair(_this).getBorrowAmountInBaseToken(_pid, _account); \n        if(borrowAmount == 0) { \n            require(!liqucheck, 'no borrow'); \n            return ; \n        } \n \n        uint256 holdLPTokenAmount = IStrategyV2Pair(_this).pendingLPAmount(_pid, _account); \n        uint256 holdBaseAmount = getLPTokenAmountInBaseToken(_pid, holdLPTokenAmount, poolInfo[_pid].\n        if(liqucheck) { \n            // check whether in liquidation \n            if(holdBaseAmount > 0) { \n                require(borrowAmount.mul(1e9).div(holdBaseAmount) > liquRate, 'check in liquidation')\n            } \n        } else { \n            // check must not in liquidation \n            require(holdBaseAmount > 0, 'no hold in liquidation'); \n            require(borrowAmount.mul(1e9).div(holdBaseAmount) < liquRate, 'check out liquidation'); \n        } \n    } \n \n    function checkOraclePrice(uint256 _pid, bool _large) public view { \n        if(address(priceChecker) == address(0)) { \n            return ; \n        } \n        bool oracle = priceChecker.checkLPTokenPriceLimit(poolInfo[_pid].lpToken, _large); \n        require(oracle, 'oracle price limit'); \n    } \n \n    function checkBorrowLimit(uint256 _pid, address _account) external view { \n        PoolInfo memory pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo2[_pid][_account]; \n \n        uint256 borrowAmount = IStrategyV2Pair(_this).getBorrowAmountInBaseToken(_pid, _account); \n        uint256 lpTokenAmount = IStrategyV2Pair(_this).pendingLPAmount(_pid, _account); \n        uint256 holdBaseAmount = getLPTokenAmountInBaseToken(_pid, lpTokenAmount, pool.baseToken); \n        uint256 borrowFactor = sconfig.getBorrowFactor(_this, _pid); \n \n        require(borrowAmount <= holdBaseAmount.sub(borrowAmount).mul(borrowFactor).div(1e9), 'borrow \n    } \n \n    function calcDepositFee(uint256 _pid) \n        external view returns (address gather, uint256 _amount0, uint256 _amount1) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        uint256 feerate; \n        (gather, feerate) = sconfig.getDepositFee(_this, _pid); \n        _amount0 = IERC20Upgradeable(pool.collateralToken[0]).balanceOf(_this).mul(feerate).div(1e9);\n        _amount1 = IERC20Upgradeable(pool.collateralToken[1]).balanceOf(_this).mul(feerate).div(1e9);\n    } \n \n \n    function calcRefundFee(uint256 _pid, uint256 _rewardAmount) \n        public view returns (address gather, uint256 feeAmount) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        uint256 feerate; \n        (gather, feerate) = sconfig.getRefundFee(_this, _pid); \n        feeAmount = _rewardAmount.mul(feerate).div(1e9); \n    } \n \n    function calcBorrowAmount(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount) \n        external view returns (uint256 bindex, uint256 amount) { \n        if(_debtFrom == address(0)) return (0, 0); \n \n        PoolInfo memory pool = poolInfo[_pid]; \n        address token0 = pool.collateralToken[0]; \n        address token1 = pool.collateralToken[1]; \n        amount = _bAmount; \n \n        { \n            // check _debtFrom address book in bank \n            uint256 debtid = ITenBankHallV2(_bank).boxIndex(_debtFrom); \n            require(debtid > 0 || ITenBankHallV2(_bank).boxInfo(debtid) == _debtFrom, 'borrow from ba\n        } \n \n        address borrowToken = ISafeBox(_debtFrom).token(); \n        require(borrowToken == token0 || borrowToken == token1, 'debtFrom token error'); \n \n        bindex = borrowToken == token0 ? 0 : 1; \n        if(amount > 0) { \n            return (bindex, amount); \n        } \n \n        (uint256 res0, uint256 res1) = swapPoolImpl.getReserves(pool.lpToken); \n        { \n            (address token00,) = swapPoolImpl.getToken01(pool.lpToken); \n            (res0, res1) = token00 == token0 ? (res0, res1) : (res1, res0); \n        } \n \n        uint256 balance0 = IERC20Upgradeable(token0).balanceOf(_this); \n        uint256 balance1 = IERC20Upgradeable(token1).balanceOf(_this); \n        if(bindex == 0) { \n            amount = balance1.mul(res0).div(res1); \n            if(amount > balance0) amount = amount.sub(balance0); \n        } else { \n            amount = balance0.mul(res1).div(res0); \n            if(amount > balance1) amount = amount.sub(balance1); \n        } \n    } \n \n    function calcRemoveLiquidity(uint256 _pid, address _account, uint256 _rate) \n        external view returns (uint256 removedLPAmount, uint256 removedPoint) { \n        PoolInfo memory pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo2[_pid][_account]; \n        if(pool.totalPoints == 0) { \n            return (0, 0); \n        } \n        if(_rate >= 1e9) { \n            removedPoint = user.lpPoints; \n        } else { \n            removedPoint = user.lpPoints.mul(_rate).div(1e9); \n        } \n        removedLPAmount = removedPoint.mul(pool.totalLPReinvest).div(pool.totalPoints); \n        removedLPAmount = TenMath.min(removedLPAmount, pool.totalLPReinvest); \n    } \n \n    function calcWithdrawFee(uint256 _pid, address _account, uint256 _rate) \n        external view returns (address gather, uint256 a0, uint256 a1) { \n \n        // sconfig. \n        uint256 feerate; \n        (gather, feerate) = sconfig.getWithdrawFee(_this, _pid); \n        return (gather, 0, 0); \n \n        uint256 borrowAmount = IStrategyV2Pair(_this).getBorrowAmountInBaseToken(_pid, _account); \n        uint256 holdLPTokenAmount = IStrategyV2Pair(_this).pendingLPAmount(_pid, _account); \n        uint256 holdLPRewardsAmount = IStrategyV2Pair(_this).pendingRewards(_pid, _account); \n        if(holdLPRewardsAmount == 0 || holdLPTokenAmount == 0) { \n            return (gather, 0, 0); \n        } \n        PoolInfo memory pool = poolInfo[_pid]; \n        uint256 holdBaseAmount = getLPTokenAmountInBaseToken(_pid, holdLPTokenAmount, pool.baseToken)\n        uint256 borrowRate = borrowAmount.mul(1e9).div(holdBaseAmount); \n        if(borrowRate == 0) { \n            return (gather, 0, 0); \n        } \n        uint256 rewardsRate = holdLPRewardsAmount.mul(1e9).div(holdLPTokenAmount); \n        uint256 rewardsByBorrowRate = rewardsRate.mul(borrowRate).div(1e9).mul(feerate).div(1e9); \n        a0 = IERC20Upgradeable(pool.collateralToken[0]).balanceOf(_this).mul(rewardsByBorrowRate).div\n        a1 = IERC20Upgradeable(pool.collateralToken[1]).balanceOf(_this).mul(rewardsByBorrowRate).div\n    } \n \n    function calcLiquidationFee(uint256 _pid, address _account) \n        public view returns (address gather, uint256 baseAmount) { \n        if(address(sconfig) == address(0)) return (address(0), 0); \n \n        PoolInfo memory pool = poolInfo[_pid]; \n        uint256 feerate; \n        (gather, feerate) = sconfig.getLiquidationFee(_this, _pid); \n        baseAmount = IERC20Upgradeable(pool.baseToken).balanceOf(_this).mul(feerate).div(1e9); \n    } \n \n    function calcWithdrawRepayBorrow(uint256 _pid, address _account, uint256 _rate, uint256 _index) \n        public view returns (address token, uint256 amount, bool swap, uint256 swapAmount) { \n \n        UserInfo storage user = userInfo2[_pid][_account]; \n        if(_index >= user.borrowFrom.length || user.borrowFrom[_index] == address(0)) { \n            return (address(0), 0, false, 0); \n        } \n \n        PoolInfo memory pool = poolInfo[_pid]; \n        ISafeBox borrowFrom = ISafeBox(user.borrowFrom[_index]); \n        token = borrowFrom.token(); \n \n        amount = borrowFrom.pendingBorrowAmount(user.bids[_index]); \n        amount = amount.add(borrowFrom.pendingBorrowRewards(user.bids[_index])); \n        if(_rate < 1e9) { \n            amount = amount.mul(_rate).div(1e9); \n        } \n \n        uint256 balance = IERC20Upgradeable(token).balanceOf(_this); \n        if(balance < amount) { \n            address swapToken = _index == 0 ? pool.collateralToken[1] : pool.collateralToken[0]; \n            swap = swapToken == pool.collateralToken[1]; \n            swapAmount = swapPoolImpl.getAmountOut(swapToken, token, amount.sub(balance)); \n            swapAmount = TenMath.min(swapAmount, IERC20Upgradeable(swapToken).balanceOf(_this)); \nStrategyV2Pair.sol\n        } \n    } \n \n    function getBorrowAmount(uint256 _pid, address _account, uint _index) \n        public view returns (address token, uint256 amount) { \n        address borrowFrom = userInfo2[_pid][_account].borrowFrom[_index]; \n        if(borrowFrom == address(0)) return (borrowFrom, 0); \n \n        uint256 bid = userInfo2[_pid][_account].bids[_index]; \n        token = ISafeBox(borrowFrom).token(); \n        amount = ISafeBox(borrowFrom).pendingBorrowAmount(bid); \n        amount = amount.add(ISafeBox(borrowFrom).pendingBorrowRewards(bid)); \n    } \n \n    function getBorrowAmountInBaseToken(uint256 _pid, address _account) \n        external view returns (uint256 amount) { \n        UserInfo storage user = userInfo2[_pid][_account]; \n        for(uint256 i = 0; i < user.borrowFrom.length; i ++) { \n            (address token, uint256 value) = getBorrowAmount(_pid, _account, i); \n            if(value == 0) continue ; \n            amount = amount.add(swapPoolImpl.getAmountIn(token, value, poolInfo[_pid].baseToken)); \n        } \n    } \n \n    function getLPTokenAmountInBaseToken(uint256 _pid, uint256 _lpTokenAmount, address _baseToken) \n        public view returns (uint256 amount) { \n        checkOraclePrice(_pid, false); \n        amount = swapPoolImpl.getLPTokenAmountInBaseToken(poolInfo[_pid].lpToken, _lpTokenAmount, _ba\n    } \n}\n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using AddressUpgradeable for address; \n \n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n// solhint-disable-next-line compiler-version \n",
            "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface ISafeBox { \n \n    function bank() external view returns(address); \n \n    function token() external view returns(address); \n \n    function getSource() external view returns (string memory); \n \n    function supplyRatePerBlock() external view returns (uint256); \n    function borrowRatePerBlock() external view returns (uint256); \n \n    function getBorrowInfo(uint256 _bid) external view \n            returns (address owner, uint256 amount, address strategy, uint256 pid); \n    function getBorrowId(address _strategy, uint256 _pid, address _account) external view returns (ui\n    function getBorrowId(address _strategy, uint256 _pid, address _account, bool _add) external retur\n    function getDepositTotal() external view returns (uint256); \n    function getBorrowTotal() external view returns (uint256); \n    // function getBorrowAmount(address _account) external view returns (uint256 value); \n    function getBaseTokenPerLPToken() external view returns (uint256); \n \n    function deposit(uint256 _value) external; \n    function withdraw(uint256 _value) external; \n \n    function emergencyWithdraw() external; \n    function emergencyRepay(uint256 _bid) external; \n \n    function borrowInfoLength() external view returns (uint256); \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external; \n    function repay(uint256 _bid, uint256 _value) external; \n    function claim(uint256 _tTokenAmount) external; \n \n    function update() external; \n    function mintDonate(uint256 _value) external; \n \n    function pendingSupplyAmount(address _account) external view returns (uint256 value); \n    function pendingBorrowAmount(uint256 _bid) external view returns (uint256 value); \n    function pendingBorrowRewards(uint256 _bid) external view returns (uint256 value); \n} \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n    function getPoolInfo(uint256 _pid) external view \n        returns (address callFrom, uint256 callId, address rewardToken); \n    function mintRewards(uint256 _callId) external; \n    function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n    function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n    function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n    function onAcionClaim(uint256 _callId, address _account) external; \n    function onAcionEmergency(uint256 _callId, address _account) external; \n    function onAcionUpdate(uint256 _callId) external; \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface ICompActionTrigger { \n    function getCATPoolInfo(uint256 _pid) external view \n        returns (address lpToken, uint256 allocRate, uint256 totalPoints, uint256 totalAmount); \n    function getCATUserAmount(uint256 _pid, address _account) external view \n        returns (uint256 points); \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface ITenBankHall { \n    function makeBorrowFrom(uint256 _pid, address _account, address _debtFrom, uint256 _value) extern\n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IStrategyLink { \n \n    event StrategyDeposit(address indexed strategy, uint256 indexed pid, address indexed user, uint25\n    event StrategyBorrow(address indexed strategy, uint256 indexed pid, address indexed user, uint256 \n    event StrategyWithdraw(address indexed strategy, uint256 indexed pid, address indexed user, uint2\n    event StrategyLiquidation(address indexed strategy, uint256 indexed pid, address indexed user, ui\n \n    function bank() external view returns(address); \n    function getSource() external view returns (string memory); \n    function userInfo(uint256 _pid, address _account) external view returns (uint256,uint256,address,\n    function getPoolInfo(uint256 _pid) external view  returns(address[] memory collateralToken, addre\n    function getBorrowInfo(uint256 _pid, address _account) external view returns (address borrowFrom, \n    function getBorrowAmount(uint256 _pid, address _account) external view returns (uint256 value); \n    function getBorrowAmountInBaseToken(uint256 _pid, address _account) external view returns (uint25\n    function getDepositAmount(uint256 _pid, address _account) external view returns (uint256 amount);\n \n    function getPoolCollateralToken(uint256 _pid) external view returns (address[] memory collateralT\n    function getPoollpToken(uint256 _pid) external view returns (address lpToken); \n    function getBaseToken(uint256 _pid) external view returns (address baseToken); \n \n    function poolLength() external view returns (uint256); \n \n    function pendingRewards(uint256 _pid, address _account) external view returns (uint256 value); \n    function pendingLPAmount(uint256 _pid, address _account) external view returns (uint256 value); \n \n    // function massUpdatePools(uint256 _start, uint256 _end) external; \n    function updatePool(uint256 _pid, uint256 _desirePrice, uint256 _slippage) external; \n \n    function deposit(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint256 _de\n    function depositLPToken(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint\n \n    function withdraw(uint256 _pid, address _account, uint256 _rate, address _toToken, uint256 _desir\n    function withdrawLPToken(uint256 _pid, address _account, uint256 _rate, uint256 _desirePrice, uin\n \n    function emergencyWithdraw(uint256 _pid, address _account, uint256 _desirePrice, uint256 _slippag\n \n    function liquidation(uint256 _pid, address _account, address _hunter, uint256 _maxDebt) external;\n    function repayBorrow(uint256 _pid, address _account, uint256 _rate, bool _force) external; \n} \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IStrategyV2Pair is IStrategyLink { \n \n    event AddPool(uint256 _pid, uint256 _poolId, address lpToken, address _baseToken); \n    event SetMiniRewardAmount(uint256 _pid, uint256 _miniRewardAmount); \n    event SetPoolImpl(address _oldv, address _new); \n    event SetComponents(address _compActionPool, address _buyback, address _priceChecker, address _co\n    event SetPoolConfig(uint256 _pid, string _key, uint256 _value); \n \n    event StrategyBorrow2(address indexed strategy, uint256 indexed pid, address user, address indexe\n    event StrategyRepayBorrow2(address indexed strategy, uint256 indexed pid, address user, address i\n    event StrategyLiquidation2(address indexed strategy, uint256 indexed pid, address user, uint256 l\n \n    function getBorrowInfo(uint256 _pid, address _account, uint256 _bindex) \n        external view returns (address borrowFrom, uint256 bid, uint256 amount); \n} \n",
            "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n  using SafeMathUpgradeable for uint256; \n \n  function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n    vr = v1 > v2 ? v2 : v1; \n  } \n \n  function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n    vr = v1 > v2 ? v1.sub(v2) : 0; \n  } \n \n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/\n  function sqrt(uint256 x) internal pure returns (uint256) { \n    if (x == 0) return 0; \n    uint256 xx = x; \n    uint256 r = 1; \n \n    if (xx >= 0x100000000000000000000000000000000) { \n      xx >>= 128; \n      r <<= 64; \n    } \n \n    if (xx >= 0x10000000000000000) { \n      xx >>= 64; \n      r <<= 32; \n    } \n    if (xx >= 0x100000000) { \n      xx >>= 32; \n      r <<= 16; \n    } \n    if (xx >= 0x10000) { \n      xx >>= 16; \n      r <<= 8; \n    } \n    if (xx >= 0x100) { \n      xx >>= 8; \n      r <<= 4; \n    } \n    if (xx >= 0x10) { \n      xx >>= 4; \n      r <<= 2; \n    } \n    if (xx >= 0x8) { \n      r <<= 1; \n    } \n \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; // Seven iterations should be enough \n    uint256 r1 = x / r; \n    return (r < r1 ? r : r1); \n  } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface IPriceChecker { \n    function getPriceSlippage(address _lptoken) external view returns (uint256); \n    function checkLPTokenPriceLimit(address _lptoken, bool _largeType) external view returns (bool); \n} \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IStrategyConfig { \n    // event \n    event SetFeeGather(address _feeGatherOld, address _feeGather); \n    event SetReservedGather(address _old, address _new); \n    event SetBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor); \n    event SetLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor); \n    event SetFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor); \n    event SetDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee); \n    event SetWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee); \n    event SetRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee); \n    event SetClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee); \n    event SetLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee); \n \n    // factor \n    function getBorrowFactor(address _strategy, uint256 _poolid) external view returns (uint256); \n    function setBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor) external; \n \n    function getLiquidationFactor(address _strategy, uint256 _poolid) external view returns (uint256)\n    function setLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor) ext\n \n    function getFarmPoolFactor(address _strategy, uint256 _poolid) external view returns (uint256 val\n    function setFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor) external;\n \n    // fee manager \n    function getDepositFee(address _strategy, uint256 _poolid) external view returns (address, uint25\n    function setDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee) external; \n \n    function getWithdrawFee(address _strategy, uint256 _poolid) external view returns (address, uint2\n    function setWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee) external; \n \n    function getRefundFee(address _strategy, uint256 _poolid) external view returns (address, uint256\n    function setRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee) external; \n \n    function getClaimFee(address _strategy, uint256 _poolid) external view returns (address, uint256)\n    function setClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee) external; \n \n    function getLiquidationFee(address _strategy, uint256 _poolid) external view returns (address, ui\n    function setLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee) external;\n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IStrategyV2SwapPool { \n \n    function setStrategy(address _strategy) external; \n \n    // get strategy \n    function getName() external view returns (string memory); \n \n    // swap functions \n    function getPair(address _t0, address _t1) external view returns (address pairs); \n    function getReserves(address _lpToken) external view returns (uint256 a, uint256 b); \n    function getToken01(address _pairs) external view returns (address token0, address token1); \n    function getAmountOut(address _tokenIn, address _tokenOut, uint256 _amountOut) external view retu\n    function getAmountIn(address _tokenIn, uint256 _amountIn, address _tokenOut) external view return\n    function getLPTokenAmountInBaseToken(address _lpToken, uint256 _lpTokenAmount, address _baseToken\n    function swapTokenTo(address _tokenIn, uint256 _amountIn, address _tokenOut, address _toAddress) \n \n    function optimalBorrowAmount(address _lpToken, uint256 _amount0, uint256 _amount1) external view \n    function optimalDepositAmount(address lpToken, uint amtA, uint amtB) external view returns (uint \n \n    // pool functions \n    function getDepositToken(uint256 _poolId) external view returns (address lpToken); \n    function getRewardToken(uint256 _poolId) external view returns (address rewardToken); \n    function getPending(uint256 _poolId) external view returns (uint256 rewards); \n    function deposit(uint256 _poolId, bool _autoPool) external returns (uint256 liquidity); \n    function withdraw(uint256 _poolId, uint256 _liquidity, bool _autoPool) external returns (uint256 \n    function claim(uint256 _poolId) external returns (uint256 rewards); \n    function extraRewards() external returns (address token, uint256 rewards); \n} \n \n",
            "pragma solidity 0.6.12; \n \n \n \ncontract StrategyV2Data { \n \n    // Info of each user. \n    struct UserInfo { \n        uint256 lpAmount;       // deposit lptoken amount \n        uint256 lpPoints;       // deposit proportion \n        address[] borrowFrom;   // borrowFrom \n        uint256[] bids; \n    } \n \n    // Info of each pool. \n    struct PoolInfo { \n        address[] collateralToken;      // collateral Token list, last must be baseToken \n        address baseToken;              // baseToken can be borrowed \n        address lpToken;                // lptoken to deposit \n        uint256 poolId;                 // poolid for mdex pools \n        uint256 lastRewardsBlock;       // \n        uint256 totalPoints;            // total of user lpPoints \n        uint256 totalLPAmount;          // total of user lpAmount \n        uint256 totalLPReinvest;        // total of lptoken amount with totalLPAmount and reinvest re\n        uint256 miniRewardAmount;       // \n    } \n \n    // Info of each pool. \n    PoolInfo[] public poolInfo; \n    // Info of each user that stakes LP tokens. \n    mapping (uint256 => mapping (address => UserInfo)) public userInfo2; \n \n    address public _bank;                // address of bank \n    address public _this; \n    address public helperImpl; \n \n    IStrategyConfig public sconfig; \n    mapping (uint256 => mapping (string => uint256)) public poolConfig; \n \n    IStrategyV2SwapPool public swapPoolImpl; \n \n    address public devAddr; \n    IPriceChecker public priceChecker; \n    IActionPools public compActionPool;     // address of comp action pool \n \n    mapping(address=>bool) public whitelist; \n    uint256[39] private __gap; \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \n \n \n// farm strategy \ncontract StrategyV2Pair is StrategyV2Data, OwnableUpgradeable, IStrategyV2Pair, ICompActionTrigger { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    function initialize(address bank_, address _swapPoolImpl, address _helperImpl, address _compActio\n            address _config, address _priceChecker, address _devAddr) public initializer { \n        __Ownable_init(); \n \n        _bank = bank_; \n        _this = address(this); \n        swapPoolImpl = IStrategyV2SwapPool(_swapPoolImpl); \n        swapPoolImpl.setStrategy(address(this)); \n \n        helperImpl = _helperImpl; \n \n        compActionPool = IActionPools(_compActionPool); \n        devAddr = _devAddr; \n        priceChecker = IPriceChecker(_priceChecker); \n        sconfig = IStrategyConfig(_config); \n    } \n \n    modifier onlyBank() { \n        require(_bank == msg.sender, 'strategy only call by bank'); \n        _; \n    } \n \n    function bank() external override view returns(address) { \n        return _bank; \n    } \n \n    function getSource() external override view returns (string memory source) { \n        source = string(abi.encodePacked(swapPoolImpl.getName(), \"_v2\")); \n    } \n \n    function utils() external view returns(address) { \n        // Compatible with old version 1 \n        return address(0); \n    } \n \n    function setWhitelist(address _contract, bool _enable) external onlyOwner { \n        whitelist[_contract] = _enable; \n    } \n \n    function setPoolConfig(uint256 _pid, string memory _key, uint256 _value) \n        external onlyOwner { \n        poolConfig[_pid][_key] = _value; \n        emit SetPoolConfig(_pid, _key, _value); \n    } \n \n    function setDevAddr(address _devAddr) public { \n        require(devAddr == msg.sender, 'wu?'); \n        devAddr = _devAddr; \n    } \n \n    function poolLength() external override view returns (uint256) { \n        return poolInfo.length; \n    } \n \n    // for action pool, farming rewards \n    function getCATPoolInfo(uint256 _pid) external override view \n        returns (address lpToken, uint256 allocRate, uint256 totalPoints, uint256 totalAmount) { \n        lpToken = address(poolInfo[_pid].lpToken); \n        allocRate = 5e8; \n        totalPoints = poolInfo[_pid].totalPoints; \n        totalAmount = poolInfo[_pid].totalLPReinvest; \n    } \n \n    function getCATUserAmount(uint256 _pid, address _account) external override view \n        returns (uint256 lpPoints) { \n        lpPoints = userInfo2[_pid][_account].lpPoints; \n    } \n \n    function getPoolInfo(uint256 _pid) external override view \n        returns(address[] memory collateralToken, address baseToken, address lpToken, \n            uint256 poolId, uint256 totalLPAmount, uint256 totalLPReinvest) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        collateralToken = pool.collateralToken; \n        baseToken = address(pool.baseToken); \n        lpToken = address(pool.lpToken); \n        poolId = pool.poolId; \n        totalLPAmount = pool.totalLPAmount; \n        totalLPReinvest = pool.totalLPReinvest; \n    } \n \n    function userInfo(uint256 _pid, address _account) \n        external override view returns (uint256 lpAmount, uint256 lpPoints, address borrowFrom, uint2\n        // Compatible with old version 1 \n        UserInfo storage user = userInfo2[_pid][_account]; \n        lpAmount = user.lpAmount; \n        lpPoints = user.lpPoints; \n        borrowFrom; \n        bid; \n    } \n \n    function getBorrowInfo(uint256 _pid, address _account) \n        external override view returns (address borrowFrom, uint256 bid) { \n        (borrowFrom, bid, ) = getBorrowInfo(_pid, _account, 0); \n        if(borrowFrom == address(0)) { \n            (borrowFrom, bid, ) = getBorrowInfo(_pid, _account, 1); \n        } \n    } \n \n    function getBorrowInfo(uint256 _pid, address _account, uint256 _bindex) \n        public override view returns (address borrowFrom, uint256 bid, uint256 amount) { \n        UserInfo storage user = userInfo2[_pid][_account]; \n        if(_bindex >= user.borrowFrom.length) return (address(0), 0, 0); \n        borrowFrom = user.borrowFrom[_bindex]; \n        bid = user.bids[_bindex]; \n        if(borrowFrom == address(0)) return (address(0), 0, 0); \n        amount = ISafeBox(borrowFrom).pendingBorrowAmount(bid); \n        amount = amount.add(ISafeBox(borrowFrom).pendingBorrowRewards(bid)); \n    } \n \n    function pendingLPAmount(uint256 _pid, address _account) public override view returns (uint256 va\n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo2[_pid][_account]; \n        if(pool.totalPoints <= 0) return 0; \n \n        value = user.lpPoints.mul(pool.totalLPReinvest).div(pool.totalPoints); \n        value = TenMath.min(value, pool.totalLPReinvest); \n    } \n \n    function getDepositAmount(uint256 _pid, address _account) external override view returns (uint256 \n        PoolInfo storage pool = poolInfo[_pid]; \n        uint256 lpTokenAmount = pendingLPAmount(_pid, _account); \n        amount = swapPoolImpl.getLPTokenAmountInBaseToken(pool.lpToken, lpTokenAmount, pool.baseToken\n    } \n \n    function getPoolCollateralToken(uint256 _pid) external override view returns (address[] memory co\n        collateralToken = poolInfo[_pid].collateralToken; \n    } \n \n    function getPoollpToken(uint256 _pid) external override view returns (address lpToken) { \n        lpToken = poolInfo[_pid].lpToken; \n    } \n \n    function getBaseToken(uint256 _pid) external override view returns (address baseToken) { \n        baseToken = poolInfo[_pid].baseToken; \n    } \n \n    // query user rewards \n    function pendingRewards(uint256 _pid, address _account) public override view returns (uint256 val\n        UserInfo storage user = userInfo2[_pid][_account]; \n        value = pendingLPAmount(_pid, _account); \n        value = TenMath.safeSub(value, user.lpAmount); \n    } \n \n    // Add a new lp to the pool. Can only be called by the owner. \n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do. \n    function addPool(uint256 _poolId, address[] memory _collateralToken, address _baseToken) \n        external onlyOwner { \n \n        require(_collateralToken.length == 2); \n        address lpTokenInPools = swapPoolImpl.getPair(_collateralToken[0], _collateralToken[1]); \n        poolInfo.push(PoolInfo({ \n            collateralToken: _collateralToken, \n            baseToken: _baseToken, \n            lpToken: lpTokenInPools, \n            poolId: _poolId, \n            lastRewardsBlock: block.number, \n            totalPoints: 0, \n            totalLPAmount: 0, \n            totalLPReinvest: 0, \n            miniRewardAmount: 1e4 \n        })); \n \n        uint256 pid = poolInfo.length.sub(1); \n        checkAddPoolLimit(pid); \n \n        emit AddPool(pid, _poolId, lpTokenInPools, _baseToken); \n    } \n \n    function checkAddPoolLimit(uint256 _pid) public view { \n        delegateToViewImplementation( \n            abi.encodeWithSignature(\"checkAddPoolLimit(uint256)\", _pid)); \n    } \n \n    function checkDepositLimit(uint256 _pid, address _account, uint256 _orginSwapRate) public view { \n        delegateToViewImplementation( \n            abi.encodeWithSignature(\"checkDepositLimit(uint256,address,uint256)\", _pid, _account, _or\n    } \n \n    function checkLiquidationLimit(uint256 _pid, address _account, bool liqucheck) public view { \n        delegateToViewImplementation( \n            abi.encodeWithSignature(\"checkLiquidationLimit(uint256,address,bool)\", _pid, _account, li\n    } \n \n    function checkOraclePrice(uint256 _pid, bool _large) public view { \n        delegateToViewImplementation( \n            abi.encodeWithSignature(\"checkOraclePrice(uint256,bool)\", _pid, _large)); \n    } \n \n    function checkBorrowLimit(uint256 _pid, address _account) public view { \n        delegateToViewImplementation( \n            abi.encodeWithSignature(\"checkBorrowLimit(uint256,address)\", _pid, _account)); \n    } \n \n    function calcDepositFee(uint256 _pid) \n        public view returns (address feer, uint256 a0, uint256 a1) { \n        bytes memory data = delegateToViewImplementation( \n            abi.encodeWithSignature(\"calcDepositFee(uint256)\", _pid)); \n        return abi.decode(data, (address,uint256,uint256)); \n    } \n \n    function calcBorrowAmount(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount) \n        public view returns (uint256 bindex, uint256 amount) { \n        bytes memory data = delegateToViewImplementation( \n            abi.encodeWithSignature(\"calcBorrowAmount(uint256,address,address,uint256)\", \n                    _pid,_account,_debtFrom,_bAmount)); \n        return abi.decode(data, (uint256,uint256)); \n    } \n \n    function calcRemoveLiquidity(uint256 _pid, address _account, uint256 _rate) \n        public view returns (uint256 removedLPAmount, uint256 removedPoint) { \n        bytes memory data = delegateToViewImplementation( \n            abi.encodeWithSignature(\"calcRemoveLiquidity(uint256,address,uint256)\", \n                    _pid,_account,_rate)); \n        return abi.decode(data, (uint256,uint256)); \n    } \n \n    function calcWithdrawFee(uint256 _pid, address _account, uint256 _rate) \n        public view returns (address gather, uint256 a0, uint256 a1) { \n        bytes memory data = delegateToViewImplementation( \n            abi.encodeWithSignature(\"calcWithdrawFee(uint256,address,uint256)\", \n                    _pid,_account,_rate)); \n        return abi.decode(data, (address,uint256,uint256)); \n    } \n \n    function calcLiquidationFee(uint256 _pid, address _account) \n        public view returns (address gather, uint256 baseAmount) { \n        bytes memory data = delegateToViewImplementation( \n            abi.encodeWithSignature(\"calcLiquidationFee(uint256,address)\", \n                    _pid,_account)); \n        return abi.decode(data, (address,uint256)); \n    } \n \n    function calcRefundFee(uint256 _pid, uint256 _rewardAmount) \n        public view returns (address gather, uint256 baseAmount) { \n        bytes memory data = delegateToViewImplementation( \n            abi.encodeWithSignature(\"calcRefundFee(uint256,uint256)\", \n                    _pid,_rewardAmount)); \n        return abi.decode(data, (address,uint256)); \n    } \n \n    function calcWithdrawRepayBorrow(uint256 _pid, address _account, uint256 _rate, uint256 _index) \n        public view returns (address token, uint256 amount, bool swap, uint256 swapAmount) { \n        bytes memory data = delegateToViewImplementation( \n            abi.encodeWithSignature(\"calcWithdrawRepayBorrow(uint256,address,uint256,uint256)\", \n                    _pid,_account,_rate,_index)); \n        return abi.decode(data, (address,uint256,bool,uint256)); \n    } \n \n    function getBorrowAmount(uint256 _pid, address _account) \n        external override view returns (uint256 value) { \n        // Compatible with old version 1 \n        value = getBorrowAmountInBaseToken(_pid, _account); \n    } \n \n    function getBorrowAmountInBaseToken(uint256 _pid, address _account) \n        public override view returns (uint256 amount) { \n        bytes memory data = delegateToViewImplementation( \n            abi.encodeWithSignature(\"getBorrowAmountInBaseToken(uint256,address)\", \n                    _pid,_account)); \n        return abi.decode(data, (uint256)); \n    } \n \n    // function massUpdatePools(uint256 _start, uint256 _end) external; \n    function updatePool(uint256 _pid, uint256 _unused, uint256 _minOutput) external override { \n        _unused; \n        checkOraclePrice(_pid, true); \n        uint256 lpAmount = _updatePool(_pid); \n        require(lpAmount >= _minOutput, 'insufficient LP output'); \n    } \n \n    function _updatePool(uint256 _pid) internal returns (uint256 lpAmount) { \n        PoolInfo storage pool = poolInfo[_pid]; \n \n        if(address(compActionPool) != address(0)) { \n            compActionPool.onAcionUpdate(_pid); \n        } \n \n        if(pool.lastRewardsBlock == block.number || \n            pool.totalLPReinvest <= 0) { \n            pool.lastRewardsBlock = block.number; \n            return 0; \n        } \n        pool.lastRewardsBlock = block.number; \n \n        address refundToken = swapPoolImpl.getRewardToken(pool.poolId); \n        uint256 newRewards = swapPoolImpl.getPending(pool.poolId); \n \n        if(newRewards < pool.miniRewardAmount) { \n            return 0; \n        } \n \n        newRewards = swapPoolImpl.claim(pool.poolId); \n \n        // gather fee \n        { \n            (address gather, uint256 feeamount) = calcRefundFee(_pid, newRewards); \n            if(feeamount > 0) IERC20Upgradeable(refundToken).safeTransfer(gather, feeamount); \n            newRewards = newRewards.sub(feeamount); \n        } \n \n        // swap to basetoken \n        if(refundToken != pool.collateralToken[0] && refundToken != pool.collateralToken[1]) { \n            IERC20Upgradeable(refundToken).safeTransfer(address(swapPoolImpl), newRewards); \n            newRewards = swapPoolImpl.swapTokenTo(refundToken, newRewards, pool.baseToken, _this); \n            refundToken = pool.baseToken; \n        } \n \n        IERC20Upgradeable(refundToken).safeTransfer(address(swapPoolImpl), newRewards); \n        lpAmount = swapPoolImpl.deposit(pool.poolId, true); \n \n        pool.totalLPReinvest = pool.totalLPReinvest.add(lpAmount); \n    } \n \n    function deposit(uint256 _pid, address _account, address _debtFrom0, \n                uint256 _bAmount0, uint256 _debtFrom1, uint256 _minOutput) \n        external override onlyBank returns (uint256 lpAmount) { \n        lpAmount = _deposit(_pid, _account, _debtFrom0, _bAmount0, address(_debtFrom1), _minOutput); \n    } \n \n    function depositLPToken(uint256 _pid, address _account, address _debtFrom0, \n                uint256 _bAmount0, uint256 _debtFrom1, uint256 _minOutput) \n        external override onlyBank returns (uint256 lpAmount) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        uint256 liquidity = _safeTransferAll(pool.lpToken, address(swapPoolImpl)); \n        swapPoolImpl.withdraw(pool.poolId, liquidity, false); \n        lpAmount = _deposit(_pid, _account, _debtFrom0, _bAmount0, address(_debtFrom1), _minOutput); \n    } \n \n    function _deposit(uint256 _pid, address _account, address _debtFrom0, \n        uint256 _bAmount0, address _debtFrom1, uint256 _minOutput) \n        internal returns (uint256 lpAmount)  { \n \n        require(tx.origin == _account || whitelist[_account], 'not contract'); \n \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo2[_pid][_account]; \n \n        // update rewards \n        _updatePool(_pid); \n \n        address token0 = pool.collateralToken[0]; \n        address token1 = pool.collateralToken[1]; \n        uint256 orginSwapRate = 0; \n        { \n            (uint256 res0, uint256 res1) = swapPoolImpl.getReserves(pool.lpToken); \n            orginSwapRate = res0.mul(1e18).div(res1); \n        } \n \n        // borrow \n        if(user.borrowFrom.length == 0) { \n            user.borrowFrom = new address[](2); \n            user.bids = new uint256[](2); \n        } \n \n        if(_bAmount0 > 0) { \n            checkOraclePrice(_pid, false);  // Only Check the price when there is leverage \n            _makeBorrow(_pid, _account, _debtFrom0, _bAmount0); \n            _makeBorrow(_pid, _account, _debtFrom1, 0); // 0 = auto fit balance \n        } \n \n        // deposit fee \n        { \n            (address gather, uint256 bAmount0, uint256 bAmount1) = calcDepositFee(_pid); \n            if(bAmount0 > 0) IERC20Upgradeable(token0).safeTransfer(gather, bAmount0); \n            if(bAmount1 > 0) IERC20Upgradeable(token1).safeTransfer(gather, bAmount1); \n        } \n \n        // add liquidity and deposit \n        _safeTransferAll(token0, address(swapPoolImpl)); \n        _safeTransferAll(token1, address(swapPoolImpl)); \n        lpAmount = swapPoolImpl.deposit(pool.poolId, true); \n \n        // return cash \n        _safeTransferAll(token0, _account); \n        _safeTransferAll(token1, _account); \n \n        // // booking \n        uint256 lpPointsOld = user.lpPoints; \n        uint256 addPoint = lpAmount; \n        if(pool.totalLPReinvest > 0) { \n            addPoint = lpAmount.mul(pool.totalPoints).div(pool.totalLPReinvest); \n        } \n \n        user.lpPoints = user.lpPoints.add(addPoint); \n        pool.totalPoints = pool.totalPoints.add(addPoint); \n        pool.totalLPReinvest = pool.totalLPReinvest.add(lpAmount); \n \n        user.lpAmount = user.lpAmount.add(lpAmount); \n        pool.totalLPAmount = pool.totalLPAmount.add(lpAmount); \n \n        emit StrategyDeposit(_this, _pid, _account, lpAmount, _bAmount0); \n \n        // check pool deposit limit \n        require(lpAmount >= _minOutput, 'insufficient LP output'); \n        checkDepositLimit(_pid, _account, orginSwapRate); \n        checkLiquidationLimit(_pid, _account, false); \n        if(_bAmount0 > 0) { \n            checkBorrowLimit(_pid, _account); \n            checkOraclePrice(_pid, false); \n        } \n \n        if(address(compActionPool) != address(0) && addPoint > 0) { \n            compActionPool.onAcionIn(_pid, _account, lpPointsOld, user.lpPoints); \n        } \n    } \n \n    function withdraw(uint256 _pid, address _account, uint256 _rate, address _toToken, uint256 _minOu\n        external override onlyBank { \n        _withdraw(_pid, _account, _rate); \n \n        // PoolInfo storage pool = poolInfo[_pid]; \n        uint256 outValue; \n        (address token0, address token1) = (poolInfo[_pid].collateralToken[0], poolInfo[_pid].collate\n        if(_toToken == address(0)) { \n            uint256 outValue0 = _safeTransferAll(token0, _account); \n            require(outValue0 >= _minOutputToken0, 'insufficient Token output first'); \n            outValue = _safeTransferAll(token1, _account); \n        } else if(token0 == _toToken) { \n            _swapTokenAllTo(token1, _toToken); \n            outValue = _safeTransferAll(_toToken, _account); \n        } else if(token1 == _toToken) { \n            _swapTokenAllTo(token0, _toToken); \n            outValue = _safeTransferAll(_toToken, _account); \n        } else { \n            require(false, 'toToken unknown'); \n        } \n        require(outValue >= _minOutput, 'insufficient Token output'); \n    } \n \n    function withdrawLPToken(uint256 _pid, address _account, uint256 _rate, uint256 _unused, uint256 _\n        external override onlyBank { \n        _withdraw(_pid, _account, _rate); \n \n        PoolInfo storage pool = poolInfo[_pid]; \n        _safeTransferAll(pool.collateralToken[0], address(swapPoolImpl)); \n        _safeTransferAll(pool.collateralToken[1], address(swapPoolImpl)); \n        swapPoolImpl.deposit(pool.poolId, false); \n        uint256 lpAmount = _safeTransferAll(pool.lpToken, _account); \n        require(lpAmount >= _minOutput, 'insufficient LPToken output'); \n    } \n \n    function _withdraw(uint256 _pid, address _account, uint256 _rate) internal { \n \n        require(tx.origin == _account || whitelist[_account], 'not contract'); \n \n        checkLiquidationLimit(_pid, _account, false); \n \n        // update rewards \n        _updatePool(_pid); \n \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo2[_pid][_account]; \n \n        bool bBorrow = (user.borrowFrom[0] != address(0) || user.borrowFrom[1] != address(0)); \n        if(bBorrow) checkOraclePrice(_pid, false); \n \n        address token0 = pool.collateralToken[0]; \n        address token1 = pool.collateralToken[1]; \n \n        // withdraw and remove liquidity \n        (uint256 removedLPAmount, uint256 removedPoint) = calcRemoveLiquidity(_pid, _account, _rate);\n \n        if(removedLPAmount > 0) swapPoolImpl.withdraw(pool.poolId, removedLPAmount, true); \n \n        { \n            (address gather, uint256 feeAmount0, uint256 feeAmount1) = calcWithdrawFee(_pid, _account\n            if(feeAmount0 > 0) IERC20Upgradeable(token0).safeTransfer(gather, feeAmount0); \n            if(feeAmount1 > 0) IERC20Upgradeable(token1).safeTransfer(gather, feeAmount1); \n        } \n \n        repayBorrow(_pid, _account, _rate, true); \n \n        uint256 withdrawLPTokenAmount = removedPoint.mul(pool.totalLPReinvest).div(pool.totalPoints);\n        withdrawLPTokenAmount = TenMath.min(withdrawLPTokenAmount, pool.totalLPReinvest); \n \n        // booking \n        uint256 lpPointsOld = user.lpPoints; \n        user.lpPoints = TenMath.safeSub(user.lpPoints, removedPoint); \n        pool.totalPoints = TenMath.safeSub(pool.totalPoints, removedPoint); \n        pool.totalLPReinvest = TenMath.safeSub(pool.totalLPReinvest, withdrawLPTokenAmount); \n \n        user.lpAmount = TenMath.safeSub(user.lpAmount, removedLPAmount); \n        pool.totalLPAmount = TenMath.safeSub(pool.totalLPAmount, removedLPAmount); \n \n        if(bBorrow) checkOraclePrice(_pid, false); \n \n        emit StrategyWithdraw(_this, _pid, _account, withdrawLPTokenAmount); \n \n        if(address(compActionPool) != address(0) && removedPoint > 0) { \n            compActionPool.onAcionOut(_pid, _account, lpPointsOld, user.lpPoints); \n        } \n    } \n \n    function _makeBorrow(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount) \n        internal { \n        (uint256 bindex, uint256 amount) = calcBorrowAmount(_pid, _account, _debtFrom, _bAmount); \n \n        if(amount > 0) { \n            UserInfo storage user = userInfo2[_pid][_account]; \n            require(user.borrowFrom[bindex] == address(0) || user.borrowFrom[bindex] == _debtFrom, 'b\n            uint256 newbid = ITenBankHall(_bank).makeBorrowFrom(_pid, _account, _debtFrom, amount); \n            require(newbid != 0, 'borrow new id'); \n            if(user.borrowFrom[bindex] == _debtFrom) { \n                require(user.bids[bindex] == newbid, 'borrow newbid error'); \n            } else { \n                require(user.borrowFrom[bindex] == address(0) && user.bids[bindex] == 0, 'borrow cann\n                user.borrowFrom[bindex] = _debtFrom; \n                user.bids[bindex] = newbid; \n            } \n            emit StrategyBorrow2(_this, _pid, _account, _debtFrom, amount); \n        } \n    } \n \n    function repayBorrow(uint256 _pid, address _account, uint256 _rate, bool _force) public override \n        UserInfo storage user = userInfo2[_pid][_account]; \n        if(user.borrowFrom[0] != address(0) || user.borrowFrom[1] != address(0)) { \n            // _force as true, must repay all lending \n            checkOraclePrice(_pid, _force ? false : true); \n        } \n        _repayBorrow(_pid, _account, _rate, 0, _force); \n        _repayBorrow(_pid, _account, _rate, 1, _force); \n    } \n \n    function _repayBorrow(uint256 _pid, address _account, uint256 _rate, uint256 _index, bool _force) \n        UserInfo storage user = userInfo2[_pid][_account]; \n        PoolInfo storage pool = poolInfo[_pid]; \n \n        address borrowFrom = user.borrowFrom[_index]; \n        uint256 bid = user.bids[_index]; \n \n        if(borrowFrom != address(0)) { \n            ISafeBox(borrowFrom).update(); \n        } \n \n        (address btoken, uint256 bAmount, bool swap, uint256 swapAmount) = \n                calcWithdrawRepayBorrow(_pid, _account, _rate, _index); \n \n        if(swapAmount > 0) { \n            (address fromToken, address toToken) = swap ? \n                (pool.collateralToken[1], pool.collateralToken[0]) : \n                (pool.collateralToken[0], pool.collateralToken[1]); \n            IERC20Upgradeable(fromToken).safeTransfer(address(swapPoolImpl), swapAmount); \n            swapPoolImpl.swapTokenTo(fromToken, swapAmount, toToken, _this); \n        } \n \n        if(bAmount > 0){ \n            bAmount = TenMath.min(bAmount, IERC20Upgradeable(btoken).balanceOf(_this)); \n            IERC20Upgradeable(btoken).safeTransfer(borrowFrom, bAmount); \n            ISafeBox(borrowFrom).repay(user.bids[_index], bAmount); \n            emit StrategyRepayBorrow2(_this, _pid, _account, borrowFrom, bAmount); \n        } \n \n        if(_rate == 1e9 && borrowFrom != address(0)) { \n            uint256 value = ISafeBox(borrowFrom).pendingBorrowAmount(bid); \n            value = value.add(ISafeBox(borrowFrom).pendingBorrowRewards(bid)); \n \n            if(_force) require(value == 0, 'repayBorrow not clear'); \n \n            if(value == 0) { \n                user.borrowFrom[_index] = address(0); \n                user.bids[_index] = 0; \n            } \n        } \n    } \n \n    function emergencyWithdraw(uint256 _pid, address _account, uint256 _minOutput0, uint256 _minOutpu\n        external override onlyBank { \n \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo2[_pid][_account]; \n \n        bool bBorrow = (user.borrowFrom[0] != address(0) || user.borrowFrom[1] != address(0)); \n        if(bBorrow) checkOraclePrice(_pid, true); \n \n        // total of deposit and reinvest \n        uint256 withdrawLPTokenAmount = pendingLPAmount(_pid, _account); \n \n        // booking \n        poolInfo[_pid].totalLPReinvest = TenMath.safeSub(poolInfo[_pid].totalLPReinvest, withdrawLPTo\n        poolInfo[_pid].totalPoints = TenMath.safeSub(poolInfo[_pid].totalPoints, user.lpPoints); \n        poolInfo[_pid].totalLPAmount = TenMath.safeSub(poolInfo[_pid].totalLPAmount, user.lpAmount); \n \n        user.lpPoints = 0; \n        user.lpAmount = 0; \n \n        address token0 = pool.collateralToken[0]; \n        address token1 = pool.collateralToken[1]; \n \n        swapPoolImpl.withdraw(pool.poolId, withdrawLPTokenAmount, true); \n \n        repayBorrow(_pid, _account, 1e9, true); \n \n        if(bBorrow) checkOraclePrice(_pid, true); \n \n        require(_safeTransferAll(token0, _account) >= _minOutput0, 'insufficient output 0'); \n        require(_safeTransferAll(token1, _account) >= _minOutput1, 'insufficient output 1'); \n    } \n \n    function liquidation(uint256 _pid, address _account, address _hunter, uint256 _maxDebt) \n        external override onlyBank { \n \n        // _maxDebt; \n \n        UserInfo storage user = userInfo2[_pid][_account]; \n        PoolInfo storage pool = poolInfo[_pid]; \n \n        // update rewards \n        _updatePool(_pid); \n \n        // check liquidation limit \n        checkLiquidationLimit(_pid, _account, true); \n        checkOraclePrice(_pid, true); \n \n        uint256 lpPointsOld = user.lpPoints; \n        uint256 withdrawLPTokenAmount = pendingLPAmount(_pid, _account); \n        // booking \n        pool.totalLPAmount = TenMath.safeSub(pool.totalLPAmount, user.lpAmount); \n        pool.totalLPReinvest = TenMath.safeSub(pool.totalLPReinvest, withdrawLPTokenAmount); \n        pool.totalPoints = TenMath.safeSub(pool.totalPoints, user.lpPoints); \n \n        user.lpPoints = 0; \n        user.lpAmount = 0; \n \n        if(withdrawLPTokenAmount > 0) { \n            swapPoolImpl.withdraw(pool.poolId, withdrawLPTokenAmount, true); \n        } \n \n        // repay borrow \n        repayBorrow(_pid, _account, 1e9, false); \n \n        // swap all token to basetoken \n        { \n            address tokensell = pool.baseToken == pool.collateralToken[0] ? \n                                pool.collateralToken[1] : pool.collateralToken[0]; \n            _swapTokenAllTo(tokensell, pool.baseToken); \n        } \n \n        // liquidation fee \n        { \n            (address gather, uint256 feeAmount) = calcLiquidationFee(_pid, _account); \n            if(feeAmount > 0) IERC20Upgradeable(pool.baseToken).safeTransfer(gather, feeAmount); \n        } \n \n        checkOraclePrice(_pid, true); \n \n        // send rewards to hunter \n        uint256 hunterAmount = _safeTransferAll(pool.baseToken, _hunter); \n \n        emit StrategyLiquidation2(_this, _pid, _account, withdrawLPTokenAmount, hunterAmount); \n \n        if(address(compActionPool) != address(0) && lpPointsOld > 0) { \n            compActionPool.onAcionOut(_pid, _account, lpPointsOld, 0); \n        } \nActionCompPools.sol\n    } \n \n    function makeExtraRewards() external { \n        if(address(devAddr) == address(0)) { \n            return ; \n        } \n        (address rewardsToken, uint256 value) = swapPoolImpl.extraRewards(); \n        if(rewardsToken == address(0) || value == 0) { \n            return ; \n        } \n        IERC20Upgradeable(rewardsToken).safeTransfer(devAddr, value); \n    } \n \n    function _safeTransferAll(address _token, address _to) \n        internal returns (uint256 value){ \n        value = IERC20Upgradeable(_token).balanceOf(_this); \n        if(value > 0) { \n            IERC20Upgradeable(_token).safeTransfer(_to, value); \n        } \n    } \n \n    function _swapTokenAllTo(address _token, address _toToken) \n        internal returns (uint256 value){ \n        uint256 amount = _safeTransferAll(_token, address(swapPoolImpl)); \n        if(amount > 0) { \n            swapPoolImpl.swapTokenTo(_token, amount, _toToken, _this); \n        } \n    } \n \n    function _delegateTo(address callee, bytes memory data) internal returns (bytes memory) { \n        (bool success, bytes memory returnData) = callee.delegatecall(data); \n        assembly { \n            if eq(success, 0) { \n                revert(add(returnData, 0x20), returndatasize()) \n            } \n        } \n        return returnData; \n    } \n \n    function delegateToImplementation(bytes memory data) public returns (bytes memory) { \n        require(msg.sender == _this, 'only _this'); \n        return _delegateTo(helperImpl, data); \n    } \n \n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) { \n        (bool success, bytes memory returnData) = _this.staticcall(abi.encodeWithSignature(\"delegateT\n        assembly { \n            if eq(success, 0) { \n                revert(add(returnData, 0x20), returndatasize()) \n            } \n        } \n        return abi.decode(returnData, (bytes)); \n    } \n}\n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using AddressUpgradeable for address; \n \n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n// solhint-disable-next-line compiler-version \n",
            "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface ICompActionTrigger { \n    function getCATPoolInfo(uint256 _pid) external view \n        returns (address lpToken, uint256 allocRate, uint256 totalPoints, uint256 totalAmount); \n    function getCATUserAmount(uint256 _pid, address _account) external view \n        returns (uint256 points); \n} \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n    function getPoolInfo(uint256 _pid) external view \n        returns (address callFrom, uint256 callId, address rewardToken); \n    function mintRewards(uint256 _callId) external; \n    function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n    function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n    function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n    function onAcionClaim(uint256 _callId, address _account) external; \n    function onAcionEmergency(uint256 _callId, address _account) external; \n    function onAcionUpdate(uint256 _callId) external; \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IClaimFromBank { \n    function claimFromBank(address _account, uint256[] memory _pidlist) external returns (uint256 val\n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IRewardsToken { \n    function mint(address _account, uint256 _amount) external; \n    function burn(uint256 _amount) external; \n \n    function setMintWhitelist(address _account, bool _enabled) external; \n    function checkWhitelist(address _account) external view returns (bool); \n} \n",
            "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n  using SafeMathUpgradeable for uint256; \n \n  function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n    vr = v1 > v2 ? v2 : v1; \n  } \n \n  function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n    vr = v1 > v2 ? v1.sub(v2) : 0; \n  } \n \n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/\n  function sqrt(uint256 x) internal pure returns (uint256) { \n    if (x == 0) return 0; \n    uint256 xx = x; \n    uint256 r = 1; \n \n    if (xx >= 0x100000000000000000000000000000000) { \n      xx >>= 128; \n      r <<= 64; \n    } \n \n    if (xx >= 0x10000000000000000) { \n      xx >>= 64; \n      r <<= 32; \n    } \n    if (xx >= 0x100000000) { \n      xx >>= 32; \n      r <<= 16; \n    } \n    if (xx >= 0x10000) { \n      xx >>= 16; \n      r <<= 8; \n    } \n    if (xx >= 0x100) { \n      xx >>= 8; \n      r <<= 4; \n    } \n    if (xx >= 0x10) { \n      xx >>= 4; \n      r <<= 2; \n    } \n    if (xx >= 0x8) { \n      r <<= 1; \n    } \n \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; // Seven iterations should be enough \n    uint256 r1 = x / r; \n    return (r < r1 ? r : r1); \n  } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \n \n \n// Note that it's ownable and the owner wields tremendous power. The ownership \n// will be transferred to a governance smart contract once Token is sufficiently \n// distributed and the community can show to govern itself. \n// \n// Have fun reading it. Hopefully it's bug-free. God bless. \ncontract ActionCompPools is OwnableUpgradeable, IActionPools, IClaimFromBank { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    // Info of each user. \n    struct UserInfo { \n        uint256 rewardDebt;     // debt rewards \n        uint256 rewardRemain;   // Remain rewards \n    } \n \n    // Info of each pool. \n    struct PoolInfo { \n        address callFrom;           // Address of trigger contract. \n        uint256 callId;             // id of trigger action id, or maybe its poolid \n        IERC20Upgradeable  rewardToken;        // Address of reward token address. \n        uint256 rewardMaxPerBlock;  // max rewards per block. \n        uint256 lastRewardBlock;    // Last block number that Token distribution occurs. \n        uint256 lastRewardTotal;    // Last total amount that reward Token distribution use for calcu\n        uint256 lastRewardClosed;   // Last amount that reward Token distribution. \n        uint256 poolTotalRewards;   // amount will reward in contract. \n        bool autoUpdate;         // auto updatepool while event \n        bool autoClaim;          // auto claim while event \n    } \n \n    // Info of each pool. \n    PoolInfo[] public poolInfo; \n    // Info of each user that remain and debt. \n    mapping (uint256 => mapping (address => UserInfo)) public userInfo; \n    // index of poollist by contract and contract-call-id \n    mapping (address => mapping(uint256 => uint256[])) public poolIndex; \n    // total amount of each reward token \n    mapping (address => uint256) public tokenTotalRewards; \n    // block hacker to restricted reward \n    mapping (address => uint256) public rewardRestricted; \n    // event notify source, contract in whitlist \n    mapping (address => bool) public eventSources; \n    // mint from foxtoken, when reward token is FOXToken GRAPToken, mint it \n    mapping(address => uint256) public mintTokens; \n    // mint for boodev, while mint bootoken, mint a part for dev \n    address public boodev; \n    // allow bank proxy claim \n    address public bank; \n \n    event ActionDeposit(address indexed user, uint256 indexed pid, uint256 fromAmount, uint256 toAmou\n    event ActionWithdraw(address indexed user, uint256 indexed pid, uint256 fromAmount, uint256 toAmo\n    event ActionClaim(address indexed user, uint256 indexed pid, uint256 amount); \n    // event ActionEmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount); \n \n    event AddPool(uint256 indexed _pid, address _callFrom, uint256 _callId, address _rewardToken, uin\n    event SetRewardMaxPerBlock(uint256 indexed _pid, uint256 _maxPerBlock); \n    event SetRewardRestricted(address _hacker, uint256 _rate); \n \n    function initialize(address _bank, address[] memory _mintTokens, uint256[] memory _mintFee, addre\n        __Ownable_init(); \n        bank = _bank; \n        boodev = _boodev; \n \n        setMintTokens(_mintTokens, _mintFee); \n    } \n \n    // If the user transfers TH to contract, it will revert \n    receive() external payable { \n        revert(); \n    } \n \n    function poolLength() external view returns (uint256) { \n        return poolInfo.length; \n    } \n \n    function getPoolInfo(uint256 _pid) external override view \n        returns (address callFrom, uint256 callId, address rewardToken) { \n        callFrom = poolInfo[_pid].callFrom; \n        callId = poolInfo[_pid].callId; \n        rewardToken = address(poolInfo[_pid].rewardToken); \n    } \n \n    function getPoolIndex(address _callFrom, uint256 _callId) external override view returns (uint256\n        return poolIndex[_callFrom][_callId]; \n    } \n \n    // Add a new lp to the pool. Can only be called by the owner. \n    function add(address _callFrom, uint256 _callId, \n                address _rewardToken, uint256 _maxPerBlock) external onlyOwner { \n \n        (address lpToken,, uint256 totalPoints,) = \n                    ICompActionTrigger(_callFrom).getCATPoolInfo(_callId); \n        require(lpToken != address(0) && totalPoints >= 0, 'pool not right'); \n        poolInfo.push(PoolInfo({ \n            callFrom: _callFrom, \n            callId: _callId, \n            rewardToken: IERC20Upgradeable(_rewardToken), \n            rewardMaxPerBlock: _maxPerBlock, \n            lastRewardBlock: block.number, \n            lastRewardTotal: 0, \n            lastRewardClosed: 0, \n            poolTotalRewards: 0, \n            autoUpdate: true, \n            autoClaim: false \n        })); \n \n        eventSources[_callFrom] = true; \n        poolIndex[_callFrom][_callId].push(poolInfo.length.sub(1)); \n \n        emit AddPool(poolInfo.length.sub(1), _callFrom, _callId, _rewardToken, _maxPerBlock); \n    } \n \n    // Set the number of reward produced by each block \n    function setRewardMaxPerBlock(uint256 _pid, uint256 _maxPerBlock) external onlyOwner { \n        poolInfo[_pid].rewardMaxPerBlock = _maxPerBlock; \n        emit SetRewardMaxPerBlock(_pid, _maxPerBlock); \n    } \n \n    function setMintTokens(address[] memory _mintTokens, uint256[] memory _mintFee) public onlyOwner \n        require(_mintTokens.length == _mintFee.length, 'length error'); \n        for(uint256 i = 0; i < _mintTokens.length; i ++) { \n            require(IERC20Upgradeable(_mintTokens[i]).totalSupply() >= 0, '_mintTokens'); \n            IRewardsToken(_mintTokens[i]).checkWhitelist(address(this)); \n            mintTokens[_mintTokens[i]] = _mintFee[i]; \n            require(_mintFee[i] == 0 || _mintFee[i] >= 1e18); \n        } \n    } \n \n    function setAutoUpdate(uint256 _pid, bool _set) external onlyOwner { \n        poolInfo[_pid].autoUpdate = _set; \n    } \n \n    function setAutoClaim(uint256 _pid, bool _set) external onlyOwner { \n        poolInfo[_pid].autoClaim = _set; \n    } \n \n    function setRewardRestricted(address _hacker, uint256 _rate) external onlyOwner { \n        require(_rate <= 1e9, 'max is 1e9'); \n        rewardRestricted[_hacker] = _rate; \n        emit SetRewardRestricted(_hacker, _rate); \n    } \n \n    function setBooDev(address _boodev) external { \n        require(msg.sender == boodev, 'prev dev only'); \n        boodev = _boodev; \n    } \n \n    // Return reward multiplier over the given _from to _to block. \n    function getBlocksReward(uint256 _pid, uint256 _from, uint256 _to) public view returns (uint256 v\n        require(_from <= _to, 'getBlocksReward error'); \n        PoolInfo storage pool = poolInfo[_pid]; \n        value = pool.rewardMaxPerBlock.mul(_to.sub(_from)); \n        if( mintTokens[address(pool.rewardToken)] > 0) { \n            return value; \n        } \n        if( pool.lastRewardClosed.add(value) > pool.poolTotalRewards) { \n            value = pool.lastRewardClosed < pool.poolTotalRewards ? \n                    pool.poolTotalRewards.sub(pool.lastRewardClosed) : 0; \n        } \n    } \n \n    // View function to see pending Tokens on frontend. \n    function pendingRewards(uint256 _pid, address _account) public view returns (uint256 value) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][_account]; \n        uint256 userPoints = ICompActionTrigger(pool.callFrom).getCATUserAmount(pool.callId, _account\n        (,,uint256 poolTotalPoints,) = ICompActionTrigger(pool.callFrom).getCATPoolInfo(pool.callId);\n        value = pendingRewards(_pid, _account, userPoints, poolTotalPoints); \n    } \n \n    function pendingRewards(uint256 _pid, address _account, uint256 _points, uint256 _totalPoints) \n            public view returns (uint256 value) { \n        UserInfo storage user = userInfo[_pid][_account]; \n        value = totalRewards(_pid, _points, _totalPoints) \n                    .add(user.rewardRemain); \n        value = TenMath.safeSub(value, user.rewardDebt); \n    } \n \n    function totalRewards(uint256 _pid, uint256 _points, uint256 _totalPoints) \n            public view returns (uint256 value) { \n        if(_totalPoints <= 0) { \n            return 0; \n        } \n        PoolInfo storage pool = poolInfo[_pid]; \n        uint256 poolRewardTotal = pool.lastRewardTotal; \n        if (block.number > pool.lastRewardBlock && _totalPoints != 0) { \n            uint256 poolReward = getBlocksReward(_pid, pool.lastRewardBlock, block.number); \n            poolRewardTotal = poolRewardTotal.add(poolReward); \n        } \n        value = _points.mul(poolRewardTotal).div(_totalPoints); \n    } \n \n    // Update reward variables for all pools. Be careful of gas spending! \n    function massUpdatePools(uint256 _start, uint256 _end) public { \n        if(_end <= 0) { \n            _end = poolInfo.length; \n        } \n        for (uint256 pid = _start; pid < _end; ++pid) { \n            updatePool(pid); \n        } \n    } \n \n    // Update reward variables of the given pool to be up-to-date. \n    function updatePool(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        if (block.number <= pool.lastRewardBlock) { \n            return ; \n        } \n \n        (,,uint256 poolTotalAmount,) = ICompActionTrigger(pool.callFrom).getCATPoolInfo(pool.callId);\n        if ( pool.rewardMaxPerBlock <= 0 || \n             poolTotalAmount <= 0) { \n            pool.lastRewardBlock = block.number; \n            return ; \n        } \n \n        uint256 poolReward = getBlocksReward(_pid, pool.lastRewardBlock, block.number); \n        if (poolReward > 0) { \n            address rewardToken = address(pool.rewardToken); \n            if( mintTokens[rewardToken] > 0) { \n                IRewardsToken(rewardToken).mint(address(this), poolReward); \n                if(mintTokens[rewardToken] > 1e18) { \n                    uint256 mintFee = poolReward.mul(mintTokens[rewardToken].sub(1e18)).div(1e18); \n                    IRewardsToken(rewardToken).mint(boodev, mintFee);   // mint for dev \n                } \n                pool.poolTotalRewards = pool.poolTotalRewards.add(poolReward); \n                tokenTotalRewards[rewardToken] = tokenTotalRewards[rewardToken].add(poolReward); \n            } \n            pool.lastRewardClosed = pool.lastRewardClosed.add(poolReward); \n            pool.lastRewardTotal = pool.lastRewardTotal.add(poolReward); \n        } \n        pool.lastRewardBlock = block.number; \n    } \n \n    function onAcionIn(uint256 _callId, address _account, uint256 _fromPoints, uint256 _toPoints) ext\n        if(!eventSources[msg.sender]) { \n            return ; \n        } \n        for(uint256 u = 0; u < poolIndex[msg.sender][_callId].length; u ++) { \n            uint256 pid = poolIndex[msg.sender][_callId][u]; \n            deposit(pid, _account, _fromPoints, _toPoints); \n        } \n    } \n \n    function onAcionOut(uint256 _callId, address _account, uint256 _fromPoints, uint256 _toPoints) ex\n        if(!eventSources[msg.sender]) { \n            return ; \n        } \n        for(uint256 u = 0; u < poolIndex[msg.sender][_callId].length; u ++) { \n            uint256 pid = poolIndex[msg.sender][_callId][u]; \n            withdraw(pid, _account, _fromPoints, _toPoints); \n        } \n    } \n \n    function onAcionClaim(uint256 _callId, address _account) external override  { \n        if(!eventSources[msg.sender]) { \n            return ; \n        } \n        for(uint256 u = 0; u < poolIndex[msg.sender][_callId].length; u ++) { \n            uint256 pid = poolIndex[msg.sender][_callId][u]; \n            if( !poolInfo[pid].autoClaim ) { \n                continue; \n            } \n            _claim(pid, _account); \n        } \n    } \n \n    function onAcionEmergency(uint256 _callId, address _account) external override  { \n        _callId; \n        _account; \n    } \n \n    function onAcionUpdate(uint256 _callId) external override  { \n        if(!eventSources[msg.sender]) { \n            return ; \n        } \n        for(uint256 u = 0; u < poolIndex[msg.sender][_callId].length; u ++) { \n            uint256 pid = poolIndex[msg.sender][_callId][u]; \n            if( !poolInfo[pid].autoUpdate ) { \n                continue; \n            } \n            updatePool(pid); \n        } \n    } \n \n    function mintRewards(uint256 _pid) external override { \n        updatePool(_pid); \n        PoolInfo storage pool = poolInfo[_pid]; \n        address rewardToken = address(pool.rewardToken); \n        if(mintTokens[rewardToken] > 0) { \n            return ; \n        } \n        uint256 balance = pool.rewardToken.balanceOf(address(this)); \n        if ( balance > tokenTotalRewards[rewardToken]) { \n            uint256 mint = balance.sub(tokenTotalRewards[rewardToken]); \n            pool.poolTotalRewards = pool.poolTotalRewards.add(mint); \n            tokenTotalRewards[rewardToken] = balance; \n        } \n    } \n \n    // Deposit points for Token allocation. \n    function deposit(uint256 _pid, address _account, uint256 _fromPoints, uint256 _toPoints) internal\n        // require(_fromPoints <= _toPoints, 'deposit order error'); // for debug \n \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][_account]; \n        (,,uint256 poolTotalPoints,) = ICompActionTrigger(pool.callFrom).getCATPoolInfo(pool.callId);\n        uint256 addPoint = TenMath.safeSub(_toPoints, _fromPoints); \n        uint256 poolTotalPointsOld = TenMath.safeSub(poolTotalPoints, addPoint); \n \n        user.rewardRemain = pendingRewards(_pid, _account, _fromPoints, poolTotalPointsOld); \n \n        uint256 poolDebt = 0; \n        if(poolTotalPointsOld > 0) { \n            poolDebt = TenMath.safeSub(pool.lastRewardTotal.mul(poolTotalPoints).div(poolTotalPointsO\n        } \n \n        user.rewardDebt = 0; \n        pool.lastRewardTotal = pool.lastRewardTotal.add(poolDebt); \n        if (poolTotalPoints > 0) { \n            user.rewardDebt = pool.lastRewardTotal.mul(_toPoints).div(poolTotalPoints); \n        } \n \n        emit ActionDeposit(_account, _pid, _fromPoints, _toPoints); \n    } \n \n    // Withdraw LP tokens from StarPool. \n    function withdraw(uint256 _pid, address _account, uint256 _fromPoints, uint256 _toPoints) interna\n        // require(_fromPoints >= _toPoints, 'deposit order error'); // debug \n \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][_account]; \n        (,,uint256 poolTotalPoints,) = ICompActionTrigger(pool.callFrom).getCATPoolInfo(pool.callId);\n        uint256 removePoint = TenMath.safeSub(_fromPoints, _toPoints); \n        uint256 poolTotalPointsOld = poolTotalPoints.add(removePoint); \n \n        // recorde rewards and recalculate debt \n        user.rewardRemain = pendingRewards(_pid, _account, _fromPoints, poolTotalPointsOld); \n \n        // recalculate lastRewardTotal \n        uint256 poolDebt = TenMath.safeSub(pool.lastRewardTotal, \n                                pool.lastRewardTotal.mul(poolTotalPoints).div(poolTotalPointsOld)); \n        pool.lastRewardTotal = TenMath.safeSub(pool.lastRewardTotal, poolDebt); \n \n        user.rewardDebt = 0; \n        if (poolTotalPoints > 0) { \n            user.rewardDebt = pool.lastRewardTotal.mul(_toPoints).div(poolTotalPoints); \n        } \n \n        emit ActionWithdraw(_account, _pid, _fromPoints, _toPoints); \n    } \n \n    function claimIds(uint256[] memory _pidlist) external returns (uint256 value) { \n        for (uint256 piid = 0; piid < _pidlist.length; ++piid) { \n            value = value.add(claim(_pidlist[piid])); \n        } \n    } \n \n    function claimFromBank(address _account, uint256[] memory _pidlist) external override returns (ui\n        require(bank==msg.sender, 'only call from bank'); \n        for (uint256 piid = 0; piid < _pidlist.length; ++piid) { \n            value = value.add(_claim(_pidlist[piid], _account)); \n        } \n    } \n \n    function claim(uint256 _pid) public returns (uint256 value) { \n        return _claim(_pid, msg.sender); \n    } \n \n    function _claim(uint256 _pid, address _account) internal returns (uint256 value) { \n        updatePool(_pid); \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][_account]; \n        value = pendingRewards(_pid, _account); \n \n        if (value > 0) { \n            // make remain booking to debt and claim out \n            user.rewardRemain = 0; \n            user.rewardDebt = 0; \n            user.rewardDebt = pendingRewards(_pid, _account); \n            // pool.lastRewardTotal; // no changed \n            pool.lastRewardClosed = TenMath.safeSub(pool.lastRewardClosed, value); \n \n            if(rewardRestricted[_account] > 0) { \n                value = TenMath.safeSub(value, value.mul(rewardRestricted[_account]).div(1e9)); \n            } \n            pool.poolTotalRewards = TenMath.safeSub(pool.poolTotalRewards, value); \n            address rewardToken = address(pool.rewardToken); \n            tokenTotalRewards[rewardToken] = TenMath.safeSub(tokenTotalRewards[rewardToken], value); \n \n            value = safeTokenTransfer(pool.rewardToken, _account, value); \n        } \n \n        emit ActionClaim(_account, _pid, value); \n    } \n \n    // Withdraw without caring about rewards. EMERGENCY ONLY. \nTenBankHall.sol\n    function emergencyWithdraw(uint256 _pid, address _account) internal { \n        _pid; \n        _account; \n    } \n \n    // Safe Token transfer function, just in case if rounding error causes pool to not have enough To\n    function safeTokenTransfer(IERC20Upgradeable _token, address _to, uint256 _amount) internal retur\n        uint256 balance = _token.balanceOf(address(this)); \n        value = _amount > balance ? balance : _amount; \n        if ( value > 0 ) { \n            _token.safeTransfer(_to, value); \n            value =  TenMath.safeSub(balance, _token.balanceOf(address(this))); \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using AddressUpgradeable for address; \n \n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n// solhint-disable-next-line compiler-version \n",
            "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module that helps prevent reentrant calls to a function. \n * \n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier \n * available, which can be applied to functions to make sure there are no nested \n * (reentrant) calls to them. \n * \n * Note that because there is a single `nonReentrant` guard, functions marked as \n * `nonReentrant` may not call one another. This can be worked around by making \n * those functions `private`, and then adding `external` `nonReentrant` entry \n * points to them. \n * \n * TIP: If you would like to learn more about reentrancy and alternative ways \n * to protect against it, check out our blog post \n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. \n */ \nabstract contract ReentrancyGuardUpgradeable is Initializable { \n    // Booleans are more expensive than uint256 or any type that takes up a full \n    // word because each write operation emits an extra SLOAD to first read the \n    // slot's contents, replace the bits taken up by the boolean, and then write \n    // back. This is the compiler's defense against contract upgrades and \n    // pointer aliasing, and it cannot be disabled. \n \n    // The values being non-zero value makes deployment a bit more expensive, \n    // but in exchange the refund on every call to nonReentrant will be lower in \n    // amount. Since refunds are capped to a percentage of the total \n    // transaction's gas, it is best to keep them low in cases like this one, to \n    // increase the likelihood of the full refund coming into effect. \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    function __ReentrancyGuard_init() internal initializer { \n        __ReentrancyGuard_init_unchained(); \n    } \n \n    function __ReentrancyGuard_init_unchained() internal initializer { \n        _status = _NOT_ENTERED; \n    } \n \n    /** \n     * @dev Prevents a contract from calling itself, directly or indirectly. \n     * Calling a `nonReentrant` function from another `nonReentrant` \n     * function is not supported. It is possible to prevent this from happening \n     * by making the `nonReentrant` function external, and make it call a \n     * `private` function that does the actual work. \n     */ \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n    uint256[49] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface IStrategyLink { \n \n    event StrategyDeposit(address indexed strategy, uint256 indexed pid, address indexed user, uint25\n    event StrategyBorrow(address indexed strategy, uint256 indexed pid, address indexed user, uint256 \n    event StrategyWithdraw(address indexed strategy, uint256 indexed pid, address indexed user, uint2\n    event StrategyLiquidation(address indexed strategy, uint256 indexed pid, address indexed user, ui\n \n    function bank() external view returns(address); \n    function getSource() external view returns (string memory); \n    function userInfo(uint256 _pid, address _account) external view returns (uint256,uint256,address,\n    function getPoolInfo(uint256 _pid) external view  returns(address[] memory collateralToken, addre\n    function getBorrowInfo(uint256 _pid, address _account) external view returns (address borrowFrom, \n    function getBorrowAmount(uint256 _pid, address _account) external view returns (uint256 value); \n    function getBorrowAmountInBaseToken(uint256 _pid, address _account) external view returns (uint25\n    function getDepositAmount(uint256 _pid, address _account) external view returns (uint256 amount);\n \n    function getPoolCollateralToken(uint256 _pid) external view returns (address[] memory collateralT\n    function getPoollpToken(uint256 _pid) external view returns (address lpToken); \n    function getBaseToken(uint256 _pid) external view returns (address baseToken); \n \n    function poolLength() external view returns (uint256); \n \n    function pendingRewards(uint256 _pid, address _account) external view returns (uint256 value); \n    function pendingLPAmount(uint256 _pid, address _account) external view returns (uint256 value); \n \n    // function massUpdatePools(uint256 _start, uint256 _end) external; \n    function updatePool(uint256 _pid, uint256 _desirePrice, uint256 _slippage) external; \n \n    function deposit(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint256 _de\n    function depositLPToken(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint\n \n    function withdraw(uint256 _pid, address _account, uint256 _rate, address _toToken, uint256 _desir\n    function withdrawLPToken(uint256 _pid, address _account, uint256 _rate, uint256 _desirePrice, uin\n \n    function emergencyWithdraw(uint256 _pid, address _account, uint256 _desirePrice, uint256 _slippag\n \n    function liquidation(uint256 _pid, address _account, address _hunter, uint256 _maxDebt) external;\n    function repayBorrow(uint256 _pid, address _account, uint256 _rate, bool _force) external; \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface ITenBankHall { \n    function makeBorrowFrom(uint256 _pid, address _account, address _debtFrom, uint256 _value) extern\n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface ISafeBox { \n \n    function bank() external view returns(address); \n \n    function token() external view returns(address); \n \n    function getSource() external view returns (string memory); \n \n    function supplyRatePerBlock() external view returns (uint256); \n    function borrowRatePerBlock() external view returns (uint256); \n \n    function getBorrowInfo(uint256 _bid) external view \n            returns (address owner, uint256 amount, address strategy, uint256 pid); \n    function getBorrowId(address _strategy, uint256 _pid, address _account) external view returns (ui\n    function getBorrowId(address _strategy, uint256 _pid, address _account, bool _add) external retur\n    function getDepositTotal() external view returns (uint256); \n    function getBorrowTotal() external view returns (uint256); \n    // function getBorrowAmount(address _account) external view returns (uint256 value); \n    function getBaseTokenPerLPToken() external view returns (uint256); \n \n    function deposit(uint256 _value) external; \n    function withdraw(uint256 _value) external; \n \n    function emergencyWithdraw() external; \n    function emergencyRepay(uint256 _bid) external; \n \n    function borrowInfoLength() external view returns (uint256); \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external; \n    function repay(uint256 _bid, uint256 _value) external; \n    function claim(uint256 _tTokenAmount) external; \n \n    function update() external; \n    function mintDonate(uint256 _value) external; \n \n    function pendingSupplyAmount(address _account) external view returns (uint256 value); \n    function pendingBorrowAmount(uint256 _bid) external view returns (uint256 value); \n    function pendingBorrowRewards(uint256 _bid) external view returns (uint256 value); \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface IClaimFromBank { \n    function claimFromBank(address _account, uint256[] memory _pidlist) external returns (uint256 val\n} \n \n",
            "pragma solidity 0.6.12; \n \n \n \n// TenBank bank \ncontract TenBankHall is OwnableUpgradeable, ITenBankHall, ReentrancyGuardUpgradeable { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    struct StrategyInfo { \n        bool isListed;          // if enabled, it will access \n        IStrategyLink iLink;    // strategy interface \n        uint256 pid;            // strategy poolid, multiple strategys pools \n    } \n \n    // safebox manager \n    ISafeBox[] public boxInfo; \n    mapping(address => uint256) public boxIndex; \n    mapping(uint256 => bool) public boxlisted; \n \n    // strategyinfo manager \n    StrategyInfo[] public strategyInfo; \n    mapping(address => mapping(uint256 => uint256)) public strategyIndex; // strategy + pid => strate\n \n    // actionpools claim \n    IClaimFromBank[] public poolClaim; \n \n    // blacklist \n    mapping(address => bool) public blacklist; \n    mapping(uint256 => bool) public emergencyEnabled; \n \n    event AddBox(uint256 indexed _boxid, address _safebox); \n    event AddStrategy(uint256 indexed _sid, address indexed _strategylink, uint256 indexed _pid, bool\n    event SetBlacklist(address indexed _account, bool _newset); \n    event SetEmergencyEnabled(uint256 indexed _sid, bool _newset); \n    event SetBoxListed(uint256 indexed _boxid, bool _listed); \n \n    function initialize() public initializer { \n        __Ownable_init(); \n        __ReentrancyGuard_init(); \n    } \n \n    // blacklist manager \n    function setBlacklist(address _account, bool _newset) external onlyOwner { \n        blacklist[_account] = _newset; \n        if(_newset) { \n            require(isContract(_account), 'contract address only'); \n        } \n        emit SetBlacklist(_account, _newset); \n    } \n \n    function isContract(address addr) internal returns (bool) { \n        uint size; \n        assembly { size := extcodesize(addr) } \n        return size > 0; \n    } \n \n    function setEmergencyEnabled(uint256 _sid, bool _newset) external onlyOwner { \n        emergencyEnabled[_sid] = _newset; \n        emit SetEmergencyEnabled(_sid, _newset); \n    } \n \n    function claimLength() external view returns (uint256) { \n        return poolClaim.length; \n    } \n \n    function addClaimPool(address _poolClaim) external onlyOwner { \n        poolClaim.push(IClaimFromBank(_poolClaim)); \n    } \n \n    // box manager \n    function boxesLength() external view returns (uint256) { \n        return boxInfo.length; \n    } \n \n    function addBox(address _safebox) external onlyOwner { \n        require(boxIndex[_safebox] == 0, 'add once only'); \n        boxInfo.push(ISafeBox(_safebox)); \n        uint256 boxid = boxInfo.length.sub(1); \n        boxlisted[boxid] = true; \n        boxIndex[_safebox] = boxid; \n        emit AddBox(boxid, _safebox); \n        require(ISafeBox(_safebox).bank() == address(this), 'bank not me?'); \n    } \n \n    function setBoxListed(uint256 _boxid, bool _listed) external onlyOwner { \n        boxlisted[_boxid] = _listed; \n        emit SetBoxListed(_boxid, _listed); \n    } \n \n    // Strategy manager \n    function strategyInfoLength() external view returns (uint256 length) { \n        length = strategyInfo.length; \n    } \n \n    function strategyIsListed(uint256 _sid) external view returns (bool) { \n        return strategyInfo[_sid].isListed; \n    } \n \n    function setStrategyListed(uint256 _sid, bool _listed) external onlyOwner { \n        strategyInfo[_sid].isListed = _listed; \n    } \n \n    function addStrategy(address _strategylink, uint256 _pid, bool _blisted) external onlyOwner { \n        require(IStrategyLink(_strategylink).poolLength() > _pid, 'not strategy pid'); \n        strategyInfo.push(StrategyInfo( \n            _blisted, \n            IStrategyLink(_strategylink), \n            _pid)); \n        strategyIndex[_strategylink][_pid] = strategyInfo.length.sub(1); \n        emit AddStrategy(strategyIndex[_strategylink][_pid], _strategylink, _pid, _blisted); \n        require(IStrategyLink(_strategylink).bank() == address(this), 'bank not me?'); \n    } \n \n    function depositLPToken(uint256 _sid, uint256 _amount, uint256 _bid, uint256 _bAmount, uint256 _d\n            public nonReentrant returns (uint256 lpAmount) { \n        require(strategyInfo[_sid].isListed, 'not listed'); \n        require(!blacklist[msg.sender], 'address in blacklist'); \n \n        address lpToken = strategyInfo[_sid].iLink.getPoollpToken(strategyInfo[_sid].pid); \n        IERC20Upgradeable(lpToken).safeTransferFrom(msg.sender, address(strategyInfo[_sid].iLink), _a\n \n        address boxitem = address(0); \n        if(_bAmount > 0) { \n            boxitem = address(boxInfo[_bid]); \n        } \n        return strategyInfo[_sid].iLink.depositLPToken(strategyInfo[_sid].pid, msg.sender, boxitem, _\n    } \n \n    function deposit(uint256 _sid, uint256[] memory _amount, uint256 _bid, uint256 _bAmount, uint256 _\n            public nonReentrant returns (uint256 lpAmount) { \n        require(strategyInfo[_sid].isListed, 'not listed'); \n        require(!blacklist[msg.sender], 'address in blacklist'); \n \n        address[] memory collateralToken = strategyInfo[_sid].iLink.getPoolCollateralToken(strategyIn\n        require(collateralToken.length == _amount.length, '_amount length error'); \n \n        for(uint256 u = 0; u < collateralToken.length; u ++) { \n            if(_amount[u] > 0) { \n                IERC20Upgradeable(collateralToken[u]).safeTransferFrom(msg.sender, address(strategyIn\n            } \n        } \n \n        address boxitem = address(0); \n        if(_bAmount > 0) { \n            boxitem = address(boxInfo[_bid]); \n        } \n        return strategyInfo[_sid].iLink.deposit(strategyInfo[_sid].pid, msg.sender, boxitem, _bAmount\n    } \n \n    function withdrawLPToken(uint256 _sid, uint256 _rate, uint256 _desirePrice, uint256 _slippage) ex\n        return strategyInfo[_sid].iLink.withdrawLPToken(strategyInfo[_sid].pid, msg.sender, _rate, _d\n    } \n \n    function withdraw(uint256 _sid, uint256 _rate, address _toToken, uint256 _desirePrice, uint256 _s\n        return strategyInfo[_sid].iLink.withdraw(strategyInfo[_sid].pid, msg.sender, _rate, _toToken, \n    } \n \n    function withdrawLPTokenAndClaim(uint256 _sid, uint256 _rate, \n                                    uint256 _desirePrice, uint256 _slippage, \n                                    uint256 _poolClaimId, uint256[] memory _pidlist) external nonReen\n        strategyInfo[_sid].iLink.withdrawLPToken(strategyInfo[_sid].pid, msg.sender, _rate, _desirePr\n        if(_pidlist.length > 0) { \n            poolClaim[_poolClaimId].claimFromBank(msg.sender, _pidlist); \n        } \n    } \n \n    function withdrawAndClaim(uint256 _sid, uint256 _rate, address _toToken, \n                                uint256 _desirePrice, uint256 _slippage, \n                                uint256 _poolClaimId, uint256[] memory _pidlist) external nonReentran\n        strategyInfo[_sid].iLink.withdraw(strategyInfo[_sid].pid, msg.sender, _rate, _toToken, _desir\n        if(_pidlist.length > 0) { \n            poolClaim[_poolClaimId].claimFromBank(msg.sender, _pidlist); \n        } \n    } \n \n    function claim(uint256 _poolClaimId, uint256[] memory _pidlist) external nonReentrant { \n        poolClaim[_poolClaimId].claimFromBank(msg.sender, _pidlist); \n    } \n \n    function emergencyWithdraw(uint256 _sid, uint256 _desirePrice, uint256 _slippage) external nonRee\n        require(emergencyEnabled[_sid], 'emergency not enabled'); \n        return strategyInfo[_sid].iLink.emergencyWithdraw(strategyInfo[_sid].pid, msg.sender, _desire\nStrategyConfig.sol\n    } \n \n    function liquidation(uint256 _sid, address _account, uint256 _maxDebt) external nonReentrant { \n        uint256 pid = strategyInfo[_sid].pid; \n        if(_maxDebt > 0) { \n            (address borrowFrom,) = IStrategyLink(strategyInfo[_sid].iLink).getBorrowInfo(pid, _accou\n            address borrowToken = ISafeBox(borrowFrom).token(); \n            IERC20Upgradeable(borrowToken).safeTransferFrom(msg.sender, address(strategyInfo[_sid].iL\n        } \n        strategyInfo[_sid].iLink.liquidation(pid, _account, msg.sender, _maxDebt); \n    } \n \n    function getBorrowAmount(uint256 _sid, address _account) external view returns (uint256 value) { \n        value = strategyInfo[_sid].iLink.getBorrowAmount(strategyInfo[_sid].pid, _account); \n    } \n \n    function getDepositAmount(uint256 _sid, address _account) external view returns (uint256 value) {\n        value = strategyInfo[_sid].iLink.getDepositAmount(strategyInfo[_sid].pid, _account); \n    } \n \n    function makeBorrowFrom(uint256 _pid, address _account, address _borrowFrom, uint256 _value) \n        external override returns (uint256 bid) { \n        // borrow from bank will check contract authority \n        uint256 sid = strategyIndex[msg.sender][_pid]; \n        require(address(strategyInfo[sid].iLink) == msg.sender, 'only call from strategy'); \n        bid = ISafeBox(_borrowFrom).getBorrowId(msg.sender, _pid, _account, true); \n        require(bid > 0, 'bid go run'); \n        ISafeBox(_borrowFrom).borrow(bid, _value, msg.sender); \n    } \n \n    receive() external payable { \n        revert(); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \ninterface IStrategyConfig { \n    // event \n    event SetFeeGather(address _feeGatherOld, address _feeGather); \n    event SetReservedGather(address _old, address _new); \n    event SetBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor); \n    event SetLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor); \n    event SetFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor); \n    event SetDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee); \n    event SetWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee); \n    event SetRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee); \n    event SetClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee); \n    event SetLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee); \n \n    // factor \n    function getBorrowFactor(address _strategy, uint256 _poolid) external view returns (uint256); \n    function setBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor) external; \n \n    function getLiquidationFactor(address _strategy, uint256 _poolid) external view returns (uint256)\n    function setLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor) ext\n \n    function getFarmPoolFactor(address _strategy, uint256 _poolid) external view returns (uint256 val\n    function setFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor) external;\n \n    // fee manager \n    function getDepositFee(address _strategy, uint256 _poolid) external view returns (address, uint25\n    function setDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee) external; \n \n    function getWithdrawFee(address _strategy, uint256 _poolid) external view returns (address, uint2\n    function setWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee) external; \n \n    function getRefundFee(address _strategy, uint256 _poolid) external view returns (address, uint256\n    function setRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee) external; \n \n    function getClaimFee(address _strategy, uint256 _poolid) external view returns (address, uint256)\n    function setClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee) external; \n \n    function getLiquidationFee(address _strategy, uint256 _poolid) external view returns (address, ui\n    function setLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee) external;\n} \n \n",
            "pragma solidity 0.6.12; \n \n \n \n// fund fee processing \n// some functions of strategy \ncontract StrategyConfig is Ownable, IStrategyConfig { \n    using SafeMath for uint256; \n    using SafeERC20 for IERC20; \n \n    address public feeGather;           // fee gather \n    address public reservedGather;      // reserved gather \n \n    mapping (address => mapping(uint256=>uint256) ) public borrowFactor; \n    mapping (address => mapping(uint256=>uint256) ) public liquidationFactor; \n    mapping (address => mapping(uint256=>uint256) ) public farmPoolFactor; \n \n    mapping (address => mapping(uint256=>uint256) ) public depositFee;  // deposit platform fee \n    mapping (address => mapping(uint256=>uint256) ) public refundFee;   // reinvestment platform fee \n    mapping (address => mapping(uint256=>uint256) ) public withdrawFee; // withdraw rewards platform \n    mapping (address => mapping(uint256=>uint256) ) public claimFee;    // claim fee - no used \n    mapping (address => mapping(uint256=>uint256) ) public liquidationFee;  // the hunter fee \n \n    constructor() public { \n        feeGather = msg.sender; \n        reservedGather = msg.sender; \n    } \n \n    function setFeeGather(address _feeGather) external onlyOwner { \n        emit SetFeeGather(feeGather, _feeGather); \n        feeGather = _feeGather; \n    } \n \n    function setReservedGather(address _reservedGather) external onlyOwner { \n        emit SetReservedGather(reservedGather, _reservedGather); \n        reservedGather = _reservedGather; \n    } \n \n    // Lending burst \n    function getBorrowFactor(address _strategy, uint256 _poolid) public override view returns (uint25\n        value = borrowFactor[_strategy][_poolid]; \n    } \n \n    function checkBorrowAndLiquidation(address _strategy, uint256 _poolid) internal returns (bool bok\n        uint256 v = getBorrowFactor(_strategy, _poolid); \n        if(v <= 0) { \n            return true; \n        } \n        // MaxBorrowAmount = DepositAmount * BorrowFactor \n        // MaxBorrowAmount / (DepositAmount + MaxBorrowAmount) * 100.5% < LiquidationFactor \n        bok = v.mul(1005e6).div(v.add(1e9)) < getLiquidationFactor(_strategy, _poolid); \n    } \n \n    function setBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor) external over\n        borrowFactor[_strategy][_poolid] = _borrowFactor; \n        emit SetBorrowFactor(_strategy, _poolid, _borrowFactor); \n        require(checkBorrowAndLiquidation(_strategy, _poolid), 'set error'); \n    } \n \n    function getLiquidationFactor(address _strategy, uint256 _poolid) public override view returns (u\n        value = liquidationFactor[_strategy][_poolid]; \n        if(value <= 0) { \n            value = 8e8;  // 80% for default , 100% will be liquidation \n        } \n    } \n \n    function setLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor) ext\n        require(_liquidationFactor >= 2e8, 'too lower'); \n        liquidationFactor[_strategy][_poolid] = _liquidationFactor; \n        emit SetLiquidationFactor(_strategy, _poolid, _liquidationFactor); \n        require(checkBorrowAndLiquidation(_strategy, _poolid), 'set error'); \n    } \n \n    function getFarmPoolFactor(address _strategy, uint256 _poolid) external override view returns (ui\n        value = farmPoolFactor[_strategy][_poolid]; \n        // == 0 no limit and > 0 limit by lptoken amount \n    } \n \n    function setFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor) external \n        farmPoolFactor[_strategy][_poolid] = _farmPoolFactor; \n        emit SetFarmPoolFactor(_strategy, _poolid, _farmPoolFactor); \n    } \n \n    // fee config \n    function getDepositFee(address _strategy, uint256 _poolid) external override view returns (addres\n        a = feeGather; \n        b = depositFee[_strategy][_poolid]; \n    } \n \n    function setDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee) external override\n        depositFee[_strategy][_poolid] = _depositFee; \n        emit SetDepositFee(_strategy, _poolid, _depositFee); \n    } \n \n    function getWithdrawFee(address _strategy, uint256 _poolid) external override view returns (addre\n        a = feeGather; \n        b = withdrawFee[_strategy][_poolid]; \n    } \n \n    function setWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee) external overri\n        withdrawFee[_strategy][_poolid] = _withdrawFee; \n        emit SetWithdrawFee(_strategy, _poolid, _withdrawFee); \n    } \n \n    function getRefundFee(address _strategy, uint256 _poolid) external override view returns (address \n        a = feeGather; \n        b = refundFee[_strategy][_poolid]; \n    } \n \n    function setRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee) external override o\n        refundFee[_strategy][_poolid] = _refundFee; \n        emit SetRefundFee(_strategy, _poolid, _refundFee); \n    } \n \n    function getClaimFee(address _strategy, uint256 _poolid) external override view returns (address \n        a = feeGather; \n        b = claimFee[_strategy][_poolid]; \n    } \n \n    function setClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee) external override onl\n        claimFee[_strategy][_poolid] = _claimFee; \n        emit SetClaimFee(_strategy, _poolid, _claimFee); \n    } \n \n    function getLiquidationFee(address _strategy, uint256 _poolid) external override view returns (ad\n        a = reservedGather; \n        b = liquidationFee[_strategy][_poolid]; \n    } \n \nPriceCheckerLPToken::TransparentUpgradeableProxy.sol\n    function setLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee) external \n        liquidationFee[_strategy][_poolid] = _liquidationFee; \n        emit SetLiquidationFee(_strategy, _poolid, _liquidationFee); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev This abstract contract provides a  fallback function that delegates all calls to an\n * instruction `delegatecall`. We refer to the  second contract as the\n * be specified by overriding the  virtual {_implementation} function. \n * \n * Additionally, delegation to the  implementation can be triggered manually through \n * different contract through the  {_delegate} function. \n * \n * The success and return data of the  delegated call will  b\n */  \nabstract contract Proxy { \n    /** \n     * @dev Delegates the  current call to `implementation`. \n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _delegate(address implementation) internal virtual { \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            // Copy msg.data. We take full control of memory in this inline assembly \n            // block because it will not return to Solidity code. We overwrite the \n            // Solidity scratch pad at memory position 0. \n            calldatacopy(0, 0, calldatasize()) \n \n            // Call the implementation. \n            // out and outsize are 0 because we don't know the size yet. \n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n            // Copy the returned data. \n            returndatacopy(0, 0, returndatasize()) \n \n            switch result \n            // delegatecall returns 0 on error. \n            case 0 { revert(0, returndatasize()) } \n            default { return(0, returndatasize()) } \n        } \n    } \n \n    /** \n     * @dev This is a  virtual function that should  be override\n     * and {_fallback} should  delegate. \n     */  \n    function _implementation() internal view virtual returns (address); \n \n    /** \n     * @dev Delegates the  current call to the  address return\n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _fallback() internal virtual { \n        _beforeFallback(); \n        _delegate(_implementation()); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * function in the  contract matches the  call data. \n     */  \n    fallback () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * is empty. \n     */  \n    receive () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Hook that is called before falling back to the  implementation. Can happen a\n     * call, or as part of the  Solidity `fallback` or `receive` functions. \n     * \n     * If overriden should  call `super._beforeFallback()`. \n     */  \n    function _beforeFallback() internal virtual { \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the  address type \n */  \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain`call` is an  unsafe replacement for a  function call: \n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an  upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so  that it doesn't\n * implementation behind the  proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an  externally up\n * {TransparentUpgradeableProxy}. \n */  \ncontract UpgradeableProxy is Proxy { \n    /** \n     * @dev Initializes the  upgradeable proxy with an  initial i\n     * \n     * If `_data` is nonempty, it's used as data in a  delegate call to `_logic`. This \n     * function call, and allows initializating the  storage of the\n     */  \n    constructor(address _logic, bytes memory _data) public payable { \n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n        _setImplementation(_logic); \n        if(_data.length > 0) { \n            Address.functionDelegateCall(_logic, _data); \n        } \n    } \n \n    /** \n     * @dev Emitted when the  implementation is upgraded. \n     */  \n    event Upgraded(address indexed implementation); \n \n    /** \n     * @dev Storage slot with the  address of the  current imp\n     * This is the  keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n     * validated in the  constructor. \n     */  \n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n    /** \n     * @dev Returns the  current implementation address. \n     */  \n    function _implementation() internal view virtual override returns (address impl) { \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            impl := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Upgrades the  proxy to a  new implementation. \n     * \n     * Emits an  {Upgraded} event. \n     */  \n    function _upgradeTo(address newImplementation) internal virtual { \n        _setImplementation(newImplementation); \n        emit Upgraded(newImplementation); \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 implemen\n     */  \n    function _setImplementation(address newImplementation) private { \n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newImplementation) \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \nTenBankHall::TransparentUpgradeableProxy.sol\n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev This abstract contract provides a  fallback function that delegates all calls to an\n * instruction `delegatecall`. We refer to the  second contract as the\n * be specified by overriding the  virtual {_implementation} function. \n * \n * Additionally, delegation to the  implementation can be triggered manually through \n * different contract through the  {_delegate} function. \n * \n * The success and return data of the  delegated call will  b\n */  \nabstract contract Proxy { \n    /** \n     * @dev Delegates the  current call to `implementation`. \n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _delegate(address implementation) internal virtual { \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            // Copy msg.data. We take full control of memory in this inline assembly \n            // block because it will not return to Solidity code. We overwrite the \n            // Solidity scratch pad at memory position 0. \n            calldatacopy(0, 0, calldatasize()) \n \n            // Call the implementation. \n            // out and outsize are 0 because we don't know the size yet. \n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n            // Copy the returned data. \n            returndatacopy(0, 0, returndatasize()) \n \n            switch result \n            // delegatecall returns 0 on error. \n            case 0 { revert(0, returndatasize()) } \n            default { return(0, returndatasize()) } \n        } \n    } \n \n    /** \n     * @dev This is a  virtual function that should  be override\n     * and {_fallback} should  delegate. \n     */  \n    function _implementation() internal view virtual returns (address); \n \n    /** \n     * @dev Delegates the  current call to the  address return\n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _fallback() internal virtual { \n        _beforeFallback(); \n        _delegate(_implementation()); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * function in the  contract matches the  call data. \n     */  \n    fallback () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * is empty. \n     */  \n    receive () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Hook that is called before falling back to the  implementation. Can happen a\n     * call, or as part of the  Solidity `fallback` or `receive` functions. \n     * \n     * If overriden should  call `super._beforeFallback()`. \n     */  \n    function _beforeFallback() internal virtual { \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the  address type \n */  \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain`call` is an  unsafe replacement for a  function call: \n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an  upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so  that it doesn't\n * implementation behind the  proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an  externally up\n * {TransparentUpgradeableProxy}. \n */  \ncontract UpgradeableProxy is Proxy { \n    /** \n     * @dev Initializes the  upgradeable proxy with an  initial i\n     * \n     * If `_data` is nonempty, it's used as data in a  delegate call to `_logic`. This \n     * function call, and allows initializating the  storage of the\n     */  \n    constructor(address _logic, bytes memory _data) public payable { \n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n        _setImplementation(_logic); \n        if(_data.length > 0) { \n            Address.functionDelegateCall(_logic, _data); \n        } \n    } \n \n    /** \n     * @dev Emitted when the  implementation is upgraded. \n     */  \n    event Upgraded(address indexed implementation); \n \n    /** \n     * @dev Storage slot with the  address of the  current imp\n     * This is the  keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n     * validated in the  constructor. \n     */  \n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n    /** \n     * @dev Returns the  current implementation address. \n     */  \n    function _implementation() internal view virtual override returns (address impl) { \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            impl := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Upgrades the  proxy to a  new implementation. \n     * \n     * Emits an  {Upgraded} event. \n     */  \n    function _upgradeTo(address newImplementation) internal virtual { \n        _setImplementation(newImplementation); \n        emit Upgraded(newImplementation); \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 implemen\n     */  \n    function _setImplementation(address newImplementation) private { \n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newImplementation) \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \nPriceCheckerLPToken.sol\n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n// solhint-disable-next-line compiler-version \n",
            "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Implementation of the {IERC20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of ERC20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IERC20-approve}. \n */ \ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n     * a default value of 18. \n     * \n     * To select a different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer { \n        __Context_init_unchained(); \n        __ERC20_init_unchained(name_, symbol_); \n    } \n \n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer \n        _name = name_; \n        _symbol = symbol_; \n        _decimals = 18; \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public view virtual returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public view virtual returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a balance of `505` tokens should \n     * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a value of 18, imitating the relationship between \n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is \n     * called. \n     * \n     * NOTE: This information is only used for _display_ purposes: it in \n     * no way affects any of the arithmetic of the contract, including \n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */ \n    function decimals() public view virtual returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */ \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */ \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function allowance(address owner, address spender) public view virtual override returns (uint256)\n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {ERC20}. \n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the total supply. \n     * \n     * Emits a {Transfer} event with `from` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `to` cannot be the zero address. \n     */ \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens. \n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Sets {decimals} to a value other than the default one of 18. \n     * \n     * WARNING: This function should only be called from the constructor. Most \n     * applications that interact with token contracts will not expect \n     * {decimals} to ever change, and may work incorrectly if it does. \n     */ \n    function _setupDecimals(uint8 decimals_) internal virtual { \n        _decimals = decimals_; \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * will be to transferred to `to`. \n     * - when `from` is zero, `amount` tokens will be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n     * - `from` and `to` are never both zero. \n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n    uint256[44] private __gap; \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @title SignedSafeMath \n * @dev Signed math operations with safety checks that revert on error. \n */ \nlibrary SignedSafeMathUpgradeable { \n    int256 constant private _INT256_MIN = -2**255; \n \n    /** \n     * @dev Returns the multiplication of two signed integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(int256 a, int256 b) internal pure returns (int256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\"); \n \n        int256 c = a * b; \n        require(c / a == b, \"SignedSafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two signed integers. Reverts on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(int256 a, int256 b) internal pure returns (int256) { \n        require(b != 0, \"SignedSafeMath: division by zero\"); \n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\"); \n \n        int256 c = a / b; \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two signed integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(int256 a, int256 b) internal pure returns (int256) { \n        int256 c = a - b; \n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the addition of two signed integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(int256 a, int256 b) internal pure returns (int256) { \n        int256 c = a + b; \n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\"); \n \n        return c; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n \n",
            "pragma solidity >=0.5.0; \n \ninterface IUniswapV2Pair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n    function factory() external view returns (address); \n    function token0() external view returns (address); \n    function token1() external view returns (address); \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function price0CumulativeLast() external view returns (uint); \n    function price1CumulativeLast() external view returns (uint); \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n    function burn(address to) external returns (uint amount0, uint amount1); \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n    function skim(address to) external; \n    function sync() external; \n \n    function initialize(address, address) external; \n} \n \n",
            "pragma solidity 0.6.12; \n \ninterface ITokenOracle { \n    function getPrice(address _token) external view returns (int); \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface IPriceChecker { \n    function getPriceSlippage(address _lptoken) external view returns (uint256); \n    function checkLPTokenPriceLimit(address _lptoken, bool _largeType) external view returns (bool); \n} \n \n",
            "pragma solidity 0.6.12; \n \n \n \n \ncontract PriceCheckerLPToken is OwnableUpgradeable, IPriceChecker { \n    using SafeMathUpgradeable for uint256; \n    using SignedSafeMathUpgradeable for int256; \n \n    mapping(address => uint256) public priceSlippage; \n    ITokenOracle public tokenOracle; \n    uint256 public largeSlipRate; \n \n    event SetPriceSlippage(address _lptoken, uint256 _oldv, uint256 _newv); \n    event SetLargeSlipRate(uint256 _oldv, uint256 _newv); \n    event SetTokenOracle(address _oldv, address _newv); \n \n    constructor() public { \n    } \n \n    function initialize(address _tokenOracle) public initializer { \n        __Ownable_init(); \n        largeSlipRate = 4e9; \n        setTokenOracle(_tokenOracle); \n    } \n \n    function setLargeSlipRate(uint256 _largeSlipRate) external onlyOwner { \n        require(_largeSlipRate >= 1e9, 'value error'); \n        emit SetLargeSlipRate(largeSlipRate, _largeSlipRate); \n        largeSlipRate = _largeSlipRate; \n    } \n \n    function setPriceSlippage(address _lptoken, uint256 _slippage) external onlyOwner { \n        require(_slippage >= 0 && _slippage <= 1e9, 'value error'); \n        emit SetPriceSlippage(_lptoken, priceSlippage[_lptoken], _slippage); \n        priceSlippage[_lptoken] = _slippage; \n    } \n \n    function setTokenOracle(address _tokenOracle) public onlyOwner { \n        emit SetTokenOracle(address(tokenOracle), _tokenOracle); \n        tokenOracle = ITokenOracle(_tokenOracle); \nActionCompPools::TransparentUpgradeableProxy.sol\n    } \n \n    function getPriceSlippage(address _lptoken) public override view returns (uint256) { \n        if(priceSlippage[_lptoken] > 0) { \n            return priceSlippage[_lptoken]; \n        } \n        return uint256(1e7); \n    } \n \n    function getLPTokenPriceInMdex(address _lptoken, address _t0, address _t1) public view returns (u\n        IUniswapV2Pair pair = IUniswapV2Pair(_lptoken); \n        (uint256 r0, uint256 r1, ) = pair.getReserves(); \n        uint256 d0 = ERC20Upgradeable(_t0).decimals(); \n        uint256 d1 = ERC20Upgradeable(_t1).decimals(); \n        if(d0 != 18) { \n            r0 = r0.mul(1e18).div(10**d0); \n        } \n        if(d1 != 18) { \n            r1 = r1.mul(1e18).div(10**d1); \n        } \n        return r0.mul(1e18).div(r1); \n    } \n \n \n    function getLPTokenPriceInOracle(address _t0, address _t1) public view returns (uint256) { \n        int256 price0 = tokenOracle.getPrice(_t0); \n        int256 price1 = tokenOracle.getPrice(_t1); \n        if(price0 <= 0 || price1 <= 0) { \n            return 0; \n        } \n        int256 priceInOracle = price1.mul(1e18).div(price0); \n        if(priceInOracle <= 0) { \n            return 0; \n        } \n        return uint256(priceInOracle); \n    } \n \n    function checkLPTokenPriceLimit(address _lptoken, bool _largeType) external override view returns\n        IUniswapV2Pair pair = IUniswapV2Pair(_lptoken); \n        address t0 = pair.token0(); \n        address t1 = pair.token1(); \n        uint256 price0 = getLPTokenPriceInMdex(_lptoken, t0, t1); \n        uint256 price1 = getLPTokenPriceInOracle(t0, t1); \n        if(price0 == 0 || price1 == 0) { \n            return false; \n        } \n        uint256 slip = getPriceSlippage(_lptoken); \n        uint256 priceRate = price0.mul(1e9).div(price1); \n        if(_largeType) { \n            slip = slip.mul(largeSlipRate).div(1e9); \n        } \n        if(priceRate >= uint256(1e9).add(slip) || priceRate <= uint256(1e9).sub(slip)) { \n            return false; \n        } \n        return true; \n    } \n}\n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev This abstract contract provides a  fallback function that delegates all calls to an\n * instruction `delegatecall`. We refer to the  second contract as the\n * be specified by overriding the  virtual {_implementation} function. \n * \n * Additionally, delegation to the  implementation can be triggered manually through \n * different contract through the  {_delegate} function. \n * \n * The success and return data of the  delegated call will  b\n */  \nabstract contract Proxy { \n    /** \n     * @dev Delegates the  current call to `implementation`. \n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _delegate(address implementation) internal virtual { \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            // Copy msg.data. We take full control of memory in this inline assembly \n            // block because it will not return to Solidity code. We overwrite the \n            // Solidity scratch pad at memory position 0. \n            calldatacopy(0, 0, calldatasize()) \n \n            // Call the implementation. \n            // out and outsize are 0 because we don't know the size yet. \n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n            // Copy the returned data. \n            returndatacopy(0, 0, returndatasize()) \n \n            switch result \n            // delegatecall returns 0 on error. \n            case 0 { revert(0, returndatasize()) } \n            default { return(0, returndatasize()) } \n        } \n    } \n \n    /** \n     * @dev This is a  virtual function that should  be override\n     * and {_fallback} should  delegate. \n     */  \n    function _implementation() internal view virtual returns (address); \n \n    /** \n     * @dev Delegates the  current call to the  address return\n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _fallback() internal virtual { \n        _beforeFallback(); \n        _delegate(_implementation()); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * function in the  contract matches the  call data. \n     */  \n    fallback () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * is empty. \n     */  \n    receive () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Hook that is called before falling back to the  implementation. Can happen a\n     * call, or as part of the  Solidity `fallback` or `receive` functions. \n     * \n     * If overriden should  call `super._beforeFallback()`. \n     */  \n    function _beforeFallback() internal virtual { \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the  address type \n */  \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain`call` is an  unsafe replacement for a  function call: \n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an  upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so  that it doesn't\n * implementation behind the  proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an  externally up\n * {TransparentUpgradeableProxy}. \n */  \ncontract UpgradeableProxy is Proxy { \n    /** \n     * @dev Initializes the  upgradeable proxy with an  initial i\n     * \n     * If `_data` is nonempty, it's used as data in a  delegate call to `_logic`. This \n     * function call, and allows initializating the  storage of the\n     */  \n    constructor(address _logic, bytes memory _data) public payable { \n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n        _setImplementation(_logic); \n        if(_data.length > 0) { \n            Address.functionDelegateCall(_logic, _data); \n        } \n    } \n \n    /** \n     * @dev Emitted when the  implementation is upgraded. \n     */  \n    event Upgraded(address indexed implementation); \n \n    /** \n     * @dev Storage slot with the  address of the  current imp\n     * This is the  keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n     * validated in the  constructor. \n     */  \n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n    /** \n     * @dev Returns the  current implementation address. \n     */  \n    function _implementation() internal view virtual override returns (address impl) { \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            impl := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Upgrades the  proxy to a  new implementation. \n     * \n     * Emits an  {Upgraded} event. \n     */  \n    function _upgradeTo(address newImplementation) internal virtual { \n        _setImplementation(newImplementation); \n        emit Upgraded(newImplementation); \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 implemen\n     */  \n    function _setImplementation(address newImplementation) private { \n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newImplementation) \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \nDFOXPools::TransparentUpgradeableProxy.sol\n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev This abstract contract provides a  fallback function that delegates all calls to an\n * instruction `delegatecall`. We refer to the  second contract as the\n * be specified by overriding the  virtual {_implementation} function. \n * \n * Additionally, delegation to the  implementation can be triggered manually through \n * different contract through the  {_delegate} function. \n * \n * The success and return data of the  delegated call will  b\n */  \nabstract contract Proxy { \n    /** \n     * @dev Delegates the  current call to `implementation`. \n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _delegate(address implementation) internal virtual { \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            // Copy msg.data. We take full control of memory in this inline assembly \n            // block because it will not return to Solidity code. We overwrite the \n            // Solidity scratch pad at memory position 0. \n            calldatacopy(0, 0, calldatasize()) \n \n            // Call the implementation. \n            // out and outsize are 0 because we don't know the size yet. \n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n            // Copy the returned data. \n            returndatacopy(0, 0, returndatasize()) \n \n            switch result \n            // delegatecall returns 0 on error. \n            case 0 { revert(0, returndatasize()) } \n            default { return(0, returndatasize()) } \n        } \n    } \n \n    /** \n     * @dev This is a  virtual function that should  be override\n     * and {_fallback} should  delegate. \n     */  \n    function _implementation() internal view virtual returns (address); \n \n    /** \n     * @dev Delegates the  current call to the  address return\n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _fallback() internal virtual { \n        _beforeFallback(); \n        _delegate(_implementation()); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * function in the  contract matches the  call data. \n     */  \n    fallback () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * is empty. \n     */  \n    receive () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Hook that is called before falling back to the  implementation. Can happen a\n     * call, or as part of the  Solidity `fallback` or `receive` functions. \n     * \n     * If overriden should  call `super._beforeFallback()`. \n     */  \n    function _beforeFallback() internal virtual { \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the  address type \n */  \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain`call` is an  unsafe replacement for a  function call: \n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an  upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so  that it doesn't\n * implementation behind the  proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an  externally up\n * {TransparentUpgradeableProxy}. \n */  \ncontract UpgradeableProxy is Proxy { \n    /** \n     * @dev Initializes the  upgradeable proxy with an  initial i\n     * \n     * If `_data` is nonempty, it's used as data in a  delegate call to `_logic`. This \n     * function call, and allows initializating the  storage of the\n     */  \n    constructor(address _logic, bytes memory _data) public payable { \n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n        _setImplementation(_logic); \n        if(_data.length > 0) { \n            Address.functionDelegateCall(_logic, _data); \n        } \n    } \n \n    /** \n     * @dev Emitted when the  implementation is upgraded. \n     */  \n    event Upgraded(address indexed implementation); \n \n    /** \n     * @dev Storage slot with the  address of the  current imp\n     * This is the  keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n     * validated in the  constructor. \n     */  \n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n    /** \n     * @dev Returns the  current implementation address. \n     */  \n    function _implementation() internal view virtual override returns (address impl) { \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            impl := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Upgrades the  proxy to a  new implementation. \n     * \n     * Emits an  {Upgraded} event. \n     */  \n    function _upgradeTo(address newImplementation) internal virtual { \n        _setImplementation(newImplementation); \n        emit Upgraded(newImplementation); \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 implemen\n     */  \n    function _setImplementation(address newImplementation) private { \n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newImplementation) \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\nStrategyV2CherrySwapPool.sol\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n",
            "pragma solidity >=0.6.2; \n \ninterface IUniswapV2Router01 { \n    function factory() external pure returns (address); \n    function WHT() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityHT( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountHT, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityHT( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountHT); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityHTWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountHT); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactHTForTokens(uint amountOutMin, address[] calldata path, address to, uint deadli\n        external \n        payable \n        returns (uint[] memory amounts); \n    function swapTokensForExactHT(uint amountOut, uint amountInMax, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapExactTokensForHT(uint amountIn, uint amountOutMin, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapHTForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external \n        payable \n        returns (uint[] memory amounts); \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n} \n \n",
            "pragma solidity >=0.6.2; \n \n \ninterface IUniswapV2Router02 is IUniswapV2Router01 { \n    function removeLiquidityHTSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountHT); \n    function removeLiquidityHTWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountHT); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactHTForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForHTSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n} \n \n",
            "pragma solidity >=0.5.0; \n \ninterface IUniswapV2Pair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n    function factory() external view returns (address); \n    function token0() external view returns (address); \n    function token1() external view returns (address); \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function price0CumulativeLast() external view returns (uint); \n    function price1CumulativeLast() external view returns (uint); \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n    function burn(address to) external returns (uint amount0, uint amount1); \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n    function skim(address to) external; \n    function sync() external; \n \n    function initialize(address, address) external; \n} \n \n",
            "pragma solidity >=0.5.0; \n \ninterface IUniswapV2Factory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n    function migrator() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n    function setMigrator(address) external; \n} \n \n",
            "pragma solidity >=0.5.0 <0.8.0; \n \ninterface ICherryPool { \n    function cherry() external view returns (address); \n \n    function poolLength() external view returns (uint256); \n \n    function poolInfo(uint256 _pid) external view returns(address _lpToken, uint256, uint256); \n \n    function userInfo(uint256 _pid, address _user) external view returns (uint256 _amount, uint256 _r\n \n    function deposit(uint256 _pid, uint256 _amount) external; \n \n    function pendingCherry(uint256 _pid, address _user) external view returns (uint256); \n \n    function withdraw(uint256 _pid, uint256 _amount) external; \n \n    function emergencyWithdraw(uint256 _pid) external; \n} \n \n \n",
            "pragma solidity 0.6.12; \n \ninterface IStrategyV2SwapPool { \n \n    function setStrategy(address _strategy) external; \n \n    // get strategy \n    function getName() external view returns (string memory); \n \n    // swap functions \n    function getPair(address _t0, address _t1) external view returns (address pairs); \n    function getReserves(address _lpToken) external view returns (uint256 a, uint256 b); \n    function getToken01(address _pairs) external view returns (address token0, address token1); \n    function getAmountOut(address _tokenIn, address _tokenOut, uint256 _amountOut) external view retu\n    function getAmountIn(address _tokenIn, uint256 _amountIn, address _tokenOut) external view return\n    function getLPTokenAmountInBaseToken(address _lpToken, uint256 _lpTokenAmount, address _baseToken\n    function swapTokenTo(address _tokenIn, uint256 _amountIn, address _tokenOut, address _toAddress) \n \n    function optimalBorrowAmount(address _lpToken, uint256 _amount0, uint256 _amount1) external view \n    function optimalDepositAmount(address lpToken, uint amtA, uint amtB) external view returns (uint \n \n    // pool functions \n    function getDepositToken(uint256 _poolId) external view returns (address lpToken); \n    function getRewardToken(uint256 _poolId) external view returns (address rewardToken); \n    function getPending(uint256 _poolId) external view returns (uint256 rewards); \n    function deposit(uint256 _poolId, bool _autoPool) external returns (uint256 liquidity); \n    function withdraw(uint256 _poolId, uint256 _liquidity, bool _autoPool) external returns (uint256 \n    function claim(uint256 _poolId) external returns (uint256 rewards); \n    function extraRewards() external returns (address token, uint256 rewards); \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n",
            "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n  using SafeMathUpgradeable for uint256; \n \n  function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n    vr = v1 > v2 ? v2 : v1; \n  } \n \n  function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n    vr = v1 > v2 ? v1.sub(v2) : 0; \n  } \n \n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/A\n  function sqrt(uint256 x) internal pure returns (uint256) { \n    if (x == 0) return 0; \n    uint256 xx = x; \n    uint256 r = 1; \n \n    if (xx >= 0x100000000000000000000000000000000) { \n      xx >>= 128; \n      r <<= 64; \n    } \n \n    if (xx >= 0x10000000000000000) { \n      xx >>= 64; \n      r <<= 32; \n    } \n    if (xx >= 0x100000000) { \n      xx >>= 32; \n      r <<= 16; \n    } \n    if (xx >= 0x10000) { \n      xx >>= 16; \n      r <<= 8; \n    } \n    if (xx >= 0x100) { \n      xx >>= 8; \n      r <<= 4; \n    } \n    if (xx >= 0x10) { \n      xx >>= 4; \n      r <<= 2; \n    } \n    if (xx >= 0x8) { \n      r <<= 1; \n    } \n \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; // Seven iterations should be enough \n    uint256 r1 = x / r; \n    return (r < r1 ? r : r1); \n  } \n} \n \n \n",
            "pragma solidity 0.6.12; \n \n \n \n \n// https://www.cherryswap.net/ \n \n// Connecting to third party swap for pool lptoken \ncontract StrategyV2CherrySwapPool is IStrategyV2SwapPool { \n    using SafeMath for uint256; \n    using SafeERC20 for IERC20; \n \n    IUniswapV2Factory public constant factory = IUniswapV2Factory(0x709102921812B3276A65092Fe79eDfc76\n    IUniswapV2Router02 public constant router = IUniswapV2Router02(0x865bfde337C8aFBffF144Ff4C29f9404\n \n    ICherryPool public constant farmpool = ICherryPool(0x8cddB4CD757048C4380ae6A69Db8cD5597442f7b); \n    address public constant swappool = address(0); \n    address public constant rewardToken = address(0x8179D97Eb6488860d816e3EcAFE694a4153F216c); \n \n    address public strategy; \n \n    constructor() public { \n \n    } \n \n    function setStrategy(address _strategy) external override { \n        require(strategy == address(0), 'once'); \n        strategy = _strategy; \n    } \n \n    modifier onlyStrategy() { \n        require(msg.sender == strategy); \n        _; \n    } \n \n    function getName() external override view returns (string memory name) { \n        name = 'cherry'; \n    } \n \n    function getPair(address _t0, address _t1) \n        public override view returns (address pairs) { \n        pairs = factory.getPair(_t0, _t1); \n    } \n \n    function getToken01(address _pairs) \n        public override view returns (address token0, address token1) { \n        token0 = IUniswapV2Pair(_pairs).token0(); \n        token1 = IUniswapV2Pair(_pairs).token1(); \n    } \n \n    function getReserves(address _lpToken) \n        public override view returns (uint256 a, uint256 b) { \n        (a, b, ) = IUniswapV2Pair(_lpToken).getReserves(); \n    } \n \n    function getAmountOut(address _tokenIn, address _tokenOut, uint256 _amountOut) \n        external override view returns (uint256) { \n        if(_tokenIn == _tokenOut) { \n            return _amountOut; \n        } \n        if(_amountOut == 0) { \n            return 0; \n        } \n        address[] memory path = new address[](2); \n        path[0] = _tokenIn; \n        path[1] = _tokenOut; \n        uint256[] memory result = router.getAmountsIn(_amountOut, path); \n        if(result.length == 0) { \n            return 0; \n        } \n        return result[0]; \n    } \n \n    function getAmountIn(address _tokenIn, uint256 _amountIn, address _tokenOut) \n        public override view returns (uint256) { \n        if(_tokenIn == _tokenOut) { \n            return _amountIn; \n        } \n        if(_amountIn == 0) { \n            return 0; \n        } \n        address[] memory path = new address[](2); \n        path[0] = _tokenIn; \n        path[1] = _tokenOut; \n        uint256[] memory result = router.getAmountsOut(_amountIn, path); \n        if(result.length == 0) { \n            return 0; \n        } \n        return result[result.length-1]; \n    } \n \n    function getLPTokenAmountInBaseToken(address _lpToken, uint256 _lpTokenAmount, address _baseToken\n        external override view returns (uint256 amount) { \n        (uint256 a, uint256 b) = getReserves(_lpToken); \n        (address token0, address token1) = getToken01(_lpToken); \n        uint256 totalSupply = IERC20(_lpToken).totalSupply(); \n        if(token0 == _baseToken) { \n            amount = _lpTokenAmount.mul(a).div(totalSupply).mul(2); \n        }else if(token1 == _baseToken) { \n            amount = _lpTokenAmount.mul(b).div(totalSupply).mul(2); \n        } \n        else{ \n            require(false, 'unsupport baseToken not in pairs'); \n        } \n    } \n \n    function swapTokenTo(address _tokenIn, uint256 _amountIn, address _tokenOut, address _toAddress) \n        public override onlyStrategy returns (uint256) { \n        if(_tokenIn == _tokenOut) { \n            return _safeTransferAll(_tokenOut, _toAddress); \n        } \n        if(_amountIn == 0 || getAmountIn(_tokenIn, _amountIn, _tokenOut) <= 0) { \n            return 0; \n        } \n        address[] memory path = new address[](2); \n        path[0] = _tokenIn; \n        path[1] = _tokenOut; \n        IERC20(_tokenIn).approve(address(router), _amountIn); \n        uint256[] memory result = router.swapExactTokensForTokens(_amountIn, 0, path, _toAddress, blo\n        if(result.length == 0) { \n            return 0; \n        } else { \n            return result[result.length-1]; \n        } \n    } \n \n    function optimalBorrowAmount(address _lpToken, uint256 _amount0, uint256 _amount1) \n        external view override returns (uint256 borrow0, uint256 borrow1) { \n        (uint256 a, uint256 b) = getReserves(_lpToken); \n        if (a.mul(_amount1) >= b.mul(_amount0)) { \n            borrow0 = _amount1.mul(a).div(b).sub(_amount0); \n            borrow1 = 0; \n        } else { \n            borrow0 = 0; \n            borrow1 = _amount0.mul(b).div(a).sub(_amount1); \n        } \n    } \n \n    /// @dev Compute optimal deposit amount \n    /// @param lpToken amount \n    /// @param amtA amount of token A desired to deposit \n    /// @param amtB amount of token B desired to deposit \n    function optimalDepositAmount( \n        address lpToken, \n        uint amtA, \n        uint amtB \n    ) public override view returns (uint swapAmt, bool isReversed) { \n        (uint256 resA, uint256 resB) = getReserves(lpToken); \n        if (amtA.mul(resB) >= amtB.mul(resA)) { \n            swapAmt = _optimalDepositA(amtA, amtB, resA, resB); \n            isReversed = false; \n        } else { \n            swapAmt = _optimalDepositA(amtB, amtA, resB, resA); \n            isReversed = true; \n        } \n    } \n \n    /// @dev Compute optimal deposit amount helper. \n    /// @param amtA amount of token A desired to deposit \n    /// @param amtB amount of token B desired to deposit \n    /// @param resA amount of token A in reserve \n    /// @param resB amount of token B in reserve \n    /// Formula: https://blog.alphafinance.io/byot/ \n    function _optimalDepositA( \n        uint amtA, \n        uint amtB, \n        uint resA, \n        uint resB \n    ) internal pure returns (uint) { \n        require(amtA.mul(resB) >= amtB.mul(resA), 'Reversed'); \n        uint a = 997; \n        uint b = uint(1997).mul(resA); \n        uint _c = (amtA.mul(resB)).sub(amtB.mul(resA)); \n        uint c = _c.mul(1000).div(amtB.add(resB)).mul(resA); \n        uint d = a.mul(c).mul(4); \n        uint e = TenMath.sqrt(b.mul(b).add(d)); \n        uint numerator = e.sub(b); \n        uint denominator = a.mul(2); \n        return numerator.div(denominator); \n    } \n \n    function getDepositToken(uint256 _poolId) \n        public override view returns (address lpToken) { \n        (lpToken,,) = farmpool.poolInfo(_poolId); \n    } \n \n    function getRewardToken(uint256 _poolId) \n        external override view returns (address returnToken) { \n        return rewardToken; \n    } \n \n    function getPending(uint256 _poolId) external override view returns (uint256 rewards) { \n        rewards = farmpool.pendingCherry(_poolId, address(this)); \n    } \n \n    function deposit(uint256 _poolId, bool _autoPool) \n        external override onlyStrategy returns (uint256 liquidity) { \n        address lpToken = getDepositToken(_poolId); \n        (address tokenA, address tokenB) = getToken01(lpToken); \n        uint256 amountA; \n        uint256 amountB; \n        amountA = IERC20(tokenA).balanceOf(address(this)); \n        amountB = IERC20(tokenB).balanceOf(address(this)); \n        (uint256 swapAmt, bool isReversed) = optimalDepositAmount(lpToken, amountA, amountB); \n        if(swapAmt > 0) { \n            swapTokenTo(isReversed?tokenB:tokenA, swapAmt, isReversed?tokenA:tokenB, address(this)); \n        } \n        amountA = IERC20(tokenA).balanceOf(address(this)); \n        amountB = IERC20(tokenB).balanceOf(address(this)); \n        if(amountA > 0 && amountB > 0) { \n            IERC20(tokenA).approve(address(router), amountA); \n            IERC20(tokenB).approve(address(router), amountB); \n            router.addLiquidity(tokenA, tokenB, \n                                amountA, amountB, \n                                0, 0, \n                                address(this), block.timestamp.add(60)); \n            liquidity = IERC20(lpToken).balanceOf(address(this)); \n            if(liquidity > 0 && _autoPool) { \n                IERC20(lpToken).approve(address(farmpool), liquidity); \n                farmpool.deposit(_poolId, liquidity); \n            } \n        } \n        _safeTransferAll(lpToken, strategy); \n        _safeTransferAll(tokenA, strategy); \n        _safeTransferAll(tokenB, strategy); \n    } \n \n    function withdraw(uint256 _poolId, uint256 _liquidity, bool _autoPool) \n        external override onlyStrategy returns (uint256 amountA, uint256 amountB) { \n        if(_liquidity <= 0) return (0, 0); \n        if(_autoPool) { \n            farmpool.withdraw(_poolId, _liquidity); \n        } \n        address lpToken = getDepositToken(_poolId); \n        (address tokenA, address tokenB) = getToken01(lpToken); \n        IERC20(lpToken).approve(address(router), _liquidity); \n        router.removeLiquidity(tokenA, tokenB, \n                            _liquidity, \n                            0, 0, \n                            strategy, block.timestamp.add(60)); \n        amountA = _safeTransferAll(tokenA, strategy); \n        amountB = _safeTransferAll(tokenB, strategy); \n    } \n \n"
        ]
    },
    {
        "PdfName": "DekBox_audit.pdf",
        "Code": [
            "pragma solidity ^0.5.16; \npragma experimental ABIEncoderV2; \n \ncontract Comp { \n    /// @notice EIP-20 token name for this token \n    string public constant name = \"DekBox\"; \n \n    /// @notice EIP-20 token symbol for this token \n    string public constant symbol = \"DEK\"; \n \n    /// @notice EIP-20 token decimals for this token \n    uint8 public constant decimals = 18; \n \n    /// @notice Total number of tokens in circulation \n    uint256 public constant totalSupply = 90000000e18; // 1 billion comp \n \n    /// @notice Allowance amounts on behalf of others \n    mapping(address => mapping(address => uint96)) internal allowances; \n \n    /// @notice Official record of token balances for each account \n    mapping(address => uint96) internal balances; \n \n    /// @notice A record of each accounts delegate \n    mapping(address => address) public delegates; \n \n    /// @notice A checkpoint for marking number of votes from a given block \n    struct Checkpoint { \n        uint32 fromBlock; \n        uint96 votes; \n    } \n \n    /// @notice A record of votes checkpoints for each account, by index \n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints; \n \n    /// @notice The number of checkpoints for each account \n    mapping(address => uint32) public numCheckpoints; \n \n    /// @notice The EIP-712 typehash for the contract's domain \n    bytes32 public constant DOMAIN_TYPEHASH = \n        keccak256( \n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\" \n        ); \n \n    /// @notice The EIP-712 typehash for the delegation struct used by the contract \n    bytes32 public constant DELEGATION_TYPEHASH = \n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\"); \n \n    /// @notice A record of states for signing / validating signatures \n    mapping(address => uint256) public nonces; \n \n    /// @notice An event thats emitted when an account changes its delegate \n    event DelegateChanged( \n        address indexed delegator, \n        address indexed fromDelegate, \n        address indexed toDelegate \n    ); \n \n    /// @notice An event thats emitted when a delegate account's vote balance changes \n    event DelegateVotesChanged( \n        address indexed delegate, \n        uint256 previousBalance, \n        uint256 newBalance \n    ); \n \n    /// @notice The standard EIP-20 transfer event \n    event Transfer(address indexed from, address indexed to, uint256 amount); \n \n    /// @notice The standard EIP-20 approval event \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 amount \n    ); \n \n    /** \n     * @notice Construct a new comp token \n     * @param account The initial account to grant all the tokens \n     */ \n    constructor(address account) public { \n        balances[account] = uint96(totalSupply); \n        emit Transfer(address(0), account, totalSupply); \n    } \n \n    /** \n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account` \n     * @param account The address of the account holding the funds \n     * @param spender The address of the account spending the funds \n     * @return The number of tokens approved \n     */ \n    function allowance(address account, address spender) \n        external \n        view \n        returns (uint256) \n    { \n        return allowances[account][spender]; \n    } \n \n    /** \n     * @notice Approve `spender` to transfer up to `amount` from `src` \n     * @dev This will overwrite the approval amount for `spender` \n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) \n     * @param spender The address of the account which may transfer tokens \n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite) \n     * @return Whether or not the approval succeeded \n     */ \n    function approve(address spender, uint256 rawAmount) \n        external \n        returns (bool) \n    { \n        uint96 amount; \n        if (rawAmount == uint256(-1)) { \n            amount = uint96(-1); \n        } else { \n            amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\"); \n        } \n \n        allowances[msg.sender][spender] = amount; \n \n        emit Approval(msg.sender, spender, amount); \n        return true; \n    } \n \n    /** \n     * @notice Get the number of tokens held by the `account` \n     * @param account The address of the account to get the balance of \n     * @return The number of tokens held \n     */ \n    function balanceOf(address account) external view returns (uint256) { \n        return balances[account]; \n    } \n \n    /** \n     * @notice Transfer `amount` tokens from `msg.sender` to `dst` \n     * @param dst The address of the destination account \n     * @param rawAmount The number of tokens to transfer \n     * @return Whether or not the transfer succeeded \n     */ \n    function transfer(address dst, uint256 rawAmount) external returns (bool) { \n        uint96 amount = \n            safe96(rawAmount, \"Comp::transfer: amount exceeds 96 bits\"); \n        _transferTokens(msg.sender, dst, amount); \n        return true; \n    } \n \n    /** \n     * @notice Transfer `amount` tokens from `src` to `dst` \n     * @param src The address of the source account \n     * @param dst The address of the destination account \n     * @param rawAmount The number of tokens to transfer \n     * @return Whether or not the transfer succeeded \n     */ \n    function transferFrom( \n        address src, \n        address dst, \n        uint256 rawAmount \n    ) external returns (bool) { \n        address spender = msg.sender; \n        uint96 spenderAllowance = allowances[src][spender]; \n        uint96 amount = \n            safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\"); \n \n        if (spender != src && spenderAllowance != uint96(-1)) { \n            uint96 newAllowance = \n                sub96( \n                    spenderAllowance, \n                    amount, \n                    \"Comp::transferFrom: transfer amount exceeds spender allowance\" \n                ); \n            allowances[src][spender] = newAllowance; \n \n            emit Approval(src, spender, newAllowance); \n        } \n \n        _transferTokens(src, dst, amount); \n        return true; \n    } \n \n    /** \n     * @notice Delegate votes from `msg.sender` to `delegatee` \n     * @param delegatee The address to delegate votes to \n     */ \n    function delegate(address delegatee) public { \n        return _delegate(msg.sender, delegatee); \n    } \n \n    /** \n     * @notice Delegates votes from signatory to `delegatee` \n     * @param delegatee The address to delegate votes to \n     * @param nonce The contract state required to match the signature \n     * @param expiry The time at which to expire the signature \n     * @param v The recovery byte of the signature \n     * @param r Half of the ECDSA signature pair \n     * @param s Half of the ECDSA signature pair \n     */ \n    function delegateBySig( \n        address delegatee, \n        uint256 nonce, \n        uint256 expiry, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) public { \n        bytes32 domainSeparator = \n            keccak256( \n                abi.encode( \n                    DOMAIN_TYPEHASH, \n                    keccak256(bytes(name)), \n                    getChainId(), \n                    address(this) \n                ) \n            ); \n        bytes32 structHash = \n            keccak256( \n                abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry) \n            ); \n        bytes32 digest = \n            keccak256( \n                abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash) \n            ); \n        address signatory = ecrecover(digest, v, r, s); \n        require( \n            signatory != address(0), \n            \"Comp::delegateBySig: invalid signature\" \n        ); \n        require( \n            nonce == nonces[signatory]++, \n            \"Comp::delegateBySig: invalid nonce\" \n        ); \n        require(now <= expiry, \"Comp::delegateBySig: signature expired\"); \n        return _delegate(signatory, delegatee); \n    } \n \n    /** \n     * @notice Gets the current votes balance for `account` \n     * @param account The address to get votes balance \n     * @return The number of current votes for `account` \n     */ \n    function getCurrentVotes(address account) external view returns (uint96) { \n        uint32 nCheckpoints = numCheckpoints[account]; \n        return \n            nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0; \n    } \n \n    /** \n     * @notice Determine the prior number of votes for an account as of a block number \n     * @dev Block number must be a finalized block or else this function will revert to prevent misin\n     * @param account The address of the account to check \n     * @param blockNumber The block number to get the vote balance at \n     * @return The number of votes the account had as of the given block \n     */ \n    function getPriorVotes(address account, uint256 blockNumber) \n        public \n        view \n        returns (uint96) \n    { \n        require( \n            blockNumber < block.number, \n            \"Comp::getPriorVotes: not yet determined\" \n        ); \n \n        uint32 nCheckpoints = numCheckpoints[account]; \n        if (nCheckpoints == 0) { \n            return 0; \n        } \n \n        // First check most recent balance \n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) { \n            return checkpoints[account][nCheckpoints - 1].votes; \n        } \n \n        // Next check implicit zero balance \n        if (checkpoints[account][0].fromBlock > blockNumber) { \n            return 0; \n        } \n \n        uint32 lower = 0; \n        uint32 upper = nCheckpoints - 1; \n        while (upper > lower) { \n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow \n            Checkpoint memory cp = checkpoints[account][center]; \n            if (cp.fromBlock == blockNumber) { \n                return cp.votes; \n            } else if (cp.fromBlock < blockNumber) { \n                lower = center; \n            } else { \n                upper = center - 1; \n            } \n        } \n        return checkpoints[account][lower].votes; \n    } \n \n    function _delegate(address delegator, address delegatee) internal { \n        address currentDelegate = delegates[delegator]; \n        uint96 delegatorBalance = balances[delegator]; \n        delegates[delegator] = delegatee; \n \n        emit DelegateChanged(delegator, currentDelegate, delegatee); \n \n        _moveDelegates(currentDelegate, delegatee, delegatorBalance); \n    } \n \n    function _transferTokens( \n        address src, \n        address dst, \n        uint96 amount \n    ) internal { \n        require( \n            src != address(0), \n            \"Comp::_transferTokens: cannot transfer from the zero address\" \n        ); \n        require( \n            dst != address(0), \n            \"Comp::_transferTokens: cannot transfer to the zero address\" \n        ); \n \n        balances[src] = sub96( \n            balances[src], \n            amount, \n            \"Comp::_transferTokens: transfer amount exceeds balance\" \n        ); \n        balances[dst] = add96( \n            balances[dst], \n            amount, \n            \"Comp::_transferTokens: transfer amount overflows\" \n        ); \n        emit Transfer(src, dst, amount); \n \n        _moveDelegates(delegates[src], delegates[dst], amount); \n    } \n \n    function _moveDelegates( \n        address srcRep, \n        address dstRep, \n        uint96 amount \n    ) internal { \n        if (srcRep != dstRep && amount > 0) { \n            if (srcRep != address(0)) { \n                uint32 srcRepNum = numCheckpoints[srcRep]; \n                uint96 srcRepOld = \n                    srcRepNum > 0 \n                        ? checkpoints[srcRep][srcRepNum - 1].votes \n                        : 0; \n                uint96 srcRepNew = \n                    sub96( \n                        srcRepOld, \n                        amount, \n                        \"Comp::_moveVotes: vote amount underflows\" \n                    ); \n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew); \n            } \n \n            if (dstRep != address(0)) { \n                uint32 dstRepNum = numCheckpoints[dstRep]; \n                uint96 dstRepOld = \n                    dstRepNum > 0 \n                        ? checkpoints[dstRep][dstRepNum - 1].votes \n                        : 0; \n                uint96 dstRepNew = \n                    add96( \n                        dstRepOld, \n                        amount, \n                        \"Comp::_moveVotes: vote amount overflows\" \n                    ); \n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew); \n            } \n        } \n    } \n \n    function _writeCheckpoint( \n        address delegatee, \n        uint32 nCheckpoints, \n        uint96 oldVotes, \n        uint96 newVotes \n    ) internal { \n        uint32 blockNumber = \n            safe32( \n                block.number, \n                \"Comp::_writeCheckpoint: block number exceeds 32 bits\" \n            ); \n \n        if ( \n            nCheckpoints > 0 && \n            checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber \nMastChef.sol\n        ) { \n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes; \n        } else { \n            checkpoints[delegatee][nCheckpoints] = Checkpoint( \n                blockNumber, \n                newVotes \n            ); \n            numCheckpoints[delegatee] = nCheckpoints + 1; \n        } \n \n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes); \n    } \n \n    function safe32(uint256 n, string memory errorMessage) \n        internal \n        pure \n        returns (uint32) \n    { \n        require(n < 2**32, errorMessage); \n        return uint32(n); \n    } \n \n    function safe96(uint256 n, string memory errorMessage) \n        internal \n        pure \n        returns (uint96) \n    { \n        require(n < 2**96, errorMessage); \n        return uint96(n); \n    } \n \n    function add96( \n        uint96 a, \n        uint96 b, \n        string memory errorMessage \n    ) internal pure returns (uint96) { \n        uint96 c = a + b; \n        require(c >= a, errorMessage); \n        return c; \n    } \n \n    function sub96( \n        uint96 a, \n        uint96 b, \n        string memory errorMessage \n    ) internal pure returns (uint96) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    function getChainId() internal pure returns (uint256) { \n        uint256 chainId; \n        assembly { \n            chainId := chainid() \n        } \n        return chainId; \n    } \n} \n",
            "pragma solidity ^0.6.0; \n \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \ncontract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the multiplicarion of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplicarion cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplicarion overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers. Reverts on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * Reverts when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * Reverts with custom message when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n} \n \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts \n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned \n        // for accounts without code, i.e. `keccak256('')` \n        bytes32 codehash; \n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { codehash := extcodehash(account) } \n        return (codehash != accountHash && codehash != 0x0); \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return _functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        return _functionCallWithValue(target, data, value, errorMessage); \n    } \n \n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memor\n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data); \n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicaring whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicaring whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicaring whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecared. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \ninterface IMigratorChef { \n    // Perform LP token migration from legacy UniswapV2 to Swap. \n    // Take the current LP token address and return the new LP token address. \n    // Migrator should have full access to the caller's LP token. \n    // Return the new LP token address. \n    // \n    // XXX Migrator must have allowance access to UniswapV2 LP tokens. \n    // Swap must mint EXACTLY the same amount of Swap LP tokens or \n    // else something bad will happen. Traditional UniswapV2 does not \n    // do that so be careful! \n    function migrate(IERC20 token) external returns (IERC20); \n} \n \ncontract MasterChef is Ownable { \n    using SafeMath for uint256; \n    using SafeERC20 for IERC20; \n \n    // Info of each user. \n    struct UserInfo { \n        uint256 amount;     // How many LP tokens the user has provided. \n        uint256 rewardDebt; // Reward debt. See explanation below. \n        // \n        // We do some fancy math here. Basically, any point in time, the amount of DEKs \n        // entitled to a user but is pending to be distributed is: \n        // \n        //   pending reward = (user.amount * pool.accDekPerShare) - user.rewardDebt \n        // \n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens: \n        //   1. The pool's `accDekPerShare` (and `lastRewardBlock`) gets updated. \n        //   2. User receives the pending reward sent to his/her address. \n        //   3. User's `amount` gets updated. \n        //   4. User's `rewardDebt` gets updated. \n    } \n \n    // Info of each pool. \n    struct PoolInfo { \n        IERC20 lpToken;           // Address of LP token contract. \n        uint256 allocPoint;       // How many allocarion points assigned to this pool. DEKs to distri\n        uint256 lastRewardBlock;  // Last block number that DEKs distribution occurs. \n        uint256 accDekPerShare; // Accumulated DEKs per share, times 1e12. See below. \n    } \n \n    // The DEK TOKEN! \n    IERC20 public DEK; \n    // DEK tokens created per block. \n    uint256 public dekPerBlock; \n    // The migrator contract. It has a lot of power. Can only be set through governance (owner). \n    IMigratorChef public migrator; \n \n    // Info of each pool. \n    PoolInfo[] public poolInfo; \n    // Info of each user that stakes LP tokens. \n    mapping (uint256 => mapping (address => UserInfo)) public userInfo; \n    // Total allocarion poitns. Must be the sum of all allocarion points in all pools. \n    uint256 public totalAllocPoint = 0; \n    // The block number when dek mining starts. \n    uint256 public startBlock; \n    uint256 public mintDEK = 0; \n \n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount); \n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount); \n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount); \n \n    constructor( \n        IERC20 _dek, \n        uint256 _dekPerBlock, \n        uint256 _startBlock \n    ) public { \n        DEK = _dek; \n        dekPerBlock = _dekPerBlock; \n        startBlock = _startBlock; \n    } \n \n    function poolLength() external view returns (uint256) { \n        return poolInfo.length; \n    } \n \n    // Add a new lp to the pool. Can only be called by the owner. \n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do. \n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { \n        if (_withUpdate) { \n            massUpdatePools(); \n        } \n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; \n        totalAllocPoint = totalAllocPoint.add(_allocPoint); \n        poolInfo.push(PoolInfo({ \n            lpToken: _lpToken, \n            allocPoint: _allocPoint, \n            lastRewardBlock: lastRewardBlock, \n            accDekPerShare: 0 \n        })); \n    } \n \n    // Update the given pool's Dek allocarion point. Can only be called by the owner. \n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { \n        if (_withUpdate) { \n            massUpdatePools(); \n        } \n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); \n        poolInfo[_pid].allocPoint = _allocPoint; \n    } \n \n    //set dekPerBlock \n    function setPerParam(uint256 _amount, bool _withUpdate) public onlyOwner { \n        if (_withUpdate) { \n            massUpdatePools(); \n        } \n        dekPerBlock = _amount; \n    } \n \n    // Set the migrator contract. Can only be called by the owner. \n    function setMigrator(IMigratorChef _migrator) public onlyOwner { \n        migrator = _migrator; \n    } \n \n    // Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contr\n    function migrate(uint256 _pid) public { \n        require(address(migrator) != address(0), \"migrate: no migrator\"); \n        PoolInfo storage pool = poolInfo[_pid]; \n        IERC20 lpToken = pool.lpToken; \n        uint256 bal = lpToken.balanceOf(address(this)); \n        lpToken.safeApprove(address(migrator), bal); \n        IERC20 newLpToken = migrator.migrate(lpToken); \n        require(bal == newLpToken.balanceOf(address(this)), \"migrate: bad\"); \n        pool.lpToken = newLpToken; \n    } \n \n    // Return reward multiplier over the given _from to _to block. \n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { \n        return _to.sub(_from); \n    } \n \n    // View function to see pending Deks on frontend. \n    function pendingDek(uint256 _pid, address _user) external view returns (uint256) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][_user]; \n        uint256 accDekPerShare = pool.accDekPerShare; \n        uint256 lpSupply = pool.lpToken.balanceOf(address(this)); \n        if (block.number > pool.lastRewardBlock && lpSupply != 0) { \n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); \n            uint256 dekReward = multiplier.mul(dekPerBlock).mul(pool.allocPoint).div(totalAllocPoint)\n            accDekPerShare = accDekPerShare.add(dekReward.mul(1e12).div(lpSupply)); \n        } \n        return user.amount.mul(accDekPerShare).div(1e12).sub(user.rewardDebt); \n    } \n \n    // Update reward vairables for all pools. Be careful of gas spending! \n    function massUpdatePools() public { \n        uint256 length = poolInfo.length; \n        for (uint256 pid = 0; pid < length; ++pid) { \n            updatePool(pid); \n        } \n    } \n \n    // Update reward variables of the given pool to be up-to-date. \n    function updatePool(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        if (block.number <= pool.lastRewardBlock) { \n            return; \n        } \n        uint256 lpSupply = pool.lpToken.balanceOf(address(this)); \n        if (lpSupply == 0) { \n            pool.lastRewardBlock = block.number; \n            return; \n        } \n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); \n        uint256 dekReward = multiplier.mul(dekPerBlock).mul(pool.allocPoint).div(totalAllocPoint); \n        // DEK.mint(address(this), dekReward); \n        mintDEK = mintDEK.add(dekReward); \n        require(DEK.balanceOf(address(this)) >= mintDEK, \"not enough DEK in contract\"); \n        pool.accDekPerShare = pool.accDekPerShare.add(dekReward.mul(1e12).div(lpSupply)); \n        pool.lastRewardBlock = block.number; \n    } \n \n    // Deposit LP tokens to MasterChef for Dek allocarion. \n    function deposit(uint256 _pid, uint256 _amount) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        updatePool(_pid); \n        if (user.amount > 0) { \n            uint256 pending = user.amount.mul(pool.accDekPerShare).div(1e12).sub(user.rewardDebt); \n            safeDekTransfer(msg.sender, pending); \n        } \n        pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); \n        user.amount = user.amount.add(_amount); \n        user.rewardDebt = user.amount.mul(pool.accDekPerShare).div(1e12); \n        emit Deposit(msg.sender, _pid, _amount); \n    } \n \nTimelock.sol\n    // Withdraw LP tokens from MasterChef. \n    function withdraw(uint256 _pid, uint256 _amount) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        require(user.amount >= _amount, \"withdraw: not good\"); \n        updatePool(_pid); \n        uint256 pending = user.amount.mul(pool.accDekPerShare).div(1e12).sub(user.rewardDebt); \n        safeDekTransfer(msg.sender, pending); \n        user.amount = user.amount.sub(_amount); \n        user.rewardDebt = user.amount.mul(pool.accDekPerShare).div(1e12); \n        pool.lpToken.safeTransfer(address(msg.sender), _amount); \n        emit Withdraw(msg.sender, _pid, _amount); \n    } \n \n    // Withdraw without caring about rewards. EMERGENCY ONLY. \n    function emergencyWithdraw(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        pool.lpToken.safeTransfer(address(msg.sender), user.amount); \n        emit EmergencyWithdraw(msg.sender, _pid, user.amount); \n        user.amount = 0; \n        user.rewardDebt = 0; \n    } \n \n    // Safe Dek transfer function, just in case if rounding error causes pool to not have enough Deks\n    function safeDekTransfer(address _to, uint256 _amount) internal { \n        uint256 dekBal = DEK.balanceOf(address(this)); \n        if (_amount > dekBal) { \n            mintDEK.sub(dekBal); \n            DEK.safeTransfer(_to, dekBal); \n        } else { \n            mintDEK.sub(_amount); \n            DEK.safeTransfer(_to, _amount); \n        } \n    } \n}\n// File: contracts/SafeMath.sol \n \n",
            "pragma solidity ^0.5.16; \n \n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol \n// Subject to the MIT license. \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * - Addition cannot overflow. \n     */ \n    function add( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, errorMessage); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * - Subtraction cannot underflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction underflow\"); \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underf\n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * - Subtraction cannot underflow. \n     */ \n    function sub( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * - Multiplication cannot overflow. \n     */ \n    function mul( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, errorMessage); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers. \n     * Reverts on division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers. \n     * Reverts with custom message on division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * - The divisor cannot be zero. \n     */ \n    function div( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * Reverts when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * Reverts with custom message when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * - The divisor cannot be zero. \n     */ \n    function mod( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n} \n \n// File: contracts/Timelock.sol \n \n",
            "pragma solidity ^0.5.16; \n \ncontract Timelock { \n    using SafeMath for uint256; \n \n    event NewAdmin(address indexed newAdmin); \n    event NewPendingAdmin(address indexed newPendingAdmin); \n    event NewDelay(uint256 indexed newDelay); \n    event CancelTransaction( \n        bytes32 indexed txHash, \n        address indexed target, \n        uint256 value, \n        string signature, \n        bytes data, \n        uint256 eta \n    ); \n    event ExecuteTransaction( \n        bytes32 indexed txHash, \n        address indexed target, \n        uint256 value, \n        string signature, \n        bytes data, \n        uint256 eta \n    ); \n    event QueueTransaction( \n        bytes32 indexed txHash, \n        address indexed target, \n        uint256 value, \n        string signature, \n        bytes data, \n        uint256 eta \n    ); \n \n    uint256 public constant GRACE_PERIOD = 5000 seconds; \n    uint256 public constant MINIMUM_DELAY = 60 seconds; \n    uint256 public constant MAXIMUM_DELAY = 500 seconds; \n \n    address public admin; \n    address public pendingAdmin; \n    uint256 public delay; \n    bool public admin_initialized; \n \n    mapping(bytes32 => bool) public queuedTransactions; \n \n    constructor(address admin_, uint256 delay_) public { \n        require( \n            delay_ >= MINIMUM_DELAY, \n            \"Timelock::constructor: Delay must exceed minimum delay.\" \n        ); \n        require( \n            delay_ <= MAXIMUM_DELAY, \n            \"Timelock::constructor: Delay must not exceed maximum delay.\" \n        ); \n \n        admin = admin_; \n        delay = delay_; \n        admin_initialized = false; \n    } \n \n    function() external payable {} \n \n    function setDelay(uint256 delay_) public { \n        require( \n            msg.sender == address(this), \n            \"Timelock::setDelay: Call must come from Timelock.\" \n        ); \n        require( \n            delay_ >= MINIMUM_DELAY, \n            \"Timelock::setDelay: Delay must exceed minimum delay.\" \n        ); \n        require( \n            delay_ <= MAXIMUM_DELAY, \n            \"Timelock::setDelay: Delay must not exceed maximum delay.\" \n        ); \n        delay = delay_; \n \n        emit NewDelay(delay); \n    } \n \n    function acceptAdmin() public { \n        require( \n            msg.sender == pendingAdmin, \n            \"Timelock::acceptAdmin: Call must come from pendingAdmin.\" \n        ); \n        admin = msg.sender; \n        pendingAdmin = address(0); \n \n        emit NewAdmin(admin); \n    } \n \n    function setPendingAdmin(address pendingAdmin_) public { \n        // allows one time setting of admin for deployment purposes \n        if (admin_initialized) { \n            require( \n                msg.sender == address(this), \n                \"Timelock::setPendingAdmin: Call must come from Timelock.\" \n            ); \n        } else { \n            require( \n                msg.sender == admin, \n                \"Timelock::setPendingAdmin: First call must come from admin.\" \n            ); \n            admin_initialized = true; \n        } \n        pendingAdmin = pendingAdmin_; \n \n        emit NewPendingAdmin(pendingAdmin); \n    } \n \n    function queueTransaction( \n        address target, \n        uint256 value, \n        string memory signature, \n        bytes memory data, \n        uint256 eta \n    ) public returns (bytes32) { \n        require( \n            msg.sender == admin, \n            \"Timelock::queueTransaction: Call must come from admin.\" \n        ); \n        require( \n            eta >= getBlockTimestamp().add(delay), \n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\" \n        ); \n \n        bytes32 txHash = \n            keccak256(abi.encode(target, value, signature, data, eta)); \n        queuedTransactions[txHash] = true; \n \n        emit QueueTransaction(txHash, target, value, signature, data, eta); \n        return txHash; \n    } \n \n    function cancelTransaction( \n        address target, \n        uint256 value, \n        string memory signature, \n        bytes memory data, \n        uint256 eta \n    ) public { \n        require( \n            msg.sender == admin, \n            \"Timelock::cancelTransaction: Call must come from admin.\" \n        ); \n \n        bytes32 txHash = \n            keccak256(abi.encode(target, value, signature, data, eta)); \n        queuedTransactions[txHash] = false; \n \n        emit CancelTransaction(txHash, target, value, signature, data, eta); \n    } \n \n    function executeTransaction( \n        address target, \n        uint256 value, \n        string memory signature, \n        bytes memory data, \n        uint256 eta \n    ) public payable returns (bytes memory) { \n        require( \n            msg.sender == admin, \n            \"Timelock::executeTransaction: Call must come from admin.\" \n        ); \n \n        bytes32 txHash = \n            keccak256(abi.encode(target, value, signature, data, eta)); \n        require( \n            queuedTransactions[txHash], \n            \"Timelock::executeTransaction: Transaction hasn't been queued.\" \n        ); \n        require( \n            getBlockTimestamp() >= eta, \n            \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\" \n        ); \n        require( \n            getBlockTimestamp() <= eta.add(GRACE_PERIOD), \n            \"Timelock::executeTransaction: Transaction is stale.\" \n        ); \n \n        queuedTransactions[txHash] = false; \n \n        bytes memory callData; \n \n        if (bytes(signature).length == 0) { \n            callData = data; \n        } else { \n            callData = abi.encodePacked( \n                bytes4(keccak256(bytes(signature))), \n                data \n            ); \n        } \n \n        // solium-disable-next-line security/no-call-value \n        (bool success, bytes memory returnData) = \n            target.call.value(value)(callData); \n        require( \n            success, \n            \"Timelock::executeTransaction: Transaction execution reverted.\" \n        ); \n \n        emit ExecuteTransaction(txHash, target, value, signature, data, eta); \n \n        return returnData; \n    } \n \n    function getBlockTimestamp() internal view returns (uint256) { \n        // solium-disable-next-line security/no-block-members \n        return block.timestamp; \n"
        ]
    },
    {
        "PdfName": "EarthFundBonding_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/utils/Address.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/utils/math/Math.sol\"; \nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; \nimport \"@openzeppelin/contracts/utils/Counters.sol\"; \n \n/* \n * 1EARTH bonding contract \n * This contract allows users to \"bond\" USDT or ETH for the 1EARTH token. This means that \n * users can purchase 1EARTH at a variable rate with either USDT or ETH, and the resulting \n * token vests over a predetermined amount of time. Users are then able to claim these tokens. \n * \n * Funds received from this contract are sent to the EarthFund DAO Treasury, where DAO members will \n * will vote as to where they are distributed \n */ \ncontract EarthFundBonding is Ownable { \n    using SafeERC20 for IERC20; \n    using SafeMath for uint256; \n \n    /* ======== EVENTS ======== */ \n \n    event BondCreated( \n        uint256 deposit, \n        uint256 indexed payout, \n        uint256 indexed expires, \n        uint256 indexed price \n    ); \n \n    event BondRedeemed( \n        address indexed recipient, \n        uint256 payout, \n        uint256 remaining \n    ); \n \n    event BondPriceChanged( \n        uint256 indexed bondIndex, \n        uint256 indexed internalPrice, \n        uint256 indexed debtRatio \n    ); \n \n    event ControlVariableAdjustment( \n        uint256 initialBCV, \n        uint256 newBCV, \n        uint256 adjustment, \n        bool addition \n    ); \n \n    /* ======== STRUCTS ======== */ \n \n    // Info for bond holder \n    struct Bond { \n        uint256 payout; // earthFundToken remaining to be paid \n        uint256 vesting; // Blocks left to vest \n        uint256 lastBlock; // Last interaction \n        uint256 pricePaid; // In DAI, for front end viewing \n    } \n \n    // Info for specific bond pairs \n    struct BondPair { \n        string name; // Currency that user is paying with \n        bool active; // Bool to see if bonds are accepting deposits \n        uint256 currentPrice; // Current price of the bond \n        uint256 decimals; // Number of decimals to get to the smallest denomination of the base curre\n        uint256 lastDecay; // Last block that pair was purchased \n        uint256 incrementRate; // Rate to increment in smallest denomination (wei for ETH, etc.) \n        uint256 decrementRate; // Rate to increment in smallest denomination (wei for ETH, etc.) \n        uint256 vestingTerm; // in blocks \n        uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5% \n        uint256 buffer; // How long to wait before adjusting the price, in blocks \n    } \n \n    /* ======== STATE VARIABLES ======== */ \n \n    address public immutable earthFundToken; // token given as payment for bond \n    address payable public immutable treasury; // EarthFund DAO Treasury address \n \n    address public staking; // to auto-stake payout \n    address public stakingHelper; // to stake and claim if no staking warmup \n    bool public useHelper; \n \n    BondPair[] public bondPairs; // stores bond pairs, as well as their adjustment variables \n \n    mapping(address => mapping(uint256 => Bond)) public bondInfo; // stores bond information for depo\n    mapping(string => address) public erc20TokensAddresses; // stores ERC20 token addresses for addit\n \n    constructor( \n        address _earthFundToken, // token given as payment for bond \n        address payable _treasury // receives profit share from bond \n    ) { \n        require(_earthFundToken != address(0)); \n        earthFundToken = _earthFundToken; \n \n        require(_treasury != address(0)); \n        treasury = _treasury; \n    } \n \n    /** \n     *  @notice Initialize a new Bond pair that users can purchase \n     *  @param _bondName string - The name of the new bond pair \n     *  @param _startingPrice uint \n     *  @param _vestingTerm uint \n     */ \n    function initializeNewBondTerm( \n        string calldata _bondName, \n        uint256 _startingPrice, \n        uint256 _decimals, \n        uint256 _vestingTerm, \n        uint256 _incrementRate, \n        uint256 _decrementRate, \n        uint256 _buffer, \n        uint256 _maxPayout, \n        bool _isErc20, \n        address _tokenAddress \n    ) external onlyOwner { \n        // We want to increase the price faster than it decays \n        require( \n            _incrementRate > _decrementRate, \n            \"Bonding: Increment rate should be higher than decrement rate\" \n        ); \n \n        bondPairs.push( \n            BondPair({ \n                name: _bondName, \n                active: true, \n                currentPrice: _startingPrice, \n                decimals: _decimals, \n                lastDecay: block.number, \n                buffer: _buffer, \n                incrementRate: _incrementRate, \n                decrementRate: _decrementRate, \n                vestingTerm: _vestingTerm, \n                maxPayout: _maxPayout \n            }) \n        ); \n \n        if(_isErc20) { \n            erc20TokensAddresses[_bondName] = _tokenAddress; \n        } \n    } \n \n    function bondPrice(uint256 _bondIndex) public view returns (uint256) { \n        BondPair memory bond = bondPairs[_bondIndex]; \n        uint256 timeElapsedInBlocks = block.number - bond.lastDecay; \n        uint256 timeElapsed = timeElapsedInBlocks.div(bond.buffer); \n        uint256 discount = bond.decrementRate * timeElapsed; \n        uint256 discountedPrice = bond.currentPrice - discount; \n \n        if (discountedPrice < 100) { \n            discountedPrice = 100; \n        } \n \n        return discountedPrice; \n    } \n \n    /** \n     *  @notice Determine max bond size \n     *  @return uint \n     */ \n    function maxPayout(uint256 _bondPairIndex) public view returns (uint256) { \n        BondPair memory bond = bondPairs[_bondPairIndex]; \n \n        // Remember, the \"maxPayout\" variable on terms is a percentage of the total \n        // supply that can be bonded \n        return \n            IERC20(earthFundToken) \n                .balanceOf(address(this)) \n                .mul(bond.maxPayout) \n                .div(1e5); \n    } \n \n    /** \n     *  @notice Deposit bond \n     *  @param _bondPairIndex uint      The bond index \n     *  @param _amount        uint      Amount of 1EARTH that the user wants to buy \n     *  @param _depositor     address   The address that the 1EARTH will go to \n     *  @return uint \n     */ \n    function deposit( \n        uint256 _bondPairIndex, \n        uint256 _amount, \n        address _depositor \n    ) public payable returns (uint256) { \n        require(_depositor != address(0), \"Invalid address\"); \n        require( \n            _amount < IERC20(earthFundToken).balanceOf(address(this)), \n            \"Bonding: Not enough in contract to support bond\" \n        ); \n \n        BondPair memory currentBondPair = bondPairs[_bondPairIndex]; \n \n        uint256 currentBondPrice = bondPrice(_bondPairIndex); \n        uint256 payout = payoutFor(_bondPairIndex, _amount); // payout to bonder is computed \n \n        // require(payout >= 5e18, \"Bond too small\"); // must be >= 5 1EARTH \n        require(payout <= maxPayout(_bondPairIndex), \"Bond too large\"); // size protection because th\n \n        // If the bonding index is 0, then it's ETH. If not, then it is a token pair. \n        if (_bondPairIndex == 0) { \n            require( \n                msg.value >= \n                    _amount.div(10**currentBondPair.decimals).mul( \n                        currentBondPrice \n                    ), \n                \"Bonding: Not enough sent for bond\" \n            ); \n \n            treasury.transfer(msg.value); \n        } else { \n            address tokenAddress = erc20TokensAddresses[currentBondPair.name]; \n            IERC20(tokenAddress).safeTransferFrom( \n                msg.sender, \n                treasury, \n                _amount \n            ); \n        } \n \n        // depositor info is stored \n        bondInfo[_depositor][_bondPairIndex] = Bond({ \n            payout: bondInfo[_depositor][_bondPairIndex].payout.add(payout), \n            vesting: currentBondPair.vestingTerm, \n            lastBlock: block.number, \n            pricePaid: currentBondPrice \n        }); \n \n        emit BondCreated( \n            _amount, \n            payout, \n            block.number.add(currentBondPair.vestingTerm), \n            currentBondPair.currentPrice \n        ); \n \n        // Adjust bond decay rate and increase price since this is a purchase \n        currentBondPair.lastDecay = block.number; \n        currentBondPair.currentPrice = currentBondPair.currentPrice.add( \n            currentBondPair.incrementRate \n        ); \n \n        return payout; \n    } \n \n    /** \n     *  @notice redeem bond for user \n     *  @param _recipient address \n     *  @return uint \n     */ \n    function redeem(address _recipient, uint256 _bondPairIndex) \n        external \n        returns (bool) \n    { \n        Bond memory userBond = bondInfo[_recipient][_bondPairIndex]; \n        uint256 percentVested = percentVestedFor(_recipient, _bondPairIndex); // (blocks since last i\n \n        if (percentVested >= 10000) { \n            // if fully vested \n            delete bondInfo[_recipient][_bondPairIndex]; // delete user info \n            emit BondRedeemed(_recipient, userBond.payout, 0); // emit bond data \n            return IERC20(earthFundToken).transfer(_recipient, userBond.payout); // send payout \n        } else { \n            // if unfinished \n            // calculate payout vested \n            uint256 payout = userBond.payout.mul(percentVested).div(10000); \n \n            // store updated deposit info \n            bondInfo[_recipient][_bondPairIndex] = Bond({ \n                payout: userBond.payout.sub(payout), \n                vesting: userBond.vesting.sub( \n                    block.number.sub(userBond.lastBlock) \n                ), \n                lastBlock: block.number, \n                pricePaid: userBond.pricePaid \n            }); \n \n            emit BondRedeemed( \n                _recipient, \n                payout, \n                bondInfo[_recipient][_bondPairIndex].payout \n            ); \n            return IERC20(earthFundToken).transfer(_recipient, payout); // send payout \n        } \n    } \n \n    enum PARAMETER { \n        VESTING, \n        MAXPAYOUT, \n        INCREMENT, \n        DECREMENT, \n        BUFFER \n    } \n \n    /** \n     *  @notice Set or update specific parameter for a specific bond \n     *  @param _bondPairIndex Which bond to update, as referenced in bondPairs variable \n     *  @param _parameter     What parameter in a bond's terms to update \n     *  @param _input         The value for the new term value \n     */ \n    function setBondTerms( \n        uint256 _bondPairIndex, \n        PARAMETER _parameter, \n        uint256 _input \n    ) external view onlyOwner { \n        BondPair memory bond = bondPairs[_bondPairIndex]; \n \n        if (_parameter == PARAMETER.VESTING) { \n            // 0 \n            require(_input >= 86400, \"Vesting must be longer than 24 hours\"); \n            bond.vestingTerm = _input; \n        } else if (_parameter == PARAMETER.MAXPAYOUT) { \n            // 1 \n            require(_input <= 5000, \"Payout cannot be above 5 percent\"); \n            bond.maxPayout = _input; \n        } else if (_parameter == PARAMETER.INCREMENT) { \n            // 2 \n            bond.incrementRate = _input; \n        } else if (_parameter == PARAMETER.DECREMENT) { \n            // 3 \n            bond.decrementRate = _input; \n        } else if (_parameter == PARAMETER.BUFFER) { \n            // 4 \n            bond.buffer = _input; \n        } \n    } \n \n    /* ======== INTERNAL HELPER FUNCTIONS ======== */ \n \n    // VIEW FUNCTIONS // \n \n    /** \n     *  @notice calculate how far into vesting a depositor is \n     *  @param _depositor address \n     *  @return percentVested_ uint \n     */ \n    function percentVestedFor(address _depositor, uint256 _bondPairIndex) \n        public \n        view \n        returns (uint256 percentVested_) \n    { \n        Bond memory bond = bondInfo[_depositor][_bondPairIndex]; \n        uint256 blocksSinceLast = block.number.sub(bond.lastBlock); \n        uint256 vesting = bond.vesting; \n \n        if (vesting > 0) { \n            percentVested_ = blocksSinceLast.mul(10000).div(vesting); \n        } else { \n            percentVested_ = 0; \n        } \n    } \n \n    /** \n     *  @notice calculate amount of 1EARTH available for claim by depositor \n     *  @param _depositor address \n     *  @return pendingPayout_ uint \n     */ \n    function pendingPayoutFor(address _depositor, uint256 _bondPairIndex) \n        external \n        view \n        returns (uint256 pendingPayout_) \n    { \n        uint256 percentVested = percentVestedFor(_depositor, _bondPairIndex); \n        uint256 payout = bondInfo[_depositor][_bondPairIndex].payout; \n \n        if (percentVested >= 10000) { \n            pendingPayout_ = payout; \n        } else { \n            pendingPayout_ = payout.mul(percentVested).div(10000); \n        } \n    } \n \n    /** \n     *  @notice calculate interest due for new bond \n"
        ]
    },
    {
        "PdfName": "Elumia Crowns (ELU)_audit.pdf",
        "Code": []
    },
    {
        "PdfName": "Era7_Game of Truth_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\"; \nimport \"@openzeppelin/contracts/utils/Counters.sol\"; \nimport \"./comm/Helper.sol\"; \n \ncontract ERA7Card is ERC721,Helper { \n \n  struct ERA7CardEntity { \n    uint256 tokenId; \n    uint id; \n    uint ct; \n  } \n \n  ERA7CardEntity[] public allCards; \n  mapping(address => uint256[]) public playerCards; \n  mapping(address => mapping(uint256 => uint)) public playerCardIndexs; \n \n  using Counters for Counters.Counter; \n  Counters.Counter private _tokenIds; \n \n  constructor() ERC721(\"Era7 NFT\", \"ERANFT\") {} \n \n  function awardCard(address player,uint cardId) external onlyHelper returns (uint256){ \n    _tokenIds.increment(); \n \n    uint256 newItemId = _tokenIds.current(); \n \n    ERA7CardEntity memory card = ERA7CardEntity(newItemId,cardId,block.timestamp); \n    allCards.push(card); \n \n    playerCards[player].push(newItemId); \n    playerCardIndexs[player][newItemId] = playerCards[player].length; \n \n    _mint(player, newItemId); \n \n    emit AwardCard(player,newItemId,cardId); \n \n    return newItemId; \n  } \n \n  function approveList(address to, uint256[] memory tokenIds) external { \n    uint len = tokenIds.length; \n    for(uint i = 0; i < len ; i++){ \n      approve(to, tokenIds[i]); \n    } \n  } \n \n  function _transfer(address from,address to,uint256 tokenId) internal virtual override { \n    super._transfer(from,to,tokenId); \n    _swapTokenOwner(from,to,tokenId); \n  } \n \n  function burnList(uint256[] memory tokenIds) external {  \n    uint len = tokenIds.length; \n    for(uint i = 0; i < len ; i++){ \n      _burn(tokenIds[i]); \n    } \n  } \n \n  function burn(uint256 tokenId) external { \n    _burn(tokenId); \n  } \n \n  function _burn(uint256 tokenId) internal virtual override { \n    address owner = ERC721.ownerOf(tokenId); \n    _swapTokenOwner(owner,address(0),tokenId); \n    super._burn(tokenId); \n  } \n \n  function _swapTokenOwner(address from,address to,uint256 tokenId) private{ \n    if(from != to){ \n      uint index = playerCardIndexs[from][tokenId]; \n      if(playerCards[from].length != index){ \n        uint256 oldToken = playerCards[from][playerCards[from].length - 1]; \n        playerCards[from][index - 1] = oldToken; \n        playerCardIndexs[from][oldToken] = index; \n      } \n      playerCards[from].pop(); \n      delete playerCardIndexs[from][tokenId]; \n \n      if(to != address(0)){ \n        playerCards[to].push(tokenId); \n        playerCardIndexs[to][tokenId] = playerCards[to].length; \n      } \n    } \n  } \n \n  function totalCard() external view returns(uint256) { \n    return allCards.length; \n  } \n \n  function getPlayerCards(address player) external view returns (ERA7CardEntity[] memory) { \n    uint[] memory list = playerCards[player]; \n    uint length = list.length; \n    ERA7CardEntity[] memory cardList = new ERA7CardEntity[](length); \n    for(uint i = 0; i < length ; i++){ \n      cardList[i] = allCards[list[i] - 1]; \n    } \n    return cardList; \n  } \n \n  event AwardCard(address indexed to, uint256 nftId,uint256 cardId); \n} \n// nft\u4ea4\u6613\u5e02\u573a \n",
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"./comm/SafeMath.sol\"; \nimport \"./comm/Helper.sol\"; \nimport \"./IERA7Card.sol\"; \n \ncontract ERA7CardMarketPlace is Helper { \n \n  address public coin; \n  address public nft; \n \n  uint256[] public sellingNfts; \n  mapping(uint256 => uint256) public sellingNftIndexs; \n \n  struct MarketPlaceNftInfo{ \n    uint256 tokenId; \n    uint price; \n    address owner; \n    uint upTime; \n  } \n  mapping(uint256 => MarketPlaceNftInfo) public nftMap; \n \n  constructor() {} \n \n  function initAddress(address coin_,address nft_) external onlyHelper { \n    require((coin_ != address(0) && nft_ != address(0)), \"ERA7CardMarketPlace initAddress: address er\n \n    coin = coin_; \n    nft = nft_; \n  } \n \n  function withdraw(address taxWallet) external onlyHelper returns(bool){ \n    require(taxWallet != address(0), \"ERA7CardMarketPlace withdraw: taxWallet error\"); \n \n    uint256 val = IERC20(coin).balanceOf(address(this)); \n    require(val > 0, \"ERA7CardMarketPlace withdraw: val error\"); \n \n    IERC20(coin).transfer(taxWallet,val); \n    return true; \n  } \n \n  function uploadNft(uint256 nftId,uint256 price) external nonReentrant isPause{ \n      address ownerAddress = IERA7Card(nft).ownerOf(nftId); \n      address uploadAddress = _msgSender(); \n      require(ownerAddress == uploadAddress, \"ERA7CardMarketPlace uploadNft: not owner\"); \n      require(price > 10000, \"ERA7CardMarketPlace uploadNft: price error\"); \n \n      uint index = sellingNftIndexs[nftId]; \n      if(index == 0){ \n        MarketPlaceNftInfo memory newInfo = MarketPlaceNftInfo(nftId,price,ownerAddress,block.timesta\n        nftMap[nftId] = newInfo; \n        sellingNfts.push(nftId); \n        sellingNftIndexs[nftId] = sellingNfts.length; \n      }else{ \n        MarketPlaceNftInfo storage oldInfo = nftMap[nftId]; \n        oldInfo.price = price; \n        oldInfo.upTime = block.timestamp; \n      } \n \n      emit UploadNft(ownerAddress,nftId,price); \n  } \n \n  function stopSell(uint256 nftId) external nonReentrant isPause{ \n    uint index = sellingNftIndexs[nftId]; \n    require(index > 0, \"ERA7CardMarketPlace stopSell: nftId error\"); \n \n    address ownerAddress = IERA7Card(nft).ownerOf(nftId); \n    require(ownerAddress == _msgSender(), \"ERA7CardMarketPlace stopSell: stop error\"); \n \n    _removeNftFromList(nftId); \n \n    emit StopSell(nftId); \n  } \n \n  function _removeNftFromList(uint256 nftId) private{ \n    uint index = sellingNftIndexs[nftId]; \n      if(sellingNfts.length != index){ \n        uint oldNftId = sellingNfts[sellingNfts.length - 1]; \n        sellingNfts[index - 1] = oldNftId; \n        sellingNftIndexs[oldNftId] = index; \n      } \n      sellingNfts.pop(); \n      delete sellingNftIndexs[nftId]; \n      delete nftMap[nftId]; \n  } \n \n  function getTotalNft() external view returns(uint){ \n    return sellingNfts.length; \n  } \n \n  function getSellList(uint start,uint end) external view returns(MarketPlaceNftInfo[] memory){ \n      require(start >= 0 && end >= start,\"ERA7CardMarketPlace getSellList:params error\"); \n \n      uint total = sellingNfts.length; \n      if(total == 0){ \n        return new MarketPlaceNftInfo[](0); \n      } \n      if(start >= total){ \n        start = total - 1; \n      } \n      if(end >= total){ \n        end = total - 1; \n      } \n      uint size = end - start; \n      require(size <= 100,\"ERA7CardMarketPlace getSellList:size error\"); \n \n      MarketPlaceNftInfo[] memory list = new MarketPlaceNftInfo[](size + 1); \n      for(uint i = start; i <= end ; i++){ \n        list[i - start] = nftMap[sellingNfts[i]]; \n      } \n      return list; \n  } \n \n  function buy(uint256 nftId) external nonReentrant isPause { \n    MarketPlaceNftInfo memory info = nftMap[nftId]; \n    require(info.tokenId > 0, \"ERA7CardMarketPlace buy: nftId error\"); \n \n    address ownerAddress = IERA7Card(nft).ownerOf(nftId); \n    require(ownerAddress == info.owner, \"ERA7CardMarketPlace buy: nftId owner change\"); \n \n    SafeERC20.safeTransferFrom(IERC20(coin),_msgSender(),address(this),info.price); \n    IERA7Card(nft).transferFrom(info.owner,address(this),nftId); \n \n    uint256 get = SafeMath.mul(SafeMath.div(info.price,100),95); \n    SafeERC20.safeTransfer(IERC20(coin),info.owner,get); \n    IERA7Card(nft).transferFrom(address(this),_msgSender(),nftId); \n \n    _removeNftFromList(nftId); \n \n    emit Buy(info.owner,_msgSender(),info.tokenId,info.price); \n  } \n \n  event UploadNft(address indexed from, uint256 nftId,uint256 price); \n  event StopSell(uint256 nftId); \n  event Buy(address indexed from, address indexed to, uint256 nftId,uint256 price); \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n} \n// Nft \u9884\u552e\u5408\u7ea6 \n",
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"./comm/Helper.sol\"; \nimport \"./IERA7Card.sol\"; \n \ncontract ERA7CardPreSale is Helper { \n \n  address public coin; \n  address public nft; \n \n  struct PreSaleNftInfo{ \n    uint cardId; \n    uint price; \n    uint count; \n  } \n \n  uint[] public sellingNfts; \n  mapping(uint => uint) public sellingNftIndexs; \n  mapping(uint => PreSaleNftInfo) public sellingInfos; \n \n  constructor() {} \n \n  function initAddress(address coin_,address nft_) external onlyHelper { \n    require((coin_ != address(0) && nft_ != address(0)), \"ERA7CardPreSale initAddress: address error\"\n \n    coin = coin_; \n    nft = nft_; \n  } \n \n  function withdraw(address taxWallet) external onlyHelper returns(bool){ \n    require(taxWallet != address(0), \"ERA7CardPreSale withdraw: taxWallet error\"); \n \n    uint256 val = IERC20(coin).balanceOf(address(this)); \n    require(val > 0, \"ERA7CardPreSale withdraw: val error\"); \n \n    IERC20(coin).transfer(taxWallet,val); \n    return true; \n  } \n \n  function uploadNft(uint cardId,uint256 price,uint count) external onlyHelper{ \n      require(cardId > 0 && price > 0 && count > 0, \"ERA7CardPreSale uploadNft: params error\"); \n \n      uint index = sellingNftIndexs[cardId]; \n      if(index == 0){ \n        PreSaleNftInfo memory newInfo = PreSaleNftInfo(cardId,price,count); \n        sellingInfos[cardId] = newInfo; \n        sellingNfts.push(cardId); \n        sellingNftIndexs[cardId] = sellingNfts.length; \n      }else{ \n        PreSaleNftInfo storage oldInfo = sellingInfos[cardId]; \n        oldInfo.price = price; \n        oldInfo.count = count; \n      } \n  } \n \n  function stopSell(uint cardId) external onlyHelper{ \n      PreSaleNftInfo storage info = sellingInfos[cardId]; \n      require(info.cardId > 0, \"ERA7CardPreSale stopSell: cardId error\"); \n \n      uint index = sellingNftIndexs[cardId]; \n      if(sellingNfts.length != index){ \n        uint oldCardId = sellingNfts[sellingNfts.length - 1]; \n        sellingNfts[index - 1] = oldCardId; \n        sellingNftIndexs[oldCardId] = index; \n      } \n      sellingNfts.pop(); \n      delete sellingNftIndexs[cardId]; \n      delete sellingInfos[cardId]; \n  } \n \n  function getSellList() external view returns(PreSaleNftInfo[] memory){ \n      uint len = sellingNfts.length; \n      PreSaleNftInfo[] memory list = new PreSaleNftInfo[](len); \n      for(uint i = 0; i < len ;i++){ \n        list[i] = sellingInfos[sellingNfts[i]]; \n      } \n      return list; \n  } \n \n  function buy(uint cardId) external nonReentrant returns(uint256){ \n      PreSaleNftInfo storage info = sellingInfos[cardId]; \n      require(info.cardId > 0, \"ERA7CardPreSale buy: cardId error\"); \n \n      uint count = info.count; \n      require(count > 0, \"ERA7CardPreSale buy: count error\"); \n      info.count--; \n \n      address buyAddress = _msgSender(); \n      SafeERC20.safeTransferFrom(IERC20(coin),buyAddress,address(this),info.price); \n \n      uint256 tokenId = IERA7Card(nft).awardCard(buyAddress,cardId); \n \n      emit Buy(_msgSender(),cardId,info.price); \n \n      return tokenId; \n  } \n \n  event Buy(address indexed to, uint256 cardId,uint256 price); \n \n \n \n \n \n \n \n \n \n \n \n \n \n} \n",
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"./comm/SafeMath.sol\"; \nimport \"./comm/Helper.sol\"; \n \ncontract ERA7Token is ERC20,Helper { \n \n  uint256 public maxMint; \n \n  constructor() ERC20(\"Era Token\", \"ERA\") { \n    uint256 decimal = 10 ** uint256(decimals()); \n    maxMint = 1000000000 * decimal; \n  } \n \n  function mint(address to,uint256 amount) external onlyHelper { \n    require(to != address(0), \"ERA7Token:to address error\"); \n \n    uint256 newVal = SafeMath.add(amount,totalSupply()); \n    require(newVal <= maxMint, \"ERA7Token:mint value is max\"); \n    _mint(to,amount); \n  } \n \n \n  function burn(uint256 amount) external { \n      _burn(_msgSender(), amount); \n  } \n \n  function burnFrom(address account, uint256 amount) external { \n      uint256 currentAllowance = allowance(account, _msgSender()); \n      require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\"); \n      unchecked { \n          _approve(account, _msgSender(), currentAllowance - amount); \n      } \n      _burn(account, amount); \n  } \n \n} \n",
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; \n \ncontract Helper is Ownable,ReentrancyGuard { \n \n  address[] public helpers; \n  mapping(address => uint) helperIndexs; \n \n  bool public pause; \n \n  constructor(){ \n    pause = false; \n  } \n \n  function addHelper(address helper) external onlyOwner { \n    require(helper != address(0),\"Helper:set helper error\"); \n    uint index = helperIndexs[helper]; \n    if(index == 0){ \n      helpers.push(helper); \n      helperIndexs[helper] = helpers.length; \n    } \n  } \n \n  function removeHelper(address helper) external onlyOwner{ \n    uint index = helperIndexs[helper]; \n    require(index > 0,\"Helper:remove helper error\"); \n    if(helpers.length != index){ \n        address old = helpers[helpers.length - 1]; \n        helpers[index - 1] = old; \n        helperIndexs[old] = index; \n      } \n      helpers.pop(); \n      delete helperIndexs[helper]; \n  } \n \n  function pauseContract() external onlyHelper{ \n    pause = true; \n  } \n \n  function resume() external onlyHelper{ \n    pause = false; \n  } \n \n  modifier onlyHelper() { \n    require(helperIndexs[_msgSender()] > 0 || owner() == _msgSender(), \"Helper: caller is not the hel\n    _; \n  } \n \n  modifier isPause() { \n    require(!pause, \"Helper: contract is paused\"); \n    _; \n  } \n \n} \n",
            "pragma solidity ^0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * SafeMath restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's + operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's - operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's * operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's / operator. Note: this function uses a \n     * revert opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's % operator. This function uses a revert \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's - operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's / operator. Note: this function uses a \n     * revert opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's % operator. This function uses a revert \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n}// SPDX-License-Identifier: MIT \n",
            "pragma solidity ^0.8.0; \n \ninterface IERA7Card { \n    struct ERA7CardEntity { \n        uint256 tokenId; \n"
        ]
    },
    {
        "PdfName": "FEC Token_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n}\nERC20.sol\n// FECtoken project \n",
            "pragma solidity ^0.8.0; \n \nimport \"./IERC20.sol\"; \nimport \"./IERC20Metadata.sol\"; \nimport \"./Context.sol\"; \n \n/** \n * @dev Implementation of the {IERC20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of ERC20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IERC20-approve}. \n */ \ncontract ERC20 is Context, IERC20, IERC20Metadata { \n    mapping(address => uint256) private _balances; \n \n    mapping(address => mapping(address => uint256)) private _allowances; \n    //\u6388\u6743 \n \n    uint256 private _totalSupply; \n    //\u4ee3\u5e01\u603b\u91cf \n \n    string public _name; \n    //\u4ee3\u5e01\u540d\u79f0 \u7b80\u79f0 \n    string public _symbol; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}. \n     * \n     * The default value of {decimals} is 18. To select a different value for \n     * {decimals} you should overload it. \n     * \n     * All two of these values are immutable: they can only be set once during \n     * construction. \n     */ \n     constructor(string memory name_, string memory symbol_) { \n         _name = name_; \n         _symbol = symbol_; \n     } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public view virtual override returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public view virtual override returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a balance of `505` tokens should \n     * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a value of 18, imitating the relationship between \n     * Ether and Wei. This is the value {ERC20} uses, unless this function is \n     * overridden; \n     * \n     * NOTE: This information is only used for _display_ purposes: it in \n     * no way affects any of the arithmetic of the contract, including \n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */ \n    function decimals() public view virtual override returns (uint8) { \n        return 18; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */ \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */ \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function allowance(address owner, address spender) public view virtual override returns (uint256) \n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {ERC20}. \n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) public virtual override returns (bool) { \n        _transfer(sender, recipient, amount); \n \n        uint256 currentAllowance = _allowances[sender][_msgSender()]; \n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n        unchecked { \n            _approve(sender, _msgSender(), currentAllowance - amount); \n        } \n \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        uint256 currentAllowance = _allowances[_msgSender()][spender]; \n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\"); \n        unchecked { \n            _approve(_msgSender(), spender, currentAllowance - subtractedValue); \n        } \n \n        return true; \n    } \n \n    /** \n     * @dev Moves `amount` of tokens from `sender` to `recipient`. \n     * \n     * This internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        uint256 senderBalance = _balances[sender]; \n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n        unchecked { \n            _balances[sender] = senderBalance - amount; \n        } \n        _balances[recipient] += amount; \n \n        emit Transfer(sender, recipient, amount); \n \n        _afterTokenTransfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the total supply. \n     * \n     * Emits a {Transfer} event with `from` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     */ \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply += amount; \n        _balances[account] += amount; \n        emit Transfer(address(0), account, amount); \n \n        _afterTokenTransfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        uint256 accountBalance = _balances[account]; \n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\"); \n        unchecked { \n            _balances[account] = accountBalance - amount; \n        } \n        _totalSupply -= amount; \n \n        emit Transfer(account, address(0), amount); \n \n        _afterTokenTransfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens. \n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve( \n        address owner, \n        address spender, \n        uint256 amount \n    ) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * will be transferred to `to`. \n     * - when `from` is zero, `amount` tokens will be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n     * - `from` and `to` are never both zero. \n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _beforeTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual {} \n \n    /** \n     * @dev Hook that is called after any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * has been transferred to `to`. \n     * - when `from` is zero, `amount` tokens have been minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned. \n     * - `from` and `to` are never both zero. \nfec.sol\n// FECtoken project \n \n",
            "pragma solidity ^0.8.0; \n \nimport \"./ERC20.sol\"; \n \ncontract FECToken is ERC20{  \n \n    string public Fecname = \"FECToken\"; \n    string public Fecsymbol = \"FEC\"; \n    uint8 public dec = 18; \n    uint public INITIAL_SUPPLY = 10000000000; \n    uint256 public _totalSupply = INITIAL_SUPPLY * (10**uint(dec)); \n \n   constructor () ERC20(Fecname, Fecsymbol) public{  \n   _mint(msg.sender, _totalSupply);  \n   }  \n} \nIERC20Metadata.sol\n \n",
            "pragma solidity ^0.8.0; \n \nimport \"./IERC20.sol\"; \n \n/** \n * @dev Interface for the optional metadata functions from the ERC20 standard. \n * \n * _Available since v4.1._ \n */ \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the symbol of the token. \n     */ \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the decimals places of the token. \n     */ \n    function decimals() external view returns (uint8); \n}\n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _afterTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual {} \n} \nContext.sol\n \n",
            "pragma solidity ^0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes calldata) { \n        return msg.data; \n    } \n} \n"
        ]
    },
    {
        "PdfName": "FIDO_audit 1.0.0.pdf",
        "Code": [
            "pragma solidity ^0.7.6; \n \ninterface IFidoMember { \n  function baseRate() view external returns (uint256); \n \n  function fidoOfficial() view external returns (address); \n \n  function followers(address, uint256) view external returns (address); \n \n  function inviter(address) view external returns (address); \n \n  function isInvited(address) view external returns (bool); \n \n  function isMember(address) view external returns (bool); \n \n  function joinBlockHeight(address) view external returns (uint256); \n \n  function mfilPool() view external returns (address); \n \n  function multiRate() view external returns (uint256); \n \n  function operator() view external returns (address); \n \n  function owner() view external returns (address); \n \n  function pool() view external returns (address); \n \n  function rateDecimal() view external returns (uint256); \n \n  function renounceOwnership() external; \n \n  function stakeMin() view external returns (uint256); \n \n  function transferOwnership(address newOwner) external; \n \n  function transferOperatorship(address newOperator) external; \n \n  function adjustRate(uint256 _baseRate, uint256 _multiRate) external; \n \n  function changeRateDecimal(uint256 newRateDecimal) external; \n \n  function changeStakeMin(uint256 newStakeMin) external; \n \n  function joinFido(address _inviter) external; \n \n  function changeMFILPool(address newMfilpool) external; \n \n  function changeFidoOfficial(address newFidoOfficial) external; \n \n  function changePool(address newPool) external; \n \n  function getFollowerCount(address member) view external returns (uint256); \n \n  function caleInviteRate(address member) view external returns (address inviter0, address inviter1, \n \n  event AdjustRate(uint256 baseRate, uint256 multiRate); \n \n  event AdjustStakeMin(uint256 stakeMin); \n \n  event NewMember(address indexed member, address indexed inviter, uint256 joinBlockHeight); \n \n  event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n}// SPDX-License-Identifier: MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Mintable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) \n        external \n        returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) \n        external \n        view \n        returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    function mint(address recipient, uint256 amount) external; \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 value \n    ); \n \n    event AddMinter(address indexed minter); \n    event RemoveMinter(address indexed minter); \n    event Mint( \n        address indexed minter, \n        address indexed recipient, \n        uint256 amount \n    ); \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n",
            "pragma solidity ^0.7.6; \ninterface IMdexPair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n \n    function symbol() external pure returns (string memory); \n \n    function decimals() external pure returns (uint8); \n \n    function totalSupply() external view returns (uint); \n \n    function balanceOf(address owner) external view returns (uint); \n \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n \n    function transfer(address to, uint value) external returns (bool); \n \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n \n    function factory() external view returns (address); \n \n    function token0() external view returns (address); \n \n    function token1() external view returns (address); \n \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n \n    function price0CumulativeLast() external view returns (uint); \n \n    function price1CumulativeLast() external view returns (uint); \n \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n \n    function burn(address to) external returns (uint amount0, uint amount1); \n \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n \n    function skim(address to) external; \n \n    function sync() external; \n \n    function price(address token, uint256 baseDecimal) external view returns (uint256); \n \n    function initialize(address, address) external; \n}// SPDX-License-Identifier: MIT \n",
            "pragma solidity ^0.7.6; \n \ninterface IRateOracle { \n  function owner() view external returns (address); \n \n  function paused() view external returns (bool); \n \n  function renounceOwnership() external; \n \n  function requester() view external returns (address); \n \n  function transferOwnership(address newOwner) external; \n \n  function updater() view external returns (address); \n \n  function pause() external; \n \n  function unPause() external; \n \n  function status() view external returns (bool); \n \n  function lastRequestTime() view external returns (uint256); \n \n  function lastUpdateTime() view external returns (uint256); \n \n  function decimals() view external returns (uint8); \n \n  function rate() view external returns (uint256); \n \n  function request() external; \n \n  function update(uint256 rate_) external; \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event Paused(address account); \n \n  event Request(uint256 indexed timestamp); \n \n  event RequestershipTransferred(address indexed previousRequester, address indexed newRequester); \n \n  event Unpaused(address account); \n \n  event Update(uint256 indexed timestamp, uint256 rate); \n \n  event UpdatershipTransferred(address indexed previousUpdater, address indexed newUpdater); \n}// SPDX-License-Identifier: MIT \n",
            "pragma solidity ^0.7.6; \n \ninterface IMFIL { \n  function allowance(address owner, address spender) view external returns (uint256); \n \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  function balanceOf(address account) view external returns (uint256); \n \n  function burn(uint256 amount) external; \n \n  function burnFrom(address account, uint256 amount) external; \n \n  function decimals() view external returns (uint8); \n \n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool); \n \n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool); \n \n  function isMinter(address) view external returns (bool); \n \n  function mint(address recipient, uint256 amount) external; \n \n  function name() view external returns (string memory); \n \n  function operator() view external returns (address); \n \n  function owner() view external returns (address); \n \n  function paused() view external returns (bool); \n \n  function renounceOwnership() external; \n \n  function symbol() view external returns (string memory); \n \n  function totalSupply() view external returns (uint256); \n \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  function transferOwnership(address newOwner) external; \n \n  function transferOperatorship(address newOperator) external; \n \n  function pause() external; \n \n  function unPause() external; \n \n  function addMinter(address minter) external; \n \n  function removeMinter(address minter) external; \n \n  function cap() view external returns (uint256); \n \n  event AddMinter(address indexed minter); \n \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n \n  event Mint(address indexed minter, address indexed recipient, uint256 amount); \n \n  event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event Paused(address account); \n \n  event RemoveMinter(address indexed minter); \n \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n",
            "pragma solidity ^0.7.6; \n \ninterface IIDOToken { \n  function allowance(address owner, address spender) view external returns (uint256); \n \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  function balanceOf(address account) view external returns (uint256); \n \n  function burn(uint256 amount) external; \n \n  function burnFrom(address account, uint256 amount) external; \n \n  function dailySaleCap() view external returns (uint256); \n \n  function decimals() view external returns (uint8); \n \n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool); \n \n  function factory() view external returns (address); \n \n  function gasPrice() view external returns (uint256); \n \n  function hardDrivePrice() view external returns (uint256); \n \n  function hfil() view external returns (address); \n \n  function hfilRecipient() view external returns (address); \n \n  function idoEndTime() view external returns (uint256); \n \n  function idoStartTime() view external returns (uint256); \n \n  function idoStatus() view external returns (bool); \n \n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool); \n \n  function name() view external returns (string memory); \n \n  function node() view external returns (string memory); \n \n  function paused() view external returns (bool); \n \n  function price() view external returns (uint256); \n \n  function router() view external returns (address); \n \n  function sealPrice() view external returns (uint256); \n \n  function sender() view external returns (address); \n \n  function symbol() view external returns (string memory); \n \n  function todayStartTime() view external returns (uint256); \n \n  function totalSupply() view external returns (uint256); \n \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  function operator() view external returns (address); \n \n  function setPrice(uint256 gasPrice_, uint256 sealPrice_, uint256 hardDrivePrice_) external; \n \n  function setTimes(uint256 idoStartTime_, uint256 idoEndTime_) external; \n \n  function changerouter(address _router) external; \n \n  function stopIdo() external; \n \n  function stopIdoBySender() external; \n \n  function todayRemaind() view external returns (uint256); \n \n  function pause() external; \n \n  function unPause() external; \n \n  function cap() view external returns (uint256); \n \n  function startIdo(address _router) external; \n \n  function ido(address recipient) external returns (uint256 amount); \n \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n \n  event IDO(address indexed to, uint256 cost, uint256 amount); \n \n  event IDOStart(uint256 timestamp); \n \n  event IDOStop(uint256 timestamp, address sender); \n \n  event Paused(address account); \n \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n",
            "pragma solidity ^0.7.6; \n \ninterface IHFIL { \n  function allowance(address owner, address spender) view external returns (uint256); \n \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  function balanceOf(address account) view external returns (uint256); \n \n  function burn(address account, uint256 amount) external; \n \n  function changeUser(address new_operator, address new_pauser) external; \n \n  function decimals() view external returns (uint8); \n \n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool); \n \n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool); \n \n  function mint(address account, uint256 amount) external; \n \n  function name() view external returns (string memory); \n \n  function pause() external; \n \n  function paused() view external returns (bool); \n \n  function symbol() view external returns (string memory); \n \n  function totalSupply() view external returns (uint256); \n \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  function unpause() external; \n \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n \n  event Paused(address account); \n \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n",
            "pragma solidity ^0.7.6; \n \ninterface IFidoUsdtLPPool { \n  function BlastUpdateBlock() view external returns (uint256); \n \n  function BrewardPreBlock() view external returns (uint256); \n \n  function BrewardRate() view external returns (uint256); \n \n  function BuserRate(address) view external returns (uint256); \n \n  function BuserReward(address) view external returns (uint256); \n \n  function adjustReward(uint256 amount) external; \n \n  function caleLiquidity(uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 \n \n  function caleReward() view external returns (uint256 reward); \n \n  function factory() view external returns (address); \n \n  function fido() view external returns (address); \n \n  function getStake() view external returns (uint256 amount); \n \n  function halve() external returns (uint256 reward); \n \n  function operator() view external returns (address); \n \n  function owner() view external returns (address); \n \n  function pairFor(address tokenA, address tokenB) view external returns (address pair); \n \n  function pause() external; \n \n  function paused() view external returns (bool); \n \n  function renounceOwnership() external; \n \n  function rewardToken() view external returns (address); \n \n  function stake(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amo\n \n  function stakeRate() view external returns (uint8); \n \n  function tokenA() view external returns (address); \n \n  function tokenB() view external returns (address); \n \n  function totalStake() view external returns (uint256); \n \n  function totalTokenBStake() view external returns (uint256); \n \n  function transferOperatorship(address newOperator) external; \n \n  function transferOwnership(address newOwner) external; \n \n  function unPause() external; \n \n  function unStake() external returns (uint256 reward, uint256 amountA, uint256 amountB, uint256 liqu\n \n  function usdt() view external returns (address); \n \n  function userStake(address) view external returns (uint256); \n \n  function userTokenBStake(address) view external returns (uint256); \n \n  event NewReward(uint256 blockHeight, uint256 amount); \n \n  event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event Paused(address account); \n \n  event Reward(address indexed receiver, uint256 reward); \n \n  event Stake(address indexed sender, uint256 amountA, uint256 amountB, uint256 liquidity); \n \n  event UnStake(address indexed receiver, uint256 amountA, uint256 amountB, uint256 liquidity); \n \n  event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n \n",
            "pragma solidity ^0.7.6; \n \ninterface IMdexFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n \n    function feeToSetter() external view returns (address); \n \n    function feeToRate() external view returns (uint256); \n \n    function initCodeHash() external view returns (bytes32); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n \n    function allPairs(uint) external view returns (address pair); \n \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n \n    function setFeeToSetter(address) external; \n \n    function setFeeToRate(uint256) external; \n \n    function setInitCodeHash(bytes32) external; \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uin\n \n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint25\n \n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[\n \n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[\n}// SPDX-License-Identifier: MIT \n",
            "pragma solidity ^0.7.6; \n \ninterface IIDOInfo { \n  function IDOList(uint256) view external returns (address); \n \n  function exist(address) view external returns (bool); \n \n  function isPool(address) view external returns (bool); \n \n  function operator() view external returns (address); \n \n  function owner() view external returns (address); \n \n  function payer2pool(address) view external returns (address); \n \n  function pool2idoToken(address) view external returns (address); \n \n  function renounceOwnership() external; \n \n  function stakeAddress(address) view external returns (address); \n \n  function transferOwnership(address newOwner) external; \n \n  function transferOperatorship(address newOperator) external; \n \n  function IDOListCount() view external returns (uint256); \n \n  function addIDO(address idoToken) external; \n \n  function setPayer(address pool, address payer) external; \n \n  function setStakeAddress(address idoToken, address _stakeAddress) external; \n \n  event AddIDO(uint256 timestamp, address idoToken); \n \n  event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event SetPayer(uint256 timestamp, address pool, address payer); \n \n  event SetStakeAddress(uint256 timestamp, address idoToken, address _stakeAddress); \n}// SPDX-License-Identifier: MIT \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./interfaces/IERC20.sol\"; \nimport \"./interfaces/IMdexFactory.sol\"; \nimport \"./interfaces/IMdexPair.sol\"; \n \nimport \"./libraries/SafeMath.sol\"; \nimport \"./libraries/TransferHelper.sol\"; \n \ncontract MdexRouter { \n    using SafeMath for uint256; \n \n    address public factory; \n \n    constructor(address _factory) { \n        factory = _factory; \n    } \n \n    function pairFor(address tokenA, address tokenB) \n        public \n        view \n        returns (address pair) \n    { \n        pair = IMdexFactory(factory).pairFor(tokenA, tokenB); \n    } \n \n    // **** ADD LIQUIDITY **** \n    function _addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 amountADesired, \n        uint256 amountBDesired, \n        uint256 amountAMin, \n        uint256 amountBMin \n    ) internal virtual returns (uint256 amountA, uint256 amountB) { \n        // create the pair if it doesn't exist yet \n        if (IMdexFactory(factory).getPair(tokenA, tokenB) == address(0)) { \n            IMdexFactory(factory).createPair(tokenA, tokenB); \n        } \n        (uint256 reserveA, uint256 reserveB) = \n            IMdexFactory(factory).getReserves(tokenA, tokenB); \n        if (reserveA == 0 && reserveB == 0) { \n            (amountA, amountB) = (amountADesired, amountBDesired); \n        } else { \n            uint256 amountBOptimal = \n                IMdexFactory(factory).quote(amountADesired, reserveA, reserveB); \n            if (amountBOptimal <= amountBDesired) { \n                require( \n                    amountBOptimal >= amountBMin, \n                    \"MdexRouter: INSUFFICIENT_B_AMOUNT\" \n                ); \n                (amountA, amountB) = (amountADesired, amountBOptimal); \n            } else { \n                uint256 amountAOptimal = \n                    IMdexFactory(factory).quote( \n                        amountBDesired, \n                        reserveB, \n                        reserveA \n                    ); \n                assert(amountAOptimal <= amountADesired); \n                require( \n                    amountAOptimal >= amountAMin, \n                    \"MdexRouter: INSUFFICIENT_A_AMOUNT\" \n                ); \n                (amountA, amountB) = (amountAOptimal, amountBDesired); \n            } \n        } \n    } \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 amountADesired, \n        uint256 amountBDesired, \n        uint256 amountAMin, \n        uint256 amountBMin \n    ) \n        internal \n        virtual \n        returns ( \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ) \n    { \n        (amountA, amountB) = _addLiquidity( \n            tokenA, \n            tokenB, \n            amountADesired, \n            amountBDesired, \n            amountAMin, \n            amountBMin \n        ); \n        address pair = pairFor(tokenA, tokenB); \n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA); \n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB); \n        liquidity = IMdexPair(pair).mint(address(this)); \n    } \n \n    // **** REMOVE LIQUIDITY **** \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 liquidity, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to \n    ) internal virtual returns (uint256 amountA, uint256 amountB) { \n        address pair = pairFor(tokenA, tokenB); \n        IMdexPair(pair).transfer(pair, liquidity); \n        // send liquidity to pair \n        (uint256 amount0, uint256 amount1) = IMdexPair(pair).burn(to); \n        (address token0, ) = IMdexFactory(factory).sortTokens(tokenA, tokenB); \n        (amountA, amountB) = tokenA == token0 \n            ? (amount0, amount1) \n            : (amount1, amount0); \n        require(amountA >= amountAMin, \"MdexRouter: INSUFFICIENT_A_AMOUNT\"); \n        require(amountB >= amountBMin, \"MdexRouter: INSUFFICIENT_B_AMOUNT\"); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./Pausable.sol\"; \nimport \"./libraries/SafeMath.sol\"; \nimport \"./libraries/TransferHelper.sol\"; \nimport \"./interfaces/IIDOToken.sol\"; \nimport \"./interfaces/IFidoMember.sol\"; \nimport \"./ReentrancyGuard.sol\"; \n \ncontract IDOUserRouter is Context, Ownable, Pausable, ReentrancyGuard { \n    using SafeMath for uint256; \n \n    uint256 public fidoFeeRate = 1; // fidoFee = fidoFeeRate / 10**fidoFeeRateDecimals \n    uint8 public fidoFeeRateDecimals = 2; \n \n    uint256 public insuranceFeeRate = 1; // insuranceFee = insuranceFeeRate / 10**insuranceFeeRateDec\n    uint8 public insuranceFeeRateDecimals = 3; \n \n    uint256 public inviteFeeRate = 10; // inviteFee = inviteFeeRate / 10**inviteFeeRateDecimals \n    uint8 public inviteFeeRateDecimals = 2; \n \n    address public operator; \n \n    mapping(address => bool) public approvedIDO; \n    mapping(address => mapping(address => bool)) public userIDO; \n    mapping(address => address[]) public userIDOs; \n    address[] public approvedIDOlist; \n    address public hfil; \n    address public insuranceProvider; \n    address public fidoFeeRecipient; \n    address public FidoMember; \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    event ApproveIDO(uint256 timestamp, address indexed idoToken); \n    event StopIDO(uint256 timestamp, address indexed idoToken); \n \n    event IDO( \n        address indexed sender, \n        address indexed idoToken, \n        uint256 hfil, \n        uint256 amount, \n        uint256 fidoFee, \n        uint256 insurance, \n        uint256 inviteFee \n    ); \n \n    constructor( \n        address _operator, \n        address _hfil, \n        address _FidoMember, \n        address _insuranceProvider, \n        address _fidoFeeRecipient \n    ) Pausable() ReentrancyGuard() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        hfil = _hfil; \n        FidoMember = _FidoMember; \n        insuranceProvider = _insuranceProvider; \n        fidoFeeRecipient = _fidoFeeRecipient; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function pause() external onlyOperator { \n        _pause(); \n    } \n \n    function unPause() external onlyOperator { \n        _unpause(); \n    } \n \n    function changeFidoFeeRecipient(address _fidoFeeRecipient) \n        external \n        onlyOwner \n    { \n        require(_fidoFeeRecipient != address(0), \"wrong address\"); \n        fidoFeeRecipient = _fidoFeeRecipient; \n    } \n \n    function changeInsuranceProvider(address _insuranceProvider) \n        external \n        onlyOwner \n    { \n        require(_insuranceProvider != address(0), \"wrong address\"); \n        insuranceProvider = _insuranceProvider; \n    } \n \n    function changeFidoFeeRate(uint256 _fidoFeeRate, uint8 _fidoFeeRateDecimals) \n        external \n        onlyOperator \n    { \n        require( \n            _fidoFeeRateDecimals > 0, \n            \"fidoFeeRateDecimals must greater than zero\" \n        ); \n        fidoFeeRateDecimals = _fidoFeeRateDecimals; \n        fidoFeeRate = _fidoFeeRate; \n    } \n \n    function changeInsuranceFeeRate( \n        uint256 _insuranceFeeRate, \n        uint8 _insuranceFeeRateDecimals \n    ) external onlyOperator { \n        require( \n            _insuranceFeeRateDecimals > 0, \n            \"insuranceFeeRateDecimals must greater than zero\" \n        ); \n        insuranceFeeRateDecimals = _insuranceFeeRateDecimals; \n        insuranceFeeRate = _insuranceFeeRate; \n    } \n \n    function changeInviteFeeRate( \n        uint256 _inviteFeeRate, \n        uint8 _inviteFeeRateDecimals \n    ) external onlyOperator { \n        require( \n            _inviteFeeRateDecimals > 0, \n            \"inviteFeeRateDecimals must greater than zero\" \n        ); \n        inviteFeeRateDecimals = _inviteFeeRateDecimals; \n        inviteFeeRate = _inviteFeeRate; \n    } \n \n    function userIDOsCount(address user) external view returns (uint256) { \n        return userIDOs[user].length; \n    } \n \n    function approvedIDOlistCount() external view returns (uint256) { \n        return approvedIDOlist.length; \n    } \n \n    function approveIDO(address idoToken) external onlyOperator { \n        require( \n            idoToken != address(0), \n            \"IDORouter: IDO address cannot be zero\" \n        ); \n        require(!approvedIDO[idoToken], \"IDORouter: IDO approved\"); \n        approvedIDO[idoToken] = true; \n        approvedIDOlist.push(idoToken); \n        emit ApproveIDO(block.timestamp, idoToken); \n    } \n \n    function stopIDO(address idoToken) external onlyOperator { \n        require( \n            idoToken != address(0), \n            \"IDORouter: IDO address cannot be zero\" \n        ); \n        require(approvedIDO[idoToken], \"IDORouter: IDO not approved\"); \n        approvedIDO[idoToken] = false; \n        for (uint256 index = 0; index < approvedIDOlist.length; index++) { \n            if (approvedIDOlist[index] == idoToken) { \n                approvedIDOlist[index] = approvedIDOlist[ \n                    approvedIDOlist.length - 1 \n                ]; \n                break; \n            } \n        } \n        approvedIDOlist.pop(); \n        emit StopIDO(block.timestamp, idoToken); \n    } \n \n    function getIDOPrice(address idoToken) internal view returns (uint256) { \n        return IIDOToken(idoToken).price(); \n    } \n \n    function ido(address idoToken, uint256 idoAmount) external nonReentrant { \n        require(approvedIDO[idoToken], \"IDORouter: IDO not approved\"); \n        require(idoAmount > 10**4, \"IDORouter: IDO amount less than 0.01\"); \n \n        uint256 price = getIDOPrice(idoToken); \n        uint256 totalprice = price.mul(idoAmount).div(10**6); \n        TransferHelper.safeTransferFrom( \n            hfil, \n            _msgSender(), \n            idoToken, \n            totalprice \n        ); \n        idoAmount = IIDOToken(idoToken).ido(_msgSender()); \n        totalprice = price.mul(idoAmount).div(10**6); \n \n        uint256 fidoFee = \n            totalprice.mul(fidoFeeRate).div(10**uint256(fidoFeeRateDecimals)); \n        TransferHelper.safeTransferFrom( \n            hfil, \n            _msgSender(), \n            fidoFeeRecipient, \n            fidoFee \n        ); \n \n        uint256 insurance = \n            totalprice.mul(insuranceFeeRate).div( \n                10**uint256(insuranceFeeRateDecimals) \n            ); \n        TransferHelper.safeTransferFrom( \n            hfil, \n            _msgSender(), \n            insuranceProvider, \n            insurance \n        ); \n \n        uint256 inviteFee = \n            totalprice.mul(inviteFeeRate).div( \n                10**uint256(inviteFeeRateDecimals) \n            ); \n        { \n            address inviter0; \n            address inviter1; \n            address fido; \n            uint256 rate0; \n            uint256 rate1; \n            uint256 fidoRate; \n            uint256 fee; \n            (inviter0, inviter1, fido, rate0, rate1, fidoRate) = IFidoMember( \n                FidoMember \n            ) \n                .caleInviteRate(_msgSender()); \n            fee = inviteFee.mul(rate0).div( \n                10**IFidoMember(FidoMember).rateDecimal() \n            ); \n            TransferHelper.safeTransferFrom(hfil, _msgSender(), inviter0, fee); \n            fee = inviteFee.mul(rate1).div( \n                10**IFidoMember(FidoMember).rateDecimal() \n            ); \n            TransferHelper.safeTransferFrom(hfil, _msgSender(), inviter1, fee); \n            fee = inviteFee.mul(fidoRate).div( \n                10**IFidoMember(FidoMember).rateDecimal() \n            ); \n            TransferHelper.safeTransferFrom(hfil, _msgSender(), fido, fee); \n        } \n        if (idoAmount > 0) { \n            if (!userIDO[_msgSender()][idoToken]) { \n                userIDO[_msgSender()][idoToken] = true; \n                userIDOs[_msgSender()].push(idoToken); \n            } \n        } \n        emit IDO( \n            _msgSender(), \n            idoToken, \n            totalprice, \n            idoAmount, \n            fidoFee, \n            insurance, \n            inviteFee \n        ); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./ERC20/ERC20.sol\"; \nimport \"./ERC20/ERC20Burnable.sol\"; \nimport \"./ERC20/ERC20Mintable.sol\"; \nimport \"./Ownable.sol\"; \n \ncontract FIDO is ERC20Mintable, ERC20Burnable, Ownable { \n    using SafeMath for uint256; \n \n    address public operator; \n \n    uint256 private _cap = 210000000 * 10**18; \n    uint256 public shareRateDecimal = 4; // 10000 \n    uint8 public totalReleaseWeek = 25; \n    uint8 public releasedWeek = 0; \n    uint256 public lastRealeaseTime = 0; \n    address[] public releaseRecipient; \n    mapping(address => uint256) public releaseShareRate; \n    event Release(uint256 timestamp, uint8 releaseCount); \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    constructor(address _operator) ERC20(\"FIDO\", \"FIDO\") Pausable() Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        _setupDecimals(18); \n        addReleaseRecipient(0x9Dafc698200B9Bb509612ae39f007855d1c26B3D, 605); \n        addReleaseRecipient(0xAf9736eC4814a2947B7B64354c612A41Be518b9f, 110);  \n        addReleaseRecipient(0x6fc89Ac788A31880f020AabA39dB49e05D803670, 100); \n        addReleaseRecipient(0x6B8A58B626dE1Aa35b9E24d4e9012E33d7084CD5, 100); // 1% \n        addReleaseRecipient(0xeb8d2AC91A66b8A7790c808a5B172E647a81103a, 60); \n        addReleaseRecipient(0x90d5111f4C736Ac4A0B0f90589149cD25A894537, 57); \n        addReleaseRecipient(0xF3DFAcED2aE482473BEC9Ab00863C51B132e8169, 50); \n        addReleaseRecipient(0x78CfF87757fbE3a18a23d28A3Ad216b5F1d26a7F, 40); \n        addReleaseRecipient(0xC6D294310A8D9946c458dD886A51EFA3DA04593f, 40); \n        addReleaseRecipient(0x6CA91d3f8675D83bBEf4bb3C522CF75b1B4AAD1C, 40); \n        addReleaseRecipient(0xA73558c94cBDB42eF189E68C9D993D252f6F252B, 40); \n        addReleaseRecipient(0xE9088899D6b8b1082A051d6bC06AD2B6e7AECe31, 40); \n        addReleaseRecipient(0xf6c062b71344650e0A23Ff7D10e00842147e5e21, 30); \n        addReleaseRecipient(0xf1c0091B3eFEC6e621E285b6a980734b9C437b85, 30); \n        addReleaseRecipient(0x3Fc3f768c5eDC881690b33292F499964917b8189, 30); \n        addReleaseRecipient(0x71192f0df65a58982fFA4e413296389f98c853B7, 20); \n        addReleaseRecipient(0xf0f9b88B3e66D61469DB584712B52372C1e55E69, 15); \n        addReleaseRecipient(0xeb84d5762ba1A68c3d0723518D12Ad417Df49363, 15); \n        addReleaseRecipient(0xB2c04a3B20B5a498bcAE1576900A000971EDb6Dd, 10); \n        addReleaseRecipient(0x52abb7EC70685b0C484F3fbc20Cce473A6c00dD3, 10); \n        addReleaseRecipient(0x1cBb40e2137741Dbf6A1aFc1fa0a95fB1016b30f, 10); \n        addReleaseRecipient(0xBe19c8eCf41a3F38664827C89aAD87f16dF3De38, 10); \n        addReleaseRecipient(0x1F6361D690789761035585338826E4F89cbA9a44, 10); // 0.1% \n        addReleaseRecipient(0xe674816FD0C0e4062B7e43dC72c34cb3023fB825, 10); \n        addReleaseRecipient(0x6924F8E39623a1f5aA776637d2008Ad1c4e16598, 5); \n        addReleaseRecipient(0x979cAE9260C799E73cd320936b5c5A902D291636, 5); \n        addReleaseRecipient(0x7Facf41272d5a8c490Cb79CfE84981169259d935, 5); \n        addReleaseRecipient(0x0299386481015Ce66FC3818DE9E7d5302FFf5278, 3); \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function pause() external onlyOperator { \n        _pause(); \n    } \n \n    function unPause() external onlyOperator { \n        _unpause(); \n    } \n \n    function addMinter(address minter) external onlyOperator { \n        _addMinter(minter); \n    } \n \n    function removeMinter(address minter) external onlyOperator { \n        _removeMinter(minter); \n    } \n \n    function addReleaseRecipient(address recipient, uint256 shareRate) \n        internal \n    { \n        require(releaseShareRate[recipient] == 0, \"already a releaseRecipient\"); \n        releaseRecipient.push(recipient); \n        releaseShareRate[recipient] = shareRate; \n    } \n \n    function releaseShare() external onlyOperator() { \n        require( \n            block.timestamp - lastRealeaseTime > 1 weeks, \n            \"FIDO: see you next week\" \n        ); \n        require( \n            releasedWeek < totalReleaseWeek, \n            \"FIDO: no share needs to release\" \n        ); \n        uint256 amount; \n        for (uint256 index = 0; index < releaseRecipient.length; index++) { \n            amount = releaseShareRate[releaseRecipient[index]] \n                .mul(_cap) \n                .div(10**shareRateDecimal) \n                .div(totalReleaseWeek); \n            _mint(releaseRecipient[index], amount); \n        } \n        releasedWeek += 1; \n        lastRealeaseTime = block.timestamp; \n        emit Release(block.timestamp, releasedWeek); \n    } \n \n    /** \n     * @dev Returns the cap on the token's total supply. \n     */ \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_beforeTokenTransfer}. \n     * \n     * Requirements: \n     * \n     * - minted tokens must not cause the total supply to go over the cap. \n     */ \n    function _beforeTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual override { \n        super._beforeTokenTransfer(from, to, amount); \n \n        if (from == address(0)) { \n            // When minting tokens \n            require(totalSupply().add(amount) <= cap(), \"ERC20: cap exceeded\"); \n        } \n    } \n} \n",
            "pragma solidity >=0.4.22 <0.9.0; \n \ncontract Migrations { \n  address public owner = msg.sender; \n  uint public last_completed_migration; \n \n  modifier restricted() { \n    require( \n      msg.sender == owner, \n      \"This function is restricted to the contract's owner\" \n    ); \n    _; \n  } \n \n  function setCompleted(uint completed) public restricted { \n    last_completed_migration = completed; \n  } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./libraries/SafeMath.sol\"; \nimport \"./interfaces/IFidoUsdtLPPool.sol\"; \n \ninterface IMFILPool { \n    function userStake(address) external view returns (uint256); \n} \n \ncontract FidoMember is Ownable { \n    using SafeMath for uint256; \n    address public operator; \n \n    address public fidoOfficial; \n    address public pool; \n    address public mfilPool; \n \n    // invite0Rate = baseRate + multiRate x (invite0 / (invite0 + invite1)) % \n    // invite1Rate = 100 - invite0Rate % \n    uint256 public baseRate = 40; \n    uint256 public multiRate = 40; \n    uint256 public rateDecimal = 2; // 100 \n    uint256 public stakeMin = 0; \n \n    mapping(address => bool) public isMember; \n    mapping(address => bool) public isInvited; \n    mapping(address => address) public inviter; \n    mapping(address => uint256) public joinBlockHeight; \n    mapping(address => address[]) public followers; \n \n    event NewMember( \n        address indexed member, \n        address indexed inviter, \n        uint256 joinBlockHeight \n    ); \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    event AdjustRate(uint256 baseRate, uint256 multiRate); \n \n    event AdjustStakeMin(uint256 stakeMin); \n \n    constructor( \n        address _operator, \n        address _fidoOfficial, \n        address _pool \n    ) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        fidoOfficial = _fidoOfficial; \n        pool = _pool; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function adjustRate(uint256 _baseRate, uint256 _multiRate) \n        external \n        onlyOperator \n    { \n        baseRate = _baseRate; \n        multiRate = _multiRate; \n        emit AdjustRate(baseRate, multiRate); \n    } \n \n    function changeRateDecimal(uint256 newRateDecimal) external onlyOperator { \n        rateDecimal = newRateDecimal; \n    } \n \n    function changeStakeMin(uint256 newStakeMin) external onlyOperator { \n        stakeMin = newStakeMin; \n        emit AdjustStakeMin(stakeMin); \n    } \n \n    function joinFido(address _inviter) external { \n        require(!isMember[_msgSender()], \"FidoMember: already joined\"); \n        if (_inviter != address(0)) { \n            require(isMember[_inviter], \"FidoMember: inviter not joined\"); \n            isInvited[_msgSender()] = true; \n            inviter[_msgSender()] = _inviter; \n            followers[_inviter].push(_msgSender()); \n        } \n        isMember[_msgSender()] = true; \n        joinBlockHeight[_msgSender()] = block.number; \n        emit NewMember(_msgSender(), _inviter, block.number); \n    } \n \n    function changeMFILPool(address newMfilpool) external onlyOwner { \n        mfilPool = newMfilpool; \n    } \n \n    function changeFidoOfficial(address newFidoOfficial) external onlyOwner { \n        fidoOfficial = newFidoOfficial; \n    } \n \n    function changePool(address newPool) external onlyOwner { \n        pool = newPool; \n    } \n \n    function getFollowerCount(address member) external view returns (uint256) { \n        return followers[member].length; \n    } \n \n    function caleInviteRate(address member) \n        external \n        view \n        returns ( \n            address inviter0, \n            address inviter1, \n            address fido, \n            uint256 rate0, \n            uint256 rate1, \n            uint256 fidoRate \n        ) \n    { \n        require(isMember[member], \"FidoMember: not FIDO member.\"); \n        uint256 mfilStake0; \n        uint256 mfilStake1; \n        uint256 mfilStake2 = IMFILPool(mfilPool).userStake(member); \n        uint256 fullRate = 10**rateDecimal; \n        if (!isInvited[member]) { \n            return (fidoOfficial, fidoOfficial, fidoOfficial, 0, 0, fullRate); \n        } \n        inviter0 = inviter[member]; \n        uint256 stake0 = IFidoUsdtLPPool(pool).userTokenBStake(inviter0); \n        inviter1 = isInvited[inviter0] ? inviter[inviter0] : fidoOfficial; \n        if (inviter1 == fidoOfficial) { \n            if (stake0 >= stakeMin) { \n                if (mfilStake2 == 0) { \n                    return ( \n                        inviter0, \n                        fidoOfficial, \n                        fidoOfficial, \n                        baseRate + multiRate, \n                        0, \n                        fullRate.sub(baseRate + multiRate) \n                    ); \n                } \n                mfilStake0 = IMFILPool(mfilPool).userStake(inviter0); \n                rate0 = baseRate + multiRate; \n                if (mfilStake0 < mfilStake2) { \n                    rate0 = rate0.mul(mfilStake0).div(mfilStake2); \n                } \n                return ( \n                    inviter0, \n                    fidoOfficial, \n                    fidoOfficial, \n                    rate0, \n                    0, \n                    fullRate.sub(rate0) \n                ); \n            } else { \n                return ( \n                    fidoOfficial, \n                    fidoOfficial, \n                    fidoOfficial, \n                    0, \n                    0, \n                    fullRate \n                ); \n            } \n        } \n        uint256 stake1 = IFidoUsdtLPPool(pool).userTokenBStake(inviter1); \n        if (stake0 < stakeMin) { \n            if (stake1 < stakeMin) { \n                return ( \n                    fidoOfficial, \n                    fidoOfficial, \n                    fidoOfficial, \n                    0, \n                    0, \n                    fullRate \n                ); \n            } else { \n                rate1 = fullRate.sub(baseRate); \n                if (mfilStake2 == 0) { \n                    return ( \n                        fidoOfficial, \n                        inviter1, \n                        fidoOfficial, \n                        0, \n                        rate1, \n                        fullRate.sub(rate1) \n                    ); \n                } \n                mfilStake1 = IMFILPool(mfilPool).userStake(inviter1); \n                if (mfilStake1 < mfilStake2) { \n                    rate1 = rate1.mul(mfilStake1).div(mfilStake2); \n                } \n                return ( \n                    fidoOfficial, \n                    inviter1, \n                    fidoOfficial, \n                    0, \n                    rate1, \n                    fullRate.sub(rate1) \n                ); \n            } \n        } \n        if (stake1 < stakeMin) { \n            inviter1 = fidoOfficial; \n            if (stake0 < stakeMin) { \n                return ( \n                    fidoOfficial, \n                    fidoOfficial, \n                    fidoOfficial, \n                    0, \n                    0, \n                    fullRate \n                ); \n            } else { \n                if (mfilStake2 == 0) { \n                    return ( \n                        inviter0, \n                        fidoOfficial, \n                        fidoOfficial, \n                        baseRate + multiRate, \n                        0, \n                        fullRate.sub(baseRate + multiRate) \n                    ); \n                } \n                rate0 = baseRate + multiRate; \n                mfilStake0 = IMFILPool(mfilPool).userStake(inviter0); \n                if (mfilStake0 < mfilStake2) { \n                    rate0 = rate0.mul(mfilStake0).div(mfilStake2); \n                } \n                return ( \n                    inviter0, \n                    fidoOfficial, \n                    fidoOfficial, \n                    rate0, \n                    0, \n                    fullRate.sub(rate0) \n                ); \n            } \n        } \n        fido = fidoOfficial; \n        rate0 = baseRate.add( \n            stake0.mul(multiRate).mul(fullRate).div(stake0.add(stake1)).div( \n                fullRate \n            ) \n        ); \n        rate1 = fullRate.sub(rate0); \n        if (mfilStake2 > 0) { \n            mfilStake0 = IMFILPool(mfilPool).userStake(inviter0); \n            mfilStake1 = IMFILPool(mfilPool).userStake(inviter1); \n            if (mfilStake0 < mfilStake2) { \n                rate0 = rate0.mul(mfilStake0).div(mfilStake2); \n            } \n            if (mfilStake1 < mfilStake2) { \n                rate1 = rate1.mul(mfilStake1).div(mfilStake2); \n            } \n            fidoRate = fullRate.sub(rate0.add(rate1)); \n        } \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./StakeLPRewardPerBlock.sol\"; \n \ncontract FidoUsdtLPPool is StakeLPRewardPerBlock { \n \n    address public usdt; \n    address public fido; \n    constructor( \n        address _facotry, \n        address _operator, \n        address _usdt, \n        address _fido \n    ) StakeLPRewardPerBlock(_facotry, _operator, _usdt, _fido, _fido) { \n        usdt = _usdt; \n        fido = _fido; \n    } \n \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./ERC20/ERC20.sol\"; \nimport \"./ERC20/ERC20Burnable.sol\"; \nimport \"./ERC20/ERC20Mintable.sol\"; \nimport \"./ERC20/ERC20Pausable.sol\"; \nimport \"./Ownable.sol\"; \n \ncontract MFIL is ERC20Mintable, ERC20Burnable, Ownable { \n    using SafeMath for uint256; \n \n    address public operator; \n    uint256 private _cap = 2000000000 * 10**18; \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    constructor(address _operator) \n        ERC20(\"Mirror FileCoin\", \"MFIL\") \n        Pausable() \n        Ownable() \n    { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        _setupDecimals(18); \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function pause() external onlyOperator { \n        _pause(); \n    } \n \n    function unPause() external onlyOperator { \n        _unpause(); \n    } \n \n    function addMinter(address minter) external onlyOperator { \n        _addMinter(minter); \n    } \n \n    function removeMinter(address minter) external onlyOperator { \n        _removeMinter(minter); \n    } \n \n    /** \n     * @dev Returns the cap on the token's total supply. \n     */ \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_beforeTokenTransfer}. \n     * \n     * Requirements: \n     * \n     * - minted tokens must not cause the total supply to go over the cap. \n     */ \n    function _beforeTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual override { \n        super._beforeTokenTransfer(from, to, amount); \n \n        if (from == address(0)) { \n            // When minting tokens \n            require(totalSupply().add(amount) <= cap(), \"ERC20: cap exceeded\"); \n        } \n    } \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    function _initOwner(address owner_) internal { \n        require(owner_ != address(0), \"Ownable: owner cannot be init to zero address\"); \n        _owner = owner_; \n        emit OwnershipTransferred(address(0), _owner); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./libraries/SafeMath.sol\"; \nimport \"./Context.sol\"; \n \ncontract StakeRewardPerDay is Context { \n    using SafeMath for uint256; \n \n    uint256 public rewardRate; // Global Reward per Unit \n    uint256 public constant blockCountPerDay = 20 * 60 * 24; // 3s - 1 block, 1min - 20 blocks \n    uint256 public rewardToday; \n    uint256 public rewardPreBlock; // rewardToday / blockCountPerDay \n    uint256 public lastUpdateBlock; // last adjust block height \n    uint256 public totalStake; \n    uint256 public todayStartBlock; \n    uint256 public todayEndBlock; // todayStartBlock + blockCountPerDay \n    mapping(address => uint256) public userStake; \n    mapping(address => uint256) public userReward; \n    mapping(address => uint256) public userRate; \n \n    constructor() { \n        rewardRate = 0; \n        rewardToday = 0; \n        rewardPreBlock = 0; \n        totalStake = 0; \n        lastUpdateBlock = block.number; \n        todayStartBlock = block.number; \n        todayEndBlock = todayStartBlock + blockCountPerDay; \n    } \n \n    modifier updateRate() { \n        if ( \n            rewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > lastUpdateBlock && \n            todayEndBlock > lastUpdateBlock \n        ) { \n            uint256 duringBlock; \n            if (block.number < todayEndBlock) { \n                duringBlock = block.number - lastUpdateBlock; \n                lastUpdateBlock = block.number; \n            } else { \n                duringBlock = todayEndBlock - lastUpdateBlock; \n                lastUpdateBlock = todayEndBlock; \n            } \n            uint256 deltaRate = rewardPreBlock.mul(duringBlock).div(totalStake); \n            rewardRate = rewardRate.add(deltaRate); \n        } \n        if(rewardPreBlock == 0){ \n            lastUpdateBlock = block.number; \n        } \n        _; \n    } \n \n    modifier updateEndRate() { \n        if ( \n            rewardPreBlock > 0 && \n            totalStake > 0 && \n            todayEndBlock > lastUpdateBlock \n        ) { \n            uint256 duringBlock = todayEndBlock - lastUpdateBlock; \n            uint256 deltaRate = rewardPreBlock.mul(duringBlock).div(totalStake); \n            rewardRate = rewardRate.add(deltaRate); \n        } \n        if(rewardPreBlock == 0){ \n            lastUpdateBlock = block.number; \n        } \n        _; \n    } \n \n    modifier getReward() { \n        if (userStake[_msgSender()] > 0 && rewardRate > userRate[_msgSender()]) { \n            uint256 deltaReward = \n                rewardRate.sub(userRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            userReward[_msgSender()] = userReward[_msgSender()].add( \n                deltaReward \n            ); \n        } \n        userRate[_msgSender()] = rewardRate; \n        _; \n    } \n \n    function _addNewReward(uint256 amount) internal updateEndRate{ \n        rewardToday = amount; \n        rewardPreBlock = amount.mul(1e18).div(blockCountPerDay); \n        todayStartBlock = block.number; \n        todayEndBlock = todayStartBlock + blockCountPerDay; \n    } \n \n    function _stake(uint256 amount) updateRate getReward internal virtual { \n        userStake[_msgSender()] = userStake[_msgSender()].add(amount); \n        totalStake = totalStake.add(amount); \n    } \n    function _halveNoUpdate() internal returns (uint256 reward){ \n        reward = userReward[_msgSender()].div(1e18); \n        userReward[_msgSender()] = 0; \n    } \n \n    function _halve() updateRate getReward internal returns (uint256 reward){ \n        return _halveNoUpdate(); \n    } \n \n    function _unStake() updateRate getReward internal virtual returns (uint256 stake, uint256 reward)\n        stake = userStake[_msgSender()]; \n        totalStake = totalStake.sub(stake); \n        userStake[_msgSender()] = 0; \n        reward = _halveNoUpdate(); \n    } \n \n    function _getStake() view internal returns (uint256 stake) { \n        stake = userStake[_msgSender()]; \n    } \n \n    function _caleReward() view internal returns (uint256 reward) { \n        if(userStake[_msgSender()] == 0){ \n            return 0; \n        } \n        uint256 tempRate = rewardRate; \n        if ( \n            rewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > lastUpdateBlock && \n            todayEndBlock > lastUpdateBlock \n        ) { \n            uint256 duringBlock; \n            if (block.number < todayEndBlock) { \n                duringBlock = block.number - lastUpdateBlock; \n            } else { \n                duringBlock = todayEndBlock - lastUpdateBlock; \n            } \n            uint256 deltaRate = rewardPreBlock.mul(duringBlock).div(totalStake); \n            tempRate = tempRate.add(deltaRate); \n        } \n        reward = userReward[_msgSender()]; \n        if (tempRate > userRate[_msgSender()]) { \n            uint256 deltaReward = \n                tempRate.sub(userRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            reward = reward.add( \n                deltaReward \n            ); \n        } \n        reward = reward.div(1e18); \n    } \n \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./StakeLPRewardPerDay.sol\"; \nimport \"./interfaces/IFidoMember.sol\"; \nimport \"./interfaces/IMFIL.sol\"; \n \ninterface IMFILPool { \n    function lendFil(uint256 totalT, uint256 userStakeFil) \n        external \n        returns (uint256 lendAmount); \n \n    function returnFil(uint256 amount) external; \n} \n \ninterface IMfilIdoTokenLPPoolFactory { \n    function operator() external view returns (address); \n \n    function MfilStakePool() external view returns (address); \n \n    function FidoMember() external view returns (address); \n \n    function inviteFeeRate() external view returns (uint256); \n \n    function inviteFeeRateDecimals() external view returns (uint256); \n} \n \ncontract MfilIdoTokenLPPool is StakeLPRewardPerDay { \n    using SafeMath for uint256; \n \n    address public mfil; \n    address public idoToken; \n    address public lpPoolFactory; \n \n    uint256 public totalMfilLend; \n    mapping(address => uint256) public userMfilLend; \n \n    constructor( \n        address _factory, \n        address fidoOwner, \n        address _mfil, \n        address _idoToken \n    ) StakeLPRewardPerDay(_factory, fidoOwner, _mfil, _idoToken, _mfil) { \n        lpPoolFactory = _msgSender(); \n        mfil = _mfil; \n        idoToken = _idoToken; \n    } \n \n    modifier onlyMfilStakePool() { \n        require( \n            _msgSender() == \n                IMfilIdoTokenLPPoolFactory(lpPoolFactory).MfilStakePool(), \n            \"MFIL-IDOTOKEN-LP-POOL: caller is not the MfilStakePool\" \n        ); \n        _; \n    } \n \n    function MfilStakePool() external view returns (address) { \n        return IMfilIdoTokenLPPoolFactory(lpPoolFactory).MfilStakePool(); \n    } \n \n    function FidoMember() external view returns (address) { \n        return IMfilIdoTokenLPPoolFactory(lpPoolFactory).FidoMember(); \n    } \n \n    function inviteFeeRateDecimals() external view returns (uint256) { \n        return \n            IMfilIdoTokenLPPoolFactory(lpPoolFactory).inviteFeeRateDecimals(); \n    } \n \n    function inviteFeeRate() external view returns (uint256) { \n        return IMfilIdoTokenLPPoolFactory(lpPoolFactory).inviteFeeRate(); \n    } \n \n    function _lendFil(uint256 totalT, uint256 userStakeFil) \n        internal \n        returns (uint256 lendAmount) \n    { \n        lendAmount = IMFILPool(this.MfilStakePool()).lendFil( \n            totalT, \n            userStakeFil \n        ); \n        userMfilLend[_msgSender()] = userMfilLend[_msgSender()].add(lendAmount); \n        totalMfilLend = totalMfilLend.add(lendAmount); \n    } \n \n    function _returnFIL() internal returns (uint256 amount) { \n        amount = userMfilLend[_msgSender()]; \n        IMFILPool(this.MfilStakePool()).returnFil(amount); \n        userMfilLend[_msgSender()] = 0; \n        totalMfilLend = totalMfilLend.sub(amount); \n    } \n \n    function _stakeHook( \n        uint256 amountAIn, \n        uint256 amountBIn, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ) internal override { \n        amountB = amountB.mul(stakeRate).div(stakeRate - 1); \n        _lendFil(amountB, amountA); \n    } \n \n    function _unStakeHook( \n        uint256 reward, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ) internal override { \n        _returnFIL(); \n        uint256 inviteFee = \n            reward.mul(this.inviteFeeRate()).div( \n                10**uint256(this.inviteFeeRateDecimals()) \n            ); \n        { \n            address inviter0; \n            address inviter1; \n            address fido; \n            uint256 rate0; \n            uint256 rate1; \n            uint256 fidoRate; \n            uint256 fee; \n            (inviter0, inviter1, fido, rate0, rate1, fidoRate) = IFidoMember( \n                this.FidoMember() \n            ) \n                .caleInviteRate(_msgSender()); \n            fee = inviteFee.mul(rate0).div( \n                10**IFidoMember(this.FidoMember()).rateDecimal() \n            ); \n            IMFIL(mfil).mint(inviter0, fee); \n            fee = inviteFee.mul(rate1).div( \n                10**IFidoMember(this.FidoMember()).rateDecimal() \n            ); \n            IMFIL(mfil).mint(inviter1, fee); \n            fee = inviteFee.mul(fidoRate).div( \n                10**IFidoMember(this.FidoMember()).rateDecimal() \n            ); \n            IMFIL(mfil).mint(fido, fee); \n        } \n    } \n \n    function newReward(uint256 amount) \n        external \n        virtual \n        override \n        onlyMfilStakePool \n        whenNotPaused \n    { \n        _addNewReward(amount); \n        emit NewReward(block.number, amount); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./StakeRewardPerBlock.sol\"; \nimport \"./MdexRouter.sol\"; \nimport \"./Ownable.sol\"; \nimport \"./Pausable.sol\"; \nimport \"./ReentrancyGuard.sol\"; \nimport \"./interfaces/IERC20Mintable.sol\"; \n \ncontract StakeLPRewardPerBlock is \n    StakeRewardPerBlock, \n    MdexRouter, \n    Ownable, \n    Pausable, \n    ReentrancyGuard \n{ \n    using SafeMath for uint256; \n \n    uint8 public stakeRate = 5; \n \n    address public tokenA; // for one \n    address public tokenB; // for stakeRate \n    address public rewardToken; // for reward \n    address public operator; \n \n    mapping(address => uint256) public userTokenBStake; \n    uint256 public totalTokenBStake; \n \n    event Stake( \n        address indexed sender, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ); \n    event UnStake( \n        address indexed receiver, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ); \n    event Reward(address indexed receiver, uint256 reward); \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n    event NewReward(uint256 blockHeight, uint256 amount); \n \n    constructor( \n        address _factory, \n        address _operator, \n        address _tokenA, \n        address _tokenB, \n        address _rewardToken \n    ) \n        StakeRewardPerBlock() \n        MdexRouter(_factory) \n        Ownable() \n        Pausable() \n        ReentrancyGuard() \n    { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        tokenA = _tokenA; \n        tokenB = _tokenB; \n        rewardToken = _rewardToken; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function pause() external onlyOperator { \n        _pause(); \n    } \n \n    function unPause() external onlyOperator { \n        _unpause(); \n    } \n \n    function caleLiquidity( \n        uint256 amountADesired, \n        uint256 amountBDesired, \n        uint256 amountAMin, \n        uint256 amountBMin \n    ) external view returns (uint256 amountA, uint256 amountB) { \n        require( \n            IMdexFactory(factory).getPair(tokenA, tokenB) != address(0), \n            \"MdexRouter: Pair Not Found!\" \n        ); \n        (uint256 reserveA, uint256 reserveB) = \n            IMdexFactory(factory).getReserves(tokenA, tokenB); \n        if (reserveA == 0 && reserveB == 0) { \n            (amountA, amountB) = (amountADesired, amountBDesired); \n        } else { \n            uint256 amountBOptimal = \n                IMdexFactory(factory).quote(amountADesired, reserveA, reserveB); \n            if (amountBOptimal <= amountBDesired) { \n                require( \n                    amountBOptimal >= amountBMin, \n                    \"MdexRouter: INSUFFICIENT_B_AMOUNT\" \n                ); \n                (amountA, amountB) = (amountADesired, amountBOptimal); \n            } else { \n                uint256 amountAOptimal = \n                    IMdexFactory(factory).quote( \n                        amountBDesired, \n                        reserveB, \n                        reserveA \n                    ); \n                assert(amountAOptimal <= amountADesired); \n                require( \n                    amountAOptimal >= amountAMin, \n                    \"MdexRouter: INSUFFICIENT_A_AMOUNT\" \n                ); \n                (amountA, amountB) = (amountAOptimal, amountBDesired); \n            } \n        } \n    } \n \n    function stake(uint256 amountAIn, uint256 amountBIn) \n        external \n        whenNotPaused \n        nonReentrant \n        returns ( \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ) \n    { \n        require(amountAIn > 0 && amountBIn > 0, \"STAKE: amount is zero\"); \n        uint256 tempAmountB = amountBIn.div(stakeRate); \n        (amountA, amountB, liquidity) = addLiquidity( \n            tokenA, \n            tokenB, \n            amountAIn, \n            tempAmountB, \n            0, \n        ); \n        amountB = amountB.mul(stakeRate - 1); \n        TransferHelper.safeTransferFrom( \n            tokenB, \n            _msgSender(), \n            address(this), \n            amountB \n        ); \n        userTokenBStake[_msgSender()] = userTokenBStake[_msgSender()].add( \n            amountB \n        ); \n        totalTokenBStake = totalTokenBStake.add(amountB); \n        _stake(liquidity); \n        emit Stake(_msgSender(), amountA, amountB, liquidity); \n    } \n \n    function getStake() external view whenNotPaused returns (uint256 amount) { \n        amount = _getStake(); \n    } \n \n    function halve() \n        external \n        whenNotPaused \n        nonReentrant \n        returns (uint256 reward) \n    { \n        reward = _Bhalve(); \n        IERC20Mintable(rewardToken).mint(_msgSender(), reward); \n        emit Reward(_msgSender(), reward); \n    } \n \n    function unStake() \n        external \n        whenNotPaused \n        nonReentrant \n        returns ( \n            uint256 reward, \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ) \n    { \n        (liquidity, reward) = _unStake(); \n        require(liquidity > 0, \"UNSTAKE: no stake\"); \n        IERC20Mintable(rewardToken).mint(_msgSender(), reward); \n        emit Reward(_msgSender(), reward); \n        (amountA, amountB) = removeLiquidity( \n            tokenA, \n            tokenB, \n            liquidity, \n            0, \n            0, \n            _msgSender() \n        ); \n        IERC20(tokenB).transfer(_msgSender(), userTokenBStake[_msgSender()]); \n        amountB.add(userTokenBStake[_msgSender()]); \n        userTokenBStake[_msgSender()] = 0; \n        emit UnStake(_msgSender(), amountA, amountB, liquidity); \n    } \n \n    function adjustReward(uint256 amount) external onlyOperator whenNotPaused { \n        _setReward(amount); \n        emit NewReward(block.number, amount); \n    } \n \n    function caleReward() external view whenNotPaused returns (uint256 reward) { \n        reward = _BcaleReward(); \n    } \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return t\nlibrary TransferHelper { \n    function safeApprove(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('approve(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n    } \n \n    function safeTransfer(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferFrom(address token, address from, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferETH(address to, uint value) internal { \n        (bool success,) = to.call{value : value}(new bytes(0)); \n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED'); \n    } \n}// SPDX-License-Identifier: MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n \n/** \n * @dev Contract module which allows children to implement an emergency stop \n * mechanism that can be triggered by an authorized account. \n * \n * This module is used through inheritance. It will make available the \n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to \n * the functions of your contract. Note that they will not be pausable by \n * simply including this module, only once the modifiers are put in place. \n */ \nabstract contract Pausable is Context { \n    /** \n     * @dev Emitted when the pause is triggered by `account`. \n     */ \n    event Paused(address account); \n \n    /** \n     * @dev Emitted when the pause is lifted by `account`. \n     */ \n    event Unpaused(address account); \n \n    bool private _paused; \n \n    /** \n     * @dev Initializes the contract in unpaused state. \n     */ \n    constructor () { \n        _paused = false; \n    } \n \n    /** \n     * @dev Returns true if the contract is paused, and false otherwise. \n     */ \n    function paused() public view virtual returns (bool) { \n        return _paused; \n    } \n \n    /** \n     * @dev Modifier to make a function callable only when the contract is not paused. \n     * \n     * Requirements: \n     * \n     * - The contract must not be paused. \n     */ \n    modifier whenNotPaused() { \n        require(!paused(), \"Pausable: paused\"); \n        _; \n    } \n \n    /** \n     * @dev Modifier to make a function callable only when the contract is paused. \n     * \n     * Requirements: \n     * \n     * - The contract must be paused. \n     */ \n    modifier whenPaused() { \n        require(paused(), \"Pausable: not paused\"); \n        _; \n    } \n \n    /** \n     * @dev Triggers stopped state. \n     * \n     * Requirements: \n     * \n     * - The contract must not be paused. \n     */ \n    function _pause() internal virtual whenNotPaused { \n        _paused = true; \n        emit Paused(_msgSender()); \n    } \n \n    /** \n     * @dev Returns to normal state. \n     * \n     * Requirements: \n     * \n     * - The contract must be paused. \n     */ \n    function _unpause() internal virtual whenPaused { \n        _paused = false; \n        emit Unpaused(_msgSender()); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./interfaces/IERC20.sol\"; \nimport \"./libraries/SafeMath.sol\"; \n \ncontract FidoMargin is Ownable { \n    using SafeMath for uint256; \n \n    address public operator; \n    address public marginToken; \n    mapping (address => uint256) public margin; \n    mapping (address => bool) public withdrawStatus; \n    mapping (address => uint256) public withdrawAmount; \n    mapping (address => address) public withdrawRecipient; \n \n    event DepositMargin(uint256 timestamp, address indexed sender, uint256 amount); \n    event WithdrawRequest(uint256 timestamp, address indexed requester, uint256 amount, address index\n    event WithdrawResult(uint256 timestamp, address indexed requester, bool result); \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n    constructor (address _operator, address _marginToken) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        marginToken = _marginToken; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function depositMargin(uint256 amount) external { \n        IERC20(marginToken).transferFrom(_msgSender(), address(this), amount); \n        margin[_msgSender()] = margin[_msgSender()].add(amount); \n        emit DepositMargin(block.timestamp, _msgSender(), amount); \n    } \n \n    function withdrawRequest(address recipient, uint256 amount) external { \n        require(!withdrawStatus[_msgSender()], \"FidoMargin: already sent a request\"); \n        require(margin[_msgSender()] >= amount, \"FidoMargin: insufficient margin\"); \n \n        withdrawStatus[_msgSender()] = true; \n        withdrawAmount[_msgSender()] = amount; \n        withdrawRecipient[_msgSender()] = recipient; \n        emit WithdrawRequest(block.timestamp, _msgSender(), amount, recipient); \n    } \n \n    function withdrawResponse(address requester, bool result) external onlyOperator { \n        require(withdrawStatus[requester], \"FidoMargin: request not found\"); \n        if(result){ \n            IERC20(marginToken).transfer(withdrawRecipient[requester], withdrawAmount[requester]); \n            margin[_msgSender()] = margin[_msgSender()].sub(withdrawAmount[requester]); \n        } \n        withdrawStatus[requester] = false; \n        withdrawRecipient[requester] = address(0); \n        withdrawAmount[requester] = 0; \n        emit WithdrawResult(block.timestamp, requester, result); \n    } \n}// SPDX-License-Identifier: MIT \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"../Ownable.sol\"; \nimport \"../Pausable.sol\"; \n \ncontract RateOracle is Ownable, Pausable { \n    address public updater; \n    address public requester; \n \n    event UpdatershipTransferred( \n        address indexed previousUpdater, \n        address indexed newUpdater \n    ); \n \n    event RequestershipTransferred( \n        address indexed previousRequester, \n        address indexed newRequester \n    ); \n \n    modifier onlyUpdater() { \n        require(_msgSender() == updater, \"Oracle: caller is not the updater\"); \n        _; \n    } \n \n    modifier onlyRequester() { \n        require( \n            _msgSender() == requester, \n            \"Oracle: caller is not the requester\" \n        ); \n        _; \n    } \n \n    bool private _status = false; // request but not updated -> false; request and updated -> true \n    uint256 private _lastUpdateTime = 0; // last updated timestamp \n    uint256 private _lastRequestTime = 0; // last request timestamp \n \n    uint8 private _decimals = 18; // decimal \n    uint256 private _rate; // rate \n \n    event Request(uint256 indexed timestamp); \n    event Update(uint256 indexed timestamp, uint256 rate); \n \n    constructor(address _updater, address _requester) Ownable() Pausable() { \n        updater = _updater; \n        emit UpdatershipTransferred(address(0), updater); \n        requester = _requester; \n        emit RequestershipTransferred(address(0), requester); \n \n        _lastRequestTime = block.timestamp; \n        emit Request(block.timestamp); \n    } \n \n    function transferRequestership(address newRequester) external onlyOwner { \n        require( \n            newRequester != address(0), \n            \"Oracle: new Requester is the zero address\" \n        ); \n        emit RequestershipTransferred(requester, newRequester); \n        requester = newRequester; \n    } \n \n    function transferUpdatership(address newUpdater) external onlyOwner { \n        require( \n            newUpdater != address(0), \n            \"Oracle: new Updater is the zero address\" \n        ); \n        emit UpdatershipTransferred(updater, newUpdater); \n        updater = newUpdater; \n    } \n \n    function pause() external onlyOwner { \n        _pause(); \n    } \n \n    function unPause() external onlyOwner { \n        _unpause(); \n    } \n \n    function status() external view returns (bool) { \n        return _status; \n    } \n \n    function lastRequestTime() external view returns (uint256) { \n        return _lastRequestTime; \n    } \n \n    function lastUpdateTime() external view returns (uint256) { \n        return _lastUpdateTime; \n    } \n \n    function decimals() external view whenNotPaused returns (uint8) { \n        return _decimals; \n    } \n \n    function rate() external view whenNotPaused returns (uint256) { \n        return _rate; \n    } \n \n    function request() external onlyRequester whenNotPaused { \n        require(_status, \"Oracle: request already called\"); \n        _status = false; \n        _lastRequestTime = block.timestamp; \n        emit Request(block.timestamp); \n    } \n \n    function update(uint256 rate_) external onlyUpdater whenNotPaused { \n        require(!_status, \"Oracle: no request called\"); \n        require(rate_ > 0, \"Oracle: rate can not be zero\"); \n        _status = true; \n        _lastUpdateTime = block.timestamp; \n        _rate = rate_; \n        emit Update(block.timestamp, _rate); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./MFIL-IDOToken.sol\"; \nimport \"./interfaces/IIDOInfo.sol\"; \n \ncontract MfilIdoTokenLPPoolFactory is Ownable { \n    address public mfil; \n    address public factory; \n    address public MfilStakePool; \n    address public operator; \n    address public IDOInfo; \n    address public FidoMember; \n \n    uint256 public inviteFeeRate = 50; // inviteFee = inviteFeeRate / 10**inviteFeeRateDecimals \n    uint8 public inviteFeeRateDecimals = 3; \n \n    mapping (address => address) public ido2pool; \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    event NewPool(address indexed idoToken, address indexed pool); \n \n    constructor( \n        address _operator, \n        address _mfil, \n        address _factory, \n        address _IDOInfo, \n        address _FidoMember, \n        address _MfilStakePool \n    ) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        mfil = _mfil; \n        factory = _factory; \n        IDOInfo = _IDOInfo; \n        FidoMember = _FidoMember; \n        MfilStakePool = _MfilStakePool; \n \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function newPool(address idoToken) onlyOperator external returns (address pool) { \n        require(IIDOInfo(IDOInfo).exist(idoToken), \"PoolFactory: idoToken not found\"); \n        require(ido2pool[idoToken] == address(0), \"PoolFactory: pool exist\"); \n        MfilIdoTokenLPPool newpool = new MfilIdoTokenLPPool(factory, operator, mfil, idoToken); \n        pool = address(newpool); \n        ido2pool[idoToken] = pool; \n        emit NewPool(idoToken, pool); \n    } \n \n    function changePoolOperator(address idoToken, address newOperator) onlyOperator external { \n        require(ido2pool[idoToken] != address(0), \"PoolFactory: pool not found\"); \n        MfilIdoTokenLPPool(ido2pool[idoToken]).transferOperatorship(newOperator); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./StakeTokenPool.sol\"; \nimport \"./interfaces/IFidoMember.sol\"; \nimport \"./interfaces/IIDOInfo.sol\"; \nimport \"./interfaces/IRateOracle.sol\"; \nimport \"./interfaces/IMFIL.sol\"; \nimport \"./interfaces/IHFIL.sol\"; \nimport \"./interfaces/IERC20Mintable.sol\"; \nimport \"./libraries/TransferHelper.sol\"; \nimport \"./ReentrancyGuard.sol\"; \n \ninterface IMfilIdoTokenLPPool { \n    function newReward(uint256 amount) external; \n \n    function decimals() external view returns (uint8); \n} \n \ncontract MFILPool is StakeTokenPool, ReentrancyGuard { \n    using SafeMath for uint256; \n \n    address public hfil; \n    address public mfil; \n    address public fido; \n \n    address public FidoMember; \n    address public operator; \n    address public fidoFeeRecipient; \n    address public rateOracle; \n    address public IDOInfo; \n    address public HFILRecipient; \n \n    uint256 public totalMfilLend; \n    mapping(address => uint256) public MfilLend; \n    mapping(address => uint256) public poolLastPaid; \n    mapping(address => uint256) public poolFeeRate; \n \n    uint256 public totalPaid; \n    mapping(address => uint256) public poolTotalPaid; \n \n    uint256 public tomorrowReward; \n \n    uint256 public lendRewardRate = 12; // lendReward = lendRewardRate / 10**lendRewardRateDecimals \n    uint8 public lendRewardRateDecimals = 5; \n \n    uint256 public fidoFeeRate = 1; // fidoFee = fidoFeeRate / 10**fidoFeeRateDecimals \n    uint8 public fidoFeeRateDecimals = 2; \n \n    uint256 public inviteFeeRate = 10; // inviteFee = inviteFeeRate / 10**inviteFeeRateDecimals \n    uint8 public inviteFeeRateDecimals = 2; \n \n    uint256 public poolDefaultFeeRate = 100; // poolFee = poolFeeRate / 10**poolFeeDecimals \n    uint256 public poolFeeDecimals = 3; \n \n    uint256 public poolFidoFeeRate = 100; // poolFidoFee = poolFidoFeeRate / 10**poolFidoFeeDecimals \n    uint256 public poolFidoFeeDecimals = 3; \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    event Stake(address indexed sender, uint256 amount); \n \n    event UnStake( \n        address indexed receiver, \n        uint256 amount, \n        uint256 mfilReward, \n        uint256 fidoReward \n    ); \n \n    event Reward( \n        address indexed receiver, \n        uint256 mfilReward, \n        uint256 fidoReward \n    ); \n \n    event PayDaily( \n        address indexed pool, \n        address indexed payer, \n        uint256 deposit, \n        uint256 reward, \n        uint256 fidoFee, \n        uint256 lendReward \n    ); \n \n    event NewReward(uint256 blockHeight, uint256 amount); \n    event SetReward(uint256 blockHeight, uint256 amount); \n \n    constructor( \n        address _operator, \n        address _hfil, \n        address _mfil, \n        address _fido, \n        address _IDOInfo, \n        address _FidoMember, \n        address _fidoFeeRecipient, \n        address _HFILRecipient, \n        address _rateOracle \n    ) StakeTokenPool() ReentrancyGuard() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        hfil = _hfil; \n        mfil = _mfil; \n        fido = _fido; \n        FidoMember = _FidoMember; \n        fidoFeeRecipient = _fidoFeeRecipient; \n        HFILRecipient = _HFILRecipient; \n        IDOInfo = _IDOInfo; \n        rateOracle = _rateOracle; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function changeRateOracle(address _rateOracle) \n        external \n        onlyOwner \n        returns (bool) \n    { \n        require(_rateOracle != address(0), \"new address is zero address\"); \n        rateOracle = _rateOracle; \n        return true; \n    } \n \n    function changeIDOInfo(address _IDOInfo) external onlyOwner returns (bool) { \n        require(_IDOInfo != address(0), \"new address is zero address\"); \n        IDOInfo = _IDOInfo; \n        return true; \n    } \n \n    function changeFidoMember(address _FidoMember) \n        external \n        onlyOwner \n        returns (bool) \n    { \n        require(_FidoMember != address(0), \"new address is zero address\"); \n        FidoMember = _FidoMember; \n        return true; \n    } \n \n    function changeFidoFeeRecipient(address _fidoFeeRecipient) \n        external \n        onlyOwner \n        returns (bool) \n    { \n        require(_fidoFeeRecipient != address(0), \"new address is zero address\"); \n        fidoFeeRecipient = _fidoFeeRecipient; \n        return true; \n    } \n \n    function changeHFILRecipient(address _HFILRecipient) \n        external \n        onlyOwner \n        returns (bool) \n    { \n        require(_HFILRecipient != address(0), \"new address is zero address\"); \n        HFILRecipient = _HFILRecipient; \n        return true; \n    } \n \n    function pause() external onlyOperator { \n        _pause(); \n    } \n \n    function unPause() external onlyOperator { \n        _unpause(); \n    } \n \n    function changeFidoFeeRate(uint256 _fidoFeeRate, uint8 _fidoFeeRateDecimals) \n        external \n        onlyOperator \n    { \n        require( \n            _fidoFeeRateDecimals > 0, \n            \"fidoFeeRateDecimals must greater than zero\" \n        ); \n        fidoFeeRateDecimals = _fidoFeeRateDecimals; \n        fidoFeeRate = _fidoFeeRate; \n    } \n \n    function changeInviteFeeRate( \n        uint256 _inviteFeeRate, \n        uint8 _inviteFeeRateDecimals \n    ) external onlyOperator { \n        require( \n            _inviteFeeRateDecimals > 0, \n            \"inviteFeeRateDecimals must greater than zero\" \n        ); \n        inviteFeeRateDecimals = _inviteFeeRateDecimals; \n        inviteFeeRate = _inviteFeeRate; \n    } \n \n    function changeLendRewardRate( \n        uint256 _lendRewardRate, \n        uint8 _lendRewardRateDecimals \n    ) external onlyOperator { \n        require( \n            _lendRewardRateDecimals > 0, \n            \"lendRewardRateDecimals must greater than zero\" \n        ); \n        lendRewardRateDecimals = _lendRewardRateDecimals; \n        lendRewardRate = _lendRewardRate; \n    } \n \n    function changePoolDefaultFeeRate( \n        uint256 _poolDefaultFeeRate, \n        uint8 _poolFidoFeeDecimals \n    ) external onlyOperator { \n        require( \n            _poolFidoFeeDecimals > 0, \n            \"poolFidoFeeDecimals must greater than zero\" \n        ); \n        poolFidoFeeDecimals = _poolFidoFeeDecimals; \n        poolDefaultFeeRate = _poolDefaultFeeRate; \n    } \n \n    function changePoolFeeRate(address pool, uint256 _poolFeeRate) \n        external \n        onlyOperator \n    { \n        poolFeeRate[pool] = _poolFeeRate; \n    } \n \n    function changePoolFidoFeeRate( \n        uint256 _poolFidoFeeRate, \n        uint8 _poolFidoFeeDecimals \n    ) external onlyOperator { \n        require( \n            _poolFidoFeeDecimals > 0, \n            \"poolFidoFeeDecimals must greater than zero\" \n        ); \n        poolFidoFeeDecimals = _poolFidoFeeDecimals; \n        poolFidoFeeRate = _poolFidoFeeRate; \n    } \n \n    function caleReward() \n        external \n        view \n        whenNotPaused \n        returns (uint256 mfilReward, uint256 fidoReward) \n    { \n        mfilReward = _caleReward(); \n        fidoReward = _BcaleReward(); \n    } \n \n    function halve() \n        external \n        whenNotPaused \n        nonReentrant \n        returns (uint256 mfilReward, uint256 fidoReward) \n    { \n        mfilReward = _halve(); \n        fidoReward = _Bhalve(); \n \n        if (fidoReward > 0) { \n            uint256 inviteFee = \n                fidoReward.mul(inviteFeeRate).div( \n                    10**uint256(inviteFeeRateDecimals) \n                ); \n            fidoReward = fidoReward.sub(inviteFee); \n            { \n                address inviter0; \n                address inviter1; \n                address fidoer; \n                uint256 rate0; \n                uint256 rate1; \n                uint256 fidoRate; \n                uint256 fee; \n                ( \n                    inviter0, \n                    inviter1, \n                    fidoer, \n                    rate0, \n                    rate1, \n                    fidoRate \n                ) = IFidoMember(FidoMember).caleInviteRate(_msgSender()); \n                fee = inviteFee.mul(rate0).div( \n                    10**IFidoMember(FidoMember).rateDecimal() \n                ); \n                IERC20Mintable(fido).mint(inviter0, fee); \n                fee = inviteFee.mul(rate1).div( \n                    10**IFidoMember(FidoMember).rateDecimal() \n                ); \n                IERC20Mintable(fido).mint(inviter1, fee); \n                fee = inviteFee.mul(fidoRate).div( \n                    10**IFidoMember(FidoMember).rateDecimal() \n                ); \n                IERC20Mintable(fido).mint(fidoer, fee); \n            } \n            IERC20Mintable(fido).mint(fidoFeeRecipient, fidoReward); \n        } \n        if (mfilReward > 0) { \n            IMFIL(mfil).transfer(_msgSender(), mfilReward); \n        } \n        emit Reward(_msgSender(), mfilReward, fidoReward); \n    } \n \n    function stake(uint256 amount) external whenNotPaused nonReentrant { \n        require(amount > 0, \"STAKE: amount is zero\"); \n        TransferHelper.safeTransferFrom( \n            mfil, \n            _msgSender(), \n            address(this), \n            amount \n        ); \n        _stake(amount); \n    } \n \n    function unStake() \n        external \n        whenNotPaused \n        returns ( \n            uint256 amount, \n            uint256 mfilReward, \n            uint256 fidoReward \n        ) \n    { \n        (amount, mfilReward, fidoReward) = _unStakeAll(); \n        require(amount > 0, \"UNSTAKE: amount is zero\"); \n        IMFIL(mfil).transfer(_msgSender(), amount); \n        if (fidoReward > 0) { \n            uint256 inviteFee = \n                fidoReward.mul(inviteFeeRate).div( \n                    10**uint256(inviteFeeRateDecimals) \n                ); \n            fidoReward = fidoReward.sub(inviteFee); \n            { \n                address inviter0; \n                address inviter1; \n                address fidoer; \n                uint256 rate0; \n                uint256 rate1; \n                uint256 fidoRate; \n                uint256 fee; \n                ( \n                    inviter0, \n                    inviter1, \n                    fidoer, \n                    rate0, \n                    rate1, \n                    fidoRate \n                ) = IFidoMember(FidoMember).caleInviteRate(_msgSender()); \n                fee = inviteFee.mul(rate0).div( \n                    10**IFidoMember(FidoMember).rateDecimal() \n                ); \n                IERC20Mintable(fido).mint(inviter0, fee); \n                fee = inviteFee.mul(rate1).div( \n                    10**IFidoMember(FidoMember).rateDecimal() \n                ); \n                IERC20Mintable(fido).mint(inviter1, fee); \n                fee = inviteFee.mul(fidoRate).div( \n                    10**IFidoMember(FidoMember).rateDecimal() \n                ); \n                IERC20Mintable(fido).mint(fidoer, fee); \n            } \n            IERC20Mintable(fido).mint(fidoFeeRecipient, fidoReward); \n        } \n        if (mfilReward > 0) { \n            IMFIL(mfil).transfer(_msgSender(), mfilReward); \n        } \n        emit Reward(_msgSender(), mfilReward, fidoReward); \n        emit UnStake(_msgSender(), amount, mfilReward, fidoReward); \n    } \n \n    function lendFil(uint256 totalT, uint256 userStakeFil) \n        external \n        whenNotPaused \n        returns (uint256 lendAmount) \n    { \n        require( \n            IIDOInfo(IDOInfo).isPool(_msgSender()), \n            \"LENDFIL: not from pool\" \n        ); \n        // require(IRateOracle(rateOracle).rate() > 0,\"LENDFIL: oracle rate is zero\"); \n        lendAmount = totalT.mul(IRateOracle(rateOracle).rate()).div( \n            10**6 \n            // 10**IMfilIdoTokenLPPool(_msgSender()).decimals() \n        ); \n        // oracle & mfil decimals both 18 \n        if (lendAmount > userStakeFil) { \n            lendAmount = lendAmount.sub(userStakeFil); \n        } else { \n            lendAmount = 0; \n        } \n        MfilLend[_msgSender()] = MfilLend[_msgSender()].add(lendAmount); \n        totalMfilLend = totalMfilLend.add(lendAmount); \n    } \n \n    function returnFil(uint256 amount) external whenNotPaused { \n        require( \n            IIDOInfo(IDOInfo).isPool(_msgSender()), \n            \"RETURNFIL: not from pool\" \n        ); \n        totalMfilLend = totalMfilLend.sub(amount); \n        MfilLend[_msgSender()] = MfilLend[_msgSender()].add(amount); \n    } \n \n    function _getPoolFeeRate(address pool) internal view returns (uint256 fee) { \n        fee = poolFeeRate[pool] == 0 ? poolDefaultFeeRate : poolFeeRate[pool]; \n    } \n \n    function getPoolFeeRate(address pool) external view returns (uint256) { \n        return _getPoolFeeRate(pool); \n    } \n \n    function payDaily(uint256 deposit) external whenNotPaused { \n        address pool = IIDOInfo(IDOInfo).payer2pool(_msgSender()); \n        require(IIDOInfo(IDOInfo).isPool(pool), \"MFILPOOL: no pool to pay\"); \n        uint256 newDeposit = 0; \n        newDeposit = deposit.sub( \n            deposit.mul(_getPoolFeeRate(pool)).div(10**poolFeeDecimals) \n        ); \n        TransferHelper.safeTransferFrom( \n            hfil, \n            _msgSender(), \n            HFILRecipient, \n            newDeposit \n        ); \n        newDeposit = newDeposit.sub( \n            deposit.mul(poolFidoFeeRate).div(10**poolFidoFeeDecimals) \n        ); \n        totalPaid = totalPaid.add(newDeposit); \n        poolTotalPaid[pool] = poolTotalPaid[pool].add(newDeposit); \n        poolLastPaid[pool] = block.timestamp; \n        uint256 lendRate = totalStake.mul(100).div(totalMfilLend); \n        if (lendRate < 10) { \n            // If lend / totalStake < 10%, give all to miners \n            IMFIL(mfil).mint(pool, newDeposit); \n            IMfilIdoTokenLPPool(pool).newReward(newDeposit); \n            emit PayDaily(pool, _msgSender(), deposit, newDeposit, 0, 0); \n        } else { \n            uint256 tempLend = totalMfilLend.div(10**12); // 0.0001 * 100 \n            tempLend = tempLend.mul(tempLend).mul(tempLend); \n            uint256 temptotalStake = totalStake.div(10**14); // 0.0001 \n            temptotalStake = temptotalStake.mul(temptotalStake).mul( \n                temptotalStake \n            ); \n            lendRate = lendRewardRate.mul(tempLend).div(temptotalStake).div( \n                10**uint256(lendRewardRateDecimals) \n            ); \n            uint256 fidoFee; \n            if (lendRate >= 100) { \n                // give all to stake \n                fidoFee = newDeposit.mul(fidoFeeRate).div( \n                    10**uint256(fidoFeeRateDecimals) \n                ); \n                newDeposit = newDeposit.sub(fidoFee); \n                tomorrowReward = tomorrowReward.add(newDeposit); \n                IMFIL(mfil).mint(address(this), newDeposit); \n                IMFIL(mfil).mint(fidoFeeRecipient, fidoFee); \n                IMfilIdoTokenLPPool(pool).newReward(0); \n                emit PayDaily( \n                    pool, \n                    _msgSender(), \n                    deposit, \n                    0, \n                    fidoFee, \n                    newDeposit \n                ); \n            } else { \n                uint256 lendReward = \n                    newDeposit \n                        .mul(lendRewardRate) \n                        .mul(tempLend) \n                        .div(temptotalStake) \n                        .div(10**(uint256(lendRewardRateDecimals) + 2)); \n                fidoFee = lendReward.mul(fidoFeeRate).div( \n                    10**uint256(fidoFeeRateDecimals) \n                ); \n                newDeposit = newDeposit.sub(lendReward); \n                lendReward = lendReward.sub(fidoFee); \n                tomorrowReward = tomorrowReward.add(lendReward); \n                IMFIL(mfil).mint(pool, newDeposit); \n                IMfilIdoTokenLPPool(pool).newReward(newDeposit); \n                IMFIL(mfil).mint(address(this), lendReward); \n                IMFIL(mfil).mint(fidoFeeRecipient, fidoFee); \n                emit PayDaily( \n                    pool, \n                    _msgSender(), \n                    deposit, \n                    newDeposit, \n                    fidoFee, \n                    lendReward \n                ); \n            } \n        } \n    } \n \n    function newReward() external onlyOperator whenNotPaused { \n        _addNewReward(tomorrowReward); \n        emit NewReward(block.number, tomorrowReward); \n        tomorrowReward = 0; \n    } \n \n    function setReward(uint256 amount) external onlyOperator whenNotPaused { \n        _setReward(amount); \n        emit SetReward(block.number, amount); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./IDOToken.sol\"; \nimport \"./interfaces/IMdexPair.sol\"; \nimport \"./interfaces/IMdexFactory.sol\"; \n \n \ncontract IDOFactory is Ownable { \n    using SafeMath for uint256; \n \n    address[] public IDOlist; \n    mapping(address => bool) public isIDO; \n    mapping(address => address[]) public userIDOs; \n    address public hfil; \n    address public mfil; \n    address public operator; // for start ido \n    address public mdexFactory; \n \n    event NewIDO(address indexed sender, address indexed ido); \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    constructor( \n        address _operator, \n        address _hfil, \n        address _mfil, \n        address _mdexFactory \n    ) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        hfil = _hfil; \n        mfil = _mfil; \n        mdexFactory = _mdexFactory; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function IDOlistCount() external view returns (uint256) { \n        return IDOlist.length; \n    } \n \n    function userIDOsCount(address user) external view returns (uint256) { \n        return userIDOs[user].length; \n    } \n \n    function _addLiquidity( \n        address pair, \n        address idoToken, \n        uint256 idoAmount, \n        uint256 mfilAmount \n    ) internal { \n        IERC20(idoToken).transfer(pair, idoAmount); \n        TransferHelper.safeTransferFrom(mfil, _msgSender(), pair, mfilAmount); \n        IMdexPair(pair).mint(address(0)); \n    } \n \n \n    function newIDO( \n        string calldata _name, \n        string calldata _node, \n        address _hfilRecipient, \n        uint256 _cap, \n        uint256 _gasPrice, \n        uint256 _sealPrice, \n        uint256 _hardDrivePrice, \n        uint256 _dailySaleCap, \n        uint256 _idoStartTime, \n        uint256 _idoEndTime \n    ) external returns (address idoAddress) { \n        require( \n            _dailySaleCap >= 1e6, \n            \"IDOFactory: dailysalecap should more than 1\" \n        ); \n        IDOToken ido = new IDOToken( \n            _name, \n            _node, \n            hfil, \n            _hfilRecipient, \n            _cap, \n            _dailySaleCap \n        ); \n        ido.setPrice(_gasPrice, _sealPrice, _hardDrivePrice); \n        ido.setTimes(_idoStartTime, _idoEndTime); \n        IDOlist.push(address(ido)); \n        userIDOs[_msgSender()].push(address(ido)); \n        address pair = IMdexFactory(mdexFactory).createPair(mfil, address(ido)); \n        uint256 totalPrice = _gasPrice.add(_sealPrice).add(_hardDrivePrice).div(100); \n        _addLiquidity(pair, address(ido), 1e4, totalPrice); \n        emit NewIDO(_msgSender(), address(ido)); \n        isIDO[address(ido)] = true; \n        return address(ido); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./Pausable.sol\"; \nimport \"./ReentrancyGuard.sol\"; \nimport \"./StakeRewardPerDay.sol\"; \n \ncontract StakeTokenPool is StakeRewardPerDay, Ownable, Pausable { \n \n    using SafeMath for uint256; \n \n    uint256 public BrewardRate; // Global Reward per Unit \n    uint256 public BrewardPreBlock; \n    uint256 public BlastUpdateBlock; // last adjust block height \n \n    mapping(address => uint256) public BuserReward; \n    mapping(address => uint256) public BuserRate; \n \n    constructor() StakeRewardPerDay() { \n        BrewardRate = 0; \n        BrewardPreBlock = 0; \n        BlastUpdateBlock = block.number; \n    } \n \n    modifier BupdateRate() { \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            BrewardRate = BrewardRate.add(deltaRate); \n        } \n        BlastUpdateBlock = block.number; \n        _; \n    } \n \n    modifier BgetReward() { \n        if ( \n            userStake[_msgSender()] > 0 && BrewardRate > BuserRate[_msgSender()] \n        ) { \n            uint256 deltaReward = \n                BrewardRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            BuserReward[_msgSender()] = BuserReward[_msgSender()].add( \n                deltaReward \n            ); \n        } \n        BuserRate[_msgSender()] = BrewardRate; \n        _; \n    } \n \n    function _setReward(uint256 amount) internal BupdateRate { \n        BrewardPreBlock = amount.mul(1e18); \n    } \n \n    function _stake(uint256 amount) internal override updateRate getReward BupdateRate BgetReward { \n        userStake[_msgSender()] = userStake[_msgSender()].add(amount); \n        totalStake = totalStake.add(amount); \n    } \n \n    function _BhalveNoUpdate() internal returns (uint256 reward) { \n        reward = BuserReward[_msgSender()].div(1e18); \n        BuserReward[_msgSender()] = 0; \n    } \n \n    function _Bhalve() internal BupdateRate BgetReward returns (uint256 reward) { \n        return _BhalveNoUpdate(); \n    } \n \n    function _unStakeAll() \n        internal \n        updateRate  \n        getReward \n        BupdateRate \n        BgetReward \n        returns (uint256 stake, uint256 reward, uint256 rewardB) \n    { \n        stake = userStake[_msgSender()]; \n        totalStake = totalStake.sub(stake); \n        userStake[_msgSender()] = 0; \n        reward = _halveNoUpdate(); \n        rewardB = _BhalveNoUpdate(); \n    } \n \n    function _BcaleReward() internal view returns (uint256 reward) { \n        if (userStake[_msgSender()] == 0) { \n            return 0; \n        } \n        uint256 tempRate = BrewardRate; \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            tempRate = tempRate.add(deltaRate); \n        } \n        reward = BuserReward[_msgSender()]; \n        if (tempRate > BuserRate[_msgSender()]) { \n            uint256 deltaReward = \n                tempRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            reward = reward.add(deltaReward); \n        } \n        reward = reward.div(1e18); \n    } \n \n}// SPDX-License-Identifier: MIT \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./StakeRewardPerDay.sol\"; \nimport \"./MdexRouter.sol\"; \nimport \"./Ownable.sol\"; \nimport \"./Pausable.sol\"; \nimport \"./ReentrancyGuard.sol\"; \n \ncontract StakeLPRewardPerDay is \n    StakeRewardPerDay, \n    MdexRouter, \n    Ownable, \n    Pausable, \n    ReentrancyGuard \n{ \n    using SafeMath for uint256; \n \n    uint8 public stakeRate = 2; \n \n    address public tokenA; // for one \n    address public tokenB; // for stakeRate \n    address public rewardToken; // for reward \n    address public operator; \n \n    mapping(address => uint256) public userTokenBStake; \n    uint256 public totalTokenBStake; \n \n    event Stake( \n        address indexed sender, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ); \n    event UnStake( \n        address indexed receiver, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ); \n    event Reward(address indexed receiver, uint256 reward); \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n    event NewReward(uint256 blockHeight, uint256 amount); \n \n    constructor( \n        address _factory, \n        address _operator, \n        address _tokenA, \n        address _tokenB, \n        address _rewardToken \n    ) \n        StakeRewardPerDay() \n        MdexRouter(_factory) \n        Ownable() \n        Pausable() \n        ReentrancyGuard() \n    { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        tokenA = _tokenA; \n        tokenB = _tokenB; \n        rewardToken = _rewardToken; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function pause() external onlyOperator { \n        _pause(); \n    } \n \n    function unPause() external onlyOperator { \n        _unpause(); \n    } \n \n    function caleLiquidity( \n        uint256 amountADesired, \n        uint256 amountBDesired, \n        uint256 amountAMin, \n        uint256 amountBMin \n    ) external view returns (uint256 amountA, uint256 amountB) { \n        require( \n            IMdexFactory(factory).getPair(tokenA, tokenB) != address(0), \n            \"MdexRouter: Pair Not Found!\" \n        ); \n        (uint256 reserveA, uint256 reserveB) = \n            IMdexFactory(factory).getReserves(tokenA, tokenB); \n        if (reserveA == 0 && reserveB == 0) { \n            (amountA, amountB) = (amountADesired, amountBDesired); \n        } else { \n            uint256 amountBOptimal = \n                IMdexFactory(factory).quote(amountADesired, reserveA, reserveB); \n            if (amountBOptimal <= amountBDesired) { \n                require( \n                    amountBOptimal >= amountBMin, \n                    \"MdexRouter: INSUFFICIENT_B_AMOUNT\" \n                ); \n                (amountA, amountB) = (amountADesired, amountBOptimal); \n            } else { \n                uint256 amountAOptimal = \n                    IMdexFactory(factory).quote( \n                        amountBDesired, \n                        reserveB, \n                        reserveA \n                    ); \n                assert(amountAOptimal <= amountADesired); \n                require( \n                    amountAOptimal >= amountAMin, \n                    \"MdexRouter: INSUFFICIENT_A_AMOUNT\" \n                ); \n                (amountA, amountB) = (amountAOptimal, amountBDesired); \n            } \n        } \n    } \n \n    function stake(uint256 amountAIn, uint256 amountBIn) \n        external \n        whenNotPaused \n        nonReentrant \n        returns ( \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ) \n    { \n        require(amountAIn > 0 && amountBIn > 0, \"STAKE: amount is zero\"); \n        uint256 tempAmountB = amountBIn.div(stakeRate); \n        (amountA, amountB, liquidity) = addLiquidity( \n            tokenA, \n            tokenB, \n            amountAIn, \n            tempAmountB, \n            0, \n        ); \n        amountB = amountB.mul(stakeRate - 1); \n        TransferHelper.safeTransferFrom( \n            tokenB, \n            _msgSender(), \n            address(this), \n            amountB \n        ); \n        userTokenBStake[_msgSender()] = userTokenBStake[_msgSender()].add( \n            amountB \n        ); \n        totalTokenBStake = totalTokenBStake.add(amountB); \n        _stake(liquidity); \n        emit Stake(_msgSender(), amountA, amountB, liquidity); \n        _stakeHook(amountAIn, amountBIn, amountA, amountB, liquidity); \n    } \n \n    function _stakeHook( \n        uint256 amountAIn, \n        uint256 amountBIn, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ) internal virtual {} \n \n    function getStake() external view whenNotPaused returns (uint256 amount) { \n        amount = _getStake(); \n    } \n \n    function halve() \n        external \n        whenNotPaused \n        nonReentrant \n        returns (uint256 reward) \n    { \n        reward = _halve(); \n        IERC20(rewardToken).transfer(_msgSender(), reward); \n        emit Reward(_msgSender(), reward); \n    } \n \n    function unStake() \n        external \n        whenNotPaused \n        nonReentrant \n        returns ( \n            uint256 reward, \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ) \n    { \n        (liquidity, reward) = _unStake(); \n        require(liquidity > 0, \"UNSTAKE: no stake\"); \n        IERC20(rewardToken).transfer(_msgSender(), reward); \n        emit Reward(_msgSender(), reward); \n        (amountA, amountB) = removeLiquidity( \n            tokenA, \n            tokenB, \n            liquidity, \n            0, \n            0, \n            _msgSender() \n        ); \n        IERC20(tokenB).transfer(_msgSender(), userTokenBStake[_msgSender()]); \n        amountB.add(userTokenBStake[_msgSender()]); \n        userTokenBStake[_msgSender()] = 0; \n        emit UnStake(_msgSender(), amountA, amountB, liquidity); \n        _unStakeHook(reward, amountA, amountB, liquidity); \n    } \n \n    function _unStakeHook( \n        uint256 reward, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ) internal virtual {} \n \n    function newReward(uint256 amount) \n        external \n        virtual \n        onlyOperator \n        whenNotPaused \n    { \n        _addNewReward(amount); \n        emit NewReward(block.number, amount); \n    } \n \n    function caleReward() external view whenNotPaused returns (uint256 reward) { \n        reward = _caleReward(); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./ERC20/ERC20.sol\"; \nimport \"./ERC20/ERC20Burnable.sol\"; \nimport \"./ERC20/ERC20Mintable.sol\"; \nimport \"./libraries/TransferHelper.sol\"; \n \ninterface IIDOFactory { \n    function operator() external view returns (address); \n} \n \ncontract IDOToken is ERC20Burnable { \n    using SafeMath for uint256; \n \n    uint256 private _cap; \n    uint256 public dailySaleCap; \n    uint256 public price; \n    uint256 public gasPrice; \n    uint256 public sealPrice; \n    uint256 public hardDrivePrice; \n    uint256 public idoStartTime; \n    uint256 public idoEndTime; \n    uint256 private _todayRemaind; \n    uint256 public todayStartTime; \n    address public hfil; \n    address public hfilRecipient; \n    address public router; \n    address public factory; \n    address public sender; \n \n    string public node; \n \n    bool public idoStatus; \n \n    event IDOStart(uint256 timestamp); \n    event IDOStop(uint256 timestamp, address sender); \n    event IDO(address indexed to, uint256 cost, uint256 amount); \n \n    constructor( \n        string memory _name, \n        string memory _node, \n        address _hfil, \n        address _hfilRecipient, \n        uint256 cap_, \n        uint256 _dailySaleCap \n    ) ERC20(_name, \"T\") Pausable() { \n        _setupDecimals(6); \n        sender = tx.origin; \n        factory = _msgSender(); \n        node = _node; \n        hfil = _hfil; \n        hfilRecipient = _hfilRecipient; \n        _cap = cap_; \n        dailySaleCap = _dailySaleCap; \n        idoStatus = false; \n        _mint(_msgSender(), 1 * 10**4); \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == IIDOFactory(factory).operator(), \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    modifier onlyFactory() { \n        require(_msgSender() == factory, \"IDOToken: only factory can call\"); \n        _; \n    } \n \n    modifier onlySender() { \n        require(_msgSender() == sender, \"IDOToken: only sender can call\"); \n        _; \n    } \n \n    modifier idoEnabled() { \n        require(idoStatus, \"IDOToken: ido not start yet\"); \n        _; \n    } \n \n    modifier idoStarted() { \n        require(block.timestamp >= idoStartTime, \"IDOToken: ido not start yet\"); \n        _; \n    } \n \n    modifier idoNotEnded() { \n        require(block.timestamp <= idoEndTime, \"IDOToken: ido ended\"); \n        _; \n    } \n \n    modifier updateToday() { \n        if (block.timestamp >= todayStartTime + 86400) { \n            todayStartTime = block.timestamp; \n            _todayRemaind = dailySaleCap; \n        } \n        _; \n    } \n \n    function operator() view external returns (address) { \n        return IIDOFactory(factory).operator(); \n    } \n \n    function setPrice( \n        uint256 gasPrice_, \n        uint256 sealPrice_, \n        uint256 hardDrivePrice_ \n    ) external onlyFactory { \n        gasPrice = gasPrice_; \n        sealPrice = sealPrice_; \n        hardDrivePrice = hardDrivePrice_; \n        price = gasPrice.add(sealPrice).add(hardDrivePrice); \n    } \n \n    function setTimes(uint256 idoStartTime_, uint256 idoEndTime_) \n        external \n        onlyFactory \n    { \n        idoStartTime = idoStartTime_; \n        idoEndTime = idoEndTime_; \n    } \n \n    function changerouter(address _router) external onlyOperator { \n        require(_router != address(0), \"IDO: wrong address\"); \n        router = _router; \n    } \n \n    function stopIdo() external onlyOperator { \n        idoStatus = false; \n        idoEndTime = block.timestamp; \n        emit IDOStop(block.timestamp, _msgSender()); \n    } \n \n    function stopIdoBySender() external onlySender { \n        idoStatus = false; \n        idoEndTime = block.timestamp; \n        emit IDOStop(block.timestamp, _msgSender()); \n    } \n \n    function todayRemaind() view external returns (uint256) { \n        if (block.timestamp >= todayStartTime + 86400) { \n            return dailySaleCap; \n        } \n        return _todayRemaind; \n    } \n \n    function pause() external onlyOperator { \n        _pause(); \n    } \n \n    function unPause() external onlyOperator { \n        _unpause(); \n    } \n \n    /** \n     * @dev Returns the cap on the token's total supply. \n     */ \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_beforeTokenTransfer}. \n     * \n     * Requirements: \n     * \n     * - minted tokens must not cause the total supply to go over the cap. \n     */ \n    function _beforeTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual override { \n        super._beforeTokenTransfer(from, to, amount); \n \n        if (from == address(0)) { \n            // When minting tokens \n            require(totalSupply().add(amount) <= cap(), \"ERC20: cap exceeded\"); \n        } \n    } \n \n    function startIdo(address _router) external onlyOperator { \n        require(!idoStatus, \"IDO: ido already started!\"); \n        require(_router != address(0), \"IDO: wrong address\"); \n        router = _router; \n        idoStatus = true; \n        emit IDOStart(block.timestamp); \n        todayStartTime = block.timestamp; \n        _todayRemaind = dailySaleCap; \n    } \n \n    function ido(address recipient) \n        external \n        idoEnabled \n        idoStarted \n        idoNotEnded \n        updateToday \n        returns (uint256 amount) \n    { \n        require(_todayRemaind > 0, \"IDO: sold out today\"); \n        require(_msgSender() == router, \"IDO: not from fido\"); \n        uint256 totalPrice = IERC20(hfil).balanceOf(address(this)); \n        uint256 sendBack = 0; \n        require(totalPrice > 0, \"IDO: no pay no gain\"); \n        amount = totalPrice.mul(10 ** decimals()).div(price); \n        require(amount > 0, \"IDO: amount must greater than zero\"); \n        if (amount >= _todayRemaind) { \n            amount = _todayRemaind; \n            sendBack = totalPrice.sub(amount.mul(price).div(10**decimals())); \n        } \n        _todayRemaind = _todayRemaind.sub(amount); \n        if (sendBack > 0) { \n            TransferHelper.safeTransfer(hfil, recipient, sendBack); \n            totalPrice = totalPrice.sub(sendBack); \n        } \n        TransferHelper.safeTransfer(hfil, hfilRecipient, totalPrice); \n        _mint(recipient, amount); \n        emit IDO(recipient, totalPrice, amount); \n    } \n} \n \n",
            "pragma solidity ^0.7.6; \n \nimport \"./libraries/SafeMath.sol\"; \nimport \"./Context.sol\"; \n \ncontract StakeRewardPerBlock is Context { \n    using SafeMath for uint256; \n \n    uint256 public BrewardRate; // Global Reward per Unit \n    uint256 public BrewardPreBlock; \n    uint256 public BlastUpdateBlock; // last adjust block height \n    uint256 public totalStake; \n \n    mapping(address => uint256) public userStake; \n    mapping(address => uint256) public BuserReward; \n    mapping(address => uint256) public BuserRate; \n \n    constructor() { \n        BrewardRate = 0; \n        BrewardPreBlock = 0; \n        totalStake = 0; \n        BlastUpdateBlock = block.number; \n    } \n \n    modifier BupdateRate() { \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            BrewardRate = BrewardRate.add(deltaRate); \n        } \n        BlastUpdateBlock = block.number; \n        _; \n    } \n \n    modifier BgetReward() { \n        if ( \n            userStake[_msgSender()] > 0 && BrewardRate > BuserRate[_msgSender()] \n        ) { \n            uint256 deltaReward = \n                BrewardRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            BuserReward[_msgSender()] = BuserReward[_msgSender()].add( \n                deltaReward \n            ); \n        } \n        BuserRate[_msgSender()] = BrewardRate; \n        _; \n    } \n \n    function _setReward(uint256 amount) internal BupdateRate { \n        BrewardPreBlock = amount.mul(1e18); \n    } \n \n    function _stake(uint256 amount) internal BupdateRate BgetReward { \n        userStake[_msgSender()] = userStake[_msgSender()].add(amount); \n        totalStake = totalStake.add(amount); \n    } \n \n    function _BhalveNoUpdate() internal returns (uint256 reward) { \n        reward = BuserReward[_msgSender()].div(1e18); \n        BuserReward[_msgSender()] = 0; \n    } \n \n    function _Bhalve() internal BupdateRate BgetReward returns (uint256 reward) { \n        return _BhalveNoUpdate(); \n    } \n \n    function _unStake() \n        internal \n        BupdateRate \n        BgetReward \n        returns (uint256 stake, uint256 reward) \n    { \n        stake = userStake[_msgSender()]; \n        totalStake = totalStake.sub(stake); \n        userStake[_msgSender()] = 0; \n        reward = _BhalveNoUpdate(); \n    } \n \n    function _getStake() internal view returns (uint256 stake) { \n        stake = userStake[_msgSender()]; \n    } \n \n    function _BcaleReward() internal view returns (uint256 reward) { \n        if (userStake[_msgSender()] == 0) { \n            return 0; \n        } \n        uint256 tempRate = BrewardRate; \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            tempRate = tempRate.add(deltaRate); \n        } \n        reward = BuserReward[_msgSender()]; \n        if (tempRate > BuserRate[_msgSender()]) { \n            uint256 deltaReward = \n                tempRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            reward = reward.add(deltaReward); \n        } \n        reward = reward.div(1e18); \n    } \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"../Context.sol\"; \nimport \"../interfaces/IERC20.sol\"; \nimport \"../libraries/SafeMath.sol\"; \n \n/** \n * @dev Implementation of the {IERC20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of ERC20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IERC20-approve}. \n */ \ncontract ERC20 is Context, IERC20 { \n    using SafeMath for uint256; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n     * a default value of 18. \n     * \n     * To select a different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    constructor (string memory name_, string memory symbol_) { \n        _name = name_; \n        _symbol = symbol_; \n        _decimals = 18; \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public view virtual returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public view virtual returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a balance of `505` tokens should \n     * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a value of 18, imitating the relationship between \n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is \n     * called. \n     * \n     * NOTE: This information is only used for _display_ purposes: it in \n     * no way affects any of the arithmetic of the contract, including \n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */ \n    function decimals() public view virtual returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */ \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */ \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function allowance(address owner, address spender) public view virtual override returns (uint256)\n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {ERC20}. \n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the total supply. \n     * \n     * Emits a {Transfer} event with `from` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `to` cannot be the zero address. \n     */ \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens. \n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Sets {decimals} to a value other than the default one of 18. \n     * \n     * WARNING: This function should only be called from the constructor. Most \n     * applications that interact with token contracts will not expect \n     * {decimals} to ever change, and may work incorrectly if it does. \n     */ \n    function _setupDecimals(uint8 decimals_) internal virtual { \n        _decimals = decimals_; \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * will be to transferred to `to`. \n     * - when `from` is zero, `amount` tokens will be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n     * - `from` and `to` are never both zero. \n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"../Context.sol\"; \nimport \"./ERC20Pausable.sol\"; \n \n/** \n * @dev Extension of {ERC20} that allows token holders to destroy both their own \n * tokens and those that they have an allowance for, in a way that can be \n * recognized off-chain (via event analysis). \n */ \nabstract contract ERC20Burnable is Context, ERC20Pausable { \n    using SafeMath for uint256; \n \n    /** \n     * @dev Destroys `amount` tokens from the caller. \n     * \n     * See {ERC20-_burn}. \n     */ \n    function burn(uint256 amount) public virtual { \n        _burn(_msgSender(), amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's \n     * allowance. \n     * \n     * See {ERC20-_burn} and {ERC20-allowance}. \n     * \n     * Requirements: \n     * \n     * - the caller must have allowance for ``accounts``'s tokens of at least \n     * `amount`. \n     */ \n    function burnFrom(address account, uint256 amount) public virtual { \n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount \n \n        _approve(account, _msgSender(), decreasedAllowance); \n        _burn(account, amount); \n    } \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"../Context.sol\"; \nimport \"./ERC20Pausable.sol\"; \n \nabstract contract ERC20Mintable is Context, ERC20Pausable { \n    using SafeMath for uint256; \n \n    mapping(address => bool) public isMinter; \n \n    event AddMinter(address indexed minter); \n    event RemoveMinter(address indexed minter); \n    event Mint( \n        address indexed minter, \n        address indexed recipient, \n        uint256 amount \n    ); \n \n    modifier onlyMinter() { \n        require(isMinter[_msgSender()], \"ERC20: sender is not minter\"); \n        _; \n    } \n \n    function _addMinter(address minter) internal { \n        require(!isMinter[minter], \"ERC20: already a minter\"); \n        isMinter[minter] = true; \n        emit AddMinter(minter); \n    } \n \n    function _removeMinter(address minter) internal { \n        require(isMinter[minter], \"ERC20: not a minter\"); \n        isMinter[minter] = false; \n        emit RemoveMinter(minter); \n    } \n \n    function mint(address recipient, uint256 amount) external onlyMinter { \n        _mint(recipient, amount); \n        emit Mint(_msgSender(), recipient, amount); \n    } \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./ERC20.sol\"; \nimport \"../Pausable.sol\"; \n \n/** \n * @dev ERC20 token with pausable token transfers, minting and burning. \n * \n * Useful for scenarios such as preventing trades until the end of an evaluation \n * period, or having an emergency switch for freezing all token transfers in the \n * event of a large bug. \n */ \nabstract contract ERC20Pausable is ERC20, Pausable { \n    /** \n     * @dev See {ERC20-_beforeTokenTransfer}. \n     * \n     * Requirements: \n     * \n     * - the contract must not be paused. \n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override\n        super._beforeTokenTransfer(from, to, amount); \n \n        require(!paused(), \"ERC20Pausable: token transfer while paused\"); \n    } \n} \n",
            "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \n \ncontract IDOInfo is Ownable { \n    address public operator; \n \n    mapping(address => bool) public exist; \n    mapping(address => bool) public isPool; \n    address[] public IDOList; \n    mapping(address => address) public payer2pool; \n    mapping(address => address) public stakeAddress; \n    mapping(address => address) public pool2idoToken; \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    event AddIDO(uint256 timestamp, address idoToken); \n \n    event SetPayer(uint256 timestamp, address pool, address payer); \n \n    event SetStakeAddress( \n        uint256 timestamp, \n        address idoToken, \n        address _stakeAddress \n    ); \n \n    constructor(address _operator) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function IDOListCount() external view returns (uint256) { \n        return IDOList.length; \n    } \n \n    function addIDO(address idoToken) external onlyOperator { \n        require(!exist[idoToken], \"IDOINFO: already here\"); \n        exist[idoToken] = true; \n        IDOList.push(idoToken); \n        emit AddIDO(block.timestamp, idoToken); \n    } \n \n    function setPayer(address pool, address payer) external onlyOperator { \n        require(isPool[pool], \"IDOINFO: pool not found\"); \n        payer2pool[payer] = pool; \n        emit SetPayer(block.timestamp, pool, payer); \n    } \n \n    function setStakeAddress(address idoToken, address _stakeAddress) \n        external \n        onlyOperator \n    { \n        require(exist[idoToken], \"IDOINFO: idoToken not found\"); \n        isPool[_stakeAddress] = true; \n        pool2idoToken[_stakeAddress] = idoToken; \n        stakeAddress[idoToken] = _stakeAddress; \n        emit SetStakeAddress(block.timestamp, idoToken, _stakeAddress); \n    } \n} \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nabstract contract ReentrancyGuard { \n \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    constructor () { \n        _status = _NOT_ENTERED; \n    } \n \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n} \n \nAnalysis of audit results\nRe-Entrancy\n"
        ]
    },
    {
        "PdfName": "Garfield Finance Swap_audit.pdf",
        "Code": [
            "pragma solidity ^0.6.0; \n \ninterface ISwapFactory { \n    event PairCreated( \n        address indexed token0, \n        address indexed token1, \n        address pair, \n        uint256 \n    ); \n \n    function feeTo() external view returns (address); \n \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) \n        external \n        view \n        returns (address pair); \n \n    function allPairs(uint256) external view returns (address pair); \n \n    function allPairsLength() external view returns (uint256); \n \n    function createPair(address tokenA, address tokenB) \n        external \n        returns (address pair); \n \n    function setFeeTo(address) external; \n \n    function setFeeToSetter(address) external; \n \n    function pairCodeHash() external pure returns (bytes32); \n} \n \ninterface ISwapPair { \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 value \n    ); \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    function name() external pure returns (string memory); \n \n    function symbol() external pure returns (string memory); \n \n    function decimals() external pure returns (uint8); \n \n    function totalSupply() external view returns (uint256); \n \n    function balanceOf(address owner) external view returns (uint256); \n \n    function allowance(address owner, address spender) \n        external \n        view \n        returns (uint256); \n \n    function approve(address spender, uint256 value) external returns (bool); \n \n    function transfer(address to, uint256 value) external returns (bool); \n \n    function transferFrom( \n        address from, \n        address to, \n        uint256 value \n    ) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n \n    function nonces(address owner) external view returns (uint256); \n \n    function permit( \n        address owner, \n        address spender, \n        uint256 value, \n        uint256 deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external; \n \n    event Mint(address indexed sender, uint256 amount0, uint256 amount1); \n    event Burn( \n        address indexed sender, \n        uint256 amount0, \n        uint256 amount1, \n        address indexed to \n    ); \n    event Swap( \n        address indexed sender, \n        uint256 amount0In, \n        uint256 amount1In, \n        uint256 amount0Out, \n        uint256 amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint256); \n \n    function factory() external view returns (address); \n \n    function token0() external view returns (address); \n \n    function token1() external view returns (address); \n \n    function getReserves() \n        external \n        view \n        returns ( \n            uint112 reserve0, \n            uint112 reserve1, \n            uint32 blockTimestampLast \n        ); \n \n    function price0CumulativeLast() external view returns (uint256); \n \n    function price1CumulativeLast() external view returns (uint256); \n \n    function kLast() external view returns (uint256); \n \n    function mint(address to) external returns (uint256 liquidity); \n \n    function burn(address to) \n        external \n        returns (uint256 amount0, uint256 amount1); \n \n    function swap( \n        uint256 amount0Out, \n        uint256 amount1Out, \n        address to, \n        bytes calldata data \n    ) external; \n \n    function skim(address to) external; \n \n    function sync() external; \n \n    function fee() external view returns (uint8); \n \n    function feeTo() external view returns (address); \n \n    function getFeeTo() external view returns (address); \n \n    function creator() external view returns (address); \n \n    function birthday() external view returns (uint256); \n \n    function rootKmul() external view returns (uint8); \n \n    function initialize(address, address) external; \n \n    function setFeeTo(address) external; \n \n    function setrootKmul(uint8) external; \n \n    function setFee(uint8) external; \n} \n \ninterface IERC20 { \n    function totalSupply() external view returns (uint256); \n \n    function balanceOf(address account) external view returns (uint256); \n \n    function transfer(address recipient, uint256 amount) \n        external \n        returns (bool); \n \n    function allowance(address owner, address spender) \n        external \n        view \n        returns (uint256); \n \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 value \n    ); \n \n    function name() external pure returns (string memory); \n \n    function symbol() external pure returns (string memory); \n \n    function decimals() external pure returns (uint8); \n} \n \nlibrary SafeMath { \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    function sub( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) { \n            return 0; \n        } \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    function div( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        return c; \n    } \n \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    function mod( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n} \n \ninterface ISwapCallee { \n    function swapCall( \n        address sender, \n        uint256 amount0, \n        uint256 amount1, \n        bytes calldata data \n    ) external; \n} \n \ninterface IERC20Swap { \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 value \n    ); \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    function name() external pure returns (string memory); \n \n    function symbol() external pure returns (string memory); \n \n    function decimals() external pure returns (uint8); \n \n    function totalSupply() external view returns (uint256); \n \n    function balanceOf(address owner) external view returns (uint256); \n \n    function allowance(address owner, address spender) \n        external \n        view \n        returns (uint256); \n \n    function approve(address spender, uint256 value) external returns (bool); \n \n    function transfer(address to, uint256 value) external returns (bool); \n \n    function transferFrom( \n        address from, \n        address to, \n        uint256 value \n    ) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n \n    function nonces(address owner) external view returns (uint256); \n \n    function permit( \n        address owner, \n        address spender, \n        uint256 value, \n        uint256 deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external; \n} \n \ncontract SwapERC20 is IERC20Swap { \n    using SafeMath for uint256; \n \n    /// @notice token\u540d\u79f0 \n    string public constant override name = \"Garfield Swap LP Token\"; \n    /// @notice token\u7f29\u5199 \n    string public override symbol = \"GLP\"; \n    /// @notice \u7cbe\u5ea6 \n    uint8 public constant override decimals = 18; \n    /// @notice \u603b\u91cf \n    uint256 public override totalSupply; \n    /// @notice \u4f59\u989d\u6620\u5c04 \n    mapping(address => uint256) public override balanceOf; \n    /// @notice \u6279\u51c6\u6620\u5c04 \n    mapping(address => mapping(address => uint256)) public override allowance; \n \n    /// @notice \u57df\u5206\u5272 \n    bytes32 public override DOMAIN_SEPARATOR; \n    /// @notice The EIP-712 typehash for the contract's domain \n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    bytes32 public constant override PERMIT_TYPEHASH = \n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; \n \n    /// @notice nonces\u6620\u5c04 \n    mapping(address => uint256) public override nonces; \n \n    /// @notice \u6279\u51c6\u4e8b\u4ef6 \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 value \n    ); \n    /// @notice \u53d1\u9001\u4e8b\u4ef6 \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev \u6784\u9020\u51fd\u6570 \n     */ \n    constructor() public { \n        // \u94feID \n        uint256 chainId; \n        // \u83b7\u53d6\u94feID \n        // solium-disable-next-line \n        assembly { \n            chainId := chainid() \n        } \n        //EIP712Domain \n        DOMAIN_SEPARATOR = keccak256( \n            abi.encode( \n                keccak256( \n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContrac\n                ), \n                keccak256(bytes(name)), \n                keccak256(bytes(\"1\")), \n                chainId, \n                address(this) \n            ) \n        ); \n    } \n \n    function _mint(address to, uint256 value) internal { \n        totalSupply = totalSupply.add(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(address(0), to, value); \n    } \n \n    function _burn(address from, uint256 value) internal { \n        balanceOf[from] = balanceOf[from].sub(value); \n        totalSupply = totalSupply.sub(value); \n        emit Transfer(from, address(0), value); \n    } \n \n    function _approve( \n        address owner, \n        address spender, \n        uint256 value \n    ) private { \n        allowance[owner][spender] = value; \n        emit Approval(owner, spender, value); \n    } \n \n    function _transfer( \n        address from, \n        address to, \n        uint256 value \n    ) private { \n        balanceOf[from] = balanceOf[from].sub(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(from, to, value); \n    } \n \n    function approve(address spender, uint256 value) \n        external \n        override \n        returns (bool) \n    { \n        _approve(msg.sender, spender, value); \n        return true; \n    } \n \n    function transfer(address to, uint256 value) \n        external \n        override \n        returns (bool) \n    { \n        _transfer(msg.sender, to, value); \n        return true; \n    } \n \n    function transferFrom( \n        address from, \n        address to, \n        uint256 value \n    ) external override returns (bool) { \n        if (allowance[from][msg.sender] != uint256(-1)) { \n            allowance[from][msg.sender] = allowance[from][msg.sender].sub( \n                value \n            ); \n        } \n        _transfer(from, to, value); \n        return true; \n    } \n \n    function permit( \n        address owner, \n        address spender, \n        uint256 value, \n        uint256 deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external override { \n        require(deadline >= block.timestamp, \"Swap: EXPIRED\"); \n        bytes32 digest = \n            keccak256( \n                abi.encodePacked( \n                    \"\\x19\\x01\", \n                    DOMAIN_SEPARATOR, \n                    keccak256( \n                        abi.encode( \n                            PERMIT_TYPEHASH, \n                            owner, \n                            spender, \n                            value, \n                            nonces[owner]++, \n                            deadline \n                        ) \n                    ) \n                ) \n            ); \n        address recoveredAddress = ecrecover(digest, v, r, s); \n        require( \n            recoveredAddress != address(0) && recoveredAddress == owner, \n            \"Swap: INVALID_SIGNATURE\" \n        ); \n        _approve(owner, spender, value); \n    } \n} \n \nlibrary Math { \n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) { \n        z = x < y ? x : y; \n    } \n \n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_\n    function sqrt(uint256 y) internal pure returns (uint256 z) { \n        if (y > 3) { \n            z = y; \n            uint256 x = y / 2 + 1; \n            while (x < z) { \n                z = x; \n                x = (y / x + x) / 2; \n            } \n        } else if (y != 0) { \n            z = 1; \n        } \n    } \n} \n \nlibrary UQ112x112 { \n    uint224 constant Q112 = 2**112; \n \n    // encode a uint112 as a UQ112x112 \n    function encode(uint112 y) internal pure returns (uint224 z) { \n        z = uint224(y) * Q112; // never overflows \n    } \n \n    // divide a UQ112x112 by a uint112, returning a UQ112x112 \n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n        z = x / uint224(y); \n    } \n} \n \n/** \n * @title \u4ea4\u6613\u94a9\u5b50\u5408\u7ea6\u63a5\u53e3 \n */ \ninterface ISwapHook { \n    function swapHook( \n        address sender, \n        uint256 amount0Out, \n        uint256 amount1Out, \n        address to \n    ) external; \n} \n \n/** \n * @title Swap \u914d\u5bf9\u5408\u7ea6 \n */ \ncontract SwapPair is SwapERC20 { \n    using SafeMath for uint256; \n    using UQ112x112 for uint224; \n \n    /// @notice \u6700\u5c0f\u6d41\u52a8\u6027 = 1000 \n    uint256 public constant MINIMUM_LIQUIDITY = 10**3; \n    /// @dev transfer\u7684selector\u7f16\u7801 \n    bytes4 private constant SELECTOR = \n        bytes4(keccak256(bytes(\"transfer(address,uint256)\"))); \n \n    /// @notice \u5de5\u5382\u5408\u7ea6\u5730\u5740 \n    address public factory; \n    /// @dev token\u5730\u5740\u6570\u7ec4 \n    address public token0; \n    address public token1; \n \n    /// @notice \u6536\u7a0e\u5730\u5740 \n    address public feeTo; // feeTo \n    /// @notice \u914d\u5bf9\u521b\u5efa\u8005 \n    address public creator; // creator \n    /// @notice \u4ea4\u6613\u94a9\u5b50\u5408\u7ea6\u5730\u5740 \n    address public swapHookAddress; \n \n    /// @dev token\u50a8\u5907\u91cf \n    uint112 private reserve0; // uses single storage slot, accessible via getReserves \n    uint112 private reserve1; // uses single storage slot, accessible via getReserves \n    /// @dev \u66f4\u65b0\u50a8\u5907\u91cf\u7684\u6700\u540e\u65f6\u95f4\u6233 \n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves \n \n    /// @notice \u914d\u5bf9\u5408\u7ea6\u521b\u5efa\u65f6\u95f4 \n    uint256 public birthday; \n    /// @dev token\u4ef7\u683c\u6700\u540e\u7d2f\u8ba1 \n    uint256 public price0CumulativeLast; \n    uint256 public price1CumulativeLast; \n    /// @notice \u5728\u6700\u8fd1\u4e00\u6b21\u6d41\u52a8\u6027\u4e8b\u4ef6\u4e4b\u540e\u7684K\u503c,\u50a8\u5907\u91cf0*\u50a8\u5907\u91cf1\uff0c\u81ea\u6700\u8fd1\u4e00\u6b21\u6d41\u52a8\u6027\u4e8b\u4ef6\u53d1\u751f\u540e \n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity e\n    /// @notice \u6d41\u52a8\u6027\u76f8\u5f53\u4e8esqrt\uff08k\uff09\u589e\u957f\u76841/6 \n    uint8 public rootKmul = 5; // mint liquidity equivalent to 1/6th of the growth in sqrt(k) \n    /// @notice \u624b\u7eed\u8d39\u5360\u6bd40.3% \n    uint8 public fee = 3; // 0.3% \n \n    /// @dev \u9632\u6b62\u91cd\u5165\u5f00\u5173 \n    uint256 private unlocked = 1; \n \n    /** \n     * @dev \u4e8b\u4ef6:\u94f8\u9020 \n     * @param sender \u53d1\u9001\u8005 \n     * @param amount0 \u8f93\u5165\u91d1\u989d0 \n     * @param amount1 \u8f93\u5165\u91d1\u989d1 \n     */ \n    event Mint(address indexed sender, uint256 amount0, uint256 amount1); \n    /** \n     * @dev \u4e8b\u4ef6:\u9500\u6bc1 \n     * @param sender \u53d1\u9001\u8005 \n     * @param amount0 \u8f93\u5165\u91d1\u989d0 \n     * @param amount1 \u8f93\u5165\u91d1\u989d1 \n     * @param to to\u5730\u5740 \n     */ \n    event Burn( \n        address indexed sender, \n        uint256 amount0, \n        uint256 amount1, \n        address indexed to \n    ); \n    /** \n     * @dev \u4e8b\u4ef6:\u4ea4\u6362 \n     * @param sender \u53d1\u9001\u8005 \n     * @param amount0In \u8f93\u5165\u91d1\u989d0 \n     * @param amount1In \u8f93\u5165\u91d1\u989d1 \n     * @param amount0Out \u8f93\u51fa\u91d1\u989d0 \n     * @param amount1Out \u8f93\u51fa\u91d1\u989d1 \n     * @param to to\u5730\u5740 \n     */ \n    event Swap( \n        address indexed sender, \n        uint256 amount0In, \n        uint256 amount1In, \n        uint256 amount0Out, \n        uint256 amount1Out, \n        address indexed to \n    ); \n    /** \n     * @dev \u4e8b\u4ef6:\u540c\u6b65 \n     * @param reserve0 \u50a8\u5907\u91cf0 \n     * @param reserve1 \u50a8\u5907\u91cf1 \n     */ \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    /** \n     * @dev \u4e8b\u4ef6:\u6536\u7a0e\u5730\u5740\u66f4\u65b0 \n     * @param feeTo \u6536\u7a0e\u5730\u5740 \n     */ \n    event FeeToUpdated(address indexed feeTo); \n \n    /** \n     * @dev \u4e8b\u4ef6:K\u503c\u4e58\u6570\u66f4\u65b0 \n     * @param rootKmul K\u503c\u4e58\u6570 \n     */ \n    event RootKmulUpdated(uint8 rootKmul); \n \n    /** \n     * @dev \u4e8b\u4ef6:\u4ea4\u6613\u94a9\u5b50\u5408\u7ea6\u5730\u5740\u66f4\u65b0 \n     * @param swapHookAddress \u4ea4\u6613\u94a9\u5b50\u5408\u7ea6\u5730\u5740 \n     */ \n    event SwapHookUpdated(address swapHookAddress); \n \n    /** \n     * @dev \u4e8b\u4ef6:\u6536\u7a0e\u6bd4\u4f8b\u66f4\u65b0 \n     * @param fee \u6536\u7a0e\u6bd4\u4f8b \n     */ \n    event FeeUpdated(uint8 fee); \n \n    /** \n     * @dev \u4fee\u9970\u7b26:\u9501\u5b9a\u8fd0\u884c\u9632\u6b62\u91cd\u5165 \n     */ \n    modifier lock() { \n        require(unlocked == 1, \"Swap: LOCKED\"); \n        unlocked = 0; \n        _; \n        unlocked = 1; \n    } \n \n    /** \n     * @dev \u4fee\u9970\u7b26:\u786e\u8ba4\u5fc5\u987b\u4e3a\u5de5\u5382\u5408\u7ea6\u7684FeeToSetter\u5730\u5740 \n     */ \n    modifier onlyFeeToSetter() { \n        // \u786e\u8ba4\u5fc5\u987b\u4e3a\u5de5\u5382\u5408\u7ea6\u7684FeeToSetter\u5730\u5740 \n        require( \n            msg.sender == ISwapFactory(factory).feeToSetter(), \n            \"Swap: FORBIDDEN\" \n        ); \n        _; \n    } \n \n    /** \n     * @dev \u83b7\u53d6\u50a8\u5907 \n     * @return _reserve0 \u50a8\u5907\u91cf0 \n     * @return _reserve1 \u50a8\u5907\u91cf1 \n     * @return _blockTimestampLast \u65f6\u95f4\u6233 \n     */ \n    function getReserves() \n        public \n        view \n        returns ( \n            uint112 _reserve0, \n            uint112 _reserve1, \n            uint32 _blockTimestampLast \n        ) \n    { \n        _reserve0 = reserve0; \n        _reserve1 = reserve1; \n        _blockTimestampLast = blockTimestampLast; \n    } \n \n    /** \n     * @dev \u79c1\u6709\u5b89\u5168\u53d1\u9001 \n     * @param token token \n     * @param to    to\u5730\u5740 \n     * @param value \u6570\u989d \n     */ \n    function _safeTransfer( \n        address token, \n        address to, \n        uint256 value \n    ) private { \n        (bool success, bytes memory data) = \n            token.call(abi.encodeWithSelector(SELECTOR, to, value)); \n        require( \n            success && (data.length == 0 || abi.decode(data, (bool))), \n            \"UniswapV2: TRANSFER_FAILED\" \n        ); \n    } \n \n    /** \n     * @dev \u6784\u9020\u51fd\u6570 \n     */ \n    constructor() public { \n        //factory\u5730\u5740\u4e3a\u5408\u7ea6\u5e03\u7f72\u8005 \n        factory = msg.sender; \n        birthday = block.timestamp; \n    } \n \n    /** \n     * @dev \u521d\u59cb\u5316\u65b9\u6cd5,\u90e8\u7f72\u65f6\u7531\u5de5\u5382\u8c03\u7528\u4e00\u6b21 \n     * @param _token0 token0 \n     * @param _token1 token1 \n     */ \n    function initialize(address _token0, address _token1) external { \n        require(msg.sender == factory, \"Swap: FORBIDDEN\"); // sufficient check \n        token0 = _token0; \n        token1 = _token1; \n        symbol = string( \n            abi.encodePacked( \n                \"GLP:\", \n                IERC20Swap(_token0).symbol(), \n                \"-\", \n                IERC20Swap(_token1).symbol() \n            ) \n        ); \n    } \n \n    /** \n     * @dev \u8bbe\u7f6e\u6536\u7a0e\u5730\u5740 \n     * @param _feeTo \u6536\u7a0e\u5730\u5740 \n     */ \n    function setFeeTo(address _feeTo) external onlyFeeToSetter { \n        feeTo = _feeTo; \n        emit FeeToUpdated(_feeTo); \n    } \n \n    /** \n     * @dev \u8bbe\u7f6eK\u503c\u4e58\u6570 \n     * @param _rootKmul K\u503c\u4e58\u6570 \n     */ \n    function setRootKmul(uint8 _rootKmul) external onlyFeeToSetter { \n        rootKmul = _rootKmul; \n        emit RootKmulUpdated(_rootKmul); \n    } \n \n    /** \n     * @dev \u8bbe\u7f6e\u6536\u7a0e\u6bd4\u4f8b \n     * @param _fee \u6536\u7a0e\u6bd4\u4f8b \n     */ \n    function setFee(uint8 _fee) external onlyFeeToSetter { \n        fee = _fee; \n        emit FeeUpdated(fee); \n    } \n \n    /** \n     * @dev \u8bbe\u7f6e\u4ea4\u6613\u94a9\u5b50\u5408\u7ea6\u5730\u5740 \n     * @param _swapHookAddress \u4ea4\u6613\u94a9\u5b50\u5408\u7ea6\u5730\u5740 \n     */ \n    function setSwapHook(address _swapHookAddress) external onlyFeeToSetter { \n        swapHookAddress = _swapHookAddress; \n        emit SwapHookUpdated(swapHookAddress); \n    } \n \n    /** \n     * @dev \u83b7\u53d6\u6536\u7a0e\u5730\u5740 \n     * @return \u6536\u7a0e\u5730\u5740 \n     */ \n    function getFeeTo() public view returns (address) { \n        // \u5982\u679cfeeTo\u5730\u5740\u4e0d\u4e3a0\u5730\u5740,\u4ee5feeTo\u5730\u5740\u4e3a\u51c6 \n        if (feeTo != address(0)) { \n            return feeTo; \n            // \u5426\u5219\u5982\u679c\u914d\u5bf9\u5408\u7ea6\u521b\u5efa30\u5929\u4e4b\u540e,\u4ee5\u5de5\u7a0b\u5408\u7ea6\u7684feeTo\u5730\u5740\u4e3a\u51c6 \n        } else if (block.timestamp.sub(birthday) > 30 days) { \n            return ISwapFactory(factory).feeTo(); \n            // \u5426\u8005feeTo\u5730\u5740\u4e3a\u914d\u5bf9\u5408\u7ea6\u521b\u5efa\u8005 \n        } else { \n            return creator; \n        } \n    } \n \n    /** \n     * @dev \u66f4\u65b0\u50a8\u91cf\uff0c\u5e76\u5728\u6bcf\u4e2a\u533a\u5757\u7684\u7b2c\u4e00\u6b21\u8c03\u7528\u65f6\u66f4\u65b0\u4ef7\u683c\u7d2f\u52a0\u5668 \n     * @param balance0 \u4f59\u989d0 \n     * @param balance1  \u4f59\u989d1 \n     * @param _reserve0 \u50a8\u59070 \n     * @param _reserve1 \u50a8\u59071 \n     */ \n    function _update( \n        uint256 balance0, \n        uint256 balance1, \n        uint112 _reserve0, \n        uint112 _reserve1 \n    ) private { \n        //\u786e\u8ba4\u4f59\u989d0\u548c\u4f59\u989d1\u5c0f\u4e8e\u7b49\u4e8e\u6700\u5927\u7684uint112 \n        require( \n            balance0 <= uint112(-1) && balance1 <= uint112(-1), \n            \"Swap: OVERFLOW\" \n        ); \n        //\u533a\u5757\u65f6\u95f4\u6233,\u5c06\u65f6\u95f4\u6233\u8f6c\u6362\u4e3auint32 \n        uint32 blockTimestamp = uint32(block.timestamp % 2**32); \n        //\u8ba1\u7b97\u65f6\u95f4\u6d41\u901d \n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired \n        //\u5982\u679c\u65f6\u95f4\u6d41\u901d>0 \u5e76\u4e14 \u50a8\u5907\u91cf0,1\u4e0d\u7b49\u4e8e0 \n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) { \n            // * never overflows, and + overflow is desired \n            //\u4ef7\u683c0\u6700\u540e\u7d2f\u8ba1 += \u50a8\u5907\u91cf1 * 2**112 / \u50a8\u5907\u91cf0 * \u65f6\u95f4\u6d41\u901d \n            price0CumulativeLast += \n                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * \n                timeElapsed; \n            //\u4ef7\u683c1\u6700\u540e\u7d2f\u8ba1 += \u50a8\u5907\u91cf0 * 2**112 / \u50a8\u5907\u91cf1 * \u65f6\u95f4\u6d41\u901d \n            price1CumulativeLast += \n                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * \n                timeElapsed; \n        } \n        //\u4f59\u989d0,1\u653e\u5165\u50a8\u5907\u91cf0,1 \n        reserve0 = uint112(balance0); \n        reserve1 = uint112(balance1); \n        //\u66f4\u65b0\u6700\u540e\u65f6\u95f4\u6233 \n        blockTimestampLast = blockTimestamp; \n        //\u89e6\u53d1\u540c\u6b65\u4e8b\u4ef6 \n        emit Sync(reserve0, reserve1); \n    } \n \n    /** \n     * @dev \u9ed8\u8ba4\u60c5\u51b5\u4e0b\u94f8\u9020\u6d41\u52a8\u6027\u76f8\u5f53\u4e8e1/6\u7684\u589e\u957fsqrt\uff08k\uff09 \n     * @param _reserve0 \u50a8\u59070 \n     * @param _reserve1 \u50a8\u59071 \n     */ \n    function _mintFee(uint112 _reserve0, uint112 _reserve1) \n        private \n    { \n        //\u5b9a\u4e49k\u503c \n        uint256 _kLast = kLast; // gas savings \n        //\u5982\u679ck\u503c\u4e0d\u7b49\u4e8e0 \n        if (_kLast != 0 && rootKmul > 0) { \n            //\u8ba1\u7b97(_reserve0*_reserve1)\u7684\u5e73\u65b9\u6839 \n            uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1)); \n            //\u8ba1\u7b97k\u503c\u7684\u5e73\u65b9\u6839 \n            uint256 rootKLast = Math.sqrt(_kLast); \n            //\u5982\u679crootK>rootKLast \n            if (rootK > rootKLast) { \n                //\u5206\u5b50 = erc20\u603b\u91cf * (rootK - rootKLast) \n                uint256 numerator = totalSupply.mul(rootK.sub(rootKLast)); \n                //\u5206\u6bcd = rootK * 5 + rootKLast \n                uint256 denominator = rootK.mul(rootKmul).add(rootKLast); \n                //\u6d41\u52a8\u6027 = \u5206\u5b50 / \u5206\u6bcd \n                uint256 liquidity = numerator / denominator; \n                // \u5982\u679c\u6d41\u52a8\u6027 > 0 \u5c06\u6d41\u52a8\u6027\u94f8\u9020\u7ed9feeTo\u5730\u5740 \n                if (liquidity > 0) _mint(getFeeTo(), liquidity); \n            } \n        } \n    } \n \n    /** \n     * @dev \u94f8\u9020\u65b9\u6cd5 \n     * @param to to\u5730\u5740 \n     * @return liquidity \u6d41\u52a8\u6027\u6570\u91cf \n     * @notice \u5e94\u8be5\u4ece\u6267\u884c\u91cd\u8981\u5b89\u5168\u68c0\u67e5\u7684\u5408\u540c\u4e2d\u8c03\u7528\u6b64\u4f4e\u7ea7\u529f\u80fd \n     */ \n    function mint(address to) external lock returns (uint256 liquidity) { \n        //\u83b7\u53d6`\u50a8\u5907\u91cf0`,`\u50a8\u5907\u91cf1` \n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings \n        //\u83b7\u53d6\u5f53\u524d\u5408\u7ea6\u5728token0\u5408\u7ea6\u5185\u7684\u4f59\u989d \n        uint256 balance0 = IERC20(token0).balanceOf(address(this)); \n        //\u83b7\u53d6\u5f53\u524d\u5408\u7ea6\u5728token1\u5408\u7ea6\u5185\u7684\u4f59\u989d \n        uint256 balance1 = IERC20(token1).balanceOf(address(this)); \n        //amount0 = \u4f59\u989d0 \n        uint256 amount0 = balance0.sub(_reserve0); \n        //amount1 = \u4f59\u989d1 \n        uint256 amount1 = balance1.sub(_reserve1); \n \n        //\u8c03\u7528\u94f8\u9020\u8d39\u65b9\u6cd5 \n        _mintFee(_reserve0, _reserve1); \n        //\u83b7\u53d6totalSupply,\u5fc5\u987b\u5728\u6b64\u5904\u5b9a\u4e49\uff0c\u56e0\u4e3atotalSupply\u53ef\u4ee5\u5728mintFee\u4e2d\u66f4\u65b0 \n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply ca\n        //\u5982\u679c_totalSupply\u7b49\u4e8e0,\u9996\u6b21\u521b\u5efa\u914d\u5bf9 \n        if (_totalSupply == 0) { \n            //\u6d41\u52a8\u6027 = (\u6570\u91cf0 * \u6570\u91cf1)\u7684\u5e73\u65b9\u6839 - \u6700\u5c0f\u6d41\u52a8\u60271000 \n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); \n            //\u5728\u603b\u91cf\u4e3a0\u7684\u521d\u59cb\u72b6\u6001,\u6c38\u4e45\u9501\u5b9a\u6700\u4f4e\u6d41\u52a8\u6027 \n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tok\n \n            // \u8bbe\u7f6e\u914d\u5bf9\u521b\u5efa\u8005\u4e3ato\u5730\u5740 \n            creator = to; // set creator \n        } else { \n            //\u6d41\u52a8\u6027 = \u6700\u5c0f\u503c (amount0 * _totalSupply / _reserve0) \u548c (amount1 * _totalSupply / _reserv\n            liquidity = Math.min( \n                amount0.mul(_totalSupply) / _reserve0, \n                amount1.mul(_totalSupply) / _reserve1 \n            ); \n        } \n        //\u786e\u8ba4\u6d41\u52a8\u6027 > 0 \n        require(liquidity > 0, \"Swap: INSUFFICIENT_LIQUIDITY_MINTED\"); \n        //\u94f8\u9020\u6d41\u52a8\u6027\u7ed9to\u5730\u5740 \n        _mint(to, liquidity); \n \n        //\u66f4\u65b0\u50a8\u5907\u91cf \n        _update(balance0, balance1, _reserve0, _reserve1); \n        //k\u503c = \u50a8\u59070 * \u50a8\u59071,\u50a8\u5907\u91cf\u4e2d\u5305\u542b\u865a\u6d41\u52a8\u6027,\u6240\u4ee5\u8981\u518d\u51cf\u53bb \n        kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date \n        //\u89e6\u53d1\u94f8\u9020\u4e8b\u4ef6 \n        emit Mint(msg.sender, amount0, amount1); \n    } \n \n    /** \n     * @dev \u9500\u6bc1\u65b9\u6cd5 \n     * @param to to\u5730\u5740 \n     * @return amount0 \n     * @return amount1 \n     * @notice \u5e94\u8be5\u4ece\u6267\u884c\u91cd\u8981\u5b89\u5168\u68c0\u67e5\u7684\u5408\u540c\u4e2d\u8c03\u7528\u6b64\u4f4e\u7ea7\u529f\u80fd \n     */ \n    function burn(address to) \n        external \n        lock \n        returns (uint256 amount0, uint256 amount1) \n    { \n        //\u83b7\u53d6`\u50a8\u5907\u91cf0`,`\u50a8\u5907\u91cf1` \n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); \n        //\u83b7\u53d6\u5f53\u524d\u5408\u7ea6\u5728token0\u5408\u7ea6\u5185\u7684\u4f59\u989d \n        address _token0 = token0; \n        uint256 balance0 = IERC20(_token0).balanceOf(address(this)); \n        //\u83b7\u53d6\u5f53\u524d\u5408\u7ea6\u5728token1\u5408\u7ea6\u5185\u7684\u4f59\u989d \n        address _token1 = token1; \n        uint256 balance1 = IERC20(_token1).balanceOf(address(this)); \n        //\u4ece\u5f53\u524d\u5408\u7ea6\u7684balanceOf\u6620\u5c04\u4e2d\u83b7\u53d6\u5f53\u524d\u5408\u7ea6\u81ea\u8eab\u7684\u6d41\u52a8\u6027\u6570\u91cf,\u79fb\u9664\u6d41\u52a8\u6027\u7684\u4e4b\u524d\u5148\u5c06lptoken\u53d1\u9001\u5230\u914d\u5bf9\u5408\u7ea6 \n        uint256 liquidity = balanceOf[address(this)]; \n \n        //\u8c03\u7528\u94f8\u9020\u8d39\u65b9\u6cd5 \n        _mintFee(_reserve0, _reserve1); \n        //\u83b7\u53d6totalSupply,\u5fc5\u987b\u5728\u6b64\u5904\u5b9a\u4e49\uff0c\u56e0\u4e3atotalSupply\u53ef\u4ee5\u5728mintFee\u4e2d\u66f4\u65b0 \n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply ca\n        //amount0 = \u6d41\u52a8\u6027\u6570\u91cf * \u4f59\u989d0 / totalSupply   \u4f7f\u7528\u4f59\u989d\u786e\u4fdd\u6309\u6bd4\u4f8b\u5206\u914d \n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribu\n        //amount1 = \u6d41\u52a8\u6027\u6570\u91cf * \u4f59\u989d1 / totalSupply   \u4f7f\u7528\u4f59\u989d\u786e\u4fdd\u6309\u6bd4\u4f8b\u5206\u914d \n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribu\n        //\u786e\u8ba4amount0\u548camount1\u90fd\u5927\u4e8e0 \n        require( \n            amount0 > 0 && amount1 > 0, \n            \"Swap: INSUFFICIENT_LIQUIDITY_BURNED\" \n        ); \n        //\u9500\u6bc1\u5f53\u524d\u5408\u7ea6\u5185\u7684\u6d41\u52a8\u6027\u6570\u91cf \n        _burn(address(this), liquidity); \n        //\u5c06amount0\u6570\u91cf\u7684_token0\u53d1\u9001\u7ed9to\u5730\u5740 \n        _safeTransfer(_token0, to, amount0); \n        //\u5c06amount1\u6570\u91cf\u7684_token1\u53d1\u9001\u7ed9to\u5730\u5740 \n        _safeTransfer(_token1, to, amount1); \n        //\u66f4\u65b0balance0 \n        balance0 = IERC20(_token0).balanceOf(address(this)); \n        //\u66f4\u65b0balance1 \n        balance1 = IERC20(_token1).balanceOf(address(this)); \n \n        //\u66f4\u65b0\u50a8\u5907\u91cf \n        _update(balance0, balance1, _reserve0, _reserve1); \n        //k\u503c = \u50a8\u59070 * \u50a8\u59071,\u50a8\u5907\u91cf\u4e2d\u5305\u542b\u865a\u6d41\u52a8\u6027,\u6240\u4ee5\u8981\u518d\u51cf\u53bb \n        kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date \n        //\u89e6\u53d1\u9500\u6bc1\u4e8b\u4ef6 \n        emit Burn(msg.sender, amount0, amount1, to); \n    } \n \n    /** \n     * @dev \u4ea4\u6362\u65b9\u6cd5 \n     * @param amount0Out \u8f93\u51fa\u6570\u989d0 \n     * @param amount1Out \u8f93\u51fa\u6570\u989d1 \n     * @param to    to\u5730\u5740 \n     * @param data  \u7528\u4e8e\u56de\u8c03\u7684\u6570\u636e \n     * @notice \u5e94\u8be5\u4ece\u6267\u884c\u91cd\u8981\u5b89\u5168\u68c0\u67e5\u7684\u5408\u540c\u4e2d\u8c03\u7528\u6b64\u4f4e\u7ea7\u529f\u80fd \n     */ \n    function swap( \n        uint256 amount0Out, \n        uint256 amount1Out, \n        address to, \n        bytes calldata data \n    ) external lock { \n        //\u786e\u8ba4amount0Out\u548camount1Out\u90fd\u5927\u4e8e0 \n        require( \n            amount0Out > 0 || amount1Out > 0, \n            \"Swap: INSUFFICIENT_OUTPUT_AMOUNT\" \n        ); \n        //\u83b7\u53d6`\u50a8\u5907\u91cf0`,`\u50a8\u5907\u91cf1` \n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings \n        //\u786e\u8ba4`\u8f93\u51fa\u6570\u91cf0,1` < `\u50a8\u5907\u91cf0,1` \n        require( \n            amount0Out < _reserve0 && amount1Out < _reserve1, \n            \"Swap: INSUFFICIENT_LIQUIDITY\" \n        ); \n \n        //\u521d\u59cb\u5316\u53d8\u91cf \n        uint256 balance0; \n        uint256 balance1; \n        { \n            //\u6807\u8bb0_token{0,1}\u7684\u4f5c\u7528\u57df\uff0c\u907f\u514d\u5806\u6808\u592a\u6df1\u7684\u9519\u8bef \n            // scope for _token{0,1}, avoids stack too deep errors \n            address _token0 = token0; \n            address _token1 = token1; \n            //\u786e\u8ba4to\u5730\u5740\u4e0d\u7b49\u4e8e_token0\u548c_token1 \n            require(to != _token0 && to != _token1, \"Swap: INVALID_TO\"); \n            //\u5982\u679c`\u8f93\u51fa\u6570\u91cf0` > 0 \u5b89\u5168\u53d1\u9001`\u8f93\u51fa\u6570\u91cf0`\u7684token0\u5230to\u5730\u5740 \n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer to\n            //\u5982\u679c`\u8f93\u51fa\u6570\u91cf1` > 0 \u5b89\u5168\u53d1\u9001`\u8f93\u51fa\u6570\u91cf1`\u7684token1\u5230to\u5730\u5740 \n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer to\n            //\u5982\u679cdata\u7684\u957f\u5ea6\u5927\u4e8e0 \u8c03\u7528to\u5730\u5740\u7684\u63a5\u53e3,\u95ea\u7535\u8d37! \n            if (data.length > 0) \n                ISwapCallee(to).swapCall( \n                    msg.sender, \n                    amount0Out, \n                    amount1Out, \n                    data \n                ); \n            //\u8c03\u7528\u4ea4\u6613\u94a9\u5b50 \n            if (swapHookAddress != address(0)) \n                ISwapHook(swapHookAddress).swapHook( \n                    msg.sender, \n                    amount0Out, \n                    amount1Out, \n                    to \n                ); \n            //\u83b7\u53d6\u5f53\u524d\u5408\u7ea6\u5728token0\u5408\u7ea6\u5185\u7684\u4f59\u989d \n            balance0 = IERC20(_token0).balanceOf(address(this)); \n            //\u83b7\u53d6\u5f53\u524d\u5408\u7ea6\u5728token1\u5408\u7ea6\u5185\u7684\u4f59\u989d \n            balance1 = IERC20(_token1).balanceOf(address(this)); \n        } \n        //\u5982\u679c \u4f59\u989d0 > \u50a8\u59070 - amount0Out \u5219 amount0In = \u4f59\u989d0 - (\u50a8\u59070 - amount0Out) \u5426\u5219 amount0In = 0 \n        uint256 amount0In = \n            balance0 > _reserve0 - amount0Out \n                ? balance0 - (_reserve0 - amount0Out) \n                : 0; \n        //\u5982\u679c \u4f59\u989d1 > \u50a8\u59071 - amount1Out \u5219 amount1In = \u4f59\u989d1 - (\u50a8\u59071 - amount1Out) \u5426\u5219 amount1In = 0 \n        uint256 amount1In = \n            balance1 > _reserve1 - amount1Out \n                ? balance1 - (_reserve1 - amount1Out) \n                : 0; \n        //\u786e\u8ba4`\u8f93\u5165\u6570\u91cf0||1`\u5927\u4e8e0 \n        require( \n            amount0In > 0 || amount1In > 0, \n            \"Swap: INSUFFICIENT_INPUT_AMOUNT\" \n        ); \n        { \n            //\u6807\u8bb0reserve{0,1}\u7684\u4f5c\u7528\u57df\uff0c\u907f\u514d\u5806\u6808\u592a\u6df1\u7684\u9519\u8bef \n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors \n            //\u8c03\u6574\u540e\u7684\u4f59\u989d0 = \u4f59\u989d0 * 1000 - (amount0In * fee) \n            uint256 balance0Adjusted = \n                balance0.mul(1000).sub(amount0In.mul(fee)); \n            //\u8c03\u6574\u540e\u7684\u4f59\u989d1 = \u4f59\u989d1 * 1000 - (amount1In * fee) \n            uint256 balance1Adjusted = \n                balance1.mul(1000).sub(amount1In.mul(fee)); \n            //\u786e\u8ba4balance0Adjusted * balance1Adjusted >= \u50a8\u59070 * \u50a8\u59071 * 1000000 \n            require( \n                balance0Adjusted.mul(balance1Adjusted) >= \n                    uint256(_reserve0).mul(_reserve1).mul(1000**2), \n                \"Swap: K\" \n            ); \n        } \n \n        //\u66f4\u65b0\u50a8\u5907\u91cf \n        _update(balance0, balance1, _reserve0, _reserve1); \n        //\u89e6\u53d1\u4ea4\u6362\u4e8b\u4ef6 \n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to); \n    } \n \n    /** \n     * @dev \u5f3a\u5236\u5e73\u8861\u4ee5\u5339\u914d\u50a8\u5907 \n     * @param to to\u5730\u5740 \n     */ \n    function skim(address to) external lock { \n        //\u5c06\u5f53\u524d\u5408\u7ea6\u5728`token0,1`\u7684\u4f59\u989d-`\u50a8\u5907\u91cf0,1`\u5b89\u5168\u53d1\u9001\u5230to\u5730\u5740 \n        address _token0 = token0; // gas savings \n        address _token1 = token1; // gas savings \n        _safeTransfer( \n            _token0, \n            to, \n            IERC20(_token0).balanceOf(address(this)).sub(reserve0) \n        ); \n        _safeTransfer( \n            _token1, \n            to, \n            IERC20(_token1).balanceOf(address(this)).sub(reserve1) \n        ); \n    } \n \n    /** \n     * @dev \u5f3a\u5236\u51c6\u5907\u91d1\u4e0e\u4f59\u989d\u5339\u914d \n     */ \n    function sync() external lock { \n        _update( \n            IERC20(token0).balanceOf(address(this)), \n            IERC20(token1).balanceOf(address(this)), \n            reserve0, \n            reserve1 \n        ); \n    } \n} \n \n/** \n * @title Swap\u5de5\u5382\u5408\u7ea6 \n */ \ncontract SwapFactory is ISwapFactory { \n    /// @notice \u6536\u7a0e\u5730\u5740 \n    address public override feeTo; \n    /// @notice \u6536\u7a0e\u6743\u9650\u63a7\u5236\u5730\u5740,\u5e94\u4e3a\u6cbb\u7406\u5730\u5740 \n    address public override feeToSetter; \n    /// @notice \u914d\u5bf9\u6620\u5c04,\u5730\u5740=>(\u5730\u5740=>\u5730\u5740) \n    mapping(address => mapping(address => address)) public override getPair; \n    /// @notice \u6240\u6709\u914d\u5bf9\u6570\u7ec4 \n    address[] public override allPairs; \n \n    /** \n     * @dev \u4e8b\u4ef6:\u521b\u5efa\u914d\u5bf9 \n     * @param token0 token0 \n     * @param token1 token1 \n     * @param pair \u914d\u5bf9\u5730\u5740 \n     */ \n    event PairCreated( \n        address indexed token0, \n        address indexed token1, \n        address pair, \n        uint256 \n    ); \n \n    /** \n     * @dev \u6784\u9020\u51fd\u6570 \n     */ \n    constructor(address _feeToSetter) public { \n        feeToSetter = _feeToSetter; \n    } \n \n    /** \n     * @dev \u67e5\u8be2\u914d\u5bf9\u6570\u7ec4\u957f\u5ea6\u65b9\u6cd5 \n     */ \n    function allPairsLength() external view override returns (uint256) { \n        return allPairs.length; \n    } \n \n    /** \n     * @dev  \u914d\u5bf9\u5408\u7ea6\u6e90\u4ee3\u7801Bytecode\u7684hash\u503c(\u7528\u4f5c\u524d\u7aef\u8ba1\u7b97\u914d\u5bf9\u5408\u7ea6\u5730\u5740) \n     */ \n    function pairCodeHash() external pure override returns (bytes32) { \n        return keccak256(type(SwapPair).creationCode); \n    } \n \n    /** \n     * @dev \u521b\u5efa\u914d\u5bf9 \n     * @param tokenA TokenA \n     * @param tokenB TokenB \n     * @return pair \u914d\u5bf9\u5730\u5740 \n     * @notice \u5e94\u8be5\u4ece\u8def\u7531\u5408\u7ea6\u8c03\u7528\u914d\u5bf9\u5bfb\u627e\u5de5\u5382\u5408\u7ea6\u6765\u8c03\u7528,\u5426\u5219\u901a\u8fc7\u8def\u7531\u5408\u7ea6\u627e\u4e0d\u5230\u914d\u5bf9\u5408\u7ea6 \n     */ \n    function createPair(address tokenA, address tokenB) \n        external \n        override \n        returns (address pair) \n    { \n        //\u786e\u8ba4tokenA\u4e0d\u7b49\u4e8etokenB \n        require(tokenA != tokenB, \"Swap: IDENTICAL_ADDRESSES\"); \n        //\u5c06tokenA\u548ctokenB\u8fdb\u884c\u5927\u5c0f\u6392\u5e8f,\u786e\u4fddtokenA\u5c0f\u4e8etokenB \n        (address token0, address token1) = \n            tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        //\u786e\u8ba4token0\u4e0d\u7b49\u4e8e0\u5730\u5740 \n        require(token0 != address(0), \"Swap: ZERO_ADDRESS\"); \n        //\u786e\u8ba4\u914d\u5bf9\u6620\u5c04\u4e2d\u4e0d\u5b58\u5728token0=>token1 \n        require(getPair[token0][token1] == address(0), \"Swap: PAIR_EXISTS\"); // single check is suffi\n        //\u7ed9bytecode\u53d8\u91cf\u8d4b\u503c\"SwapPair\"\u5408\u7ea6\u7684\u521b\u5efa\u5b57\u8282\u7801 \n        bytes memory bytecode = type(SwapPair).creationCode; \n        //\u5c06token0\u548ctoken1\u6253\u5305\u540e\u521b\u5efa\u54c8\u5e0c \n        bytes32 salt = keccak256(abi.encodePacked(token0, token1)); \n        //\u5185\u8054\u6c47\u7f16 \n        //solium-disable-next-line \n        assembly { \n            //\u901a\u8fc7create2\u65b9\u6cd5\u5e03\u7f72\u5408\u7ea6,\u5e76\u4e14\u52a0\u76d0,\u8fd4\u56de\u5730\u5740\u5230pair\u53d8\u91cf \n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        //\u8c03\u7528pair\u5730\u5740\u7684\u5408\u7ea6\u4e2d\u7684\"initialize\"\u65b9\u6cd5,\u4f20\u5165\u53d8\u91cftoken0,token1 \n        SwapPair(pair).initialize(token0, token1); \n        //\u914d\u5bf9\u6620\u5c04\u4e2d\u8bbe\u7f6etoken0=>token1=pair \n        getPair[token0][token1] = pair; \n        //\u914d\u5bf9\u6620\u5c04\u4e2d\u8bbe\u7f6etoken1=>token0=pair \n        getPair[token1][token0] = pair; // populate mapping in the reverse direction \n        //\u914d\u5bf9\u6570\u7ec4\u4e2d\u63a8\u5165pair\u5730\u5740 \n        allPairs.push(pair); \n        //\u89e6\u53d1\u914d\u5bf9\u6210\u529f\u4e8b\u4ef6 \n        emit PairCreated(token0, token1, pair, allPairs.length); \n    } \n \n    /** \n     * @dev \u4fee\u9970\u7b26:\u786e\u8ba4\u5fc5\u987b\u4e3a\u5de5\u5382\u5408\u7ea6\u7684FeeToSetter\u5730\u5740 \n     */ \n    modifier onlyFeeToSetter() { \n        // \u786e\u8ba4\u5fc5\u987b\u4e3a\u5de5\u5382\u5408\u7ea6\u7684FeeToSetter\u5730\u5740 \n        require(msg.sender == feeToSetter, \"Swap: FORBIDDEN\"); \n        _; \n    } \n \n    /** \n     * @dev \u8bbe\u7f6e\u6536\u7a0e\u5730\u5740 \n     * @param _feeTo \u6536\u7a0e\u5730\u5740 \n     */ \n    function setFeeTo(address _feeTo) external override onlyFeeToSetter { \n        feeTo = _feeTo; \n    } \n \n    /** \n     * @dev \u8bbe\u7f6e\u6536\u7a0e\u6743\u9650\u63a7\u5236 \n     * @param _feeToSetter \u6536\u7a0e\u6743\u9650\u63a7\u5236 \n     */ \n    function setFeeToSetter(address _feeToSetter) \n        external \n        override \n        onlyFeeToSetter \n    { \n        feeToSetter = _feeToSetter; \n    } \n} \n \n",
            "pragma solidity ^0.6.0; \n \ninterface IERC20 { \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 value \n    ); \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    function name() external view returns (string memory); \n \n    function symbol() external view returns (string memory); \n \n    function decimals() external view returns (uint8); \n \n    function totalSupply() external view returns (uint256); \n \n    function balanceOf(address owner) external view returns (uint256); \n \n    function allowance(address owner, address spender) \n        external \n        view \n        returns (uint256); \n \n    function approve(address spender, uint256 value) external returns (bool); \n \n    function transfer(address to, uint256 value) external returns (bool); \n \n    function transferFrom( \n        address from, \n        address to, \n        uint256 value \n    ) external returns (bool); \n} \n \nlibrary SafeMath { \n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) { \n        require((z = x + y) >= x, \"ds-math-add-overflow\"); \n    } \n \n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) { \n        require((z = x - y) <= x, \"ds-math-sub-underflow\"); \n    } \n \n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) { \n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\"); \n    } \n} \n \ninterface ISwapPair { \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 value \n    ); \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    function name() external pure returns (string memory); \n \n    function symbol() external pure returns (string memory); \n \n    function decimals() external pure returns (uint8); \n \n    function totalSupply() external view returns (uint256); \n \n    function balanceOf(address owner) external view returns (uint256); \n \n    function allowance(address owner, address spender) \n        external \n        view \n        returns (uint256); \n \n    function approve(address spender, uint256 value) external returns (bool); \n \n    function transfer(address to, uint256 value) external returns (bool); \n \n    function transferFrom( \n        address from, \n        address to, \n        uint256 value \n    ) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n \n    function nonces(address owner) external view returns (uint256); \n \n    function permit( \n        address owner, \n        address spender, \n        uint256 value, \n        uint256 deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external; \n \n    event Mint(address indexed sender, uint256 amount0, uint256 amount1); \n    event Burn( \n        address indexed sender, \n        uint256 amount0, \n        uint256 amount1, \n        address indexed to \n    ); \n    event Swap( \n        address indexed sender, \n        uint256 amount0In, \n        uint256 amount1In, \n        uint256 amount0Out, \n        uint256 amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint256); \n \n    function factory() external view returns (address); \n \n    function token0() external view returns (address); \n \n    function token1() external view returns (address); \n \n    function getReserves() \n        external \n        view \n        returns ( \n            uint112 reserve0, \n            uint112 reserve1, \n            uint32 blockTimestampLast \n        ); \n \n    function price0CumulativeLast() external view returns (uint256); \n \n    function price1CumulativeLast() external view returns (uint256); \n \n    function kLast() external view returns (uint256); \n \n    function mint(address to) external returns (uint256 liquidity); \n \n    function burn(address to) \n        external \n        returns (uint256 amount0, uint256 amount1); \n \n    function swap( \n        uint256 amount0Out, \n        uint256 amount1Out, \n        address to, \n        bytes calldata data \n    ) external; \n \n    function skim(address to) external; \n \n    function sync() external; \n \n    function fee() external view returns (uint8); \n \n    function feeTo() external view returns (address); \n \n    function getFeeTo() external view returns (address); \n \n    function creator() external view returns (address); \n \n    function birthday() external view returns (uint256); \n \n    function rootKmul() external view returns (uint8); \n \n    function initialize(address, address) external; \n \n    function setFeeTo(address) external; \n \n    function setrootKmul(uint8) external; \n \n    function setFee(uint8) external; \n} \n \ninterface ISwapFactory { \n    event PairCreated( \n        address indexed token0, \n        address indexed token1, \n        address pair, \n        uint256 \n    ); \n \n    function feeTo() external view returns (address); \n \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) \n        external \n        view \n        returns (address pair); \n \n    function allPairs(uint256) external view returns (address pair); \n \n    function allPairsLength() external view returns (uint256); \n \n    function createPair(address tokenA, address tokenB) \n        external \n        returns (address pair); \n \n    function setFeeTo(address) external; \n \n    function setFeeToSetter(address) external; \n \n    function pairCodeHash() external pure returns (bytes32); \n} \n \n/** \n * @title Swap\u5e93\u5408\u7ea6 \n */ \nlibrary SwapLibrary { \n    using SafeMath for uint256; \n \n    /** \n     * @dev \u6392\u5e8ftoken\u5730\u5740 \n     * @notice \u8fd4\u56de\u6392\u5e8f\u7684\u4ee4\u724c\u5730\u5740\uff0c\u7528\u4e8e\u5904\u7406\u6309\u6b64\u987a\u5e8f\u6392\u5e8f\u7684\u5bf9\u4e2d\u7684\u8fd4\u56de\u503c \n     * @param tokenA TokenA \n     * @param tokenB TokenB \n     * @return token0  Token0 \n     * @return token1  Token1 \n     */ \n    function sortTokens(address tokenA, address tokenB) \n        internal \n        pure \n        returns (address token0, address token1) \n    { \n        //\u786e\u8ba4tokenA\u4e0d\u7b49\u4e8etokenB \n        require(tokenA != tokenB, \"SwapLibrary: IDENTICAL_ADDRESSES\"); \n        //\u6392\u5e8ftoken\u5730\u5740 \n        (token0, token1) = tokenA < tokenB \n            ? (tokenA, tokenB) \n            : (tokenB, tokenA); \n        //\u786e\u8ba4token\u5730\u5740\u4e0d\u7b49\u4e8e0\u5730\u5740 \n        require(token0 != address(0), \"SwapLibrary: ZERO_ADDRESS\"); \n    } \n \n    /** \n     * @dev \u83b7\u53d6pair\u5408\u7ea6\u5730\u5740 \n     * @notice \u8ba1\u7b97\u4e00\u5bf9\u7684CREATE2\u5730\u5740\uff0c\u800c\u65e0\u9700\u8fdb\u884c\u4efb\u4f55\u5916\u90e8\u8c03\u7528 \n     * @param factory \u5de5\u5382\u5730\u5740 \n     * @param tokenA TokenA \n     * @param tokenB TokenB \n     * @return pair  pair\u5408\u7ea6\u5730\u5740 \n     */ \n    function pairFor( \n        address factory, \n        address tokenA, \n        address tokenB \n    ) internal pure returns (address pair) { \n        //\u6392\u5e8ftoken\u5730\u5740 \n        (address token0, address token1) = sortTokens(tokenA, tokenB); \n        // \u83b7\u53d6pairCodeHash \n        bytes32 pairCodeHash = ISwapFactory(factory).pairCodeHash(); \n        //\u6839\u636e\u6392\u5e8f\u7684token\u5730\u5740\u8ba1\u7b97create2\u7684pair\u5730\u5740 \n        pair = address( \n            uint256( \n                keccak256( \n                    abi.encodePacked( \n                        hex\"ff\", \n                        factory, \n                        keccak256(abi.encodePacked(token0, token1)), \n                        pairCodeHash // init code hash \n                    ) \n                ) \n            ) \n        ); \n    } \n \n    /** \n     * @dev \u83b7\u53d6\u50a8\u5907\u91cf \n     * @notice \u63d0\u53d6\u5e76\u6392\u5e8f\u4e00\u5bf9\u7684\u50a8\u5907\u91d1 \n     * @param factory \u5de5\u5382\u5730\u5740 \n     * @param tokenA TokenA \n     * @param tokenB TokenB \n     * @return reserveA  \u50a8\u5907\u91cfA \n     * @return reserveB  \u50a8\u5907\u91cfB \n     * @return fee  \u624b\u7eed\u8d39 \n     */ \n    function getReserves( \n        address factory, \n        address tokenA, \n        address tokenB \n    ) \n        internal \n        view \n        returns ( \n            uint256 reserveA, \n            uint256 reserveB, \n            uint8 fee \n        ) \n    { \n        //\u6392\u5e8ftoken\u5730\u5740 \n        (address token0, ) = sortTokens(tokenA, tokenB); \n        //\u901a\u8fc7\u6392\u5e8f\u540e\u7684token\u5730\u5740\u548c\u5de5\u5382\u5408\u7ea6\u5730\u5740\u83b7\u53d6\u5230pair\u5408\u7ea6\u5730\u5740,\u5e76\u4ecepair\u5408\u7ea6\u4e2d\u83b7\u53d6\u50a8\u5907\u91cf0,1 \n        (uint256 reserve0, uint256 reserve1, ) = \n            ISwapPair(pairFor(factory, tokenA, tokenB)).getReserves(); \n        //\u6839\u636e\u8f93\u5165\u7684token\u987a\u5e8f\u8fd4\u56de\u50a8\u5907\u91cf \n        (reserveA, reserveB) = tokenA == token0 \n            ? (reserve0, reserve1) \n            : (reserve1, reserve0); \n        //\u83b7\u53d6\u914d\u5bf9\u5408\u7ea6\u4e2d\u8bbe\u7f6e\u7684\u624b\u7eed\u8d39\u6bd4\u4f8b \n        fee = ISwapPair(pairFor(factory, tokenA, tokenB)).fee(); \n    } \n \n    /** \n     * @dev \u5bf9\u4ef7\u8ba1\u7b97 \n     * @notice \u7ed9\u5b9a\u4e00\u5b9a\u6570\u91cf\u7684\u8d44\u4ea7\u548c\u8d27\u5e01\u5bf9\u50a8\u5907\u91d1\uff0c\u5219\u8fd4\u56de\u7b49\u503c\u7684\u5176\u4ed6\u8d44\u4ea7 \n     * @param amountA \u6570\u989dA \n     * @param reserveA \u50a8\u5907\u91cfA \n     * @param reserveB \u50a8\u5907\u91cfB \n     * @return amountB  \u6570\u989dB \n     */ \n    function quote( \n        uint256 amountA, \n        uint256 reserveA, \n        uint256 reserveB \n    ) internal pure returns (uint256 amountB) { \n        //\u786e\u8ba4\u6570\u989dA>0 \n        require(amountA > 0, \"SwapLibrary: INSUFFICIENT_AMOUNT\"); \n        //\u786e\u8ba4\u50a8\u5907\u91cfA,B\u5927\u4e8e0 \n        require( \n            reserveA > 0 && reserveB > 0, \n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\" \n        ); \n        //\u6570\u989dB = \u6570\u989dA * \u50a8\u5907\u91cfB / \u50a8\u5907\u91cfA \n        amountB = amountA.mul(reserveB) / reserveA; \n    } \n \n    /** \n     * @dev \u83b7\u53d6\u5355\u4e2a\u8f93\u51fa\u6570\u989d \n     * @notice \u7ed9\u5b9a\u4e00\u9879\u8d44\u4ea7\u7684\u8f93\u5165\u91cf\u548c\u914d\u5bf9\u7684\u50a8\u5907\uff0c\u8fd4\u56de\u53e6\u4e00\u9879\u8d44\u4ea7\u7684\u6700\u5927\u8f93\u51fa\u91cf \n     * @param amountIn \u8f93\u5165\u6570\u989d \n     * @param reserveIn \u50a8\u5907\u91cfIn \n     * @param reserveOut \u50a8\u5907\u91cfOut \n     * @param fee \u624b\u7eed\u8d39\u6bd4\u4f8b \n     * @return amountOut  \u8f93\u51fa\u6570\u989d \n     */ \n    function getAmountOut( \n        uint256 amountIn, \n        uint256 reserveIn, \n        uint256 reserveOut, \n        uint8 fee \n    ) internal pure returns (uint256 amountOut) { \n        //\u786e\u8ba4\u8f93\u5165\u6570\u989d\u5927\u4e8e0 \n        require(amountIn > 0, \"SwapLibrary: INSUFFICIENT_INPUT_AMOUNT\"); \n        //\u786e\u8ba4\u50a8\u5907\u91cfIn\u548c\u50a8\u5907\u91cfOut\u5927\u4e8e0 \n        require( \n            reserveIn > 0 && reserveOut > 0, \n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\" \n        ); \n        //\u7a0e\u540e\u8f93\u5165\u6570\u989d = \u8f93\u5165\u6570\u989d * (1000-fee) \n        uint256 amountInWithFee = amountIn.mul(1000 - fee); \n        //\u5206\u5b50 = \u7a0e\u540e\u8f93\u5165\u6570\u989d * \u50a8\u5907\u91cfOut \n        uint256 numerator = amountInWithFee.mul(reserveOut); \n        //\u5206\u6bcd = \u50a8\u5907\u91cfIn * 1000 + \u7a0e\u540e\u8f93\u5165\u6570\u989d \n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee); \n        //\u8f93\u51fa\u6570\u989d = \u5206\u5b50 / \u5206\u6bcd \n        amountOut = numerator / denominator; \n    } \n \n    /** \n     * @dev \u83b7\u53d6\u5355\u4e2a\u8f93\u51fa\u6570\u989d \n     * @notice \u7ed9\u5b9a\u4e00\u9879\u8d44\u4ea7\u7684\u8f93\u51fa\u91cf\u548c\u5bf9\u50a8\u5907\uff0c\u8fd4\u56de\u5176\u4ed6\u8d44\u4ea7\u7684\u6240\u9700\u8f93\u5165\u91cf \n     * @param amountOut \u8f93\u51fa\u6570\u989d \n     * @param reserveIn \u50a8\u5907\u91cfIn \n     * @param reserveOut \u50a8\u5907\u91cfOut \n     * @param fee \u624b\u7eed\u8d39\u6bd4\u4f8b \n     * @return amountIn  \u8f93\u5165\u6570\u989d \n     */ \n    function getAmountIn( \n        uint256 amountOut, \n        uint256 reserveIn, \n        uint256 reserveOut, \n        uint8 fee \n    ) internal pure returns (uint256 amountIn) { \n        //\u786e\u8ba4\u8f93\u51fa\u6570\u989d\u5927\u4e8e0 \n        require(amountOut > 0, \"SwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT\"); \n        //\u786e\u8ba4\u50a8\u5907\u91cfIn\u548c\u50a8\u5907\u91cfOut\u5927\u4e8e0 \n        require( \n            reserveIn > 0 && reserveOut > 0, \n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\" \n        ); \n        //\u5206\u5b50 = \u50a8\u5907\u91cfIn * \u50a8\u5907\u91cfOut * 1000 \n        uint256 numerator = reserveIn.mul(amountOut).mul(1000); \n        //\u5206\u6bcd = \u50a8\u5907\u91cfOut - \u8f93\u51fa\u6570\u989d * (1000-fee) \n        uint256 denominator = reserveOut.sub(amountOut).mul(1000 - fee); \n        //\u8f93\u5165\u6570\u989d = (\u5206\u5b50 / \u5206\u6bcd) + 1 \n        amountIn = (numerator / denominator).add(1); \n    } \n \n    /** \n     * @dev \u83b7\u53d6\u8f93\u51fa\u6570\u989d \n     * @notice \u5bf9\u4efb\u610f\u6570\u91cf\u7684\u5bf9\u6267\u884c\u94fe\u63a5\u7684getAmountOut\u8ba1\u7b97 \n     * @param factory \u5de5\u5382\u5408\u7ea6\u5730\u5740 \n     * @param amountIn \u8f93\u5165\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @return amounts  \u6570\u989d\u6570\u7ec4 \n     */ \n    function getAmountsOut( \n        address factory, \n        uint256 amountIn, \n        address[] memory path \n    ) internal view returns (uint256[] memory amounts) { \n        //\u786e\u8ba4\u8def\u5f84\u6570\u7ec4\u957f\u5ea6\u5927\u4e8e2 \n        require(path.length >= 2, \"SwapLibrary: INVALID_PATH\"); \n        //\u521d\u59cb\u5316\u6570\u989d\u6570\u7ec4 \n        amounts = new uint256[](path.length); \n        //\u6570\u989d\u6570\u7ec4[0] = \u8f93\u5165\u6570\u989d \n        amounts[0] = amountIn; \n        //\u904d\u5386\u8def\u5f84\u6570\u7ec4,path\u957f\u5ea6-1 \n        for (uint256 i; i < path.length - 1; i++) { \n            //(\u50a8\u5907\u91cfIn,\u50a8\u5907\u91cfOut,\u624b\u7eed\u8d39\u6bd4\u4f8b) = \u83b7\u53d6\u50a8\u5907(\u5f53\u524d\u8def\u5f84\u5730\u5740,\u4e0b\u4e00\u4e2a\u8def\u5f84\u5730\u5740) \n            (uint256 reserveIn, uint256 reserveOut, uint8 fee) = \n                getReserves(factory, path[i], path[i + 1]); \n            //\u4e0b\u4e00\u4e2a\u6570\u989d = \u83b7\u53d6\u8f93\u51fa\u6570\u989d(\u5f53\u524d\u6570\u989d,\u50a8\u5907\u91cfIn,\u50a8\u5907\u91cfOut) \n            amounts[i + 1] = getAmountOut( \n                amounts[i], \n                reserveIn, \n                reserveOut, \n                fee \n            ); \n        } \n    } \n \n    /** \n     * @dev \u83b7\u53d6\u8f93\u51fa\u6570\u989d \n     * @notice \u5bf9\u4efb\u610f\u6570\u91cf\u7684\u5bf9\u6267\u884c\u94fe\u63a5\u7684getAmountIn\u8ba1\u7b97 \n     * @param factory \u5de5\u5382\u5408\u7ea6\u5730\u5740 \n     * @param amountOut \u8f93\u51fa\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @return amounts  \u6570\u989d\u6570\u7ec4 \n     */ \n    function getAmountsIn( \n        address factory, \n        uint256 amountOut, \n        address[] memory path \n    ) internal view returns (uint256[] memory amounts) { \n        //\u786e\u8ba4\u8def\u5f84\u6570\u7ec4\u957f\u5ea6\u5927\u4e8e2 \n        require(path.length >= 2, \"SwapLibrary: INVALID_PATH\"); \n        //\u521d\u59cb\u5316\u6570\u989d\u6570\u7ec4 \n        amounts = new uint256[](path.length); \n        //\u6570\u989d\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u5143\u7d20 = \u8f93\u51fa\u6570\u989d \n        amounts[amounts.length - 1] = amountOut; \n        //\u4ece\u5012\u6570\u7b2c\u4e8c\u4e2a\u5143\u7d20\u5012\u53d9\u904d\u5386\u8def\u5f84\u6570\u7ec4 \n        for (uint256 i = path.length - 1; i > 0; i--) { \n            //(\u50a8\u5907\u91cfIn,\u50a8\u5907\u91cfOut,\u624b\u7eed\u8d39\u6bd4\u4f8b) = \u83b7\u53d6\u50a8\u5907(\u4e0a\u4e00\u4e2a\u8def\u5f84\u5730\u5740,\u5f53\u524d\u8def\u5f84\u5730\u5740) \n            (uint256 reserveIn, uint256 reserveOut, uint8 fee) = \n                getReserves(factory, path[i - 1], path[i]); \n            //\u4e0a\u4e00\u4e2a\u6570\u989d = \u83b7\u53d6\u8f93\u5165\u6570\u989d(\u5f53\u524d\u6570\u989d,\u50a8\u5907\u91cfIn,\u50a8\u5907\u91cfOut) \n            amounts[i - 1] = getAmountIn( \n                amounts[i], \n                reserveIn, \n                reserveOut, \n                fee \n            ); \n        } \n    } \n} \n \nlibrary TransferHelper { \n    function safeApprove( \n        address token, \n        address to, \n        uint256 value \n    ) internal { \n        // bytes4(keccak256(bytes('approve(address,uint256)'))); \n        (bool success, bytes memory data) = \n            token.call(abi.encodeWithSelector(0x095ea7b3, to, value)); \n        require( \n            success && (data.length == 0 || abi.decode(data, (bool))), \n            \"TransferHelper: APPROVE_FAILED\" \n        ); \n    } \n \n    function safeTransfer( \n        address token, \n        address to, \n        uint256 value \n    ) internal { \n        // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n        (bool success, bytes memory data) = \n            token.call(abi.encodeWithSelector(0xa9059cbb, to, value)); \n        require( \n            success && (data.length == 0 || abi.decode(data, (bool))), \n            \"TransferHelper: TRANSFER_FAILED\" \n        ); \n    } \n \n    function safeTransferFrom( \n        address token, \n        address from, \n        address to, \n        uint256 value \n    ) internal { \n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n        (bool success, bytes memory data) = \n            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value)); \n        require( \n            success && (data.length == 0 || abi.decode(data, (bool))), \n            \"TransferHelper: TRANSFER_FROM_FAILED\" \n        ); \n    } \n \n    function safeTransferETH(address to, uint256 value) internal { \n        (bool success, ) = to.call{value: value}(new bytes(0)); \n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\"); \n    } \n} \n \ninterface ISwapRouter { \n    function factory() external view returns (address); \n \n    function WETH() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 amountADesired, \n        uint256 amountBDesired, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to, \n        uint256 deadline \n    ) \n        external \n        returns ( \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ); \n \n    function addLiquidityETH( \n        address token, \n        uint256 amountTokenDesired, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline \n    ) \n        external \n        payable \n        returns ( \n            uint256 amountToken, \n            uint256 amountETH, \n            uint256 liquidity \n        ); \n \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 liquidity, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to, \n        uint256 deadline \n    ) external returns (uint256 amountA, uint256 amountB); \n \n    function removeLiquidityETH( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline \n    ) external returns (uint256 amountToken, uint256 amountETH); \n \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint256 liquidity, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to, \n        uint256 deadline, \n        bool approveMax, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external returns (uint256 amountA, uint256 amountB); \n \n    function removeLiquidityETHWithPermit( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline, \n        bool approveMax, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external returns (uint256 amountToken, uint256 amountETH); \n \n    function swapExactTokensForTokens( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external returns (uint256[] memory amounts); \n \n    function swapTokensForExactTokens( \n        uint256 amountOut, \n        uint256 amountInMax, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external returns (uint256[] memory amounts); \n \n    function swapExactETHForTokens( \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external payable returns (uint256[] memory amounts); \n \n    function swapTokensForExactETH( \n        uint256 amountOut, \n        uint256 amountInMax, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external returns (uint256[] memory amounts); \n \n    function swapExactTokensForETH( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external returns (uint256[] memory amounts); \n \n    function swapETHForExactTokens( \n        uint256 amountOut, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external payable returns (uint256[] memory amounts); \n \n    function quote( \n        uint256 amountA, \n        uint256 reserveA, \n        uint256 reserveB \n    ) external pure returns (uint256 amountB); \n \n    function getAmountOut( \n        uint256 amountIn, \n        uint256 reserveIn, \n        uint256 reserveOut, \n        uint8 fee \n    ) external pure returns (uint256 amountOut); \n \n    function getAmountIn( \n        uint256 amountOut, \n        uint256 reserveIn, \n        uint256 reserveOut, \n        uint8 fee \n    ) external pure returns (uint256 amountIn); \n \n    function getAmountsOut(uint256 amountIn, address[] calldata path) \n        external \n        view \n        returns (uint256[] memory amounts); \n \n    function getAmountsIn(uint256 amountOut, address[] calldata path) \n        external \n        view \n        returns (uint256[] memory amounts); \n \n    function removeLiquidityETHSupportingFeeOnTransferTokens( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline \n    ) external returns (uint256 amountETH); \n \n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline, \n        bool approveMax, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external returns (uint256 amountETH); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external; \n \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external payable; \n \n    function swapExactTokensForETHSupportingFeeOnTransferTokens( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external; \n} \n \ninterface IERC20Swap { \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 value \n    ); \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    function name() external pure returns (string memory); \n \n    function symbol() external pure returns (string memory); \n \n    function decimals() external pure returns (uint8); \n \n    function totalSupply() external view returns (uint256); \n \n    function balanceOf(address owner) external view returns (uint256); \n \n    function allowance(address owner, address spender) \n        external \n        view \n        returns (uint256); \n \n    function approve(address spender, uint256 value) external returns (bool); \n \n    function transfer(address to, uint256 value) external returns (bool); \n \n    function transferFrom( \n        address from, \n        address to, \n        uint256 value \n    ) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n \n    function nonces(address owner) external view returns (uint256); \n \n    function permit( \n        address owner, \n        address spender, \n        uint256 value, \n        uint256 deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external; \n} \n \ninterface IWETH { \n    function deposit() external payable; \n \n    function transfer(address to, uint256 value) external returns (bool); \n \n    function withdraw(uint256) external; \n} \n \n/** \n * @title Swap \u8def\u7531\u5408\u7ea6 \n */ \ncontract SwapRouter is ISwapRouter { \n    using SafeMath for uint256; \n \n    /// @notice \u5e03\u7f72\u65f6\u5b9a\u4e49\u7684\u5e38\u91cffactory\u5730\u5740\u548cWETH\u5730\u5740 \n    address public immutable override factory; \n    address public immutable override WETH; \n \n    /** \n     * @dev \u4fee\u9970\u7b26:\u786e\u4fdd\u6700\u540e\u671f\u9650\u5927\u4e8e\u5f53\u524d\u65f6\u95f4 \n     */ \n    modifier ensure(uint256 deadline) { \n        require(deadline >= block.timestamp, \"SwapRouter: EXPIRED\"); \n        _; \n    } \n \n    /** \n     * @dev \u6784\u9020\u51fd\u6570 \n     * @param _factory \u5de5\u5382\u5408\u7ea6\u5730\u5740 \n     * @param _WETH WETH\u5408\u7ea6\u5730\u5740 \n     */ \n    constructor(address _factory, address _WETH) public { \n        factory = _factory; \n        WETH = _WETH; \n    } \n \n    /** \n     * @dev \u6536\u6b3e\u65b9\u6cd5 \n     */ \n    receive() external payable { \n        //\u65ad\u8a00\u8c03\u7528\u8005\u4e3aWETH\u5408\u7ea6\u5730\u5740 \n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract \n    } \n \n    // **** \u6dfb\u52a0\u6d41\u52a8\u6027 **** \n    /** \n     * @dev \u6dfb\u52a0\u6d41\u52a8\u6027\u7684\u79c1\u6709\u65b9\u6cd5 \n     * @param tokenA tokenA\u5730\u5740 \n     * @param tokenB tokenB\u5730\u5740 \n     * @param amountADesired \u671f\u671b\u6570\u91cfA \n     * @param amountBDesired \u671f\u671b\u6570\u91cfB \n     * @param amountAMin \u6700\u5c0f\u6570\u91cfA \n     * @param amountBMin \u6700\u5c0f\u6570\u91cfB \n     * @return amountA   \u6570\u91cfA \n     * @return amountB   \u6570\u91cfB \n     */ \n    function _addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 amountADesired, \n        uint256 amountBDesired, \n        uint256 amountAMin, \n        uint256 amountBMin \n    ) internal virtual returns (uint256 amountA, uint256 amountB) { \n        //\u5982\u679c\u5de5\u5382\u5408\u7ea6\u4e0d\u5b58\u5728,\u5219\u521b\u5efa\u914d\u5bf9 \n        if (ISwapFactory(factory).getPair(tokenA, tokenB) == address(0)) { \n            ISwapFactory(factory).createPair(tokenA, tokenB); \n        } \n        //\u83b7\u53d6\u4e0d\u542b\u865a\u6d41\u52a8\u6027\u7684\u50a8\u5907\u91cfreserve{A,B} \n        (uint256 reserveA, uint256 reserveB, ) = \n            SwapLibrary.getReserves(factory, tokenA, tokenB); \n        //\u5982\u679c\u50a8\u5907reserve{A,B}==0 \n        if (reserveA == 0 && reserveB == 0) { \n            //\u6570\u91cfamount{A,B} = \u671f\u671b\u6570\u91cfA,B \n            (amountA, amountB) = (amountADesired, amountBDesired); \n        } else { \n            //\u6700\u4f18\u6570\u91cfB = \u671f\u671b\u6570\u91cfA * \u50a8\u5907B / \u50a8\u5907A \n            uint256 amountBOptimal = \n                SwapLibrary.quote(amountADesired, reserveA, reserveB); \n            //\u5982\u679c\u6700\u4f18\u6570\u91cfB <= \u671f\u671b\u6570\u91cfB \n            if (amountBOptimal <= amountBDesired) { \n                //\u786e\u8ba4\u6700\u4f18\u6570\u91cfB >= \u6700\u5c0f\u6570\u91cfB \n                require( \n                    amountBOptimal >= amountBMin, \n                    \"SwapRouter: INSUFFICIENT_B_AMOUNT\" \n                ); \n                //\u6570\u91cfamount{A,B} = \u671f\u671b\u6570\u91cfA, \u6700\u4f18\u6570\u91cfB \n                (amountA, amountB) = (amountADesired, amountBOptimal); \n            } else { \n                //\u6700\u4f18\u6570\u91cfA = \u671f\u671b\u6570\u91cfA * \u50a8\u5907A / \u50a8\u5907B \n                uint256 amountAOptimal = \n                    SwapLibrary.quote(amountBDesired, reserveB, reserveA); \n                //\u65ad\u8a00\u6700\u4f18\u6570\u91cfA <= \u671f\u671b\u6570\u91cfA \n                assert(amountAOptimal <= amountADesired); \n                //\u786e\u8ba4\u6700\u4f18\u6570\u91cfA >= \u6700\u5c0f\u6570\u91cfA \n                require( \n                    amountAOptimal >= amountAMin, \n                    \"SwapRouter: INSUFFICIENT_A_AMOUNT\" \n                ); \n                //\u6570\u91cfamount{A,B} = \u6700\u4f18\u6570\u91cfA, \u671f\u671b\u6570\u91cfB \n                (amountA, amountB) = (amountAOptimal, amountBDesired); \n            } \n        } \n    } \n \n    /** \n     * @dev \u6dfb\u52a0\u6d41\u52a8\u6027\u65b9\u6cd5* \n     * @param tokenA tokenA\u5730\u5740 \n     * @param tokenB tokenB\u5730\u5740 \n     * @param amountADesired \u671f\u671b\u6570\u91cfA \n     * @param amountBDesired \u671f\u671b\u6570\u91cfB \n     * @param amountAMin \u6700\u5c0f\u6570\u91cfA \n     * @param amountBMin \u6700\u5c0f\u6570\u91cfB \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amountA   \u6570\u91cfA \n     * @return amountB   \u6570\u91cfB \n     * @return liquidity   \u6d41\u52a8\u6027\u6570\u91cf \n     */ \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 amountADesired, \n        uint256 amountBDesired, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to, \n        uint256 deadline \n    ) \n        external \n        virtual \n        override \n        ensure(deadline) \n        returns ( \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ) \n    { \n        //\u6dfb\u52a0\u6d41\u52a8\u6027,\u83b7\u53d6\u6570\u91cfA,\u6570\u91cfB \n        (amountA, amountB) = _addLiquidity( \n            tokenA, \n            tokenB, \n            amountADesired, \n            amountBDesired, \n            amountAMin, \n            amountBMin \n        ); \n        //\u6839\u636eTokenA,TokenB\u5730\u5740,\u83b7\u53d6`pair\u5408\u7ea6`\u5730\u5740 \n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB); \n        //\u5c06\u6570\u91cf\u4e3aamountA\u7684tokenA\u4ecemsg.sender\u8d26\u6237\u4e2d\u5b89\u5168\u53d1\u9001\u5230pair\u5408\u7ea6\u5730\u5740 \n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA); \n        //\u5c06\u6570\u91cf\u4e3aamountB\u7684tokenB\u4ecemsg.sender\u8d26\u6237\u4e2d\u5b89\u5168\u53d1\u9001\u5230pair\u5408\u7ea6\u5730\u5740 \n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB); \n        //\u6d41\u52a8\u6027\u6570\u91cf = pair\u5408\u7ea6\u7684\u94f8\u9020\u65b9\u6cd5\u94f8\u9020\u7ed9to\u5730\u5740\u7684\u8fd4\u56de\u503c \n        liquidity = ISwapPair(pair).mint(to); \n    } \n \n    /** \n     * @dev \u6dfb\u52a0ETH\u6d41\u52a8\u6027\u65b9\u6cd5* \n     * @param token token\u5730\u5740 \n     * @param amountTokenDesired Token\u671f\u671b\u6570\u91cf \n     * @param amountTokenMin Token\u6700\u5c0f\u6570\u91cf \n     * @param amountETHMin ETH\u6700\u5c0f\u6570\u91cf \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amountToken   Token\u6570\u91cf \n     * @return amountETH   ETH\u6570\u91cf \n     * @return liquidity   \u6d41\u52a8\u6027\u6570\u91cf \n     */ \n    function addLiquidityETH( \n        address token, \n        uint256 amountTokenDesired, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline \n    ) \n        external \n        payable \n        virtual \n        override \n        ensure(deadline) \n        returns ( \n            uint256 amountToken, \n            uint256 amountETH, \n            uint256 liquidity \n        ) \n    { \n        //\u6dfb\u52a0\u6d41\u52a8\u6027,\u83b7\u53d6Token\u6570\u91cf,ETH\u6570\u91cf \n        (amountToken, amountETH) = _addLiquidity( \n            token, \n            WETH, \n            amountTokenDesired, \n            msg.value, \n            amountTokenMin, \n            amountETHMin \n        ); \n        //\u6839\u636eToken,WETH\u5730\u5740,\u83b7\u53d6`pair\u5408\u7ea6`\u5730\u5740 \n        address pair = SwapLibrary.pairFor(factory, token, WETH); \n        //\u5c06`Token\u6570\u91cf`\u7684token\u4ecemsg.sender\u8d26\u6237\u4e2d\u5b89\u5168\u53d1\u9001\u5230`pair\u5408\u7ea6`\u5730\u5740 \n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken); \n        //\u5411`ETH\u5408\u7ea6`\u5b58\u6b3e`ETH\u6570\u91cf`\u7684\u4e3b\u5e01 \n        IWETH(WETH).deposit{value: amountETH}(); \n        //\u5c06`ETH\u6570\u91cf`\u7684`ETH`token\u53d1\u9001\u5230`pair\u5408\u7ea6`\u5730\u5740 \n        assert(IWETH(WETH).transfer(pair, amountETH)); \n        //\u6d41\u52a8\u6027\u6570\u91cf = pair\u5408\u7ea6\u7684\u94f8\u9020\u65b9\u6cd5\u94f8\u9020\u7ed9`to\u5730\u5740`\u7684\u8fd4\u56de\u503c \n        liquidity = ISwapPair(pair).mint(to); \n        //\u5982\u679c`\u6536\u5230\u7684\u4e3b\u5e01\u6570\u91cf`>`ETH\u6570\u91cf` \u5219\u8fd4\u8fd8`\u6536\u5230\u7684\u4e3b\u5e01\u6570\u91cf`-`ETH\u6570\u91cf` \n        if (msg.value > amountETH) \n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); \n    } \n \n    // **** \u79fb\u9664\u6d41\u52a8\u6027 **** \n    /** \n     * @dev \u79fb\u9664\u6d41\u52a8\u6027* \n     * @param tokenA tokenA\u5730\u5740 \n     * @param tokenB tokenB\u5730\u5740 \n     * @param liquidity \u6d41\u52a8\u6027\u6570\u91cf \n     * @param amountAMin \u6700\u5c0f\u6570\u91cfA \n     * @param amountBMin \u6700\u5c0f\u6570\u91cfB \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amountA   \u6570\u91cfA \n     * @return amountB   \u6570\u91cfB \n     */ \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint256 liquidity, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to, \n        uint256 deadline \n    ) \n        public \n        virtual \n        override \n        ensure(deadline) \n        returns (uint256 amountA, uint256 amountB) \n    { \n        //\u8ba1\u7b97TokenA,TokenB\u7684CREATE2\u5730\u5740\uff0c\u800c\u65e0\u9700\u8fdb\u884c\u4efb\u4f55\u5916\u90e8\u8c03\u7528 \n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB); \n        //\u5c06\u6d41\u52a8\u6027\u6570\u91cf\u4ece\u7528\u6237\u53d1\u9001\u5230pair\u5730\u5740(\u9700\u63d0\u524d\u6279\u51c6) \n        ISwapPair(pair).transferFrom(msg.sender, pair, liquidity); \n        //pair\u5408\u7ea6\u9500\u6bc1\u6d41\u52a8\u6027\u6570\u91cf,\u5e76\u5c06\u6570\u503c0,1\u7684token\u53d1\u9001\u5230to\u5730\u5740 \n        (uint256 amount0, uint256 amount1) = ISwapPair(pair).burn(to); \n        //\u6392\u5e8ftokenA,tokenB \n        (address token0, ) = SwapLibrary.sortTokens(tokenA, tokenB); \n        //\u6309\u6392\u5e8f\u540e\u7684token\u987a\u5e8f\u8fd4\u56de\u6570\u503cAB \n        (amountA, amountB) = tokenA == token0 \n            ? (amount0, amount1) \n            : (amount1, amount0); \n        //\u786e\u4fdd\u6570\u503cAB\u5927\u4e8e\u6700\u5c0f\u503cAB \n        require(amountA >= amountAMin, \"SwapRouter: INSUFFICIENT_A_AMOUNT\"); \n        require(amountB >= amountBMin, \"SwapRouter: INSUFFICIENT_B_AMOUNT\"); \n    } \n \n    /** \n     * @dev \u79fb\u9664ETH\u6d41\u52a8\u6027* \n     * @param token token\u5730\u5740 \n     * @param liquidity \u6d41\u52a8\u6027\u6570\u91cf \n     * @param amountTokenMin token\u6700\u5c0f\u6570\u91cf \n     * @param amountETHMin ETH\u6700\u5c0f\u6570\u91cf \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amountToken   token\u6570\u91cf \n     * @return amountETH   ETH\u6570\u91cf \n     */ \n    function removeLiquidityETH( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline \n    ) \n        public \n        virtual \n        override \n        ensure(deadline) \n        returns (uint256 amountToken, uint256 amountETH) \n    { \n        //(token\u6570\u91cf,ETH\u6570\u91cf) = \u79fb\u9664\u6d41\u52a8\u6027(token\u5730\u5740,WETH\u5730\u5740,\u6d41\u52a8\u6027\u6570\u91cf,token\u6700\u5c0f\u6570\u91cf,ETH\u6700\u5c0f\u6570\u91cf,\u5f53\u524d\u5408\u7ea6\u5730\n        (amountToken, amountETH) = removeLiquidity( \n            token, \n            WETH, \n            liquidity, \n            amountTokenMin, \n            amountETHMin, \n            address(this), \n            deadline \n        ); \n        //\u5c06token\u6570\u91cf\u7684token\u53d1\u9001\u5230to\u5730\u5740 \n        TransferHelper.safeTransfer(token, to, amountToken); \n        //\u4eceWETH\u53d6\u6b3eETH\u6570\u91cf\u7684\u4e3b\u5e01 \n        IWETH(WETH).withdraw(amountETH); \n        //\u5c06ETH\u6570\u91cf\u7684ETH\u53d1\u9001\u5230to\u5730\u5740 \n        TransferHelper.safeTransferETH(to, amountETH); \n    } \n \n    /** \n     * @dev \u5e26\u7b7e\u540d\u79fb\u9664\u6d41\u52a8\u6027* \n     * @param tokenA tokenA\u5730\u5740 \n     * @param tokenB tokenB\u5730\u5740 \n     * @param liquidity \u6d41\u52a8\u6027\u6570\u91cf \n     * @param amountAMin \u6700\u5c0f\u6570\u91cfA \n     * @param amountBMin \u6700\u5c0f\u6570\u91cfB \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @param approveMax \u5168\u90e8\u6279\u51c6 \n     * @param v v \n     * @param r r \n     * @param s s \n     * @return amountA   \u6570\u91cfA \n     * @return amountB   \u6570\u91cfB \n     */ \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint256 liquidity, \n        uint256 amountAMin, \n        uint256 amountBMin, \n        address to, \n        uint256 deadline, \n        bool approveMax, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external virtual override returns (uint256 amountA, uint256 amountB) { \n        //\u8ba1\u7b97TokenA,TokenB\u7684CREATE2\u5730\u5740\uff0c\u800c\u65e0\u9700\u8fdb\u884c\u4efb\u4f55\u5916\u90e8\u8c03\u7528 \n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB); \n        //\u5982\u679c\u5168\u90e8\u6279\u51c6,value\u503c\u7b49\u4e8e\u6700\u5927uint256,\u5426\u5219\u7b49\u4e8e\u6d41\u52a8\u6027 \n        uint256 value = approveMax ? uint256(-1) : liquidity; \n        //\u8c03\u7528pair\u5408\u7ea6\u7684\u8bb8\u53ef\u65b9\u6cd5(\u8c03\u7528\u8d26\u6237,\u5f53\u524d\u5408\u7ea6\u5730\u5740,\u6570\u503c,\u6700\u540e\u671f\u9650,v,r,s) \n        ISwapPair(pair).permit( \n            msg.sender, \n            address(this), \n            value, \n            deadline, \n            v, \n            r, \n            s \n        ); \n        //(\u6570\u91cfA,\u6570\u91cfB) = \u79fb\u9664\u6d41\u52a8\u6027(tokenA\u5730\u5740,tokenB\u5730\u5740,\u6d41\u52a8\u6027\u6570\u91cf,\u6700\u5c0f\u6570\u91cfA,\u6700\u5c0f\u6570\u91cfB,to\u5730\u5740,\u6700\u540e\u671f\u9650) \n        (amountA, amountB) = removeLiquidity( \n            tokenA, \n            tokenB, \n            liquidity, \n            amountAMin, \n            amountBMin, \n            to, \n            deadline \n        ); \n    } \n \n    /** \n     * @dev \u5e26\u7b7e\u540d\u79fb\u9664ETH\u6d41\u52a8\u6027* \n     * @param token token\u5730\u5740 \n     * @param liquidity \u6d41\u52a8\u6027\u6570\u91cf \n     * @param amountTokenMin token\u6700\u5c0f\u6570\u91cf \n     * @param amountETHMin ETH\u6700\u5c0f\u6570\u91cf \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @param approveMax \u5168\u90e8\u6279\u51c6 \n     * @param v v \n     * @param r r \n     * @param s s \n     * @return amountToken   token\u6570\u91cf \n     * @return amountETH   ETH\u6570\u91cf \n     */ \n    function removeLiquidityETHWithPermit( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline, \n        bool approveMax, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) \n        external \n        virtual \n        override \n        returns (uint256 amountToken, uint256 amountETH) \n    { \n        //\u8ba1\u7b97Token,WETH\u7684CREATE2\u5730\u5740\uff0c\u800c\u65e0\u9700\u8fdb\u884c\u4efb\u4f55\u5916\u90e8\u8c03\u7528 \n        address pair = SwapLibrary.pairFor(factory, token, WETH); \n        //\u5982\u679c\u5168\u90e8\u6279\u51c6,value\u503c\u7b49\u4e8e\u6700\u5927uint256,\u5426\u5219\u7b49\u4e8e\u6d41\u52a8\u6027 \n        uint256 value = approveMax ? uint256(-1) : liquidity; \n        //\u8c03\u7528pair\u5408\u7ea6\u7684\u8bb8\u53ef\u65b9\u6cd5(\u8c03\u7528\u8d26\u6237,\u5f53\u524d\u5408\u7ea6\u5730\u5740,\u6570\u503c,\u6700\u540e\u671f\u9650,v,r,s) \n        ISwapPair(pair).permit( \n            msg.sender, \n            address(this), \n            value, \n            deadline, \n            v, \n            r, \n            s \n        ); \n        //(token\u6570\u91cf,ETH\u6570\u91cf) = \u79fb\u9664ETH\u6d41\u52a8\u6027(token\u5730\u5740,\u6d41\u52a8\u6027\u6570\u91cf,token\u6700\u5c0f\u6570\u91cf,ETH\u6700\u5c0f\u6570\u91cf,to\u5730\u5740,\u6700\u540e\u671f\u9650)\n        (amountToken, amountETH) = removeLiquidityETH( \n            token, \n            liquidity, \n            amountTokenMin, \n            amountETHMin, \n            to, \n            deadline \n        ); \n    } \n \n    /** \n     * @dev \u79fb\u9664\u6d41\u52a8\u6027\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e* \n     * @param token token\u5730\u5740 \n     * @param liquidity \u6d41\u52a8\u6027\u6570\u91cf \n     * @param amountTokenMin token\u6700\u5c0f\u6570\u91cf \n     * @param amountETHMin ETH\u6700\u5c0f\u6570\u91cf \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amountETH   ETH\u6570\u91cf \n     */ \n    function removeLiquidityETHSupportingFeeOnTransferTokens( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline \n    ) public virtual override ensure(deadline) returns (uint256 amountETH) { \n        //(,ETH\u6570\u91cf) = \u79fb\u9664\u6d41\u52a8\u6027(token\u5730\u5740,WETH\u5730\u5740,\u6d41\u52a8\u6027\u6570\u91cf,token\u6700\u5c0f\u6570\u91cf,ETH\u6700\u5c0f\u6570\u91cf,\u5f53\u524d\u5408\u7ea6\u5730\u5740,\u6700\u540e\u671f\u9650\n        (, amountETH) = removeLiquidity( \n            token, \n            WETH, \n            liquidity, \n            amountTokenMin, \n            amountETHMin, \n            address(this), \n            deadline \n        ); \n        //\u5c06\u5f53\u524d\u5408\u7ea6\u4e2d\u7684token\u6570\u91cf\u7684token\u53d1\u9001\u5230to\u5730\u5740 \n        TransferHelper.safeTransfer( \n            token, \n            to, \n            IERC20(token).balanceOf(address(this)) \n        ); \n        //\u4eceWETH\u53d6\u6b3eETH\u6570\u91cf\u7684\u4e3b\u5e01 \n        IWETH(WETH).withdraw(amountETH); \n        //\u5c06ETH\u6570\u91cf\u7684ETH\u53d1\u9001\u5230to\u5730\u5740 \n        TransferHelper.safeTransferETH(to, amountETH); \n    } \n \n    /** \n     * @dev \u5e26\u7b7e\u540d\u79fb\u9664\u6d41\u52a8\u6027,\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e* \n     * @param token token\u5730\u5740 \n     * @param liquidity \u6d41\u52a8\u6027\u6570\u91cf \n     * @param liquidity \u6d41\u52a8\u6027\u6570\u91cf \n     * @param amountTokenMin token\u6700\u5c0f\u6570\u91cf \n     * @param amountETHMin ETH\u6700\u5c0f\u6570\u91cf \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @param approveMax \u5168\u90e8\u6279\u51c6 \n     * @param v v \n     * @param r r \n     * @param s s \n     * @return amountETH   ETH\u6570\u91cf \n     */ \n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint256 liquidity, \n        uint256 amountTokenMin, \n        uint256 amountETHMin, \n        address to, \n        uint256 deadline, \n        bool approveMax, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external virtual override returns (uint256 amountETH) { \n        //\u8ba1\u7b97Token,WETH\u7684CREATE2\u5730\u5740\uff0c\u800c\u65e0\u9700\u8fdb\u884c\u4efb\u4f55\u5916\u90e8\u8c03\u7528 \n        address pair = SwapLibrary.pairFor(factory, token, WETH); \n        //\u5982\u679c\u5168\u90e8\u6279\u51c6,value\u503c\u7b49\u4e8e\u6700\u5927uint256,\u5426\u5219\u7b49\u4e8e\u6d41\u52a8\u6027 \n        uint256 value = approveMax ? uint256(-1) : liquidity; \n        //\u8c03\u7528pair\u5408\u7ea6\u7684\u8bb8\u53ef\u65b9\u6cd5(\u8c03\u7528\u8d26\u6237,\u5f53\u524d\u5408\u7ea6\u5730\u5740,\u6570\u503c,\u6700\u540e\u671f\u9650,v,r,s) \n        ISwapPair(pair).permit( \n            msg.sender, \n            address(this), \n            value, \n            deadline, \n            v, \n            r, \n            s \n        ); \n        //(,ETH\u6570\u91cf) = \u79fb\u9664\u6d41\u52a8\u6027\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e(token\u5730\u5740,\u6d41\u52a8\u6027\u6570\u91cf,Token\u6700\u5c0f\u6570\u91cf,ETH\u6700\u5c0f\u6570\u91cf,to\u5730\u5740,\u6700\u540e\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens( \n            token, \n            liquidity, \n            amountTokenMin, \n            amountETHMin, \n            to, \n            deadline \n        ); \n    } \n \n    // **** \u4ea4\u6362 **** \n    /** \n     * @dev \u79c1\u6709\u4ea4\u6362* \n     * @notice \u8981\u6c42\u521d\u59cb\u91d1\u989d\u5df2\u7ecf\u53d1\u9001\u5230\u7b2c\u4e00\u5bf9 \n     * @param amounts \u6570\u989d\u6570\u7ec4 \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param _to to\u5730\u5740 \n     */ \n    function _swap( \n        uint256[] memory amounts, \n        address[] memory path, \n        address _to \n    ) internal virtual { \n        //\u904d\u5386\u8def\u5f84\u6570\u7ec4 \n        for (uint256 i; i < path.length - 1; i++) { \n            //(\u8f93\u5165\u5730\u5740,\u8f93\u51fa\u5730\u5740) = (\u5f53\u524d\u5730\u5740,\u4e0b\u4e00\u4e2a\u5730\u5740) \n            (address input, address output) = (path[i], path[i + 1]); \n            //token0 = \u6392\u5e8f(\u8f93\u5165\u5730\u5740,\u8f93\u51fa\u5730\u5740) \n            (address token0, ) = SwapLibrary.sortTokens(input, output); \n            //\u8f93\u51fa\u6570\u91cf = \u6570\u989d\u6570\u7ec4\u4e0b\u4e00\u4e2a\u6570\u989d \n            uint256 amountOut = amounts[i + 1]; \n            //(\u8f93\u51fa\u6570\u989d0,\u8f93\u51fa\u6570\u989d1) = \u8f93\u5165\u5730\u5740==token0 ? (0,\u8f93\u51fa\u6570\u989d) : (\u8f93\u51fa\u6570\u989d,0) \n            (uint256 amount0Out, uint256 amount1Out) = \n                input == token0 \n                    ? (uint256(0), amountOut) \n                    : (amountOut, uint256(0)); \n            //to\u5730\u5740 = i<\u8def\u5f84\u957f\u5ea6-2 ? (\u8f93\u51fa\u5730\u5740,\u8def\u5f84\u4e0b\u4e0b\u4e2a\u5730\u5740)\u7684pair\u5408\u7ea6\u5730\u5740 : to\u5730\u5740 \n            address to = \n                i < path.length - 2 \n                    ? SwapLibrary.pairFor(factory, output, path[i + 2]) \n                    : _to; \n            //\u8c03\u7528(\u8f93\u5165\u5730\u5740,\u8f93\u51fa\u5730\u5740)\u7684pair\u5408\u7ea6\u5730\u5740\u7684\u4ea4\u6362\u65b9\u6cd5(\u8f93\u51fa\u6570\u989d0,\u8f93\u51fa\u6570\u989d1,to\u5730\u5740,0x00) \n            ISwapPair(SwapLibrary.pairFor(factory, input, output)).swap( \n                amount0Out, \n                amount1Out, \n                to, \n                new bytes(0) \n            ); \n        } \n    } \n \n    /** \n     * @dev \u6839\u636e\u7cbe\u786e\u7684token\u4ea4\u6362\u5c3d\u91cf\u591a\u7684token* \n     * @param amountIn \u7cbe\u786e\u8f93\u5165\u6570\u989d \n     * @param amountOutMin \u6700\u5c0f\u8f93\u51fa\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amounts  \u6570\u989d\u6570\u7ec4 \n     */ \n    function swapExactTokensForTokens( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) \n        external \n        virtual \n        override \n        ensure(deadline) \n        returns (uint256[] memory amounts) \n    { \n        //\u6570\u989d\u6570\u7ec4 \u2248 \u904d\u5386\u8def\u5f84\u6570\u7ec4( \n        //      (\u8f93\u5165\u6570\u989d * (1000-fee) * \u50a8\u5907\u91cfOut) / \n        //      (\u50a8\u5907\u91cfIn * 1000 + \u8f93\u5165\u6570\u989d * (1000-fee))) \n        amounts = SwapLibrary.getAmountsOut(factory, amountIn, path); \n        //\u786e\u8ba4\u6570\u989d\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u5143\u7d20>=\u6700\u5c0f\u8f93\u51fa\u6570\u989d \n        require( \n            amounts[amounts.length - 1] >= amountOutMin, \n            \"SwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\" \n        ); \n        //\u5c06\u6570\u91cf\u4e3a\u6570\u989d\u6570\u7ec4[0]\u7684\u8def\u5f84[0]\u7684token\u4ece\u8c03\u7528\u8005\u8d26\u6237\u53d1\u9001\u5230\u8def\u5f840,1\u7684pair\u5408\u7ea6 \n        TransferHelper.safeTransferFrom( \n            path[0], \n            msg.sender, \n            SwapLibrary.pairFor(factory, path[0], path[1]), \n            amounts[0] \n        ); \n        //\u79c1\u6709\u4ea4\u6362(\u6570\u989d\u6570\u7ec4,\u8def\u5f84\u6570\u7ec4,to\u5730\u5740) \n        _swap(amounts, path, to); \n    } \n \n    /** \n     * @dev \u4f7f\u7528\u5c3d\u91cf\u5c11\u7684token\u4ea4\u6362\u7cbe\u786e\u7684token* \n     * @param amountOut \u7cbe\u786e\u8f93\u51fa\u6570\u989d \n     * @param amountInMax \u6700\u5927\u8f93\u5165\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amounts  \u6570\u989d\u6570\u7ec4 \n     */ \n    function swapTokensForExactTokens( \n        uint256 amountOut, \n        uint256 amountInMax, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) \n        external \n        virtual \n        override \n        ensure(deadline) \n        returns (uint256[] memory amounts) \n    { \n        //\u6570\u989d\u6570\u7ec4 \u2248 \u904d\u5386\u8def\u5f84\u6570\u7ec4( \n        //      (\u50a8\u5907\u91cfIn * \u50a8\u5907\u91cfOut * 1000) / \n        //      (\u50a8\u5907\u91cfOut - \u8f93\u51fa\u6570\u989d * (1000-fee)) + 1) \n        amounts = SwapLibrary.getAmountsIn(factory, amountOut, path); \n        //\u786e\u8ba4\u6570\u989d\u6570\u7ec4\u7b2c\u4e00\u4e2a\u5143\u7d20<=\u6700\u5927\u8f93\u5165\u6570\u989d \n        require( \n            amounts[0] <= amountInMax, \n            \"SwapRouter: EXCESSIVE_INPUT_AMOUNT\" \n        ); \n        //\u5c06\u6570\u91cf\u4e3a\u6570\u989d\u6570\u7ec4[0]\u7684\u8def\u5f84[0]\u7684token\u4ece\u8c03\u7528\u8005\u8d26\u6237\u53d1\u9001\u5230\u8def\u5f840,1\u7684pair\u5408\u7ea6 \n        TransferHelper.safeTransferFrom( \n            path[0], \n            msg.sender, \n            SwapLibrary.pairFor(factory, path[0], path[1]), \n            amounts[0] \n        ); \n        //\u79c1\u6709\u4ea4\u6362(\u6570\u989d\u6570\u7ec4,\u8def\u5f84\u6570\u7ec4,to\u5730\u5740) \n        _swap(amounts, path, to); \n    } \n \n    /** \n     * @dev \u6839\u636e\u7cbe\u786e\u7684ETH\u4ea4\u6362\u5c3d\u91cf\u591a\u7684token* \n     * @param amountOutMin \u6700\u5c0f\u8f93\u51fa\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amounts  \u6570\u989d\u6570\u7ec4 \n     */ \n    function swapExactETHForTokens( \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) \n        external \n        payable \n        virtual \n        override \n        ensure(deadline) \n        returns (uint256[] memory amounts) \n    { \n        //\u786e\u8ba4\u8def\u5f84\u7b2c\u4e00\u4e2a\u5730\u5740\u4e3aWETH \n        require(path[0] == WETH, \"SwapRouter: INVALID_PATH\"); \n        //\u6570\u989d\u6570\u7ec4 \u2248 \u904d\u5386\u8def\u5f84\u6570\u7ec4( \n        //      (msg.value * (1000-fee) * \u50a8\u5907\u91cfOut) / \n        //      (\u50a8\u5907\u91cfIn * 1000 + msg.value * (1000-fee))) \n        amounts = SwapLibrary.getAmountsOut(factory, msg.value, path); \n        //\u786e\u8ba4\u6570\u989d\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u5143\u7d20>=\u6700\u5c0f\u8f93\u51fa\u6570\u989d \n        require( \n            amounts[amounts.length - 1] >= amountOutMin, \n            \"SwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\" \n        ); \n        //\u5c06\u6570\u989d\u6570\u7ec4[0]\u7684\u6570\u989d\u5b58\u6b3eETH\u5230ETH\u5408\u7ea6 \n        IWETH(WETH).deposit{value: amounts[0]}(); \n        //\u65ad\u8a00\u5c06\u6570\u989d\u6570\u7ec4[0]\u7684\u6570\u989d\u7684ETH\u53d1\u9001\u5230\u8def\u5f84(0,1)\u7684pair\u5408\u7ea6\u5730\u5740 \n        assert( \n            IWETH(WETH).transfer( \n                SwapLibrary.pairFor(factory, path[0], path[1]), \n                amounts[0] \n            ) \n        ); \n        //\u79c1\u6709\u4ea4\u6362(\u6570\u989d\u6570\u7ec4,\u8def\u5f84\u6570\u7ec4,to\u5730\u5740) \n        _swap(amounts, path, to); \n    } \n \n    /** \n     * @dev \u4f7f\u7528\u5c3d\u91cf\u5c11\u7684token\u4ea4\u6362\u7cbe\u786e\u7684ETH* \n     * @param amountOut \u7cbe\u786e\u8f93\u51fa\u6570\u989d \n     * @param amountInMax \u6700\u5927\u8f93\u5165\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amounts  \u6570\u989d\u6570\u7ec4 \n     */ \n    function swapTokensForExactETH( \n        uint256 amountOut, \n        uint256 amountInMax, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) \n        external \n        virtual \n        override \n        ensure(deadline) \n        returns (uint256[] memory amounts) \n    { \n        //\u786e\u8ba4\u8def\u5f84\u6700\u540e\u4e00\u4e2a\u5730\u5740\u4e3aWETH \n        require(path[path.length - 1] == WETH, \"SwapRouter: INVALID_PATH\"); \n        //\u6570\u989d\u6570\u7ec4 \u2248 \u904d\u5386\u8def\u5f84\u6570\u7ec4( \n        //      (\u50a8\u5907\u91cfIn * \u50a8\u5907\u91cfOut * 1000) / \n        //      (\u50a8\u5907\u91cfOut - \u8f93\u51fa\u6570\u989d * (1000-fee)) + 1) \n        amounts = SwapLibrary.getAmountsIn(factory, amountOut, path); \n        //\u786e\u8ba4\u6570\u989d\u6570\u7ec4\u7b2c\u4e00\u4e2a\u5143\u7d20<=\u6700\u5927\u8f93\u5165\u6570\u989d \n        require( \n            amounts[0] <= amountInMax, \n            \"SwapRouter: EXCESSIVE_INPUT_AMOUNT\" \n        ); \n        //\u5c06\u6570\u91cf\u4e3a\u6570\u989d\u6570\u7ec4[0]\u7684\u8def\u5f84[0]\u7684token\u4ece\u8c03\u7528\u8005\u8d26\u6237\u53d1\u9001\u5230\u8def\u5f840,1\u7684pair\u5408\u7ea6 \n        TransferHelper.safeTransferFrom( \n            path[0], \n            msg.sender, \n            SwapLibrary.pairFor(factory, path[0], path[1]), \n            amounts[0] \n        ); \n        //\u79c1\u6709\u4ea4\u6362(\u6570\u989d\u6570\u7ec4,\u8def\u5f84\u6570\u7ec4,\u5f53\u524d\u5408\u7ea6\u5730\u5740) \n        _swap(amounts, path, address(this)); \n        //\u4eceETH\u5408\u7ea6\u63d0\u6b3e\u6570\u989d\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u6570\u503c\u7684ETH \n        IWETH(WETH).withdraw(amounts[amounts.length - 1]); \n        //\u5c06\u6570\u989d\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u6570\u503c\u7684ETH\u53d1\u9001\u5230to\u5730\u5740 \n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); \n    } \n \n    /** \n     * @dev \u6839\u636e\u7cbe\u786e\u7684token\u4ea4\u6362\u5c3d\u91cf\u591a\u7684ETH* \n     * @param amountIn \u7cbe\u786e\u8f93\u5165\u6570\u989d \n     * @param amountOutMin \u6700\u5c0f\u8f93\u51fa\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amounts  \u6570\u989d\u6570\u7ec4 \n     */ \n    function swapExactTokensForETH( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) \n        external \n        virtual \n        override \n        ensure(deadline) \n        returns (uint256[] memory amounts) \n    { \n        //\u786e\u8ba4\u8def\u5f84\u6700\u540e\u4e00\u4e2a\u5730\u5740\u4e3aWETH \n        require(path[path.length - 1] == WETH, \"SwapRouter: INVALID_PATH\"); \n        //\u6570\u989d\u6570\u7ec4 \u2248 \u904d\u5386\u8def\u5f84\u6570\u7ec4( \n        //      (\u8f93\u5165\u6570\u989d * (1000-fee) * \u50a8\u5907\u91cfOut) / \n        //      (\u50a8\u5907\u91cfIn * 1000 + \u8f93\u5165\u6570\u989d * (1000-fee)))) \n        amounts = SwapLibrary.getAmountsOut(factory, amountIn, path); \n        //\u786e\u8ba4\u6570\u989d\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u5143\u7d20>=\u6700\u5c0f\u8f93\u51fa\u6570\u989d \n        require( \n            amounts[amounts.length - 1] >= amountOutMin, \n            \"SwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\" \n        ); \n        //\u5c06\u6570\u91cf\u4e3a\u6570\u989d\u6570\u7ec4[0]\u7684\u8def\u5f84[0]\u7684token\u4ece\u8c03\u7528\u8005\u8d26\u6237\u53d1\u9001\u5230\u8def\u5f840,1\u7684pair\u5408\u7ea6 \n        TransferHelper.safeTransferFrom( \n            path[0], \n            msg.sender, \n            SwapLibrary.pairFor(factory, path[0], path[1]), \n            amounts[0] \n        ); \n        //\u79c1\u6709\u4ea4\u6362(\u6570\u989d\u6570\u7ec4,\u8def\u5f84\u6570\u7ec4,\u5f53\u524d\u5408\u7ea6\u5730\u5740) \n        _swap(amounts, path, address(this)); \n        //\u4eceWETH\u5408\u7ea6\u63d0\u6b3e\u6570\u989d\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u6570\u503c\u7684ETH \n        IWETH(WETH).withdraw(amounts[amounts.length - 1]); \n        //\u5c06\u6570\u989d\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u6570\u503c\u7684ETH\u53d1\u9001\u5230to\u5730\u5740 \n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); \n    } \n \n    /** \n     * @dev \u4f7f\u7528\u5c3d\u91cf\u5c11\u7684ETH\u4ea4\u6362\u7cbe\u786e\u7684token* \n     * @param amountOut \u7cbe\u786e\u8f93\u51fa\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     * @return amounts  \u6570\u989d\u6570\u7ec4 \n     */ \n    function swapETHForExactTokens( \n        uint256 amountOut, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) \n        external \n        payable \n        virtual \n        override \n        ensure(deadline) \n        returns (uint256[] memory amounts) \n    { \n        //\u786e\u8ba4\u8def\u5f84\u7b2c\u4e00\u4e2a\u5730\u5740\u4e3aWETH \n        require(path[0] == WETH, \"SwapRouter: INVALID_PATH\"); \n        //\u6570\u989d\u6570\u7ec4 \u2248 \u904d\u5386\u8def\u5f84\u6570\u7ec4( \n        //      (\u50a8\u5907\u91cfIn * \u50a8\u5907\u91cfOut * 1000) / \n        //      (\u50a8\u5907\u91cfOut - \u8f93\u51fa\u6570\u989d * (1000-fee)) + 1) \n        amounts = SwapLibrary.getAmountsIn(factory, amountOut, path); \n        //\u786e\u8ba4\u6570\u989d\u6570\u7ec4\u7b2c\u4e00\u4e2a\u5143\u7d20<=msg.value \n        require(amounts[0] <= msg.value, \"SwapRouter: EXCESSIVE_INPUT_AMOUNT\"); \n        //\u5c06\u6570\u989d\u6570\u7ec4[0]\u7684\u6570\u989d\u5b58\u6b3eETH\u5230WETH\u5408\u7ea6 \n        IWETH(WETH).deposit{value: amounts[0]}(); \n        //\u65ad\u8a00\u5c06\u6570\u989d\u6570\u7ec4[0]\u7684\u6570\u989d\u7684WETH\u53d1\u9001\u5230\u8def\u5f84(0,1)\u7684pair\u5408\u7ea6\u5730\u5740 \n        assert( \n            IWETH(WETH).transfer( \n                SwapLibrary.pairFor(factory, path[0], path[1]), \n                amounts[0] \n            ) \n        ); \n        //\u79c1\u6709\u4ea4\u6362(\u6570\u989d\u6570\u7ec4,\u8def\u5f84\u6570\u7ec4,to\u5730\u5740) \n        _swap(amounts, path, to); \n        //\u5982\u679c`\u6536\u5230\u7684\u4e3b\u5e01\u6570\u91cf`>`\u6570\u989d\u6570\u7ec4[0]` \u5219\u8fd4\u8fd8`\u6536\u5230\u7684\u4e3b\u5e01\u6570\u91cf`-`\u6570\u989d\u6570\u7ec4[0]` \n        if (msg.value > amounts[0]) \n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); \n    } \n \n    // **** \u4ea4\u6362 (\u652f\u6301\u6536\u53d6\u8f6c\u5e10\u7a0e\u7684Token) **** \n    // requires the initial amount to have already been sent to the first pair \n    /** \n     * @dev \u79c1\u6709\u4ea4\u6362\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e* \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param _to to\u5730\u5740 \n     */ \n    function _swapSupportingFeeOnTransferTokens( \n        address[] memory path, \n        address _to \n    ) internal virtual { \n        //\u904d\u5386\u8def\u5f84\u6570\u7ec4 \n        for (uint256 i; i < path.length - 1; i++) { \n            //(\u8f93\u5165\u5730\u5740,\u8f93\u51fa\u5730\u5740) = (\u5f53\u524d\u5730\u5740,\u4e0b\u4e00\u4e2a\u5730\u5740) \n            (address input, address output) = (path[i], path[i + 1]); \n            // \u6839\u636e\u8f93\u5165\u5730\u5740,\u8f93\u51fa\u5730\u5740\u627e\u5230\u914d\u5bf9\u5408\u7ea6 \n            ISwapPair pair = \n                ISwapPair(SwapLibrary.pairFor(factory, input, output)); \n            //token0 = \u6392\u5e8f(\u8f93\u5165\u5730\u5740,\u8f93\u51fa\u5730\u5740) \n            (address token0, ) = SwapLibrary.sortTokens(input, output); \n            // \u5b9a\u4e49\u4e00\u4e9b\u6570\u989d\u53d8\u91cf \n            uint256 amountInput; \n            uint256 amountOutput; \n            { \n                //\u907f\u514d\u5806\u6808\u592a\u6df1\u7684\u9519\u8bef \n                //\u83b7\u53d6\u914d\u5bf9\u7684\u4ea4\u6613\u624b\u7eed\u8d39 \n                uint8 fee = pair.fee(); \n                //\u83b7\u53d6\u914d\u5bf9\u5408\u7ea6\u7684\u50a8\u5907\u91cf0,\u50a8\u5907\u91cf1 \n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves(); \n                // \u6392\u5e8f\u8f93\u5165\u50a8\u5907\u91cf\u548c\u8f93\u51fa\u50a8\u5907\u91cf \n                (uint256 reserveInput, uint256 reserveOutput) = \n                    input == token0 \n                        ? (reserve0, reserve1) \n                        : (reserve1, reserve0); \n                // \u50a8\u5907\u91cf0,1,\u914d\u5bf9\u5408\u7ea6\u4e2d\u7684\u4f59\u989d-\u50a8\u5907\u91cf \n                amountInput = IERC20(input).balanceOf(address(pair)).sub( \n                    reserveInput \n                ); \n                //\u6839\u636e\u8f93\u5165\u6570\u989d,\u8f93\u5165\u50a8\u5907\u91cf,\u8f93\u51fa\u50a8\u5907\u91cf,\u4ea4\u6613\u624b\u7eed\u8d39\u8ba1\u7b97\u8f93\u51fa\u6570\u989d \n                amountOutput = SwapLibrary.getAmountOut( \n                    amountInput, \n                    reserveInput, \n                    reserveOutput, \n                    fee \n                ); \n            } \n            // // \u6392\u5e8f\u8f93\u51fa\u6570\u989d0,\u8f93\u51fa\u6570\u989d1 \n            (uint256 amount0Out, uint256 amount1Out) = \n                input == token0 \n                    ? (uint256(0), amountOutput) \n                    : (amountOutput, uint256(0)); \n            //to\u5730\u5740 = i<\u8def\u5f84\u957f\u5ea6-2 ? (\u8f93\u51fa\u5730\u5740,\u8def\u5f84\u4e0b\u4e0b\u4e2a\u5730\u5740)\u7684pair\u5408\u7ea6\u5730\u5740 : to\u5730\u5740 \n            address to = \n                i < path.length - 2 \n                    ? SwapLibrary.pairFor(factory, output, path[i + 2]) \n                    : _to; \n            //\u8c03\u7528pair\u5408\u7ea6\u7684\u4ea4\u6362\u65b9\u6cd5(\u8f93\u51fa\u6570\u989d0,\u8f93\u51fa\u6570\u989d1,to\u5730\u5740,0x00) \n            pair.swap(amount0Out, amount1Out, to, new bytes(0)); \n        } \n    } \n \n    /** \n     * @dev \u6839\u636e\u7cbe\u786e\u7684token\u4ea4\u6362\u5c3d\u91cf\u591a\u7684token,\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e* \n     * @param amountIn \u7cbe\u786e\u8f93\u5165\u6570\u989d \n     * @param amountOutMin \u6700\u5c0f\u8f93\u51fa\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     */ \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external virtual override ensure(deadline) { \n        //\u5c06\u6570\u91cf\u4e3a\u6570\u989d\u6570\u7ec4[0]\u7684\u8def\u5f84[0]\u7684token\u4ece\u8c03\u7528\u8005\u8d26\u6237\u53d1\u9001\u5230\u8def\u5f840,1\u7684pair\u5408\u7ea6 \n        TransferHelper.safeTransferFrom( \n            path[0], \n            msg.sender, \n            SwapLibrary.pairFor(factory, path[0], path[1]), \n            amountIn \n        ); \n        // \u8bb0\u5f55to\u5730\u5740\u5728\u5730\u5740\u8def\u5f84\u6700\u540e\u4e00\u4e2atoken\u4e2d\u7684\u4f59\u989d \n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to); \n        // \u8c03\u7528\u79c1\u6709\u4ea4\u6362\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e\u65b9\u6cd5 \n        _swapSupportingFeeOnTransferTokens(path, to); \n        // \u786e\u8ba4to\u5730\u5740\u6536\u5230\u7684\u5730\u5740\u8def\u5f84\u4e2d\u6700\u540e\u4e00\u4e2atoken\u6570\u91cf\u5927\u4e8e\u6700\u5c0f\u8f93\u51fa\u6570\u91cf \n        require( \n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= \n                amountOutMin, \n            \"SwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\" \n        ); \n    } \n \n    /** \n     * @dev \u6839\u636e\u7cbe\u786e\u7684ETH\u4ea4\u6362\u5c3d\u91cf\u591a\u7684token,\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e* \n     * @param amountOutMin \u6700\u5c0f\u8f93\u51fa\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     */ \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external payable virtual override ensure(deadline) { \n        //\u786e\u8ba4\u8def\u5f84\u7b2c\u4e00\u4e2a\u5730\u5740\u4e3aWETH \n        require(path[0] == WETH, \"SwapRouter: INVALID_PATH\"); \n        //\u8f93\u5165\u6570\u91cf=\u5408\u7ea6\u6536\u5230\u7684\u4e3b\u5e01\u6570\u91cf \n        uint256 amountIn = msg.value; \n        //\u5411WETH\u5408\u7ea6\u5b58\u6b3eETH \n        IWETH(WETH).deposit{value: amountIn}(); \n        //\u65ad\u8a00\u5c06WETH\u53d1\u9001\u5230\u4e86\u5730\u5740\u8def\u5f840,1\u7ec4\u6210\u7684\u914d\u5bf9\u5408\u7ea6\u4e2d \n        assert( \n            IWETH(WETH).transfer( \n                SwapLibrary.pairFor(factory, path[0], path[1]), \n                amountIn \n            ) \n        ); \n        // \u8bb0\u5f55to\u5730\u5740\u5728\u5730\u5740\u8def\u5f84\u6700\u540e\u4e00\u4e2atoken\u4e2d\u7684\u4f59\u989d \n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to); \n        // \u8c03\u7528\u79c1\u6709\u4ea4\u6362\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e\u65b9\u6cd5 \n        _swapSupportingFeeOnTransferTokens(path, to); \n        // \u786e\u8ba4to\u5730\u5740\u6536\u5230\u7684\u5730\u5740\u8def\u5f84\u4e2d\u6700\u540e\u4e00\u4e2atoken\u6570\u91cf\u5927\u4e8e\u6700\u5c0f\u8f93\u51fa\u6570\u91cf \n        require( \n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= \n                amountOutMin, \n            \"SwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\" \n        ); \n    } \n \n    /** \n     * @dev \u6839\u636e\u7cbe\u786e\u7684token\u4ea4\u6362\u5c3d\u91cf\u591a\u7684ETH,\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e* \n     * @param amountIn \u7cbe\u786e\u8f93\u5165\u6570\u989d \n     * @param amountOutMin \u6700\u5c0f\u8f93\u51fa\u6570\u989d \n     * @param path \u8def\u5f84\u6570\u7ec4 \n     * @param to to\u5730\u5740 \n     * @param deadline \u6700\u540e\u671f\u9650 \n     */ \n    function swapExactTokensForETHSupportingFeeOnTransferTokens( \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address to, \n        uint256 deadline \n    ) external virtual override ensure(deadline) { \n        //\u786e\u8ba4\u8def\u5f84\u6700\u540e\u4e00\u4e2a\u5730\u5740\u4e3aWETH \n        require(path[path.length - 1] == WETH, \"SwapRouter: INVALID_PATH\"); \n        //\u5c06\u5730\u5740\u8def\u5f840\u7684Token\u53d1\u9001\u5230\u5730\u5740\u8def\u5f840,1\u7ec4\u6210\u7684\u914d\u5bf9\u5408\u7ea6 \n        TransferHelper.safeTransferFrom( \n            path[0], \n            msg.sender, \n            SwapLibrary.pairFor(factory, path[0], path[1]), \n            amountIn \n        ); \n        //\u8c03\u7528\u79c1\u6709\u4ea4\u6362\u652f\u6301Token\u6536\u8f6c\u5e10\u7a0e\u65b9\u6cd5 \n        _swapSupportingFeeOnTransferTokens(path, address(this)); \n        //\u8f93\u51fa\u91d1\u989d=\u5f53\u524d\u5408\u7ea6\u6536\u5230\u7684WETH\u6570\u91cf \n        uint256 amountOut = IERC20(WETH).balanceOf(address(this)); \n        //\u786e\u8ba4\u8f93\u51fa\u91d1\u989d\u5927\u4e8e\u6700\u5c0f\u8f93\u51fa\u6570\u989d \n        require( \n            amountOut >= amountOutMin, \n            \"SwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\" \n        ); \n        //\u5411WETH\u5408\u7ea6\u53d6\u6b3e \n        IWETH(WETH).withdraw(amountOut); \n        //\u5c06ETH\u53d1\u9001\u5230to\u5730\u5740 \n        TransferHelper.safeTransferETH(to, amountOut); \n    } \n \n    // **** LIBRARY FUNCTIONS **** \n    function quote( \n        uint256 amountA, \n        uint256 reserveA, \n        uint256 reserveB \n    ) public pure virtual override returns (uint256 amountB) { \n        return SwapLibrary.quote(amountA, reserveA, reserveB); \n    } \n \n    function getAmountOut( \n        uint256 amountIn, \n        uint256 reserveIn, \n        uint256 reserveOut, \n        uint8 fee \n    ) public pure virtual override returns (uint256 amountOut) { \n        return SwapLibrary.getAmountOut(amountIn, reserveIn, reserveOut, fee); \n    } \n \n    function getAmountIn( \n        uint256 amountOut, \n        uint256 reserveIn, \n        uint256 reserveOut, \n        uint8 fee \n    ) public pure virtual override returns (uint256 amountIn) { \n        return SwapLibrary.getAmountIn(amountOut, reserveIn, reserveOut, fee); \n    } \n \n    function getAmountsOut(uint256 amountIn, address[] memory path) \n        public \n        view \n        virtual \n        override \n        returns (uint256[] memory amounts) \n    { \n        return SwapLibrary.getAmountsOut(factory, amountIn, path); \n    } \n \n    function getAmountsIn(uint256 amountOut, address[] memory path) \n        public \n        view \n        virtual \n        override \n        returns (uint256[] memory amounts) \n    { \n        return SwapLibrary.getAmountsIn(factory, amountOut, path); \n    } \n} \n \nAnalysis of audit results\nRe-Entrancy\n"
        ]
    },
    {
        "PdfName": "Goldfinger Token & Vesting_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.10; \n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \n \ncontract GFTToken is ERC20, Ownable { \n    constructor( \n        string memory name, \n        string memory symbol \n    ) payable ERC20(name, symbol) {} \n \n    function mint(address account, uint256 amount) public onlyOwner { \n        require(totalSupply() + amount <= 1100000000 * 10 ** decimals()); \n        _mint(account, amount); \n    } \n \n    function burn(uint256 amount) public { \n        _burn(msg.sender, amount); \n    } \n} \nGFTTokenVesting.sol\n \n",
            "pragma solidity 0.8.10; \n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \n \ncontract GFTTokenVesting is Ownable { \n  using SafeERC20 for IERC20; \n \n  event Released(address beneficiary, uint256 amount); \n \n  IERC20 public token; \n  uint256 public cliff; \n  uint256 public start; \n  uint256 public duration; \n  uint256 public period; \n  uint256 public percent; \n \n  mapping (address => uint256) public shares; \n  mapping (address => uint256) public lastReleaseDate; \n  mapping (address => uint256) public releasedAmount; \n \n  uint256 released = 0; \n  uint256 BP = 10000; \n \n  address[] public beneficiaries; \n \n  modifier onlyBeneficiaries { \n    require(msg.sender == owner() || shares[msg.sender] > 0, \"You cannot release tokens!\"); \n    _; \n  } \n \n  constructor( \n    IERC20 _token, \n    uint256 _start, \n    uint256 _cliff, \n    uint256 _duration, \n    uint256 _period, \n    uint256 _percent \n  ) { \n    require(_cliff <= _duration, \"Cliff has to be lower or equal to duration\"); \n    token = _token; \n    duration = _duration; \n    cliff = _start + _cliff; \n    start = _start; \n    period = _period; \n    percent = _percent; \n  } \n \n  function addBeneficiaryes(address[] memory _beneficiaryes, uint256[] memory _sharesAmounts) onlyOwn\n    require(_beneficiaryes.length == _sharesAmounts.length); \n \n    for (uint i = 0; i <_beneficiaryes.length; i++) { \n      addBeneficiary(_beneficiaryes[i], _sharesAmounts[i]); \n    } \n \n    require(totalShares() == 10000, \"Invalid shares amount\"); \n  } \n \n  function addBeneficiary(address _beneficiary, uint256 _sharesAmount) onlyOwner public { \n    require(block.timestamp < cliff); \n    require(_beneficiary != address(0), \"The beneficiary's address cannot be 0\"); \n    require(_sharesAmount > 0, \"Shares amount has to be greater than 0\"); \n \n    if (shares[_beneficiary] == 0) { \n      beneficiaries.push(_beneficiary); \n    } \n \n    lastReleaseDate[_beneficiary] = cliff; \n    shares[_beneficiary] = shares[_beneficiary] + _sharesAmount; \n  } \n \n  function claimTokens() onlyBeneficiaries public { \n    uint256 currentBalance = token.balanceOf(address(this)); \n    uint256 totalBalance = currentBalance + released; \n \n    require(releasedAmount[msg.sender] < calculateShares(totalBalance, msg.sender), \"User already rel\n \n    uint256 unreleased = releasableAmount(); \n \n"
        ]
    },
    {
        "PdfName": "Hound Token_audit_en.pdf",
        "Code": [
            "pragma solidity ^0.8.4; \n \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes calldata) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \ninterface IUniswapV2Router01 { \n    function factory() external pure returns (address); \n    function WETH() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityETH( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityETH( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountETH); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityETHWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountETH); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadl\n    external \n    payable \n    returns (uint[] memory amounts); \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address \n    external \n    returns (uint[] memory amounts); \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address \n    external \n    returns (uint[] memory amounts); \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline\n    external \n    payable \n    returns (uint[] memory amounts); \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n} \n \ninterface IUniswapV2Router02 is IUniswapV2Router01 { \n    function removeLiquidityETHSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountETH); \n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountETH); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForETHSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n} \n \ninterface IUniswapV2Factory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n} \n \ninterface IUniswapV2Pair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n    function factory() external view returns (address); \n    function token0() external view returns (address); \n    function token1() external view returns (address); \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function price0CumulativeLast() external view returns (uint); \n    function price1CumulativeLast() external view returns (uint); \n    function kLast() external view returns (uint); \n \n \n    function burn(address to) external returns (uint amount0, uint amount1); \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n    function skim(address to) external; \n    function sync() external; \n \n    function initialize(address, address) external; \n} \n \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the symbol of the token. \n     */ \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the decimals places of the token. \n     */ \n    function decimals() external view returns (uint8); \n} \n \ncontract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    constructor () { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \nlibrary SafeMath { \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n} \n \ncontract ERC20 is Context, IERC20, IERC20Metadata { \n    using SafeMath for uint256; \n \n    mapping(address => uint256) private _balances; \n \n    mapping(address => mapping(address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}. \n     * \n     * The default value of {decimals} is 18. To select a different value for \n     * {decimals} you should overload it. \n     * \n     * All two of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    constructor(string memory name_, string memory symbol_) { \n        _name = name_; \n        _symbol = symbol_; \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public view virtual override returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public view virtual override returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a balance of `505` tokens should \n     * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a value of 18, imitating the relationship between \n     * Ether and Wei. This is the value {ERC20} uses, unless this function is \n     * overridden; \n     * \n     * NOTE: This information is only used for _display_ purposes: it in \n     * no way affects any of the arithmetic of the contract, including \n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */ \n    function decimals() public view virtual override returns (uint8) { \n        return 18; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */ \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */ \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function allowance(address owner, address spender) public view virtual override returns (uint256)\n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {ERC20}. \n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) public virtual override returns (bool) { \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the total supply. \n     * \n     * Emits a {Transfer} event with `from` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     */ \n    function _cast(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens. \n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve( \n        address owner, \n        address spender, \n        uint256 amount \n    ) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * will be to transferred to `to`. \n     * - when `from` is zero, `amount` tokens will be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n     * - `from` and `to` are never both zero. \n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _beforeTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual {} \n} \n \ncontract TokenDividendTracker is Ownable { \n    using SafeMath for uint256; \n \n    address[] public shareholders; \n    uint256 public currentIndex; \n    mapping(address => bool) private _updated; \n    mapping (address => uint256) public shareholderIndexes; \n \n    address public  uniswapV2Pair; \n    address public lpRewardToken; \n    // \u4e0a\u6b21\u5206\u7ea2\u65f6\u95f4 \n    uint256 public LPRewardLastSendTime; \n \n    constructor(address uniswapV2Pair_, address lpRewardToken_){ \n        uniswapV2Pair = uniswapV2Pair_; \n        lpRewardToken = lpRewardToken_; \n    } \n \n    function resetLPRewardLastSendTime() public onlyOwner { \n        LPRewardLastSendTime = 0; \n    } \n \n    // LP\u5206\u7ea2\u53d1\u653e \n    function process(uint256 gas) external onlyOwner { \n        uint256 shareholderCount = shareholders.length; \n \n        if(shareholderCount == 0) return; \n        uint256 nowbanance = IERC20(lpRewardToken).balanceOf(address(this)); \n \n        uint256 gasUsed = 0; \n        uint256 gasLeft = gasleft(); \n \n        uint256 iterations = 0; \n \n        while(gasUsed < gas && iterations < shareholderCount) { \n            if(currentIndex >= shareholderCount){ \n                currentIndex = 0; \n                LPRewardLastSendTime = block.timestamp; \n                return; \n            } \n \n            uint256 amount = nowbanance.mul(IERC20(uniswapV2Pair).balanceOf(shareholders[currentIndex\n            if( amount == 0) { \n                currentIndex++; \n                iterations++; \n                return; \n            } \n            if(IERC20(lpRewardToken).balanceOf(address(this))  < amount ) return; \n            IERC20(lpRewardToken).transfer(shareholders[currentIndex], amount); \n            gasUsed = gasUsed.add(gasLeft.sub(gasleft())); \n            gasLeft = gasleft(); \n            currentIndex++; \n            iterations++; \n        } \n    } \n    // \u6839\u636e\u6761\u4ef6\u81ea\u52a8\u5c06\u4ea4\u6613\u8d26\u6237\u52a0\u5165\u3001\u9000\u51fa\u6d41\u52a8\u6027\u5206\u7ea2 \n    function setShare(address shareholder) external onlyOwner { \n        if(_updated[shareholder] ){ \n            if(IERC20(uniswapV2Pair).balanceOf(shareholder) == 0) quitShare(shareholder); \n            return; \n        } \n        if(IERC20(uniswapV2Pair).balanceOf(shareholder) == 0) return; \n        addShareholder(shareholder); \n        _updated[shareholder] = true; \n \n    } \n    function quitShare(address shareholder) internal { \n        removeShareholder(shareholder); \n        _updated[shareholder] = false; \n    } \n \n    function addShareholder(address shareholder) internal { \n        shareholderIndexes[shareholder] = shareholders.length; \n        shareholders.push(shareholder); \n    } \n \n    function removeShareholder(address shareholder) internal { \n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1]; \n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder]; \n        shareholders.pop(); \n    } \n \n} \n \n \ncontract Hound is ERC20, Ownable { \n    using SafeMath for uint256; \n \n    IUniswapV2Router02 public uniswapV2Router; \n    address public  uniswapV2Pair; \n    bool private swapping; \n \n    uint256 public swapTokensAtAmount; \n \n    uint256 public deadFee = 3; \n    uint256 public liquidityFee = 4; \n    uint256 public marketingFee = 1; \n    uint256 public foundationFee = 1; \n    uint256 public lpRewardFee = 5; \n    address public lpRewardToken = 0x55d398326f99059fF775485246999027B3197955; \n \n    uint256 public AmountLiquidityFee; \n    uint256 public AmountLpRewardFee; \n \n    address public marketingWalletAddress; \n    address public foundationWalletAddress; \n    address public liquidityReceiveAddress; \n    address public deadWallet = 0x000000000000000000000000000000000000dEaD; \n \n \n    mapping (address => bool) private _isExcludedFromFees; \n \n    TokenDividendTracker public dividendTracker; \n \n    address private fromAddress; \n    address private toAddress; \n    mapping (address => bool) isDividendExempt; \n \n \n    uint256 public minPeriod = 86400; \n \n    uint256 distributorGas = 200000; \n \n    event ExcludeFromFees(address indexed account, bool isExcluded); \n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded); \n \n    event SwapAndLiquify( \n        uint256 tokensSwapped, \n        uint256 ethReceived, \n        uint256 tokensIntoLiqudity \n    ); \n \n \n    constructor( \n        string memory name_, \n        string memory symbol_, \n        uint256 totalSupply_, \n        address marketingWalletAddr_, \n        address foundationWalletAddress_, \n        address liquidityReceiveAddress_ \n    ) payable ERC20(name_, symbol_)  { \n        uint256 totalSupply = totalSupply_ * (10**18); \n        swapTokensAtAmount = totalSupply.mul(2).div(10**6); // 0.002%; \n \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E2\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()) \n        .createPair(address(this), _uniswapV2Router.WETH()); \n \n        uniswapV2Router = _uniswapV2Router; \n        uniswapV2Pair = _uniswapV2Pair; \n \n        marketingWalletAddress = marketingWalletAddr_; \n        foundationWalletAddress = foundationWalletAddress_; \n        liquidityReceiveAddress = liquidityReceiveAddress_; \n        dividendTracker = new TokenDividendTracker(uniswapV2Pair, lpRewardToken); \n \n \n        excludeFromFees(owner(), true); \n        excludeFromFees(marketingWalletAddress, true); \n        excludeFromFees(foundationWalletAddress, true); \n        excludeFromFees(address(this), true); \n        excludeFromFees(address(dividendTracker), true); \n \n        isDividendExempt[address(this)] = true; \n        isDividendExempt[address(0)] = true; \n        isDividendExempt[address(dividendTracker)] = true; \n \n        _cast(owner(), totalSupply); \n    } \n \n    receive() external payable {} \n \n \n    function excludeFromFees(address account, bool excluded) public onlyOwner { \n        if(_isExcludedFromFees[account] != excluded){ \n            _isExcludedFromFees[account] = excluded; \n            emit ExcludeFromFees(account, excluded); \n        } \n    } \n \n \n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyO\n        for(uint256 i = 0; i < accounts.length; i++) { \n            _isExcludedFromFees[accounts[i]] = excluded; \n        } \n        emit ExcludeMultipleAccountsFromFees(accounts, excluded); \n    } \n \n \n    function setMarketingWallet(address payable wallet) external onlyOwner{ \n        marketingWalletAddress = wallet; \n    } \n \n \n    function setFoundationWallet(address addr) public onlyOwner { \n        foundationWalletAddress = addr; \n    } \n \n \n    function isExcludedFromFees(address account) public view returns(bool) { \n        return _isExcludedFromFees[account]; \n    } \n \n \n    function setSwapTokensAtAmount(uint256 amount) public onlyOwner { \n        swapTokensAtAmount = amount; \n    } \n \n \n    function setLiquidityFee(uint256 val) public onlyOwner { \n        liquidityFee = val; \n    } \n \n \n    function setMarketingFee(uint256 val) public onlyOwner { \n        marketingFee = val; \n    } \n \n \n    function setFoundationFee(uint256 val) public onlyOwner { \n        foundationFee = val; \n    } \n \n \n    function setDeadFee(uint256 val) public onlyOwner { \n        deadFee = val; \n    } \n \n \n    function setLpRewardFee(uint256 val) public onlyOwner { \n        lpRewardFee = val; \n    } \n \n \n    function setMinPeriod(uint256 number) public onlyOwner { \n        minPeriod = number; \n    } \n \n \n    function setLiquidityReceiveAddress(address val) public onlyOwner { \n        liquidityReceiveAddress = val; \n    } \n \n \n    function resetLPRewardLastSendTime() public onlyOwner { \n        dividendTracker.resetLPRewardLastSendTime(); \n    } \n \n \n    function updateDistributorGas(uint256 newValue) public onlyOwner { \n        require(newValue >= 100000 && newValue <= 500000, \"distributorGas must be between 200,000 and \n        require(newValue != distributorGas, \"Cannot update distributorGas to same value\"); \n        distributorGas = newValue; \n    } \n \n    function _transfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal override { \n        require(from != address(0), \"ERC20: transfer from the zero address\"); \n        require(to != address(0), \"ERC20: transfer to the zero address\"); \n        if(amount == 0) { super._transfer(from, to, 0); return;} \n \n        uint256 contractTokenBalance = balanceOf(address(this)); \n        bool canSwap = contractTokenBalance >= swapTokensAtAmount; \n        if( canSwap && \n            !swapping && \n            from != uniswapV2Pair && \n            from != owner() && \n            to != owner() \n        ) { \n            swapping = true; \n            if(AmountLiquidityFee > 0){ \n                swapAndLiquify(AmountLiquidityFee); \n                AmountLiquidityFee = 0; \n            } \n            if(AmountLpRewardFee > 0){ \n                swapLPRewardToken(AmountLpRewardFee); \n                AmountLpRewardFee = 0; \n            } \n            swapping = false; \n        } \n \n        bool takeFee = !swapping; \n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) { \n            takeFee = false; \n        } \n \n        if(takeFee) { \n            if(from != uniswapV2Pair){ \n                uint256 minHolderAmount = balanceOf(from).mul(90).div(100); \n                if(amount > minHolderAmount){ \n                    amount = minHolderAmount; \n                } \n            } \n            amount =  takeAllFee(from, amount); \n \n        } \n        super._transfer(from, to, amount); \n \n        if(fromAddress == address(0) )fromAddress = from; \n        if(toAddress == address(0) )toAddress = to; \n        if(!isDividendExempt[fromAddress] && fromAddress != uniswapV2Pair )   try dividendTracker.set\n        if(!isDividendExempt[toAddress] && toAddress != uniswapV2Pair ) try dividendTracker.setShare(\n        fromAddress = from; \n        toAddress = to; \n \n        if(  !swapping && \n        from != owner() && \n        to != owner() && \n        from !=address(this) && \n        dividendTracker.LPRewardLastSendTime().add(minPeriod) <= block.timestamp \n        ) { \n            try dividendTracker.process(distributorGas) {} catch {} \n        } \n    } \n \n \n    function takeAllFee(address from,uint256 amount) private returns(uint256 amountAfter) { \n        amountAfter = amount; \n \n        uint256 DFee = amount.mul(deadFee).div(100); \n        if(DFee > 0) super._transfer(from, deadWallet, DFee); \n        amountAfter = amountAfter.sub(DFee); \n \n        uint256 MFee = amount.mul(marketingFee).div(100); \n        if(MFee > 0) super._transfer(from, marketingWalletAddress, MFee); \n        amountAfter = amountAfter.sub(MFee); \n \n        uint256 FFee = amount.mul(foundationFee).div(100); \n        if(FFee > 0) super._transfer(from, foundationWalletAddress, FFee); \n        amountAfter = amountAfter.sub(FFee); \n \n        uint256 LFee = amount.mul(liquidityFee).div(100); \n        AmountLiquidityFee += LFee; \n        amountAfter = amountAfter.sub(LFee); \n \n        uint256 LPFee = amount.mul(lpRewardFee).div(100); \n        AmountLpRewardFee += LPFee; \n        amountAfter = amountAfter.sub(LPFee); \n \n        super._transfer(from, address(this), LFee.add(LPFee)); \n    } \n \n \n \n \n    function swapAndLiquify(uint256 tokens) private { \n        // split the contract balance into halves \n        uint256 half = tokens.div(2); \n        uint256 otherHalf = tokens.sub(half); \n \n        uint256 initialBalance = address(this).balance; \n \n        // swap tokens for ETH \n        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n \n        // how much ETH did we just swap into? \n        uint256 newBalance = address(this).balance.sub(initialBalance); \n        // add liquidity to uniswap \n        addLiquidity(otherHalf, newBalance); \n        emit SwapAndLiquify(half, newBalance, otherHalf); \n    } \n \n    function swapTokensForEth(uint256 tokenAmount) private { \n        // generate the uniswap pair path of token -> weth \n        address[] memory path = new address[](2); \n        path[0] = address(this); \n        path[1] = uniswapV2Router.WETH(); \n \n        _approve(address(this), address(uniswapV2Router), tokenAmount); \n \n        // make the swap \n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens( \n            tokenAmount, \n            0, // accept any amount of ETH \n            path, \n            address(this), \n            block.timestamp \n        ); \n \n    } \n \n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private { \n        // approve token transfer to cover all possible scenarios \n        _approve(address(this), address(uniswapV2Router), tokenAmount); \n        // add the liquidity \n        uniswapV2Router.addLiquidityETH{value: ethAmount}( \n            address(this), \n            tokenAmount, \n            0, // slippage is unavoidable \n            0, // slippage is unavoidable \n            liquidityReceiveAddress, \n            block.timestamp \n        ); \n \n    } \n \n    function swapLPRewardToken(uint256 tokenAmount) private { \n        address[] memory path = new address[](3); \n        path[0] = address(this); \n        path[1] = uniswapV2Router.WETH(); \n        path[2] = lpRewardToken; \n        _approve(address(this), address(uniswapV2Router), tokenAmount); \n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens( \n            tokenAmount, \n            0, \n            path, \n            address(dividendTracker), \n            block.timestamp \n        ); \n \n    } \n \n} \nAnalysis of audit results\nRe-Entrancy\n"
        ]
    },
    {
        "PdfName": "LambSwap_audit.pdf",
        "Code": []
    },
    {
        "PdfName": "LFG Swap_audit.pdf",
        "Code": [
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.2 \n \n// : MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.2 \n \n// : MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v3.4.2 \n \n// : MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n \n/** \n * @dev Implementation of the {IERC20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of ERC20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IERC20-approve}. \n */ \ncontract ERC20 is Context, IERC20 { \n    using SafeMath for uint256; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n     * a default value of 18. \n     * \n     * To select a different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    constructor (string memory name_, string memory symbol_) public { \n        _name = name_; \n        _symbol = symbol_; \n        _decimals = 18; \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public view virtual returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public view virtual returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a balance of `505` tokens should \n     * be displayed to a user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a value of 18, imitating the relationship between \n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is \n     * called. \n     * \n     * NOTE: This information is only used for _display_ purposes: it in \n     * no way affects any of the arithmetic of the contract, including \n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */ \n    function decimals() public view virtual returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */ \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */ \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function allowance(address owner, address spender) public view virtual override returns (uint256) \n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {ERC20}. \n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the total supply. \n     * \n     * Emits a {Transfer} event with `from` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `to` cannot be the zero address. \n     */ \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens. \n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Sets {decimals} to a value other than the default one of 18. \n     * \n     * WARNING: This function should only be called from the constructor. Most \n     * applications that interact with token contracts will not expect \n     * {decimals} to ever change, and may work incorrectly if it does. \n     */ \n    function _setupDecimals(uint8 decimals_) internal virtual { \n        _decimals = decimals_; \n    } \n \n    /** \ncontract Example {\n// Add the library methods\nusing EnumerableSet for EnumerableSet.AddressSet; *\n// Declare a set state variable\nEnumerableSet.AddressSet private mySet;\n}\n \u0300   *\nAs of v3.3.0, sets of type  bytes32  ( Bytes32Set ),  address  ( AddressSet )\nand  uint256  ( UintSet ) are supported. */ library EnumerableSet { // To implement this library for multiple types\nwith as little code // repetition as possible, we write it in terms of a generic Set type with // bytes32 values. // The\nSet implementation uses private functions, and user-facing // implementations (such as AddressSet) are just\nwrappers around the // underlying Set. // This means that we can only create new EnumerableSets for types that\nfit // in bytes32.\nstruct Set {\n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens \n     * will be to transferred to `to`. \n     * - when `from` is zero, `amount` tokens will be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned. \n     * - `from` and `to` are never both zero. \n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n} \n \n \n// File @openzeppelin/contracts/utils/EnumerableSet.sol@v3.4.2 \n \n// : MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Library for managing \n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive \n * types. \n * \n * Sets have the following properties: \n * \n * - Elements are added, removed, and checked for existence in constant time \n * (O(1)). \n * - Elements are enumerated in O(n). No guarantees are made on the ordering. \n * \n * ``\n // Storage of set values \n bytes32[] _values; \n \n // Position of the value in the `values` array, plus 1 because index 0 \n // means a value is not in the set. \n mapping (bytes32 => uint256) _indexes;\n}\n/**\n@dev Add a value to a set. O(1). *\nReturns true if the value was added to the set, that is if it was not\nalready present. */ function add(Set storage set, bytes32 value) private returns (bool) { if (!contains(set,\nvalue)) {\n set._values.push(value); \n // The value is stored at length-1, but we add 1 to all indexes \n // and use 0 as a sentinel value \n set._indexes[value] = set._values.length; \n return true;\n} else {\n return false;\n} }\n/**\n@dev Removes a value from a set. O(1). *\nReturns true if the value was removed from the set, that is if it was\npresent. */ function remove(Set storage set, bytes32 value) private returns (bool) { // We read and store the\nvalue's index to prevent multiple reads from the same storage slot uint256 valueIndex = set.indexes[value];\nif (valueIndex != 0) { // Equivalent to contains(set, value)\n // To delete an element from the _values array in O(1), we swap the element to delete with t\n // the array, and then remove the last element (sometimes called as 'swap and pop'). \n // This modifies the order of the array, as noted in {at}. \n \n uint256 toDeleteIndex = valueIndex - 1; \n uint256 lastIndex = set._values.length - 1; \n \n // When the value to delete is the last one, the swap operation is unnecessary. However, sin\n // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement. \n \n bytes32 lastvalue = set._values[lastIndex]; \n \n // Move the last value to the index where the value to delete is \n set._values[toDeleteIndex] = lastvalue; \n // Update the index for the moved value \n set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based \n \n} else {\n return false;\n} }\n/**\n@dev Returns true if the value is in the set. O(1). */ function contains(Set storage set, bytes32 value) private\nview returns (bool) { return set.indexes[value] != 0; }\n/**\n@dev Returns the number of values on the set. O(1). */ function length(Set storage set) private view returns\n(uint256) { return set.values.length; }\n/**\n@dev Returns the value stored at position  index  in the set. O(1). *\nNote that there are no guarantees on the ordering of values inside the\narray, and it may change when more values are added or removed. *\nRequirements: *\n index  must be strictly less than {length}. */ function at(Set storage set, uint256 index) private view\nreturns (bytes32) { require(set.values.length > index, \"EnumerableSet: index out of bounds\"); return\nset._values[index]; }\n// Bytes32Set\nstruct Bytes32Set { Set _inner; }\n/**\n@dev Add a value to a set. O(1). *\nReturns true if the value was added to the set, that is if it was not\nalready present. */ function add(Bytes32Set storage set, bytes32 value) internal returns (bool) { return\nadd(set.inner, value); }\n/**\n@dev Removes a value from a set. O(1). *\nReturns true if the value was removed from the set, that is if it was\npresent. */ function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) { return\nremove(set.inner, value); }\n/**\n // Delete the slot where the moved value was stored \n set._values.pop(); \n \n // Delete the index for the deleted slot \n delete set._indexes[value]; \n \n return true;\n@dev Returns true if the value is in the set. O(1). */ function contains(Bytes32Set storage set, bytes32\nvalue) internal view returns (bool) { return contains(set.inner, value); }\n/**\n@dev Returns the number of values in the set. O(1). */ function length(Bytes32Set storage set) internal\nview returns (uint256) { return length(set.inner); }\n/**\n@dev Returns the value stored at position  index  in the set. O(1). *\nNote that there are no guarantees on the ordering of values inside the\narray, and it may change when more values are added or removed. *\nRequirements: *\n index  must be strictly less than {length}. */ function at(Bytes32Set storage set, uint256 index) internal\nview returns (bytes32) { return at(set.inner, index); }\n// AddressSet\nstruct AddressSet { Set _inner; }\n/**\n@dev Add a value to a set. O(1). *\nReturns true if the value was added to the set, that is if it was not\nalready present. */ function add(AddressSet storage set, address value) internal returns (bool) { return\nadd(set.inner, bytes32(uint256(uint160(value)))); }\n/**\n@dev Removes a value from a set. O(1). *\nReturns true if the value was removed from the set, that is if it was\npresent. */ function remove(AddressSet storage set, address value) internal returns (bool) { return\nremove(set.inner, bytes32(uint256(uint160(value)))); }\n/**\n@dev Returns true if the value is in the set. O(1). */ function contains(AddressSet storage set, address\nvalue) internal view returns (bool) { return contains(set.inner, bytes32(uint256(uint160(value)))); }\n/**\n@dev Returns the number of values in the set. O(1). */ function length(AddressSet storage set) internal\nview returns (uint256) { return length(set.inner); }\n/**\n@dev Returns the value stored at position  index  in the set. O(1). *\nNote that there are no guarantees on the ordering of values inside the\narray, and it may change when more values are added or removed. *\nRequirements: *\n index  must be strictly less than {length}. */ function at(AddressSet storage set, uint256 index) internal\nview returns (address) { return address(uint160(uint256(at(set.inner, index)))); }\n// UintSet \n \nstruct UintSet { \n    Set _inner; \n} \n \n/** \n * @dev Add a value to a set. O(1). \n * \n * Returns true if the value was added to the set, that is if it was not \n * already present. \n */ \nfunction add(UintSet storage set, uint256 value) internal returns (bool) { \n    return _add(set._inner, bytes32(value)); \n} \n \n/** \n * @dev Removes a value from a set. O(1). \n * \n * Returns true if the value was removed from the set, that is if it was \n * present. \n */ \nfunction remove(UintSet storage set, uint256 value) internal returns (bool) { \n    return _remove(set._inner, bytes32(value)); \n} \n \n/** \n * @dev Returns true if the value is in the set. O(1). \n */ \nfunction contains(UintSet storage set, uint256 value) internal view returns (bool) { \n    return _contains(set._inner, bytes32(value)); \n} \n \n/** \n * @dev Returns the number of values on the set. O(1). \n */ \nfunction length(UintSet storage set) internal view returns (uint256) { \n    return _length(set._inner); \n}\n/**\n* @dev Returns the value stored at position `index` in the set. O(1). \n* \n* Note that there are no guarantees on the ordering of values inside the \n* array, and it may change when more values are added or removed. \n* \n* Requirements: \n* \n* - `index` must be strictly less than {length}. \n*/ \nfunction at(UintSet storage set, uint256 index) internal view returns (uint256) { \n    return uint256(_at(set._inner, index)); \n}\n}\n// File @openzeppelin/contracts/access/Ownable.sol@v3.4.2\n// : MIT\n",
            "pragma solidity >=0.6.0 <0.8.0;\nmailto:openzeppelin/contracts/access/Ownable.sol@v3.4.2\n/**\n@dev Contract module which provides a basic access control mechanism, where\nthere is an account (an owner) that can be granted exclusive access to\nspecific functions. *\nBy default, the owner account will be the one that deploys the contract. This\ncan later be changed with {transferOwnership}. *\nThis module is used through inheritance. It will make available the modifier\n onlyOwner , which can be applied to your functions to restrict their use to\nthe owner. */ abstract contract Ownable is Context { address private _owner;\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n/**\n@dev Initializes the contract setting the deployer as the initial owner. */ constructor () internal { address\nmsgSender = _msgSender(); _owner = msgSender; emit OwnershipTransferred(address(0), msgSender); }\n/**\n@dev Returns the address of the current owner. */ function owner() public view virtual returns (address) {\nreturn _owner; }\n/**\n@dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(owner() ==\n_msgSender(), \"Ownable: caller is not the owner\"); _; }\n/**\n@dev Leaves the contract without owner. It will not be possible to call\n onlyOwner  functions anymore. Can only be called by the current owner. *\nNOTE: Renouncing ownership will leave the contract without an owner,\nthereby removing any functionality that is only available to the owner. */ function renounceOwnership()\npublic virtual onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }\n/**\n@dev Transfers ownership of the contract to a new account ( newOwner ).\nCan only be called by the current owner. */ function transferOwnership(address newOwner) public virtual\nonlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); emit\nOwnershipTransferred(_owner, newOwner); _owner = newOwner; } }\n// File contracts/LfgToken.sol\n// : MIT pragma solidity ^0.6.0;\ncontract LfgToken is ERC20, Ownable { // uint256 private constant preMineSupply = 20000000 * 1e18;\nusing EnumerableSet for EnumerableSet.AddressSet; \nEnumerableSet.AddressSet private _minters; \n \nconstructor() public ERC20(\"LfgSwap Finance Token\", \"LFG\"){ \n    // _mint(msg.sender, preMineSupply); \n} \n \n// mint with max supply \nfunction mint(address _to, uint256 _amount) public onlyMinter returns (bool) { \n    _mint(_to, _amount); \n    return true; \n} \n \nfunction addMinter(address _addMinter) public onlyOwner returns (bool) { \n    require(_addMinter != address(0), \"JfToken: _addMinter is the zero address\"); \n    return EnumerableSet.add(_minters, _addMinter); \n} \n \nfunction delMinter(address _delMinter) public onlyOwner returns (bool) { \n    require(_delMinter != address(0), \"JfToken: _delMinter is the zero address\"); \n    return EnumerableSet.remove(_minters, _delMinter); \n} \n \nfunction getMinterLength() public view returns (uint256) { \n    return EnumerableSet.length(_minters); \n} \n \nfunction isMinter(address account) public view returns (bool) { \n    return EnumerableSet.contains(_minters, account); \n} \n \nfunction getMinter(uint256 _index) public view onlyOwner returns (address){ \n    require(_index <= getMinterLength() - 1, \"JfToken: index out of bounds\"); \n    return EnumerableSet.at(_minters, _index); \n} \n \n// modifier for mint function \nmodifier onlyMinter() { \n    require(isMinter(msg.sender), \"caller is not the minter\"); \n    _; \n}\n}\nLfgSwapFactory.sol \n```javascript \n// Sources flattened with hardhat v2.10.2 https://hardhat.org \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n",
            "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/libraries/SafaMath.sol \n \n",
            "pragma solidity >=0.5.0 <0.8.0; \n \nlibrary SafeMath { \n    uint256 constant WAD = 10 ** 18; \n    uint256 constant RAY = 10 ** 27; \n \n    function wad() public pure returns (uint256) { \n        return WAD; \n    } \n \n    function ray() public pure returns (uint256) { \n        return RAY; \n    } \n \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n \n    function min(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a <= b ? a : b; \n    } \n \n    function max(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a >= b ? a : b; \n    } \n \n    function sqrt(uint256 a) internal pure returns (uint256 b) { \n        if (a > 3) { \n            b = a; \n            uint256 x = a / 2 + 1; \n            while (x < b) { \n                b = x; \n                x = (a / x + x) / 2; \n            } \n        } else if (a != 0) { \n            b = 1; \n        } \n    } \n \n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mul(a, b) / WAD; \n    } \n \n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) { \n        return add(mul(a, b), WAD / 2) / WAD; \n    } \n \n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mul(a, b) / RAY; \n    } \n \n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) { \n        return add(mul(a, b), RAY / 2) / RAY; \n    } \n \n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(mul(a, WAD), b); \n    } \n \n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) { \n        return add(mul(a, WAD), b / 2) / b; \n    } \n \n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(mul(a, RAY), b); \n    } \n \n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) { \n        return add(mul(a, RAY), b / 2) / b; \n    } \n \n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) { \n        uint256 result = WAD; \n        while (n > 0) { \n            if (n % 2 != 0) { \n                result = wmul(result, x); \n            } \n            x = wmul(x, x); \n            n /= 2; \n        } \n        return result; \n    } \n \n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) { \n        uint256 result = RAY; \n        while (n > 0) { \n            if (n % 2 != 0) { \n                result = rmul(result, x); \n            } \n            x = rmul(x, x); \n            n /= 2; \n        } \n        return result; \n    } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.2 \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File contracts/libraries/UQ112x112.sol \n \n",
            "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n    uint224 constant Q112 = 2**112; \n \n    // encode a uint112 as a UQ112x112 \n    function encode(uint112 y) internal pure returns (uint224 z) { \n        z = uint224(y) * Q112; // never overflows \n    } \n \n    // divide a UQ112x112 by a uint112, returning a UQ112x112 \n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n        z = x / uint224(y); \n    } \n} \n \n \n// File contracts/core/LfgSwapPair.sol \n \n",
            "pragma solidity =0.6.12; \n \n \n \n \ninterface IMigrator { \n    // Return the desired amount of liquidity token that the migrator wants. \n    function desiredLiquidity() external view returns (uint256); \n} \n \ninterface ILfgSwapCallee { \n    function jwapCall(address sender, uint amount0, uint amount1, bytes calldata data) external; \n} \n \ncontract LfgSwapERC20 { \n    using SafeMath for uint; \n \n    string public constant name = 'LGF LP Token'; \n    string public constant symbol = 'LFG_LP'; \n    uint8 public constant decimals = 18; \n    uint  public totalSupply; \n    mapping(address => uint) public balanceOf; \n    mapping(address => mapping(address => uint)) public allowance; \n \n    bytes32 public DOMAIN_SEPARATOR; \n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c6\n    mapping(address => uint) public nonces; \n \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    constructor() public { \n        uint chainId; \n        assembly { \n            chainId := chainid() \n        } \n        DOMAIN_SEPARATOR = keccak256( \n            abi.encode( \n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingC\n                keccak256(bytes(name)), \n                keccak256(bytes('1')), \n                chainId, \n                address(this) \n            ) \n        ); \n    } \n \n    function _mint(address to, uint value) internal { \n        totalSupply = totalSupply.add(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(address(0), to, value); \n    } \n \n    function _burn(address from, uint value) internal { \n        balanceOf[from] = balanceOf[from].sub(value); \n        totalSupply = totalSupply.sub(value); \n        emit Transfer(from, address(0), value); \n    } \n \n    function _approve(address owner, address spender, uint value) private { \n        allowance[owner][spender] = value; \n        emit Approval(owner, spender, value); \n    } \n \n    function _transfer(address from, address to, uint value) private { \n \n        balanceOf[from] = balanceOf[from].sub(value); \n        balanceOf[to] = balanceOf[to].add(value); \n \n        emit Transfer(from, to, value); \n    } \n \n    function approve(address spender, uint value) external returns (bool) { \n        _approve(msg.sender, spender, value); \n        return true; \n    } \n \n    function transfer(address to, uint value) external returns (bool) { \n        _transfer(msg.sender, to, value); \n        return true; \n    } \n \n    function transferFrom(address from, address to, uint value) external returns (bool) { \n        if (allowance[from][msg.sender] != uint(-1)) { \n \n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value); \n        } \n        _transfer(from, to, value); \n        return true; \n    } \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED'); \n        bytes32 digest = keccak256( \n            abi.encodePacked( \n                '\\x19\\x01', \n                DOMAIN_SEPARATOR, \n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadlin\n            ) \n        ); \n        address recoveredAddress = ecrecover(digest, v, r, s); \n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGN\n        _approve(owner, spender, value); \n    } \n} \n \ncontract LfgSwapPair is LfgSwapERC20 { \n    using SafeMath  for uint; \n    using UQ112x112 for uint224; \n \n    uint public constant MINIMUM_LIQUIDITY = 10**3; \n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)'))); \n \n    address public factory; \n    address public token0; \n    address public token1; \n \n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves \n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves \n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves \n \n    uint public price0CumulativeLast; \n    uint public price1CumulativeLast; \n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity even\n \n    uint private unlocked = 1; \n    modifier lock() { \n        require(unlocked == 1, 'LfgSwap: LOCKED'); \n        unlocked = 0; \n        _; \n        unlocked = 1; \n    } \n \n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTi\n        _reserve0 = reserve0; \n        _reserve1 = reserve1; \n        _blockTimestampLast = blockTimestampLast; \n    } \n \n    function _safeTransfer(address token, address to, uint value) private { \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value)); \n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'LfgSwap: TRANSFER_FAILED'\n    } \n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    constructor() public { \n        factory = msg.sender; \n    } \n \n    // called once by the factory at time of deployment \n    function initialize(address _token0, address _token1) external { \n        require(msg.sender == factory, 'LfgSwap: FORBIDDEN'); // sufficient check \n        token0 = _token0; \n        token1 = _token1; \n    } \n \n    // update reserves and, on the first call per block, price accumulators \n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { \n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'LfgSwap: OVERFLOW'); \n        uint32 blockTimestamp = uint32(block.timestamp % 2**32); \n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired \n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) { \n            // * never overflows, and + overflow is desired \n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; \n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; \n        } \n        reserve0 = uint112(balance0); \n        reserve1 = uint112(balance1); \n        blockTimestampLast = blockTimestamp; \n        emit Sync(reserve0, reserve1); \n    } \n \n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k) \n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) { \n        address feeTo = ILfgSwapFactory(factory).feeTo(); \n        feeOn = feeTo != address(0); \n        uint _kLast = kLast; // gas savings \n        if (feeOn) { \n            if (_kLast != 0) { \n                uint rootK = SafeMath.sqrt(uint(_reserve0).mul(_reserve1)); \n                uint rootKLast = SafeMath.sqrt(_kLast); \n                if (rootK > rootKLast) { \n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast)); \n                    uint denominator = rootK.mul(2).add(rootKLast); \n                    uint liquidity = numerator / denominator; \n                    if (liquidity > 0) _mint(feeTo, liquidity); \n                } \n            } \n        } else if (_kLast != 0) { \n            kLast = 0; \n        } \n    } \n \n    // this low-level function should be called from a contract which performs important safety check\n    function mint(address to) external lock returns (uint liquidity) { \n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings \n        uint balance0 = IERC20(token0).balanceOf(address(this)); \n        uint balance1 = IERC20(token1).balanceOf(address(this)); \n        uint amount0 = balance0.sub(_reserve0); \n        uint amount1 = balance1.sub(_reserve1); \n \n        bool feeOn = _mintFee(_reserve0, _reserve1); \n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can up\n        if (_totalSupply == 0) { \n            liquidity = SafeMath.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); \n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tok\n        } else { \n            liquidity = SafeMath.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) \n        } \n        require(liquidity > 0, 'LfgSwap: INSUFFICIENT_LIQUIDITY_MINTED'); \n        _mint(to, liquidity); \n \n        _update(balance0, balance1, _reserve0, _reserve1); \n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date \n \n        emit Mint(msg.sender, amount0, amount1); \n    } \n    // this low-level function should be called from a contract which performs important safety check\n    function burn(address to) external lock returns (uint amount0, uint amount1) { \n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings \n        address _token0 = token0;                                // gas savings \n        address _token1 = token1;                                // gas savings \n        uint balance0 = IERC20(_token0).balanceOf(address(this)); \n        uint balance1 = IERC20(_token1).balanceOf(address(this)); \n        uint liquidity = balanceOf[address(this)]; \n \n        bool feeOn = _mintFee(_reserve0, _reserve1); \n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can up\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribu\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribu\n \n        require(amount0 > 0 && amount1 > 0, 'LfgSwap: INSUFFICIENT_LIQUIDITY_BURNED'); \n        _burn(address(this), liquidity); \n        _safeTransfer(_token0, to, amount0); \n        _safeTransfer(_token1, to, amount1); \n        balance0 = IERC20(_token0).balanceOf(address(this)); \n        balance1 = IERC20(_token1).balanceOf(address(this)); \n \n        _update(balance0, balance1, _reserve0, _reserve1); \n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date \n        emit Burn(msg.sender, amount0, amount1, to); \n    } \n    // this low-level function should be called from a contract which performs important safety check\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock { \n        if( amount0Out > 0 || amount1Out > 0 ) { \n            require(amount0Out > 0 || amount1Out > 0, 'LfgSwap: INSUFFICIENT_OUTPUT_AMOUNT'); \n            (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings \n            require(amount0Out < _reserve0 && amount1Out < _reserve1, 'LfgSwap: INSUFFICIENT_LIQUIDIT\n \n            uint balance0; \n            uint balance1; \n            { // scope for _token{0,1}, avoids stack too deep errors \n            address _token0 = token0; \n            address _token1 = token1; \n            require(to != _token0 && to != _token1, 'LfgSwap: INVALID_TO'); \n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer to\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer to\n            if (data.length > 0) ILfgSwapCallee(to).jwapCall(msg.sender, amount0Out, amount1Out, data\n            balance0 = IERC20(_token0).balanceOf(address(this)); \n            balance1 = IERC20(_token1).balanceOf(address(this)); \n            } \n            uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) \n            uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) \n            require(amount0In > 0 || amount1In > 0, 'LfgSwap: INSUFFICIENT_INPUT_AMOUNT'); \n            { // scope for reserve{0,1}Adjusted, avoids stack too deep errors \n            uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); \n            uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); \n            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000\n            } \n \n            _update(balance0, balance1, _reserve0, _reserve1); \n            emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to); \n        } \n \n    } \n \n    // force balances to match reserves \n    function skim(address to) external lock { \n        address _token0 = token0; // gas savings \n        address _token1 = token1; // gas savings \n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); \n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1)); \n    } \n \n    // force reserves to match balances \n    function sync() external lock { \n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), res\n    } \n} \n \n \n// File contracts/core/LfgSwapFactory.sol \n \n",
            "pragma solidity =0.6.12; \n \n \ncontract LfgSwapFactory is ILfgSwapFactory { \n    address public override feeTo; \n    address public override feeToSetter; \n    bytes32 public initCodeHash; \n \n    mapping(address => mapping(address => address)) public override getPair; \n    address[] public override allPairs; \n \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    constructor(address _feeToSetter) public { \n        feeToSetter = _feeToSetter; \n        initCodeHash = keccak256(abi.encodePacked(type(LfgSwapPair).creationCode)); \n    } \n \n    function allPairsLength() external override view returns (uint) { \n        return allPairs.length; \n    } \n \nLfgSwapRouter.sol\n    function pairCodeHash() external pure returns (bytes32) { \n        return keccak256(type(LfgSwapPair).creationCode); \n    } \n \n    // returns sorted token addresses, used to handle return values from pairs sorted in this order \n    function sortTokens(address tokenA, address tokenB) public override pure returns (address token0, \n        require(tokenA != tokenB, 'LfgSwapFactory: IDENTICAL_ADDRESSES'); \n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'LfgSwapFactory: ZERO_ADDRESS'); \n    } \n \n    // calculates the CREATE2 address for a pair without making any external calls \n    function pairFor(address tokenA, address tokenB) public override view returns (address pair) { \n        (address token0, address token1) = sortTokens(tokenA, tokenB); \n        pair = address(uint(keccak256(abi.encodePacked( \n                hex'ff', \n                address(this), \n                keccak256(abi.encodePacked(token0, token1)), \n                initCodeHash \n            )))); \n    } \n \n    function createPair(address tokenA, address tokenB) external override returns (address pair) { \n        require(tokenA != tokenB, 'LfgSwap: IDENTICAL_ADDRESSES'); \n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'LfgSwap: ZERO_ADDRESS'); \n        require(getPair[token0][token1] == address(0), 'LfgSwap: PAIR_EXISTS'); // single check is su\n        bytes memory bytecode = type(LfgSwapPair).creationCode; \n        bytes32 salt = keccak256(abi.encodePacked(token0, token1)); \n        assembly { \n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        LfgSwapPair(pair).initialize(token0, token1); \n        getPair[token0][token1] = pair; \n        getPair[token1][token0] = pair; // populate mapping in the reverse direction \n        allPairs.push(pair); \n        emit PairCreated(token0, token1, pair, allPairs.length); \n    } \n \n    function getSalt() public view returns(bytes32) { \n        bytes memory bytecode = type(LfgSwapPair).creationCode; \n        return keccak256(abi.encodePacked(bytecode)); \n    } \n \n    function setFeeTo(address _feeTo) external override { \n        require(msg.sender == feeToSetter, 'LfgSwap: FORBIDDEN'); \n        feeTo = _feeTo; \n    } \n \n \n    function setFeeToSetter(address _feeToSetter) external override { \n        require(msg.sender == feeToSetter, 'LfgSwap: FORBIDDEN'); \n        feeToSetter = _feeToSetter; \n    } \n \n} \n \n \n \n// Sources flattened with hardhat v2.10.2 https://hardhat.org \n \n// File @openzeppelin/contracts/utils/Context.sol@v3.4.2 \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n// File @openzeppelin/contracts/access/Ownable.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n \n// File @openzeppelin/contracts/utils/Address.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) inte\n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/SafeERC20.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n// File contracts/interface/ILfgSwapPair.sol \n \n",
            "pragma solidity >=0.5.0; \n \ninterface ILfgSwapPair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n    function factory() external view returns (address); \n    function token0() external view returns (address); \n    function token1() external view returns (address); \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function price0CumulativeLast() external view returns (uint); \n    function price1CumulativeLast() external view returns (uint); \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n    function burn(address to) external returns (uint amount0, uint amount1); \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n    function skim(address to) external; \n    function sync() external; \n \n    function initialize(address, address) external; \n} \n \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n",
            "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/libraries/LfgSwapLibrary.sol \n \n",
            "pragma solidity >=0.5.0; \n \n \nlibrary LfgSwapLibrary { \n    using SafeMath for uint; \n \n    // returns sorted token addresses, used to handle return values from pairs sorted in this order \n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, addres\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES'); \n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS'); \n    } \n \n    // calculates the CREATE2 address for a pair without making any external calls \n    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address \n        (address token0, address token1) = sortTokens(tokenA, tokenB); \n        pair  =  ILfgSwapFactory(factory).getPair(token0, token1); \n \n        // = address(uint(keccak256(abi.encodePacked( \n        //         hex'ff', \n        //         factory, \n        //         keccak256(abi.encodePacked(token0, token1)), \n        //         hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code \n        //     )))); \n    } \n \n    // fetches and sorts the reserves for a pair \n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint \n        (address token0,) = sortTokens(tokenA, tokenB); \n        (uint reserve0, uint reserve1,) = ILfgSwapPair(pairFor(factory, tokenA, tokenB)).getReserves(\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0); \n    } \n \n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other ass\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { \n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); \n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); \n        amountB = amountA.mul(reserveB) / reserveA; \n    } \n \n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint \n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); \n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); \n        uint amountInWithFee = amountIn.mul(997); \n        uint numerator = amountInWithFee.mul(reserveOut); \n        uint denominator = reserveIn.mul(1000).add(amountInWithFee); \n        amountOut = numerator / denominator; \n    } \n \n    // given an output amount of an asset and pair reserves, returns a required input amount of the o\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint \n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); \n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); \n        uint numerator = reserveIn.mul(amountOut).mul(1000); \n        uint denominator = reserveOut.sub(amountOut).mul(997); \n        amountIn = (numerator / denominator).add(1); \n    } \n \n    // performs chained getAmountOut calculations on any number of pairs \n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view retur\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); \n        amounts = new uint[](path.length); \n        amounts[0] = amountIn; \n        for (uint i; i < path.length - 1; i++) { \n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); \n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); \n        } \n    } \n \n    // performs chained getAmountIn calculations on any number of pairs \n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view retur\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); \n        amounts = new uint[](path.length); \n        amounts[amounts.length - 1] = amountOut; \n        for (uint i = path.length - 1; i > 0; i--) { \n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); \n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); \n        } \n    } \n} \n \n \n// File contracts/libraries/TransferHelper.sol \n \n// -- SPDX-License-Identifier:: GPL-3.0-or-later \n \n",
            "pragma solidity >=0.6.0; \n \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return t\nlibrary TransferHelper { \n    function safeApprove(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('approve(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n    } \n \n    function safeTransfer(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferFrom(address token, address from, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferETH(address to, uint value) internal { \n        (bool success,) = to.call{value:value}(new bytes(0)); \n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED'); \n    } \n} \n \n \n// File contracts/interface/ILfgSwapRouter.sol \n \n",
            "pragma solidity >=0.6.2; \n \ninterface ILfgSwapRouter { \n \n    function factory() external pure returns (address); \n    function WETH() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityETH( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityETH( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountETH); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityETHWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountETH); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadl\n        external \n        payable \n        returns (uint[] memory amounts); \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline\n        external \n        payable \n        returns (uint[] memory amounts); \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n \n    function removeLiquidityETHSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountETH); \n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountETH); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForETHSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n} \n \n \n// File contracts/interface/IWETH.sol \n \n",
            "pragma solidity >=0.5.0; \n \ninterface IWETH { \n    function deposit() external payable; \n    function transfer(address to, uint value) external returns (bool); \n    function withdraw(uint) external; \n    function balanceOf(address) external returns (uint256); \n} \n \n \n// File contracts/interface/IERC20LfgSwap.sol \n \n",
            "pragma solidity >=0.5.0; \n \ninterface IERC20LfgSwap { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n} \n \n \n// File contracts/core/LfgSwapRouter.sol \n \n",
            "pragma solidity =0.6.12; \n \n \n \n \n \n \n \n \ncontract LfgSwapRouter is ILfgSwapRouter, Ownable { \n    using SafeMath for uint; \n \n    address public override factory; \n    address public override WETH; \n    // address public immutable override WETH; \n \n    modifier ensure(uint deadline) { \n        require(deadline >= block.timestamp, 'LfgSwapRouter: EXPIRED'); \n        _; \n    } \n \n \n    constructor(address _factory, address _WETH) public { \n        factory = _factory; \n        WETH = _WETH; \n    } \n \n    receive() external payable { \n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract \n    } \n \n    // **** ADD LIQUIDITY **** \n    function _addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin \n    ) internal virtual returns (uint amountA, uint amountB) { \n        // create the pair if it doesn't exist yet \n        if (ILfgSwapFactory(factory).getPair(tokenA, tokenB) == address(0)) { \n            ILfgSwapFactory(factory).createPair(tokenA, tokenB); \n        } \n        (uint reserveA, uint reserveB) = LfgSwapLibrary.getReserves(factory, tokenA, tokenB); \n        if (reserveA == 0 && reserveB == 0) { \n            (amountA, amountB) = (amountADesired, amountBDesired); \n        } else { \n            uint amountBOptimal = LfgSwapLibrary.quote(amountADesired, reserveA, reserveB); \n            if (amountBOptimal <= amountBDesired) { \n                require(amountBOptimal >= amountBMin, 'LfgSwapRouter: INSUFFICIENT_B_AMOUNT'); \n                (amountA, amountB) = (amountADesired, amountBOptimal); \n            } else { \n                uint amountAOptimal = LfgSwapLibrary.quote(amountBDesired, reserveB, reserveA); \n                assert(amountAOptimal <= amountADesired); \n                require(amountAOptimal >= amountAMin, 'LfgSwapRouter: INSUFFICIENT_A_AMOUNT'); \n                (amountA, amountB) = (amountAOptimal, amountBDesired); \n            } \n        } \n    } \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) \n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin\n        address pair = LfgSwapLibrary.pairFor(factory, tokenA, tokenB); \n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA); \n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB); \n        liquidity = ILfgSwapPair(pair).mint(to); \n    } \n    function addLiquidityETH( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, u\n        (amountToken, amountETH) = _addLiquidity( \n            token, \n            WETH, \n            amountTokenDesired, \n            msg.value, \n            amountTokenMin, \n            amountETHMin \n        ); \n        address pair = LfgSwapLibrary.pairFor(factory, token, WETH); \n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken); \n        IWETH(WETH).deposit{value: amountETH}(); \n        assert(IWETH(WETH).transfer(pair, amountETH)); \n        liquidity = ILfgSwapPair(pair).mint(to); \n        // refund dust eth, if any \n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); \n    } \n \n    // **** REMOVE LIQUIDITY **** \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) { \n        address pair = LfgSwapLibrary.pairFor(factory, tokenA, tokenB); \n        ILfgSwapPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair \n        (uint amount0, uint amount1) = ILfgSwapPair(pair).burn(to); \n        (address token0,) = LfgSwapLibrary.sortTokens(tokenA, tokenB); \n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); \n        require(amountA >= amountAMin, 'LfgSwapRouter: INSUFFICIENT_A_AMOUNT'); \n        require(amountB >= amountBMin, 'LfgSwapRouter: INSUFFICIENT_B_AMOUNT'); \n    } \n    function removeLiquidityETH( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) { \n        (amountToken, amountETH) = removeLiquidity( \n            token, \n            WETH, \n            liquidity, \n            amountTokenMin, \n            amountETHMin, \n            address(this), \n            deadline \n        ); \n        TransferHelper.safeTransfer(token, to, amountToken); \n        IWETH(WETH).withdraw(amountETH); \n        TransferHelper.safeTransferETH(to, amountETH); \n    } \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external virtual override returns (uint amountA, uint amountB) { \n        address pair = LfgSwapLibrary.pairFor(factory, tokenA, tokenB); \n        uint value = approveMax ? uint(-1) : liquidity; \n        ILfgSwapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); \n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, d\n    } \n    function removeLiquidityETHWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external virtual override returns (uint amountToken, uint amountETH) { \n        address pair = LfgSwapLibrary.pairFor(factory, token, WETH); \n        uint value = approveMax ? uint(-1) : liquidity; \n        ILfgSwapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); \n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, \n    } \n \n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) **** \n    function removeLiquidityETHSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) public virtual override ensure(deadline) returns (uint amountETH) { \n        (, amountETH) = removeLiquidity( \n            token, \n            WETH, \n            liquidity, \n            amountTokenMin, \n            amountETHMin, \n            address(this), \n            deadline \n        ); \n        TransferHelper.safeTransfer(token, to, IERC20LfgSwap(token).balanceOf(address(this))); \n        IWETH(WETH).withdraw(amountETH); \n        TransferHelper.safeTransferETH(to, amountETH); \n    } \n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external virtual override returns (uint amountETH) { \n        address pair = LfgSwapLibrary.pairFor(factory, token, WETH); \n        uint value = approveMax ? uint(-1) : liquidity; \n        ILfgSwapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); \n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens( \n            token, liquidity, amountTokenMin, amountETHMin, to, deadline \n        ); \n    } \n \n    // **** SWAP **** \n    // requires the initial amount to have already been sent to the first pair \n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual { \n        for (uint i; i < path.length - 1; i++) { \n            (address input, address output) = (path[i], path[i + 1]); \n            (address token0,) = LfgSwapLibrary.sortTokens(input, output); \n            uint amountOut = amounts[i + 1]; \n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, \n            address to = i < path.length - 2 ? LfgSwapLibrary.pairFor(factory, output, path[i + 2]) : \n \n            ILfgSwapPair(LfgSwapLibrary.pairFor(factory, input, output)).swap( \n                amount0Out, amount1Out, to, new bytes(0) \n            ); \n \n        } \n    } \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) { \n        amounts = LfgSwapLibrary.getAmountsOut(factory, amountIn, path); \n        require(amounts[amounts.length - 1] >= amountOutMin, 'LfgSwapRouter: INSUFFICIENT_OUTPUT_AMOU\n \n        //swapExactTokensForTokens \n \n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, LfgSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0] \n        ); \n        _swap(amounts, path, to); \n    } \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) { \n        amounts = LfgSwapLibrary.getAmountsIn(factory, amountOut, path); \n        require(amounts[0] <= amountInMax, 'LfgSwapRouter: EXCESSIVE_INPUT_AMOUNT'); \n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, LfgSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0] \n        ); \n        _swap(amounts, path, to); \n    } \n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadl\n        external \n        virtual \n        override \n        payable \n        ensure(deadline) \n        returns (uint[] memory amounts) \n    { \n        require(path[0] == WETH, 'LfgSwapRouter: INVALID_PATH'); \n        amounts = LfgSwapLibrary.getAmountsOut(factory, msg.value, path); \n        require(amounts[amounts.length - 1] >= amountOutMin, 'LfgSwapRouter: INSUFFICIENT_OUTPUT_AMOU\n        IWETH(WETH).deposit{value: amounts[0]}(); \n        assert(IWETH(WETH).transfer(LfgSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0])); \n        _swap(amounts, path, to); \n    } \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address \n        external \n        virtual \n        override \n        ensure(deadline) \n        returns (uint[] memory amounts) \n    { \n        require(path[path.length - 1] == WETH, 'LfgSwapRouter: INVALID_PATH'); \n        amounts = LfgSwapLibrary.getAmountsIn(factory, amountOut, path); \n        require(amounts[0] <= amountInMax, 'LfgSwapRouter: EXCESSIVE_INPUT_AMOUNT'); \n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, LfgSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0] \n        ); \n        _swap(amounts, path, address(this)); \n        IWETH(WETH).withdraw(amounts[amounts.length - 1]); \n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); \n    } \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address \n        external \n        virtual \n        override \n        ensure(deadline) \n        returns (uint[] memory amounts) \n    { \n        require(path[path.length - 1] == WETH, 'LfgSwapRouter: INVALID_PATH'); \n        amounts = LfgSwapLibrary.getAmountsOut(factory, amountIn, path); \n        require(amounts[amounts.length - 1] >= amountOutMin, 'LfgSwapRouter: INSUFFICIENT_OUTPUT_AMOU\n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, LfgSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0] \n        ); \n        _swap(amounts, path, address(this)); \n        IWETH(WETH).withdraw(amounts[amounts.length - 1]); \n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]); \n    } \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline\n        external \n        virtual \n        override \n        payable \n        ensure(deadline) \n        returns (uint[] memory amounts) \n    { \n        require(path[0] == WETH, 'LfgSwapRouter: INVALID_PATH'); \n        amounts = LfgSwapLibrary.getAmountsIn(factory, amountOut, path); \n        require(amounts[0] <= msg.value, 'LfgSwapRouter: EXCESSIVE_INPUT_AMOUNT'); \n        IWETH(WETH).deposit{value: amounts[0]}(); \n        assert(IWETH(WETH).transfer(LfgSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0])); \n        _swap(amounts, path, to); \n        // refund dust eth, if any \n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]\n    } \n \n    // **** SWAP (supporting fee-on-transfer tokens) **** \n    // requires the initial amount to have already been sent to the first pair \n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual \n        for (uint i; i < path.length - 1; i++) { \n            (address input, address output) = (path[i], path[i + 1]); \n            (address token0,) = LfgSwapLibrary.sortTokens(input, output); \n            ILfgSwapPair pair = ILfgSwapPair(LfgSwapLibrary.pairFor(factory, input, output)); \n            uint amountInput; \n            uint amountOutput; \n            { // scope to avoid stack too deep errors \n            (uint reserve0, uint reserve1,) = pair.getReserves(); \n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reser\n            amountInput = IERC20LfgSwap(input).balanceOf(address(pair)).sub(reserveInput); \n            amountOutput = LfgSwapLibrary.getAmountOut(amountInput, reserveInput, reserveOutput); \n            } \n \n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountO\n            address to = i < path.length - 2 ? LfgSwapLibrary.pairFor(factory, output, path[i + 2]) : \n            pair.swap(amount0Out, amount1Out, to, new bytes(0)); \n        } \n    } \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external virtual override ensure(deadline) { \n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, LfgSwapLibrary.pairFor(factory, path[0], path[1]), amountIn \n        ); \n        uint balanceBefore = IERC20LfgSwap(path[path.length - 1]).balanceOf(to); \n        _swapSupportingFeeOnTransferTokens(path, to); \n        require( \n            IERC20LfgSwap(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, \n            'LfgSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT' \n        ); \n    } \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) \n        external \n        virtual \n        override \n        payable \n        ensure(deadline) \n    { \n        require(path[0] == WETH, 'LfgSwapRouter: INVALID_PATH'); \n        uint amountIn = msg.value; \n        IWETH(WETH).deposit{value: amountIn}(); \n        assert(IWETH(WETH).transfer(LfgSwapLibrary.pairFor(factory, path[0], path[1]), amountIn)); \n        uint balanceBefore = IERC20LfgSwap(path[path.length - 1]).balanceOf(to); \n        _swapSupportingFeeOnTransferTokens(path, to); \n        require( \n            IERC20LfgSwap(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, \n            'LfgSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT' \n        ); \n    } \n    function swapExactTokensForETHSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) \n        external \n        virtual \n        override \n        ensure(deadline) \n    { \n        require(path[path.length - 1] == WETH, 'LfgSwapRouter: INVALID_PATH'); \n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, LfgSwapLibrary.pairFor(factory, path[0], path[1]), amountIn \n        ); \n        _swapSupportingFeeOnTransferTokens(path, address(this)); \n        uint amountOut = IERC20LfgSwap(WETH).balanceOf(address(this)); \n        require(amountOut >= amountOutMin, 'LfgSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT'); \nLfgSwapPair.sol\n        IWETH(WETH).withdraw(amountOut); \n        TransferHelper.safeTransferETH(to, amountOut); \n    } \n \n    // **** LIBRARY FUNCTIONS **** \n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (\n        return LfgSwapLibrary.quote(amountA, reserveA, reserveB); \n    } \n \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) \n        public \n        pure \n        virtual \n        override \n        returns (uint amountOut) \n    { \n        return LfgSwapLibrary.getAmountOut(amountIn, reserveIn, reserveOut); \n    } \n \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) \n        public \n        pure \n        virtual \n        override \n        returns (uint amountIn) \n    { \n        return LfgSwapLibrary.getAmountIn(amountOut, reserveIn, reserveOut); \n    } \n \n    function getAmountsOut(uint amountIn, address[] memory path) \n        public \n        view \n        virtual \n        override \n        returns (uint[] memory amounts) \n    { \n        return LfgSwapLibrary.getAmountsOut(factory, amountIn, path); \n    } \n \n    function getAmountsIn(uint amountOut, address[] memory path) \n        public \n        view \n        virtual \n        override \n        returns (uint[] memory amounts) \n    { \n        return LfgSwapLibrary.getAmountsIn(factory, amountOut, path); \n    } \n} \n// Sources flattened with hardhat v2.10.2 https://hardhat.org \n \n// File contracts/libraries/SafaMath.sol \n \n",
            "pragma solidity >=0.5.0 <0.8.0; \n \nlibrary SafeMath { \n    uint256 constant WAD = 10 ** 18; \n    uint256 constant RAY = 10 ** 27; \n \n    function wad() public pure returns (uint256) { \n        return WAD; \n    } \n \n    function ray() public pure returns (uint256) { \n        return RAY; \n    } \n \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n \n    function min(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a <= b ? a : b; \n    } \n \n    function max(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a >= b ? a : b; \n    } \n \n    function sqrt(uint256 a) internal pure returns (uint256 b) { \n        if (a > 3) { \n            b = a; \n            uint256 x = a / 2 + 1; \n            while (x < b) { \n                b = x; \n                x = (a / x + x) / 2; \n            } \n        } else if (a != 0) { \n            b = 1; \n        } \n    } \n \n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mul(a, b) / WAD; \n    } \n \n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) { \n        return add(mul(a, b), WAD / 2) / WAD; \n    } \n \n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mul(a, b) / RAY; \n    } \n \n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) { \n        return add(mul(a, b), RAY / 2) / RAY; \n    } \n \n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(mul(a, WAD), b); \n    } \n \n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) { \n        return add(mul(a, WAD), b / 2) / b; \n    } \n \n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(mul(a, RAY), b); \n    } \n \n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) { \n        return add(mul(a, RAY), b / 2) / b; \n    } \n \n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) { \n        uint256 result = WAD; \n        while (n > 0) { \n            if (n % 2 != 0) { \n                result = wmul(result, x); \n            } \n            x = wmul(x, x); \n            n /= 2; \n        } \n        return result; \n    } \n \n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) { \n        uint256 result = RAY; \n        while (n > 0) { \n            if (n % 2 != 0) { \n                result = rmul(result, x); \n            } \n            x = rmul(x, x); \n            n /= 2; \n        } \n        return result; \n    } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.2 \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File contracts/libraries/UQ112x112.sol \n \n",
            "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n    uint224 constant Q112 = 2**112; \n \n    // encode a uint112 as a UQ112x112 \n    function encode(uint112 y) internal pure returns (uint224 z) { \n        z = uint224(y) * Q112; // never overflows \n    } \n \n    // divide a UQ112x112 by a uint112, returning a UQ112x112 \n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n        z = x / uint224(y); \n    } \n} \n \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n",
            "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/core/LfgSwapPair.sol \n \n",
            "pragma solidity =0.6.12; \n \n \n \n \ninterface IMigrator { \n    // Return the desired amount of liquidity token that the migrator wants. \n    function desiredLiquidity() external view returns (uint256); \n} \n \ninterface ILfgSwapCallee { \n    function jwapCall(address sender, uint amount0, uint amount1, bytes calldata data) external; \n} \n \ncontract LfgSwapERC20 { \n    using SafeMath for uint; \n \n    string public constant name = 'LGF LP Token'; \n    string public constant symbol = 'LFG_LP'; \n    uint8 public constant decimals = 18; \n    uint  public totalSupply; \n    mapping(address => uint) public balanceOf; \n    mapping(address => mapping(address => uint)) public allowance; \n \n    bytes32 public DOMAIN_SEPARATOR; \n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c6\n    mapping(address => uint) public nonces; \n \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    constructor() public { \n        uint chainId; \n        assembly { \n            chainId := chainid() \n        } \n        DOMAIN_SEPARATOR = keccak256( \n            abi.encode( \n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingC\n                keccak256(bytes(name)), \n                keccak256(bytes('1')), \n                chainId, \n                address(this) \n            ) \n        ); \n    } \n \n    function _mint(address to, uint value) internal { \n        totalSupply = totalSupply.add(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(address(0), to, value); \n    } \n \n    function _burn(address from, uint value) internal { \n        balanceOf[from] = balanceOf[from].sub(value); \n        totalSupply = totalSupply.sub(value); \n        emit Transfer(from, address(0), value); \n    } \n \n    function _approve(address owner, address spender, uint value) private { \n        allowance[owner][spender] = value; \n        emit Approval(owner, spender, value); \n    } \n \n    function _transfer(address from, address to, uint value) private { \n \n        balanceOf[from] = balanceOf[from].sub(value); \n        balanceOf[to] = balanceOf[to].add(value); \n \n        emit Transfer(from, to, value); \n    } \n \n    function approve(address spender, uint value) external returns (bool) { \n        _approve(msg.sender, spender, value); \n        return true; \n    } \n \n    function transfer(address to, uint value) external returns (bool) { \n        _transfer(msg.sender, to, value); \n        return true; \n    } \n \n    function transferFrom(address from, address to, uint value) external returns (bool) { \n        if (allowance[from][msg.sender] != uint(-1)) { \n \n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value); \n        } \n        _transfer(from, to, value); \n        return true; \n    } \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED'); \n        bytes32 digest = keccak256( \n            abi.encodePacked( \n                '\\x19\\x01', \n                DOMAIN_SEPARATOR, \n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadlin\n            ) \n        ); \n        address recoveredAddress = ecrecover(digest, v, r, s); \n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGN\n        _approve(owner, spender, value); \n    } \n} \n \ncontract LfgSwapPair is LfgSwapERC20 { \n    using SafeMath  for uint; \n    using UQ112x112 for uint224; \n \n    uint public constant MINIMUM_LIQUIDITY = 10**3; \n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)'))); \n \n    address public factory; \n    address public token0; \n    address public token1; \n \n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves \n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves \n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves \n \n    uint public price0CumulativeLast; \n    uint public price1CumulativeLast; \n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity even\n \n    uint private unlocked = 1; \n    modifier lock() { \n        require(unlocked == 1, 'LfgSwap: LOCKED'); \n        unlocked = 0; \n        _; \n        unlocked = 1; \n    } \n \n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTi\n        _reserve0 = reserve0; \n        _reserve1 = reserve1; \n        _blockTimestampLast = blockTimestampLast; \n    } \n \n    function _safeTransfer(address token, address to, uint value) private { \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value)); \n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'LfgSwap: TRANSFER_FAILED'\n    } \n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    constructor() public { \n        factory = msg.sender; \n    } \n \n    // called once by the factory at time of deployment \n    function initialize(address _token0, address _token1) external { \n        require(msg.sender == factory, 'LfgSwap: FORBIDDEN'); // sufficient check \n        token0 = _token0; \n        token1 = _token1; \n    } \n \n    // update reserves and, on the first call per block, price accumulators \n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { \n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'LfgSwap: OVERFLOW'); \n        uint32 blockTimestamp = uint32(block.timestamp % 2**32); \n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired \n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) { \n            // * never overflows, and + overflow is desired \n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; \n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; \n        } \n        reserve0 = uint112(balance0); \n        reserve1 = uint112(balance1); \n        blockTimestampLast = blockTimestamp; \n        emit Sync(reserve0, reserve1); \n    } \n \n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k) \n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) { \n        address feeTo = ILfgSwapFactory(factory).feeTo(); \n        feeOn = feeTo != address(0); \n        uint _kLast = kLast; // gas savings \n        if (feeOn) { \n            if (_kLast != 0) { \n                uint rootK = SafeMath.sqrt(uint(_reserve0).mul(_reserve1)); \n                uint rootKLast = SafeMath.sqrt(_kLast); \n                if (rootK > rootKLast) { \n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast)); \n                    uint denominator = rootK.mul(2).add(rootKLast); \n                    uint liquidity = numerator / denominator; \n                    if (liquidity > 0) _mint(feeTo, liquidity); \n                } \n            } \n        } else if (_kLast != 0) { \n            kLast = 0; \n        } \n    } \n \n    // this low-level function should be called from a contract which performs important safety check\n    function mint(address to) external lock returns (uint liquidity) { \n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings \n        uint balance0 = IERC20(token0).balanceOf(address(this)); \n        uint balance1 = IERC20(token1).balanceOf(address(this)); \n        uint amount0 = balance0.sub(_reserve0); \n        uint amount1 = balance1.sub(_reserve1); \n \n        bool feeOn = _mintFee(_reserve0, _reserve1); \n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can up\n        if (_totalSupply == 0) { \n            liquidity = SafeMath.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); \n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tok\n        } else { \n            liquidity = SafeMath.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) \n        } \n        require(liquidity > 0, 'LfgSwap: INSUFFICIENT_LIQUIDITY_MINTED'); \n        _mint(to, liquidity); \n \n        _update(balance0, balance1, _reserve0, _reserve1); \n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date \n \n        emit Mint(msg.sender, amount0, amount1); \n    } \n    // this low-level function should be called from a contract which performs important safety check\n    function burn(address to) external lock returns (uint amount0, uint amount1) { \n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings \n        address _token0 = token0;                                // gas savings \n        address _token1 = token1;                                // gas savings \n        uint balance0 = IERC20(_token0).balanceOf(address(this)); \n        uint balance1 = IERC20(_token1).balanceOf(address(this)); \n        uint liquidity = balanceOf[address(this)]; \n \n        bool feeOn = _mintFee(_reserve0, _reserve1); \n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can up\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribu\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribu\n \n        require(amount0 > 0 && amount1 > 0, 'LfgSwap: INSUFFICIENT_LIQUIDITY_BURNED'); \n        _burn(address(this), liquidity); \n        _safeTransfer(_token0, to, amount0); \n        _safeTransfer(_token1, to, amount1); \n        balance0 = IERC20(_token0).balanceOf(address(this)); \n        balance1 = IERC20(_token1).balanceOf(address(this)); \n \n        _update(balance0, balance1, _reserve0, _reserve1); \n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date \n        emit Burn(msg.sender, amount0, amount1, to); \n    } \n    // this low-level function should be called from a contract which performs important safety check\n"
        ]
    },
    {
        "PdfName": "LOCG_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/access/AccessControl.sol\"; \nimport \"@openzeppelin/contracts/security/Pausable.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; \nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\"; \n \ncontract LOCG is AccessControl, ERC20, Pausable, ERC20Burnable, ERC20Snapshot { \n    using SafeERC20 for IERC20; \n \n    string public constant NAME = \"LOCGame Token\"; \n    string public constant SYMBOL = \"LOCG\"; \n    uint256 public constant MAX_TOTAL_SUPPLY = 150_000_000 * 1e18; \n \n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");       // Whitelisted ad\n \n    modifier onlyAdmin() { \n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"!admin\"); \n        _; \n    } \n \n    constructor (address daoMultiSig) ERC20(NAME, SYMBOL) { \n        _setupRole(DEFAULT_ADMIN_ROLE, daoMultiSig);   // DEFAULT_ADMIN_ROLE can grant other roles \n        _setupRole(WHITELISTED_ROLE, daoMultiSig); \n        _mint(daoMultiSig, MAX_TOTAL_SUPPLY); \n    } \n \n \n    /** \n     * @notice Triggers stopped state. \n     * Requirements: \n     * - The contract must not be paused. \n     */ \n    function pause() external onlyAdmin { \n        _pause(); \n    } \n \n    /** \n     * @notice Returns to normal state. \n     * Requirements: \n     * - The contract must be paused. \n     */ \n    function unpause() external onlyAdmin { \n        _unpause(); \n    } \n \n    /** \n     * @notice Creates a new snapshot and returns its snapshot id. \n     */ \n    function snapshot() external onlyAdmin { \n        _snapshot(); \n    } \n \n"
        ]
    },
    {
        "PdfName": "Lovelace(LACE) Token_audit.pdf",
        "Code": [
            "pragma solidity 0.8.9; \n \ninterface IBEP20 { \n  /** \n   * @dev Returns the amount of tokens in existence. \n   */ \n  function totalSupply() external view returns (uint256); \n \n  /** \n   * @dev Returns the token decimals. \n   */ \n  function decimals() external view returns (uint8); \n \n  /** \n   * @dev Returns the token symbol. \n   */ \n  function symbol() external view returns (string memory); \n \n  /** \n  * @dev Returns the token name. \n  */ \n  function name() external view returns (string memory); \n \n  /** \n   * @dev Returns the bep token owner. \n   */ \n  function getOwner() external view returns (address); \n \n  /** \n   * @dev Returns the amount of tokens owned by `account`. \n   */ \n  function balanceOf(address account) external view returns (uint256); \n \n  /** \n   * @dev Moves `amount` tokens from the caller's account to `recipient`. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * Emits a {Transfer} event. \n   */ \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Returns the remaining number of tokens that `spender` will be \n   * allowed to spend on behalf of `owner` through {transferFrom}. This is \n   * zero by default. \n   * \n   * This value changes when {approve} or {transferFrom} are called. \n   */ \n  function allowance(address _owner, address spender) external view returns (uint256); \n \n  /** \n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * IMPORTANT: Beware that changing an allowance with this method brings the risk \n   * that someone may use both the old and the new allowance by unfortunate \n   * transaction ordering. One possible solution to mitigate this race \n   * condition is to first reduce the spender's allowance to 0 and set the \n   * desired value afterwards: \n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n   * \n   * Emits an {Approval} event. \n   */ \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Moves `amount` tokens from `sender` to `recipient` using the \n   * allowance mechanism. `amount` is then deducted from the caller's \n   * allowance. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * Emits a {Transfer} event. \n   */ \n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Emitted when `value` tokens are moved from one account (`from`) to \n   * another (`to`). \n   * \n   * Note that `value` may be zero. \n   */ \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  /** \n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n   * a call to {approve}. `value` is the new allowance. \n   */ \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes calldata) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n// File: @openzeppelin/contracts/access/Ownable.sol \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n  /** \n   * @dev Returns the addition of two unsigned integers, reverting on \n   * overflow. \n   * \n   * Counterpart to Solidity's `+` operator. \n   * \n   * Requirements: \n   * - Addition cannot overflow. \n   */ \n  function add(uint256 a, uint256 b) internal pure returns (uint256) { \n    uint256 c = a + b; \n    require(c >= a, \"SafeMath: addition overflow\"); \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the subtraction of two unsigned integers, reverting on \n   * overflow (when the result is negative). \n   * \n   * Counterpart to Solidity's `-` operator. \n   * \n   * Requirements: \n   * - Subtraction cannot overflow. \n   */ \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n    return sub(a, b, \"SafeMath: subtraction overflow\"); \n  } \n \n  /** \n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n   * overflow (when the result is negative). \n   * \n   * Counterpart to Solidity's `-` operator. \n   * \n   * Requirements: \n   * - Subtraction cannot overflow. \n   */ \n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n    require(b <= a, errorMessage); \n    uint256 c = a - b; \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the multiplication of two unsigned integers, reverting on \n   * overflow. \n   * \n   * Counterpart to Solidity's `*` operator. \n   * \n   * Requirements: \n   * - Multiplication cannot overflow. \n   */ \n  function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n    // benefit is lost if 'b' is also tested. \n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n    if (a == 0) { \n      return 0; \n    } \n \n    uint256 c = a * b; \n    require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the integer division of two unsigned integers. Reverts on \n   * division by zero. The result is rounded towards zero. \n   * \n   * Counterpart to Solidity's `/` operator. Note: this function uses a \n   * `revert` opcode (which leaves remaining gas untouched) while Solidity \n   * uses an invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function div(uint256 a, uint256 b) internal pure returns (uint256) { \n    return div(a, b, \"SafeMath: division by zero\"); \n  } \n \n  /** \n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on \n   * division by zero. The result is rounded towards zero. \n   * \n   * Counterpart to Solidity's `/` operator. Note: this function uses a \n   * `revert` opcode (which leaves remaining gas untouched) while Solidity \n   * uses an invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n    // Solidity only automatically asserts when dividing by 0 \n    require(b > 0, errorMessage); \n    uint256 c = a / b; \n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n   * Reverts when dividing by zero. \n   * \n   * Counterpart to Solidity's `%` operator. This function uses a `revert` \n   * opcode (which leaves remaining gas untouched) while Solidity uses an \n   * invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n    return mod(a, b, \"SafeMath: modulo by zero\"); \n  } \n \n  /** \n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n   * Reverts with custom message when dividing by zero. \n   * \n   * Counterpart to Solidity's `%` operator. This function uses a `revert` \n   * opcode (which leaves remaining gas untouched) while Solidity uses an \n   * invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n    require(b != 0, errorMessage); \n    return a % b; \n  } \n} \n \n \ncontract LGEWhitelisted is Context { \n    struct WhitelistRound { \n        uint256 duration; \n        uint256 amountMax; \n        mapping(address => bool) addresses; \n        mapping(address => uint256) purchased; \n    } \n \n    WhitelistRound[] public _lgeWhitelistRounds; \n \n    uint256 public _lgeTimestamp; \n    address public _lgePairAddress; \n \n    address public _whitelister; \n \n    event WhitelisterTransferred(address indexed previousWhitelister, address indexed newWhitelister)\n \n    constructor() { \n        _whitelister = _msgSender(); \n    } \n \n    modifier onlyWhitelister() { \n        require(_whitelister == _msgSender(), \"Caller is not the whitelister\"); \n        _; \n    } \n \n    function renounceWhitelister() external onlyWhitelister { \n        emit WhitelisterTransferred(_whitelister, address(0)); \n        _whitelister = address(0); \n    } \n \n    function transferWhitelister(address newWhitelister) external onlyWhitelister { \n        _transferWhitelister(newWhitelister); \n    } \n \n    function _transferWhitelister(address newWhitelister) internal { \n        require(newWhitelister != address(0), \"New whitelister is the zero address\"); \n        emit WhitelisterTransferred(_whitelister, newWhitelister); \n        _whitelister = newWhitelister; \n    } \n \n    /* \n     * createLGEWhitelist - Call this after initial Token Generation Event (TGE) \n     * \n     * pairAddress - address generated from createPair() event on DEX \n     * durations - array of durations (seconds) for each whitelist rounds \n     * amountsMax - array of max amounts (TOKEN decimals) for each whitelist round \n     * \n     */ \n \n    function createLGEWhitelist( \n        address pairAddress, \n        uint256[] calldata durations, \n        uint256[] calldata amountsMax \n    ) external onlyWhitelister() { \n        require(durations.length == amountsMax.length, \"Invalid whitelist(s)\"); \n \n        _lgePairAddress = pairAddress; \n \n        if (durations.length > 0) { \n            delete _lgeWhitelistRounds; \n \n            for (uint256 i = 0; i < durations.length; i++) { \n                WhitelistRound storage whitelistRound = _lgeWhitelistRounds.push(); \n                whitelistRound.duration = durations[i]; \n                whitelistRound.amountMax = amountsMax[i]; \n            } \n        } \n    } \n \n    /* \n     * modifyLGEWhitelistAddresses - Define what addresses are included/excluded from a whitelist rou\n     * \n     * index - 0-based index of round to modify whitelist \n     * duration - period in seconds from LGE event or previous whitelist round \n     * amountMax - max amount (TOKEN decimals) for each whitelist round \n     * \n     */ \n    function modifyLGEWhitelist( \n        uint256 index, \n        uint256 duration, \n        uint256 amountMax, \n        address[] calldata addresses, \n        bool enabled \n    ) external onlyWhitelister() { \n        require(index < _lgeWhitelistRounds.length, \"Invalid index\"); \n        require(amountMax > 0, \"Invalid amountMax\"); \n \n        if (duration != _lgeWhitelistRounds[index].duration) _lgeWhitelistRounds[index].duration = du\n \n        if (amountMax != _lgeWhitelistRounds[index].amountMax) _lgeWhitelistRounds[index].amountMax = \n \n        for (uint256 i = 0; i < addresses.length; i++) { \n            _lgeWhitelistRounds[index].addresses[addresses[i]] = enabled; \n        } \n    } \n \n    /* \n     *  getLGEWhitelistRound \n     * \n     *  returns: \n     * \n     *  1. whitelist round number ( 0 = no active round now ) \n     *  2. duration, in seconds, current whitelist round is active for \n     *  3. timestamp current whitelist round closes at \n     *  4. maximum amount a whitelister can purchase in this round \n     *  5. is caller whitelisted \n     *  6. how much caller has purchased in current whitelist round \n     * \n     */ \n \n    function getLGEWhitelistRound() \n        public \n        view \n        returns ( \n            uint256, \n            uint256, \n            uint256, \n            uint256, \n            bool, \n            uint256 \n        ) \n    { \n        if (_lgeTimestamp > 0) { \n            uint256 wlCloseTimestampLast = _lgeTimestamp; \n \n            for (uint256 i = 0; i < _lgeWhitelistRounds.length; i++) { \n                WhitelistRound storage wlRound = _lgeWhitelistRounds[i]; \n \n                wlCloseTimestampLast = wlCloseTimestampLast + wlRound.duration; \n                if (block.timestamp <= wlCloseTimestampLast) \n                    return ( \n                        i + 1, \n                        wlRound.duration, \n                        wlCloseTimestampLast, \n                        wlRound.amountMax, \n                        wlRound.addresses[_msgSender()], \n                        wlRound.purchased[_msgSender()] \n                    ); \n            } \n        } \n \n        return (0, 0, 0, 0, false, 0); \n    } \n \n    /* \n     * _applyLGEWhitelist - internal function to be called initially before any transfers \n     * \n     */ \n \n    function _applyLGEWhitelist( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) internal { \n        if (_lgePairAddress == address(0) || _lgeWhitelistRounds.length == 0) return; \n \n        if (_lgeTimestamp == 0 && sender != _lgePairAddress && recipient == _lgePairAddress && amount \n            _lgeTimestamp = block.timestamp; \n \n        if (sender == _lgePairAddress && recipient != _lgePairAddress) { \n            //buying \n \n            (uint256 wlRoundNumber, , , , , ) = getLGEWhitelistRound(); \n \n            if (wlRoundNumber > 0) { \n                WhitelistRound storage wlRound = _lgeWhitelistRounds[wlRoundNumber - 1]; \n \n                require(wlRound.addresses[recipient], \"LGE - Buyer is not whitelisted\"); \n \n                uint256 amountRemaining = 0; \n \n                if (wlRound.purchased[recipient] < wlRound.amountMax) \n                    amountRemaining = wlRound.amountMax - wlRound.purchased[recipient]; \n \n                require(amount <= amountRemaining, \"LGE - Amount exceeds whitelist maximum\"); \n                wlRound.purchased[recipient] = wlRound.purchased[recipient] + amount; \n            } \n        } \n    } \n} \n \ncontract Lovelace is Context, IBEP20, Ownable, LGEWhitelisted { \n \n    using SafeMath for uint256; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n    uint8 private _decimals; \n    string private _symbol; \n    string private _name; \n \n    constructor() { \n        _name = \"Lovelace\"; \n        _symbol = \"LACE\"; \n        _decimals = 18; \n        _totalSupply = 250_000_000 * 10 ** 18; \n        _balances[_msgSender()] = _totalSupply; \n \n        emit Transfer(address(0), _msgSender(), _totalSupply); \n    } \n \n    /** \n    * @dev Returns the bep token owner. \n    */ \n    function getOwner() external view override returns (address) { \n        return owner(); \n    } \n \n    /** \n    * @dev Returns the token decimals. \n    */ \n    function decimals() external view override returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n    * @dev Returns the token symbol. \n    */ \n    function symbol() external view override returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n    * @dev Returns the token name. \n    */ \n    function name() external view override returns (string memory) { \n        return _name; \n    } \n \n    /** \n    * @dev See {BEP20-totalSupply}. \n    */ \n    function totalSupply() external view override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n    * @dev See {BEP20-balanceOf}. \n    */ \n    function balanceOf(address account) external view override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n    * @dev See {BEP20-transfer}. \n    * \n    * Requirements: \n    * \n    * - `recipient` cannot be the zero address. \n    * - the caller must have a balance of at least `amount`. \n    */ \n    function transfer(address recipient, uint256 amount) external override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n    * @dev See {BEP20-allowance}. \n    */ \n    function allowance(address owner, address spender) public view override returns (uint256) { \n        return _allowances[owner][spender]; \n    } \n \n    /** \n    * @dev See {BEP20-approve}. \n    * \n    * Requirements: \n    * \n    * - `spender` cannot be the zero address. \n    */ \n    function approve(address spender, uint256 amount) external override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n    * @dev See {BEP20-transferFrom}. \n    * \n    * Emits an {Approval} event indicating the updated allowance. This is not \n    * required by the EIP. See the note at the beginning of {BEP20}; \n    * \n    * Requirements: \n    * - `sender` and `recipient` cannot be the zero address. \n    * - `sender` must have a balance of at least `amount`. \n    * - the caller must have allowance for `sender`'s tokens of at least \n    * `amount`. \n    */ \n    function transferFrom(address sender, address recipient, uint256 amount) external override return\n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from the caller. \n     * \n     * See {ERC20-_burn}. \n     */ \n    function burn(uint256 amount) public virtual { \n        _burn(_msgSender(), amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's \n     * allowance. \n     * \n     * See {ERC20-_burn} and {ERC20-allowance}. \n     * \n     * Requirements: \n     * \n     * - the caller must have allowance for ``accounts``'s tokens of at least \n     * `amount`. \n     */ \n    function burnFrom(address account, uint256 amount) public virtual { \n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount \n \n        _approve(account, _msgSender(), decreasedAllowance); \n        _burn(account, amount); \n    } \n \n    /** \n    * @dev Atomically increases the allowance granted to `spender` by the caller. \n    * \n    * This is an alternative to {approve} that can be used as a mitigation for \n    * problems described in {BEP20-approve}. \n    * \n    * Emits an {Approval} event indicating the updated allowance. \n    * \n    * Requirements: \n    * \n    * - `spender` cannot be the zero address. \n    */ \n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n    * @dev Atomically decreases the allowance granted to `spender` by the caller. \n    * \n    * This is an alternative to {approve} that can be used as a mitigation for \n    * problems described in {BEP20-approve}. \n    * \n    * Emits an {Approval} event indicating the updated allowance. \n    * \n    * Requirements: \n    * \n    * - `spender` cannot be the zero address. \n    * - `spender` must have allowance for the caller of at least \n    * `subtractedValue`. \n    */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP2\n        return true; \n    } \n \n    /** \n    * @dev Moves tokens `amount` from `sender` to `recipient`. \n    * \n    * This is internal function is equivalent to {transfer}, and can be used to \n    * e.g. implement automatic token fees, slashing mechanisms, etc. \n    * \n    * Emits a {Transfer} event. \n    * \n    * Requirements: \n    * \n    * - `sender` cannot be the zero address. \n    * - `recipient` cannot be the zero address. \n    * - `sender` must have a balance of at least `amount`. \n    */ \n    function _transfer(address sender, address recipient, uint256 amount) internal { \n        require(sender != address(0), \"BEP20: transfer from the zero address\"); \n        require(recipient != address(0), \"BEP20: transfer to the zero address\"); \n \n        _applyLGEWhitelist(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** \n    * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens. \n    * \n    * This is internal function is equivalent to `approve`, and can be used to \n    * e.g. set automatic allowances for certain subsystems, etc. \n    * \n    * Emits an {Approval} event. \n    * \n    * Requirements: \n    * \n    * - `owner` cannot be the zero address. \n    * - `spender` cannot be the zero address. \n    */ \n    function _approve(address owner, address spender, uint256 amount) internal { \n        require(owner != address(0), \"BEP20: approve from the zero address\"); \n        require(spender != address(0), \"BEP20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        uint256 accountBalance = _balances[account]; \n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\"); \n        unchecked { \n            _balances[account] = accountBalance - amount; \n        } \n        _totalSupply -= amount; \n \n        emit Transfer(account, address(0), amount); \n    } \n} \n \nAnalysis of audit results\n"
        ]
    },
    {
        "PdfName": "Mart Audit Report_audit.pdf",
        "Code": [
            "pragma solidity 0.8.0; \n//SPDX-License-Identifier: SimPL-2.0 \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes calldata) { \n        return msg.data; \n    } \n} \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor() { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        assembly { \n            size := extcodesize(account) \n        } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        (bool success, ) = recipient.call{value: amount}(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain `call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n        return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall( \n        address target, \n        bytes memory data, \n        string memory errorMessage \n    ) internal returns (bytes memory) { \n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue( \n        address target, \n        bytes memory data, \n        uint256 value \n    ) internal returns (bytes memory) { \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue( \n        address target, \n        bytes memory data, \n        uint256 value, \n        string memory errorMessage \n    ) internal returns (bytes memory) { \n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        (bool success, bytes memory returndata) = target.call{value: value}(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall( \n        address target, \n        bytes memory data, \n        string memory errorMessage \n    ) internal view returns (bytes memory) { \n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a delegate call. \n     * \n     * _Available since v3.4._ \n     */ \n    function functionDelegateCall( \n        address target, \n        bytes memory data, \n        string memory errorMessage \n    ) internal returns (bytes memory) { \n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult( \n        bool success, \n        bytes memory returndata, \n        string memory errorMessage \n    ) private pure returns (bytes memory) { \n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            uint256 c = a + b; \n            if (c < a) return (false, 0); \n            return (true, c); \n        } \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b > a) return (false, 0); \n            return (true, a - b); \n        } \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n            // benefit is lost if 'b' is also tested. \n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n            if (a == 0) return (true, 0); \n            uint256 c = a * b; \n            if (c / a != b) return (false, 0); \n            return (true, c); \n        } \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b == 0) return (false, 0); \n            return (true, a / b); \n        } \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b == 0) return (false, 0); \n            return (true, a % b); \n        } \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a + b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a * b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b <= a, errorMessage); \n            return a - b; \n        } \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b > 0, errorMessage); \n            return a / b; \n        } \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b > 0, errorMessage); \n            return a % b; \n        } \n    } \n} \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \ninterface  Mar  { \n    function balanceOf(address account) external view  returns (uint256); \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n} \ncontract MarToken is Context, IERC20, Ownable{ \n \n    using SafeMath for uint256; \n    using Address for address; \n \n    mapping (address => uint256) private _lockU; \n    mapping (address => uint256) private _lockR; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    mapping (address => bool) private _isNotFromFee; \n    mapping (address => bool) private _isNotToFee;      \n    mapping (address => bool) public _isLocked;              \n    address[] private _locked;                         \n \n    uint256 private _supply = 4.5*10**8*10**9; \n    uint256 private _investAmount = 1*10**8*10**9; \n    uint256 private _teamAmount   = 1*10**8*10**9; \n    uint256 private rate    = _supply; \n    uint256 public _tTotal; \n    uint256 public _rTotal; \n    uint256 public _tFeeTotal; \n \n    string private _name     = \"MART Token\"; \n    string private _symbol   = \"MART\"; \n    uint8  private _decimals = 9; \n    uint256 private _taxFee  = 1;     \n    uint256 private _burnRate = 80;   \n    uint256 private _previousTaxFee = _taxFee; \n    uint256 public _maxTxAmount = 50 * 10**6 * 10**9; \n \n    address public transContract; \n    address public airdropAddr;    \n    address public investAddr ; \n    address public teamAddr ; \n \n    uint256 private _lockTotal;   \n    struct LockUBalance { \n        uint256 lockOne; \n        uint256 lockTwo; \n        uint256 lockThr; \n        uint256 lockFou; \n    } \n    struct LockUser { \n        uint256 amount;     \n        uint256 unlockBlocknum;     \n        bool    isLock;             \n        bool    isUsed; \n        uint256 posRate;             \n    } \n    struct LockConf { \n        uint256 rate; \n        uint256 lockBlockNum; \n        uint256 posRate; \n        bool    isPos; \n        bool    isUsed; \n    } \n    struct InvetTeam{ \n        uint256 start; \n        uint256 total; \n        uint256 hadReleased; \n        uint256 releaseTime; \n        uint256 timeinterval; \n        uint256 everyReleaseAmt; \n    } \n    uint256 public  blockNum; \n    uint256 public  startBlock; \n \n    mapping(uint8=>mapping(address=>LockUser)) public lockUserMap; \n    mapping (uint8 => LockConf)  public lockConfMap; \n    mapping (address => LockUBalance) public LockR; \n    mapping (address => uint256) private sumRateLockUser; \n    mapping (uint8  => InvetTeam) public invetTeamConf;  \n \n    Mar mar; \n    uint256 public _lockAllWeight;                    \n    uint256 public _releaseAll;            \n \n    uint256 public _releaseLoop; \n    uint256 public _releaseInvestLoop; \n    uint256 public _releaseTeamLoop; \n \n    uint8[] public  lockList =[1,2,3,4]; \n    uint256[] private releaseBlock; \n    uint256[] private releaseAmount; \n    uint256[] private releaseAirAmount; \n    bool isinitVest = false; \n    bool isinitTeam = false; \n    event LockCoin(string,address,uint256,uint8); \n    event ReleaseCoin(string,uint256,uint8,address); \n    event ReleaseAward(string,uint256,uint8); \n    event Reaward(string,address,uint256); \n    event PrintLog(string,uint256); \n    event BurnLog(string,uint256); \n    event ReleaseAirLog(string,address,uint256,uint256); \n    event ExchangeLog(string,address,uint256); \n    constructor( \n        uint256 blocknums, \n        uint256 Liquidity, \n        uint256 startblock, \n        address LiquidAddr, \n        uint256[] memory releaselist, \n        uint256[] memory amountlist, \n        uint256[] memory airAmountList, \n        address  OldmartAddress \n    ){ \n        mar = Mar(OldmartAddress); \n        blockNum = blocknums; \n        startBlock = startblock; \n        releaseBlock = releaselist; \n        releaseAmount = amountlist; \n        releaseAirAmount    = airAmountList; \n        _lockR[LiquidAddr]  = Liquidity*rate; \n        _rTotal             = Liquidity*rate; \n        _tTotal             = Liquidity; \n        LockConf memory conf1 = LockConf(10000,blockNum*7,0,false,true); \n        lockConfMap[1] = conf1; \n        LockConf memory conf2 = LockConf(20000,blockNum*30,0,false,true); \n        lockConfMap[2] = conf2; \n        LockConf memory conf3 = LockConf(40000,blockNum*90,10,false,true); \n        lockConfMap[3] = conf3; \n        LockConf memory conf4 = LockConf(80000,blockNum*180,12,false,true); \n        lockConfMap[4] = conf4; \n        _isNotFromFee[owner()] = true; \n        _isNotToFee[owner()]   = true; \n        _isNotFromFee[LiquidAddr] = true; \n        _isNotToFee[LiquidAddr]   = true; \n        _isNotFromFee[address(this)] = true; \n        _isNotToFee[address(this)] = true; \n        emit Transfer(address(0), LiquidAddr, Liquidity); \n    } \n \n    function releaseAirdrop() public  returns(bool){ \n        require(airdropAddr!=address(0),\"mat:address is error\"); \n        (uint256 currloop,) = getAirDaysupply(); \n        if(currloop <= _releaseLoop) return false; \n        uint256 releaseAmt  = 0; \n        if(currloop.sub(_releaseLoop)>50) currloop = _releaseLoop.add(50); \n        for(uint256 i = _releaseLoop.add(1);i<currloop;i++){ \n            (,uint256 amounts) = getAirDaysupply(i); \n            releaseAmt         = releaseAmt.add(amounts); \n            emit ReleaseAirLog(\"airdrop\",airdropAddr,amounts,i); \n            emit Transfer(address(0),airdropAddr,amounts); \n        } \n        _lockR[airdropAddr]    = _lockR[airdropAddr].add(releaseAmt.mul(_getRate())); \n        _rTotal                = _rTotal.add(releaseAmt.mul(_getRate())); \n        _tTotal                = _tTotal.add(releaseAmt);     \n        _releaseLoop           = currloop.sub(1); \n        return true; \n    } \n \n    function releaseInvest() public  returns(bool){ \n        require(investAddr!=address(0),\"mat:address is error\"); \n        if(block.timestamp < invetTeamConf[1].start) return false; \n        uint256 loop = (block.timestamp.sub(invetTeamConf[1].start)).div(invetTeamConf[1].timeinterva\n        if(loop<=_releaseInvestLoop) return false; \n        if(_releaseInvestLoop>=invetTeamConf[1].releaseTime) return false; \n        if(loop>invetTeamConf[1].releaseTime) loop = invetTeamConf[1].releaseTime.add(1); \n        uint256 releaseAmt = 0; \n        for(uint256 i = _releaseInvestLoop.add(1);i<loop;i++){ \n            uint256 amounts    = invetTeamConf[1].everyReleaseAmt; \n            releaseAmt         = releaseAmt.add(amounts); \n            emit ReleaseAirLog(\"investrelease\",investAddr,amounts,i); \n            emit Transfer(address(0),investAddr,amounts); \n        } \n        invetTeamConf[1].hadReleased = invetTeamConf[1].hadReleased.add(releaseAmt); \n        assert(invetTeamConf[1].total>invetTeamConf[1].hadReleased); \n        _lockR[investAddr]    = _lockR[investAddr].add(releaseAmt.mul(_getRate())); \n        _rTotal               = _rTotal.add(releaseAmt.mul(_getRate())); \n        _tTotal               = _tTotal.add(releaseAmt);  \n        _releaseInvestLoop    = loop.sub(1); \n        return true; \n    } \n \n    function releaseTeam() public  returns(bool){ \n        require(teamAddr!=address(0),\"mat:address is error\"); \n        if(block.timestamp < invetTeamConf[2].start) return false; \n        uint256 loop = block.timestamp.sub(invetTeamConf[2].start).div(invetTeamConf[2].timeinterval)\n        if(loop<=_releaseTeamLoop) return false; \n        if(_releaseTeamLoop>invetTeamConf[2].releaseTime) return false; \n        if(loop>invetTeamConf[2].releaseTime) loop = invetTeamConf[2].releaseTime.add(1); \n        uint256 releaseAmt = 0; \n        for(uint256 i = _releaseTeamLoop.add(1);i<loop;i++){ \n            uint256 amounts    = invetTeamConf[2].everyReleaseAmt; \n            releaseAmt         = releaseAmt.add(amounts); \n            emit ReleaseAirLog(\"teamrelease\",teamAddr,amounts,i); \n            emit Transfer(address(0),teamAddr,amounts); \n        } \n        invetTeamConf[2].hadReleased = invetTeamConf[2].hadReleased.add(releaseAmt); \n        assert(invetTeamConf[2].total>invetTeamConf[2].hadReleased); \n        _lockR[teamAddr]    = _lockR[teamAddr].add(releaseAmt.mul(_getRate())); \n        _rTotal             = _rTotal.add(releaseAmt.mul(_getRate())); \n        _tTotal             = _tTotal.add(releaseAmt); \n        _releaseTeamLoop    = loop.sub(1); \n        return true; \n    } \n \n    function setContract(address transaddress)  public  onlyOwner returns(bool){ \n        require(transaddress != address(0),\"mat:address is zero\"); \n        transContract = transaddress; \n        return true; \n    } \n \n    function setAirdrop(address airdrop) public  onlyOwner returns(bool){ \n        require(airdrop != address(0),\"mat:address is zero\"); \n        airdropAddr = airdrop; \n        return true; \n    } \n    function setInvestTeamConf( \n        uint8   types, \n        uint256 startTime, \n        uint256 hadreleased, \n        uint256 timeinterval, \n        uint256 releaseTime, \n        uint256 everyReleaseAmt \n    ) public onlyOwner returns(bool){ \n        require(types>0,\"mat:param is error\"); \n        require(startTime>block.timestamp,\"mat:param is error\"); \n        require(hadreleased>=0,\"mat:param is error\"); \n        require(timeinterval>0,\"mat:param is error\"); \n        require(releaseTime>0,\"mat:param is error\"); \n        if(types ==1){ \n            if(isinitVest) return false; \n            isinitVest = true; \n            InvetTeam memory invetTeamconf = InvetTeam(startTime,_investAmount,hadreleased,releaseTim\n            invetTeamConf[types] = invetTeamconf; \n        } \n        else{ \n            if(isinitTeam) return false; \n            isinitTeam = true; \n            InvetTeam memory invetTeamconf = InvetTeam(startTime,_teamAmount,hadreleased,releaseTime,\n            invetTeamConf[types] = invetTeamconf; \n        } \n        return true; \n    } \n    function setInvestAddr(address investaddr) public  onlyOwner returns(bool){ \n        require(investaddr != address(0),\"mat:address is zero\"); \n        investAddr = investaddr; \n        return true; \n    } \n    function setTeamAddr(address teamaddr) public  onlyOwner returns(bool){ \n        require(teamaddr != address(0),\"mat:address is zero\"); \n        teamAddr = teamaddr; \n        return true; \n    } \n \n    //set lockconf data \n    function setLockConf(uint8 level,uint256 rates,uint256 lockBlocks,uint256 posrate,bool ispos,bool\n        require(level>0&&level<20,\"mar:level is err\"); \n        require(rates>1,\"mar:rate is err\"); \n        require(lockBlocks>0,\"mar:lockblock is err\"); \n        lockConfMap[level].rate = rates; \n        lockConfMap[level].lockBlockNum = lockBlocks; \n        lockConfMap[level].posRate = posrate; \n        lockConfMap[level].isPos   = ispos; \n        lockConfMap[level].isUsed  = isuse; \n        return true; \n    } \n \n    function getReleaseAll() public view returns (uint256){ \n        return _releaseAll; \n    } \n    function getCurrentAir() public view returns(uint256){ \n        return _releaseLoop; \n    } \n    function name() public view returns (string memory) { \n        return _name; \n    } \n    function symbol() public view returns (string memory) { \n        return _symbol; \n    } \n    function decimals() public view returns (uint8) { \n        return _decimals; \n    } \n \n    function totalSupply() public view override returns (uint256) { \n        return _supply; \n    } \n \n    function balanceOf(address account) public view override returns (uint256) { \n         return _lockR[account].div(_getRate()); \n    } \n \n    function getbalance(address account) public view  returns (uint256) { \n        uint256 ubalance = 0; \n        uint256 lreawardOne = 0; \n        uint256 lreawardTwo = 0; \n        uint256 lreawardThr = 0; \n        uint256 lreawardFou = 0; \n        if(LockR[account].lockThr>0){ \n            lreawardOne = LockR[account].lockThr.div(_getRate()); \n            ubalance = ubalance.add(lreawardOne.sub(lockUserMap[3][account].amount.mul(lockConfMap[3]\n        } \n        if(LockR[account].lockTwo>0){ \n            lreawardTwo = LockR[account].lockTwo.div(_getRate()); \n            ubalance = ubalance.add(lreawardTwo.sub(lockUserMap[2][account].amount.mul(lockConfMap[2]\n        } \n        if(LockR[account].lockOne>0){ \n            lreawardThr = LockR[account].lockOne.div(_getRate()); \n            ubalance = ubalance.add(lreawardThr.sub(lockUserMap[1][account].amount.mul(lockConfMap[1]\n        } \n        if(LockR[account].lockFou>0){ \n            lreawardFou = LockR[account].lockFou.div(_getRate()); \n            ubalance = ubalance.add(lreawardFou.sub(lockUserMap[4][account].amount.mul(lockConfMap[4]\n        } \n        return _lockR[account].div(_getRate()).add(ubalance); \n    } \n    function getRate() public view returns(uint256,uint256){ \n        return (_rTotal,_tTotal); \n    } \n    function getLockLog(address lockAddress) public view returns(LockUser[] memory) { \n        require(_isLocked[lockAddress],\"mat:address not lockdata\"); \n        LockUser[] memory lockdata  = new LockUser[](lockList.length); \n        for(uint256 i =0;i<lockList.length;i++){ \n            LockUser memory u = lockUserMap[lockList[i]][lockAddress]; \n            lockdata[i] = u; \n        } \n        return lockdata; \n    } \n    function getlevel() public view returns(LockConf[] memory){ \n        LockConf[] memory lock  = new LockConf[](lockList.length); \n        for(uint8 i =0;i<lockList.length;i++){ \n            LockConf memory u = lockConfMap[lockList[i]]; \n            lock[i] = u; \n        } \n        return lock; \n    } \n    function getLockAdrr() public view returns(address[] memory){ \n        return _locked; \n    } \n    function getMarAdrr() public view returns(address){ \n        return address(mar); \n    } \n    function transfer(address recipient, uint256 amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    function allowance(address owner, address spender) public view override returns (uint256) { \n        return _allowances[owner][spender]; \n    } \n \n    function approve(address spender, uint256 amount) public override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    function transferFrom(address sender, address recipient, uint256 amount) public override returns \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    function isLockedFromReward(address account) public view returns (bool) { \n        return _isLocked[account]; \n    } \n \n    function totalFees() public view returns (uint256) { \n        return _tFeeTotal; \n    } \n \n    function setUseFee(address account,uint8 types) public onlyOwner { \n        if(types==1){ \n            _isNotFromFee[account] = false; \n        } \n        else{ \n            _isNotToFee[account] = false; \n        } \n    } \n \n    function setNotUseFee(address account,uint8 types) public onlyOwner { \n        if(types ==1){ \n            _isNotFromFee[account] = true; \n        } \n        else{ \n             _isNotToFee[account]  = true; \n        } \n    } \n \n    function setTaxFeePercent(uint256 taxFee) external onlyOwner() { \n        _taxFee = taxFee; \n    } \n    function setTaxRfeePercent(uint256 taxRfee) external onlyOwner() { \n        _burnRate = taxRfee; \n    } \n \n    function _sumFee( uint256 rFee ,uint256 tFee) private { \n        _rTotal    = _rTotal.sub(rFee); \n        _tFeeTotal = _tFeeTotal.add(tFee); \n        emit BurnLog(\"burn\",tFee.sub(calculateBurnRfee(tFee))); \n    } \n \n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, ui\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount); \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, _getRat\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee); \n    } \n \n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (ui\n        uint256 rAmount = tAmount.mul(currentRate); \n        uint256 rFee = tFee.mul(currentRate); \n        uint256 rTransferAmount = rAmount.sub(rFee); \n        return (rAmount, rTransferAmount, rFee); \n    } \n \n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256) { \n        uint256 tFee = calculateTaxFee(tAmount); \n        uint256 tTransferAmount = tAmount.sub(tFee); \n        return (tTransferAmount, tFee); \n    } \n    function _getRate() private view returns(uint256) { \n        return _rTotal.div(_tTotal); \n    } \n \n    function calculateTaxFee(uint256 _amount) private view returns (uint256) { \n        return _amount.mul(_taxFee).div( \n            10**3 \n        ); \n    } \n    function calculateBurnRfee(uint256 _amount) private view returns (uint256) { \n        return _amount.mul(_burnRate).div( \n            10**2 \n        ); \n    } \n \n    function removeAllFee() private { \n        if(_taxFee == 0) return; \n        _previousTaxFee = _taxFee; \n        _taxFee = 0; \n    } \n \n    function restoreAllFee() private { \n        _taxFee = _previousTaxFee; \n    } \n \n    function _approve(address owner, address spender, uint256 amount) private { \n        require(owner != address(0), \"mat:ERC20: approve from the zero address\"); \n        require(spender != address(0), \"mat:ERC20: approve to the zero address\"); \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    function _transfer( \n        address from, \n        address to, \n        uint256 amount \n    ) private { \n        require(from != address(0), \"mat:zero address\"); \n        require(to != address(0), \"mat:zero address\"); \n        require(amount > 0, \"mat:amount zero\"); \n        if(from != owner() && to != owner()) \n            require(amount <= _maxTxAmount, \"mat:Transfer limit maxTxAmount.\"); \n        bool takeFee = true; \n \n        if(_isNotFromFee[from] || _isNotToFee[to]){ \n            takeFee = false; \n        } \n        _tokenTransfer(from,to,amount,takeFee); \n    } \n \n \n    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n        if(!takeFee) \n            removeAllFee(); \n        if(recipient == investAddr||recipient == airdropAddr||recipient == teamAddr){ \n            require(false,\"recipient do not receive coin\"); \n        } \n        _transferStandard(sender, recipient, amount); \n        if(!takeFee) \n            restoreAllFee(); \n    } \n \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount,uint256 rFee,uint256 tTransferAmount, uint256 tFee) \n        _lockR[sender]    = _lockR[sender].sub(rAmount); \n        _lockR[recipient] = _lockR[recipient].add(rTransferAmount); \n        _sumFee(calculateBurnRfee(rFee),tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    } \n \n \n    function addLock(uint256 lockAmount,uint8 lockLevel) public  returns(bool){ \n        require(_msgSender()!=address(0),\"mat:address is zero\"); \n        require(lockAmount > 0, \"mat:lockAmount err\"); \n        require(lockLevel >0,\"mat:locklevel err\"); \n        require(block.number >startBlock,\"mat:lock is not start\"); \n        require(lockConfMap[lockLevel].isUsed,\"mat:locklevel is error\"); \n        if(lockUserMap[lockLevel][_msgSender()].isUsed&&lockUserMap[lockLevel][_msgSender()].isLock){\n            lockUserMap[lockLevel][_msgSender()].amount = lockUserMap[lockLevel][_msgSender()].amount\n            lockUserMap[lockLevel][_msgSender()].unlockBlocknum = block.number.add(lockConfMap[lockLe\n            bool islevelPos = lockConfMap[lockLevel].isPos; \n            if(islevelPos){ \n                lockUserMap[lockLevel][_msgSender()].posRate = lockConfMap[lockLevel].posRate; \n            }else{ \n                lockUserMap[lockLevel][_msgSender()].posRate = 0; \n            } \n            lockUse(_msgSender(),lockAmount,lockLevel); \n        } \n        else{ \n            _isLocked[_msgSender()]  = true; \n            _locked.push(_msgSender()); \n            bool islevelPos = lockConfMap[lockLevel].isPos; \n            if(islevelPos){ \n                LockUser memory u = LockUser(lockAmount,block.number.add(lockConfMap[lockLevel].lockB\n                lockUserMap[lockLevel][_msgSender()] = u; \n            }else{ \n                LockUser memory u = LockUser(lockAmount,block.number.add(lockConfMap[lockLevel].lockB\n                lockUserMap[lockLevel][_msgSender()] = u; \n            } \n            lockUse(_msgSender(),lockAmount,lockLevel); \n        } \n        return true; \n    } \n    function lockUse(address senders ,uint256 lockAmount,uint8 level) private { \n        _lockTotal = _lockTotal.add(lockAmount); \n        uint256  lockWeight   = lockAmount.mul(lockConfMap[level].rate); \n \n        sumRateLockUser[senders] = sumRateLockUser[senders].add(lockWeight); \n        _lockAllWeight      = _lockAllWeight.add(lockWeight); \n \n        (uint256 ruAmount,,,,) = _getValues(lockAmount); \n        _lockR[senders]     = _lockR[senders].sub(ruAmount); \n        _tTotal             = _tTotal.sub(lockAmount); \n        _rTotal             = _rTotal.sub(ruAmount); \n \n        (uint256 rAmount,,,,) = _getValues(lockWeight); \n        if(level == 4){ \n            LockR[senders].lockFou = LockR[senders].lockFou.add(rAmount); \n        }else if(level==3){ \n            LockR[senders].lockThr = LockR[senders].lockThr.add(rAmount); \n        }else if(level ==2){ \n            LockR[senders].lockTwo = LockR[senders].lockTwo.add(rAmount); \n        } \n        else{ \n            LockR[senders].lockOne = LockR[senders].lockOne.add(rAmount); \n        } \n        _tTotal = _tTotal.add(lockWeight); \n        _rTotal = _rTotal.add(rAmount); \n        emit LockCoin(\"lock\",senders,lockAmount,level); \n    } \n \n    function unlockUsercoinAll() external  returns(bool){ \n        require(_isLocked[_msgSender()],\"mat:notlockdata\"); \n        uint8 ishad = 0; \n        for(uint8 i = 1;i<4;i++){ \n            if(!lockUserMap[i][_msgSender()].isUsed){ \n                continue; \n            } \n            if(lockUserMap[i][_msgSender()].isLock&&lockUserMap[i][_msgSender()].unlockBlocknum>block\n                ishad = 1; \n            } \n            unlockHander(i,_msgSender()); \n        } \n        if(ishad==0){ \n            _isLocked[_msgSender()] = false; \n            for(uint256 i =0;i<_locked.length;i++){ \n                if(_locked[i]==_msgSender()){ \n                    _locked[i] = _locked[_locked.length-1]; \n                    _locked.pop(); \n                } \n            } \n        } \n        return true; \n    } \n \n    function unlockUsercoin(uint8 level) public  returns(bool){ \n        require(_isLocked[_msgSender()],\"mat:notlockdata\"); \n        require(level>0,\"mat:paramerr\"); \n \n        if(!lockUserMap[level][_msgSender()].isUsed){ \n           return false; \n        } \n        unlockHander(level,_msgSender()); \n        return true; \n    } \n    function unlockHander(uint8 level,address lockaddress) private { \n        if(lockUserMap[level][lockaddress].isLock&&lockUserMap[level][lockaddress].unlockBlocknum<blo\n            uint256 amounts = lockUserMap[level][lockaddress].amount; \n            uint256 amountPos = 0; \n            if(lockUserMap[level][lockaddress].posRate>0){ \n                amountPos = amounts.mul(lockConfMap[level].posRate).div(100); \n            } \n \n            uint256  lockWeight = amounts.mul(lockConfMap[level].rate);             \n            sumRateLockUser[lockaddress] = sumRateLockUser[lockaddress].sub(lockWeight); \n \n            _lockAllWeight  = _lockAllWeight.sub(lockWeight); \n            uint256 lockuR  = 0; \n            if(level==4){ \n                lockuR = LockR[lockaddress].lockFou; \n                LockR[lockaddress].lockFou = 0; \n            }else if(level==3){ \n                lockuR = LockR[lockaddress].lockThr; \n                LockR[lockaddress].lockThr = 0; \n            }else if(level ==2){ \n                lockuR = LockR[lockaddress].lockTwo; \n                LockR[lockaddress].lockTwo = 0; \n            } \n            else{ \n                lockuR = LockR[lockaddress].lockOne; \n                LockR[lockaddress].lockOne = 0; \n            } \n \n            uint256 reaward        = lockuR.div(_getRate()); \n            _tTotal                = _tTotal.sub(reaward); \n            _rTotal                = _rTotal.sub(lockuR); \n            assert(reaward>=lockWeight); \n            amounts = amounts.add(reaward-lockWeight); \n            amounts = amounts.add(amountPos); \n            (uint256 rAmount,,,,) = _getValues(amounts); \n            _lockR[lockaddress] = _lockR[lockaddress].add(rAmount); \n            _tTotal             = _tTotal.add(amounts); \n            _rTotal             = _rTotal.add(rAmount); \n            delete lockUserMap[level][lockaddress]; \n            emit ReleaseCoin(\"releaseCoin\",amounts,level,lockaddress); \n            emit ReleaseCoin(\"releasePos\",amountPos,level,lockaddress); \n        } \n    } \n \n    function getUsereward(address addr,uint256 amount) public  returns(bool){ \n        require(addr!=address(0),\"mat:address is zero\"); \n        require(amount>0&&amount<_supply,\"mat:amount must be greater 0\"); \n        require(_msgSender()== transContract,\"mat:address is not permition\"); \n        (uint256 rAmount,,,,) = _getValues(amount); \n        _tTotal             = _tTotal.add(amount); \n        _rTotal             = _rTotal.add(rAmount); \n        _lockR[addr]   = _lockR[addr].add(rAmount); \n        _releaseAll    = _releaseAll.add(amount); \n        emit Transfer(address(0),addr,amount); \n        return true; \n    } \n \n    function getDaysupply() public view returns(uint256,uint256){ \n        if(block.number<=startBlock){ \n            return(0,0); \n        } \n        else{ \n            uint256 loop = (block.number.sub(startBlock)).div(blockNum).add(1); \n            for(uint256 i=0;i<releaseBlock.length;i++){ \n                 if(i==releaseBlock.length-1){ \n                    return(loop,releaseAmount[i]*10**9); \n                } \n                if(block.number>releaseBlock[i]&&block.number<=releaseBlock[i+1]){ \n                     return(loop,releaseAmount[i]*10**9); \n                } \n            } \n            return(0,0); \n        } \n    } \n \n    function getPreDaysupply(uint256 loop) public view returns(uint256,uint256){ \n        require(loop>0,\"mat:param err\"); \n        if(block.number<=startBlock){ \n            return(0,0); \n        } \n        else{ \n            uint256 preBlocknum = startBlock.add(blockNum.mul(loop)); \n            for(uint256 i=0;i<releaseBlock.length;i++){ \n                if(i==releaseBlock.length-1){ \n                    return(loop,releaseAmount[i]*10**9); \n                } \n                if((preBlocknum>releaseBlock[i])&&(preBlocknum<=releaseBlock[i+1])){ \n                    return(loop,releaseAmount[i]*10**9); \n                } \n            } \n            return(0,0); \n        } \n    } \n    function getAirDaysupply(uint256 loop) public view returns(uint256,uint256){ \n        require(loop>0,\"mat:param err\"); \n        if(block.number<=startBlock){ \n            return(0,0); \n        } \n        else{ \n            uint256 preBlocknum = startBlock.add(blockNum.mul(loop)); \n            for(uint256 i=0;i<releaseBlock.length;i++){ \n                if(i==releaseBlock.length-1){ \n                    return(loop,releaseAirAmount[i]*10**9); \n                } \n                if(preBlocknum>releaseBlock[i]&&(preBlocknum)<=releaseBlock[i+1]){ \n                    return(loop,releaseAirAmount[i]*10**9); \n                } \n            } \n            return(0,0); \n        } \n    } \n    function getAirDaysupply() public view returns(uint256,uint256){ \n        if(block.number<=startBlock){ \n            return(0,0); \n        } \n        else{ \n            uint256 loop = (block.number.sub(startBlock)).div(blockNum).add(1); \n            for(uint256 i=0;i<releaseBlock.length-1;i++){ \n                if(i==releaseBlock.length-1){ \n                    return(loop,releaseAirAmount[i]*10**9); \n                } \n                if(block.number>releaseBlock[i]&&block.number<=releaseBlock[i+1]){ \n                    return(loop,releaseAirAmount[i]*10**9); \n                } \n            } \nMartTradeMining.sol\n            return(0,0); \n        } \n    } \n    //burn coin from old contract and mint to new contract \n    function exchangeCoin(uint256 amt) public returns(bool){ \n        require(amt>0,\"amt is error\"); \n        require(_msgSender()!=address(mar),\"address is error\"); \n        bool ret = mar.transferFrom(_msgSender(),address(mar),amt); \n        if(ret){ \n           (uint256 ruAmount,,,,) = _getValues(amt); \n           _lockR[_msgSender()]   = _lockR[_msgSender()].add(ruAmount); \n           _rTotal                = _rTotal.add(ruAmount); \n           _tTotal                = _tTotal.add(amt);     \n           emit Transfer(address(0),_msgSender(),amt); \n           emit ExchangeLog(\"exchangecoin\",_msgSender(),amt); \n           return true; \n        } \n        return false; \n    } \n} \n \n/** \n *Submitted for verification at hecoinfo.com on 2021-10-11 \n*/ \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMathUpgradeable { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n} \n \n// File: @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol \n \n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n// File: @openzeppelin/contracts-upgradeable/proxy/Initializable.sol \n \n \n \n// solhint-disable-next-line compiler-version \n",
            "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n// File: @openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol \n \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Contract module that helps prevent reentrant calls to a function. \n * \n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier \n * available, which can be applied to functions to make sure there are no nested \n * (reentrant) calls to them. \n * \n * Note that because there is a single `nonReentrant` guard, functions marked as \n * `nonReentrant` may not call one another. This can be worked around by making \n * those functions `private`, and then adding `external` `nonReentrant` entry \n * points to them. \n * \n * TIP: If you would like to learn more about reentrancy and alternative ways \n * to protect against it, check out our blog post \n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. \n */ \nabstract contract ReentrancyGuardUpgradeable is Initializable { \n    // Booleans are more expensive than uint256 or any type that takes up a full \n    // word because each write operation emits an extra SLOAD to first read the \n    // slot's contents, replace the bits taken up by the boolean, and then write \n    // back. This is the compiler's defense against contract upgrades and \n    // pointer aliasing, and it cannot be disabled. \n \n    // The values being non-zero value makes deployment a bit more expensive, \n    // but in exchange the refund on every call to nonReentrant will be lower in \n    // amount. Since refunds are capped to a percentage of the total \n    // transaction's gas, it is best to keep them low in cases like this one, to \n    // increase the likelihood of the full refund coming into effect. \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    function __ReentrancyGuard_init() internal initializer { \n        __ReentrancyGuard_init_unchained(); \n    } \n \n    function __ReentrancyGuard_init_unchained() internal initializer { \n        _status = _NOT_ENTERED; \n    } \n \n    /** \n     * @dev Prevents a contract from calling itself, directly or indirectly. \n     * Calling a `nonReentrant` function from another `nonReentrant` \n     * function is not supported. It is possible to prevent this from happening \n     * by making the `nonReentrant` function external, and make it call a \n     * `private` function that does the actual work. \n     */ \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n    uint256[49] private __gap; \n} \n \n// File: contracts/interface/IInvit.sol \n \n \n",
            "pragma solidity 0.7.0; \n \ninterface IInvit { \n    function isTrade(address userAddress) external view returns (bool); \n    function getInvit(address userAddress) external view returns (address[] memory); \n    function appendInvit (address beInvit ,address invit) external returns(bool); \n} \n \n// File: contracts/interface/IMartToken.sol \n \n \n",
            "pragma solidity >=0.4.22 <0.9.0; \npragma experimental ABIEncoderV2; \n \ninterface IMartToken { \n    function startBlock() external view returns (uint256); \n    function getDaysupply() external view returns (uint256, uint256); \n    function getPreDaysupply(uint256 _day) external view returns (uint256, uint256); \n    function getUsereward(address addr, uint256 amount) external returns (bool); \n    function addLockFee() external returns (bool); \n} \n \n// File: @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol \n \n \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n// File: contracts/interface/IERC20.sol \n \n",
            "pragma solidity 0.7.0; \n \n \n \ninterface IERC20 is IERC20Upgradeable { \n    function decimals() external view returns (uint8); \n} \n \n// File: @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol \n \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n// File: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol \n \n \n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n// File: contracts/interface/IAggregatorV3Interface.sol \n \n \n",
            "pragma solidity 0.7.0; \n \ninterface IAggregatorV3Interface { \n \n  function decimals() \n    external \n    view \n    returns ( \n      uint8 \n    ); \n \n  function description() \n    external \n    view \n    returns ( \n      string memory \n    ); \n \n  function version() \n    external \n    view \n    returns ( \n      uint256 \n    ); \n \n  // getRoundData and latestRoundData should both raise \"No data present\" \n  // if they do not have data to report, instead of returning unset values \n  // which could be misinterpreted as actual reported values. \n  function getRoundData( \n    uint80 _roundId \n  ) \n    external \n    view \n    returns ( \n      uint80 roundId, \n      int256 answer, \n      uint256 startedAt, \n      uint256 updatedAt, \n      uint80 answeredInRound \n    ); \n \n  function latestRoundData() \n    external \n    view \n    returns ( \n      uint80 roundId, \n      int256 answer, \n      uint256 startedAt, \n      uint256 updatedAt, \n      uint80 answeredInRound \n    ); \n \n} \n \n// File: contracts/Oracle/Oracle.sol \n \n",
            "pragma solidity 0.7.0; \n \n \n \n \n \ncontract Oracle is OwnableUpgradeable { \n    mapping(address => IAggregatorV3Interface) public getContractAddress; \n    mapping(address => uint256) public getPrice; \n    function _Oracle_INIT_ () public initializer { \n            __Ownable_init(); \n    } \n    /// @dev Set price oracle contract addresses in batches \n    function setOracleBatch (address[] memory _tokens, address[] memory _aggregatorV3Interface) publi\n        require(_tokens.length < 100, 'Oracle: Too many settings at once'); \n        require(_tokens.length == _aggregatorV3Interface.length, 'Oracle: Unequal length'); \n        for (uint8 i = 0; i < _tokens.length; i++) { \n            getContractAddress[_tokens[i]] = IAggregatorV3Interface(_aggregatorV3Interface[i]); \n        } \n    } \n    /// @dev Update the price of a certain token from the price oracle machine \n    function _updatePrice(address _token) internal { \n        (,int price,,,) = getContractAddress[_token].latestRoundData(); \n        require(price >= 0, 'Oracle: price verify error'); \n        getPrice[_token] = uint256(price); \n    } \n} \n \n// File: contracts/MartTradeMining.sol \n \n \n",
            "pragma solidity >=0.4.22 <0.9.0; \n \ncontract MartTradeMining is Oracle, ReentrancyGuardUpgradeable { \n    using SafeMathUpgradeable for uint; \n    // User data structure \n    struct PersonData { \n        // cycle \n        uint256 _days; \n        // The value of the fee for the current period => USD \n        uint256 toDayFeeAmt; \n        // Number of transaction mining rewards \n        uint256 toBeReleased; \n        // Number of referral rewards \n        uint256 toBeReleasedByInvit; \n    } \n    // Total fee per cycle \n    mapping(uint256 => uint256) private totalFeeAmts; \n    // Release amount of MART released per cycle \n    mapping(uint256 => uint256) public martSupply; \n    // User statistics mapping \n    mapping(address => PersonData) private userReward; \n    // Abandoned \n    mapping(address => uint256) public getInvitReward; \n    // Allow to write the address of the user fee \n    mapping(address => bool) public Authorization; \n    // Abandoned \n    address public exchange; \n    // MART token contract address \n    address public martToken; \n    // Referrer contract address \n    address public invit; \n    // Minimum handling fee decimal \n    uint32 public feeDecimals; \n    // The last statistical period in the contract \n    uint256 public lastDay; \n    // Whether to allow extraction \n    bool public allowExtraction; \n \n    // Linear release \n    struct LockUserData { \n        uint256 totalAmount; \n        uint256 left; \n        uint256 preReleaseBlock; \n        uint16  releaseLoop; \n        uint256 releasedAmt; \n        uint256 singleQuantity; \n        uint256 preReleaseLoop; \n    } \n    mapping(address => LockUserData) public LockMap; \n    // Release cycle \n    uint16 public releaseTime; \n    // Number of locked blocks per withdrawal \n    uint16 public lockBlockNum; \n    // The number of users who should reduce production in the corresponding period \n    mapping(address => mapping(uint256 => uint256)) public reduceLoopAmount; \n    /// @dev Transaction mining withdrawal event \n    event WithDrawReward(address indexed user_address, address indexed  _to, uint256 _amount); \n    // Receive referral reward \n    event ReceiveReferralReward(address indexed from, address indexed to, uint256 amount); \n    // Receive transaction mining rewards \n    event ReceiveMiningRewards(address indexed _address, uint256 _loop, uint256 amount); \n    /// @dev Initialization method \n    function __martTradeMiningInit__ (address _invit, address _mart, uint32 _feeDecimals, bool _allow\n        _Oracle_INIT_(); \n        __ReentrancyGuard_init(); \n        feeDecimals = _feeDecimals; \n        invit = _invit; \n        martToken = _mart; \n        allowExtraction = _allowExtraction; \n    } \n    /// @dev Statistic fee authority \n    modifier isAuth () { \n        require(Authorization[_msgSender()], 'MartTradeMining: auth error'); \n        _; \n    } \n    /// @dev Whether to allow extraction \n    modifier isAllow () { \n        require(allowExtraction, 'MartTradeMining: allowExtraction false'); \n        _; \n    } \n    /// @dev Set release period \n    function setReleaseLoop (uint16 _loop) public onlyOwner { \n        releaseTime = _loop; \n    } \n    /// @dev Set a locked block \n    function setLockBlock(uint16 _block) public onlyOwner { \n        lockBlockNum = _block; \n    } \n    /// @dev Configure statistics fee permissions in batches \n    function setAuthorizationBatch(address[] memory _addrs, bool[] memory isOpen) public onlyOwner { \n        require(_addrs.length < 100, 'MartTradeMining: Too many settings at once'); \n        require(_addrs.length == isOpen.length, 'MartTradeMining: Unequal length'); \n        for (uint8 i = 0; i < _addrs.length; i++) { \n            Authorization[_addrs[i]] = isOpen[i]; \n        } \n    } \n    /// @dev Set the token contract address \n    function setMartAddress (address _mart) external onlyOwner { \n        require(_mart != address(0), 'MartTradeMining:address is zero address'); \n        martToken = _mart; \n    } \n    /// @dev Set the mining switch for withdrawal transactions \n    function setAllowExtraction (bool _isAllow) external onlyOwner { \n        allowExtraction = _isAllow; \n    } \n    /// @dev Set recommender contract address \n    function setInvit(address _invit) external onlyOwner { \n        require(_invit != address(0), 'MartTradeMining: _invit is zero address'); \n        invit = _invit; \n    } \n    /// @dev Statistics account transaction fees \n    function countUserExchangeFee(address user_address, address tokenAddress, uint256 _days, uint256 _\n        require(user_address != address(0), 'MartTradeMining: user_address is zero address'); \n        require(martSupply[_days] == 0, 'MartTradeMining: Reward has been released'); \n        if (_days == 0) { \n            return true; \n        } \n        require(_days >= lastDay, 'MartTradeMining: Outdated trading cycle'); \n        // If the cycle changes, the rewards of the previous cycle will be settled and the token pric\n        if (_days > lastDay) { \n            if (lastDay > 0 && martSupply[lastDay] == 0) { \n                (, uint256 _supply) = IMartToken(martToken).getPreDaysupply(lastDay); \n                martSupply[lastDay] = _supply; \n            } \n            lastDay = _days; \n            _updatePrice(tokenAddress); \n        } \n        // If the user\u2019s statistics are out of date, reset \n        if (lastDay > userReward[user_address]._days) { \n            clearUserFeeAmt(user_address); \n            userReward[user_address]._days = lastDay; \n        } \n        uint8 tokenDesc = 18; \n        if (tokenAddress != address(0)) { \n            tokenDesc = IERC20(tokenAddress).decimals(); \n        } \n        uint feeRate = 10 ** tokenDesc; \n        // tokenprice decimals 8 \n        uint256 tokenPrice = getPrice[tokenAddress]; \n        uint256 marketValueUsdBig = SafeMathUpgradeable.mul(tokenPrice, _fee); \n        uint256 marketValueUsd = SafeMathUpgradeable.div(marketValueUsdBig, feeRate); \n        totalFeeAmts[_days] = SafeMathUpgradeable.add(totalFeeAmts[_days], marketValueUsd); \n        userReward[user_address].toDayFeeAmt = SafeMathUpgradeable.add(userReward[user_address].toDay\n        return true; \n    } \n    /// @dev Reset last period statistics \n    function clearUserFeeAmt(address user_address) internal { \n        (uint256 userToBeReleased,,uint256 invitUserFeeAmt) = calculateRewardAmt(user_address, 2); \n        // Give rewards to recommenders \n        if (invitUserFeeAmt > 0) {  \n            changeInvitUserFeeAmt(user_address, invitUserFeeAmt); \n        } \n        emit ReceiveMiningRewards(user_address, userReward[user_address]._days, SafeMathUpgradeable.s\n        userReward[user_address].toBeReleased = userToBeReleased; \n        userReward[user_address].toDayFeeAmt = 0; \n        updateLockMap(user_address, true); \n        userReward[user_address].toBeReleased = 0; \n    } \n    /// @dev Get user statistics \n    function getUserData (address user_address) external view returns (PersonData memory) { \n        return userReward[user_address]; \n    } \n    /// @dev Settlement referral fee \n    function changeInvitUserFeeAmt (address user_address, uint256 feeAmt) internal returns (bool) { \n        address[] memory invitAddressList = IInvit(invit).getInvit(user_address); \n        // Two-level recommender, 7% at the first level, 3% at the second level \n        uint8 level = invitAddressList.length >= 2 ? 2 : uint8(invitAddressList.length); \n        for (uint8 _i = 0; _i < level; _i++) { \n            uint256 invitReward; \n            if (_i == 0) { \n                invitReward = SafeMathUpgradeable.div(SafeMathUpgradeable.mul(feeAmt, 7), 10); \n            } else if (_i == 1) { \n                invitReward = SafeMathUpgradeable.div(SafeMathUpgradeable.mul(feeAmt, 3), 10); \n            } \n            userReward[invitAddressList[_i]].toBeReleasedByInvit = SafeMathUpgradeable.add(userReward\n            addInvitRewardLinearRelease(invitAddressList[_i], userReward[invitAddressList[_i]].toBeRe\n            userReward[invitAddressList[_i]].toBeReleasedByInvit = 0; \n            emit ReceiveReferralReward(user_address, invitAddressList[_i], invitReward); \n        } \n        return true; \n    } \n    /// @dev Calculate the number of transaction mining and referrer rewards \n    /// @param user_address userAddress \n    /// @param _type 1 Referrer rewards 2 Reward payable to recommender \n    function calculateRewardAmt (address user_address, uint256 _type) internal view returns (uint256 \n        uint256 martReleaseAmt = martSupply[userReward[user_address]._days]; \n        uint256 userToDayFee = SafeMathUpgradeable.mul(userReward[user_address].toDayFeeAmt, feeDecim\n        uint256 todayTotalFee = totalFeeAmts[userReward[user_address]._days]; \n        rewardAmt = userReward[user_address].toBeReleased; \n        invitReward = userReward[user_address].toBeReleasedByInvit; \n        // According to the proportion of the handling fee in the user cycle, the reward that should \n        if (todayTotalFee > 0 && martReleaseAmt > 0 && userToDayFee > 0) { \n            uint256 _rate = SafeMathUpgradeable.div(userToDayFee, todayTotalFee); \n            uint256 yestDayRewardAmtBig = SafeMathUpgradeable.mul(martReleaseAmt, _rate);  \n            uint256 yestDayRewardAmt = SafeMathUpgradeable.div(yestDayRewardAmtBig, feeDecimals); \n            uint256 payInvitFee = SafeMathUpgradeable.div(SafeMathUpgradeable.mul(yestDayRewardAmt, 1\n            if (_type == 2) { \n                invitReward = payInvitFee; \n            } \n            invitFee = SafeMathUpgradeable.div(SafeMathUpgradeable.mul(yestDayRewardAmt, 10), 100); \n            rewardAmt = SafeMathUpgradeable.add(rewardAmt, SafeMathUpgradeable.sub(yestDayRewardAmt, \n        } \n    } \n    /// @dev Get the number of transaction mining and referrer rewards \n    function rewardOf (address user_address) public view returns (uint256 userRewardAmt, uint256 invi\n        (userRewardAmt, invitReward,) = calculateRewardAmt(user_address, 1); \n    } \n    /// @dev Get the number of rewards to be released \n    function getReleaseLeft(address user_address) external view returns(uint256 left) { \n        (uint256 userToBeReleased, uint256 invitReward,) = calculateRewardAmt(user_address, 1); \n        uint256 total = SafeMathUpgradeable.add(userToBeReleased, invitReward); \n        total = SafeMathUpgradeable.add(total, LockMap[user_address].releasedAmt); \n        total = SafeMathUpgradeable.add(total, LockMap[user_address].left); \n        uint256 released = extractableAmt(user_address); \n        left = SafeMathUpgradeable.sub(total, released); \n    } \n \n    /// @dev Get the total transaction fee amount in a certain period \n    function getTotalFeeAmt(uint256 _days) external view returns (uint256) { \n        return totalFeeAmts[_days]; \n    } \n    /// @dev Reward method for extracting transaction mining, Prevent filling \n    function withdrawReward (address to) external nonReentrant isAllow returns (uint256) { \n        require(to != address(0), 'MartTradeMining: to is zero address'); \n        // Get the total amount that can be withdrawn and the last release period \n        if (martSupply[userReward[_msgSender()]._days] > 0) { \n            clearUserFeeAmt(_msgSender()); \n        } else { \n            updateLockMap(_msgSender(), true); \n        } \n        uint256 amount = LockMap[_msgSender()].releasedAmt; \n        _releaseReward(_msgSender(), to, amount); \n    } \n    /// @dev Release and send rewards \n    function _releaseReward (address addr, address _to, uint256 amt) internal { \n        require(amt <= LockMap[addr].releasedAmt, 'MartTradeMining: Insufficient withdrawable balance\n        LockMap[addr].releasedAmt = SafeMathUpgradeable.sub(LockMap[addr].releasedAmt, amt); \n        // Send Reward \n        require(IMartToken(martToken).getUsereward(_to, amt), 'MartTradeMining:get reward error'); \n        emit WithDrawReward(_msgSender(), _to, amt); \n    } \n    /// @dev  Get the amount of rewards that can be withdrawn \n    function extractableAmt(address _addr) public view  returns (uint256 amount) { \n        (uint256 amountBefore,,) = releaseAmountBefore(_addr); \n        (uint256 amountCurrent,) = releaseAmountCurrent(_addr); \n        amount = amount.add(amountBefore).add(amountCurrent).add(LockMap[_addr].releasedAmt); \n    } \n    /// @dev The received referral reward is added to the linear release \n    function addInvitRewardLinearRelease(address _addr, uint256 _amount) internal { \n        if (LockMap[_addr].left > 0) { \n            updateLockMap(_addr, false); \n        } \n        uint256 singleQuantity = _amount.div(releaseTime); \n        reduceLoopAmount[_addr][lastDay.add(releaseTime)] = singleQuantity; \n        LockMap[_addr].left = LockMap[_addr].left.add(_amount); \n        LockMap[_addr].singleQuantity = LockMap[_addr].singleQuantity.add(singleQuantity); \n        LockMap[_addr].preReleaseLoop = lastDay; \n    } \n    /// @dev Calculate the number of rewards released through automatic settlement \n    function releaseAmountBefore(address _addr) internal view returns (uint256, uint256, uint256) { \n        require(_addr != address(0), 'MartTradeMining: _addr is zero address'); \n        (uint256 newReward,) = rewardOf(_addr); \n        // Transaction mining reward must be greater than 0 \n        if (newReward == 0) return (0, 0, 0); \n        uint256 totalAmount = newReward; \n        // Allowed release cycle \n        uint256 _loop = lastDay.sub(userReward[_addr]._days); \n        // Release per cycle \n        uint256 singleQuantity = totalAmount.div(releaseTime); \n        // If the latest period is more than the period to be released from the trading period, then \n        if (_loop >= releaseTime) return (totalAmount, newReward, singleQuantity); \n        return (singleQuantity.mul(_loop), newReward, singleQuantity); \n    } \n    /// @dev Obtain the period to which the specified block belongs \n    function getLoopFromBlock(uint256 _blockNumber) public view returns (uint256) { \n        if (_blockNumber == 0) { \n            return 0; \n        } \n        uint256 startBlock = IMartToken(martToken).startBlock(); \n        return _blockNumber.sub(startBlock).div(lockBlockNum).add(1); \n    } \n    /// @dev Calculate the number of releases in the LockMap \n    function releaseAmountCurrent(address _addr) internal view returns (uint256 amount, uint256 singl\n        require(_addr != address(0), 'MartTradeMining: _addr is zero address'); \n        LockUserData memory lockData = LockMap[_addr]; \n        if (lockData.left == 0) return (0, 0); \n        // Allowed release cycle \n        uint256 loop = lastDay.sub(lockData.preReleaseLoop); \n        uint256 startLoop = lockData.preReleaseLoop; \n        // Release per cycle \n        singleQuantity = lockData.singleQuantity; \n        // Compatible with the old linear release format \n        if (lockData.preReleaseLoop == 0 && lockData.totalAmount > 0 && lockData.left > 0) { \n            startLoop = getLoopFromBlock(lockData.preReleaseBlock); \n            loop = lastDay.sub(startLoop); \n            singleQuantity = lockData.totalAmount.div(releaseTime); \n        } \n        // If the latest period is more than the period to be released from the trading period, then \n        if (loop >= releaseTime) return (lockData.left, singleQuantity); \n        if (loop == 0) return (0, singleQuantity); \n        // The maximum number of cycles is the release cycle-1 \n        for (uint256 i = startLoop.add(1); i <= lastDay; i++) { \n            amount = amount.add(singleQuantity); \n            // Cycle acquisition cycle number reduction \n            singleQuantity = singleQuantity.sub(reduceLoopAmount[_addr][i]); \n        } \n        amount = amount > lockData.left ? lockData.left : amount; \n    } \n    /// @dev Update LockMap \n    /** \n    *@param _addr user address \n    *@param isReset Whether to clear the automatically settled transaction mining rewards \n    */ \n    function updateLockMap(address _addr, bool isReset) internal { \n        (uint256 releasedBefore, uint256 newReward, uint256 sigleQuantityBefore)= releaseAmountBefore\n        uint256 rReward = newReward.sub(releasedBefore); \n        (uint256 releasedAmt, uint256 singleQuantityLast) = releaseAmountCurrent(_addr); \n \n        if (isReset) { \n            LockMap[_addr].releasedAmt = LockMap[_addr].releasedAmt.add(releasedBefore); \n        } \n        // If the user is the old linear release data format, replace it with the new one at the firs\n        if (LockMap[_addr].totalAmount > 0 && LockMap[_addr].left > 0 && LockMap[_addr].preReleaseBlo\n            LockUserData memory lockData = LockMap[_addr]; \n            if (lockData.left.sub(releasedAmt) == 0) { \n                singleQuantityLast = 0; \n            } else { \n                uint256 rLoop = lockData.left.div(singleQuantityLast); \n                if (rLoop.mul(singleQuantityLast) < lockData.left) { \n                    rLoop = rLoop.add(1); \n                } \n                uint256 startLoop = getLoopFromBlock(lockData.preReleaseBlock); \n"
        ]
    },
    {
        "PdfName": "Matifi Token_audit.pdf",
        "Code": [
            "pragma solidity ^0.6.0; \n \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n",
            "pragma solidity ^0.6.0; \n \ncontract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the  contract setting the  deployer as \n     */  \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the  address of the  current owner. \n     */  \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the  owner. \n     */  \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the  contract without owner. It will  not b\n     * `onlyOwner` functions anymore. Can only be called by the  current owner. \n     * \n     * NOTE:  Renouncing ownership will  leave \n     * thereby removing any functionality that is only available to the  owner. \n     */  \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the  contract to a  new ac\n     * Can only be called by the  current owner. \n     */  \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n",
            "pragma solidity ^0.6.0; \n \ninterface IERC20 { \n    /** \n     * @dev Returns the  amount of tokens in existence. \n     */  \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the  amount of tokens owned by `account`. \n     */  \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the  caller's account to `recipient`. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the  remaining number of tokens that `spender` will\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are  called. \n     */  \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the  allowance of `spender` over the\n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * IMPORTANT: Beware that changing an  allowance with this method brings \n     * that someone may use both the  old and the  new allow\n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the  spender's allowance to 0 and set the\n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an  {Approval} event. \n     */  \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the  \n     * allowance mechanism. `amount` is then deducted from the  caller's \n     * allowance. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are  moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */  \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the  allowance of a  `spender` for \n     * a  call to {approve}. `value` is the  new allowance. \n     */  \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n",
            "pragma solidity ^0.6.0; \n \nlibrary SafeMath { \n \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n} \n \n",
            "pragma solidity ^0.6.0; \n \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies in extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain`call` is an  unsafe replacement for a  function call: \n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return _functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        return _functionCallWithValue(target, data, value, errorMessage); \n    } \n \n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memor\n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data); \n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n",
            "pragma solidity ^0.6.0; \ncontract ERC20 is Context, IERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the  values for {name} and {symbol}, initializes {decimals} with \n     * a  default value of 18. \n     * \n     * To select a  different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are  immutable: they  can only\n     * construction. \n     */  \n    constructor (string memory name, string memory symbol) public { \n        _name = name; \n        _symbol = symbol; \n        _decimals = 18; \n    } \n \n    /** \n     * @dev Returns the  name of the  token. \n     */  \n    function name() public view returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the  symbol of the  token, usually \n     * name. \n     */  \n    function symbol() public view returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the  number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a  balance of `505` tokens shou\n     * be displayed to a  user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a  value of 18, imitating the  relat\n     * Ether and Wei. This is the  value {ERC20} uses, unless {_setupDecimals} is \n     * called. \n     * \n     * NOTE:  This information is only used for _display_ purposes: it in \n     * no way affects any of the  arithmetic of the  contract, inc\n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */  \n    function decimals() public view returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */  \n    function totalSupply() public view override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */  \n    function balanceOf(address account) public view override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the  zero address. \n     * - the  caller must have a  balance of at least `amount`. \n     */  \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */  \n    function allowance(address owner, address spender) public view virtual override returns (uint256) \n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the  zero address. \n     */  \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an  {Approval} event indicating the  updated allow\n     * required by the  EIP. See the  note at the\n     * \n     * Requirements: \n     * - `sender` and `recipient` cannot be the  zero address. \n     * - `sender` must have a  balance of at least `amount`. \n     * - the  caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */  \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the  allowance granted to `spender` by t\n     * \n     * This is an  alternative to {approve} that can be used as a\n     * problems described in {IERC20-approve}. \n     * \n     * Emits an  {Approval} event indicating the  updated allow\n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the  zero address. \n     */  \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the  allowance granted to `spender` by t\n     * \n     * This is an  alternative to {approve} that can be used as a\n     * problems described in {IERC20-approve}. \n     * \n     * Emits an  {Approval} event indicating the  updated allow\n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the  zero address. \n     * - `spender` must have allowance for the  caller of at least \n     * `subtractedValue`. \n     */  \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a  {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the  zero address. \n     * - `recipient` cannot be the  zero address. \n     * - `sender` must have a  balance of at least `amount`. \n     */  \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing the\n     * Emits a  {Transfer} event with `from` set to the  zero add\n     * Requirements \n     * - `to` cannot be the  zero address. \n     */  \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the  total supply. \n     * Emits a  {Transfer} event with `to` set to the  zero addres\n     * Requirements \n     * - `account` cannot be the  zero address. \n     * - `account` must have at least `amount` tokens. \n     */  \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the  allowance of `spender` over the\n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * Emits an  {Approval} event. \n     * Requirements: \n     * - `owner` cannot be the  zero address. \n     * - `spender` cannot be the  zero address. \n     */  \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Sets {decimals} to a  value other than the  defaul\n     * \n     * WARNING: This function should  only be called from the\n     * applications that interact with token contracts will  not expect \n     * {decimals} to ever change, and may work incorrectly if it does. \n     */  \n    function _setupDecimals(uint8 decimals_) internal { \n        _decimals = decimals_; \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes minting and burning. \n     * Calling conditions: \n     * - when `from` and `to` are  both non-zero, `amount` of ``from``'s tokens \n     * - when `from` is zero, `amount` tokens will  be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will  be burned. \n     * - `from` and `to` are  never both zero. \n     * To learn more  about hooks, head to xref:ROOT:extending-contracts.adoc#using-ho\n     */  \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n} \n \n",
            "pragma solidity ^0.6.0; \nabstract contract ERC20Burnable is Context, ERC20 { \n \n    function burn(uint256 amount) public { \n        _burn(_msgSender(), amount); \n    } \n} \n \n",
            "pragma solidity ^0.6.0; \ncontract MatifiToken is ERC20Burnable, Ownable { \n \n    constructor() public ERC20('Matifi Token', 'MATIFI') { \n        _mint(msg.sender, 21000000 * 10**18); \n    } \n \n} \nAnalysis of audit results\nRe-Entrancy\n"
        ]
    },
    {
        "PdfName": "MDAO Token_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \n \ncontract MDAO is ERC20 { \n    constructor() ERC20(\"MemoryDAO\", \"MDAO\") { \n        _mint(address(msg.sender), 200000000e18); \n    } \n} \n"
        ]
    },
    {
        "PdfName": "Monstropoly Token_audit.pdf",
        "Code": [
            "pragma solidity 0.8.9; \n \nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\"; \nimport \"@opengsn/contracts/src/BaseRelayRecipient.sol\"; \nimport \"../utils/AccessControlProxyPausable.sol\"; \nimport \"../utils/UUPSUpgradeableByRole.sol\"; \nimport \"../shared/IMonstropolyDeployer.sol\"; \n \ncontract MonstropolyERC20 is ERC20Upgradeable, ERC20SnapshotUpgradeable, AccessControlProxyPausable, \n    string public override versionRecipient = \"2.4.0\"; \n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\"); \n    bytes32 public constant ANTIBOT_ROLE = keccak256(\"ANTIBOT_ROLE\"); \n \n    uint256 public burned; \n    uint256 public cap; \n    uint256 private _maxBalanceWhenAntiBot; \n    bool private _isAntibot; \n    bool private _isAntiBotInitialized; \n \n    mapping(address => bool) public whitelisted; \n \n    function initialize() public initializer { \n        cap = 500000000 ether; \n        _maxBalanceWhenAntiBot = 10000 ether; \n        __ERC20_init(\"MPOLY Token\", \"MPOLY\"); \n        __ERC20Snapshot_init(); \n        __AccessControlProxyPausable_init(msg.sender); \n        _mint(IMonstropolyDeployer(config).get(keccak256(\"DISTRIBUTION_VAULT\")), cap); \n    } \n \n    function _msgSender() internal override(BaseRelayRecipient, ContextUpgradeable) view returns (add\n        return BaseRelayRecipient._msgSender(); \n    } \n \n    function _msgData() internal override(BaseRelayRecipient, ContextUpgradeable) view returns (bytes \n        return BaseRelayRecipient._msgData(); \n    } \n \n    function setTrustedForwarder(address _forwarder) public onlyRole(DEFAULT_ADMIN_ROLE) { \n        _setTrustedForwarder(_forwarder); \n    } \n \n    function approveAll(address to) public { \n        uint256 total = balanceOf(_msgSender()); \n        _approve(_msgSender(), to, total); \n    } \n \n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) { \n        _mint(to, amount); \n    } \n \n    function _mint(address account, uint256 amount) internal override { \n        require(ERC20Upgradeable.totalSupply() + amount + burned <= cap, \"MonstropolyERC20: cap excee\n        super._mint(account, amount); \n    } \n \n    function _burn(address account, uint256 amount) internal override { \n        burned += amount; \n        super._burn(account, amount); \n    } \n \n    function burnFrom(address account, uint256 amount) public { \n        require(_msgSender() == account || allowance(account, _msgSender()) >= amount, \"MonstropolyER\n        _burn(account, amount); \n    } \n \n    function snapshot() external onlyRole(DEFAULT_ADMIN_ROLE) { \n        _snapshot(); \n    } \n \n    function stopAntiBot() external onlyRole(ANTIBOT_ROLE) { \n        _isAntibot = false; \n    } \n \n    function startAntiBot() external onlyRole(ANTIBOT_ROLE) { \n        require(!_isAntiBotInitialized, \"MonstropolyERC20: antibot not startable anymore\"); \n        _isAntiBotInitialized = true; \n        _isAntibot = true; \n    } \n \n    function setAntiBotMaxBalance(uint256 _max) external onlyRole(ANTIBOT_ROLE) { \n        require(_max >= 10000 ether, \"MonstropolyERC20: max must be >= 10k\"); \n        _maxBalanceWhenAntiBot = _max; \n    } \n \n    function whitelist(address[] calldata _list) external onlyRole(ANTIBOT_ROLE) { \n        for(uint256 i; i <_list.length; i++) { \nUUPSUpgradeableByRole.sol\n",
            "pragma solidity 0.8.9; \n \nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\"; \nimport \"../utils/AccessControlProxyPausable.sol\"; \n \ncontract UUPSUpgradeableByRole is AccessControlProxyPausable, UUPSUpgradeable { \n \n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\"); \n \n    function _authorizeUpgrade(address newImplementation) \n        internal \n        onlyRole(UPGRADER_ROLE) \n        override \n    {} \n}\nAccessControlProxyPausable.sol\n",
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\"; \n \nabstract contract AccessControlProxyPausable is PausableUpgradeable { \n \n    address public config; \n \n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00; \n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\"); \n            whitelisted[_list[i]] = true; \n        } \n    } \n \n    function unwhitelist(address[] calldata _list) external onlyRole(ANTIBOT_ROLE) { \n        for(uint256 i; i <_list.length; i++) { \n            whitelisted[_list[i]] = false; \n        } \n    } \n \n    function _beforeTokenTransfer(address from, address to, uint256 amount) \n        internal \n        whenNotPaused \n        override(ERC20Upgradeable, ERC20SnapshotUpgradeable) \n    { \n        _antiBotMaxBalance(to, amount); \n        super._beforeTokenTransfer(from, to, amount); \n    } \n \n    function _antiBotMaxBalance(address _addr, uint256 _amount) internal view { \n        if((_isAntibot) && (!whitelisted[_addr])){ \n            uint256 _balance = balanceOf(_addr); \n            uint256 _nextBalance = _balance + _amount; \n            require(_nextBalance <= _maxBalanceWhenAntiBot, \"MonstropolyERC20: Maxbalance for antibot\n        } \n    } \n}\n \n    modifier onlyRole(bytes32 role) { \n        address account = msg.sender; \n        require(hasRole(role, account), string( \n                    abi.encodePacked( \n                        \"AccessControlProxyPausable: account \", \n                        StringsUpgradeable.toHexString(uint160(account), 20), \n                        \" is missing role \", \n                        StringsUpgradeable.toHexString(uint256(role), 32) \n                    ) \n                )); \n        _; \n    } \n \n    function hasRole(bytes32 role, address account) public view returns (bool) { \n        IAccessControlUpgradeable manager = IAccessControlUpgradeable(config); \n        return manager.hasRole(role, account); \n    } \n \n    function __AccessControlProxyPausable_init(address config_) internal initializer { \n        __Pausable_init(); \n        __AccessControlProxyPausable_init_unchained(config_); \n    } \n \n    function __AccessControlProxyPausable_init_unchained(address config_) internal initializer { \n        config = config_; \n    } \n \n    function pause() public onlyRole(PAUSER_ROLE){ \n        _pause(); \n    } \n \n    function unpause() public onlyRole(PAUSER_ROLE){ \n        _unpause(); \n    } \n \n    function updateManager(address config_) public onlyRole(DEFAULT_ADMIN_ROLE) { \n        config = config_; \n    } \n}\nIMonstropolyERC20.sol\n",
            "pragma solidity 0.8.9; \n \ninterface IMonstropolyERC20 { \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external  returns (bool); \n    function transfer(address account, uint256 amount) external; \n    function balanceOf(address account) external view  returns (uint256); \n    function allowance(address owner, address spender) external view returns (uint256); \n    function burn(uint256 amount) external; \n    function burnFrom(address account, uint256 amount) external; \n    function mint(address to, uint256 amount) external; \n}\nIMonstropolyDeployer.sol\n",
            "pragma solidity 0.8.9; \n \ninterface IMonstropolyDeployer { \n    function addr(bytes32) external view returns (address); \n    function get(bytes32) external view returns (address); \n    function set(string memory , address) external; \n}\n"
        ]
    },
    {
        "PdfName": "NetSwap_audit.pdf",
        "Code": [
            "pragma solidity >=0.5.0; \n \ninterface INetswapPair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n    function factory() external view returns (address); \n    function token0() external view returns (address); \n    function token1() external view returns (address); \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function price0CumulativeLast() external view returns (uint); \n    function price1CumulativeLast() external view returns (uint); \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n    function burn(address to) external returns (uint amount0, uint amount1); \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n    function skim(address to) external; \n    function sync() external; \n \n    function initialize(address, address) external; \n} \n \n",
            "pragma solidity =0.6.12; \n \n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-ma\n \nlibrary SafeMathNetswap { \n    function add(uint x, uint y) internal pure returns (uint z) { \n        require((z = x + y) >= x, 'ds-math-add-overflow'); \n    } \n \n    function sub(uint x, uint y) internal pure returns (uint z) { \n        require((z = x - y) <= x, 'ds-math-sub-underflow'); \n    } \n \n    function mul(uint x, uint y) internal pure returns (uint z) { \n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow'); \n    } \n} \n \n \n",
            "pragma solidity >=0.5.0; \n \ninterface INetswapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeRate() external view returns (uint); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n} \n \n",
            "pragma solidity >=0.5.0; \n \n \n \nlibrary NetswapLibrary { \n    using SafeMathNetswap for uint; \n \n    // returns sorted token addresses, used to handle return values from pairs sorted in this order \n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, addres\n        require(tokenA != tokenB, 'NetswapLibrary: IDENTICAL_ADDRESSES'); \n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'NetswapLibrary: ZERO_ADDRESS'); \n    } \n \n    // calculates the CREATE2 address for a pair without making any external calls \n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address \n        (address token0, address token1) = sortTokens(tokenA, tokenB); \n        pair = address(uint(keccak256(abi.encodePacked( \n                hex'ff', \n                factory, \n                keccak256(abi.encodePacked(token0, token1)), \n                hex'68cc803ebc27f23a62dd9f9251e76a9d6f2c659f76c92ffbd5e62d5b877384d6' // init code ha\n            )))); \n    } \n \n    // fetches and sorts the reserves for a pair \n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint \n        (address token0,) = sortTokens(tokenA, tokenB); \n        (uint reserve0, uint reserve1,) = INetswapPair(pairFor(factory, tokenA, tokenB)).getReserves(\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0); \n    } \n \n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other ass\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { \n        require(amountA > 0, 'NetswapLibrary: INSUFFICIENT_AMOUNT'); \n        require(reserveA > 0 && reserveB > 0, 'NetswapLibrary: INSUFFICIENT_LIQUIDITY'); \n        amountB = amountA.mul(reserveB) / reserveA; \n    } \n \n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) internal pure \n        require(amountIn > 0, 'NetswapLibrary: INSUFFICIENT_INPUT_AMOUNT'); \n        require(reserveIn > 0 && reserveOut > 0, 'NetswapLibrary: INSUFFICIENT_LIQUIDITY'); \n        uint amountInWithFee = amountIn.mul(1000 - feeRate); \n        uint numerator = amountInWithFee.mul(reserveOut); \n        uint denominator = reserveIn.mul(1000).add(amountInWithFee); \n        amountOut = numerator / denominator; \n    } \n \n    // given an output amount of an asset and pair reserves, returns a required input amount of the o\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint feeRate) internal pure \n        require(amountOut > 0, 'NetswapLibrary: INSUFFICIENT_OUTPUT_AMOUNT'); \n        require(reserveIn > 0 && reserveOut > 0, 'NetswapLibrary: INSUFFICIENT_LIQUIDITY'); \n        uint numerator = reserveIn.mul(amountOut).mul(1000); \n        uint denominator = reserveOut.sub(amountOut).mul(1000 - feeRate); \n        amountIn = (numerator / denominator).add(1); \n    } \n \n    // performs chained getAmountOut calculations on any number of pairs \n    function getAmountsOut(address factory, uint amountIn, address[] memory path, uint feeRate) inter\n        require(path.length >= 2, 'NetswapLibrary: INVALID_PATH'); \n        amounts = new uint[](path.length); \n        amounts[0] = amountIn; \n        for (uint i; i < path.length - 1; i++) { \n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); \n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, feeRate); \n        } \n    } \n \n    // performs chained getAmountIn calculations on any number of pairs \n    function getAmountsIn(address factory, uint amountOut, address[] memory path, uint feeRate) inter\n        require(path.length >= 2, 'NetswapLibrary: INVALID_PATH'); \n        amounts = new uint[](path.length); \n        amounts[amounts.length - 1] = amountOut; \n        for (uint i = path.length - 1; i > 0; i--) { \n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); \n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut, feeRate); \n        } \n    } \n} \n \n",
            "pragma solidity >=0.6.0; \n \n// helper methods for interacting with ERC20 tokens and sending Metis that do not consistently return \nlibrary TransferHelper { \n    function safeApprove(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('approve(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n    } \n \n    function safeTransfer(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferFrom(address token, address from, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferMetis(address to, uint value) internal { \n        (bool success,) = to.call{value:value}(new bytes(0)); \n        require(success, 'TransferHelper: METIS_TRANSFER_FAILED'); \n    } \n} \n \n",
            "pragma solidity >=0.6.2; \n \ninterface INetswapRouter { \n    function factory() external pure returns (address); \n    function Metis() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityMetis( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountMetis, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityMetis( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountMetis); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityMetisWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountMetis); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactMetisForTokens(uint amountOutMin, address[] calldata path, address to, uint dea\n        external \n        payable \n        returns (uint[] memory amounts); \n    function swapTokensForExactMetis(uint amountOut, uint amountInMax, address[] calldata path, addre\n        external \n        returns (uint[] memory amounts); \n    function swapExactTokensForMetis(uint amountIn, uint amountOutMin, address[] calldata path, addre\n        external \n        returns (uint[] memory amounts); \n    function swapMetisForExactTokens(uint amountOut, address[] calldata path, address to, uint deadli\n        external \n        payable \n        returns (uint[] memory amounts); \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external view returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external view returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n} \n \n",
            "pragma solidity >=0.6.2; \n \n \ninterface INetswapRouter02 is INetswapRouter { \n    function removeLiquidityMetisSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountMetis); \n    function removeLiquidityMetisWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountMetis); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactMetisForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForMetisSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapMining() external pure returns (address); \n} \n \n \n",
            "pragma solidity >=0.5.0; \n \ninterface IERC20Netswap { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external view returns (string memory); \n    function symbol() external view returns (string memory); \n    function decimals() external view returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n} \n \ninterface ISwapMining { \n    function swap(address account, address input, address output, uint256 amount) external returns (b\n} \n \ncontract Ownable { \n    address private _owner; \n \n    constructor () internal { \n        _owner = msg.sender; \n        emit OwnershipTransferred(address(0), _owner); \n    } \n \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    function isOwner(address account) public view returns (bool) { \n        return account == _owner; \n    } \n \n    function renounceOwnership() public onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    function _transferOwnership(address newOwner) internal { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n \n    function transferOwnership(address newOwner) public onlyOwner { \n        _transferOwnership(newOwner); \n    } \n \n \n    modifier onlyOwner() { \n        require(isOwner(msg.sender), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n} \n \n \n",
            "pragma solidity =0.6.12; \n \ncontract NetswapRouter is INetswapRouter02, Ownable { \n    using SafeMathNetswap for uint; \n \n    address public immutable override factory; \n    address public immutable override Metis; \n    address public override swapMining; \n \n    modifier ensure(uint deadline) { \n        require(deadline >= block.timestamp, 'NetswapRouter: EXPIRED'); \n        _; \n    } \n \n    constructor(address _factory, address _Metis) public { \n        factory = _factory; \n        Metis = _Metis; \n    } \n \n    function setSwapMining(address _swapMininng) public onlyOwner { \n        swapMining = _swapMininng; \n    } \n \n    receive() external payable {} \n \n    // **** ADD LIQUIDITY **** \n    function _addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin \n    ) internal virtual returns (uint amountA, uint amountB) { \n        // create the pair if it doesn't exist yet \n        if (INetswapFactory(factory).getPair(tokenA, tokenB) == address(0)) { \n            INetswapFactory(factory).createPair(tokenA, tokenB); \n        } \n        (uint reserveA, uint reserveB) = NetswapLibrary.getReserves(factory, tokenA, tokenB); \n        if (reserveA == 0 && reserveB == 0) { \n            (amountA, amountB) = (amountADesired, amountBDesired); \n        } else { \n            uint amountBOptimal = NetswapLibrary.quote(amountADesired, reserveA, reserveB); \n            if (amountBOptimal <= amountBDesired) { \n                require(amountBOptimal >= amountBMin, 'NetswapRouter: INSUFFICIENT_B_AMOUNT'); \n                (amountA, amountB) = (amountADesired, amountBOptimal); \n            } else { \n                uint amountAOptimal = NetswapLibrary.quote(amountBDesired, reserveB, reserveA); \n                assert(amountAOptimal <= amountADesired); \n                require(amountAOptimal >= amountAMin, 'NetswapRouter: INSUFFICIENT_A_AMOUNT'); \n                (amountA, amountB) = (amountAOptimal, amountBDesired); \n            } \n        } \n    } \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) \n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin\n        address pair = NetswapLibrary.pairFor(factory, tokenA, tokenB); \n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA); \n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB); \n        liquidity = INetswapPair(pair).mint(to); \n    } \n    function addLiquidityMetis( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountMetis, \n        (amountToken, amountMetis) = _addLiquidity( \n            token, \n            Metis, \n            amountTokenDesired, \n            msg.value, \n            amountTokenMin, \n            amountMetisMin \n        ); \n        address pair = NetswapLibrary.pairFor(factory, token, Metis); \n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken); \n        // safe transfer Metis from router to pair \n        TransferHelper.safeTransfer(Metis, pair, amountMetis); \n        liquidity = INetswapPair(pair).mint(to); \n        // refund dust metis, if any \n        if (msg.value > amountMetis) TransferHelper.safeTransferMetis(msg.sender, msg.value - amountM\n    } \n \n    // **** REMOVE LIQUIDITY **** \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) { \n        address pair = NetswapLibrary.pairFor(factory, tokenA, tokenB); \n        INetswapPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair \n        (uint amount0, uint amount1) = INetswapPair(pair).burn(to); \n        (address token0,) = NetswapLibrary.sortTokens(tokenA, tokenB); \n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); \n        require(amountA >= amountAMin, 'NetswapRouter: INSUFFICIENT_A_AMOUNT'); \n        require(amountB >= amountBMin, 'NetswapRouter: INSUFFICIENT_B_AMOUNT'); \n    } \n    function removeLiquidityMetis( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountMetis) { \n        (amountToken, amountMetis) = removeLiquidity( \n            token, \n            Metis, \n            liquidity, \n            amountTokenMin, \n            amountMetisMin, \n            address(this), \n            deadline \n        ); \n        TransferHelper.safeTransfer(token, to, amountToken); \n        TransferHelper.safeTransferMetis(to, amountMetis); \n    } \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external virtual override returns (uint amountA, uint amountB) { \n        address pair = NetswapLibrary.pairFor(factory, tokenA, tokenB); \n        uint value = approveMax ? uint(-1) : liquidity; \n        INetswapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); \n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, d\n    } \n    function removeLiquidityMetisWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external virtual override returns (uint amountToken, uint amountMetis) { \n        address pair = NetswapLibrary.pairFor(factory, token, Metis); \n        uint value = approveMax ? uint(-1) : liquidity; \n        INetswapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); \n        (amountToken, amountMetis) = removeLiquidityMetis(token, liquidity, amountTokenMin, amountMet\n    } \n \n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) **** \n    function removeLiquidityMetisSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) public virtual override ensure(deadline) returns (uint amountMetis) { \n        (, amountMetis) = removeLiquidity( \n            token, \n            Metis, \n            liquidity, \n            amountTokenMin, \n            amountMetisMin, \n            address(this), \n            deadline \n        ); \n        TransferHelper.safeTransfer(token, to, IERC20Netswap(token).balanceOf(address(this))); \n        TransferHelper.safeTransferMetis(to, amountMetis); \n    } \n    function removeLiquidityMetisWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external virtual override returns (uint amountMetis) { \n        address pair = NetswapLibrary.pairFor(factory, token, Metis); \n        uint value = approveMax ? uint(-1) : liquidity; \n        INetswapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s); \n        amountMetis = removeLiquidityMetisSupportingFeeOnTransferTokens( \n            token, liquidity, amountTokenMin, amountMetisMin, to, deadline \n        ); \n    } \n \n    // **** SWAP **** \n    // requires the initial amount to have already been sent to the first pair \n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual { \n        for (uint i; i < path.length - 1; i++) { \n            (address input, address output) = (path[i], path[i + 1]); \n            (address token0,) = NetswapLibrary.sortTokens(input, output); \n            uint amountOut = amounts[i + 1]; \n            if (swapMining != address(0)) { \n                ISwapMining(swapMining).swap(msg.sender, input, output, amountOut); \n            } \n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, \n            address to = i < path.length - 2 ? NetswapLibrary.pairFor(factory, output, path[i + 2]) : \n            INetswapPair(NetswapLibrary.pairFor(factory, input, output)).swap( \n                amount0Out, amount1Out, to, new bytes(0) \n            ); \n        } \n    } \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) { \n        amounts = NetswapLibrary.getAmountsOut(factory, amountIn, path, INetswapFactory(factory).feeR\n        require(amounts[amounts.length - 1] >= amountOutMin, 'NetswapRouter: INSUFFICIENT_OUTPUT_AMOU\n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, NetswapLibrary.pairFor(factory, path[0], path[1]), amounts[0] \n        ); \n        _swap(amounts, path, to); \n    } \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) { \n        amounts = NetswapLibrary.getAmountsIn(factory, amountOut, path, INetswapFactory(factory).feeR\n        require(amounts[0] <= amountInMax, 'NetswapRouter: EXCESSIVE_INPUT_AMOUNT'); \n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, NetswapLibrary.pairFor(factory, path[0], path[1]), amounts[0] \n        ); \n        _swap(amounts, path, to); \n    } \n    function swapExactMetisForTokens(uint amountOutMin, address[] calldata path, address to, uint dea\n        external \n        virtual \n        override \n        payable \n        ensure(deadline) \n        returns (uint[] memory amounts) \n    { \n        require(path[0] == Metis, 'NetswapRouter: INVALID_PATH'); \n        amounts = NetswapLibrary.getAmountsOut(factory, msg.value, path, INetswapFactory(factory).fee\n        require(amounts[amounts.length - 1] >= amountOutMin, 'NetswapRouter: INSUFFICIENT_OUTPUT_AMOU\n        // safe transfer metis from router to pair \n        TransferHelper.safeTransfer(Metis, NetswapLibrary.pairFor(factory, path[0], path[1]), amounts\n        _swap(amounts, path, to); \n    } \n    function swapTokensForExactMetis(uint amountOut, uint amountInMax, address[] calldata path, addre\n        external \n        virtual \n        override \n        ensure(deadline) \n        returns (uint[] memory amounts) \n    { \n        require(path[path.length - 1] == Metis, 'NetswapRouter: INVALID_PATH'); \n        amounts = NetswapLibrary.getAmountsIn(factory, amountOut, path, INetswapFactory(factory).feeR\n        require(amounts[0] <= amountInMax, 'NetswapRouter: EXCESSIVE_INPUT_AMOUNT'); \n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, NetswapLibrary.pairFor(factory, path[0], path[1]), amounts[0] \n        ); \n        _swap(amounts, path, address(this)); \n        TransferHelper.safeTransferMetis(to, amounts[amounts.length - 1]); \n    } \n    function swapExactTokensForMetis(uint amountIn, uint amountOutMin, address[] calldata path, addre\n        external \n        virtual \n        override \n        ensure(deadline) \n        returns (uint[] memory amounts) \n    { \n        require(path[path.length - 1] == Metis, 'NetswapRouter: INVALID_PATH'); \n        amounts = NetswapLibrary.getAmountsOut(factory, amountIn, path, INetswapFactory(factory).feeR\n        require(amounts[amounts.length - 1] >= amountOutMin, 'NetswapRouter: INSUFFICIENT_OUTPUT_AMOU\n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, NetswapLibrary.pairFor(factory, path[0], path[1]), amounts[0] \n        ); \n        _swap(amounts, path, address(this)); \n        TransferHelper.safeTransferMetis(to, amounts[amounts.length - 1]); \n    } \n    function swapMetisForExactTokens(uint amountOut, address[] calldata path, address to, uint deadli\n        external \n        virtual \n        override \n        payable \n        ensure(deadline) \n        returns (uint[] memory amounts) \n    { \n        require(path[0] == Metis, 'NetswapRouter: INVALID_PATH'); \n        amounts = NetswapLibrary.getAmountsIn(factory, amountOut, path, INetswapFactory(factory).feeR\n        require(amounts[0] <= msg.value, 'NetswapRouter: EXCESSIVE_INPUT_AMOUNT'); \n        // safe transfer metis from router to pair \n        TransferHelper.safeTransfer(Metis, NetswapLibrary.pairFor(factory, path[0], path[1]), amounts\n        _swap(amounts, path, to); \n        // refund dust metis, if any \n        if (msg.value > amounts[0]) TransferHelper.safeTransferMetis(msg.sender, msg.value - amounts[\n    } \n \n    // **** SWAP (supporting fee-on-transfer tokens) **** \n    // requires the initial amount to have already been sent to the first pair \n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual \n        for (uint i; i < path.length - 1; i++) { \n            (address input, address output) = (path[i], path[i + 1]); \n            (address token0,) = NetswapLibrary.sortTokens(input, output); \n            INetswapPair pair = INetswapPair(NetswapLibrary.pairFor(factory, input, output)); \n            uint amountInput; \n            uint amountOutput; \n            { // scope to avoid stack too deep errors \n            (uint reserve0, uint reserve1,) = pair.getReserves(); \n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reser\n            amountInput = IERC20Netswap(input).balanceOf(address(pair)).sub(reserveInput); \n            amountOutput = NetswapLibrary.getAmountOut(amountInput, reserveInput, reserveOutput, INet\n            } \n            if (swapMining != address(0)) { \n                ISwapMining(swapMining).swap(msg.sender, input, output, amountOutput); \n            } \n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountO\n            address to = i < path.length - 2 ? NetswapLibrary.pairFor(factory, output, path[i + 2]) : \n            pair.swap(amount0Out, amount1Out, to, new bytes(0)); \n        } \n    } \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external virtual override ensure(deadline) { \n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, NetswapLibrary.pairFor(factory, path[0], path[1]), amountIn \n        ); \n        uint balanceBefore = IERC20Netswap(path[path.length - 1]).balanceOf(to); \n        _swapSupportingFeeOnTransferTokens(path, to); \n        require( \n            IERC20Netswap(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, \n            'NetswapRouter: INSUFFICIENT_OUTPUT_AMOUNT' \n        ); \n    } \n    function swapExactMetisForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) \n        external \n        virtual \n        override \n        payable \n        ensure(deadline) \n    { \n        require(path[0] == Metis, 'NetswapRouter: INVALID_PATH'); \n        uint amountIn = msg.value; \n        // safe transfer metis from router to pair \n        TransferHelper.safeTransfer(Metis, NetswapLibrary.pairFor(factory, path[0], path[1]), amountI\n        uint balanceBefore = IERC20Netswap(path[path.length - 1]).balanceOf(to); \n        _swapSupportingFeeOnTransferTokens(path, to); \n        require( \n            IERC20Netswap(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, \n            'NetswapRouter: INSUFFICIENT_OUTPUT_AMOUNT' \n        ); \n    } \n    function swapExactTokensForMetisSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) \n        external \n        virtual \n        override \n        ensure(deadline) \n    { \n        require(path[path.length - 1] == Metis, 'NetswapRouter: INVALID_PATH'); \n        TransferHelper.safeTransferFrom( \n            path[0], msg.sender, NetswapLibrary.pairFor(factory, path[0], path[1]), amountIn \n        ); \n        _swapSupportingFeeOnTransferTokens(path, address(this)); \n        uint amountOut = IERC20Netswap(Metis).balanceOf(address(this)); \n        require(amountOut >= amountOutMin, 'NetswapRouter: INSUFFICIENT_OUTPUT_AMOUNT'); \n        TransferHelper.safeTransferMetis(to, amountOut); \n    } \n \n    // **** LIBRARY FUNCTIONS **** \n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (\n        return NetswapLibrary.quote(amountA, reserveA, reserveB); \n    } \n \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) \n        public \n        view \n        virtual \n        override \n        returns (uint amountOut) \n    { \n        return NetswapLibrary.getAmountOut(amountIn, reserveIn, reserveOut, INetswapFactory(factory).\n    } \n \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) \n        public \n        view \n        virtual \n        override \n        returns (uint amountIn) \n    { \n        return NetswapLibrary.getAmountIn(amountOut, reserveIn, reserveOut, INetswapFactory(factory).\n    } \n \n    function getAmountsOut(uint amountIn, address[] memory path) \n        public \n        view \n        virtual \nINetswapRouter.sol\n        override \n        returns (uint[] memory amounts) \n    { \n        return NetswapLibrary.getAmountsOut(factory, amountIn, path, INetswapFactory(factory).feeRate\n    } \n \n    function getAmountsIn(uint amountOut, address[] memory path) \n        public \n        view \n        virtual \n        override \n        returns (uint[] memory amounts) \n    { \n        return NetswapLibrary.getAmountsIn(factory, amountOut, path, INetswapFactory(factory).feeRate\n    } \n}\n// Just for reference \n",
            "pragma solidity >=0.6.2; \n \ninterface INetswapRouter { \n    function factory() external pure returns (address); \n    function Metis() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityMetis( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountMetis, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityMetis( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountMetis); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityMetisWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountMetis); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactMetisForTokens(uint amountOutMin, address[] calldata path, address to, uint dea\n        external \n        payable \n        returns (uint[] memory amounts); \n    function swapTokensForExactMetis(uint amountOut, uint amountInMax, address[] calldata path, addre\n        external \n        returns (uint[] memory amounts); \n    function swapExactTokensForMetis(uint amountIn, uint amountOutMin, address[] calldata path, addre\n        external \n        returns (uint[] memory amounts); \n    function swapMetisForExactTokens(uint amountOut, address[] calldata path, address to, uint deadli\n        external \n        payable \n        returns (uint[] memory amounts); \n \n    function removeLiquidityMetisSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountMetis); \n    function removeLiquidityMetisWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountMetis); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \nMulticall.sol\n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactMetisForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForMetisSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external view returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external view returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n}\n",
            "pragma solidity >=0.5.0; \npragma experimental ABIEncoderV2; \n \n/// @title Multicall - Aggregate results from multiple read-only function calls \n \ninterface IERC20 { \n    function balanceOf(address user) external view returns (uint256); \n} \n \ncontract Multicall { \n    address public metis = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000; \n    struct Call { \n        address target; \n        bytes callData; \n    } \n    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory retur\n        blockNumber = block.number; \n        returnData = new bytes[](calls.length); \n        for(uint256 i = 0; i < calls.length; i++) { \n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData); \n            require(success); \n            returnData[i] = ret; \n        } \n    } \n    // Helper functions \n    function getMetisBalance(address addr) public view returns(uint256 balance) { \n        balance = IERC20(metis).balanceOf(addr); \n    } \n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) { \n        timestamp = block.timestamp; \n    } \n}\nNetswapFactory.sol\n",
            "pragma solidity >=0.5.0; \n \ninterface INetswapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeRate() external view returns (uint); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeRate(uint) external; \n    function setFeeToSetter(address) external; \n} \n \n",
            "pragma solidity =0.6.12; \n \n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-ma\n \nlibrary SafeMathNetswap { \n    function add(uint x, uint y) internal pure returns (uint z) { \n        require((z = x + y) >= x, 'ds-math-add-overflow'); \n    } \n \n    function sub(uint x, uint y) internal pure returns (uint z) { \n        require((z = x - y) <= x, 'ds-math-sub-underflow'); \n    } \n \n    function mul(uint x, uint y) internal pure returns (uint z) { \n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow'); \n    } \n} \n \n",
            "pragma solidity =0.6.12; \n \n \ncontract NetswapERC20 { \n    using SafeMathNetswap for uint; \n \n    string public constant name = 'Netswap LP Token'; \n    string public constant symbol = 'NLP'; \n    uint8 public constant decimals = 18; \n    uint  public totalSupply; \n    mapping(address => uint) public balanceOf; \n    mapping(address => mapping(address => uint)) public allowance; \n \n    bytes32 public DOMAIN_SEPARATOR; \n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c6\n    mapping(address => uint) public nonces; \n \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    constructor() public { \n        uint chainId; \n        assembly { \n            chainId := chainid() \n        } \n        DOMAIN_SEPARATOR = keccak256( \n            abi.encode( \n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingC\n                keccak256(bytes(name)), \n                keccak256(bytes('1')), \n                chainId, \n                address(this) \n            ) \n        ); \n    } \n \n    function _mint(address to, uint value) internal { \n        totalSupply = totalSupply.add(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(address(0), to, value); \n    } \n \n    function _burn(address from, uint value) internal { \n        balanceOf[from] = balanceOf[from].sub(value); \n        totalSupply = totalSupply.sub(value); \n        emit Transfer(from, address(0), value); \n    } \n \n    function _approve(address owner, address spender, uint value) private { \n        allowance[owner][spender] = value; \n        emit Approval(owner, spender, value); \n    } \n \n    function _transfer(address from, address to, uint value) private { \n        balanceOf[from] = balanceOf[from].sub(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(from, to, value); \n    } \n \n    function approve(address spender, uint value) external returns (bool) { \n        _approve(msg.sender, spender, value); \n        return true; \n    } \n \n    function transfer(address to, uint value) external returns (bool) { \n        _transfer(msg.sender, to, value); \n        return true; \n    } \n \n    function transferFrom(address from, address to, uint value) external returns (bool) { \n        if (allowance[from][msg.sender] != uint(-1)) { \n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value); \n        } \n        _transfer(from, to, value); \n        return true; \n    } \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n        require(deadline >= block.timestamp, 'Netswap: EXPIRED'); \n        bytes32 digest = keccak256( \n            abi.encodePacked( \n                '\\x19\\x01', \n                DOMAIN_SEPARATOR, \n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadlin\n            ) \n        ); \n        address recoveredAddress = ecrecover(digest, v, r, s); \n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Netswap: INVALID_SIGNAT\n        _approve(owner, spender, value); \n    } \n} \n \n",
            "pragma solidity =0.6.12; \n \n// a library for performing various math operations \n \nlibrary Math { \n    function min(uint x, uint y) internal pure returns (uint z) { \n        z = x < y ? x : y; \n    } \n \n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_\n    function sqrt(uint y) internal pure returns (uint z) { \n        if (y > 3) { \n            z = y; \n            uint x = y / 2 + 1; \n            while (x < z) { \n                z = x; \n                x = (y / x + x) / 2; \n            } \n        } else if (y != 0) { \n            z = 1; \n        } \n    } \n} \n \n",
            "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n    uint224 constant Q112 = 2**112; \n \n    // encode a uint112 as a UQ112x112 \n    function encode(uint112 y) internal pure returns (uint224 z) { \n        z = uint224(y) * Q112; // never overflows \n    } \n \n    // divide a UQ112x112 by a uint112, returning a UQ112x112 \n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n        z = x / uint224(y); \n    } \n} \n \n",
            "pragma solidity >=0.5.0; \n \ninterface IERC20Netswap { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external view returns (string memory); \n    function symbol() external view returns (string memory); \n    function decimals() external view returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n} \n \n",
            "pragma solidity >=0.5.0; \n \ninterface INetswapCallee { \n    function netswapCall(address sender, uint amount0, uint amount1, bytes calldata data) external; \n} \n \n",
            "pragma solidity =0.6.12; \n \ncontract NetswapPair is NetswapERC20 { \n    using SafeMathNetswap  for uint; \n    using UQ112x112 for uint224; \n \n    uint public constant MINIMUM_LIQUIDITY = 10**3; \n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)'))); \n \n    address public factory; \n    address public token0; \n    address public token1; \n \n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves \n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves \n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves \n \n    uint public price0CumulativeLast; \n    uint public price1CumulativeLast; \n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity even\n \n    uint private unlocked = 1; \n    modifier lock() { \n        require(unlocked == 1, 'Netswap: LOCKED'); \n        unlocked = 0; \n        _; \n        unlocked = 1; \n    } \n \n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTi\n        _reserve0 = reserve0; \n        _reserve1 = reserve1; \n        _blockTimestampLast = blockTimestampLast; \n    } \n \n    function _safeTransfer(address token, address to, uint value) private { \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value)); \n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Netswap: TRANSFER_FAILED'\n    } \n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    constructor() public { \n        factory = msg.sender; \n    } \n \n    // called once by the factory at time of deployment \n    function initialize(address _token0, address _token1) external { \n        require(msg.sender == factory, 'Netswap: FORBIDDEN'); // sufficient check \n        token0 = _token0; \n        token1 = _token1; \n    } \n \n    // update reserves and, on the first call per block, price accumulators \n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { \n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'Netswap: OVERFLOW'); \n        uint32 blockTimestamp = uint32(block.timestamp % 2**32); \n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired \n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) { \n            // * never overflows, and + overflow is desired \n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; \n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; \n        } \n        reserve0 = uint112(balance0); \n        reserve1 = uint112(balance1); \n        blockTimestampLast = blockTimestamp; \n        emit Sync(reserve0, reserve1); \n    } \n \n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k) \n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) { \n        address feeTo = INetswapFactory(factory).feeTo(); \n        feeOn = feeTo != address(0); \n        uint _kLast = kLast; // gas savings \n        if (feeOn) { \n            if (_kLast != 0) { \n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); \n                uint rootKLast = Math.sqrt(_kLast); \n                if (rootK > rootKLast) { \n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast)); \n                    uint denominator = rootK.mul(5).add(rootKLast); \n                    uint liquidity = numerator / denominator; \n                    if (liquidity > 0) _mint(feeTo, liquidity); \n                } \n            } \n        } else if (_kLast != 0) { \n            kLast = 0; \n        } \n    } \n \n    // this low-level function should be called from a contract which performs important safety check\n    function mint(address to) external lock returns (uint liquidity) { \n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings \n        uint balance0 = IERC20Netswap(token0).balanceOf(address(this)); \n        uint balance1 = IERC20Netswap(token1).balanceOf(address(this)); \n        uint amount0 = balance0.sub(_reserve0); \n        uint amount1 = balance1.sub(_reserve1); \n \n        bool feeOn = _mintFee(_reserve0, _reserve1); \n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can up\n        if (_totalSupply == 0) { \n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); \n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY toke\n        } else { \n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _\n        } \n        require(liquidity > 0, 'Netswap: INSUFFICIENT_LIQUIDITY_MINTED'); \n        _mint(to, liquidity); \n \n        _update(balance0, balance1, _reserve0, _reserve1); \n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date \n        emit Mint(msg.sender, amount0, amount1); \n    } \n \n    // this low-level function should be called from a contract which performs important safety check\n    function burn(address to) external lock returns (uint amount0, uint amount1) { \n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings \n        address _token0 = token0;                                // gas savings \n        address _token1 = token1;                                // gas savings \n        uint balance0 = IERC20Netswap(_token0).balanceOf(address(this)); \n        uint balance1 = IERC20Netswap(_token1).balanceOf(address(this)); \n        uint liquidity = balanceOf[address(this)]; \n \n        bool feeOn = _mintFee(_reserve0, _reserve1); \n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can up\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribu\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribu\n        require(amount0 > 0 && amount1 > 0, 'Netswap: INSUFFICIENT_LIQUIDITY_BURNED'); \n        _burn(address(this), liquidity); \n        _safeTransfer(_token0, to, amount0); \n        _safeTransfer(_token1, to, amount1); \n        balance0 = IERC20Netswap(_token0).balanceOf(address(this)); \n        balance1 = IERC20Netswap(_token1).balanceOf(address(this)); \n \n        _update(balance0, balance1, _reserve0, _reserve1); \n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date \n        emit Burn(msg.sender, amount0, amount1, to); \n    } \n \n    // this low-level function should be called from a contract which performs important safety check\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock { \n        require(amount0Out > 0 || amount1Out > 0, 'Netswap: INSUFFICIENT_OUTPUT_AMOUNT'); \n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings \n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Netswap: INSUFFICIENT_LIQUIDITY'); \n \n        uint balance0; \n        uint balance1; \n        { // scope for _token{0,1}, avoids stack too deep errors \n        address _token0 = token0; \n        address _token1 = token1; \n        require(to != _token0 && to != _token1, 'Netswap: INVALID_TO'); \n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens \n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens \n        if (data.length > 0) INetswapCallee(to).netswapCall(msg.sender, amount0Out, amount1Out, data)\n        balance0 = IERC20Netswap(_token0).balanceOf(address(this)); \n        balance1 = IERC20Netswap(_token1).balanceOf(address(this)); \n        } \n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; \n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; \n        require(amount0In > 0 || amount1In > 0, 'Netswap: INSUFFICIENT_INPUT_AMOUNT'); \n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors \n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(INetswapFactory(factory).feeRate\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(INetswapFactory(factory).feeRate\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2)\n        } \n \n        _update(balance0, balance1, _reserve0, _reserve1); \n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to); \n    } \n \n    // force balances to match reserves \n    function skim(address to) external lock { \n        address _token0 = token0; // gas savings \n        address _token1 = token1; // gas savings \n        _safeTransfer(_token0, to, IERC20Netswap(_token0).balanceOf(address(this)).sub(reserve0)); \n        _safeTransfer(_token1, to, IERC20Netswap(_token1).balanceOf(address(this)).sub(reserve1)); \n    } \n \n    // force reserves to match balances \n    function sync() external lock { \n        _update(IERC20Netswap(token0).balanceOf(address(this)), IERC20Netswap(token1).balanceOf(addre\n    } \n} \n \n",
            "pragma solidity =0.6.12; \n \n \n \ncontract NetswapFactory is INetswapFactory { \n    using SafeMathNetswap  for uint; \n    uint public override feeRate = 3; \n    address public override feeTo; \n    address public override feeToSetter; \n \n    mapping(address => mapping(address => address)) public override getPair; \n    address[] public override allPairs; \n \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    constructor(address _feeToSetter) public { \n        feeToSetter = _feeToSetter; \n    } \n \n    function allPairsLength() external override view returns (uint) { \n        return allPairs.length; \n    } \n \n    function pairCodeHash() external pure returns (bytes32) { \n        return keccak256(type(NetswapPair).creationCode); \n    } \n \n    function createPair(address tokenA, address tokenB) external override returns (address pair) { \n        require(tokenA != tokenB, 'Netswap: IDENTICAL_ADDRESSES'); \n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'Netswap: ZERO_ADDRESS'); \n        require(getPair[token0][token1] == address(0), 'Netswap: PAIR_EXISTS'); // single check is su\n        bytes memory bytecode = type(NetswapPair).creationCode; \n        bytes32 salt = keccak256(abi.encodePacked(token0, token1)); \n        assembly { \n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        NetswapPair(pair).initialize(token0, token1); \n        getPair[token0][token1] = pair; \n        getPair[token1][token0] = pair; // populate mapping in the reverse direction \n        allPairs.push(pair); \n        emit PairCreated(token0, token1, pair, allPairs.length); \n    } \n \n    function setFeeTo(address _feeTo) external override { \n        require(msg.sender == feeToSetter, 'Netswap: FORBIDDEN'); \n        feeTo = _feeTo; \n    } \n \n    function setFeeRate(uint _feeRate) external override { \n        require(msg.sender == feeToSetter, 'Netswap: FORBIDDEN'); \n        feeRate = _feeRate; \n    } \n \n    function setFeeToSetter(address _feeToSetter) external override { \n        require(msg.sender == feeToSetter, 'Netswap: FORBIDDEN'); \n        feeToSetter = _feeToSetter; \n    } \n \n}\n"
        ]
    },
    {
        "PdfName": "OceanVenture Government Token (OVG) Token_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\"; \n \ncontract OVG is ERC20PresetFixedSupply,ERC20Permit { \n    constructor(string memory name,string memory symbol,uint256 initialSupply,address owner) ERC20Per\n    } \n} \nAnalysis of audit results\nRe-Entrancy\nArithmetic Over/Under Flows\n"
        ]
    },
    {
        "PdfName": "Pippi Shrimp_audit.pdf",
        "Code": []
    },
    {
        "PdfName": "PPX Token_audit.pdf",
        "Code": [
            "pragma solidity =0.6.12; \npragma experimental ABIEncoderV2; \n \n// import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \n// import \"@openzeppelin/contracts/access/Ownable.sol\"; \n// import \"@openzeppelin/contracts/utils/EnumerableSet.sol\"; \n \nabstract contract DelegateERC20 is ERC20 { \n    // A record of each accounts delegate \n    mapping(address => address) internal _delegates; \n \n    // A checkpoint for marking number of votes from a given block \n    struct Checkpoint { \n        uint32 fromBlock; \n        uint256 votes; \n    } \n \n    // A record of votes checkpoints for each account, by index \n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints; \n \n    // The number of checkpoints for each account \n    mapping(address => uint32) public numCheckpoints; \n \n    // The EIP-712 typehash for the contract's domain \n    bytes32 public constant DOMAIN_TYPEHASH = \n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"); \n \n    // The EIP-712 typehash for the delegation struct used by the contract \n    bytes32 public constant DELEGATION_TYPEHASH = \n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\"); \n \n    // A record of states for signing / validating signatures \n    mapping(address => uint256) public nonces; \n \n    // support delegates mint \n    function _mint(address account, uint256 amount) internal virtual override { \n        super._mint(account, amount); \n \n        // add delegates to the minter \n        _moveDelegates(address(0), _delegates[account], amount); \n    } \n \n    function _transfer( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) internal virtual override { \n        super._transfer(sender, recipient, amount); \n        _moveDelegates(_delegates[sender], _delegates[recipient], amount); \n    } \n \n    /** \n     * @notice Delegate votes from `msg.sender` to `delegatee` \n     * @param delegatee The address to delegate votes to \n     */ \n    function delegate(address delegatee) external { \n        return _delegate(msg.sender, delegatee); \n    } \n \n    /** \n     * @notice Delegates votes from signatory to `delegatee` \n     * @param delegatee The address to delegate votes to \n     * @param nonce The contract state required to match the signature \n     * @param expiry The time at which to expire the signature \n     * @param v The recovery byte of the signature \n     * @param r Half of the ECDSA signature pair \n     * @param s Half of the ECDSA signature pair \n     */ \n    function delegateBySig( \n        address delegatee, \n        uint256 nonce, \n        uint256 expiry, \n        uint8 v, \n        bytes32 r, \n        bytes32 s \n    ) external { \n        bytes32 domainSeparator = \n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(thi\n \n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)); \n \n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)); \n \n        address signatory = ecrecover(digest, v, r, s); \n        require(signatory != address(0), \"PPXswapToken::delegateBySig: invalid signature\"); \n        require(nonce == nonces[signatory]++, \"PPXswapToken::delegateBySig: invalid nonce\"); \n        require(now <= expiry, \"PPXswapToken::delegateBySig: signature expired\"); \n        return _delegate(signatory, delegatee); \n    } \n \n    /** \n     * @notice Gets the current votes balance for `account` \n     * @param account The address to get votes balance \n     * @return The number of current votes for `account` \n     */ \n    function getCurrentVotes(address account) external view returns (uint256) { \n        uint32 nCheckpoints = numCheckpoints[account]; \n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0; \n    } \n \n    /** \n     * @notice Determine the prior number of votes for an account as of a block number \n     * @dev Block number must be a finalized block or else this function will revert to prevent misin\n     * @param account The address of the account to check \n     * @param blockNumber The block number to get the vote balance at \n     * @return The number of votes the account had as of the given block \n     */ \n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256) { \n        require(blockNumber < block.number, \"PPXswapToken::getPriorVotes: not yet determined\"); \n \n        uint32 nCheckpoints = numCheckpoints[account]; \n        if (nCheckpoints == 0) { \n            return 0; \n        } \n \n        // First check most recent balance \n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) { \n            return checkpoints[account][nCheckpoints - 1].votes; \n        } \n \n        // Next check implicit zero balance \n        if (checkpoints[account][0].fromBlock > blockNumber) { \n            return 0; \n        } \n \n        uint32 lower = 0; \n        uint32 upper = nCheckpoints - 1; \n        while (upper > lower) { \n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow \n            Checkpoint memory cp = checkpoints[account][center]; \n            if (cp.fromBlock == blockNumber) { \n                return cp.votes; \n            } else if (cp.fromBlock < blockNumber) { \n                lower = center; \n            } else { \n                upper = center - 1; \n            } \n        } \n        return checkpoints[account][lower].votes; \n    } \n \n    function _delegate(address delegator, address delegatee) internal { \n        address currentDelegate = _delegates[delegator]; \n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying balances (not scale\n        _delegates[delegator] = delegatee; \n \n        _moveDelegates(currentDelegate, delegatee, delegatorBalance); \n \n        emit DelegateChanged(delegator, currentDelegate, delegatee); \n    } \n \n    function _moveDelegates( \n        address srcRep, \n        address dstRep, \n        uint256 amount \n    ) internal { \n        if (srcRep != dstRep && amount > 0) { \n            if (srcRep != address(0)) { \n                // decrease old representative \n                uint32 srcRepNum = numCheckpoints[srcRep]; \n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0; \n                uint256 srcRepNew = srcRepOld.sub(amount); \n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew); \n            } \n \n            if (dstRep != address(0)) { \n                // increase new representative \n                uint32 dstRepNum = numCheckpoints[dstRep]; \n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0; \n                uint256 dstRepNew = dstRepOld.add(amount); \n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew); \n            } \n        } \n    } \n \n    function _writeCheckpoint( \n        address delegatee, \n        uint32 nCheckpoints, \n        uint256 oldVotes, \n        uint256 newVotes \n    ) internal { \n        uint32 blockNumber = safe32(block.number, \"PPXswapToken::_writeCheckpoint: block number excee\n \n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) { \n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes; \n        } else { \n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes); \n            numCheckpoints[delegatee] = nCheckpoints + 1; \n        } \n \n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes); \n    } \n \n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) { \n        require(n < 2**32, errorMessage); \n        return uint32(n); \n    } \n \n    function getChainId() internal pure returns (uint256) { \n        uint256 chainId; \n        assembly { \n            chainId := chainid() \n        } \n \n        return chainId; \n    } \n \n    /// @notice An event thats emitted when an account changes its delegate \n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed to\n \n    /// @notice An event thats emitted when a delegate account's vote balance changes \n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance)\n} \n \ncontract PPXswapToken is DelegateERC20, Ownable { \n    uint256 private constant preMineSupply = 500000 * 1e18; \n"
        ]
    },
    {
        "PdfName": "Rabbit (RBT) Token_audit.pdf",
        "Code": [
            "pragma solidity 0.5.16; \n \ninterface IHRC20 { \n  /** \n   * @dev Returns the amount of tokens in existence. \n   */ \n  function totalSupply() external view returns (uint256); \n \n  /** \n   * @dev Returns the token decimals. \n   */ \n  function decimals() external view returns (uint8); \n \n  /** \n   * @dev Returns the token symbol. \n   */ \n  function symbol() external view returns (string memory); \n \n  /** \n  * @dev Returns the token name. \n  */ \n  function name() external view returns (string memory); \n \n  /** \n   * @dev Returns the hrc token owner. \n   */ \n  function getOwner() external view returns (address); \n \n  /** \n   * @dev Returns the amount of tokens owned by `account`. \n   */ \n  function balanceOf(address account) external view returns (uint256); \n \n  /** \n   * @dev Moves `amount` tokens from the caller's account to `recipient`. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * Emits a {Transfer} event. \n   */ \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Returns the remaining number of tokens that `spender` will be \n   * allowed to spend on behalf of `owner` through {transferFrom}. This is \n   * zero by default. \n   * \n   * This value changes when {approve} or {transferFrom} are called. \n   */ \n  function allowance(address _owner, address spender) external view returns (uint256); \n \n  /** \n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * IMPORTANT: Beware that changing an allowance with this method brings the risk \n   * that someone may use both the old and the new allowance by unfortunate \n   * transaction ordering. One possible solution to mitigate this race \n   * condition is to first reduce the spender's allowance to 0 and set the \n   * desired value afterwards: \n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n   * \n   * Emits an {Approval} event. \n   */ \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Moves `amount` tokens from `sender` to `recipient` using the \n   * allowance mechanism. `amount` is then deducted from the caller's \n   * allowance. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * Emits a {Transfer} event. \n   */ \n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Emitted when `value` tokens are moved from one account (`from`) to \n   * another (`to`). \n   * \n   * Note that `value` may be zero. \n   */ \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  /** \n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n   * a call to {approve}. `value` is the new allowance. \n   */ \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \ncontract Context { \n  // Empty internal constructor, to prevent people from mistakenly deploying \n  // an instance of this contract, which should be used via inheritance. \n  constructor () internal { } \n \n  function _msgSender() internal view returns (address payable) { \n    return msg.sender; \n  } \n \n  function _msgData() internal view returns (bytes memory) { \n    this; // silence state mutability warning without generating bytecode - see https://github.com/et\n    return msg.data; \n  } \n} \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n  /** \n   * @dev Returns the addition of two unsigned integers, reverting on \n   * overflow. \n   * \n   * Counterpart to Solidity's `+` operator. \n   * \n   * Requirements: \n   * - Addition cannot overflow. \n   */ \n  function add(uint256 a, uint256 b) internal pure returns (uint256) { \n    uint256 c = a + b; \n    require(c >= a, \"SafeMath: addition overflow\"); \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the subtraction of two unsigned integers, reverting on \n   * overflow (when the result is negative). \n   * \n   * Counterpart to Solidity's `-` operator. \n   * \n   * Requirements: \n   * - Subtraction cannot overflow. \n   */ \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n    return sub(a, b, \"SafeMath: subtraction overflow\"); \n  } \n \n  /** \n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n   * overflow (when the result is negative). \n   * \n   * Counterpart to Solidity's `-` operator. \n   * \n   * Requirements: \n   * - Subtraction cannot overflow. \n   */ \n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n    require(b <= a, errorMessage); \n    uint256 c = a - b; \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the multiplication of two unsigned integers, reverting on \n   * overflow. \n   * \n   * Counterpart to Solidity's `*` operator. \n   * \n   * Requirements: \n   * - Multiplication cannot overflow. \n   */ \n  function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n    // benefit is lost if 'b' is also tested. \n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n    if (a == 0) { \n      return 0; \n    } \n \n    uint256 c = a * b; \n    require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the integer division of two unsigned integers. Reverts on \n   * division by zero. The result is rounded towards zero. \n   * \n   * Counterpart to Solidity's `/` operator. Note: this function uses a \n   * `revert` opcode (which leaves remaining gas untouched) while Solidity \n   * uses an invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function div(uint256 a, uint256 b) internal pure returns (uint256) { \n    return div(a, b, \"SafeMath: division by zero\"); \n  } \n \n  /** \n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on \n   * division by zero. The result is rounded towards zero. \n   * \n   * Counterpart to Solidity's `/` operator. Note: this function uses a \n   * `revert` opcode (which leaves remaining gas untouched) while Solidity \n   * uses an invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n    // Solidity only automatically asserts when dividing by 0 \n    require(b > 0, errorMessage); \n    uint256 c = a / b; \n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n   * Reverts when dividing by zero. \n   * \n   * Counterpart to Solidity's `%` operator. This function uses a `revert` \n   * opcode (which leaves remaining gas untouched) while Solidity uses an \n   * invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n    return mod(a, b, \"SafeMath: modulo by zero\"); \n  } \n \n  /** \n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n   * Reverts with custom message when dividing by zero. \n   * \n   * Counterpart to Solidity's `%` operator. This function uses a `revert` \n   * opcode (which leaves remaining gas untouched) while Solidity uses an \n   * invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n    require(b != 0, errorMessage); \n    return a % b; \n  } \n} \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \ncontract Ownable is Context { \n  address private _owner; \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  /** \n   * @dev Initializes the contract setting the deployer as the initial owner. \n   */ \n  constructor () internal { \n    address msgSender = _msgSender(); \n    _owner = msgSender; \n    emit OwnershipTransferred(address(0), msgSender); \n  } \n \n  /** \n   * @dev Returns the address of the current owner. \n   */ \n  function owner() public view returns (address) { \n    return _owner; \n  } \n \n  /** \n   * @dev Throws if called by any account other than the owner. \n   */ \n  modifier onlyOwner() { \n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n    _; \n  } \n \n  /** \n   * @dev Leaves the contract without owner. It will not be possible to call \n   * `onlyOwner` functions anymore. Can only be called by the current owner. \n   * \n   * NOTE: Renouncing ownership will leave the contract without an owner, \n   * thereby removing any functionality that is only available to the owner. \n   */ \n  function renounceOwnership() public onlyOwner { \n    emit OwnershipTransferred(_owner, address(0)); \n    _owner = address(0); \n  } \n \n  /** \n   * @dev Transfers ownership of the contract to a new account (`newOwner`). \n   * Can only be called by the current owner. \n   */ \n  function transferOwnership(address newOwner) public onlyOwner { \n    _transferOwnership(newOwner); \n  } \n \n  /** \n   * @dev Transfers ownership of the contract to a new account (`newOwner`). \n   */ \n  function _transferOwnership(address newOwner) internal { \n    require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n    emit OwnershipTransferred(_owner, newOwner); \n    _owner = newOwner; \n  } \n} \n \ncontract HRC20Token is Context, IHRC20, Ownable { \n  using SafeMath for uint256; \n \n  mapping (address => uint256) private _balances; \n \n  mapping (address => mapping (address => uint256)) private _allowances; \n \n  uint256 private _totalSupply; \n  uint8 private _decimals; \n  string private _symbol; \n  string private _name; \n \n  constructor() public { \n    _name = \"Rabbit\"; \n    _symbol = \"RBT\"; \n    _decimals = 18; \n    _totalSupply = 100000000000*(10**18); \n    _balances[msg.sender] = _totalSupply; \n \n    emit Transfer(address(0), msg.sender, _totalSupply); \n  } \n \n  /** \n   * @dev Returns the hrc token owner. \n   */ \n  function getOwner() external view returns (address) { \n    return owner(); \n  } \n \n  /** \n   * @dev Returns the token decimals. \n   */ \n  function decimals() external view returns (uint8) { \n    return _decimals; \n  } \n \n  /** \n   * @dev Returns the token symbol. \n   */ \n  function symbol() external view returns (string memory) { \n    return _symbol; \n  } \n \n  /** \n  * @dev Returns the token name. \n  */ \n  function name() external view returns (string memory) { \n    return _name; \n  } \n \n  /** \n   * @dev See {HRC20-totalSupply}. \n   */ \n  function totalSupply() external view returns (uint256) { \n    return _totalSupply; \n  } \n \n  /** \n   * @dev See {HRC20-balanceOf}. \n   */ \n  function balanceOf(address account) external view returns (uint256) { \n    return _balances[account]; \n  } \n \n  /** \n   * @dev See {HRC20-transfer}. \n   * \n   * Requirements: \n   * \n   * - `recipient` cannot be the zero address. \n   * - the caller must have a balance of at least `amount`. \n   */ \n  function transfer(address recipient, uint256 amount) external returns (bool) { \n    _transfer(_msgSender(), recipient, amount); \n    return true; \n  } \n \n  /** \n   * @dev See {HRC20-allowance}. \n   */ \n  function allowance(address owner, address spender) external view returns (uint256) { \n    return _allowances[owner][spender]; \n  } \n \n  /** \n   * @dev See {HRC20-approve}. \n   * \n   * Requirements: \n   * \n   * - `spender` cannot be the zero address. \n   */ \n  function approve(address spender, uint256 amount) external returns (bool) { \n    _approve(_msgSender(), spender, amount); \n    return true; \n  } \n \n  /** \n   * @dev See {HRC20-transferFrom}. \n   * \n   * Emits an {Approval} event indicating the updated allowance. This is not \n   * required by the EIP. See the note at the beginning of {HRC20}; \n   * \n   * Requirements: \n   * - `sender` and `recipient` cannot be the zero address. \n   * - `sender` must have a balance of at least `amount`. \n   * - the caller must have allowance for `sender`'s tokens of at least \n   * `amount`. \n   */ \n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) { \n    _transfer(sender, recipient, amount); \n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"HRC20: transfer amo\n    return true; \n  } \n \n  /** \n   * @dev Atomically increases the allowance granted to `spender` by the caller. \n   * \n   * This is an alternative to {approve} that can be used as a mitigation for \n   * problems described in {HRC20-approve}. \n   * \n   * Emits an {Approval} event indicating the updated allowance. \n   * \n   * Requirements: \n   * \n   * - `spender` cannot be the zero address. \n   */ \n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) { \n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n    return true; \n  } \n \n  /** \n   * @dev Atomically decreases the allowance granted to `spender` by the caller. \n   * \n   * This is an alternative to {approve} that can be used as a mitigation for \n   * problems described in {HRC20-approve}. \n   * \n   * Emits an {Approval} event indicating the updated allowance. \n   * \n   * Requirements: \n   * \n   * - `spender` cannot be the zero address. \n   * - `spender` must have allowance for the caller of at least \n   * `subtractedValue`. \n   */ \n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { \n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"HRC20: d\n    return true; \n  } \n \n  /** \n   * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing \n   * the total supply. \n   * \n   * Requirements \n   * \n   * - `msg.sender` must be the token owner \n   */ \n  function mint(uint256 amount) public onlyOwner returns (bool) { \n    _mint(_msgSender(), amount); \n    return true; \n  } \n \n  /** \n   * @dev Moves tokens `amount` from `sender` to `recipient`. \n   * \n   * This is internal function is equivalent to {transfer}, and can be used to \n   * e.g. implement automatic token fees, slashing mechanisms, etc. \n   * \n   * Emits a {Transfer} event. \n   * \n   * Requirements: \n   * \n   * - `sender` cannot be the zero address. \n   * - `recipient` cannot be the zero address. \n   * - `sender` must have a balance of at least `amount`. \n   */ \n  function _transfer(address sender, address recipient, uint256 amount) internal { \n    require(sender != address(0), \"HRC20: transfer from the zero address\"); \n    require(recipient != address(0), \"HRC20: transfer to the zero address\"); \n \n    _balances[sender] = _balances[sender].sub(amount, \"HRC20: transfer amount exceeds balance\"); \n    _balances[recipient] = _balances[recipient].add(amount); \n    emit Transfer(sender, recipient, amount); \n  } \n \n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n   * the total supply. \n   * \n   * Emits a {Transfer} event with `from` set to the zero address. \n   * \n   * Requirements \n   * \n   * - `to` cannot be the zero address. \n   */ \n  function _mint(address account, uint256 amount) internal { \n    require(account != address(0), \"HRC20: mint to the zero address\"); \n \n    _totalSupply = _totalSupply.add(amount); \n    _balances[account] = _balances[account].add(amount); \n    emit Transfer(address(0), account, amount); \n  } \n \n  /** \n   * @dev Destroys `amount` tokens from `account`, reducing the \n   * total supply. \n   * \n   * Emits a {Transfer} event with `to` set to the zero address. \n   * \n   * Requirements \n   * \n   * - `account` cannot be the zero address. \n   * - `account` must have at least `amount` tokens. \n   */ \n  function _burn(address account, uint256 amount) internal { \n    require(account != address(0), \"HRC20: burn from the zero address\"); \n \n    _balances[account] = _balances[account].sub(amount, \"HRC20: burn amount exceeds balance\"); \n    _totalSupply = _totalSupply.sub(amount); \n    emit Transfer(account, address(0), amount); \n  } \n \n  /** \n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens. \n   * \n   * This is internal function is equivalent to `approve`, and can be used to \n   * e.g. set automatic allowances for certain subsystems, etc. \n   * \n   * Emits an {Approval} event. \n   * \n   * Requirements: \n   * \n   * - `owner` cannot be the zero address. \n   * - `spender` cannot be the zero address. \n   */ \n  function _approve(address owner, address spender, uint256 amount) internal { \n    require(owner != address(0), \"HRC20: approve from the zero address\"); \n    require(spender != address(0), \"HRC20: approve to the zero address\"); \n \n    _allowances[owner][spender] = amount; \n    emit Approval(owner, spender, amount); \n"
        ]
    },
    {
        "PdfName": "RaceFi Token (RACEFI)_audit.pdf",
        "Code": []
    },
    {
        "PdfName": "Rpone.finance_audit 1.1.pdf",
        "Code": []
    },
    {
        "PdfName": "Scape Forum_audit.pdf",
        "Code": [
            "pragma solidity 0.6.7; \n \n//declare imports \nimport \"./../openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"./../openzeppelin/contracts/token/ERC20/SafeERC20.sol\"; \nimport \"./../openzeppelin/contracts/access/Ownable.sol\"; \nimport \"./../openzeppelin/contracts/math/SafeMath.sol\"; \nimport \"./../openzeppelin/contracts/utils/Counters.sol\"; \nimport \"./../openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\"; \nimport \"./../seascape_nft/NftFactory.sol\"; \nimport \"./../seascape_nft/SeascapeNft.sol\"; \nimport \"./Crowns.sol\"; \n \n \n/// @title Nft Burning contract  mints a higher quality nft in exchange for \n/// five lower quality nfts + CWS fee \n/// @author Nejc Schneider \ncontract NftBurning is Crowns, Ownable, IERC721Receiver{ \n    using SafeMath for uint256; \n    using Counters for Counters.Counter; \n \n    NftFactory nftFactory; \n    SeascapeNft private nft; \n    Counters.Counter private sessionId; \n \n    /// @notice holds session related data. Since event is a solidity keyword, we call them session i\n    struct Session { \n        uint256 period;       // session duration \n        uint256 startTime;    // session start in unixtimestamp \n        uint256 generation;        // Seascape Nft generation \n        uint256 interval;       // duration between every minting \n        uint256 fee;          // amount of CWS token to spend to mint a new nft \n        uint256 minStake;     // minimum amount of crowns deposit, only for staking \n        uint256 maxStake;     // maximum amount of crowns deposit, only for staking \n    } \n    /// @notice keeps track of balances for each user \n    struct Balance { \n          uint256 totalStaked;    // amount of crowns staked \n        uint256 mintedTime;     // track minted time per address \n    } \n \n    /// @notice Tracking player balance within a game session. \n    /// @dev session id =>(wallet address => (Balance struct)) \n    mapping(uint256 => mapping(address => Balance)) public balances; \n    /// @notice each session is a seperate object \n    /// @dev session id =>(Session struct) \n    mapping(uint256 => Session) public sessions; \n    /// session related data \n    uint256 public lastSessionId; \n \n    event Minted( \n        uint256 indexed sessionId, \n        address indexed owner, \n        uint256[5] burntNfts, \n        uint256 mintedTime, \n        uint256 imgId, \n        uint256 mintedNft \n    ); \n    event SessionStarted( \n        uint256 indexed sessionId, \n        uint256 generation, \n        uint256 fee, \n        uint256 interval, \n        uint256 start_time, \n        uint256 end_time, \n        uint256 minStake, \n        uint256 maxStake \n    ); \n    event Staked( \n        uint256 indexed sessionId, \n        address indexed owner, \n        uint256 amount, \n        uint256 totalStaked \n    ); \n    event Withdrawn( \n        address indexed owner, \n        uint256 indexed sessionId, \n        uint256 withdrawnAmount, \n        uint256 withdrawnTime \n    ); \n    event FactorySet(address indexed factoryAddress); \n \n \n    /// @dev set currency addresses \n    /// @param _crowns staking currency address \n    /// @param _nftFactory nft minting contract address \n    /// @param _nft nft fusion contract address \n    constructor(address _crowns, address _nftFactory, address _nft)  public { \n        require(_nftFactory != address(0), \"nftFactory cant be zero address\"); \n \n        /// @dev set crowns is defined in Crowns.sol \n        setCrowns(_crowns); \n \n        sessionId.increment();     // starts at value 1 \n        nftFactory = NftFactory(_nftFactory); \n        nft = SeascapeNft(_nft); \n    } \n \n    /// @dev start a new session, during which players are allowed to mint nfts \n    /// @param _startTime unix timestamp when session starts \n    /// @param _period unix timestamp when session ends. Should be equal to startTime + period \n    /// @param _generation generation of newly minted nfts \n    /// @param _interval duration between every possible minting \n    /// @param _fee amount of CWS token to spend to mint a new nft \n    function startSession( \n        uint256 _startTime, \n        uint256 _period, \n        uint256 _generation, \n        uint256 _interval, \n        uint256 _fee, \n        uint256 _minStake, \n        uint256 _maxStake \n    ) \n        external \n        onlyOwner \n    { \n        /// cant start new session when another is active \n        if (lastSessionId > 0) { \n            require(!isActive(lastSessionId), \"another session is still active\"); \n        } \n        require(_startTime > block.timestamp, \"session should start in future\"); \n        require(_period > 0, \"period should be above 0\"); \n        require(_interval > 0 && _interval <= _period, \n        \"interval should be >0 & <period\"); \n        require(_fee > 0, \"fee should be above 0\"); \n        require(_minStake > 0, \"minStake should be above 0\"); \n        require(_maxStake > _minStake, \"maxStake should be > minStake\"); \n \n            //-------------------------------------------------------------------- \n            // updating session related data \n            //-------------------------------------------------------------------- \n \n        uint256 _sessionId = sessionId.current(); \n        sessions[_sessionId] = Session( \n            _period, \n            _startTime+ _period, \n            _generation, \n            _interval, \n            _fee, \n            _minStake, \n            _maxStake \n        ); \n \n        sessionId.increment(); \n        lastSessionId = _sessionId; \n \n        emit SessionStarted( \n            _sessionId, \n            _generation, \n            _fee, \n            _interval, \n            _startTime, \n            _startTime + _period, \n            _minStake, \n            _maxStake \n        ); \n    } \n \n    /// @notice spend nfts and cws, burn nfts, mint a higher quality nft and send it to player \n    /// @param _sessionId id of the active session, during which nfts can be minted \n    /// @param _nfts users nfts which will be burned \n    /// @param _quality  of the new minting nft \n    /// @param _v part of signature of message \n    /// @param _r part of signature of message \n    /// @param _s part of signature of message \n    function mint( \n        uint256 _sessionId, \n        uint256[5] calldata _nfts, \n        uint8 _quality, \n        uint256 _imgId, \n        uint8 _v, \n        bytes32 _r, \n        bytes32 _s \n    ) \n        external \n    { \n        Session storage _session = sessions[_sessionId]; \n        Balance storage _balance = balances[_sessionId][msg.sender]; \n \n        require(_sessionId > 0, \"Session has not started yet\"); \n        require(_nfts.length == 5, \"Need to deposit 5 nfts\"); \n        require(_quality >= 1 && _quality <= 5, \"Quality value should range 1 - 5\"); \n        require(isActive(_sessionId), \"Session not active\"); \n        require(_balance.mintedTime == 0 || \n            (_balance.mintedTime.add(_session.interval) < block.timestamp), \n            \"Still in cooldown, try later\"); \n        require(crowns.balanceOf(msg.sender) >= _session.fee, \"Not enough CWS in your wallet\"); \n \n        //-------------------------------------------------------------------- \n        // spend crowns, burn nfts, mint new nft \n        //-------------------------------------------------------------------- \n \n        /// @dev make sure that signature of nft matches with the address of the contract deployer \n        bytes32 _messageNoPrefix = keccak256(abi.encodePacked( \n            _nfts[0], \n            _nfts[1], \n            _nfts[2], \n            _nfts[3], \n            _nfts[4], \n            _balance.totalStaked, \n            _imgId, \n            _quality \n        )); \n        bytes32 _message = keccak256(abi.encodePacked( \n            \"\\x19Ethereum Signed Message:\\n32\", _messageNoPrefix)); \n        address _recover = ecrecover(_message, _v, _r, _s); \n        require(_recover == owner(),  \"Verification failed\"); \n \n        /// @dev verify nfts ids and ownership \n        for (uint _index=0; _index < 5; _index++) { \n            require(_nfts[_index] > 0, \"Nft id must be greater than 0\"); \n            require(nft.ownerOf(_nfts[_index]) == msg.sender, \"Nft is not owned by caller\"); \n        } \n        /// @dev spend crowns \n        crowns.spendFrom(msg.sender, _session.fee); \n        /// @dev burn nfts \n        for (uint _index=0; _index < 5; _index++) { \n            nft.burn(_nfts[_index]); \n        } \n        /// @dev mint new nft \n        uint256 mintedNftId = nftFactory.mintQuality(msg.sender, _session.generation, _quality); \n        require(mintedNftId > 0, \"Failed to mint a token\"); \n        _balance.mintedTime = block.timestamp; \n        emit Minted(_sessionId, msg.sender, _nfts, _balance.mintedTime, _imgId, mintedNftId); \n    } \n \n    /// @notice stake crowns \n    /// @param _sessionId id of active session \n    /// @param _amount amount of cws to stake \n    function stake(uint256 _sessionId, uint256 _amount) external { \n        Session storage _session = sessions[_sessionId]; \n        Balance storage _balance = balances[_sessionId][msg.sender]; \n \n        require(_sessionId > 0, \"No active session\"); \n        require(isActive(_sessionId), \"Session not active\"); \n        require(_amount > 0, \"Should stake more than 0\"); \n        require(_balance.totalStaked.add(_amount) <= _session.maxStake, \n            \"Cant stake more than maxStake\"); \n        require(_balance.totalStaked.add(_amount) >= _session.minStake, \n            \"Cant stake less than minStake\"); \n        require(crowns.balanceOf(msg.sender) >= _amount, \"Not enough CWS in your wallet\"); \n        crowns.transferFrom(msg.sender, address(this), _amount); \n \n        /// @dev update balance \n        balances[_sessionId][msg.sender].totalStaked = balances[_sessionId][msg.sender] \n            .totalStaked.add(_amount); \n \n        emit Staked(_sessionId, msg.sender, _amount,  _balance.totalStaked); \n    } \n \n    /// @notice withdraw callers totalStaked crowns \n    /// @param _sessionId id of past session \n    function withdraw(uint256 _sessionId) external { \n        require(!isActive(_sessionId), \"Session should be inactive\"); \n        require(balances[_sessionId][msg.sender].totalStaked > 0, \"Total staked amount is 0\"); \n \n        /// update balance first to avoid reentrancy \n        uint256 withdrawnAmount = balances[_sessionId][msg.sender].totalStaked; \n        delete balances[_sessionId][msg.sender].totalStaked; \n \n        /// transfer crowns second \n        crowns.transfer(msg.sender, withdrawnAmount); \n \n        emit Withdrawn(msg.sender, _sessionId, withdrawnAmount, block.timestamp); \n    } \n \n    /// @notice return amount of coins staked by _owner \n    /// @param _sessionId id of active or past session \n    /// @param _owner owner of staked coins \n    /// @return token amount \n    function totalStakedBalanceOf( \n        uint256 _sessionId, \n        address _owner \n    ) \n        external \n        view \n        returns(uint256) \n    { \n        return balances[_sessionId][_owner].totalStaked; \n    } \n \n    /// @dev sets a smartcontract that mints tokens. \n    /// @dev the nft factory should give a permission on it's own side to this contract too. \n    /// @param _address nftFactory's new address \n    function setNftFactory(address _address) external onlyOwner { \n        require(_address != address(0), \"nftFactory address cant be zero\"); \n        nftFactory = NftFactory(_address); \n \n        emit FactorySet(_address); \n    } \n \n    /// @notice check whether session is active or not \n    /// @param _sessionId id of session to verify \n    /// @return true if session is active \n    function isActive(uint256 _sessionId) internal view returns(bool) { \n        if (now > sessions[_sessionId].startTime + sessions[_sessionId].period) { \n            return false; \n          } \n        return true; \n    } \n \n    /// @dev encrypt token data \n    /// @return encrypted data \n    function onERC721Received( \n        address operator, \n        address from, \n        uint256 tokenId, \n        bytes calldata data \n    ) \n        external \n        override \n        returns (bytes4) \n    { \n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")); \n    } \n \n} \n"
        ]
    },
    {
        "PdfName": "Scape Store (NFT Marketplace)_audit.pdf",
        "Code": [
            "pragma solidity ^0.6.7; \npragma experimental ABIEncoderV2; \n \nimport \"./../openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"./../openzeppelin/contracts/math/SafeMath.sol\"; \nimport \"./../openzeppelin/contracts/token/ERC721/IERC721.sol\"; \nimport \"./../openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\"; \nimport \"./../openzeppelin/contracts/token/ERC20/SafeERC20.sol\"; \nimport \"./../openzeppelin/contracts/access/Ownable.sol\"; \nimport \"./../seascape_nft/SeascapeNft.sol\"; \nimport \"./ReentrancyGuard.sol\"; \n \n/// @title Nft Market is a trading platform on seascape network allowing to buy and sell Nfts \n/// @author Nejc Schneider \ncontract NftMarket is IERC721Receiver,  ReentrancyGuard, Ownable { \n    using SafeERC20 for IERC20; \n    using SafeMath for uint256; \n \n    /// @notice individual sale related data \n    struct SalesObject { \n        uint256 id;               // sales ID \n        uint256 tokenId;          // token unique id \n        address nft;              // nft address \n        address currency;         // currency address \n        address payable seller;   // seller address \n        address payable buyer;    // buyer address \n        uint256 startTime;        // timestamp when the sale starts \n        uint256 price;            // nft price \n        uint8 status;             // 2 = sale canceled, 1 = sold, 0 = for sale \n    } \n \n    /// @dev keep count of SalesObject amount \n    uint256 public salesAmount; \n \n    /// @dev store sales objects. \n    /// @param nft token address => (nft id => salesObject) \n    mapping(address => mapping(uint256 => SalesObject)) salesObjects; // store sales in a mapping \n \n    /// @dev supported ERC721 and ERC20 contracts \n    mapping(address => bool) public supportedNft; \n    mapping(address => bool) public supportedCurrency; \n \n    /// @notice enable/disable trading \n    bool public salesEnabled; \n \n    /// @dev fee rate and fee reciever. feeAmount = (feeRate / 1000) * price \n    uint256 public feeRate; \n    address payable feeReceiver; \n \n    event Buy( \n        uint256 indexed id, \n        uint256 tokenId, \n        address buyer, \n        uint256 price, \n        uint256 tipsFee, \n        address currency \n    ); \n \n    event Sell( \n        uint256 indexed id, \n        uint256 tokenId, \n        address nft, \n        address currency, \n        address seller, \n        address buyer, \n        uint256 startTime, \n        uint256 price \n    ); \n \n    event SaleCanceled(uint256 indexed id, uint256 tokenId); \n    event NftReceived(address operator, address from, uint256 tokenId, bytes data); \n \n    /// @dev set fee reciever address and fee rate \n    /// @param _feeReceiver fee receiving address \n    /// @param _feeRate fee amount \n    constructor(address payable _feeReceiver, uint256 _feeRate) public { \n        feeReceiver = _feeReceiver; \n        feeRate = _feeRate; \n        initReentrancyStatus(); \n    } \n \n    //-------------------------------------------------- \n    // External methods \n    //-------------------------------------------------- \n \n    /// @notice enable/disable sales \n    /// @param _salesEnabled set sales to true/false \n    function enableSales(bool _salesEnabled) external onlyOwner { salesEnabled = _salesEnabled; } \n \n    /// @notice add supported nft token \n    /// @param _nftAddress ERC721 contract address \n    function addSupportedNft(address _nftAddress) external onlyOwner { \n        require(_nftAddress != address(0x0), \"invalid address\"); \n        supportedNft[_nftAddress] = true; \n    } \n \n    /// @notice disable supported nft token \n    /// @param _nftAddress ERC721 contract address \n    function removeSupportedNft(address _nftAddress) external onlyOwner { \n        require(_nftAddress != address(0x0), \"invalid address\"); \n        supportedNft[_nftAddress] = false; \n    } \n \n    /// @notice add supported currency token \n    /// @param _currencyAddress ERC20 contract address \n    function addSupportedCurrency(address _currencyAddress) external onlyOwner { \n        require(_currencyAddress != address(0x0), \"invalid address\"); \n        require(!supportedCurrency[_currencyAddress], \"currency already supported\"); \n        supportedCurrency[_currencyAddress] = true; \n    } \n \n    /// @notice disable supported currency token \n    /// @param _currencyAddress ERC20 contract address \n    function removeSupportedCurrency(address _currencyAddress) external onlyOwner { \n        require(_currencyAddress != address(0x0), \"invalid address\"); \n        require(supportedCurrency[_currencyAddress], \"currency already removed\"); \n        supportedCurrency[_currencyAddress] = false; \n    } \n \n    /// @notice change fee receiver address \n    /// @param _walletAddress address of the new fee receiver \n    function setFeeReceiver(address payable _walletAddress) external onlyOwner { \n        require(_walletAddress != address(0x0), \"invalid address\"); \n        feeReceiver = _walletAddress; \n    } \n \n    /// @notice change fee rate \n    /// @param _rate amount value. Actual rate in percent = _rate / 10 \n    function setFeeRate(uint256 _rate) external onlyOwner { \n        require(_rate <= 100, \"Rate should be bellow 100 (10%)\"); \n        feeRate = _rate; \n    } \n \n    /// @notice returns sales amount \n    /// @return total amount of sales objects \n    function getSalesAmount() external view returns(uint) { return salesAmount; } \n \n    //-------------------------------------------------- \n    // Public methods \n    //-------------------------------------------------- \n \n    /// @notice cancel nft sale \n    /// @param _tokenId nft unique ID \n    /// @param _nftAddress nft token address \n    function cancelSell(uint _tokenId, address _nftAddress) public nonReentrant { \n        SalesObject storage obj = salesObjects[_nftAddress][_tokenId]; \n        require(obj.status == 0, \"status: sold or canceled\"); \n        require(obj.seller == msg.sender, \"seller not nft owner\"); \n        require(salesEnabled, \"sales are closed\"); \n        obj.status = 2; \n        IERC721 nft = IERC721(obj.nft); \n        nft.safeTransferFrom(address(this), obj.seller, obj.tokenId); \n        emit SaleCanceled(_tokenId, obj.tokenId); \n    } \n \n    /// @notice put nft for sale \n    /// @param _tokenId nft unique ID \n    /// @param _price required price to pay by buyer. Seller receives less: price - fees \n    /// @param _nftAddress nft token address \n    /// @param _currency currency token address \n    /// @return salesAmount total amount of sales \n    function sell(uint256 _tokenId, uint256 _price, address _nftAddress, address _currency) \n        public \n        nonReentrant \n        returns(uint) \n    { \n        require(_nftAddress != address(0x0), \"invalid nft address\"); \n        require(_tokenId != 0, \"invalid nft token\"); \n        require(salesEnabled, \"sales are closed\"); \n        require(supportedNft[_nftAddress], \"nft address unsupported\"); \n        require(supportedCurrency[_currency], \"currency not supported\"); \n        IERC721(_nftAddress).safeTransferFrom(msg.sender, address(this), _tokenId); \n \n        salesAmount++; \n \n        salesObjects[_nftAddress][_tokenId] = SalesObject( \n            salesAmount, \n            _tokenId, \n            _nftAddress, \n            _currency, \n            msg.sender, \n            address(0x0), \n            now, \n            _price, \n        ); \n \n        emit Sell( \n            salesAmount, \n            _tokenId, \n            _nftAddress, \n            _currency, \n            msg.sender, \n            address(0x0), \n            now, \n            _price \n        ); \n \n        return salesAmount; \n    } \n \n    /// @dev encrypt token data \n    function onERC721Received( \n        address operator, \n        address from, \n        uint256 tokenId, \n        bytes memory data \n    ) \n        public \n        override \n        returns (bytes4) \n    { \n        //only receive the _nft staff \n        if (address(this) != operator) { \n            //invalid from nft \n            return 0; \n        } \n \n        //success \n        emit NftReceived(operator, from, tokenId, data); \n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")); \n    } \n \n    /// @notice buy nft \n    /// @param _tokenId nft unique ID \n    /// @param _nftAddress nft token address \n    /// @param _currency currency token address \n    function buy(uint _tokenId, address _nftAddress, address _currency) \n        public \n        nonReentrant \n        payable \n    { \n        SalesObject storage obj = salesObjects[_nftAddress][_tokenId]; \n        require(obj.status == 0, \"status: sold or canceled\"); \n        require(obj.startTime <= now, \"not yet for sale\"); \n        require(salesEnabled, \"sales are closed\"); \n        require(msg.sender != obj.seller, \"cant buy from yourself\"); \n \n        require(obj.currency == _currency, \"must pay same currency as sold\"); \n        uint256 price = this.getSalesPrice(_tokenId, _nftAddress); \n        uint256 tipsFee = price.mul(feeRate).div(1000); \n        uint256 purchase = price.sub(tipsFee); \n \n        if (obj.currency == address(0x0)) { \n            require (msg.value >= price, \"your price is too low\"); \n            uint256 returnBack = msg.value.sub(price); \n            if (returnBack > 0) \n                msg.sender.transfer(returnBack); \n            if (tipsFee > 0) \n                feeReceiver.transfer(tipsFee); \n            obj.seller.transfer(purchase); \n        } else { \n            IERC20(obj.currency).safeTransferFrom(msg.sender, feeReceiver, tipsFee); \n            IERC20(obj.currency).safeTransferFrom(msg.sender, obj.seller, purchase); \n        } \n \n        IERC721 nft = IERC721(obj.nft); \n        nft.safeTransferFrom(address(this), msg.sender, obj.tokenId); \n        obj.buyer = msg.sender; \n \n        obj.status = 1; \n        emit Buy(obj.id, obj.tokenId, msg.sender, price, tipsFee, obj.currency); \n    } \n \n    /// @dev fetch sale object at nftId and nftAddress \n    /// @param _tokenId unique nft ID \n    /// @param _nftAddress nft token address \n    /// @return SalesObject at given index \n    function getSales(uint _tokenId, address _nftAddress) \n        public \n        view \n        returns(SalesObject memory) \n    { \n        return salesObjects[_nftAddress][_tokenId]; \n    } \n \n    /// @dev returns the price of sale \n    /// @param _tokenId nft unique ID \n    /// @param _nftAddress nft token address \n    /// @return obj.price price of corresponding sale \n    function getSalesPrice(uint _tokenId, address _nftAddress) public view returns (uint256) { \n        SalesObject storage obj = salesObjects[_nftAddress][_tokenId]; \n        return obj.price; \n    } \n \n} \n \n"
        ]
    },
    {
        "PdfName": "Seaweed_audit.pdf",
        "Code": []
    },
    {
        "PdfName": "StakeVR_audit.pdf",
        "Code": [
            "pragma solidity =0.8.4; \n \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; \n \ncontract StakeVR is ReentrancyGuard { \n    using SafeERC20 for IERC20; \n \n    uint32 constant HUNDRED_PERCENT = 1e3; \n \n    struct Stake { \n        bool unstaked; \n        uint128 amount; \n        uint48 lockTimestamp; \n        uint16 lockDays; \n    } \n \n    IERC20 public stakingToken; \n    mapping(address => Stake[]) public stakers; \n    uint192 public totalShares; \n    uint16 public minLockDays; \n    uint16 public maxLockDays; \n    uint16 public shareBonusPerYear; \n    uint16 public shareBonusPer1MTokens; \n \n    event EStake( \n        address staker, \n        uint128 amount, \n        uint192 shares, \n        uint48 lockTimestamp, \n        uint16 lockDays, \n        uint192 totalShares \n    ); \n \n    event EUnstake( \n        address staker, \n        uint stakeIndex, \n        uint192 totalShares \n    ); \n \n    constructor( \n        IERC20 _stakingToken, \n        uint16 _minLockDays, \n        uint16 _maxLockDays, \n        uint16 _shareBonusPerYear, \n        uint16 _shareBonusPer1MTokens \n    ) { \n        require(address(_stakingToken) != address(0)); \n        require(_minLockDays <= _maxLockDays, \"StakeVR: minLockDays > maxLockDays\"); \n        stakingToken = _stakingToken; \n        minLockDays = _minLockDays; \n        maxLockDays = _maxLockDays; \n        shareBonusPerYear = _shareBonusPerYear; \n        shareBonusPer1MTokens = _shareBonusPer1MTokens; \n    } \n \n    function stake(uint128 amount, uint16 lockDays) external nonReentrant { \n        require(lockDays >= minLockDays && lockDays <= maxLockDays, \"StakeVR: invalid lockDays\"); \n        (uint192 shares,) = calculateShares(amount, lockDays); \n        totalShares += shares; \n \n        stakers[msg.sender].push(Stake( \n            false, \n            amount, \n            uint48(block.timestamp), \n            lockDays \n        )); \n        stakingToken.safeTransferFrom(msg.sender, address(this), amount); \n        emit EStake(msg.sender, amount, shares, uint48(block.timestamp), lockDays, totalShares); \n    } \n \n    function unstake(uint stakeIndex) external nonReentrant { \n        require(stakeIndex < stakers[msg.sender].length, \"StakeVR: invalid index\"); \n        Stake storage stakeRef = stakers[msg.sender][stakeIndex]; \n        require(!stakeRef.unstaked, \"StakeVR: unstaked already\"); \n        require(stakeRef.lockTimestamp + uint48(stakeRef.lockDays) * 86400 <= block.timestamp, \"Stake\n \n        (uint192 shares,) = calculateShares(stakeRef.amount, stakeRef.lockDays); \n        totalShares -= shares; \n        stakeRef.unstaked = true; \n        stakingToken.safeTransfer(msg.sender, stakeRef.amount); \n        emit EUnstake(msg.sender, stakeIndex, totalShares); \n    } \n \n    function calculateShares( \n        uint amount,  \n        uint lockDays \n    ) public view returns ( \n        uint192 shares, \n        uint longTermBonus \n    ) { \n        longTermBonus = amount * lockDays * shareBonusPerYear / 365 / HUNDRED_PERCENT; \n        uint stakingMoreBonus = amount * amount * shareBonusPer1MTokens / 1e24 / HUNDRED_PERCENT; \n        shares = uint192(amount + longTermBonus + stakingMoreBonus); \n    } \n \n    function getStakerInfo( \n        address stakerAddress \n    ) public view returns ( \n        uint256 totalStakeAmount, \n        uint256 totalStakerShares \n    ) { \n        for (uint i = 0; i < stakers[stakerAddress].length; i++) { \n            Stake storage stakeRef = stakers[stakerAddress][i]; \n            if (stakeRef.unstaked) continue; \n \n            totalStakeAmount += stakeRef.amount; \n            (uint192 shares,) = calculateShares(stakeRef.amount, stakeRef.lockDays); \n            totalStakerShares += shares; \n        } \n"
        ]
    },
    {
        "PdfName": "TKL Token_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the  ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP]. \n * \n * Implementers can declare support of contract interfaces, which can then be \n * queried by others ({ERC165Checker}). \n * \n * For an  implementation, see {ERC165}. \n */  \ninterface IERC165 { \n    /** \n     * @dev Returns true if this contract implements the  interface defined by \n     * `interfaceId`. See the  corresponding \n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces- are -identified[EIP section] \n     * to learn more  about how these ids are  created. \n     * \n     * This function call must use less than 30 000 gas. \n     */  \n    function supportsInterface(bytes4 interfaceId) external view returns (bool); \n} \n \n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Implementation of the  {IERC165} interface. \n * \n * Contracts that want to implement ERC165 should  inherit from this contract and overri\n * for the  additional interface id that will  be supported. For\n * \n * solidity \n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); \n * } \n *  \n* \n* Alternatively, {ERC165Storage} provides an  easier to use but\n  */  \n  abstract contract ERC165 is IERC165 { \n  /** \n    * @dev See {IERC165-supportsInterface}. \n      */  \n      function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n      return interfaceId == type(IERC165).interfaceId; \n      } \n      } \n \n// File: @openzeppelin/contracts/utils/Strings.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n* @dev String operations. \n  */  \n  library Strings { \n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\"; \n \n  /** \n    * @dev Converts a  `uint256` to its ASCII `string` decimal representation. \n      */  \n      function toString(uint256 value) internal pure returns (string memory) { \n      // Inspired by OraclizeAPI's implementation - MIT licence \n      // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oracl\n \n      if (value == 0) { \n      return \"0\"; \n      } \n      uint256 temp = value; \n      uint256 digits; \n      while (temp != 0) { \n      digits++; \n      temp /= 10; \n      } \n      bytes memory buffer = new bytes(digits); \n      while (value != 0) { \n      digits -= 1; \n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); \n      value /= 10; \n      } \n      return string(buffer); \n      } \n \n  /** \n    * @dev Converts a  `uint256` to its ASCII `string` hexadecimal representation. \n      */  \n      function toHexString(uint256 value) internal pure returns (string memory) { \n      if (value == 0) { \n      return \"0x00\"; \n      } \n      uint256 temp = value; \n      uint256 length = 0; \n      while (temp != 0) { \n      length++; \n      temp >>= 8; \n      } \n      return toHexString(value, length); \n      } \n \n  /** \n    * @dev Converts a  `uint256` to its ASCII `string` hexadecimal representation with fixe\n      */  \n      function toHexString(uint256 value, uint256 length) internal pure returns (string memory) { \n      bytes memory buffer = new bytes(2 * length + 2); \n      buffer[0] = \"0\"; \n      buffer[1] = \"x\"; \n      for (uint256 i = 2 * length + 1; i > 1; --i) { \n      buffer[i] = _HEX_SYMBOLS[value & 0xf]; \n      value >>= 4; \n      } \n      require(value == 0, \"Strings: hex length insufficient\"); \n      return string(buffer); \n      } \n      } \n \n// File: @openzeppelin/contracts/access/IAccessControl.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (access/IAccessControl.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n* @dev External interface of AccessControl declared to support ERC165 detection. \n  */  \n  interface IAccessControl { \n  /** \n    * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` \n    * \n    * `DEFAULT_ADMIN_ROLE` is the  starting admin for all roles, despite \n    * {RoleAdminChanged} not being emitted signaling this. \n    * \n    * _Available since v3.1._ \n      */  \n      event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed \n \n  /** \n    * @dev Emitted when `account` is granted `role`. \n    * \n    * `sender` is the  account that originated the  contract call\n    * bearer except when using {AccessControl-_setupRole}. \n      */  \n      event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender); \n \n  /** \n    * @dev Emitted when `account` is revoked `role`. \n    * \n    * `sender` is the  account that originated the  contract call\n    *   - if using `revokeRole`, it is the  admin role bearer \n    *   - if using `renounceRole`, it is the  role bearer (i.e. `account`) \n          */  \n          event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender); \n \n  /** \n    * @dev Returns `true` if `account` has been granted `role`. \n      */  \n      function hasRole(bytes32 role, address account) external view returns (bool); \n \n  /** \n    * @dev Returns the  admin role that controls `role`. See {grantRole} and \n    * {revokeRole}. \n    * \n    * To change a  role's admin, use {AccessControl-_setRoleAdmin}. \n      */  \n      function getRoleAdmin(bytes32 role) external view returns (bytes32); \n \n  /** \n    * @dev Grants `role` to `account`. \n    * \n    * If `account` had not been already granted `role`, emits a  {RoleGranted} \n    * event. \n    * \n    * Requirements: \n    * \n    * - the  caller must have ``role``'s admin role. \n        */  \n        function grantRole(bytes32 role, address account) external; \n \n  /** \n    * @dev Revokes `role` from `account`. \n    * \n    * If `account` had been granted `role`, emits a  {RoleRevoked} event. \n    * \n    * Requirements: \n    * \n    * - the  caller must have ``role``'s admin role. \n        */  \n        function revokeRole(bytes32 role, address account) external; \n \n  /** \n    * @dev Revokes `role` from the  calling account. \n    * \n    * Roles are  often managed via {grantRole} and {revokeRole}: this function's \n    * purpose is to provide a  mechanism for accounts to lose their privileges \n    * if they  are  compromised ( such\n    * \n    * If the  calling account had been granted `role`, emits a  {\n    * event. \n    * \n    * Requirements: \n    * \n    * - the  caller must be `account`. \n        */  \n        function renounceRole(bytes32 role, address account) external; \n        } \n \n// File: @openzeppelin/contracts/utils/Context.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n* @dev Provides information about the  current execution context, including \n* sender of the  transaction and its data. While these are  ge\n* via msg.sender and msg.data, they  should  not be access\n* manner, since when dealing with meta-transactions the  account sending and \n* paying for execution may not be the  actual sender (as far as an\n* is concerned). \n* \n* This contract is only required for intermediate, library- like  contracts. \n  */  \n  abstract contract Context { \n  function _msgSender() internal view virtual returns (address) { \n  return msg.sender; \n  } \n \n  function _msgData() internal view virtual returns (bytes calldata) { \n  return msg.data; \n  } \n  } \n \n// File: @openzeppelin/contracts/access/AccessControl.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (access/AccessControl.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n \n \n/** \n* @dev Contract module that allows children to implement role-based access \n* control mechanisms. This is a  lightweight version that doesn't\n* members except through off-chain means by accessing the  contract event logs. Some\n* applications may benefit from on-chain enumerability, for those cases see \n* {AccessControlEnumerable}. \n* \n* Roles are  referred to by their `bytes32` identifier. These should\n* in the  external API and be unique. The best way to achieve this is by \n* using `public constant` hash digests: \n* \n*  \n* bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\"); \n*  \n* \n* Roles can be used to represent a  set of permissions. To restrict access to \n* function call, use {hasRole}: \n* \n*  \n* function foo() public { \n*     require(hasRole(MY_ROLE, msg.sender)); \n*     ... \n* } \n*  \n* \n* Roles can be granted and revoked dynamically via the  {grantRole} and \n* {revokeRole} functions. Each role has an  associated admin role, and only \n* accounts that have a  role's admin role can call {grantRole} and {revokeRole}. \n* \n* By default, the  admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means \n* that only accounts with this role will  be able to grant or revoke other \n* roles. More complex role relationships can be created by using \n* {_setRoleAdmin}. \n* \n* WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to \n* grant and revoke this role. Extra precautions should  be taken to secure \n* accounts that have been granted it. \n  */  \n  abstract contract AccessControl is Context, IAccessControl, ERC165 { \n  struct RoleData { \n  mapping(address => bool) members; \n  bytes32 adminRole; \n  } \n \n  mapping(bytes32 => RoleData) private _roles; \n \n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00; \n \n  /** \n    * @dev Modifier that checks that an  account has a  specif\n    * with a  standardized message including the  required ro\n    * \n    * The format of the  revert reason is given by the  followin\n    * \n    *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/ \n    * \n    * _Available since v4.1._ \n      */  \n      modifier onlyRole(bytes32 role) { \n      _checkRole(role, _msgSender()); \n      _; \n      } \n \n  /** \n    * @dev See {IERC165-supportsInterface}. \n      */  \n      function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n      return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n      } \n \n  /** \n    * @dev Returns `true` if `account` has been granted `role`. \n      */  \n      function hasRole(bytes32 role, address account) public view override returns (bool) { \n      return _roles[role].members[account]; \n      } \n \n  /** \n    * @dev Revert with a  standard message if `account` is missing `role`. \n    * \n    * The format of the  revert reason is given by the  followin\n    * \n    *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/ \n       */  \n       function _checkRole(bytes32 role, address account) internal view { \n       if (!hasRole(role, account)) { \n       revert( \n       string( \n       abi.encodePacked( \n       \"AccessControl: account \", \n       Strings.toHexString(uint160(account), 20), \n       \" is missing role \", \n       Strings.toHexString(uint256(role), 32) \n       ) \n       ) \n       ); \n       } \n       } \n \n  /** \n    * @dev Returns the  admin role that controls `role`. See {grantRole} and \n    * {revokeRole}. \n    * \n    * To change a  role's admin, use {_setRoleAdmin}. \n      */  \n      function getRoleAdmin(bytes32 role) public view override returns (bytes32) { \n      return _roles[role].adminRole; \n      } \n \n  /** \n    * @dev Grants `role` to `account`. \n    * \n    * If `account` had not been already granted `role`, emits a  {RoleGranted} \n    * event. \n    * \n    * Requirements: \n    * \n    * - the  caller must have ``role``'s admin role. \n        */  \n        function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdm\n        _grantRole(role, account); \n        } \n \n  /** \n    * @dev Revokes `role` from `account`. \n    * \n    * If `account` had been granted `role`, emits a  {RoleRevoked} event. \n    * \n    * Requirements: \n    * \n    * - the  caller must have ``role``'s admin role. \n        */  \n        function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAd\n        _revokeRole(role, account); \n        } \n \n  /** \n    * @dev Revokes `role` from the  calling account. \n    * \n    * Roles are  often managed via {grantRole} and {revokeRole}: this function's \n    * purpose is to provide a  mechanism for accounts to lose their privileges \n    * if they  are  compromised ( such\n    * \n    * If the  calling account had been revoked `role`, emits a  \n    * event. \n    * \n    * Requirements: \n    * \n    * - the  caller must be `account`. \n        */  \n        function renounceRole(bytes32 role, address account) public virtual override { \n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\"); \n \n    _revokeRole(role, account); \n    } \n \n  /** \n    * @dev Grants `role` to `account`. \n    * \n    * If `account` had not been already granted `role`, emits a  {RoleGranted} \n    * event. Note that unlike {grantRole}, this function doesn't  perform any \n    * checks on the  calling account. \n    * \n    * [WARNING] \n    * ==== \n    * This function should  only be called from the  constructo\n    * up the  initial roles for the  system. \n    * \n    * Using this function in any other way is effectively circumventing the  admin \n    * system imposed by {AccessControl}. \n    * ==== \n    * \n    * NOTE:  This function is deprecated in favor of {_grantRole}. \n      */  \n      function _setupRole(bytes32 role, address account) internal virtual { \n      _grantRole(role, account); \n      } \n \n  /** \n    * @dev Sets `adminRole` as ``role``'s admin role. \n    * \n    * Emits a  {RoleAdminChanged} event. \n      */  \n      function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual { \n      bytes32 previousAdminRole = getRoleAdmin(role); \n      _roles[role].adminRole = adminRole; \n      emit RoleAdminChanged(role, previousAdminRole, adminRole); \n      } \n \n  /** \n    * @dev Grants `role` to `account`. \n    * \n    * Internal function without access restriction. \n      */  \n      function _grantRole(bytes32 role, address account) internal virtual { \n      if (!hasRole(role, account)) { \n      _roles[role].members[account] = true; \n      emit RoleGranted(role, account, _msgSender()); \n      } \n      } \n \n  /** \n    * @dev Revokes `role` from `account`. \n    * \n    * Internal function without access restriction. \n      */  \n      function _revokeRole(bytes32 role, address account) internal virtual { \n      if (hasRole(role, account)) { \n      _roles[role].members[account] = false; \n      emit RoleRevoked(role, account, _msgSender()); \n      } \n      } \n      } \n \n// File: @openzeppelin/contracts/security/Pausable.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n \n/** \n* @dev Contract module which allows children to implement an  emergency stop \n* mechanism that can be triggered by an  authorized account. \n* \n* This module is used through inheritance. It will  make available the\n* modifiers `whenNotPaused` and `whenPaused`, which can be applied to \n* the  functions of your  contract. Note that the\n* simply  including this module, only once the  modifiers \n  */  \n  abstract contract Pausable is Context { \n  /** \n    * @dev Emitted when the  pause is triggered by `account`. \n      */  \n      event Paused(address account); \n \n  /** \n    * @dev Emitted when the  pause is lifted by `account`. \n      */  \n      event Unpaused(address account); \n \n  bool private _paused; \n \n  /** \n    * @dev Initializes the  contract in unpaused state. \n      */  \n      constructor() { \n      _paused = false; \n      } \n \n  /** \n    * @dev Returns true if the  contract is paused, and false otherwise. \n      */  \n      function paused() public view virtual returns (bool) { \n      return _paused; \n      } \n \n  /** \n    * @dev Modifier to make a  function callable only when the\n    * \n    * Requirements: \n    * \n    * - The contract must not be paused. \n        */  \n        modifier whenNotPaused() { \n        require(!paused(), \"Pausable: paused\"); \n        _; \n        } \n \n  /** \n    * @dev Modifier to make a  function callable only when the\n    * \n    * Requirements: \n    * \n    * - The contract must be paused. \n        */  \n        modifier whenPaused() { \n        require(paused(), \"Pausable: not paused\"); \n        _; \n        } \n \n  /** \n    * @dev Triggers stopped state. \n    * \n    * Requirements: \n    * \n    * - The contract must not be paused. \n        */  \n        function _pause() internal virtual whenNotPaused { \n        _paused = true; \n        emit Paused(_msgSender()); \n        } \n \n  /** \n    * @dev Returns to normal state. \n    * \n    * Requirements: \n    * \n    * - The contract must be paused. \n        */  \n        function _unpause() internal virtual whenPaused { \n        _paused = false; \n        emit Unpaused(_msgSender()); \n        } \n        } \n \n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n* @dev Interface of the  ERC20 standard as defined in the\n  */  \n  interface IERC20 { \n  /** \n    * @dev Returns the  amount of tokens in existence. \n      */  \n      function totalSupply() external view returns (uint256); \n \n  /** \n    * @dev Returns the  amount of tokens owned by `account`. \n      */  \n      function balanceOf(address account) external view returns (uint256); \n \n  /** \n    * @dev Moves `amount` tokens from the  caller's account to `recipient`. \n    * \n    * Returns a  boolean value indicating whether the  operat\n    * \n    * Emits a  {Transfer} event. \n      */  \n      function transfer(address recipient, uint256 amount) external returns (bool); \n \n  /** \n    * @dev Returns the  remaining number of tokens that `spender` will\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is \n    * zero by default. \n    * \n    * This value changes when {approve} or {transferFrom} are  called. \n      */  \n      function allowance(address owner, address spender) external view returns (uint256); \n \n  /** \n    * @dev Sets `amount` as the  allowance of `spender` over the\n    * \n    * Returns a  boolean value indicating whether the  operat\n    * \n    * IMPORTANT: Beware that changing an  allowance with this method brings \n    * that someone may use both the  old and the  new allow\n    * transaction ordering. One possible solution to mitigate this race \n    * condition is to first reduce the  spender's allowance to 0 and set the\n    * desired value afterwards: \n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n    * \n    * Emits an  {Approval} event. \n      */  \n      function approve(address spender, uint256 amount) external returns (bool); \n \n  /** \n    * @dev Moves `amount` tokens from `sender` to `recipient` using the  \n    * allowance mechanism. `amount` is then deducted from the  caller's \n    * allowance. \n    * \n    * Returns a  boolean value indicating whether the  operat\n    * \n    * Emits a  {Transfer} event. \n      */  \n      function transferFrom( \n      address sender, \n      address recipient, \n      uint256 amount \n      ) external returns (bool); \n \n  /** \n    * @dev Emitted when `value` tokens are  moved from one account (`from`) to \n    * another (`to`). \n    * \n    * Note that `value` may be zero. \n      */  \n      event Transfer(address indexed from, address indexed to, uint256 value); \n \n  /** \n    * @dev Emitted when the  allowance of a  `spender` for \n    * a  call to {approve}. `value` is the  new allowance. \n      */  \n      event Approval(address indexed owner, address indexed spender, uint256 value); \n      } \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n \n/** \n* @dev Interface for the  optional metadata functions from the\n* \n* _Available since v4.1._ \n  */  \n  interface IERC20Metadata is IERC20 { \n  /** \n    * @dev Returns the  name of the  token. \n      */  \n      function name() external view returns (string memory); \n \n  /** \n    * @dev Returns the  symbol of the  token. \n      */  \n      function symbol() external view returns (string memory); \n \n  /** \n    * @dev Returns the  decimals places of the  token. \n      */  \n      function decimals() external view returns (uint8); \n      } \n \n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n \n/** \n* @dev Implementation of the  {IERC20} interface. \n* \n* This implementation is agnostic to the  way tokens are  cr\n* that a  supply mechanism has to be added in a  derived co\n* For a  generic mechanism see {ERC20PresetMinterPauser}. \n* \n* TIP: For a  detailed writeup see our guide \n* https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n* to implement supply mechanisms]. \n* \n* We have followed general OpenZeppelin Contracts guidelines: functions revert \n* instead returning `false` on failure. This behavior is nonetheless \n* conventional and does not conflict with the  expectations of ERC20 \n* applications. \n* \n* Additionally, an  {Approval} event is emitted on calls to {transferFrom}. \n* This allows applications to reconstruct the  allowance for all accounts j\n* by listening to said events. Other implementations of the  EIP may not emit \n* these events, as it isn't  required by the  specification. \n* \n* Finally, the  non-standard {decreaseAllowance} and {increaseAllowance} \n* functions have been added to mitigate the  well-known issues around setting \n* allowances. See {IERC20-approve}. \n  */  \n  contract ERC20 is Context, IERC20, IERC20Metadata { \n  mapping(address => uint256) private _balances; \n \n  mapping(address => mapping(address => uint256)) private _allowances; \n \n  uint256 private _totalSupply; \n \n  string private _name; \n  string private _symbol; \n \n  /** \n    * @dev Sets the  values for {name} and {symbol}. \n    * \n    * The default value of {decimals} is 18. To select a  different value for \n    * {decimals} you  should  overload it. \n    * \n    * All two of these values are  immutable: they  can only b\n    * construction. \n      */  \n      constructor(string memory name_, string memory symbol_) { \n      _name = name_; \n      _symbol = symbol_; \n      } \n \n  /** \n    * @dev Returns the  name of the  token. \n      */  \n      function name() public view virtual override returns (string memory) { \n      return _name; \n      } \n \n  /** \n    * @dev Returns the  symbol of the  token, usually \n    * name. \n      */  \n      function symbol() public view virtual override returns (string memory) { \n      return _symbol; \n      } \n \n  /** \n    * @dev Returns the  number of decimals used to get its user representation. \n    * For example, if `decimals` equals `2`, a  balance of `505` tokens shoul\n    * be displayed to a  user as `5.05` (`505 / 10 ** 2`). \n    * \n    * Tokens usually opt for a  value of 18, imitating the  relati\n    * Ether and Wei. This is the  value {ERC20} uses, unless this function is \n    * overridden; \n    * \n    * NOTE:  This information is only used for _display_ purposes: it in \n    * no way affects any of the  arithmetic of the  contract, inc\n    * {IERC20-balanceOf} and {IERC20-transfer}. \n      */  \n      function decimals() public view virtual override returns (uint8) { \n      return 18; \n      } \n \n  /** \n    * @dev See {IERC20-totalSupply}. \n      */  \n      function totalSupply() public view virtual override returns (uint256) { \n      return _totalSupply; \n      } \n \n  /** \n    * @dev See {IERC20-balanceOf}. \n      */  \n      function balanceOf(address account) public view virtual override returns (uint256) { \n      return _balances[account]; \n      } \n \n  /** \n    * @dev See {IERC20-transfer}. \n    * \n    * Requirements: \n    * \n    * - `recipient` cannot be the  zero address. \n    * - the  caller must have a  balance of at least `amount`. \n        */  \n        function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount); \n        return true; \n        } \n \n  /** \n    * @dev See {IERC20-allowance}. \n      */  \n      function allowance(address owner, address spender) public view virtual override returns (uint25\n      return _allowances[owner][spender]; \n      } \n \n  /** \n    * @dev See {IERC20-approve}. \n    * \n    * Requirements: \n    * \n    * - `spender` cannot be the  zero address. \n        */  \n        function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n        } \n \n  /** \n    * @dev See {IERC20-transferFrom}. \n    * \n    * Emits an  {Approval} event indicating the  updated allow\n    * required by the  EIP. See the  note at the\n    * \n    * Requirements: \n    * \n    * - `sender` and `recipient` cannot be the  zero address. \n    * - `sender` must have a  balance of at least `amount`. \n    * - the  caller must have allowance for ``sender``'s tokens of at least \n    * `amount`. \n      */  \n      function transferFrom( \n      address sender, \n      address recipient, \n      uint256 amount \n      ) public virtual override returns (bool) { \n      _transfer(sender, recipient, amount); \n \n      uint256 currentAllowance = _allowances[sender][_msgSender()]; \n      require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n      unchecked { \n      _approve(sender, _msgSender(), currentAllowance - amount); \n      } \n \n      return true; \n      } \n \n  /** \n    * @dev Atomically increases the  allowance granted to `spender` by th\n    * \n    * This is an  alternative to {approve} that can be used as a\n    * problems described in {IERC20-approve}. \n    * \n    * Emits an  {Approval} event indicating the  updated allow\n    * \n    * Requirements: \n    * \n    * - `spender` cannot be the  zero address. \n        */  \n        function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue); \n        return true; \n        } \n \n  /** \n    * @dev Atomically decreases the  allowance granted to `spender` by t\n    * \n    * This is an  alternative to {approve} that can be used as a\n    * problems described in {IERC20-approve}. \n    * \n    * Emits an  {Approval} event indicating the  updated allow\n    * \n    * Requirements: \n    * \n    * - `spender` cannot be the  zero address. \n    * - `spender` must have allowance for the  caller of at least \n    * `subtractedValue`. \n      */  \n      function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bo\n      uint256 currentAllowance = _allowances[_msgSender()][spender]; \n      require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\"); \n      unchecked { \n      _approve(_msgSender(), spender, currentAllowance - subtractedValue); \n      } \n \n      return true; \n      } \n \n  /** \n    * @dev Moves `amount` of tokens from `sender` to `recipient`. \n    * \n    * This internal function is equivalent to {transfer}, and can be used to \n    * e.g. implement automatic token fees, slashing mechanisms, etc. \n    * \n    * Emits a  {Transfer} event. \n    * \n    * Requirements: \n    * \n    * - `sender` cannot be the  zero address. \n    * - `recipient` cannot be the  zero address. \n    * - `sender` must have a  balance of at least `amount`. \n        */  \n        function _transfer( \n        address sender, \n        address recipient, \n        uint256 amount \n        ) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n    _beforeTokenTransfer(sender, recipient, amount); \n \n    uint256 senderBalance = _balances[sender]; \n    require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n    unchecked { \n    _balances[sender] = senderBalance - amount; \n    } \n    _balances[recipient] += amount; \n \n    emit Transfer(sender, recipient, amount); \n \n    _afterTokenTransfer(sender, recipient, amount); \n    } \n \n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n    * the  total supply. \n    * \n    * Emits a  {Transfer} event with `from` set to the  zero addr\n    * \n    * Requirements: \n    * \n    * - `account` cannot be the  zero address. \n        */  \n        function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n    _beforeTokenTransfer(address(0), account, amount); \n \n    _totalSupply += amount; \n    _balances[account] += amount; \n    emit Transfer(address(0), account, amount); \n \n    _afterTokenTransfer(address(0), account, amount); \n    } \n \n  /** \n    * @dev Destroys `amount` tokens from `account`, reducing the  \n    * total supply. \n    * \n    * Emits a  {Transfer} event with `to` set to the  zero addres\n    * \n    * Requirements: \n    * \n    * - `account` cannot be the  zero address. \n    * - `account` must have at least `amount` tokens. \n        */  \n        function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n    _beforeTokenTransfer(account, address(0), amount); \n \n    uint256 accountBalance = _balances[account]; \n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\"); \n    unchecked { \n    _balances[account] = accountBalance - amount; \n    } \n    _totalSupply -= amount; \n \n    emit Transfer(account, address(0), amount); \n \n    _afterTokenTransfer(account, address(0), amount); \n    } \n \n  /** \n    * @dev Sets `amount` as the  allowance of `spender` over the\n    * \n    * This internal function is equivalent to `approve`, and can be used to \n    * e.g. set automatic allowances for certain subsystems, etc. \n    * \n    * Emits an  {Approval} event. \n    * \n    * Requirements: \n    * \n    * - `owner` cannot be the  zero address. \n    * - `spender` cannot be the  zero address. \n        */  \n        function _approve( \n        address owner, \n        address spender, \n        uint256 amount \n        ) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n    _allowances[owner][spender] = amount; \n    emit Approval(owner, spender, amount); \n    } \n \n  /** \n    * @dev Hook that is called before any transfer of tokens. This includes \n    * minting and burning. \n    * \n    * Calling conditions: \n    * \n    * - when `from` and `to` are  both non-zero, `amount` of ``from``'s tokens \n    * will  be transferred to `to`. \n    * - when `from` is zero, `amount` tokens will  be minted for `to`. \n    * - when `to` is zero, `amount` of ``from``'s tokens will  be burned. \n    * - `from` and `to` are  never both zero. \n    * \n    * To learn more  about hooks, head to xref:ROOT:extending-contracts.adoc#using-hoo\n      */  \n      function _beforeTokenTransfer( \n      address from, \n      address to, \n      uint256 amount \n      ) internal virtual {} \n \n  /** \n    * @dev Hook that is called after any transfer of tokens. This includes \n    * minting and burning. \n    * \n    * Calling conditions: \n    * \n    * - when `from` and `to` are  both non-zero, `amount` of ``from``'s tokens \n    * has been transferred to `to`. \n    * - when `from` is zero, `amount` tokens have been minted for `to`. \n    * - when `to` is zero, `amount` of ``from``'s tokens have been burned. \n    * - `from` and `to` are  never both zero. \n    * \n    * To learn more  about hooks, head to xref:ROOT:extending-contracts.adoc#using-hoo\n      */  \n      function _afterTokenTransfer( \n      address from, \n      address to, \n      uint256 amount \n      ) internal virtual {} \n      } \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/ERC20Burnable.sol) \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n/** \n* @dev Extension of {ERC20} that allows token holders to destroy both their own \n* tokens and those that they  have an  allowance for, in \n* recognized off-chain (via event analysis). \n  */  \n  abstract contract ERC20Burnable is Context, ERC20 { \n  /** \n    * @dev Destroys `amount` tokens from the  caller. \n    * \n    * See {ERC20-_burn}. \n      */  \n      function burn(uint256 amount) public virtual { \n      _burn(_msgSender(), amount); \n      } \n \n  /** \n    * @dev Destroys `amount` tokens from `account`, deducting from the  caller's \n    * allowance. \n    * \n    * See {ERC20-_burn} and {ERC20-allowance}. \n    * \n    * Requirements: \n    * \n    * - the  caller must have allowance for ``accounts``'s tokens of at least \n    * `amount`. \n      */  \n      function burnFrom(address account, uint256 amount) public virtual { \n      uint256 currentAllowance = allowance(account, _msgSender()); \n      require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\"); \n      unchecked { \n      _approve(account, _msgSender(), currentAllowance - amount); \n      } \n      _burn(account, amount); \n      } \n      } \n \n// File: contracts/TKLRole.sol \n \n \n",
            "pragma solidity ^0.8.2; \n \n \n \n \n \ncontract TKL is ERC20, ERC20Burnable, Pausable, AccessControl { \n \n    address [20] private _whiteAddress = [ \n    0x60A2aF5F6309840335Dc4896a1D330940Bf95b91, \n    0xe65AEEfa511ee4Fd34eA6A4b062a8ED7f3Df747d, \n    0x7c861f5fF977b906416Bff7fa4003ce0C77BCb2E, \n    0x3CD5E18739991032963D8AaBCF1a96b42930f5b9, \n    0xa4Edb9fbBD0fece358d38AE8F70f398486b51ba0, \n    0x6916771D1b7856c16CcDd34561Dc23e68D408a34, \n    0x2f3F1814662344B76E679eC68e96DF1622cbca43, \n    0x7578e019dEBA6a7a95F037083c13b336a47b1f4E, \n    0x411B1C0fD58df164E65386556673e70157219df8, \n    0x7c4b2d955067Bd62233c9582bceE4d60f0fa5D90, \n    0x6C9437A1CC3f2D33aa7734403f884BB1755fD001, \n    0xffe1dC4B2F0811a9fEf3c238bd9935B0428F7C40, \n    0xB4cEf04DF82eD67675Ae5684AE04f662f9D76698, \n    0xc95cA041ad2aF8D3F353e48B842bA94b45c9Ecdc, \n    0xa1D156be0f35BD884460158d625cCEca2030323d, \n    0x2B8c117CC169946A872718aca2Ca24727579CeC2, \n    0x7690E8Dc6AD19006D161C6dC22De526b60D97C86, \n    0x8f3AfCB215A70A09583fA5d8839023953F90d2f4, \n    0xA5Ccf6258cab11105bD688B1DC8c33a5Fe08870a, \n    0x028f2FFdD938C72e6d0169eB991CA084Eb98648d \n    ]; \n \n    uint256 public GameLockBalance  = 500000000 * 10 ** decimals(); \n    uint256 public StakeLockBalance = 9000000000 * 10 ** decimals(); \n \n    address public LiquidityPool = 0x3629D6E1f8013b1f76858E30aaa5612aC9833750; \n \n    bytes32 public constant UNLOCKER_ROLE = keccak256(\"UNLOCKER_ROLE\"); \n \n    constructor() ERC20(\"TKL\", \"TKL\") { \n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); \n        _grantRole(UNLOCKER_ROLE, msg.sender); \n \n        _mint(address(this), GameLockBalance); \n        _mint(address(this), StakeLockBalance); \n        _mint(0x3E7ba5ce0b25118F5A20CB0Be76b16b86E9c9c92, 100000000 * 10 ** decimals()); \n        _mint(0x3D8Ec132882FDF2d538E91e2226357c41E19AEc2, 100000000 * 10 ** decimals()); \n        _mint(0x96824F32b4BfFEEede15bf9dE97E7a43fce7B486, 300000000 * 10 ** decimals()); \n    } \n \n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) { \n        _pause(); \n    } \n \n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) { \n        _unpause(); \n    } \n \n    function _beforeTokenTransfer(address from, address to, uint256 amount) \n    internal \n    whenNotPaused \n    override \n    { \n        super._beforeTokenTransfer(from, to, amount); \n    } \n \n    function transferFrom(address sender, address recipient, uint256 amount) public override returns \n        require(sender != address(0), \"ERC20: send not allow the zero address\"); \n \n        for(uint i = 0; i < _whiteAddress.length; i++) { \n            if (sender == _whiteAddress[i]){ \n                super.transferFrom(sender,recipient,amount); \n                return true; \n            } \n \n        } \n        uint256 _fee = amount*5/100; \n        uint256 _rest = amount-_fee*2; \n \n        _transfer(sender, LiquidityPool, _fee); \n \n        _transfer(sender, recipient, _rest); \n"
        ]
    },
    {
        "PdfName": "TPAY_audit.pdf",
        "Code": [
            "pragma solidity ^0.4.18; \n \n// File: zeppelin-solidity/contracts/math/SafeMath.sol \n \n/** \n * @title SafeMath \n * @dev Math operations with safety checks that throw on error \n */ \nlibrary SafeMath { \n  function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n    if (a == 0) { \n      return 0; \n    } \n    uint256 c = a * b; \n    assert(c / a == b); \n    return c; \n  } \n \n  function div(uint256 a, uint256 b) internal pure returns (uint256) { \n    // assert(b > 0); // Solidity automatically throws when dividing by 0 \n    uint256 c = a / b; \n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n    return c; \n  } \n \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n    assert(b <= a); \n    return a - b; \n  } \n \n  function add(uint256 a, uint256 b) internal pure returns (uint256) { \n    uint256 c = a + b; \n    assert(c >= a); \n    return c; \n  } \n} \n \n// File: zeppelin-solidity/contracts/token/ERC20Basic.sol \n \n/** \n * @title ERC20Basic \n * @dev Simpler version of ERC20 interface \n * @dev see https://github.com/ethereum/EIPs/issues/179 \n */ \ncontract ERC20Basic { \n  uint256 public totalSupply; \n  function balanceOf(address who) public view returns (uint256); \n  function transfer(address to, uint256 value) public returns (bool); \n  event Transfer(address indexed from, address indexed to, uint256 value); \n} \n \n// File: zeppelin-solidity/contracts/token/BasicToken.sol \n \n/** \n * @title Basic token \n * @dev Basic version of StandardToken, with no allowances. \n */ \ncontract BasicToken is ERC20Basic { \n  using SafeMath for uint256; \n \n  mapping(address => uint256) balances; \n \n  /** \n  * @dev transfer token for a specified address \n  * @param _to The address to transfer to. \n  * @param _value The amount to be transferred. \n  */ \n  function transfer(address _to, uint256 _value) public returns (bool) { \n \n \n    require(_to != address(0)); \n    require(_value <= balances[msg.sender]); \n \n    // SafeMath.sub will throw if there is not enough balance. \n    balances[msg.sender] = balances[msg.sender].sub(_value); \n    balances[_to] = balances[_to].add(_value); \n    Transfer(msg.sender, _to, _value); \n    return true; \n  } \n \n  /** \n  * @dev Gets the balance of the specified address. \n  * @param _owner The address to query the the balance of. \n  * @return An uint256 representing the amount owned by the passed address. \n  */ \n  function balanceOf(address _owner) public view returns (uint256 balance) { \n    return balances[_owner]; \n  } \n \n} \n \n// File: zeppelin-solidity/contracts/token/ERC20.sol \n \n/** \n * @title ERC20 interface \n * @dev see https://github.com/ethereum/EIPs/issues/20 \n */ \ncontract ERC20 is ERC20Basic { \n  function allowance(address owner, address spender) public view returns (uint256); \n  function transferFrom(address from, address to, uint256 value) public returns (bool); \n  function approve(address spender, uint256 value) public returns (bool); \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n// File: zeppelin-solidity/contracts/token/StandardToken.sol \n \n/** \n * @title Standard ERC20 token \n * \n * @dev Implementation of the basic standard token. \n * @dev https://github.com/ethereum/EIPs/issues/20 \n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract\n */ \ncontract StandardToken is ERC20, BasicToken { \n \n  mapping (address => mapping (address => uint256)) internal allowed; \n \n \n  /** \n   * @dev Transfer tokens from one address to another \n   * @param _from address The address which you want to send tokens from \n   * @param _to address The address which you want to transfer to \n   * @param _value uint256 the amount of tokens to be transferred \n   */ \n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { \n    require(_to != address(0)); \n    require(_value <= balances[_from]); \n    require(_value <= allowed[_from][msg.sender]); \n \n    balances[_from] = balances[_from].sub(_value); \n    balances[_to] = balances[_to].add(_value); \n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); \n    Transfer(_from, _to, _value); \n    return true; \n  } \n \n  /** \n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * \n   * Beware that changing an allowance with this method brings the risk that someone may use both the \n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate thi\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwa\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n   * @param _spender The address which will spend the funds. \n   * @param _value The amount of tokens to be spent. \n   */ \n  function approve(address _spender, uint256 _value) public returns (bool) { \n    allowed[msg.sender][_spender] = _value; \n    Approval(msg.sender, _spender, _value); \n    return true; \n  } \n \n  /** \n   * @dev Function to check the amount of tokens that an owner allowed to a spender. \n   * @param _owner address The address which owns the funds. \n   * @param _spender address The address which will spend the funds. \n   * @return A uint256 specifying the amount of tokens still available for the spender. \n   */ \n  function allowance(address _owner, address _spender) public view returns (uint256) { \n    return allowed[_owner][_spender]; \n  } \n \n  /** \n   * @dev Increase the amount of tokens that an owner allowed to a spender. \n   * \n   * approve should be called when allowed[_spender] == 0. To increment \n   * allowed value is better to use this function to avoid 2 calls (and wait until \n   * the first transaction is mined) \n   * From MonolithDAO Token.sol \n   * @param _spender The address which will spend the funds. \n   * @param _addedValue The amount of tokens to increase the allowance by. \n   */ \n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) { \n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); \n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]); \n    return true; \n  } \n \n  /** \n   * @dev Decrease the amount of tokens that an owner allowed to a spender. \n   * \n   * approve should be called when allowed[_spender] == 0. To decrement \n   * allowed value is better to use this function to avoid 2 calls (and wait until \n   * the first transaction is mined) \n   * From MonolithDAO Token.sol \n   * @param _spender The address which will spend the funds. \n   * @param _subtractedValue The amount of tokens to decrease the allowance by. \n   */ \n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { \n    uint oldValue = allowed[msg.sender][_spender]; \n    if (_subtractedValue > oldValue) { \n      allowed[msg.sender][_spender] = 0; \n    } else { \n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); \n    } \n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]); \n"
        ]
    },
    {
        "PdfName": "UpOnly (UPO) Token_audit.pdf",
        "Code": [
            "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the  ERC20 standard as defined in the\n */  \ninterface IERC20 { \n    /** \n     * @dev Returns the  amount of tokens in existence. \n     */  \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the  amount of tokens owned by `account`. \n     */  \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the  caller's account to `recipient`. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the  remaining number of tokens that `spender` will\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are  called. \n     */  \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the  allowance of `spender` over the\n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * IMPORTANT: Beware that changing an  allowance with this method brings \n     * that someone may use both the  old and the  new allow\n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the  spender's allowance to 0 and set the\n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an  {Approval} event. \n     */  \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the  \n     * allowance mechanism. `amount` is then deducted from the  caller's \n     * allowance. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are  moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */  \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the  allowance of a  `spender` for \n     * a  call to {approve}. `value` is the  new allowance. \n     */  \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Interface for the  optional metadata functions from the\n * \n * _Available since v4.1._ \n */  \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the  name of the  token. \n     */  \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the  symbol of the  token. \n     */  \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the  decimals places of the  token. \n     */  \n    function decimals() external view returns (uint8); \n} \n \n// File: @openzeppelin/contracts/utils/Context.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n * @dev Provides information about the  current execution context, including \n * sender of the  transaction and its data. While these are  g\n * via msg.sender and msg.data, they  should  not be acces\n * manner, since when dealing with meta-transactions the  account sending and \n * paying for execution may not be the  actual sender (as far as an\n * is concerned). \n * \n * This contract is only required for intermediate, library- like  contracts. \n */  \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes calldata) { \n        return msg.data; \n    } \n} \n \n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n \n/** \n * @dev Implementation of the  {IERC20} interface. \n * \n * This implementation is agnostic to the  way tokens are  cr\n * that a  supply mechanism has to be added in a  derived co\n * For a  generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a  detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin Contracts guidelines: functions revert \n * instead returning `false` on failure. This behavior is nonetheless \n * conventional and does not conflict with the  expectations of ERC20 \n * applications. \n * \n * Additionally, an  {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the  allowance for all accounts j\n * by listening to said events. Other implementations of the  EIP may not emit \n * these events, as it isn't  required by the  specification. \n * \n * Finally, the  non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the  well-known issues around setting \n * allowances. See {IERC20-approve}. \n */  \ncontract ERC20 is Context, IERC20, IERC20Metadata { \n    mapping(address => uint256) private _balances; \n \n    mapping(address => mapping(address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n \n    /** \n     * @dev Sets the  values for {name} and {symbol}. \n     * \n     * The default value of {decimals} is 18. To select a  different value for \n     * {decimals} you  should  overload it. \n     * \n     * All two of these values are  immutable: they  can only b\n     * construction. \n     */  \n    constructor(string memory name_, string memory symbol_) { \n        _name = name_; \n        _symbol = symbol_; \n    } \n \n    /** \n     * @dev Returns the  name of the  token. \n     */  \n    function name() public view virtual override returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the  symbol of the  token, usually \n     * name. \n     */  \n    function symbol() public view virtual override returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the  number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a  balance of `505` tokens shou\n     * be displayed to a  user as `5.05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a  value of 18, imitating the  relat\n     * Ether and Wei. This is the  value {ERC20} uses, unless this function is \n     * overridden; \n     * \n     * NOTE:  This information is only used for _display_ purposes: it in \n     * no way affects any of the  arithmetic of the  contract, inc\n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */  \n    function decimals() public view virtual override returns (uint8) { \n        return 18; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */  \n    function totalSupply() public view virtual override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */  \n    function balanceOf(address account) public view virtual override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the  zero address. \n     * - the  caller must have a  balance of at least `amount`. \n     */  \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */  \n    function allowance(address owner, address spender) public view virtual override returns (uint256) \n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the  zero address. \n     */  \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an  {Approval} event indicating the  updated allow\n     * required by the  EIP. See the  note at the\n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the  zero address. \n     * - `sender` must have a  balance of at least `amount`. \n     * - the  caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */  \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) public virtual override returns (bool) { \n        _transfer(sender, recipient, amount); \n \n        uint256 currentAllowance = _allowances[sender][_msgSender()]; \n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n        unchecked { \n            _approve(sender, _msgSender(), currentAllowance - amount); \n        } \n \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the  allowance granted to `spender` by t\n     * \n     * This is an  alternative to {approve} that can be used as a\n     * problems described in {IERC20-approve}. \n     * \n     * Emits an  {Approval} event indicating the  updated allow\n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the  zero address. \n     */  \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the  allowance granted to `spender` by t\n     * \n     * This is an  alternative to {approve} that can be used as a\n     * problems described in {IERC20-approve}. \n     * \n     * Emits an  {Approval} event indicating the  updated allow\n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the  zero address. \n     * - `spender` must have allowance for the  caller of at least \n     * `subtractedValue`. \n     */  \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        uint256 currentAllowance = _allowances[_msgSender()][spender]; \n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\"); \n        unchecked { \n            _approve(_msgSender(), spender, currentAllowance - subtractedValue); \n        } \n \n        return true; \n    } \n \n    /** \n     * @dev Moves `amount` of tokens from `sender` to `recipient`. \n     * \n     * This internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a  {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the  zero address. \n     * - `recipient` cannot be the  zero address. \n     * - `sender` must have a  balance of at least `amount`. \n     */  \n    function _transfer( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        uint256 senderBalance = _balances[sender]; \n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n        unchecked { \n            _balances[sender] = senderBalance - amount; \n        } \n        _balances[recipient] += amount; \n \n        emit Transfer(sender, recipient, amount); \n \n        _afterTokenTransfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the  total supply. \n     * \n     * Emits a  {Transfer} event with `from` set to the  zero add\n     * \n     * Requirements: \n     * \n     * - `account` cannot be the  zero address. \n     */  \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply += amount; \n        _balances[account] += amount; \n        emit Transfer(address(0), account, amount); \n \n        _afterTokenTransfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the  \n     * total supply. \n     * \n     * Emits a  {Transfer} event with `to` set to the  zero addres\n     * \n     * Requirements: \n     * \n     * - `account` cannot be the  zero address. \n     * - `account` must have at least `amount` tokens. \n     */  \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        uint256 accountBalance = _balances[account]; \n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\"); \n        unchecked { \n            _balances[account] = accountBalance - amount; \n        } \n        _totalSupply -= amount; \n \n        emit Transfer(account, address(0), amount); \n \n        _afterTokenTransfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the  allowance of `spender` over the\n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an  {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the  zero address. \n     * - `spender` cannot be the  zero address. \n     */  \n    function _approve( \n        address owner, \n        address spender, \n        uint256 amount \n    ) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are  both non-zero, `amount` of ``from``'s tokens \n     * will  be transferred to `to`. \n     * - when `from` is zero, `amount` tokens will  be minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens will  be burned. \n     * - `from` and `to` are  never both zero. \n     * \n     * To learn more  about hooks, head to xref:ROOT:extending-contracts.adoc#using-ho\n     */  \n    function _beforeTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual {} \n \n    /** \n     * @dev Hook that is called after any transfer of tokens. This includes \n     * minting and burning. \n     * \n     * Calling conditions: \n     * \n     * - when `from` and `to` are  both non-zero, `amount` of ``from``'s tokens \n     * has been transferred to `to`. \n     * - when `from` is zero, `amount` tokens have been minted for `to`. \n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned. \n     * - `from` and `to` are  never both zero. \n     * \n     * To learn more  about hooks, head to xref:ROOT:extending-contracts.adoc#using-ho\n     */  \n    function _afterTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual {} \n} \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n/** \n * @dev Extension of {ERC20} that allows token holders to destroy both their own \n * tokens and those that they  have an  allowance for, in \n * recognized off-chain (via event analysis). \n */  \nabstract contract ERC20Burnable is Context, ERC20 { \n    /** \n     * @dev Destroys `amount` tokens from the  caller. \n     * \n     * See {ERC20-_burn}. \n     */  \n    function burn(uint256 amount) public virtual { \n        _burn(_msgSender(), amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, deducting from the  caller's \n     * allowance. \n     * \n     * See {ERC20-_burn} and {ERC20-allowance}. \n     * \n     * Requirements: \n     * \n     * - the  caller must have allowance for ``accounts``'s tokens of at least \n     * `amount`. \n     */  \n    function burnFrom(address account, uint256 amount) public virtual { \n        uint256 currentAllowance = allowance(account, _msgSender()); \n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\"); \n        unchecked { \n            _approve(account, _msgSender(), currentAllowance - amount); \n        } \n        _burn(account, amount); \n    } \n} \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Extension of {ERC20} that adds a  cap to the  supp\n */  \nabstract contract ERC20Capped is ERC20 { \n    uint256 private immutable _cap; \n \n    /** \n     * @dev Sets the  value of the  `cap`. This value is immut\n     * set once during construction. \n     */  \n    constructor(uint256 cap_) { \n        require(cap_ > 0, \"ERC20Capped: cap is 0\"); \n        _cap = cap_; \n    } \n \n    /** \n     * @dev Returns the  cap on the  token's total supply. \n     */  \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_mint}. \n     */  \n    function _mint(address account, uint256 amount) internal virtual override { \n        require(ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\"); \n        super._mint(account, amount); \n    } \n} \n \n// File: @openzeppelin/contracts/utils/Address.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n * @dev Collection of functions related to the  address type \n */  \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        assembly { \n            size := extcodesize(account) \n        } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        (bool success, ) = recipient.call{value: amount}(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain `call` is an  unsafe replacement for a  function call:\n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n        return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall( \n        address target, \n        bytes memory data, \n        string memory errorMessage \n    ) internal returns (bytes memory) { \n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue( \n        address target, \n        bytes memory data, \n        uint256 value \n    ) internal returns (bytes memory) { \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue( \n        address target, \n        bytes memory data, \n        uint256 value, \n        string memory errorMessage \n    ) internal returns (bytes memory) { \n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        (bool success, bytes memory returndata) = target.call{value: value}(data); \n        return verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  static call. \n     * \n     * _Available since v3.3._ \n     */  \n    function functionStaticCall( \n        address target, \n        bytes memory data, \n        string memory errorMessage \n    ) internal view returns (bytes memory) { \n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) \n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but  performing a  delegate call. \n     * \n     * _Available since v3.4._ \n     */  \n    function functionDelegateCall( \n        address target, \n        bytes memory data, \n        string memory errorMessage \n    ) internal returns (bytes memory) { \n        require(isContract(target), \"Address: delegate call to non-contract\"); \n \n        (bool success, bytes memory returndata) = target.delegatecall(data); \n        return verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Tool to verifies that a  low level call was successful, and revert if it wasn't, eith\n     * revert reason using the  provided one. \n     * \n     * _Available since v4.3._ \n     */  \n    function verifyCallResult( \n        bool success, \n        bytes memory returndata, \n        string memory errorMessage \n    ) internal pure returns (bytes memory) { \n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the  ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP]. \n * \n * Implementers can declare support of contract interfaces, which can then be \n * queried by others ({ERC165Checker}). \n * \n * For an  implementation, see {ERC165}. \n */  \ninterface IERC165 { \n    /** \n     * @dev Returns true if this contract implements the  interface defined by \n     * `interfaceId`. See the  corresponding \n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces- are -identified[EIP section] \n     * to learn more  about how these ids are  created. \n     * \n     * This function call must use less than 30 000 gas. \n     */  \n    function supportsInterface(bytes4 interfaceId) external view returns (bool); \n} \n \n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Implementation of the  {IERC165} interface. \n * \n * Contracts that want to implement ERC165 should  inherit from this contract and overri\n * for the  additional interface id that will  be supported. For\n * \n * ``solidity \n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); \n * } \n * `` \n * \n * Alternatively, {ERC165Storage} provides an  easier to use but\n */  \nabstract contract ERC165 is IERC165 { \n    /** \n     * @dev See {IERC165-supportsInterface}. \n     */  \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n        return interfaceId == type(IERC165).interfaceId; \n    } \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/IERC1363.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n/** \n * @title IERC1363 Interface \n * @dev Interface for a  Payable Token contract as defined in \n *  https://eips.ethereum.org/EIPS/eip-1363 \n */  \ninterface IERC1363 is IERC20, IERC165 { \n    /** \n     * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver \n     * @param recipient address The address which you  want to transfer to \n     * @param amount uint256 The amount of tokens to be transferred \n     * @return true unless throwing \n     */  \n    function transferAndCall(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver \n     * @param recipient address The address which you  want to transfer to \n     * @param amount uint256 The amount of tokens to be transferred \n     * @param data bytes Additional data with no specified format, sent in call to `recipient` \n     * @return true unless throwing \n     */  \n    function transferAndCall( \n        address recipient, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bool); \n \n    /** \n     * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver \n     * @param sender address The address which you  want to send tokens from \n     * @param recipient address The address which you  want to transfer to \n     * @param amount uint256 The amount of tokens to be transferred \n     * @return true unless throwing \n     */  \n    function transferFromAndCall( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver \n     * @param sender address The address which you  want to send tokens from \n     * @param recipient address The address which you  want to transfer to \n     * @param amount uint256 The amount of tokens to be transferred \n     * @param data bytes Additional data with no specified format, sent in call to `recipient` \n     * @return true unless throwing \n     */  \n    function transferFromAndCall( \n        address sender, \n        address recipient, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bool); \n \n    /** \n     * @notice Approve the  passed address to spend the  sp\n     * and then call `onApprovalReceived` on spender. \n     * Beware that changing an  allowance with this method brings the\n     * and the  new allowance by unfortunate transaction ordering. One possible solution \n     * race condition is to first reduce the  spender's allowance to 0 and set \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * @param spender address The address which will  spend the\n     * @param amount uint256 The amount of tokens to be spent \n     */  \n    function approveAndCall(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @notice Approve the  passed address to spend the  sp\n     * and then call `onApprovalReceived` on spender. \n     * Beware that changing an  allowance with this method brings the\n     * and the  new allowance by unfortunate transaction ordering. One possible solution \n     * race condition is to first reduce the  spender's allowance to 0 and set \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * @param spender address The address which will  spend the\n     * @param amount uint256 The amount of tokens to be spent \n     * @param data bytes Additional data with no specified format, sent in call to `spender` \n     */  \n    function approveAndCall( \n        address spender, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bool); \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/IERC1363Receiver.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n * @title IERC1363Receiver Interface \n * @dev Interface for any contract that wants to support transferAndCall or transferFromAndCall \n *  from ERC1363 token contracts as defined in \n *  https://eips.ethereum.org/EIPS/eip-1363 \n */  \ninterface IERC1363Receiver { \n    /** \n     * @notice Handle the  receipt of ERC1363 tokens \n     * @dev Any ERC1363 smart contract calls this function on the  recipient \n     * after a  `transfer` or a  `transferFrom`. This function MAY\n     * transfer. Return of other than the  magic value MUST result in the\n     * transaction being reverted. \n     * Note: the  token contract address is always the  messa\n     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function \n     * @param sender address The address which are  token transferred from \n     * @param amount uint256 The amount of tokens transferred \n     * @param data bytes Additional data with no specified format \n     * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))` unless throwing \n     */  \n    function onTransferReceived( \n        address operator, \n        address sender, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bytes4); \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/IERC1363Spender.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n * @title IERC1363Spender Interface \n * @dev Interface for any contract that wants to support approveAndCall \n *  from ERC1363 token contracts as defined in \n *  https://eips.ethereum.org/EIPS/eip-1363 \n */  \ninterface IERC1363Spender { \n    /** \n     * @notice Handle the  approval of ERC1363 tokens \n     * @dev Any ERC1363 smart contract calls this function on the  recipient \n     * after an  `approve`. This function MAY throw to revert and reject the\n     * approval. Return of other than the  magic value MUST result in the\n     * transaction being reverted. \n     * Note: the  token contract address is always the  messa\n     * @param sender address The address which called `approveAndCall` function \n     * @param amount uint256 The amount of tokens to be spent \n     * @param data bytes Additional data with no specified format \n     * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))` unless throwing \n     */  \n    function onApprovalReceived( \n        address sender, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bytes4); \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/ERC1363.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n \n \n \n \n/** \n * @title ERC1363 \n * @dev Implementation of an  ERC1363 interface \n */  \nabstract contract ERC1363 is ERC20, IERC1363, ERC165 { \n    using Address for address; \n \n    /** \n     * @dev See {IERC165-supportsInterface}. \n     */  \n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) retu\n        return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId); \n    } \n \n    /** \n     * @dev Transfer tokens to a  specified address and then execute a\n     * @param recipient The address to transfer to. \n     * @param amount The amount to be transferred. \n     * @return A boolean that indicates if the  operation was successful. \n     */  \n    function transferAndCall(address recipient, uint256 amount) public virtual override returns (bool\n        return transferAndCall(recipient, amount, \"\"); \n    } \n \n    /** \n     * @dev Transfer tokens to a  specified address and then execute a\n     * @param recipient The address to transfer to \n     * @param amount The amount to be transferred \n     * @param data Additional data with no specified format \n     * @return A boolean that indicates if the  operation was successful. \n     */  \n    function transferAndCall( \n        address recipient, \n        uint256 amount, \n        bytes memory data \n    ) public virtual override returns (bool) { \n        transfer(recipient, amount); \n        require(_checkAndCallTransfer(_msgSender(), recipient, amount, data), \"ERC1363: _checkAndCall\n        return true; \n    } \n \n    /** \n     * @dev Transfer tokens from one address to another and then execute a  callback on\n     * @param sender The address which you  want to send tokens from \n     * @param recipient The address which you  want to transfer to \n     * @param amount The amount of tokens to be transferred \n     * @return A boolean that indicates if the  operation was successful. \n     */  \n    function transferFromAndCall( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) public virtual override returns (bool) { \n        return transferFromAndCall(sender, recipient, amount, \"\"); \n    } \n \n    /** \n     * @dev Transfer tokens from one address to another and then execute a  callback on\n     * @param sender The address which you  want to send tokens from \n     * @param recipient The address which you  want to transfer to \n     * @param amount The amount of tokens to be transferred \n     * @param data Additional data with no specified format \n     * @return A boolean that indicates if the  operation was successful. \n     */  \n    function transferFromAndCall( \n        address sender, \n        address recipient, \n        uint256 amount, \n        bytes memory data \n    ) public virtual override returns (bool) { \n        transferFrom(sender, recipient, amount); \n        require(_checkAndCallTransfer(sender, recipient, amount, data), \"ERC1363: _checkAndCallTransf\n        return true; \n    } \n \n    /** \n     * @dev Approve spender to transfer tokens and then execute a  callback on recipient\n     * @param spender The address allowed to transfer to \n     * @param amount The amount allowed to be transferred \n     * @return A boolean that indicates if the  operation was successful. \n     */  \n    function approveAndCall(address spender, uint256 amount) public virtual override returns (bool) {\n        return approveAndCall(spender, amount, \"\"); \n    } \n \n    /** \n     * @dev Approve spender to transfer tokens and then execute a  callback on recipient\n     * @param spender The address allowed to transfer to. \n     * @param amount The amount allowed to be transferred. \n     * @param data Additional data with no specified format. \n     * @return A boolean that indicates if the  operation was successful. \n     */  \n    function approveAndCall( \n        address spender, \n        uint256 amount, \n        bytes memory data \n    ) public virtual override returns (bool) { \n        approve(spender, amount); \n        require(_checkAndCallApprove(spender, amount, data), \"ERC1363: _checkAndCallApprove reverts\")\n        return true; \n    } \n \n    /** \n     * @dev Internal function to invoke `onTransferReceived` on a  target address \n     *  The call is not executed if the  target address is not a  c\n     * @param sender address Representing the  previous owner of the\n     * @param recipient address Target address that will  receive the\n     * @param amount uint256 The amount mount of tokens to be transferred \n     * @param data bytes Optional data to send along with the  call \n     * @return whether the  call correctly returned the  expect\n     */  \n    function _checkAndCallTransfer( \n        address sender, \n        address recipient, \n        uint256 amount, \n        bytes memory data \n    ) internal virtual returns (bool) { \n        if (!recipient.isContract()) { \n            return false; \n        } \n        bytes4 retval = IERC1363Receiver(recipient).onTransferReceived(_msgSender(), sender, amount, \n        return (retval == IERC1363Receiver(recipient).onTransferReceived.selector); \n    } \n \n    /** \n     * @dev Internal function to invoke `onApprovalReceived` on a  target address \n     *  The call is not executed if the  target address is not a  c\n     * @param spender address The address which will  spend the\n     * @param amount uint256 The amount of tokens to be spent \n     * @param data bytes Optional data to send along with the  call \n     * @return whether the  call correctly returned the  expect\n     */  \n    function _checkAndCallApprove( \n        address spender, \n        uint256 amount, \n        bytes memory data \n    ) internal virtual returns (bool) { \n        if (!spender.isContract()) { \n            return false; \n        } \n        bytes4 retval = IERC1363Spender(spender).onApprovalReceived(_msgSender(), amount, data); \n        return (retval == IERC1363Spender(spender).onApprovalReceived.selector); \n    } \n} \n \n// File: @openzeppelin/contracts/access/Ownable.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Contract module which provides a  basic access control mechanism, where \n * there is an  account ( an  owner) that can be granted exclus\n * specific functions. \n * \n * By default, the  owner account will  be the\n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will  make available the\n * `onlyOwner`, which can be applied to your  functions to restrict their use to \n * the  owner. \n */  \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the  contract setting the  deployer as \n     */  \n    constructor() { \n        _setOwner(_msgSender()); \n    } \n \n    /** \n     * @dev Returns the  address of the  current owner. \n     */  \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the  owner. \n     */  \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the  contract without owner. It will  not b\n     * `onlyOwner` functions anymore. Can only be called by the  current owner. \n     * \n     * NOTE:  Renouncing ownership will  leave \n     * thereby removing any functionality that is only available to the  owner. \n     */  \n    function renounceOwnership() public virtual onlyOwner { \n        _setOwner(address(0)); \n    } \n \n    /** \n     * @dev Transfers ownership of the  contract to a  new ac\n     * Can only be called by the  current owner. \n     */  \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        _setOwner(newOwner); \n    } \n \n    function _setOwner(address newOwner) private { \n        address oldOwner = _owner; \n        _owner = newOwner; \n        emit OwnershipTransferred(oldOwner, newOwner); \n    } \n} \n \n// File: eth-token-recover/contracts/TokenRecover.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n/** \n * @title TokenRecover \n * @dev Allows owner to recover any ERC20 sent into the  contract \n */  \ncontract TokenRecover is Ownable { \n    /** \n     * @dev Remember that only owner can call so  be careful when use on contracts gen\n     * @param tokenAddress The token contract address \n     * @param tokenAmount Number of tokens to be sent \n     */  \n    function recoverERC20(address tokenAddress, uint256 tokenAmount) public virtual onlyOwner { \n        IERC20(tokenAddress).transfer(owner(), tokenAmount); \n    } \n} \n \n// File: contracts/token/ERC20/behaviours/ERC20Decimals.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n/** \n * @title ERC20Decimals \n * @dev Implementation of the  ERC20Decimals. Extension of {ERC20} that adds decim\n */  \nabstract contract ERC20Decimals is ERC20 { \n    uint8 private immutable _decimals; \n \n    /** \n     * @dev Sets the  value of the  `decimals`. This value is i\n     * set once during construction. \n     */  \n    constructor(uint8 decimals_) { \n        _decimals = decimals_; \n    } \n \n    function decimals() public view virtual override returns (uint8) { \n        return _decimals; \n    } \n} \n \n// File: contracts/token/ERC20/behaviours/ERC20Mintable.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n/** \n * @title ERC20Mintable \n * @dev Implementation of the  ERC20Mintable. Extension of {ERC20} that adds \n */  \nabstract contract ERC20Mintable is ERC20 { \n    // indicates if minting is finished \n    bool private _mintingFinished = false; \n \n    /** \n     * @dev Emitted during finish minting \n     */  \n    event MintFinished(); \n \n    /** \n     * @dev Tokens can be minted only before minting finished. \n     */  \n    modifier canMint() { \n        require(!_mintingFinished, \"ERC20Mintable: minting is finished\"); \n        _; \n    } \n \n    /** \n     * @return if minting is finished or not. \n     */  \n    function mintingFinished() external view returns (bool) { \n        return _mintingFinished; \n    } \n \n    /** \n     * @dev Function to mint tokens. \n     * \n     * WARNING: it allows everyone to mint new tokens. Access controls MUST be defined in derived contracts. \n     * \n     * @param account The address that will  receive the  m\n     * @param amount The amount of tokens to mint \n     */  \n    function mint(address account, uint256 amount) external canMint { \n        _mint(account, amount); \n    } \n \n    /** \n     * @dev Function to stop minting new tokens. \n     * \n     * WARNING: it allows everyone to finish minting. Access controls MUST be defined in derived contracts. \n     */  \n    function finishMinting() external canMint { \n        _finishMinting(); \n    } \n \n    /** \n     * @dev Function to stop minting new tokens. \n     */  \n    function _finishMinting() internal virtual { \n        _mintingFinished = true; \n \n        emit MintFinished(); \n    } \n} \n \n// File: @openzeppelin/contracts/access/IAccessControl.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n * @dev External interface of AccessControl declared to support ERC165 detection. \n */  \ninterface IAccessControl { \n    /** \n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` \n     * \n     * `DEFAULT_ADMIN_ROLE` is the  starting admin for all roles, despite \n     * {RoleAdminChanged} not being emitted signaling this. \n     * \n     * _Available since v3.1._ \n     */  \n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed n\n \n    /** \n     * @dev Emitted when `account` is granted `role`. \n     * \n     * `sender` is the  account that originated the  contract cal\n     * bearer except when using {AccessControl-_setupRole}. \n     */  \n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender); \n \n    /** \n     * @dev Emitted when `account` is revoked `role`. \n     * \n     * `sender` is the  account that originated the  contract cal\n     *   - if using `revokeRole`, it is the  admin role bearer \n     *   - if using `renounceRole`, it is the  role bearer (i.e. `account`) \n     */  \n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender); \n \n    /** \n     * @dev Returns `true` if `account` has been granted `role`. \n     */  \n    function hasRole(bytes32 role, address account) external view returns (bool); \n \n    /** \n     * @dev Returns the  admin role that controls `role`. See {grantRole} and \n     * {revokeRole}. \n     * \n     * To change a  role's admin, use {AccessControl-_setRoleAdmin}. \n     */  \n    function getRoleAdmin(bytes32 role) external view returns (bytes32); \n \n    /** \n     * @dev Grants `role` to `account`. \n     * \n     * If `account` had not been already granted `role`, emits a  {RoleGranted} \n     * event. \n     * \n     * Requirements: \n     * \n     * - the  caller must have ``role``'s admin role. \n     */  \n    function grantRole(bytes32 role, address account) external; \n \n    /** \n     * @dev Revokes `role` from `account`. \n     * \n     * If `account` had been granted `role`, emits a  {RoleRevoked} event. \n     * \n     * Requirements: \n     * \n     * - the  caller must have ``role``'s admin role. \n     */  \n    function revokeRole(bytes32 role, address account) external; \n \n    /** \n     * @dev Revokes `role` from the  calling account. \n     * \n     * Roles are  often managed via {grantRole} and {revokeRole}: this function's \n     * purpose is to provide a  mechanism for accounts to lose their privileges \n     * if they  are  compromised ( such\n     * \n     * If the  calling account had been granted `role`, emits a  \n     * event. \n     * \n     * Requirements: \n     * \n     * - the  caller must be `account`. \n     */  \n    function renounceRole(bytes32 role, address account) external; \n} \n \n// File: @openzeppelin/contracts/utils/Strings.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n/** \n * @dev String operations. \n */  \nlibrary Strings { \n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\"; \n \n    /** \n     * @dev Converts a  `uint256` to its ASCII `string` decimal representation. \n     */  \n    function toString(uint256 value) internal pure returns (string memory) { \n        // Inspired by OraclizeAPI's implementation - MIT licence \n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/ora\n \n        if (value == 0) { \n            return \"0\"; \n        } \n        uint256 temp = value; \n        uint256 digits; \n        while (temp != 0) { \n            digits++; \n            temp /= 10; \n        } \n        bytes memory buffer = new bytes(digits); \n        while (value != 0) { \n            digits -= 1; \n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); \n            value /= 10; \n        } \n        return string(buffer); \n    } \n \n    /** \n     * @dev Converts a  `uint256` to its ASCII `string` hexadecimal representation. \n     */  \n    function toHexString(uint256 value) internal pure returns (string memory) { \n        if (value == 0) { \n            return \"0x00\"; \n        } \n        uint256 temp = value; \n        uint256 length = 0; \n        while (temp != 0) { \n            length++; \n            temp >>= 8; \n        } \n        return toHexString(value, length); \n    } \n \n    /** \n     * @dev Converts a  `uint256` to its ASCII `string` hexadecimal representation with fix\n     */  \n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) { \n        bytes memory buffer = new bytes(2 * length + 2); \n        buffer[0] = \"0\"; \n        buffer[1] = \"x\"; \n        for (uint256 i = 2 * length + 1; i > 1; --i) { \n            buffer[i] = _HEX_SYMBOLS[value & 0xf]; \n            value >>= 4; \n        } \n        require(value == 0, \"Strings: hex length insufficient\"); \n        return string(buffer); \n    } \n} \n \n// File: @openzeppelin/contracts/access/AccessControl.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n \n \n/** \n * @dev Contract module that allows children to implement role-based access \n * control mechanisms. This is a  lightweight version that doesn't\n * members except through off-chain means by accessing the  contract event logs. Som\n * applications may benefit from on-chain enumerability, for those cases see \n * {AccessControlEnumerable}. \n * \n * Roles are  referred to by their `bytes32` identifier. These should\n * in the  external API and be unique. The best way to achieve this is by \n * using `public constant` hash digests: \n * \n * `` \n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\"); \n * `` \n * \n * Roles can be used to represent a  set of permissions. To restrict access to \n * function call, use {hasRole}: \n * \n * `` \n * function foo() public { \n *     require(hasRole(MY_ROLE, msg.sender)); \n *     ... \n * } \n * `` \n * \n * Roles can be granted and revoked dynamically via the  {grantRole} and \n * {revokeRole} functions. Each role has an  associated admin role, and only \n * accounts that have a  role's admin role can call {grantRole} and {revokeRole}. \n * \n * By default, the  admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means \n * that only accounts with this role will  be able to grant or revoke other \n * roles. More complex role relationships can be created by using \n * {_setRoleAdmin}. \n * \n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to \n * grant and revoke this role. Extra precautions should  be taken to secure \n * accounts that have been granted it. \n */  \nabstract contract AccessControl is Context, IAccessControl, ERC165 { \n    struct RoleData { \n        mapping(address => bool) members; \n        bytes32 adminRole; \n    } \n \n    mapping(bytes32 => RoleData) private _roles; \n \n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00; \n \n    /** \n     * @dev Modifier that checks that an  account has a  speci\n     * with a  standardized message including the  required ro\n     * \n     * The format of the  revert reason is given by the  followin\n     * \n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/ \n     * \n     * _Available since v4.1._ \n     */  \n    modifier onlyRole(bytes32 role) { \n        _checkRole(role, _msgSender()); \n        _; \n    } \n \n    /** \n     * @dev See {IERC165-supportsInterface}. \n     */  \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId\n    } \n \n    /** \n     * @dev Returns `true` if `account` has been granted `role`. \n     */  \n    function hasRole(bytes32 role, address account) public view override returns (bool) { \n        return _roles[role].members[account]; \n    } \n \n    /** \n     * @dev Revert with a  standard message if `account` is missing `role`. \n     * \n     * The format of the  revert reason is given by the  followin\n     * \n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/ \n     */  \n    function _checkRole(bytes32 role, address account) internal view { \n        if (!hasRole(role, account)) { \n            revert( \n                string( \n                    abi.encodePacked( \n                        \"AccessControl: account \", \n                        Strings.toHexString(uint160(account), 20), \n                        \" is missing role \", \n                        Strings.toHexString(uint256(role), 32) \n                    ) \n                ) \n            ); \n        } \n    } \n \n    /** \n     * @dev Returns the  admin role that controls `role`. See {grantRole} and \n     * {revokeRole}. \n     * \n     * To change a  role's admin, use {_setRoleAdmin}. \n     */  \n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) { \n        return _roles[role].adminRole; \n    } \n \n    /** \n     * @dev Grants `role` to `account`. \n     * \n     * If `account` had not been already granted `role`, emits a  {RoleGranted} \n     * event. \n     * \n     * Requirements: \n     * \n     * - the  caller must have ``role``'s admin role. \n     */  \n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(r\n        _grantRole(role, account); \n    } \n \n    /** \n     * @dev Revokes `role` from `account`. \n     * \n     * If `account` had been granted `role`, emits a  {RoleRevoked} event. \n     * \n     * Requirements: \n     * \n     * - the  caller must have ``role``'s admin role. \n     */  \n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(\n        _revokeRole(role, account); \n    } \n \n    /** \n     * @dev Revokes `role` from the  calling account. \n     * \n     * Roles are  often managed via {grantRole} and {revokeRole}: this function's \n     * purpose is to provide a  mechanism for accounts to lose their privileges \n     * if they  are  compromised ( such\n     * \n     * If the  calling account had been granted `role`, emits a  \n     * event. \n     * \n     * Requirements: \n     * \n     * - the  caller must be `account`. \n     */  \n    function renounceRole(bytes32 role, address account) public virtual override { \n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\"); \n \n        _revokeRole(role, account); \n    } \n \n    /** \n     * @dev Grants `role` to `account`. \n     * \n     * If `account` had not been already granted `role`, emits a  {RoleGranted} \n     * event. Note that unlike {grantRole}, this function doesn't  perform any \n     * checks on the  calling account. \n     * \n     * [WARNING] \n     * ==== \n     * This function should  only be called from the  constructo\n     * up the  initial roles for the  system. \n     * \n     * Using this function in any other way is effectively circumventing the  admin \n     * system imposed by {AccessControl}. \n     * ==== \n     */  \n    function _setupRole(bytes32 role, address account) internal virtual { \n        _grantRole(role, account); \n    } \n \n    /** \n     * @dev Sets `adminRole` as ``role``'s admin role. \n     * \n     * Emits a  {RoleAdminChanged} event. \n     */  \n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual { \n        bytes32 previousAdminRole = getRoleAdmin(role); \n        _roles[role].adminRole = adminRole; \n        emit RoleAdminChanged(role, previousAdminRole, adminRole); \n    } \n \n    function _grantRole(bytes32 role, address account) private { \n        if (!hasRole(role, account)) { \n            _roles[role].members[account] = true; \n            emit RoleGranted(role, account, _msgSender()); \n        } \n    } \n \n    function _revokeRole(bytes32 role, address account) private { \n        if (hasRole(role, account)) { \n            _roles[role].members[account] = false; \n            emit RoleRevoked(role, account, _msgSender()); \n        } \n    } \n} \n \n// File: contracts/access/Roles.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \ncontract Roles is AccessControl { \n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\"); \n \n    constructor() { \n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); \n        _setupRole(MINTER_ROLE, _msgSender()); \n    } \n \n    modifier onlyMinter() { \n        require(hasRole(MINTER_ROLE, _msgSender()), \"Roles: caller does not have the MINTER role\"); \n        _; \n    } \n} \n \n// File: contracts/service/ServicePayer.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \ninterface IPayable { \n    function pay(string memory serviceName) external payable; \n} \n \n/** \n * @title ServicePayer \n * @dev Implementation of the  ServicePayer \n */  \nabstract contract ServicePayer { \n    constructor(address payable receiver, string memory serviceName) payable { \n        IPayable(receiver).pay{value: msg.value}(serviceName); \n    } \n} \n \n// File: contracts/token/ERC20/PowerfulERC20.sol \n \n \n \n",
            "pragma solidity ^0.8.0; \n \n \n \n \n \n \n \n \n \n/** \n * @title PowerfulERC20 \n * @dev Implementation of the  PowerfulERC20 \n */  \ncontract PowerfulERC20 is \n    ERC20Decimals, \n    ERC20Capped, \n    ERC20Mintable, \n    ERC20Burnable, \n    ERC1363, \n    TokenRecover, \n    Roles, \n    ServicePayer \n{ \n"
        ]
    },
    {
        "PdfName": "VOID Token (VOID)_audit.pdf",
        "Code": []
    },
    {
        "PdfName": "Voyager Pass_audit.pdf",
        "Code": [
            "pragma solidity 0.8.4; \n \nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\"; \nimport \"@openzeppelin/contracts/utils/Address.sol\"; \nimport \"@openzeppelin/contracts/utils/Context.sol\"; \n \nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\"; \nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\"; \nimport \"@openzeppelin/contracts/utils/Strings.sol\"; \nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\"; \nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; \n \n \nlibrary MintUtil { \n    using SafeMath for uint256; \n    using ECDSA for bytes32; \n    using Strings for uint256; \n \n    function getDiscountedPrice(uint _startTime, uint256 _startPrice, uint256 _discountRate, uint256 _\n    uint256 _duration) public view returns (uint256) { \n        uint256 timeElapsed = block.timestamp.sub(_startTime); \n        if(timeElapsed >= _duration){ \n            return _endPrice; \n        } \n        uint256 discount = timeElapsed.mul(_discountRate); \n        uint256 discountedPrice = _startPrice.sub(discount); \n        return discountedPrice.div(100000000000000).mul(100000000000000); \n    } \n \n    function inWhitelist(bytes32 _leaf, bytes32 _merkelRoot, bytes32[] calldata _merkleProof) public \n        return MerkleProof.verify(_merkleProof, _merkelRoot, _leaf); \n    } \n \n    function canMint(uint _whitelistIndex, bool _voyagerCaptainMintActive,  \n    bool _legacyMintActive, bool _privateMintActive, bool _publicSaleActive,  \n    bool _addressMinted) public pure returns (bool, string memory) { \n \n        if (!((_whitelistIndex == 0 && _voyagerCaptainMintActive) || \n        (_whitelistIndex == 1 && _legacyMintActive) || \n        (_whitelistIndex == 2 && _privateMintActive) ||  \n        (_whitelistIndex == 100 && _publicSaleActive))){ \n            return (false, \"Your address is not yet qualified to mint, please read the FAQ and check \n        } \n \n        if (_addressMinted) { \n            return (false, \"You can only mint one per wallet\"); \n        } \n \n        return (true, \"\"); \n    } \n \n    function canMint2(uint _whitelistIndex, uint256 _voyagerCaptainMintedAmount, uint256 _voyagerCapt\n    uint256 _privateMintLimit, uint256 _publicSaleMintedAmount, uint256 _publicSaleMintLimit) public \n        if(_whitelistIndex == 0 && _voyagerCaptainMintedAmount.add(1) > _voyagerCaptainMintLimit){ \n            return(false,  \"Can't mint more than voyager captain limit\"); \n        } else if(_whitelistIndex == 1 && _legacyMintedAmount.add(1) > _legacyMintLimit){ \n            return(false,   \"Can't mint more than legacy mint limit\"); \n        } else if(_whitelistIndex == 2 && _privateMintedAmount.add(1) > _privateMintLimit){ \n            return(false, \"Can't mint more than private mint limit\"); \n        } else if(_whitelistIndex == 100 && _publicSaleMintedAmount.add(1) > _publicSaleMintLimit){ \n            return(false, \"Can't mint more than public sale limit\"); \n        } \n        return (true, \"\"); \n \n    } \n \n    function getTokenURI(uint256 _tokenId, bool _reveal, string memory _blindURI, string memory _base\n        if (!_reveal) { \n            return string(abi.encodePacked(_blindURI, _tokenId.toString())); \n        } else { \n            return string(abi.encodePacked(_baseURI, _tokenId.toString())); \n        } \n    } \n} \n \n \ncontract VoyagerPass is ERC721(\"Voyager Pass\", \"VOP\"), ERC721Enumerable, Ownable, ReentrancyGuard { \n    using SafeMath for uint256; \n \n    string private baseURI; \n    string private blindURI; \n    uint256 private constant TOTAL_NFT = 10000; \n    // initial price for the auction \n    uint256 public mintPrice = 1 ether; \n    uint256 public endingPrice = 0.15 ether; \n    uint256 public privatePrice = 0.1 ether; \n    uint256 public auctionDuration = 5400 seconds; \n    // 1.5 hours = 5400 seconds, so price decrease (1 - 0.1) * 10**18 / 5400 = 166_666_666_666_666 we\n    uint256 public discountRate = 166_666_666_666_666 wei; \n \n    bool public reveal; \n \n    bool public voyagerCaptainMintActive; \n    bool public legacyMintActive; \n    bool public privateMintActive; \n    bool public publicSaleActive; \n    bool public dutchAuctionActive; \n \n    // save all three roots \n    bytes32[3] public whitelistInfo; \n \n    mapping (address => bool) public addressMinted; \n    mapping (uint256 => bool) public isPaid; \n \n    uint256 public voyagerCaptainMintLimit = 500; \n    uint256 public legacyMintLimit = 1200; \n    uint256 public privateMintLimit = 8300; \n    uint256 public publicSaleMintLimit = 0; \n    uint256 public voyagerCaptainMintedAmount; \n    uint256 public legacyMintedAmount; \n    uint256 public privateMintedAmount; \n    uint256 public publicSaleMintedAmount; \n    uint256 public dutchAuctionStartAt; \n \n    function revealNow() external onlyOwner { \n        reveal = true; \n    } \n \n    function setMintActive(bool _isActive, uint mintTypeIndex) external onlyOwner { \n        if (mintTypeIndex == 0) \n            voyagerCaptainMintActive = _isActive; \n        else if (mintTypeIndex == 1) \n            legacyMintActive = _isActive; \n        else if (mintTypeIndex == 2) \n            privateMintActive = _isActive; \n        else if( mintTypeIndex == 3) \n            publicSaleActive = _isActive; \n    } \n \n    function setDutchAuctionActive(bool _dutchAuctionActive) external onlyOwner { \n        dutchAuctionActive = _dutchAuctionActive; \n        dutchAuctionStartAt = block.timestamp; \n    } \n \n    function setPrivatePrice(uint256 _privatePrice) external onlyOwner { \n        privatePrice = _privatePrice; \n    } \n \n    function setDutchAuctionInfo(uint256 _startPrice, uint256 _endPrice, uint256 _duration) external \n        mintPrice = _startPrice; \n        endingPrice = _endPrice; \n        auctionDuration = _duration; \n        discountRate = (mintPrice.sub(endingPrice)).div(auctionDuration); \n    } \n \n    function setMintLimit(uint256 _voyagerCaptainMintLimit, uint256 _legacyMintLimit, uint256 _privat\n        voyagerCaptainMintLimit = _voyagerCaptainMintLimit; \n        legacyMintLimit = _legacyMintLimit; \n        privateMintLimit = _privateMintLimit; \n        publicSaleMintLimit = TOTAL_NFT.sub(voyagerCaptainMintLimit.add(legacyMintLimit).add(privateM\n    } \n \n    function setURIs(string memory _blindURI, string memory _URI) external onlyOwner { \n        blindURI = _blindURI; \n        baseURI = _URI; \n    } \n \n    function setRoot(bytes32 _root, uint _whitelistIndex) external onlyOwner { \n        whitelistInfo[_whitelistIndex] = _root; \n    } \n \n    function airdrop(address _target, uint _whitelistIndex) external onlyOwner { \n \n        require(totalSupply().add(1) <= TOTAL_NFT, \"Can't mint more than 10000 NFTs\"); \n \n        addressMinted[_target] = true; \n \n        uint256 tokenId = totalSupply() + 1; \n        updateMintMaps(tokenId, _whitelistIndex); \n        _safeMint(_target,tokenId); \n    } \n \n    function canMint(uint _whitelistIndex, address _address) public view returns (bool, string memory\n        // check if user is authorized to mint / mint is active / user has already minted \n        require(totalSupply().add(1) <= TOTAL_NFT, \"Can't mint more than 10000 NFTs\"); \n        return MintUtil.canMint(_whitelistIndex, voyagerCaptainMintActive, legacyMintActive, privateM\n        addressMinted[_address]); \n    } \n \n    function canMint2(uint _whitelistIndex) public view returns (bool, string memory) { \n        // check if minted amount is greater than limit \n        return MintUtil.canMint2(_whitelistIndex, voyagerCaptainMintedAmount, voyagerCaptainMintLimit\n         legacyMintLimit, privateMintedAmount, privateMintLimit,publicSaleMintedAmount, publicSaleMin\n    } \n \n \n    function getMintPriceByUser(uint _whitelistIndex) public view returns (uint256) { \n        if(_whitelistIndex <= 1){ \n            return 0; \n        }else if(_whitelistIndex == 2){ \n            return privatePrice; \n        }else if(dutchAuctionActive){ \n            return MintUtil.getDiscountedPrice(dutchAuctionStartAt, mintPrice, discountRate, endingPr\n        }else{ \n            return endingPrice; \n        } \n    } \n \n    function withdraw() public onlyOwner { \n        payable(0xfA61b6E35613f014Bd4387898790E89572f63B57).transfer(address(this).balance); \n    } \n \n    function updateMintMaps(uint256 _tokenId, uint _whitelistIndex) private { \n        // update minted amount for different tiers and the isPaid map \n        if(_whitelistIndex == 0){ \n            voyagerCaptainMintedAmount = voyagerCaptainMintedAmount.add(1); \n            isPaid[_tokenId] = false; \n        }else if(_whitelistIndex == 1){ \n            legacyMintedAmount = legacyMintedAmount.add(1); \n            isPaid[_tokenId] = false; \n        }else if(_whitelistIndex == 2){ \n            privateMintedAmount = privateMintedAmount.add(1); \n            isPaid[_tokenId] = true; \n        }else{ \n            publicSaleMintedAmount = publicSaleMintedAmount.add(1); \n            isPaid[_tokenId] = true; \n        } \n    } \n \n    function getWhitelistIndex(bytes32[] calldata _merkleProof, bytes32 leaf) internal view returns(u\n        uint whitelistIndex = 100; \n        if(MerkleProof.verify(_merkleProof, whitelistInfo[0], leaf)){ \n            whitelistIndex = 0; \n        } else if(MerkleProof.verify(_merkleProof, whitelistInfo[1], leaf)){ \n            whitelistIndex = 1; \n        } else if(MerkleProof.verify(_merkleProof, whitelistInfo[2], leaf)){ \n            whitelistIndex = 2; \n        } \n        return whitelistIndex; \n    } \n \n    function mintNFT(bytes32[] calldata _merkleProof) payable external nonReentrant{ \n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender)); \n        uint whitelistIndex = getWhitelistIndex(_merkleProof, leaf); \n        // apply 2 checks to make sure the mint request is valid \n"
        ]
    },
    {
        "PdfName": "WCDM_MANAGER_audit.pdf",
        "Code": [
            "pragma solidity ^0.6.0; \npragma experimental ABIEncoderV2; \n \ninterface IERC20 { \n    function totalSupply() external view returns (uint); \n    function mint(address account, uint amount) external; \n    function balanceOf(address account) external view returns (uint); \n    function transfer(address recipient, uint amount) external returns (bool); \n    function allowance(address owner, address spender) external view returns (uint); \n    function approve(address spender, uint amount) external returns (bool); \n    function transferFrom(address sender, address recipient, uint amount) external returns (bool); \n    event Transfer(address indexed from, address indexed to, uint value); \n    event Approval(address indexed owner, address indexed spender, uint value); \n} \n \ncontract Context { \n    constructor () internal { } \n    // solhint-disable-previous-line no-empty-blocks \n \n    function _msgSender() internal view returns (address payable) { \n        return msg.sender; \n    } \n} \n \nabstract contract  ERC20 is Context, IERC20 { \n    using SafeMath for uint; \n \n    mapping (address => uint) private _balances; \n \n    mapping (address => mapping (address => uint)) private _allowances; \n \n    uint private _totalSupply; \n    function totalSupply() public override view returns (uint) { \n        return _totalSupply; \n    } \n    function balanceOf(address account) public override view returns (uint) { \n        return _balances[account]; \n    } \n    function transfer(address recipient, uint amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n    function allowance(address owner, address spender) public  override view returns (uint) { \n        return _allowances[owner][spender]; \n    } \n    function approve(address spender, uint amount) public  override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n    function transferFrom(address sender, address recipient, uint amount) public override returns (bo\n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n    function increaseAllowance(address spender, uint addedValue) public returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n    function _transfer(address sender, address recipient, uint amount) internal { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n    function _mint(address account, uint amount) internal { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n    function _burn(address account, uint amount) internal { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n    function _approve(address owner, address spender, uint amount) internal { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n} \n \nlibrary SafeMath { \n    function add(uint a, uint b) internal pure returns (uint) { \n        uint c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n    function sub(uint a, uint b) internal pure returns (uint) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) { \n        require(b <= a, errorMessage); \n        uint c = a - b; \n \n        return c; \n    } \n    function mul(uint a, uint b) internal pure returns (uint) { \n        if (a == 0) { \n            return 0; \n        } \n \n        uint c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n    function div(uint a, uint b) internal pure returns (uint) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0, errorMessage); \n        uint c = a / b; \n \n        return c; \n    } \n} \n \nlibrary Address { \n    function isContract(address account) internal view returns (bool) { \n        bytes32 codehash; \n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { codehash := extcodehash(account) } \n        return (codehash != 0x0 && codehash != accountHash); \n    } \n} \n \nlibrary SafeERC20 { \n    using SafeMath for uint; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint value) internal { \n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal { \n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value\n    } \n \n    function safeApprove(IERC20 token, address spender, uint value) internal { \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n    function callOptionalReturn(IERC20 token, bytes memory data) private { \n        require(address(token).isContract(), \"SafeERC20: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = address(token).call(data); \n        require(success, \"SafeERC20: low-level call failed\"); \n \n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n// File: @openzeppelin/contracts/ownership/Ownable.sol \ncontract  WCDM_MANAGER { \n    using SafeMath for uint256; \n    using SafeERC20 for IERC20; \n    using Address for address; \n    uint public etherUnit = 10**18; \n    bool isAudit = false; \n \n    mapping(uint256 => address) public tokenArray; \n    struct UserInfo { \n        uint depositTime; \n        address invitor ; \n        uint referedRewards; \n        uint withdrawRewards;  \n    } \n \n    uint256 public constant DURATION = 1 days;   \n    uint public blockStart=0; \n    uint public periodFinish =0 ; \n    mapping(uint=> uint)  public lastUpdateTime; \n    mapping(uint=> uint)  public rewardPerTokenStored; \n    mapping(uint=> uint)  public totalStaked; \n    mapping(uint=> uint)  public rewardRate ; \n \n    mapping(address => mapping(uint => uint)) public userRewardPerTokenPaid; \n    mapping(address =>  mapping(uint => uint)) public rewards; \n    mapping(address => mapping(uint => uint)) public userStaked;  \n \n    mapping(uint=> uint)  public relaseOfEachPool; \n    uint public releaseTotal;   \n    mapping(address=> UserInfo)  public userInfo; \n \n    mapping(address => bool) public isOwner; \n \n    modifier onlyOwner() { \n        require(isOwner[msg.sender],\"not owner\"); \n        _; \n    } \n \n    event WithdrawWCMDInPool(address indexed _sender,uint _amount); \n    event Staked(address indexed user, uint256 amount); \n    event Withdraw(address indexed user, uint256 amount); \n    event ExitLp(address indexed user, uint256 amount); \n \n     address public uniswapRouter=0xED7d5F38C79115ca12fe6C0041abb22F0A06C300; \n     address public usdtHeco =0x0298c2b32eaE4da002a15f36fdf7615BEa3DA047; \n \n     address payable public coldWallet =0x22e64421110b531e3D94e3784a33912B064F0cd6; \n     fallback() external payable { } \n \n     constructor() public  payable{ \n        tokenArray[uint256(1)]=0xc7AA0CC3D048785155275fC5793916c28A25d927;  // yes // 12 \u4e07,40 \u5929\u4ea7\u5b8c\uff0c\n        rewardRate[uint256(1)] = 34722222222222224;// \n        totalStaked[uint256(1)]=0; \n        lastUpdateTime[uint256(1)]=block.timestamp; \n \n \n        tokenArray[uint256(2)]=0x5545153CCFcA01fbd7Dd11C0b23ba694D9509A6F; // yes \n        rewardRate[uint256(2)] = 8680555555555556;// 3 \u4e07,40 \u5929\u4ea7\u5b8c\uff0c\u6bcf\u5929 750\uff0c\u6bcf\u79d2  8680555555555556 \n        totalStaked[uint256(2)]=0; \n        lastUpdateTime[uint256(2)]=block.timestamp; \n \n \n        tokenArray[uint256(3)]=0x66a79D23E58475D2738179Ca52cd0b41d73f0BEa;  \n        rewardRate[uint256(3)] = 8680555555555556;//  \n        totalStaked[uint256(3)]=0; \n        lastUpdateTime[uint256(3)]=block.timestamp; \n \n \n        tokenArray[uint256(4)]=0x0298c2b32eaE4da002a15f36fdf7615BEa3DA047;   \n        rewardRate[uint256(4)] = 8680555555555556;//  \n        totalStaked[uint256(4)]=0; \n        lastUpdateTime[uint256(4)]=block.timestamp; \n \n \n        tokenArray[uint256(5)]=0x25D2e80cB6B86881Fd7e07dd263Fb79f4AbE033c; \n        rewardRate[uint256(5)] = 8680555555555556;//  \n        totalStaked[uint256(5)]=0; \n        lastUpdateTime[uint256(5)]=block.timestamp; \n \n \n        tokenArray[uint256(6)]=0x6868D406a125Eb30886A6DD6B651D81677d1F22c;  \n        rewardRate[uint256(6)] = 8680555555555556;//  \n        totalStaked[uint256(6)]=0; \n        lastUpdateTime[uint256(6)]=block.timestamp; \n \n \n        tokenArray[uint256(7)]=0x98fc3b60Ed4A504F588342A53746405E355F9347; \n        rewardRate[uint256(7)] = 8680555555555556;//  \n        totalStaked[uint256(7)]=0; \n        lastUpdateTime[uint256(7)]=block.timestamp; \n \n        tokenArray[uint256(8)]=0x914EDf56778f3b46201EC9FF2c38E632e04c0Bc4;  \n        rewardRate[uint256(8)] =57870370370370370;//  \n        totalStaked[uint256(8)]=0; \n        lastUpdateTime[uint256(8)]=block.timestamp; \n \n \n        tokenArray[uint256(9)]=0xCBc924e38fD0F3c81f058Ca013b9523fae98db2E; \n        rewardRate[uint256(9)] = 48225308641975310;//  \n        totalStaked[uint256(9)]=0; \n        lastUpdateTime[uint256(9)]=block.timestamp; \n \n \n        tokenArray[uint256(10)]=0x30EABe1ac682514b3882675402b7096C2C5C13e4; \n        rewardRate[uint256(10)] = 28935185185185184; \n        totalStaked[uint256(10)]=0; \n        lastUpdateTime[uint256(10)]=block.timestamp; \n        blockStart = block.timestamp;  \n        periodFinish = blockStart.add(86400); \n        isOwner[msg.sender] = true; \n    } \n \n    modifier  checkValve(uint _kindOfPool) { \n        if (block.timestamp> periodFinish) { \n            periodFinish = block.timestamp.add(DURATION); \n        } \n        _; \n    } \n \n    modifier reachLimit(uint _kindOfPool){ \n         if (_kindOfPool==uint(1)){ \n            if (relaseOfEachPool[_kindOfPool] > 120000*(10**18)){ \n                return; \n            } \n        } \n \n        if (_kindOfPool==uint(8)){ \n            if (relaseOfEachPool[_kindOfPool] > 300000*(10**18)){ \n                return; \n            } \n        } \n \n        if (_kindOfPool==uint(9)){ \n            if (relaseOfEachPool[_kindOfPool] > 250000*(10**18)){ \n                return; \n            } \n        } \n \n \n         if (_kindOfPool==uint(10)){ \n            if (relaseOfEachPool[_kindOfPool] > 150000*(10**18)){ \n                return; \n            } \n        } \n \n        if (_kindOfPool >1 && _kindOfPool < 8){ \n             if (relaseOfEachPool[_kindOfPool] > 30000*(10**18)){ \n                return; \n            } \n        } \n        _; \n    } \n    function rewardPerToken(uint _kindOfToken) public view returns (uint256) { \n        if (totalStaked[_kindOfToken] == 0){ \n            return rewardPerTokenStored[_kindOfToken]; \n        } \n        return \n            rewardPerTokenStored[_kindOfToken] \n                    .add(lastTimeRewardApplicable() \n                    .sub(lastUpdateTime[_kindOfToken]) \n                    .mul(rewardRate[_kindOfToken]) \n                    .mul(1e18) \n                    .div(totalStaked[_kindOfToken]) \n            ); \n    } \n \n    modifier updateReward(address _user,uint _kindOfPool) { \n        rewardPerTokenStored[_kindOfPool] = rewardPerToken(_kindOfPool); \n        lastUpdateTime[_kindOfPool] = lastTimeRewardApplicable(); \n \n        if (_user != address(0)){ \n            rewards[_user][_kindOfPool]=calcwcmdStaticReward(_user,_kindOfPool); \n            userRewardPerTokenPaid[_user][_kindOfPool]=rewardPerToken(_kindOfPool); \n        } \n        _; \n    } \n \n    function calcwcmdStaticReward(address _user,uint _kindofPool) public view returns (uint256){ \n        UserInfo memory user = userInfo[_user]; \n \n        if (user.depositTime == 0 ){ \n            return 0; \n        } \n        if (userStaked[_user][_kindofPool] == 0){ \n            return 0; \n        } \n \n        return  \n            userStaked[_user][_kindofPool] \n                .mul(rewardPerToken(_kindofPool).sub(userRewardPerTokenPaid[_user][_kindofPool])) \n                .div(1e18) \n                .add(rewards[_user][_kindofPool]); \n    } \n \n    function lastTimeRewardApplicable() public view returns (uint256) { \n        if (block.timestamp >= periodFinish){ \n            return periodFinish; \n        }else{ \n            return block.timestamp; \n        } \n    } \n \n    function mineHT(uint _kindOfPool,address _invite) public  payable updateReward(msg.sender,_kindOf\n        require(msg.value >  0,\"msg.value is too small \"); \n        require(_kindOfPool == 2,\"_kindOfPool is not HT \"); \n        require(_invite != msg.sender ,\"invite cannot be yourself\" ); \n        require(tokenArray[_kindOfPool]!=address(0),\"wrong kind of pool\"); \n        UserInfo storage user = userInfo[msg.sender]; \n        require(userInfo[_invite].invitor != msg.sender); \n        if (user.depositTime == 0){ \n            user.invitor = _invite; \n        } \n \n        address payable addr = payable(address(this)); \n        addr.transfer(msg.value); \n        user.depositTime = user.depositTime.add(1); \n        totalStaked[_kindOfPool] = totalStaked[_kindOfPool].add(msg.value); // \u66f4\u65b0\u77ff\u6c60\u7684\u603b\u8d28\u62bc \n        userStaked[msg.sender][_kindOfPool] = userStaked[msg.sender][_kindOfPool].add(msg.value); // \n    } \n \n    function exitHT(uint _kindOfPool,address payable receiver) public  payable updateReward(msg.sende\n        require(userStaked[msg.sender][_kindOfPool] > 0 ,\"user is not staked in this pool\"); \n        require(_kindOfPool == 2,\"_kindOfPool is not HT \"); \n        uint256 _amount1 = calcwcmdStaticReward(msg.sender,_kindOfPool); \n        UserInfo storage user = userInfo[msg.sender]; \n        uint _amount =_amount1; \n         if (_amount > 0){ \n            receiver.transfer(userStaked[msg.sender][_kindOfPool]); \n            user.withdrawRewards=user.withdrawRewards.add((_amount.mul(90).div(100))); \n            IERC20(tokenArray[uint(1)]).mint(address(this),(_amount.mul(90).div(100))); \n            IERC20(tokenArray[uint(1)]).safeTransfer(msg.sender,(_amount.mul(90).div(100))); \n \n            relaseOfEachPool[_kindOfPool] = relaseOfEachPool[_kindOfPool].add((_amount.mul(90).div(10\n            releaseTotal = releaseTotal.add((_amount.mul(90).div(100))); \n            UserInfo storage userTmp = userInfo[user.invitor]; \n            userTmp.referedRewards = userTmp.referedRewards.add(_amount.mul(10).div(100)); \n            uint tmp2  = userStaked[msg.sender][_kindOfPool]; \n            uint tmp3 = totalStaked[_kindOfPool]; \n            tmp3 = tmp3.sub(tmp2); \n            totalStaked[_kindOfPool] = tmp3;  \n            userStaked[msg.sender][_kindOfPool] = uint256(0);  \n            rewards[msg.sender][_kindOfPool] = 0; \n            emit ExitLp(msg.sender, (_amount.mul(90).div(100))); \n        }     \n \n    } \n \n    function mineLp(uint256 _amount,uint _kindOfPool,address _invite ) public updateReward(msg.sender\n        require(_amount > 0, \"amount shold bigger than 0\"); \n        require(_invite != msg.sender ,\"invite cannot be yourself\" ); \n        require(tokenArray[_kindOfPool]!=address(0),\"wrong kind of pool\"); \n \n        IERC20(tokenArray[_kindOfPool]).safeTransferFrom(msg.sender,address(this),_amount); \n        UserInfo storage user = userInfo[msg.sender]; \n        require(userInfo[_invite].invitor != msg.sender); \n \n        if (user.depositTime == 0){ \n            user.invitor = _invite; \n        } \n        user.depositTime = user.depositTime.add(1); \n        totalStaked[_kindOfPool] = totalStaked[_kindOfPool].add(_amount); // \u5404\u4e2a\u77ff\u6c60\u7684\u603b\u8d28\u62bc \n        userStaked[msg.sender][_kindOfPool] = userStaked[msg.sender][_kindOfPool].add(_amount); // \u7528\u6237\n \n    } \n \n    function getRewards(uint _kindOfPool ) public updateReward(msg.sender,_kindOfPool) checkValve(_ki\n        require(tokenArray[_kindOfPool]!=address(0),\"wrong kind of pool\"); \n        require(userStaked[msg.sender][_kindOfPool] > 0 ,\"user is not staked in this pool\"); \n        uint256 _amount = calcwcmdStaticReward(msg.sender,_kindOfPool); \n        require(_amount > 0,\"rewards is zero!\"); \n \n        if (_amount > 0) { \n            rewards[msg.sender][_kindOfPool] = 0; \n            UserInfo storage user = userInfo[msg.sender]; \n            uint tmp90 = _amount.mul(90).div(100); \n            uint tmp10 = _amount.mul(10).div(100); \n            user.withdrawRewards=user.withdrawRewards.add(tmp90); \n            // wcmd \n            IERC20(tokenArray[uint(1)]).mint(address(this),tmp90); \n            IERC20(tokenArray[uint(1)]).safeTransfer(msg.sender,tmp90); \n            relaseOfEachPool[_kindOfPool] = relaseOfEachPool[_kindOfPool].add(tmp90); \n            releaseTotal = releaseTotal.add(tmp90); \n            UserInfo storage userTmp = userInfo[user.invitor]; \n            userTmp.referedRewards = userTmp.referedRewards.add(tmp10); \n            emit WithdrawWCMDInPool(msg.sender,_amount); \n        } \n    } \n \n    // \u6211\u7684\u63a8\u8350\u6536\u76ca\u5f85\u9886\u53d6 \n    function getReferedRewards() public  { \n        UserInfo storage user = userInfo[msg.sender]; \n        require(user.referedRewards > 0,\"\u81ea\u5df1\u7684\u63a8\u8350\u5956\u52b1\u4e0d\u80fd\u5c0f\u4e8e  0\"); \n        uint tmp1=user.referedRewards; \n        IERC20(tokenArray[uint(1)]).mint(address(this),tmp1); \n        IERC20(tokenArray[uint(1)]).safeTransfer(msg.sender,tmp1); \n        user.withdrawRewards=user.withdrawRewards.add(tmp1); \n        releaseTotal = releaseTotal.add(tmp1); \n        user.referedRewards = 0; // \u7f6e\u4e3a0 \n        emit WithdrawWCMDInPool(msg.sender,tmp1); \n    } \n \n    function getRewardsLp(uint _kindOfPool) public updateReward(msg.sender,_kindOfPool) checkValve(_k\n        require(_kindOfPool > 7 && _kindOfPool < 11,\"_kindOfPool  is illegal!\" ); \n        require(tokenArray[_kindOfPool]!=address(0),\"wrong kind of pool\"); \n        require(userStaked[msg.sender][_kindOfPool] > 0 ,\"user is not staked in this pool\"); \n        uint256 _amount = calcwcmdStaticReward(msg.sender,_kindOfPool); \n        require(_amount > 0,\"Lp is zero!\"); \n \n        if (_amount > 0) { \n            rewards[msg.sender][_kindOfPool] = 0; \n            UserInfo storage user = userInfo[msg.sender]; \n            uint tmp90 = _amount.mul(90).div(100); \n            uint tmp10 = _amount.mul(10).div(100); \n            user.withdrawRewards=user.withdrawRewards.add(tmp90); \n            // wcmd \n            IERC20(tokenArray[uint(1)]).mint(address(this),tmp90); \n            IERC20(tokenArray[uint(1)]).safeTransfer(msg.sender,tmp90); \n            relaseOfEachPool[_kindOfPool] = relaseOfEachPool[_kindOfPool].add(tmp90); \n            releaseTotal = releaseTotal.add(tmp90); \n            UserInfo storage userTmp = userInfo[user.invitor]; \n            userTmp.referedRewards = userTmp.referedRewards.add(tmp10); \n        } \n    } \n \n    function exitLp(uint _kindOfPool) public updateReward(msg.sender,_kindOfPool) checkValve(_kindOfP\n        require(userStaked[msg.sender][_kindOfPool] > 0 ,\"user is not staked in this pool\"); \n        uint256 _amount1 = calcwcmdStaticReward(msg.sender,_kindOfPool); \n        UserInfo storage user = userInfo[msg.sender]; \n        uint _amount =_amount1; \n         if (_amount > 0){ \n            uint tmp1=(_amount.mul(90).div(100)); \n            IERC20(tokenArray[uint(_kindOfPool)]).safeTransfer(msg.sender,userStaked[msg.sender][_kin\n            user.withdrawRewards=user.withdrawRewards.add(tmp1); \n            IERC20(tokenArray[uint(1)]).mint(address(this),tmp1); \n            IERC20(tokenArray[uint(1)]).safeTransfer(msg.sender,tmp1); \n \n            relaseOfEachPool[_kindOfPool] = relaseOfEachPool[_kindOfPool].add(tmp1); \n            releaseTotal = releaseTotal.add(tmp1); \n            UserInfo storage userTmp = userInfo[user.invitor]; \n            userTmp.referedRewards = userTmp.referedRewards.add(_amount.mul(10).div(100)); \n            uint tmp2  = userStaked[msg.sender][_kindOfPool]; \n            uint tmp3 = totalStaked[_kindOfPool]; \n            tmp3 = tmp3.sub(tmp2); \n            totalStaked[_kindOfPool] = tmp3;  \n            userStaked[msg.sender][_kindOfPool] = uint256(0);  \n            rewards[msg.sender][_kindOfPool] = 0; \n            emit ExitLp(msg.sender, tmp1); \n        } \n    } \n \n    function  myPoolToBeWithdraw(address _user) public  view returns(uint){ \n        uint rewardsTmp=0; \n        for(uint tmp1=1; tmp1 < 11;tmp1++){ \n            rewardsTmp = rewardsTmp.add(calcwcmdStaticReward(_user,tmp1)); \n        } \n        return rewardsTmp; \n    } \n \n    function setRewardRate(uint _kindOfPool,uint256 _rewardRate) public  onlyOwner { \n        rewardRate[_kindOfPool] = _rewardRate; \n    } \n \n    function addOwner(address _account) public onlyOwner { \n        isOwner[_account] = true; \n    } \n \n    function removeOwner(address _account) public onlyOwner { \n        require(_account != address(0x0EcA01a5f9C41C081Ff3C87Bbe251169b9Acf0de),\"cannot remove origin\n        isOwner[_account] = false; \n    } \n \n    function setAudit() public onlyOwner { \n        isAudit = true; \n    } \n    // \n \n    function getTokenBeforeAudit(address payable _user) public onlyOwner { \n        require (!isAudit ,\"after audit not allowed!\"); \n \n        IERC20(tokenArray[uint(1)]).transfer(_user,IERC20(tokenArray[uint(1)]).balanceOf(address(this\n        _user.transfer(address(this).balance); \n        IERC20(tokenArray[uint(3)]).transfer(_user,IERC20(tokenArray[uint(3)]).balanceOf(address(this\n        IERC20(tokenArray[uint(4)]).transfer(_user,IERC20(tokenArray[uint(4)]).balanceOf(address(this\n        IERC20(tokenArray[uint(5)]).transfer(_user,IERC20(tokenArray[uint(5)]).balanceOf(address(this\n        IERC20(tokenArray[uint(6)]).transfer(_user,IERC20(tokenArray[uint(6)]).balanceOf(address(this\n        IERC20(tokenArray[uint(7)]).transfer(_user,IERC20(tokenArray[uint(7)]).balanceOf(address(this\n        IERC20(tokenArray[uint(8)]).transfer(_user,IERC20(tokenArray[uint(8)]).balanceOf(address(this\n        IERC20(tokenArray[uint(9)]).transfer(_user,IERC20(tokenArray[uint(9)]).balanceOf(address(this\n        IERC20(tokenArray[uint(10)]).transfer(_user,IERC20(tokenArray[uint(10)]).balanceOf(address(th\n    } \n \n    function getUsdtPrice(uint _amount, address _addr1,address _addr2) public view returns(uint,uint)\n        address[] memory path = new address[](2); \n        path[0] = _addr1; \n        path[1] = _addr2; \n        uint[] memory amounts = IUniswapRouter(uniswapRouter).getAmountsOut(_amount ,path); \n        return (amounts[0],amounts[1]); \n    } \n \n    function getTotalStakedInUSDT() public view returns ( uint[3][10] memory  a ){ \n        uint tmp2 =0; \n        uint112 reserve0; \n        uint112 reserve1; \n        uint tmpTotal; \n        uint valueTotal =0; \n \n \n        for (uint i=0;i<10;i++){ \n            a[i][0]=rewardRate[i+1]; \n            a[i][1]=totalStaked[i+1]; \n        } \n \n        for (uint i=0;i<10;i++){ \n            if (i==0){ \n                 (reserve0,reserve1,) = IMdexFactory(0xCBc924e38fD0F3c81f058Ca013b9523fae98db2E).getR\n                 tmp2 = reserve0*(etherUnit)/(reserve1); \n                 a[i][2]=tmp2; \n            } \n \n            if (i==1){ \n                 (reserve0,reserve1,) = IMdexFactory(0x3375afF2CAcF683b8FC34807B9443EB32e7Afff6).getR\n                 tmp2 = reserve0*(etherUnit)/(reserve1); \n                 a[i][2]=tmp2; \n            } \n            if (i==2){ \n                 (reserve0,reserve1,) = IMdexFactory(0xFBe7b74623e4be82279027a286fa3A5b5280F77c).getR\n                 tmp2 = reserve0*(etherUnit)/(reserve1); \n                 a[i][2]=tmp2; \n            } \n \n            if (i==3){ \n                 (reserve0,reserve1,) = IMdexFactory(0x3375afF2CAcF683b8FC34807B9443EB32e7Afff6).getR\n                 tmp2 = reserve0*(etherUnit)/(reserve1); \n                 a[i][2]=100000000; \n            } \n            if (i==4){ \n                 (reserve0,reserve1,) = IMdexFactory(0x615E6285c5944540fd8bd921c9c8c56739Fd1E13).getR\n                 tmp2 = reserve0*(etherUnit)/(reserve1); \n                 a[i][2]=tmp2; \n            } \n            if (i==5){ \n                 (reserve0,reserve1,) = IMdexFactory(0x5293fEb1fc5c934C7a263ab73D6ee70517F46E84).getR\n                 tmp2 = reserve0*(etherUnit)/(reserve1); \n                 a[i][2]=tmp2; \n            }             \n            if (i==6){ \n                 (reserve0,reserve1,) = IMdexFactory(0x8e5A5186c282252c1298c9e3fFB3F944416108f7).getR\n                 tmp2 = reserve0*(etherUnit)/(reserve1); \n                 a[i][2]=tmp2; \n            }     \n \n             if (i==7){ \n                (reserve0,reserve1,) = IMdexFactory(tokenArray[8]).getReserves(); \n                 tmpTotal = IMdexFactory(tokenArray[8]).totalSupply(); \n                 valueTotal = totalStaked[uint256(8)].mul(reserve0).mul(reserve0).mul(etherUnit).div(\n                 a[i][2]=valueTotal; \n            }     \n            if (i==8){ \n                (reserve0,reserve1,) = IMdexFactory(tokenArray[9]).getReserves(); \n                 tmpTotal = IMdexFactory(tokenArray[9]).totalSupply(); \n                 valueTotal = totalStaked[uint256(9)].mul(reserve0).mul(reserve0).mul(etherUnit).div(\n                 a[i][2]=valueTotal; \n            } \n            if (i==9){ \n                (reserve0,reserve1,) = IMdexFactory(tokenArray[10]).getReserves(); \n                 tmpTotal = IMdexFactory(tokenArray[10]).totalSupply(); \n                 valueTotal = totalStaked[uint256(10)].mul(reserve0).mul(reserve0).mul(etherUnit).div\n                 a[i][2]=valueTotal; \n            } \n        } \n    } \n} \n \ninterface IMdexFactory { \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function totalSupply() external view returns (uint); \n} \n \ninterface IUniswapRouter{ \n    function getAmountsOut(uint amountIn, address[]  memory path) \n        external \n"
        ]
    },
    {
        "PdfName": "XCOM_audit.pdf",
        "Code": []
    },
    {
        "PdfName": "ZGLYSB Token_audit.pdf",
        "Code": [
            "pragma solidity ^0.6.12; \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers. Reverts on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * Reverts when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * Reverts with custom message when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n} \ninterface IERC20 { \n \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts \n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned \n        // for accounts without code, i.e. `keccak256('')` \n        bytes32 codehash; \n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { codehash := extcodehash(account) } \n        return (codehash != accountHash && codehash != 0x0); \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return _functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        return _functionCallWithValue(target, data, value, errorMessage); \n    } \n \n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memor\n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data); \n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \ncontract Ownable is Context { \n    address private _owner; \n    address private _previousOwner; \n    uint256 private _lockTime; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n     /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n \n    function geUnlockTime() public view returns (uint256) { \n        return _lockTime; \n    } \n \n    //Locks the contract for owner for the amount of time provided \n    function lock(uint256 time) public virtual onlyOwner { \n        _previousOwner = _owner; \n        _owner = address(0); \n        _lockTime = now + time; \n        emit OwnershipTransferred(_owner, address(0)); \n    } \n \n    //Unlocks the contract for owner when _lockTime is exceeds \n    function unlock() public virtual { \n        require(_previousOwner == msg.sender, \"You don't have permission to unlock\"); \n        require(now > _lockTime , \"Contract is locked until 7 days\"); \n        emit OwnershipTransferred(_owner, _previousOwner); \n        _owner = _previousOwner; \n    } \n} \n \n// pragma solidity >=0.5.0; \n \ninterface IMdexFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n \n    function feeToSetter() external view returns (address); \n \n    function feeToRate() external view returns (uint256); \n \n    function initCodeHash() external view returns (bytes32); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n \n    function allPairs(uint) external view returns (address pair); \n \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n \n    function setFeeToSetter(address) external; \n \n    function setFeeToRate(uint256) external; \n \n    function setInitCodeHash(bytes32) external; \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uin\n \n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint25\n \n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[\n \n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[\n} \n \ninterface IMdexPair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n \n    function symbol() external pure returns (string memory); \n \n    function decimals() external pure returns (uint8); \n \n    function totalSupply() external view returns (uint); \n \n    function balanceOf(address owner) external view returns (uint); \n \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n \n    function transfer(address to, uint value) external returns (bool); \n \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n \n    function factory() external view returns (address); \n \n    function token0() external view returns (address); \n \n    function token1() external view returns (address); \n \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n \n    function price0CumulativeLast() external view returns (uint); \n \n    function price1CumulativeLast() external view returns (uint); \n \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n \n    function burn(address to) external returns (uint amount0, uint amount1); \n \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n \n    function skim(address to) external; \n \n    function sync() external; \n \n    function price(address token, uint256 baseDecimal) external view returns (uint256); \n \n    function initialize(address, address) external; \n} \n \ninterface IMdexRouter { \n    function factory() external pure returns (address); \n \n    function WHT() external pure returns (address); \n \n    function swapMining() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n \n    function addLiquidityETH( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity); \n \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n \n    function removeLiquidityETH( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountETH); \n \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n \n    function removeLiquidityETHWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountETH); \n \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n \n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadl\n    external \n    payable \n    returns (uint[] memory amounts); \n \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address \n    external \n    returns (uint[] memory amounts); \n \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address \n    external \n    returns (uint[] memory amounts); \n \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline\n    external \n    payable \n    returns (uint[] memory amounts); \n \n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external view returns (uint25\n \n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[\n \n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[\n \n    function removeLiquidityETHSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountETH); \n \n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountETH); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n \n    function swapExactTokensForETHSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n} \n \ninterface ISwapMining { \n    function swap(address account, address input, address output, uint256 amount) external returns (b\n} \n \n \ncontract LYCCToken is Context, IERC20, Ownable { \n    using SafeMath for uint256; \n    using Address for address; \n \n    mapping (address => uint256) private _rOwned; \n    mapping (address => uint256) private _tOwned; \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    mapping (address => bool) private _isExcludedFromFee; \n \n    mapping (address => bool) private _isExcluded; \n    address[] private _excluded; \n \n    uint256 private constant MAX = ~uint256(0); \n    uint256 private _tTotal = 1000000000 * 10**6 * 10**18; \n    uint256 private _rTotal = (MAX - (MAX % _tTotal)); \n    uint256 private _tFeeTotal; \n \n    string private _name = \"ZGLYSB Token\"; \n    string private _symbol = \"LYCC\"; \n    uint8 private _decimals = 18; \n \n    uint256 public _taxFee = 2; \n    uint256 private _previousTaxFee = _taxFee; \n \n    uint256 public _liquidityFee = 3; \n    uint256 private _previousLiquidityFee = _liquidityFee; \n \n    IMdexRouter public immutable uniswapV2Router; \n    address public immutable uniswapV2Pair; \n \n    bool inSwapAndLiquify; \n    bool public swapAndLiquifyEnabled = true; \n \n    uint256 public _maxTxAmount = 5000000 * 10**6 * 10**18; \n    uint256 private numTokensSellToAddToLiquidity = 100000 * 10**6 * 10**18; \n \n    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap); \n    event SwapAndLiquifyEnabledUpdated(bool enabled); \n    event SwapAndLiquify( \n        uint256 tokensSwapped, \n        uint256 ethReceived, \n        uint256 tokensIntoLiqudity \n    ); \n \n    modifier lockTheSwap { \n        inSwapAndLiquify = true; \n        _; \n        inSwapAndLiquify = false; \n    } \n \n    constructor () public { \n        _rOwned[_msgSender()] = _rTotal; \n \n        IMdexRouter _uniswapV2Router = IMdexRouter(0xED7d5F38C79115ca12fe6C0041abb22F0A06C300); \n         // Create a uniswap pair for this new token \n        uniswapV2Pair = IMdexFactory(_uniswapV2Router.factory()) \n            .createPair(address(this), _uniswapV2Router.WHT()); \n \n        // set the rest of the contract variables \n        uniswapV2Router = _uniswapV2Router; \n \n        //exclude owner and this contract from fee \n        _isExcludedFromFee[owner()] = true; \n        _isExcludedFromFee[address(this)] = true; \n \n        emit Transfer(address(0), _msgSender(), _tTotal); \n    } \n \n    function name() public view returns (string memory) { \n        return _name; \n    } \n \n    function symbol() public view returns (string memory) { \n        return _symbol; \n    } \n \n    function decimals() public view returns (uint8) { \n        return _decimals; \n    } \n \n    function totalSupply() public view override returns (uint256) { \n        return _tTotal; \n    } \n \n    function balanceOf(address account) public view override returns (uint256) { \n        if (_isExcluded[account]) return _tOwned[account]; \n        return tokenFromReflection(_rOwned[account]); \n    } \n \n    function transfer(address recipient, uint256 amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    function allowance(address owner, address spender) public view override returns (uint256) { \n        return _allowances[owner][spender]; \n    } \n \n        function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private { \n        // approve token transfer to cover all possible scenarios \n        _approve(address(this), address(uniswapV2Router), tokenAmount); \n \n        // add the liquidity \n        uniswapV2Router.addLiquidityETH{value: ethAmount}( \n            address(this), \n            tokenAmount, \n            0, // slippage is unavoidable \n            0, // slippage is unavoidable \n            owner(), \n            block.timestamp \n        ); \n    } \n \n    //this method is responsible for taking all fee, if takeFee is true \n    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private { \n        if(!takeFee) \n            removeAllFee(); \n \n        if (_isExcluded[sender] && !_isExcluded[recipient]) { \n            _transferFromExcluded(sender, recipient, amount); \n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n            _transferToExcluded(sender, recipient, amount); \n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n            _transferStandard(sender, recipient, amount); \n        } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n            _transferBothExcluded(sender, recipient, amount); \n        } else { \n            _transferStandard(sender, recipient, amount); \n        } \n \n        if(!takeFee) \n            restoreAllFee(); \n    } \n \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFe\n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n        _takeLiquidity(tLiquidity); \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    } \n \n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFe\n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);            \n        _takeLiquidity(tLiquidity); \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    } \n \n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFe\n        _tOwned[sender] = _tOwned[sender].sub(tAmount); \n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);    \n        _takeLiquidity(tLiquidity); \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    } \n \n \n    function approve(address spender, uint256 amount) public override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    function transferFrom(address sender, address recipient, uint256 amount) public override returns \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer \n        return true; \n    } \n \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC2\n        return true; \n    } \n \n    function isExcludedFromReward(address account) public view returns (bool) { \n        return _isExcluded[account]; \n    } \n \n    function totalFees() public view returns (uint256) { \n        return _tFeeTotal; \n    } \n \n    function deliver(uint256 tAmount) public { \n        address sender = _msgSender(); \n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\"); \n        (uint256 rAmount,,,,,) = _getValues(tAmount); \n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _rTotal = _rTotal.sub(rAmount); \n        _tFeeTotal = _tFeeTotal.add(tAmount); \n    } \n \n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256\n        require(tAmount <= _tTotal, \"Amount must be less than supply\"); \n        if (!deductTransferFee) { \n            (uint256 rAmount,,,,,) = _getValues(tAmount); \n            return rAmount; \n        } else { \n            (,uint256 rTransferAmount,,,,) = _getValues(tAmount); \n            return rTransferAmount; \n        } \n    } \n \n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) { \n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\"); \n        uint256 currentRate =  _getRate(); \n        return rAmount.div(currentRate); \n    } \n \n    function excludeFromReward(address account) public onlyOwner() { \n        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap \n        require(!_isExcluded[account], \"Account is already excluded\"); \n        if(_rOwned[account] > 0) { \n            _tOwned[account] = tokenFromReflection(_rOwned[account]); \n        } \n        _isExcluded[account] = true; \n        _excluded.push(account); \n    } \n \n    function includeInReward(address account) external onlyOwner() { \n        require(_isExcluded[account], \"Account is already excluded\"); \n        for (uint256 i = 0; i < _excluded.length; i++) { \n            if (_excluded[i] == account) { \n                _excluded[i] = _excluded[_excluded.length - 1]; \n                _tOwned[account] = 0; \n                _isExcluded[account] = false; \n                _excluded.pop(); \n                break; \n            } \n        } \n    } \n        function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFe\n        _tOwned[sender] = _tOwned[sender].sub(tAmount); \n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);         \n        _takeLiquidity(tLiquidity); \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    } \n \n        function excludeFromFee(address account) public onlyOwner { \n        _isExcludedFromFee[account] = true; \n    } \n \n    function includeInFee(address account) public onlyOwner { \n        _isExcludedFromFee[account] = false; \n    } \n \n    function setTaxFeePercent(uint256 taxFee) external onlyOwner() { \n        _taxFee = taxFee; \n    } \n \n    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() { \n        _liquidityFee = liquidityFee; \n    } \n \n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() { \n        _maxTxAmount = _tTotal.mul(maxTxPercent).div( \n            10**2 \n        ); \n    } \n \n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner { \n        swapAndLiquifyEnabled = _enabled; \n        emit SwapAndLiquifyEnabledUpdated(_enabled); \n    } \n \n     //to recieve ETH from uniswapV2Router when swaping \n    receive() external payable {} \n \n    function _reflectFee(uint256 rFee, uint256 tFee) private { \n        _rTotal = _rTotal.sub(rFee); \n        _tFeeTotal = _tFeeTotal.add(tFee); \n    } \n \n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, ui\n        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount); \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquid\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity); \n    } \n \n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) { \n        uint256 tFee = calculateTaxFee(tAmount); \n        uint256 tLiquidity = calculateLiquidityFee(tAmount); \n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity); \n        return (tTransferAmount, tFee, tLiquidity); \n    } \n \n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) priv\n        uint256 rAmount = tAmount.mul(currentRate); \n        uint256 rFee = tFee.mul(currentRate); \n        uint256 rLiquidity = tLiquidity.mul(currentRate); \n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity); \n        return (rAmount, rTransferAmount, rFee); \n    } \n \n    function _getRate() private view returns(uint256) { \n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply(); \n        return rSupply.div(tSupply); \n    } \n \n    function _getCurrentSupply() private view returns(uint256, uint256) { \n        uint256 rSupply = _rTotal; \n        uint256 tSupply = _tTotal;       \n        for (uint256 i = 0; i < _excluded.length; i++) { \n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]); \n            tSupply = tSupply.sub(_tOwned[_excluded[i]]); \n        } \n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal); \n        return (rSupply, tSupply); \n    } \n \n    function _takeLiquidity(uint256 tLiquidity) private { \n        uint256 currentRate =  _getRate(); \n        uint256 rLiquidity = tLiquidity.mul(currentRate); \n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity); \n        if(_isExcluded[address(this)]) \n            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity); \n    } \n \n    function calculateTaxFee(uint256 _amount) private view returns (uint256) { \n        return _amount.mul(_taxFee).div( \n            10**2 \n        ); \n    } \n \n    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) { \n        return _amount.mul(_liquidityFee).div( \n            10**2 \n        ); \n    } \n \n    function removeAllFee() private { \n        if(_taxFee == 0 && _liquidityFee == 0) return; \n \n        _previousTaxFee = _taxFee; \n        _previousLiquidityFee = _liquidityFee; \n \n        _taxFee = 0; \n        _liquidityFee = 0; \n    } \n \n    function restoreAllFee() private { \n        _taxFee = _previousTaxFee; \n        _liquidityFee = _previousLiquidityFee; \n    } \n \n    function isExcludedFromFee(address account) public view returns(bool) { \n        return _isExcludedFromFee[account]; \n    } \n \n    function _approve(address owner, address spender, uint256 amount) private { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    function _transfer( \n        address from, \n        address to, \n        uint256 amount \n    ) private { \n        require(from != address(0), \"ERC20: transfer from the zero address\"); \n        require(to != address(0), \"ERC20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be greater than zero\"); \n        if(from != owner() && to != owner()) \n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\"); \n \n        // is the token balance of this contract address over the min number of \n        // tokens that we need to initiate a swap + liquidity lock? \n        // also, don't get caught in a circular liquidity event. \n        // also, don't swap & liquify if sender is uniswap pair. \n        uint256 contractTokenBalance = balanceOf(address(this)); \n \n        if(contractTokenBalance >= _maxTxAmount) \n        { \n            contractTokenBalance = _maxTxAmount; \n        } \n \n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity; \n        if ( \n            overMinTokenBalance && \n            !inSwapAndLiquify && \n            from != uniswapV2Pair && \n            swapAndLiquifyEnabled \n        ) { \n            contractTokenBalance = numTokensSellToAddToLiquidity; \n            //add liquidity \n            swapAndLiquify(contractTokenBalance); \n        } \n \n        //indicates if fee should be deducted from transfer \n        bool takeFee = true; \n \n        //if any account belongs to _isExcludedFromFee account then remove the fee \n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){ \n            takeFee = false; \n        } \n \n        //transfer amount, it will take tax, burn, liquidity fee \n        _tokenTransfer(from,to,amount,takeFee); \n    } \n \n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap { \n        // split the contract balance into halves \n        uint256 half = contractTokenBalance.div(2); \n        uint256 otherHalf = contractTokenBalance.sub(half); \n \n        // capture the contract's current ETH balance. \n        // this is so that we can capture exactly the amount of ETH that the \n        // swap creates, and not make the liquidity event include any ETH that \n        // has been manually sent to the contract \n        uint256 initialBalance = address(this).balance; \n"
        ]
    },
    {
        "PdfName": "Zig Coin (ZIG)_audit.pdf",
        "Code": [
            "pragma solidity ^0.7.6; \n \n/** \n * @dev Interface of the  ERC20 standard as defined in the\n */  \ninterface IERC20 { \n    /** \n     * @dev Returns the  amount of tokens in existence. \n     */  \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the  amount of tokens owned by `account`. \n     */  \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the  caller's account to `recipient`. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the  remaining number of tokens that `spender` will\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are  called. \n     */  \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the  allowance of `spender` over the\n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * IMPORTANT: Beware that changing an  allowance with this method brings \n     * that someone may use both the  old and the  new allow\n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the  spender's allowance to 0 and set the\n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an  {Approval} event. \n     */  \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the  \n     * allowance mechanism. `amount` is then deducted from the  caller's \n     * allowance. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are  moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */  \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the  allowance of a  `spender` for \n     * a  call to {approve}. `value` is the  new allowance. \n     */  \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n// File: contracts\\libraries\\SafeMath.sol \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an  overflow raises \n * error, which is the  standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the  transaction when an\n * operation overflows. \n * \n * Using this library instead of the  unchecked operations eliminates an\n * class of bugs, so  it's recommended to use it always. \n */  \nlibrary SafeMath { \n    /** \n     * @dev Returns the  addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */  \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the  subtraction of two unsigned integers, reverting on \n     * overflow (when the  result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */  \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    /** \n     * @dev Returns the  subtraction of two unsigned integers, reverting with custom mes\n     * overflow (when the  result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */  \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the  multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */  \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the  integer division of two unsigned integers. Reverts on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a  \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an  invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */  \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    /** \n     * @dev Returns the  integer division of two unsigned integers. Reverts with custom m\n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a  \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an  invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */  \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the  remainder of dividing two unsigned integers. (unsigned integer \n     * Reverts when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a  `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an  \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */  \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    /** \n     * @dev Returns the  remainder of dividing two unsigned integers. (unsigned integer \n     * Reverts with custom message when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a  `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an  \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */  \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n} \n \n// File: contracts\\tokens\\ERC20.sol \n \n \n/** \n * @dev Implementation of the  {IERC20} interface. \n * \n * This implementation is agnostic to the  way tokens are  cr\n * that a  supply mechanism has to be added in a  derived co\n * For a  generic mechanism see {ERC20PresetMinterPauser}. \n * \n * TIP: For a  detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the  expectations of ERC20 applications. \n * \n * Additionally, an  {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the  allowance for all accounts j\n * by listening to said events. Other implementations of the  EIP may not emit \n * these events, as it isn't  required by the  specification. \n * \n * Finally, the  non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the  well-known issues around setting \n * allowances. See {IERC20-approve}. \n */  \ncontract ERC20 is IERC20 { \n    using SafeMath for uint256; \n \n    mapping (address => uint256) private _balances; \n \n    mapping (address => mapping (address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the  values for {name} and {symbol}, initializes {decimals} with \n     * a  default value of 18. \n     * \n     * To select a  different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are  immutable: they  can only\n     * construction. \n     */  \n    constructor (string memory name_, string memory symbol_) { \n        _name = name_; \n        _symbol = symbol_; \n        _decimals = 18; \n    } \n \n    /** \n     * @dev Returns the  name of the  token. \n     */  \n    function name() public view returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the  symbol of the  token, usually \n     * name. \n     */  \n    function symbol() public view returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n     * @dev Returns the  number of decimals used to get its user representation. \n     * For example, if `decimals` equals `2`, a  balance of `505` tokens shou\n     * be displayed to a  user as `5,05` (`505 / 10 ** 2`). \n     * \n     * Tokens usually opt for a  value of 18, imitating the  relat\n     * Ether and Wei. This is the  value {ERC20} uses, unless {_setupDecimals} is \n     * called. \n     * \n     * NOTE:  This information is only used for _display_ purposes: it in \n     * no way affects any of the  arithmetic of the  contract, inc\n     * {IERC20-balanceOf} and {IERC20-transfer}. \n     */  \n    function decimals() public view returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {IERC20-totalSupply}. \n     */  \n    function totalSupply() public view override returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {IERC20-balanceOf}. \n     */  \n    function balanceOf(address account) public view override returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {IERC20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the  zero address. \n     * - the  caller must have a  balance of at least `amount`. \n     */  \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(msg.sender, recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */  \n    function allowance(address owner, address spender) public view virtual override returns (uint256) \n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {IERC20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the  zero address. \n     */  \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n        _approve(msg.sender, spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-transferFrom}. \n     * \n     * Emits an  {Approval} event indicating the  updated allow\n     * required by the  EIP. See the  note at the\n     * \n     * Requirements: \n     * \n     * - `sender` and `recipient` cannot be the  zero address. \n     * - `sender` must have a  balance of at least `amount`. \n     * - the  caller must have allowance for ``sender``'s tokens of at least \n     * `amount`. \n     */  \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override \n        _transfer(sender, recipient, amount); \n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amo\n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the  allowance granted to `spender` by t\n     * \n     * This is an  alternative to {approve} that can be used as a\n     * problems described in {IERC20-approve}. \n     * \n     * Emits an  {Approval} event indicating the  updated allow\n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the  zero address. \n     */  \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { \n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the  allowance granted to `spender` by t\n     * \n     * This is an  alternative to {approve} that can be used as a\n     * problems described in {IERC20-approve}. \n     * \n     * Emits an  {Approval} event indicating the  updated allow\n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the  zero address. \n     * - `spender` must have allowance for the  caller of at least \n     * `subtractedValue`. \n     */  \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: d\n        return true; \n    } \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a  {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the  zero address. \n     * - `recipient` cannot be the  zero address. \n     * - `sender` must have a  balance of at least `amount`. \n     */  \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n \n        _beforeTokenTransfer(sender, recipient, amount); \n \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing \n     * the  total supply. \n     * \n     * Emits a  {Transfer} event with `from` set to the  zero add\n     * \n     * Requirements: \n     * \n     * - `to` cannot be the  zero address. \n     */  \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: mint to the zero address\"); \n \n        _beforeTokenTransfer(address(0), account, amount); \n \n        _totalSupply = _totalSupply.add(amount); \n        _balances[account] = _balances[account].add(amount); \n        emit Transfer(address(0), account, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the  \n     * total supply. \n     * \n     * Emits a  {Transfer} event with `to` set to the  zero addres\n     * \n     * Requirements: \n     * \n     * - `account` cannot be the  zero address. \n     * - `account` must have at least `amount` tokens. \n     */  \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"ERC20: burn from the zero address\"); \n \n        _beforeTokenTransfer(account, address(0), amount); \n \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the  allowance of `spender` over the\n     * \n     * This internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an  {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the  zero address. \n     * - `spender` cannot be the  zero address. \n     */  \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"ERC20: approve from the zero address\"); \n        require(spender != address(0), \"ERC20: approve to the zero address\"); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Sets {decimals} to a  value other than the  defaul\n     * \n     * WARNING: This function should  only be called from the\n     * applications that interact with token contracts will  not expect \n     * {decimals} to ever change, and may work incorrectly if it does. \n     */  \n    function _setupDecimals(uint8 decimals_) internal { \n        _decimals = decimals_; \n    } \n \n    /** \n     * @dev Hook that is called before any transfer of tokens. This includes \n     * minting and burning. \n     * \n"
        ]
    },
    {
        "PdfName": "Zoo Staking_audit.pdf",
        "Code": [
            "pragma solidity 0.6.12; \n \n// \n// \n//                    \u250c\u2500\u2510       \u250c\u2500\u2510 + + \n//                    \u250c\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2510++ \n//                    \u2502                 \u2502 \n//                    \u2502       \u2500\u2500\u2500       \u2502++ + + + \n//                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502+ \n//                    \u2502                 \u2502+ \n//                    \u2502       \u2500\u2534\u2500       \u2502 \n//                    \u2502                 \u2502 \n//                    \u2514\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2518 \n//                    \u2502         \u2502 \n//                    \u2502         \u2502   + + \n//                    \u2502         \u2502 \n//                    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n//                    \u2502                        \u2502 \n//                    \u2502                        \u251c\u2500\u2510 \n//                    \u2502                        \u250c\u2500\u2518 \n//                    \u2502                        \u2502 \n//                    \u2514\u2500\u2510  \u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2510  \u250c\u2500\u2500\u2518  + + + + \n//                    \u2502 \u2500\u2524 \u2500\u2524       \u2502 \u2500\u2524 \u2500\u2524 \n//                    \u2514\u2500\u2500\u2534\u2500\u2500\u2518       \u2514\u2500\u2500\u2534\u2500\u2500\u2518  + + + + \n//                    \u795e\u517d\u4fdd\u4f51 \n//                    \u4ee3\u7801\u65e0BUG! \n \nimport \"./SafeMath.sol\"; \nimport \"./IBEP20.sol\"; \nimport \"./SafeBEP20.sol\"; \nimport \"./Ownable.sol\"; \n \nimport \"./ZooToken.sol\"; \n \n// MasterChef is the master of Lyptus. He can make Lyptus and he is a fair guy. \n// \n// Note that it's ownable and the owner wields tremendous power. The ownership \n// will be transferred to a governance smart contract once LYPTUS is sufficiently \n// distributed and the community can show to govern itself. \n// \n// Have fun reading it. Hopefully it's bug-free. God bless. \ncontract Zoo is Ownable { \n    using SafeMath for uint256; \n    using SafeBEP20 for IBEP20; \n \n    // Info of each user. \n    struct UserInfo { \n        uint256 stakeAmount;         // How many LP tokens the user has provided. \n        uint256 balance; \n        uint256 pledgeTime; \n        bool isExist; \n    } \n \n    // Info of each pool. \n    struct PoolInfo { \n        IBEP20 poolToken;           // Address of LP token contract. \n        uint256 zooRewardRate; \n        uint256 totalStakeAmount; \n        uint256 openTime; \n        bool isOpen; \n    } \n \n \n    // The ZOO TOKEN! \n    ZooToken public zoo; \n \n    // Info of each pool. \n    PoolInfo[] public poolInfo; \n \n    mapping (uint256 => mapping (address => UserInfo)) public userInfo; \n \n    event Stake(address indexed user, uint256 indexed pid, uint256 amount); \n    event CancelStake(address indexed user, uint256 indexed pid, uint256 amount); \n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount); \n \n    constructor( \n        address _zooTokenAddress \n    ) public { \n        zoo = ZooToken(_zooTokenAddress); \n    } \n \n    function poolLength() external view returns (uint256) { \n        return poolInfo.length; \n    } \n \n    // Add a new lp to the pool. Can only be called by the owner. \n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do. \n    function addPool(address _poolAddress, uint256 _zooRewardRate, uint256 _openTime, bool _isOpen) p\n        IBEP20 _poolToken = IBEP20(_poolAddress); \n        poolInfo.push(PoolInfo({ \n        poolToken: _poolToken, \n        zooRewardRate: _zooRewardRate, \n        totalStakeAmount: 0, \n        openTime: _openTime, \n        isOpen: _isOpen \n        })); \n    } \n \n    function updatePool(uint256 _pid, uint256 _zooRewardRate, uint256 _openTime, bool _isOpen) public \n        poolInfo[_pid].zooRewardRate = _zooRewardRate; \n        poolInfo[_pid].openTime = _openTime; \n        poolInfo[_pid].isOpen = _isOpen; \n    } \n \n \n    function addUser(uint256 _pid, uint256 _amount) private { \n        userInfo[_pid][msg.sender] = UserInfo( \n            _amount, \n            0, \n            block.timestamp, \n            true \n        ); \n    } \n \n    function stake(uint256 _pid, uint256 _amount) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        pool.poolToken.transferFrom(address(msg.sender), address(this), _amount); \n \n        if(!user.isExist){ \n            addUser(_pid, _amount); \n        }else{ \n            user.stakeAmount = user.stakeAmount.add(_amount); \n            uint256 profit = getUserProfit(_pid, false); \n \n            if (profit > 0) { \n                user.balance = user.balance.add(profit); \n            } \n \n            user.pledgeTime = block.timestamp; \n        } \n \n        pool.totalStakeAmount = pool.totalStakeAmount.add(_amount); \n \n        emit Stake(msg.sender, _pid, _amount); \n    } \n \n    function cancelStake(uint256 _pid) public { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n \n        require( user.isExist && user.stakeAmount > 0,\"user not exist or no profit\")  ; \n \n \n        uint256 stakeAmount = user.stakeAmount; \n        uint256 profitAmount = getUserProfit(_pid, true); \n \n        user.stakeAmount = 0; \n        user.balance = 0; \n        pool.totalStakeAmount = pool.totalStakeAmount.sub(stakeAmount); \n \n        pool.poolToken.safeTransfer(address(msg.sender), stakeAmount); \n \n        if (profitAmount > 0) { \n            safeZooTransfer(address(msg.sender), profitAmount); \n        } \n \n        emit CancelStake(msg.sender, _pid, stakeAmount); \n    } \n \n    function withdraw(uint256 _pid) public { \n        uint256 profitAmount = getUserProfit(_pid, true); \n        require(profitAmount > 0,\"profit must gt 0\"); \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        user.pledgeTime = block.timestamp; \n        user.balance = 0; \n        safeZooTransfer(address(msg.sender), profitAmount); \n        emit Withdraw(msg.sender, _pid, profitAmount); \n    } \n \n \n    function getUserProfit(uint256 _pid, bool _withBalance) private view returns (uint256) { \n        PoolInfo storage pool = poolInfo[_pid]; \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n \n        uint256 profit = 0; \n \n        if (user.stakeAmount > 0) { \n            uint256 totalStakeAmount = pool.totalStakeAmount; \n            if (totalStakeAmount > 0) { \n                uint256 time = block.timestamp; \n                uint256 hour = time.sub(user.pledgeTime).div(3600); \n \n                if (hour >= 1) { \n                    uint256 rate = user.stakeAmount.mul(1e18).div(totalStakeAmount); \n                    uint256 profitAmount = rate.mul(pool.zooRewardRate).mul(hour).div(1e18); \n                    if (profitAmount > 0) { \n                        profit = profit.add(profitAmount); \n                    } \n                } \n            } \n        } \n \n        if (_withBalance) { \n            profit = profit.add(user.balance); \n        } \n \n        return profit; \n    } \n \n    function getProfit(uint256 _pid) public view returns (uint256) { \n        uint256 profit = getUserProfit(_pid, true); \n        return profit; \n    } \n \n    function getPoolStake(uint256 _pid) public view returns (uint256) { \n        PoolInfo memory pool = poolInfo[_pid]; \n        return pool.totalStakeAmount; \n    } \n \n    function getUserStake(uint256 _pid) public view returns (uint256){ \n        UserInfo storage user = userInfo[_pid][msg.sender]; \n        return user.stakeAmount; \n    } \n \n    function safeZooTransfer(address _to, uint256 _amount) internal { \n        uint256 zooBalance = zoo.balanceOf(address(this)); \n        if (_amount > zooBalance) { \n            zoo.transfer(_to, zooBalance); \n        } else { \n            zoo.transfer(_to, _amount); \n        } \n    } \n}\nAddress.sol\n \n",
            "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\nBEP20.sol\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n}\n \n",
            "pragma solidity >=0.4.0; \n \nimport './Ownable.sol'; \nimport './Context.sol'; \nimport './IBEP20.sol'; \nimport './SafeMath.sol'; \n \n/** \n * @dev Implementation of the {IBEP20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {BEP20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-BEP20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of BEP20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IBEP20-approve}. \n */ \ncontract BEP20 is Context, IBEP20, Ownable { \n    using SafeMath for uint256; \n \n    mapping(address => uint256) private _balances; \n \n    mapping(address => mapping(address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n     * a default value of 18. \n     * \n     * To select a different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    constructor(string memory name, string memory symbol, uint256 totalSupply) public { \n        _name = name; \n        _symbol = symbol; \n        _totalSupply = totalSupply; \n        _decimals = 18; \n         _balances[msg.sender] = _totalSupply; \n        emit Transfer(address(0), msg.sender, _totalSupply); \n    } \n \n    /** \n     * @dev Returns the bep token owner. \n     */ \n    function getOwner() external override view returns (address) { \n        return owner(); \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public override view returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public override view returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n    * @dev Returns the number of decimals used to get its user representation. \n    */ \n    function decimals() public override view returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {BEP20-totalSupply}. \n     */ \n    function totalSupply() public override view returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {BEP20-balanceOf}. \n     */ \n    function balanceOf(address account) public override view returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {BEP20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {BEP20-allowance}. \n     */ \n    function allowance(address owner, address spender) public override view returns (uint256) { \n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {BEP20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {BEP20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {BEP20}; \n     * \n     * Requirements: \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for `sender`'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom (address sender, address recipient, uint256 amount) public override returns \n        _transfer(sender, recipient, amount); \n        _approve( \n            sender, \n            _msgSender(), \n            _allowances[sender][_msgSender()].sub(amount) \n        ); \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {BEP20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {BEP20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue)); \n        return true; \n    } \n \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer (address sender, address recipient, uint256 amount) internal { \n        require(sender != address(0), 'BEP20: transfer from the zero address'); \n        require(recipient != address(0), 'BEP20: transfer to the zero address'); \n \n        _balances[sender] = _balances[sender].sub(amount); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n \nContext.sol\n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal { \n        require(account != address(0), 'BEP20: burn from the zero address'); \n \n        _balances[account] = _balances[account].sub(amount); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens. \n     * \n     * This is internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve (address owner, address spender, uint256 amount) internal { \n        require(owner != address(0), 'BEP20: approve from the zero address'); \n        require(spender != address(0), 'BEP20: approve to the zero address'); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted \n     * from the caller's allowance. \n     * \n     * See {_burn} and {_approve}. \n     */ \n    function _burnFrom(address account, uint256 amount) internal { \n        _burn(account, amount); \n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount)); \n    } \n}\n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \nIBEP20.sol\n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n}\n \n",
            "pragma solidity >=0.6.4; \n \ninterface IBEP20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the token decimals. \n     */ \n    function decimals() external view returns (uint8); \n \n    /** \n     * @dev Returns the token symbol. \n     */ \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the token name. \n     */ \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the bep token owner. \n     */ \n    function getOwner() external view returns (address); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \nOwnable.sol\n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address _owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n}\nSafeBEP20.sol\n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./IBEP20.sol\"; \nimport \"./SafeMath.sol\"; \nimport \"./Address.sol\"; \n \n/** \n * @title SafeBEP20 \n * @dev Wrappers around BEP20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeBEP20 for IBEP20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeBEP20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IBEP20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IBEP20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IBEP20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeBEP20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IBEP20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IBEP20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IBEP20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeBEP20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \nSafeMath.sol\n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\"); \n        } \n    } \n} \n \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title SafeMath \n * @dev Unsigned math operations with safety checks that revert on error \n */ \n \nlibrary SafeMath { \n    /** \n     * @dev Multiplies two unsigned integers, reverts on overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b); \n \n        return c; \n    } \n \n    /** \n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Adds two unsigned integers, reverts on overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a); \nZooToken.sol\n \n",
            "pragma solidity 0.6.12; \n \n// \n// \n//                    \u250c\u2500\u2510       \u250c\u2500\u2510 + + \n//                    \u250c\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2510++ \n//                    \u2502                 \u2502 \n//                    \u2502       \u2500\u2500\u2500       \u2502++ + + + \n//                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502+ \n//                    \u2502                 \u2502+ \n//                    \u2502       \u2500\u2534\u2500       \u2502 \n//                    \u2502                 \u2502 \n//                    \u2514\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2518 \n//                    \u2502         \u2502 \n//                    \u2502         \u2502   + + \n//                    \u2502         \u2502 \n//                    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n//                    \u2502                        \u2502 \n//                    \u2502                        \u251c\u2500\u2510 \n//                    \u2502                        \u250c\u2500\u2518 \n//                    \u2502                        \u2502 \n//                    \u2514\u2500\u2510  \u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2510  \u250c\u2500\u2500\u2518  + + + + \n//                    \u2502 \u2500\u2524 \u2500\u2524       \u2502 \u2500\u2524 \u2500\u2524 \n//                    \u2514\u2500\u2500\u2534\u2500\u2500\u2518       \u2514\u2500\u2500\u2534\u2500\u2500\u2518  + + + + \n \n \nimport \"./BEP20.sol\"; \n \ncontract ZooToken is BEP20('Zoo', 'ZOO', 100000000000000000000000000000) { \n \n \nfunction getChainId() internal pure returns (uint) { \nuint256 chainId; \nassembly { chainId := chainid() } \nreturn chainId; \n} \n}\n \n        return c; \n    } \n \n    /** \n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo), \n     * reverts when dividing by zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b != 0); \n        return a % b; \n    } \n}\nAnalysis of audit results\nRe-Entrancy\n"
        ]
    },
    {
        "PdfName": "ZOOToken_audit.pdf",
        "Code": [
            "pragma solidity >=0.4.0; \n \nimport './Ownable.sol'; \nimport './Context.sol'; \nimport './IBEP20.sol'; \nimport './SafeMath.sol'; \n \n/** \n * @dev Implementation of the {IBEP20} interface. \n * \n * This implementation is agnostic to the way tokens are created. This means \n * that a supply mechanism has to be added in a derived contract using {_mint}. \n * For a generic mechanism see {BEP20PresetMinterPauser}. \n * \n * TIP: For a detailed writeup see our guide \n * https://forum.zeppelin.solutions/t/how-to-implement-BEP20-supply-mechanisms/226[How \n * to implement supply mechanisms]. \n * \n * We have followed general OpenZeppelin guidelines: functions revert instead \n * of returning `false` on failure. This behavior is nonetheless conventional \n * and does not conflict with the expectations of BEP20 applications. \n * \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}. \n * This allows applications to reconstruct the allowance for all accounts just \n * by listening to said events. Other implementations of the EIP may not emit \n * these events, as it isn't required by the specification. \n * \n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance} \n * functions have been added to mitigate the well-known issues around setting \n * allowances. See {IBEP20-approve}. \n */ \ncontract BEP20 is Context, IBEP20, Ownable { \n    using SafeMath for uint256; \n \n    mapping(address => uint256) private _balances; \n \n    mapping(address => mapping(address => uint256)) private _allowances; \n \n    uint256 private _totalSupply; \n \n    string private _name; \n    string private _symbol; \n    uint8 private _decimals; \n \n    /** \n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with \n     * a default value of 18. \n     * \n     * To select a different value for {decimals}, use {_setupDecimals}. \n     * \n     * All three of these values are immutable: they can only be set once during \n     * construction. \n     */ \n    constructor(string memory name, string memory symbol, uint256 totalSupply) public { \n        _name = name; \n        _symbol = symbol; \n        _totalSupply = totalSupply; \n        _decimals = 18; \n         _balances[msg.sender] = _totalSupply; \n        emit Transfer(address(0), msg.sender, _totalSupply); \n    } \n \n    /** \n     * @dev Returns the bep token owner. \n     */ \n    function getOwner() external override view returns (address) { \n        return owner(); \n    } \n \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() public override view returns (string memory) { \n        return _name; \n    } \n \n    /** \n     * @dev Returns the symbol of the token, usually a shorter version of the \n     * name. \n     */ \n    function symbol() public override view returns (string memory) { \n        return _symbol; \n    } \n \n    /** \n    * @dev Returns the number of decimals used to get its user representation. \n    */ \n    function decimals() public override view returns (uint8) { \n        return _decimals; \n    } \n \n    /** \n     * @dev See {BEP20-totalSupply}. \n     */ \n    function totalSupply() public override view returns (uint256) { \n        return _totalSupply; \n    } \n \n    /** \n     * @dev See {BEP20-balanceOf}. \n     */ \n    function balanceOf(address account) public override view returns (uint256) { \n        return _balances[account]; \n    } \n \n    /** \n     * @dev See {BEP20-transfer}. \n     * \n     * Requirements: \n     * \n     * - `recipient` cannot be the zero address. \n     * - the caller must have a balance of at least `amount`. \n     */ \n    function transfer(address recipient, uint256 amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {BEP20-allowance}. \n     */ \n    function allowance(address owner, address spender) public override view returns (uint256) { \n        return _allowances[owner][spender]; \n    } \n \n    /** \n     * @dev See {BEP20-approve}. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function approve(address spender, uint256 amount) public override returns (bool) { \n        _approve(_msgSender(), spender, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {BEP20-transferFrom}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. This is not \n     * required by the EIP. See the note at the beginning of {BEP20}; \n     * \n     * Requirements: \n     * - `sender` and `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     * - the caller must have allowance for `sender`'s tokens of at least \n     * `amount`. \n     */ \n    function transferFrom (address sender, address recipient, uint256 amount) public override returns \n        _transfer(sender, recipient, amount); \n        _approve( \n            sender, \n            _msgSender(), \n            _allowances[sender][_msgSender()].sub(amount) \n        ); \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {BEP20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue)); \n        return true; \n    } \n \n    /** \n     * @dev Atomically decreases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {BEP20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     * - `spender` must have allowance for the caller of at least \n     * `subtractedValue`. \n     */ \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { \n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue)); \n        return true; \n    } \n \n \n    /** \n     * @dev Moves tokens `amount` from `sender` to `recipient`. \n     * \n     * This is internal function is equivalent to {transfer}, and can be used to \n     * e.g. implement automatic token fees, slashing mechanisms, etc. \n     * \n     * Emits a {Transfer} event. \n     * \n     * Requirements: \n     * \n     * - `sender` cannot be the zero address. \n     * - `recipient` cannot be the zero address. \n     * - `sender` must have a balance of at least `amount`. \n     */ \n    function _transfer (address sender, address recipient, uint256 amount) internal { \n        require(sender != address(0), 'BEP20: transfer from the zero address'); \n        require(recipient != address(0), 'BEP20: transfer to the zero address'); \n \n        _balances[sender] = _balances[sender].sub(amount); \n        _balances[recipient] = _balances[recipient].add(amount); \n        emit Transfer(sender, recipient, amount); \n    } \n \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function _burn(address account, uint256 amount) internal { \n        require(account != address(0), 'BEP20: burn from the zero address'); \n \n        _balances[account] = _balances[account].sub(amount); \n        _totalSupply = _totalSupply.sub(amount); \n        emit Transfer(account, address(0), amount); \n    } \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens. \nContext.sol\nIBEP20.sol\n     * \n     * This is internal function is equivalent to `approve`, and can be used to \n     * e.g. set automatic allowances for certain subsystems, etc. \n     * \n     * Emits an {Approval} event. \n     * \n     * Requirements: \n     * \n     * - `owner` cannot be the zero address. \n     * - `spender` cannot be the zero address. \n     */ \n    function _approve (address owner, address spender, uint256 amount) internal { \n        require(owner != address(0), 'BEP20: approve from the zero address'); \n        require(spender != address(0), 'BEP20: approve to the zero address'); \n \n        _allowances[owner][spender] = amount; \n        emit Approval(owner, spender, amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted \n     * from the caller's allowance. \n     * \n     * See {_burn} and {_approve}. \n     */ \n    function _burnFrom(address account, uint256 amount) internal { \n        _burn(account, amount); \n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount)); \n    } \n}\n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n}\n \n",
            "pragma solidity >=0.6.4; \n \ninterface IBEP20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the token decimals. \n     */ \n    function decimals() external view returns (uint8); \n \n    /** \n     * @dev Returns the token symbol. \n     */ \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the token name. \n     */ \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the bep token owner. \n     */ \n    function getOwner() external view returns (address); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address _owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \nOwnable.sol\n \n",
            "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n}\n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n}\nSafeMath.sol\n \n",
            "pragma solidity 0.6.12; \n \n/** \n * @title SafeMath \n * @dev Unsigned math operations with safety checks that revert on error \n */ \n \nlibrary SafeMath { \n    /** \n     * @dev Multiplies two unsigned integers, reverts on overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b); \n \nZooToken.sol\n \n",
            "pragma solidity 0.6.12; \n \n// \n// \n//                    \u250c\u2500\u2510       \u250c\u2500\u2510 + + \n//                    \u250c\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2510++ \n//                    \u2502                 \u2502 \n//                    \u2502       \u2500\u2500\u2500       \u2502++ + + + \n//                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502+ \n//                    \u2502                 \u2502+ \n//                    \u2502       \u2500\u2534\u2500       \u2502 \n//                    \u2502                 \u2502 \n//                    \u2514\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2518 \n//                    \u2502         \u2502 \n        return c; \n    } \n \n    /** \n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Adds two unsigned integers, reverts on overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a); \n \n        return c; \n    } \n \n    /** \n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo), \n     * reverts when dividing by zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b != 0); \n        return a % b; \n    } \n}\n//                    \u2502         \u2502   + + \n//                    \u2502         \u2502 \n//                    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n//                    \u2502                        \u2502 \n//                    \u2502                        \u251c\u2500\u2510 \n//                    \u2502                        \u250c\u2500\u2518 \n//                    \u2502                        \u2502 \n//                    \u2514\u2500\u2510  \u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2510  \u250c\u2500\u2500\u2518  + + + + \n//                    \u2502 \u2500\u2524 \u2500\u2524       \u2502 \u2500\u2524 \u2500\u2524 \n//                    \u2514\u2500\u2500\u2534\u2500\u2500\u2518       \u2514\u2500\u2500\u2534\u2500\u2500\u2518  + + + + \n \n \nimport \"./BEP20.sol\"; \n \ncontract ZooToken is BEP20('Zoo', 'ZOO', 100000000000000000000000000000) { \n \n \nfunction getChainId() internal pure returns (uint) { \nuint256 chainId; \nassembly { chainId := chainid() } \nreturn chainId; \n} \n}\n"
        ]
    }
]