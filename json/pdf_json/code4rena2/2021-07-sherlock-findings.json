[
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\npragma abicoder v2;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '../interfaces/IPoolBase.sol';\n\nimport '../storage/GovStorage.sol';\n\nimport '../libraries/LibPool.sol';\n\ncontract PoolBase is IPoolBase {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ILock;\n\n  //\n  // View methods\n  //\n\n  function getCooldownFee(IERC20 _token) external view override returns (uint32) {\n    return baseData().activateCooldownFee;\n  }\n\n  function getSherXWeight(IERC20 _token) external view override returns (uint16) {\n    return baseData().sherXWeight;\n  }\n\n  function getGovPool(IERC20 _token) external view override returns (address) {\n    return baseData().govPool;\n  }\n\n  function isPremium(IERC20 _token) external view override returns (bool) {\n    return baseData().premiums;\n  }\n\n  function isStake(IERC20 _token) external view override returns (bool) {\n    return baseData().stakes;\n  }\n\n  function getProtocolBalance(bytes32 _protocol, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return baseData().protocolBalance[_protocol];\n  }\n\n  function getProtocolPremium(bytes32 _protocol, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return baseData().protocolPremium[_protocol];\n  }\n\n  function getLockToken(IERC20 _token) external view override returns (ILock) {\n    return baseData().lockToken;\n  }\n\n  function isProtocol(bytes32 _protocol, IERC20 _token) external view override returns (bool) {\n    return baseData().isProtocol[_protocol];\n  }\n\n  function getProtocols(IERC20 _token) external view override returns (bytes32[] memory) {\n    return baseData().protocols;\n  }\n\n  function getUnstakeEntry(\n    address _staker,\n    uint256 _id,\n    IERC20 _token\n  ) external view override returns (PoolStorage.UnstakeEntry memory) {\n    return baseData().unstakeEntries[_staker][_id];\n  }\n\n  function getTotalAccruedDebt(IERC20 _token) external view override returns (uint256) {\n    baseData();\n    return LibPool.getTotalAccruedDebt(_token);\n  }\n\n  function getFirstMoneyOut(IERC20 _token) external view override returns (uint256) {\n    return baseData().firstMoneyOut;\n  }\n\n  function getAccruedDebt(bytes32 _protocol, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    baseData();\n    return LibPool.accruedDebt(_protocol, _token);\n  }\n\n  function getTotalPremiumPerBlock(IERC20 _token) external view override returns (uint256) {\n    return baseData().totalPremiumPerBlock;\n  }\n\n  function getPremiumLastPaid(IERC20 _token) external view override returns (uint40) {\n    return baseData().totalPremiumLastPaid;\n  }\n\n  function getSherXUnderlying(IERC20 _token) external view override returns (uint256) {\n    return baseData().sherXUnderlying;\n  }\n\n  function getUnstakeEntrySize(address _staker, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return baseData().unstakeEntries[_staker].length;\n  }\n\n  function getInitialUnstakeEntry(address _staker, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    PoolStorage.Base storage ps = baseData();\n    GovStorage.Base storage gs = GovStorage.gs();\n    for (uint256 i = 0; i < ps.unstakeEntries[_staker].length; i++) {\n      if (ps.unstakeEntries[_staker][i].blockInitiated == 0) {\n        continue;\n      }\n      if (\n        ps.unstakeEntries[_staker][i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <=\n        uint40(block.number)\n      ) {\n        continue;\n      }\n      return i;\n    }\n    return ps.unstakeEntries[_staker].length;\n  }\n\n  function getUnactivatedStakersPoolBalance(IERC20 _token) public view override returns (uint256) {\n    return baseData().stakeBalance;\n  }\n\n  function getStakersPoolBalance(IERC20 _token) public view override returns (uint256) {\n    return LibPool.stakeBalance(baseData());\n  }\n\n  function getStakerPoolBalance(address _staker, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    PoolStorage.Base storage ps = baseData();\n    if (ps.lockToken.totalSupply() == 0) {\n      return 0;\n    }\n    return\n      ps.lockToken.balanceOf(_staker).mul(getStakersPoolBalance(_token)).div(\n        ps.lockToken.totalSupply()\n      );\n  }\n\n  function getTotalUnmintedSherX(IERC20 _token) public view override returns (uint256) {\n    baseData();\n    return LibPool.getTotalUnmintedSherX(_token);\n  }\n\n  function getUnallocatedSherXStored(IERC20 _token) public view override returns (uint256) {\n    return baseData().unallocatedSherX;\n  }\n\n  function getUnallocatedSherXTotal(IERC20 _token) external view override returns (uint256) {\n    return getUnallocatedSherXStored(_token).add(LibPool.getTotalUnmintedSherX(_token));\n  }\n\n  function getUnallocatedSherXFor(address _user, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    baseData();\n    return LibPool.getUnallocatedSherXFor(_user, _token);\n  }\n\n  function getTotalSherXPerBlock(IERC20 _token) public view override returns (uint256) {\n    return SherXStorage.sx().sherXPerBlock.mul(baseData().sherXWeight).div(uint16(-1));\n  }\n\n  function getSherXPerBlock(IERC20 _token) external view override returns (uint256) {\n    return getSherXPerBlock(msg.sender, _token);\n  }\n\n  function getSherXPerBlock(address _user, IERC20 _token) public view override returns (uint256) {\n    PoolStorage.Base storage ps = baseData();\n    if (ps.lockToken.totalSupply() == 0) {\n      return 0;\n    }\n    return\n      getTotalSherXPerBlock(_token).mul(ps.lockToken.balanceOf(_user)).div(\n        ps.lockToken.totalSupply()\n      );\n  }\n\n  function getSherXPerBlock(uint256 _lock, IERC20 _token) external view override returns (uint256) {\n    // simulates staking (adding lock)\n    return\n      getTotalSherXPerBlock(_token).mul(_lock).div(baseData().lockToken.totalSupply().add(_lock));\n  }\n\n  function getSherXLastAccrued(IERC20 _token) external view override returns (uint40) {\n    return baseData().sherXLastAccrued;\n  }\n\n  function LockToTokenXRate(IERC20 _token) external view override returns (uint256) {\n    return LockToToken(10**18, _token);\n  }\n\n  function LockToToken(uint256 _amount, IERC20 _token) public view override returns (uint256) {\n    PoolStorage.Base storage ps = baseData();\n    uint256 balance = LibPool.stakeBalance(ps);\n    uint256 totalLock = ps.lockToken.totalSupply();\n    if (totalLock == 0 || balance == 0) {\n      revert('NO_DATA');\n    }\n    return balance.mul(_amount).div(totalLock);\n  }\n\n  function TokenToLockXRate(IERC20 _token) external view override returns (uint256) {\n    return TokenToLock(10**18, _token);\n  }\n\n  function TokenToLock(uint256 _amount, IERC20 _token) public view override returns (uint256) {\n    PoolStorage.Base storage ps = baseData();\n    uint256 balance = LibPool.stakeBalance(ps);\n    uint256 totalLock = ps.lockToken.totalSupply();\n    if (totalLock == 0 || balance == 0) {\n      return 10**18;\n    }\n    return totalLock.mul(_amount).div(balance);\n  }\n\n  //\n  // State changing methods\n  //\n\n  function setCooldownFee(uint32 _fee, IERC20 _token) external override {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n\n    baseData().activateCooldownFee = _fee;\n  }\n\n  function depositProtocolBalance(\n    bytes32 _protocol,\n    uint256 _amount,\n    IERC20 _token\n  ) external override {\n    require(_amount > 0, 'AMOUNT');\n    require(GovStorage.gs().protocolIsCovered[_protocol], 'PROTOCOL');\n    PoolStorage.Base storage ps = baseData();\n    require(ps.isProtocol[_protocol], 'NO_DEPOSIT');\n\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n    ps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].add(_amount);\n  }\n\n  function withdrawProtocolBalance(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    IERC20 _token\n  ) external override {\n    require(msg.sender == GovStorage.gs().protocolAgents[_protocol], 'SENDER');\n    require(_amount > 0, 'AMOUNT');\n    require(_receiver != address(0), 'RECEIVER');\n    PoolStorage.Base storage ps = baseData();\n\n    LibPool.payOffDebtAll(_token);\n\n    if (_amount == uint256(-1)) {\n      _amount = ps.protocolBalance[_protocol];\n    }\n\n    _token.safeTransfer(_receiver, _amount);\n    ps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].sub(_amount);\n  }\n\n  function activateCooldown(uint256 _amount, IERC20 _token) external override returns (uint256) {\n    require(_amount > 0, 'AMOUNT');\n    PoolStorage.Base storage ps = baseData();\n\n    ps.lockToken.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 fee = _amount.mul(ps.activateCooldownFee).div(uint32(-1));\n    if (fee > 0) {\n      // stake of user gets burned\n      // representative amount token get added to first money out pool\n      uint256 tokenAmount = fee.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());\n      ps.firstMoneyOut = ps.firstMoneyOut.add(tokenAmount);\n\n      ps.lockToken.burn(address(this), fee);\n    }\n\n    ps.unstakeEntries[msg.sender].push(\n      PoolStorage.UnstakeEntry(uint40(block.number), _amount.sub(fee))\n    );\n\n    return ps.unstakeEntries[msg.sender].length - 1;\n  }\n\n  function cancelCooldown(uint256 _id, IERC20 _token) external override {\n    PoolStorage.Base storage ps = baseData();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];\n    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n\n    require(\n      withdraw.blockInitiated + gs.unstakeCooldown >= uint40(block.number),\n      'COOLDOWN_EXPIRED'\n    );\n    delete ps.unstakeEntries[msg.sender][_id];\n    ps.lockToken.safeTransfer(msg.sender, withdraw.lock);\n  }\n\n  function unstakeWindowExpiry(\n    address _account,\n    uint256 _id,\n    IERC20 _token\n  ) external override {\n    PoolStorage.Base storage ps = baseData();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[_account][_id];\n    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n\n    require(\n      withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow < uint40(block.number),\n      'UNSTAKE_WINDOW_NOT_EXPIRED'\n    );\n    delete ps.unstakeEntries[_account][_id];\n    ps.lockToken.safeTransfer(_account, withdraw.lock);\n  }\n\n  function unstake(\n    uint256 _id,\n    address _receiver,\n    IERC20 _token\n  ) external override returns (uint256 amount) {\n    PoolStorage.Base storage ps = baseData();\n    require(_receiver != address(0), 'RECEIVER');\n    GovStorage.Base storage gs = GovStorage.gs();\n    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];\n    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n    // period is including\n    require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');\n    require(\n      withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow >= uint40(block.number),\n      'UNSTAKE_WINDOW_EXPIRED'\n    );\n    amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());\n\n    ps.stakeBalance = ps.stakeBalance.sub(amount);\n    delete ps.unstakeEntries[msg.sender][_id];\n    ps.lockToken.burn(address(this), withdraw.lock);\n    _token.safeTransfer(_receiver, amount);\n  }\n\n  function payOffDebtAll(IERC20 _token) external override {\n    baseData();\n    LibPool.payOffDebtAll(_token);\n  }\n\n  function cleanProtocol(\n    bytes32 _protocol,\n    uint256 _index,\n    bool _forceDebt,\n    address _receiver,\n    IERC20 _token\n  ) external override {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    require(_receiver != address(0), 'RECEIVER');\n\n    PoolStorage.Base storage ps = baseData();\n    require(ps.protocols[_index] == _protocol, 'INDEX');\n\n    // If protocol has 0 accrued debt, the premium should also be 0\n    // If protocol has >0 accrued debt, needs to be bigger then balance\n    // Otherwise just update premium to 0 for the protocol first and then delete\n    uint256 accrued = LibPool.accruedDebt(_protocol, _token);\n    if (accrued == 0) {\n      require(ps.protocolPremium[_protocol] == 0, 'CAN_NOT_DELETE');\n    } else {\n      require(accrued > ps.protocolBalance[_protocol], 'CAN_NOT_DELETE2');\n    }\n\n    // send the remainder of the protocol balance to the sherx underlying\n    if (_forceDebt && accrued > 0) {\n      ps.sherXUnderlying = ps.sherXUnderlying.add(ps.protocolBalance[_protocol]);\n      delete ps.protocolBalance[_protocol];\n    }\n\n    // send any leftovers back to the protocol receiver\n    if (ps.protocolBalance[_protocol] > 0) {\n      _token.safeTransfer(_receiver, ps.protocolBalance[_protocol]);\n      delete ps.protocolBalance[_protocol];\n    }\n\n    // move last index to index of _protocol\n    ps.protocols[_index] = ps.protocols[ps.protocols.length - 1];\n    // remove last index\n    ps.protocols.pop();\n    ps.isProtocol[_protocol] = false;\n    // could still be >0, if accrued more debt than needed.\n    if (ps.protocolPremium[_protocol] > 0) {\n      ps.totalPremiumPerBlock = ps.totalPremiumPerBlock.sub(ps.protocolPremium[_protocol]);\n      delete ps.protocolPremium[_protocol];\n    }\n  }\n\n  function baseData() internal view returns (PoolStorage.Base storage ps) {\n    ps = PoolStorage.ps(bps());\n    require(ps.govPool != address(0), 'INVALID_TOKEN');\n  }\n\n  function bps() internal pure returns (IERC20 rt) {\n    // These fields are not accessible from assembly\n    bytes memory array = msg.data;\n    uint256 index = msg.data.length;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n      rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "PoolBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PoolBase.sol line 271",
                "Type": "Incorrect internal balance bookkeeping",
                "Description": "An attacker can perform stake and deposit actions without actually depositing the amount that sherlock assumes.",
                "Repair": "Require the amount to be added to the contract's balance or update the pool based on actual balance changes"
            },
            {
                "Location": "PoolBase.sol line 271",
                "Type": "Bug",
                "Description": "A malicious user can inject extra values at the end of calldata and fake return values.",
                "Repair": "Fix all the places where the same pattern is used"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\nimport '../interfaces/IGovDev.sol';\n\ncontract GovDev is IGovDev {\n  function getGovDev() external view override returns (address) {\n    return LibDiamond.contractOwner();\n  }\n\n  function transferGovDev(address _govDev) external override {\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    require(_govDev != LibDiamond.contractOwner(), 'SAME_DEV');\n    LibDiamond.setContractOwner(_govDev);\n  }\n\n  function updateSolution(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) external override {\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    return LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n  }\n}\n\n\n",
        "CodeNames": [
            "GovDev.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GovDev.sol line 25",
                "Type": "Reputation risks with updateSolution",
                "Description": "Via updateSolution, any functionality can be changed and all the funds can be accessed/rugged.",
                "Repair": "Apply extra safeguards, for example, limit the time period where updateSolution can be used"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.1;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n\n* Inspired by: https://github.com/pie-dao/PieVaults/blob/master/contracts/facets/ERC20/ERC20Facet.sol\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\nimport '../interfaces/ISherXERC20.sol';\n\nimport '../libraries/LibSherXERC20.sol';\n\ncontract SherXERC20 is IERC20, ISherXERC20 {\n  using SafeMath for uint256;\n\n  //\n  // View methods\n  //\n\n  function name() external view override returns (string memory) {\n    return SherXERC20Storage.sx20().name;\n  }\n\n  function symbol() external view override returns (string memory) {\n    return SherXERC20Storage.sx20().symbol;\n  }\n\n  function decimals() external pure override returns (uint8) {\n    return 18;\n  }\n\n  function allowance(address _owner, address _spender) external view override returns (uint256) {\n    return SherXERC20Storage.sx20().allowances[_owner][_spender];\n  }\n\n  function balanceOf(address _of) external view override returns (uint256) {\n    return SherXERC20Storage.sx20().balances[_of];\n  }\n\n  function totalSupply() external view override returns (uint256) {\n    return SherXERC20Storage.sx20().totalSupply;\n  }\n\n  //\n  // State changing methods\n  //\n\n  function initializeSherXERC20(string memory _name, string memory _symbol) external override {\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n\n    require(bytes(_name).length != 0, 'NAME');\n    require(bytes(_symbol).length != 0, 'SYMBOL');\n\n    sx20.name = _name;\n    sx20.symbol = _symbol;\n  }\n\n  function increaseApproval(address _spender, uint256 _amount) external override returns (bool) {\n    require(_spender != address(0), 'SPENDER');\n    require(_amount != 0, 'AMOUNT');\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n    sx20.allowances[msg.sender][_spender] = sx20.allowances[msg.sender][_spender].add(_amount);\n    emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint256 _amount) external override returns (bool) {\n    require(_spender != address(0), 'SPENDER');\n    require(_amount != 0, 'AMOUNT');\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n    uint256 oldValue = sx20.allowances[msg.sender][_spender];\n    if (_amount > oldValue) {\n      sx20.allowances[msg.sender][_spender] = 0;\n    } else {\n      sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount);\n    }\n    emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]);\n    return true;\n  }\n\n  function approve(address _spender, uint256 _amount) external override returns (bool) {\n    require(_spender != address(0), 'SPENDER');\n    emit Approval(msg.sender, _spender, _amount);\n    return LibSherXERC20.approve(msg.sender, _spender, _amount);\n  }\n\n  function transfer(address _to, uint256 _amount) external override returns (bool) {\n    _transfer(msg.sender, _to, _amount);\n    return true;\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external override returns (bool) {\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n    require(_from != address(0), 'FROM');\n\n    // Update approval if not set to max uint256\n    if (sx20.allowances[_from][msg.sender] != uint256(-1)) {\n      uint256 newApproval = sx20.allowances[_from][msg.sender].sub(_amount);\n      sx20.allowances[_from][msg.sender] = newApproval;\n      emit Approval(_from, msg.sender, newApproval);\n    }\n\n    _transfer(_from, _to, _amount);\n    return true;\n  }\n\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal {\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n\n    sx20.balances[_from] = sx20.balances[_from].sub(_amount);\n    sx20.balances[_to] = sx20.balances[_to].add(_amount);\n\n    emit Transfer(_from, _to, _amount);\n  }\n}\n\n\n",
        "CodeNames": [
            "SherXERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SherXERC20.payOffDebtAll function",
                "Type": "Single under-funded protocol can break paying off debt",
                "Description": "If a single project does not have enough funds to cover the premium payments, the transactions come to a halt.",
                "Repair": "Add a rule in the withdrawProtocolBalance to only allow withdrawals with at least 2 days of remaining balance"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_doSherX function",
                "Type": "_doSherX optimistically assumes premiums will be paid",
                "Description": "The amounts array is an optimistic view assuming all outstanding, accrued premiums would indeed be paid until now.",
                "Repair": "Attempt to pay off the accrued premiums for all tokens, not just the ones that would otherwise revert the tx"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '../interfaces/ISherX.sol';\n\nimport '../storage/SherXERC20Storage.sol';\n\nimport '../libraries/LibPool.sol';\nimport '../libraries/LibSherX.sol';\nimport '../libraries/LibSherXERC20.sol';\n\ncontract SherX is ISherX {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //\n  // Modifiers\n  //\n\n  modifier onlyGovMain() {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    _;\n  }\n\n  //\n  // View methods\n  //\n\n  function getTotalUsdPerBlock() external view override returns (uint256) {\n    return SherXStorage.sx().totalUsdPerBlock;\n  }\n\n  function getTotalUsdPoolStored() external view override returns (uint256) {\n    return SherXStorage.sx().totalUsdPool;\n  }\n\n  function getTotalUsdPool() external view override returns (uint256) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    return sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));\n  }\n\n  function getTotalUsdLastSettled() external view override returns (uint256) {\n    return SherXStorage.sx().totalUsdLastSettled;\n  }\n\n  function getStoredUsd(IERC20 _token) external view override returns (uint256) {\n    return SherXStorage.sx().tokenUSD[_token];\n  }\n\n  function getUnmintedSherX(IERC20 _token) internal view returns (uint256) {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    SherXStorage.Base storage sx = SherXStorage.sx();\n\n    return\n      block.number.sub(ps.sherXLastAccrued).mul(sx.sherXPerBlock).mul(ps.sherXWeight).div(\n        uint16(-1)\n      );\n  }\n\n  function getTotalSherXUnminted() external view override returns (uint256) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    uint256 total =\n      block\n        .number\n        .sub(gs.watsonsSherxLastAccrued)\n        .mul(sx.sherXPerBlock)\n        .mul(gs.watsonsSherxWeight)\n        .div(uint16(-1));\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      total = total.add(getUnmintedSherX(gs.tokensStaker[i]));\n    }\n    return total;\n  }\n\n  function getTotalSherX() external view override returns (uint256) {\n    return LibSherX.getTotalSherX();\n  }\n\n  function getSherXPerBlock() external view override returns (uint256) {\n    return SherXStorage.sx().sherXPerBlock;\n  }\n\n  function getSherXBalance() external view override returns (uint256) {\n    return getSherXBalance(msg.sender);\n  }\n\n  function getSherXBalance(address _user) public view override returns (uint256) {\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n    uint256 balance = sx20.balances[_user];\n    GovStorage.Base storage gs = GovStorage.gs();\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      balance = balance.add(LibPool.getUnallocatedSherXFor(_user, gs.tokensStaker[i]));\n    }\n    return balance;\n  }\n\n  function getInternalTotalSupply() external view override returns (uint256) {\n    return SherXStorage.sx().internalTotalSupply;\n  }\n\n  function getInternalTotalSupplySettled() external view override returns (uint256) {\n    return SherXStorage.sx().internalTotalSupplySettled;\n  }\n\n  function calcUnderlying()\n    external\n    view\n    override\n    returns (IERC20[] memory tokens, uint256[] memory amounts)\n  {\n    return calcUnderlying(msg.sender);\n  }\n\n  function calcUnderlying(address _user)\n    public\n    view\n    override\n    returns (IERC20[] memory tokens, uint256[] memory amounts)\n  {\n    return LibSherX.calcUnderlying(getSherXBalance(_user));\n  }\n\n  function calcUnderlying(uint256 _amount)\n    external\n    view\n    override\n    returns (IERC20[] memory tokens, uint256[] memory amounts)\n  {\n    return LibSherX.calcUnderlying(_amount);\n  }\n\n  function calcUnderlyingInStoredUSD() external view override returns (uint256) {\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n    return calcUnderlyingInStoredUSD(sx20.balances[msg.sender]);\n  }\n\n  function calcUnderlyingInStoredUSD(uint256 _amount) public view override returns (uint256 usd) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    uint256 total = LibSherX.getTotalSherX();\n    if (total == 0) {\n      return 0;\n    }\n    for (uint256 i; i < gs.tokensSherX.length; i++) {\n      IERC20 token = gs.tokensSherX[i];\n\n      usd = usd.add(\n        PoolStorage\n          .ps(token)\n          .sherXUnderlying\n          .add(LibPool.getTotalAccruedDebt(token))\n          .mul(_amount)\n          .mul(sx.tokenUSD[token])\n          .div(10**18)\n          .div(total)\n      );\n    }\n  }\n\n  //\n  // State changing methods\n  //\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) external override {\n    doYield(ILock(msg.sender), from, to, amount);\n  }\n\n  function setInitialWeight() external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(gs.watsonsAddress != address(0), 'WATS_UNSET');\n    require(gs.watsonsSherxWeight == 0, 'ALREADY_INIT');\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);\n      require(ps.sherXWeight == 0, 'ALREADY_INIT_2');\n    }\n\n    gs.watsonsSherxWeight = uint16(-1);\n  }\n\n  function setWeights(\n    IERC20[] memory _tokens,\n    uint256[] memory _weights,\n    uint256 _watsons\n  ) external override onlyGovMain {\n    require(_tokens.length == _weights.length, 'LENGTH');\n    // NOTE: can potentially be made more gas efficient\n    // Do not loop over all staker tokens\n    // But just over the tokens in the _tokens array\n    LibSherX.accrueSherX();\n\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    uint256 weightAdd;\n    uint256 weightSub;\n\n    for (uint256 i; i < _tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(_tokens[i]);\n      // Disabled tokens can not have ps.sherXWeight > 0\n      require(ps.stakes, 'DISABLED');\n\n      weightAdd = weightAdd.add(_weights[i]);\n      weightSub = weightSub.add(ps.sherXWeight);\n      ps.sherXWeight = uint16(_weights[i]);\n    }\n    if (_watsons != uint256(-1)) {\n      weightAdd = weightAdd.add(_watsons);\n      weightSub = weightSub.add(gs.watsonsSherxWeight);\n\n      gs.watsonsSherxWeight = uint16(_watsons);\n    }\n\n    require(weightAdd == weightSub, 'SUM');\n  }\n\n  function harvest() external override {\n    harvestFor(msg.sender);\n  }\n\n  function harvest(ILock _token) external override {\n    harvestFor(msg.sender, _token);\n  }\n\n  function harvest(ILock[] calldata _tokens) external override {\n    for (uint256 i; i < _tokens.length; i++) {\n      harvestFor(msg.sender, _tokens[i]);\n    }\n  }\n\n  function harvestFor(address _user) public override {\n    GovStorage.Base storage gs = GovStorage.gs();\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);\n      harvestFor(_user, ps.lockToken);\n    }\n  }\n\n  function harvestFor(address _user, ILock _token) public override {\n    // could potentially call harvest function for token that are not in the pool\n    // if balance > 0, tx will revert\n    uint256 stakeBalance = _token.balanceOf(_user);\n    if (stakeBalance > 0) {\n      doYield(_token, _user, _user, 0);\n    }\n    emit Harvest(_user, _token);\n  }\n\n  function harvestFor(address _user, ILock[] calldata _tokens) external override {\n    for (uint256 i; i < _tokens.length; i++) {\n      harvestFor(_user, _tokens[i]);\n    }\n  }\n\n  function redeem(uint256 _amount, address _receiver) external override {\n    require(_amount > 0, 'AMOUNT');\n    require(_receiver != address(0), 'RECEIVER');\n\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    LibSherX.accrueUSDPool();\n\n    // Note: LibSherX.accrueSherX() is removed as the calcUnderlying already takes it into consideration (without changing state)\n    // Calculate the current `amounts` of underlying `tokens` for `_amount` of SherX\n    (IERC20[] memory tokens, uint256[] memory amounts) = LibSherX.calcUnderlying(_amount);\n    LibSherXERC20.burn(msg.sender, _amount);\n\n    uint256 subUsdPool = 0;\n    for (uint256 i; i < tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(tokens[i]);\n\n      // Expensive operation, only execute to prevent tx reverts\n      if (amounts[i] > ps.sherXUnderlying) {\n        LibPool.payOffDebtAll(tokens[i]);\n      }\n      // Remove the token as underlying of SherX\n      ps.sherXUnderlying = ps.sherXUnderlying.sub(amounts[i]);\n      // As the tokens are transferred, remove from the current usdPool\n      // By summing the total that needs to be deducted in the `subUsdPool` value\n      subUsdPool = subUsdPool.add(amounts[i].mul(sx.tokenUSD[tokens[i]]).div(10**18));\n\n      tokens[i].safeTransfer(_receiver, amounts[i]);\n    }\n    sx.totalUsdPool = sx.totalUsdPool.sub(subUsdPool);\n    LibSherX.settleInternalSupply(_amount);\n  }\n\n  function accrueSherX() external override {\n    LibSherX.accrueSherX();\n  }\n\n  function accrueSherX(IERC20 _token) external override {\n    LibSherX.accrueSherX(_token);\n  }\n\n  function accrueSherXWatsons() external override {\n    LibSherX.accrueSherXWatsons();\n  }\n\n  function doYield(\n    ILock token,\n    address from,\n    address to,\n    uint256 amount\n  ) private {\n    IERC20 underlying = token.underlying();\n    PoolStorage.Base storage ps = PoolStorage.ps(underlying);\n    require(ps.lockToken == token, 'SENDER');\n\n    LibSherX.accrueSherX(underlying);\n    uint256 userAmount = ps.lockToken.balanceOf(from);\n    uint256 totalAmount = ps.lockToken.totalSupply();\n\n    uint256 ineglible_yield_amount;\n    if (totalAmount > 0) {\n      ineglible_yield_amount = ps.sWeight.mul(amount).div(totalAmount);\n    } else {\n      ineglible_yield_amount = amount;\n    }\n\n    if (from != address(0)) {\n      uint256 raw_amount = ps.sWeight.mul(userAmount).div(totalAmount);\n      uint256 withdrawable_amount = raw_amount.sub(ps.sWithdrawn[from]);\n      if (withdrawable_amount > 0) {\n        // store the data in a single calc\n        ps.sWithdrawn[from] = raw_amount.sub(ineglible_yield_amount);\n        // The `withdrawable_amount` is allocated to `from`, subtract from `unallocatedSherX`\n        ps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);\n        PoolStorage.Base storage psSherX = PoolStorage.ps(IERC20(address(this)));\n        if (from == address(this)) {\n          // add SherX harvested by the pool itself to first money out pool.\n          psSherX.stakeBalance = psSherX.stakeBalance.add(withdrawable_amount);\n          psSherX.firstMoneyOut = psSherX.firstMoneyOut.add(withdrawable_amount);\n        } else {\n          LibPool.stake(psSherX, withdrawable_amount, from);\n        }\n      } else {\n        ps.sWithdrawn[from] = ps.sWithdrawn[from].sub(ineglible_yield_amount);\n      }\n    } else {\n      ps.sWeight = ps.sWeight.add(ineglible_yield_amount);\n    }\n\n    if (to != address(0)) {\n      ps.sWithdrawn[to] = ps.sWithdrawn[to].add(ineglible_yield_amount);\n    } else {\n      ps.sWeight = ps.sWeight.sub(ineglible_yield_amount);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "SherX.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SherX.sol line 309",
                "Type": "Yield distribution after large payout seems unfair",
                "Description": "When a large payout occurs, it will lower unallocatedSherX. The first couple of users will be able to get their full Yield, until the moment unallocatedSherX is depleted. The next users don't get any yield at all.",
                "Repair": "If unallocatedSherX is insufficient to provide for all the yields, only give the yields partly (so that each user gets their fair share)"
            }
        ]
    }
]