[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarDepositService } from '../interfaces/IAxelarDepositService.sol';\n\ncontract DepositReceiver {\n    constructor(bytes memory delegateData) {\n        // Reading the implementation of the AxelarDepositService\n        // and delegating the call back to it\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = IAxelarDepositService(msg.sender).receiverImplementation().delegatecall(delegateData);\n\n        // if not success revert with the original revert data\n        if (!success) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n\n        selfdestruct(payable(msg.sender));\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "DepositReceiver.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "DepositReceiver.sol#L25",
                "Type": "System will not work anymore after EIP-4758",
                "Description": "After EIP-4758, the SELFDESTRUCT op code will no longer be available. According to the EIP, 'The only use that breaks is where a contract is re-created at the same address using CREATE2 (after a SELFDESTRUCT)'. Axelar is exactly such an application, the current deposit system will no longer work.",
                "Repair": "Instead of generating addresses for every user, the user could directly interact with the deposit service and the deposit service would need to keep track of funds and provide refunds directly."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { AxelarExecutable } from '@axelar-network/axelar-utils-solidity/contracts/executables/AxelarExecutable.sol';\nimport { IAxelarGateway } from '@axelar-network/axelar-utils-solidity/contracts/interfaces/IAxelarGateway.sol';\nimport './Upgradable.sol';\nimport { LocalAsset } from './interfaces/LocalAsset.sol';\n\ncontract XC20Wrapper is AxelarExecutable, Upgradable {\n    error TransferFailed();\n    error NotAxelarToken();\n    error NotXc20Token();\n    error InsufficientBalance();\n    error AlreadyWrappingAxelarToken();\n    error AlreadyWrappingXC20Token();\n    error NotOwnerOfXc20();\n\n    mapping(address => address) public wrapped;\n    mapping(address => address) public unwrapped;\n\n    bytes32 public xc20Codehash;\n    address public immutable gatewayAddress;\n\n    constructor(address gatewayAddress_) {\n        gatewayAddress = gatewayAddress_;\n    }\n\n    function gateway() public view override returns (IAxelarGateway) {\n        return IAxelarGateway(gatewayAddress);\n    }\n\n    function _setup(bytes calldata data) internal override {\n        (address owner_, bytes32 codehash_) = abi.decode(data, (address, bytes32));\n        _transferOwnership(owner_);\n        xc20Codehash = codehash_;\n    }\n\n    function contractId() public pure returns (bytes32) {\n        return keccak256('xc20-wrapper');\n    }\n\n    function setXc20Codehash(bytes32 newCodehash) external onlyOwner {\n        xc20Codehash = newCodehash;\n    }\n\n    function addWrapping(\n        string calldata symbol,\n        address xc20Token,\n        string memory newName,\n        string memory newSymbol\n    ) external payable onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        if (xc20Token.codehash != xc20Codehash) revert('NotXc20Token()');\n        if (wrapped[axelarToken] != address(0)) revert('AlreadyWrappingAxelarToken()');\n        if (unwrapped[xc20Token] != address(0)) revert('AlreadyWrappingXC20Token()');\n        wrapped[axelarToken] = xc20Token;\n        unwrapped[xc20Token] = axelarToken;\n        if (!LocalAsset(xc20Token).set_team(address(this), address(this), address(this))) revert('NotOwner()');\n        if (!LocalAsset(xc20Token).set_metadata(newName, newSymbol, IERC20(axelarToken).decimals())) revert('CannotSetMetadata()');\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function removeWrapping(string calldata symbol) external onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        address xc20Token = wrapped[axelarToken];\n        if (xc20Token == address(0)) revert('NotWrappingToken()');\n        wrapped[axelarToken] = address(0);\n        unwrapped[xc20Token] = address(0);\n    }\n\n    function wrap(address axelarToken, uint256 amount) external {\n        _safeTransferFrom(axelarToken, msg.sender, amount);\n        address wrappedToken = wrapped[axelarToken];\n        if (wrappedToken == address(0)) revert('NotAxelarToken()');\n        if (!LocalAsset(wrappedToken).mint(msg.sender, amount)) revert('CannotMint()');\n    }\n\n    function unwrap(address wrappedToken, uint256 amount) external {\n        address axelarToken = unwrapped[wrappedToken];\n        if (axelarToken == address(0)) revert('NotXc20Token()');\n        if (IERC20(wrappedToken).balanceOf(msg.sender) < amount) revert('InsufficientBalance()');\n        if (!LocalAsset(wrappedToken).burn(msg.sender, amount)) revert('CannotBurn()');\n        _safeTransfer(axelarToken, msg.sender, amount);\n    }\n\n    function _safeTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _safeTransferFrom(\n        address tokenAddress,\n        address from,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _executeWithToken(\n        string calldata,\n        string calldata,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal override {\n        address receiver = abi.decode(payload, (address));\n        address tokenAddress = gateway().tokenAddresses(tokenSymbol);\n        address xc20 = wrapped[tokenAddress];\n        if (xc20 == address(0) || !LocalAsset(xc20).mint(receiver, amount)) {\n            _safeTransfer(tokenAddress, receiver, amount);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "XC20Wrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "XC20Wrapper.sol#L66",
                "Type": "removeWrapping can be called when there are still wrapped tokens",
                "Description": "An owner can call removeWrapping, even if there are still circulating wrapped tokens. This will cause the unwrapping of those tokens to fail, as unwrapped[wrappedToken] will be addres(0).",
                "Repair": "Track how many wrapped tokens are in circulation, only allow the removal of a wrapped tokens when there are 0 to ensure for users that they will always be able to unwrap."
            },
            {
                "Location": "XC20Wrapper.sol#L124-L126",
                "Type": "XC20Wrapper may lose received token forever if LocalAsset(xc20).mint is reverted indefinitely",
                "Description": "XC20Wrapper may lose received token forever if LocalAsset(xc20).mint is reverted indefinitely. No matter how hard you retry the GMP message execution, it always fail thus the token get locked forever.",
                "Repair": "Use try catch"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    address internal immutable AUTH_MODULE;\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule, address tokenDeployerImplementation) {\n        if (authModule.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrancy\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintLimitKey(symbol));\n    }\n\n    function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));\n    }\n\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; ++i) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n        if (symbols.length != limits.length) revert InvalidSetDailyMintLimitsParams();\n\n        for (uint256 i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenDailyMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address[] memory adminAddresses, uint256 newAdminThreshold, bytes memory newOperatorsData) = abi.decode(\n            params,\n            (address[], uint256, bytes)\n        );\n\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        if (newOperatorsData.length > 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // TEST auth and getaway separately\n        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n            uint256 chainId_,\n            bytes32[] memory commandIds_,\n            string[] memory commands_,\n            bytes[] memory params_\n        ) {\n            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);\n        } catch {\n            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n        }\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!currentOperators) continue;\n\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 dailyMintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenDailyMintLimit(symbol, dailyMintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _unpackLegacyCommands(bytes memory executeData)\n        external\n        pure\n        returns (\n            uint256 chainId,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        )\n    {\n        (chainId, , commandIds, commands, params) = abi.decode(executeData, (uint256, uint256, bytes32[], string[], bytes[]));\n    }\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenDailyMintAmount(symbol, tokenDailyMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            bool success = _callERC20Token(tokenAddress, abi.encodeWithSelector(IERC20.transfer.selector, account, amount));\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenDailyMintLimitKey(symbol), limit);\n\n        emit TokenDailyMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenDailyMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);\n\n        _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGasService } from '../interfaces/IAxelarGasService.sol';\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport '../util/Upgradable.sol';\n\n// This should be owned by the microservice that is paying for gas.\ncontract AxelarGasService is Upgradable, IAxelarGasService {\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external override {\n        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);\n\n        emit GasPaidForContractCall(\n            sender,\n            destinationChain,\n            destinationAddress,\n            keccak256(payload),\n            gasToken,\n            gasFeeAmount,\n            refundAddress\n        );\n    }\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string memory symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external override {\n        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);\n\n        emit GasPaidForContractCallWithToken(\n            sender,\n            destinationChain,\n            destinationAddress,\n            keccak256(payload),\n            symbol,\n            amount,\n            gasToken,\n            gasFeeAmount,\n            refundAddress\n        );\n    }\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable override {\n        if (msg.value == 0) revert NothingReceived();\n\n        emit NativeGasPaidForContractCall(sender, destinationChain, destinationAddress, keccak256(payload), msg.value, refundAddress);\n    }\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable override {\n        if (msg.value == 0) revert NothingReceived();\n\n        emit NativeGasPaidForContractCallWithToken(\n            sender,\n            destinationChain,\n            destinationAddress,\n            keccak256(payload),\n            symbol,\n            amount,\n            msg.value,\n            refundAddress\n        );\n    }\n\n    function addGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external override {\n        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);\n\n        emit GasAdded(txHash, logIndex, gasToken, gasFeeAmount, refundAddress);\n    }\n\n    function addNativeGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable override {\n        if (msg.value == 0) revert NothingReceived();\n\n        emit NativeGasAdded(txHash, logIndex, msg.value, refundAddress);\n    }\n\n    function collectFees(address payable receiver, address[] calldata tokens) external onlyOwner {\n        if (receiver == address(0)) revert InvalidAddress();\n\n        for (uint256 i; i < tokens.length; i++) {\n            address token = tokens[i];\n\n            if (token == address(0)) {\n                uint256 amount = address(this).balance;\n                if (amount > 0) receiver.transfer(amount);\n            } else {\n                uint256 amount = IERC20(token).balanceOf(address(this));\n                if (amount > 0) _safeTransfer(token, receiver, amount);\n            }\n        }\n    }\n\n    function refund(\n        address payable receiver,\n        address token,\n        uint256 amount\n    ) external onlyOwner {\n        if (receiver == address(0)) revert InvalidAddress();\n\n        if (token == address(0)) {\n            receiver.transfer(amount);\n        } else {\n            _safeTransfer(token, receiver, amount);\n        }\n    }\n\n    function _safeTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount\n    ) internal {\n        if (amount == 0) revert NothingReceived();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\n    }\n\n    function _safeTransferFrom(\n        address tokenAddress,\n        address from,\n        uint256 amount\n    ) internal {\n        if (amount == 0) revert NothingReceived();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\n    }\n\n    function contractId() external pure returns (bytes32) {\n        return keccak256('axelar-gas-service');\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarGateway.sol",
            "AxelarGasService.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AxelarGateway.sol#L262, AxelarGasService.sol#L98, AxelarGasService.sol#L110",
                "Type": "Add cancel and refund option for Transaction Recovery",
                "Description": "Transactions could fail or get stuck, and there are several options provided, but some transactions' execution depend on the time or certain condition. For example, some transaction has a deadline, it the deadline is passed, the transaction will be invalid. Or some conditions may be temporary, for example, some certain price difference for some token pair. In this case, the failed transactions will be meaningless to redo, the appropriate method is to cancel the transaction and refund. If no such option is provided, users' fund for this transaction would be lock or loss.",
                "Repair": "Provide a cancel option if the transaction failed, from the source chain or destination chain, and allow the user to get the gas refund."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    address internal immutable AUTH_MODULE;\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule, address tokenDeployerImplementation) {\n        if (authModule.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrancy\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintLimitKey(symbol));\n    }\n\n    function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));\n    }\n\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; ++i) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {\n        if (symbols.length != limits.length) revert InvalidSetDailyMintLimitsParams();\n\n        for (uint256 i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenDailyMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address[] memory adminAddresses, uint256 newAdminThreshold, bytes memory newOperatorsData) = abi.decode(\n            params,\n            (address[], uint256, bytes)\n        );\n\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        if (newOperatorsData.length > 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // TEST auth and getaway separately\n        bool currentOperators = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        try AxelarGateway(this)._unpackLegacyCommands(data) returns (\n            uint256 chainId_,\n            bytes32[] memory commandIds_,\n            string[] memory commands_,\n            bytes[] memory params_\n        ) {\n            (chainId, commandIds, commands, params) = (chainId_, commandIds_, commands_, params_);\n        } catch {\n            (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n        }\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!currentOperators) continue;\n\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 dailyMintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenDailyMintLimit(symbol, dailyMintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _unpackLegacyCommands(bytes memory executeData)\n        external\n        pure\n        returns (\n            uint256 chainId,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        )\n    {\n        (chainId, , commandIds, commands, params) = abi.decode(executeData, (uint256, uint256, bytes32[], string[], bytes[]));\n    }\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenDailyMintAmount(symbol, tokenDailyMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            bool success = _callERC20Token(tokenAddress, abi.encodeWithSelector(IERC20.transfer.selector, account, amount));\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {\n        _setUint(_getTokenDailyMintLimitKey(symbol), limit);\n\n        emit TokenDailyMintLimitUpdated(symbol, limit);\n    }\n\n    function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {\n        uint256 limit = tokenDailyMintLimit(symbol);\n        if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);\n\n        _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);\n    }\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarAuthWeighted } from '../interfaces/IAxelarAuthWeighted.sol';\nimport { ECDSA } from '../ECDSA.sol';\nimport { Ownable } from '../Ownable.sol';\n\ncontract AxelarAuthWeighted is Ownable, IAxelarAuthWeighted {\n    uint256 public currentEpoch;\n    mapping(uint256 => bytes32) public hashForEpoch;\n    mapping(bytes32 => uint256) public epochForHash;\n\n    uint8 internal constant OLD_KEY_RETENTION = 16;\n\n    constructor(bytes[] memory recentOperators) {\n        for (uint256 i; i < recentOperators.length; ++i) {\n            _transferOperatorship(recentOperators[i]);\n        }\n    }\n\n    /**************************\\\n    |* External Functionality *|\n    \\**************************/\n\n    function validateProof(bytes32 messageHash, bytes calldata proof) external view returns (bool currentOperators) {\n        (address[] memory operators, uint256[] memory weights, uint256 threshold, bytes[] memory signatures) = abi.decode(\n            proof,\n            (address[], uint256[], uint256, bytes[])\n        );\n\n        bytes32 operatorsHash = keccak256(abi.encode(operators, weights, threshold));\n        uint256 operatorsEpoch = epochForHash[operatorsHash];\n        uint256 epoch = currentEpoch;\n\n        if (operatorsEpoch == 0 || epoch - operatorsEpoch >= OLD_KEY_RETENTION) revert InvalidOperators();\n\n        _validateSignatures(messageHash, operators, weights, threshold, signatures);\n\n        currentOperators = operatorsEpoch == epoch;\n    }\n\n    /***********************\\\n    |* Owner Functionality *|\n    \\***********************/\n\n    function transferOperatorship(bytes calldata params) external onlyOwner {\n        _transferOperatorship(params);\n    }\n\n    /**************************\\\n    |* Internal Functionality *|\n    \\**************************/\n\n    function _transferOperatorship(bytes memory params) internal {\n        (address[] memory newOperators, uint256[] memory newWeights, uint256 newThreshold) = abi.decode(\n            params,\n            (address[], uint256[], uint256)\n        );\n        uint256 operatorsLength = newOperators.length;\n        uint256 weightsLength = newWeights.length;\n\n        // operators must be sorted binary or alphabetically in lower case\n        if (operatorsLength == 0 || !_isSortedAscAndContainsNoDuplicate(newOperators)) revert InvalidOperators();\n\n        if (weightsLength != operatorsLength) revert InvalidWeights();\n\n        uint256 totalWeight = 0;\n        for (uint256 i = 0; i < weightsLength; ++i) {\n            totalWeight += newWeights[i];\n        }\n        if (newThreshold == 0 || totalWeight < newThreshold) revert InvalidThreshold();\n\n        bytes32 newOperatorsHash = keccak256(params);\n\n        if (epochForHash[newOperatorsHash] > 0) revert SameOperators();\n\n        uint256 epoch = currentEpoch + 1;\n        currentEpoch = epoch;\n        hashForEpoch[epoch] = newOperatorsHash;\n        epochForHash[newOperatorsHash] = epoch;\n\n        emit OperatorshipTransferred(newOperators, newWeights, newThreshold);\n    }\n\n    function _validateSignatures(\n        bytes32 messageHash,\n        address[] memory operators,\n        uint256[] memory weights,\n        uint256 threshold,\n        bytes[] memory signatures\n    ) internal pure {\n        uint256 operatorsLength = operators.length;\n        uint256 operatorIndex = 0;\n        uint256 weight = 0;\n        // looking for signers within operators\n        // assuming that both operators and signatures are sorted\n        for (uint256 i = 0; i < signatures.length; ++i) {\n            address signer = ECDSA.recover(messageHash, signatures[i]);\n            // looping through remaining operators to find a match\n            for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}\n            // checking if we are out of operators\n            if (operatorIndex == operatorsLength) revert MalformedSigners();\n            // return if weight sum above threshold\n            weight += weights[operatorIndex];\n            // weight needs to reach or surpass threshold\n            if (weight >= threshold) return;\n            // increasing operators index if match was found\n            ++operatorIndex;\n        }\n        // if weight sum below threshold\n        revert MalformedSigners();\n    }\n\n    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n        for (uint256 i; i < accounts.length - 1; ++i) {\n            if (accounts[i] >= accounts[i + 1]) {\n                return false;\n            }\n        }\n\n        return accounts[0] != address(0);\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarGateway.sol",
            "AxelarAuthWeighted.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AxelarGateway.sol#L268, AxelarGateway.sol#L311, AxelarAuthWeighted.sol#L86, AxelarAuthWeighted.sol#L36",
                "Type": "Access Control",
                "Description": "The previous sets of {Operators/Weights/Threshold} are still able to generate a valid proof, and subsequently execute the command. The past 16 sets of {Operators/Weights/Threshold} are considered valid and can be used within the AxelarAuthWeighted._validateSignatures function. Thus, the past 16 sets of {Operators/Weights/Threshold} are able to sign and submit a valid proof, and the proof will be accepted by the AxelarAuthWeighted.validateProof that allows them to execute the commands.",
                "Repair": "Commands signed by the past 16 sets of {operators/weights/threshold} AFTER the operatorship transfer should not be executable and should be rejected. Only commands signed by the current set of {operators/weights/threshold} AFTER the operatorship transfer should be accepted and executable. Commands signed by the past 16 sets of {operators/weights/threshold} BEFORE the operatorship transfer should be accepted and executable."
            }
        ]
    }
]