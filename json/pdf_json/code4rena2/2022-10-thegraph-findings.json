[
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./GraphTokenUpgradeable.sol\";\nimport \"../../arbitrum/IArbToken.sol\";\n\n/**\n * @title L2 Graph Token Contract\n * @dev Provides the L2 version of the GRT token, meant to be minted/burned\n * through the L2GraphTokenGateway.\n */\ncontract L2GraphToken is GraphTokenUpgradeable, IArbToken {\n    using SafeMath for uint256;\n\n    // Address of the gateway (on L2) that is allowed to mint tokens\n    address public gateway;\n    // Address of the corresponding Graph Token contract on L1\n    address public override l1Address;\n\n    // Emitted when the bridge / gateway has minted new tokens, i.e. tokens were transferred to L2\n    event BridgeMinted(address indexed account, uint256 amount);\n    // Emitted when the bridge / gateway has burned tokens, i.e. tokens were transferred back to L1\n    event BridgeBurned(address indexed account, uint256 amount);\n    // Emitted when the address of the gateway has been updated\n    event GatewaySet(address gateway);\n    // Emitted when the address of the Graph Token contract on L1 has been updated\n    event L1AddressSet(address l1Address);\n\n    /**\n     * @dev Checks that the sender is the L2 gateway from the L1/L2 token bridge\n     */\n    modifier onlyGateway() {\n        require(msg.sender == gateway, \"NOT_GATEWAY\");\n        _;\n    }\n\n    /**\n     * @dev L2 Graph Token Contract initializer.\n     * Note some parameters have to be set separately as they are generally\n     * not expected to be available at initialization time:\n     * - gateway using setGateway\n     * - l1Address using setL1Address\n     * @param _owner Governance address that owns this contract\n     */\n    function initialize(address _owner) external onlyImpl {\n        require(_owner != address(0), \"Owner must be set\");\n        // Initial supply hard coded to 0 as tokens are only supposed\n        // to be minted through the bridge.\n        GraphTokenUpgradeable._initialize(_owner, 0);\n    }\n\n    /**\n     * @dev Sets the address of the L2 gateway allowed to mint tokens\n     * @param _gw Address for the L2GraphTokenGateway that will be allowed to mint tokens\n     */\n    function setGateway(address _gw) external onlyGovernor {\n        require(_gw != address(0), \"INVALID_GATEWAY\");\n        gateway = _gw;\n        emit GatewaySet(gateway);\n    }\n\n    /**\n     * @dev Sets the address of the counterpart token on L1\n     * @param _addr Address for the GraphToken contract on L1\n     */\n    function setL1Address(address _addr) external onlyGovernor {\n        require(_addr != address(0), \"INVALID_L1_ADDRESS\");\n        l1Address = _addr;\n        emit L1AddressSet(_addr);\n    }\n\n    /**\n     * @dev Increases token supply, only callable by the L1/L2 bridge (when tokens are transferred to L2)\n     * @param _account Address to credit with the new tokens\n     * @param _amount Number of tokens to mint\n     */\n    function bridgeMint(address _account, uint256 _amount) external override onlyGateway {\n        _mint(_account, _amount);\n        emit BridgeMinted(_account, _amount);\n    }\n\n    /**\n     * @dev Decreases token supply, only callable by the L1/L2 bridge (when tokens are transferred to L1).\n     * @param _account Address from which to extract the tokens\n     * @param _amount Number of tokens to burn\n     */\n    function bridgeBurn(address _account, uint256 _amount) external override onlyGateway {\n        burnFrom(_account, _amount);\n        emit BridgeBurned(_account, _amount);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../../arbitrum/L2ArbitrumMessenger.sol\";\nimport \"../../arbitrum/AddressAliasHelper.sol\";\nimport \"../../gateway/GraphTokenGateway.sol\";\nimport \"../../gateway/ICallhookReceiver.sol\";\nimport \"../token/L2GraphToken.sol\";\n\n/**\n * @title L2 Graph Token Gateway Contract\n * @dev Provides the L2 side of the Ethereum-Arbitrum GRT bridge. Receives GRT from the L1 chain\n * and mints them on the L2 side. Sends GRT back to L1 by burning them on the L2 side.\n * Based on Offchain Labs' reference implementation and Livepeer's arbitrum-lpt-bridge\n * (See: https://github.com/OffchainLabs/arbitrum/tree/master/packages/arb-bridge-peripherals/contracts/tokenbridge\n * and https://github.com/livepeer/arbitrum-lpt-bridge)\n */\ncontract L2GraphTokenGateway is GraphTokenGateway, L2ArbitrumMessenger, ReentrancyGuardUpgradeable {\n    using SafeMath for uint256;\n\n    // Address of the Graph Token contract on L1\n    address public l1GRT;\n    // Address of the L1GraphTokenGateway that is the counterpart of this gateway on L1\n    address public l1Counterpart;\n    // Address of the Arbitrum Gateway Router on L2\n    address public l2Router;\n\n    // Calldata included in an outbound transfer, stored as a structure for convenience and stack depth\n    struct OutboundCalldata {\n        address from;\n        bytes extraData;\n    }\n\n    // Emitted when an incoming transfer is finalized, i.e. tokens were deposited from L1 to L2\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n\n    // Emitted when an outbound transfer is initiated, i.e. tokens are being withdrawn from L2 back to L1\n    event WithdrawalInitiated(\n        address l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 indexed l2ToL1Id,\n        uint256 exitNum,\n        uint256 amount\n    );\n\n    // Emitted when the Arbitrum Gateway Router address on L2 has been updated\n    event L2RouterSet(address l2Router);\n    // Emitted when the L1 Graph Token address has been updated\n    event L1TokenAddressSet(address l1GRT);\n    // Emitted when the address of the counterpart gateway on L1 has been updated\n    event L1CounterpartAddressSet(address l1Counterpart);\n\n    /**\n     * @dev Checks that the sender is the L2 alias of the counterpart\n     * gateway on L1.\n     */\n    modifier onlyL1Counterpart() {\n        require(\n            msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Initialize this contract.\n     * The contract will be paused.\n     * Note some parameters have to be set separately as they are generally\n     * not expected to be available at initialization time:\n     * - l2Router using setL2Router\n     * - l1GRT using setL1TokenAddress\n     * - l1Counterpart using setL1CounterpartAddress\n     * - pauseGuardian using setPauseGuardian\n     * @param _controller Address of the Controller that manages this contract\n     */\n    function initialize(address _controller) external onlyImpl {\n        Managed._initialize(_controller);\n        _paused = true;\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @dev Sets the address of the Arbitrum Gateway Router on L2\n     * @param _l2Router Address of the L2 Router (provided by Arbitrum)\n     */\n    function setL2Router(address _l2Router) external onlyGovernor {\n        require(_l2Router != address(0), \"INVALID_L2_ROUTER\");\n        l2Router = _l2Router;\n        emit L2RouterSet(_l2Router);\n    }\n\n    /**\n     * @dev Sets the address of the Graph Token on L1\n     * @param _l1GRT L1 address of the Graph Token contract\n     */\n    function setL1TokenAddress(address _l1GRT) external onlyGovernor {\n        require(_l1GRT != address(0), \"INVALID_L1_GRT\");\n        l1GRT = _l1GRT;\n        emit L1TokenAddressSet(_l1GRT);\n    }\n\n    /**\n     * @dev Sets the address of the counterpart gateway on L1\n     * @param _l1Counterpart Address of the L1GraphTokenGateway on L1\n     */\n    function setL1CounterpartAddress(address _l1Counterpart) external onlyGovernor {\n        require(_l1Counterpart != address(0), \"INVALID_L1_COUNTERPART\");\n        l1Counterpart = _l1Counterpart;\n        emit L1CounterpartAddressSet(_l1Counterpart);\n    }\n\n    /**\n     * @notice Burns L2 tokens and initiates a transfer to L1.\n     * The tokens will be available on L1 only after the wait period (7 days) is over,\n     * and will require an Outbox.executeTransaction to finalize.\n     * Note that the caller must previously allow the gateway to spend the specified amount of GRT.\n     * @dev no additional callhook data is allowed. The two unused params are needed\n     * for compatibility with Arbitrum's gateway router.\n     * The function is payable for ITokenGateway compatibility, but msg.value must be zero.\n     * @param _l1Token L1 Address of GRT (needed for compatibility with Arbitrum Gateway Router)\n     * @param _to Recipient address on L1\n     * @param _amount Amount of tokens to burn\n     * @param _data Contains sender and additional data (always empty) to send to L1\n     * @return ID of the withdraw transaction\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256, // unused on L2\n        uint256, // unused on L2\n        bytes calldata _data\n    ) public payable override notPaused nonReentrant returns (bytes memory) {\n        require(_l1Token == l1GRT, \"TOKEN_NOT_GRT\");\n        require(_amount > 0, \"INVALID_ZERO_AMOUNT\");\n        require(msg.value == 0, \"INVALID_NONZERO_VALUE\");\n        require(_to != address(0), \"INVALID_DESTINATION\");\n\n        OutboundCalldata memory outboundCalldata;\n\n        (outboundCalldata.from, outboundCalldata.extraData) = parseOutboundData(_data);\n        require(outboundCalldata.extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n        // from needs to approve this contract to burn the amount first\n        L2GraphToken(calculateL2TokenAddress(l1GRT)).bridgeBurn(outboundCalldata.from, _amount);\n\n        uint256 id = sendTxToL1(\n            0,\n            outboundCalldata.from,\n            l1Counterpart,\n            getOutboundCalldata(\n                _l1Token,\n                outboundCalldata.from,\n                _to,\n                _amount,\n                outboundCalldata.extraData\n            )\n        );\n\n        // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n        emit WithdrawalInitiated(_l1Token, outboundCalldata.from, _to, id, 0, _amount);\n\n        return abi.encode(id);\n    }\n\n    /**\n     * @notice Burns L2 tokens and initiates a transfer to L1.\n     * The tokens will be received on L1 only after the wait period (7 days) is over,\n     * and will require an Outbox.executeTransaction to finalize.\n     * @dev no additional callhook data is allowed\n     * @param _l1Token L1 Address of GRT (needed for compatibility with Arbitrum Gateway Router)\n     * @param _to Recipient address on L1\n     * @param _amount Amount of tokens to burn\n     * @param _data Contains sender and additional data to send to L1\n     * @return ID of the withdraw tx\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external returns (bytes memory) {\n        return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n    }\n\n    /**\n     * @notice Calculate the L2 address of a bridged token\n     * @dev In our case, this would only work for GRT.\n     * @param l1ERC20 address of L1 GRT contract\n     * @return L2 address of the bridged GRT token\n     */\n    function calculateL2TokenAddress(address l1ERC20) public view override returns (address) {\n        if (l1ERC20 != l1GRT) {\n            return address(0);\n        }\n        return address(graphToken());\n    }\n\n    /**\n     * @notice Receives token amount from L1 and mints the equivalent tokens to the receiving address\n     * @dev Only accepts transactions from the L1 GRT Gateway.\n     * The function is payable for ITokenGateway compatibility, but msg.value must be zero.\n     * Note that whitelisted senders (some protocol contracts) can include additional calldata\n     * for a callhook to be executed on the L2 side when the tokens are received. In this case, the L2 transaction\n     * can revert if the callhook reverts, potentially locking the tokens on the bridge if the callhook\n     * never succeeds. This requires extra care when adding contracts to the whitelist, but is necessary to ensure that\n     * the tickets can be retried in the case of a temporary failure, and to ensure the atomicity of callhooks\n     * with token transfers.\n     * @param _l1Token L1 Address of GRT\n     * @param _from Address of the sender on L1\n     * @param _to Recipient address on L2\n     * @param _amount Amount of tokens transferred\n     * @param _data Extra callhook data, only used when the sender is whitelisted\n     */\n    function finalizeInboundTransfer(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override notPaused onlyL1Counterpart nonReentrant {\n        require(_l1Token == l1GRT, \"TOKEN_NOT_GRT\");\n        require(msg.value == 0, \"INVALID_NONZERO_VALUE\");\n\n        L2GraphToken(calculateL2TokenAddress(l1GRT)).bridgeMint(_to, _amount);\n\n        if (_data.length > 0) {\n            bytes memory callhookData;\n            {\n                bytes memory gatewayData;\n                (gatewayData, callhookData) = abi.decode(_data, (bytes, bytes));\n            }\n            ICallhookReceiver(_to).onTokenTransfer(_from, _amount, callhookData);\n        }\n\n        emit DepositFinalized(_l1Token, _from, _to, _amount);\n    }\n\n    /**\n     * @notice Creates calldata required to send tx to L1\n     * @dev encodes the target function with its params which\n     * will be called on L1 when the message is received on L1\n     * @param _token Address of the token on L1\n     * @param _from Address of the token sender on L2\n     * @param _to Address to which we're sending tokens on L1\n     * @param _amount Amount of GRT to transfer\n     * @param _data Additional calldata for the transaction\n     * @return Calldata for a transaction sent to L1\n     */\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                ITokenGateway.finalizeInboundTransfer.selector,\n                _token,\n                _from,\n                _to,\n                _amount,\n                abi.encode(0, _data) // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n            );\n    }\n\n    /**\n     * @notice Decodes calldata required for migration of tokens\n     * @dev extraData can be left empty\n     * @param _data Encoded callhook data\n     * @return Sender of the tx\n     * @return Any other data sent to L1\n     */\n    function parseOutboundData(bytes memory _data) private view returns (address, bytes memory) {\n        address from;\n        bytes memory extraData;\n        if (msg.sender == l2Router) {\n            (from, extraData) = abi.decode(_data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = _data;\n        }\n        return (from, extraData);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"../upgrades/GraphUpgradeable.sol\";\nimport \"../governance/Managed.sol\";\nimport \"../token/IGraphToken.sol\";\n\n/**\n * @title Bridge Escrow\n * @dev This contracts acts as a gateway for an L2 bridge (or several). It simply holds GRT and has\n * a set of spenders that can transfer the tokens; the L1 side of each L2 bridge has to be\n * approved as a spender.\n */\ncontract BridgeEscrow is GraphUpgradeable, Managed {\n    /**\n     * @dev Initialize this contract.\n     * @param _controller Address of the Controller that manages this contract\n     */\n    function initialize(address _controller) external onlyImpl {\n        Managed._initialize(_controller);\n    }\n\n    /**\n     * @dev Approve a spender (i.e. a bridge that manages the GRT funds held by the escrow)\n     * @param _spender Address of the spender that will be approved\n     */\n    function approveAll(address _spender) external onlyGovernor {\n        graphToken().approve(_spender, type(uint256).max);\n    }\n\n    /**\n     * @dev Revoke a spender (i.e. a bridge that will no longer manage the GRT funds held by the escrow)\n     * @param _spender Address of the spender that will be revoked\n     */\n    function revokeAll(address _spender) external onlyGovernor {\n        IGraphToken grt = graphToken();\n        grt.decreaseAllowance(_spender, grt.allowance(address(this), _spender));\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../arbitrum/L1ArbitrumMessenger.sol\";\nimport \"./GraphTokenGateway.sol\";\n\n/**\n * @title L1 Graph Token Gateway Contract\n * @dev Provides the L1 side of the Ethereum-Arbitrum GRT bridge. Sends GRT to the L2 chain\n * by escrowing them and sending a message to the L2 gateway, and receives tokens from L2 by\n * releasing them from escrow.\n * Based on Offchain Labs' reference implementation and Livepeer's arbitrum-lpt-bridge\n * (See: https://github.com/OffchainLabs/arbitrum/tree/master/packages/arb-bridge-peripherals/contracts/tokenbridge\n * and https://github.com/livepeer/arbitrum-lpt-bridge)\n */\ncontract L1GraphTokenGateway is GraphTokenGateway, L1ArbitrumMessenger {\n    using SafeMath for uint256;\n\n    // Address of the Graph Token contract on L2\n    address public l2GRT;\n    // Address of the Arbitrum Inbox\n    address public inbox;\n    // Address of the Arbitrum Gateway Router on L1\n    address public l1Router;\n    // Address of the L2GraphTokenGateway on L2 that is the counterpart of this gateway\n    address public l2Counterpart;\n    // Address of the BridgeEscrow contract that holds the GRT in the bridge\n    address public escrow;\n    // Addresses for which this mapping is true are allowed to send callhooks in outbound transfers\n    mapping(address => bool) public callhookWhitelist;\n\n    // Emitted when an outbound transfer is initiated, i.e. tokens are deposited from L1 to L2\n    event DepositInitiated(\n        address l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 indexed sequenceNumber,\n        uint256 amount\n    );\n\n    // Emitted when an incoming transfer is finalized, i.e tokens are withdrawn from L2 to L1\n    event WithdrawalFinalized(\n        address l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 indexed exitNum,\n        uint256 amount\n    );\n\n    // Emitted when the Arbitrum Inbox and Gateway Router addresses have been updated\n    event ArbitrumAddressesSet(address inbox, address l1Router);\n    // Emitted when the L2 GRT address has been updated\n    event L2TokenAddressSet(address l2GRT);\n    // Emitted when the counterpart L2GraphTokenGateway address has been updated\n    event L2CounterpartAddressSet(address l2Counterpart);\n    // Emitted when the escrow address has been updated\n    event EscrowAddressSet(address escrow);\n    // Emitted when an address is added to the callhook whitelist\n    event AddedToCallhookWhitelist(address newWhitelisted);\n    // Emitted when an address is removed from the callhook whitelist\n    event RemovedFromCallhookWhitelist(address notWhitelisted);\n\n    /**\n     * @dev Allows a function to be called only by the gateway's L2 counterpart.\n     * The message will actually come from the Arbitrum Bridge, but the Outbox\n     * can tell us who the sender from L2 is.\n     */\n    modifier onlyL2Counterpart() {\n        require(inbox != address(0), \"INBOX_NOT_SET\");\n\n        // a message coming from the counterpart gateway was executed by the bridge\n        IBridge bridge = IInbox(inbox).bridge();\n        require(msg.sender == address(bridge), \"NOT_FROM_BRIDGE\");\n\n        // and the outbox reports that the L2 address of the sender is the counterpart gateway\n        address l2ToL1Sender = IOutbox(bridge.activeOutbox()).l2ToL1Sender();\n        require(l2ToL1Sender == l2Counterpart, \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /**\n     * @dev Initialize this contract.\n     * The contract will be paused.\n     * Note some parameters have to be set separately as they are generally\n     * not expected to be available at initialization time:\n     * - inbox  and l1Router using setArbitrumAddresses\n     * - l2GRT using setL2TokenAddress\n     * - l2Counterpart using setL2CounterpartAddress\n     * - escrow using setEscrowAddress\n     * - whitelisted callhook callers using addToCallhookWhitelist\n     * - pauseGuardian using setPauseGuardian\n     * @param _controller Address of the Controller that manages this contract\n     */\n    function initialize(address _controller) external onlyImpl {\n        Managed._initialize(_controller);\n        _paused = true;\n    }\n\n    /**\n     * @dev Sets the addresses for L1 contracts provided by Arbitrum\n     * @param _inbox Address of the Inbox that is part of the Arbitrum Bridge\n     * @param _l1Router Address of the Gateway Router\n     */\n    function setArbitrumAddresses(address _inbox, address _l1Router) external onlyGovernor {\n        require(_inbox != address(0), \"INVALID_INBOX\");\n        require(_l1Router != address(0), \"INVALID_L1_ROUTER\");\n        inbox = _inbox;\n        l1Router = _l1Router;\n        emit ArbitrumAddressesSet(_inbox, _l1Router);\n    }\n\n    /**\n     * @dev Sets the address of the L2 Graph Token\n     * @param _l2GRT Address of the GRT contract on L2\n     */\n    function setL2TokenAddress(address _l2GRT) external onlyGovernor {\n        require(_l2GRT != address(0), \"INVALID_L2_GRT\");\n        l2GRT = _l2GRT;\n        emit L2TokenAddressSet(_l2GRT);\n    }\n\n    /**\n     * @dev Sets the address of the counterpart gateway on L2\n     * @param _l2Counterpart Address of the corresponding L2GraphTokenGateway on Arbitrum\n     */\n    function setL2CounterpartAddress(address _l2Counterpart) external onlyGovernor {\n        require(_l2Counterpart != address(0), \"INVALID_L2_COUNTERPART\");\n        l2Counterpart = _l2Counterpart;\n        emit L2CounterpartAddressSet(_l2Counterpart);\n    }\n\n    /**\n     * @dev Sets the address of the escrow contract on L1\n     * @param _escrow Address of the BridgeEscrow\n     */\n    function setEscrowAddress(address _escrow) external onlyGovernor {\n        require(_escrow != address(0) && Address.isContract(_escrow), \"INVALID_ESCROW\");\n        escrow = _escrow;\n        emit EscrowAddressSet(_escrow);\n    }\n\n    /**\n     * @dev Adds an address to the callhook whitelist.\n     * This address will be allowed to include callhooks when transferring tokens.\n     * @param _newWhitelisted Address to add to the whitelist\n     */\n    function addToCallhookWhitelist(address _newWhitelisted) external onlyGovernor {\n        require(_newWhitelisted != address(0), \"INVALID_ADDRESS\");\n        require(!callhookWhitelist[_newWhitelisted], \"ALREADY_WHITELISTED\");\n        callhookWhitelist[_newWhitelisted] = true;\n        emit AddedToCallhookWhitelist(_newWhitelisted);\n    }\n\n    /**\n     * @dev Removes an address from the callhook whitelist.\n     * This address will no longer be allowed to include callhooks when transferring tokens.\n     * @param _notWhitelisted Address to remove from the whitelist\n     */\n    function removeFromCallhookWhitelist(address _notWhitelisted) external onlyGovernor {\n        require(_notWhitelisted != address(0), \"INVALID_ADDRESS\");\n        require(callhookWhitelist[_notWhitelisted], \"NOT_WHITELISTED\");\n        callhookWhitelist[_notWhitelisted] = false;\n        emit RemovedFromCallhookWhitelist(_notWhitelisted);\n    }\n\n    /**\n     * @notice Creates and sends a retryable ticket to transfer GRT to L2 using the Arbitrum Inbox.\n     * The tokens are escrowed by the gateway until they are withdrawn back to L1.\n     * The ticket must be redeemed on L2 to receive tokens at the specified address.\n     * Note that the caller must previously allow the gateway to spend the specified amount of GRT.\n     * @dev maxGas and gasPriceBid must be set using Arbitrum's NodeInterface.estimateRetryableTicket method.\n     * Also note that whitelisted senders (some protocol contracts) can include additional calldata\n     * for a callhook to be executed on the L2 side when the tokens are received. In this case, the L2 transaction\n     * can revert if the callhook reverts, potentially locking the tokens on the bridge if the callhook\n     * never succeeds. This requires extra care when adding contracts to the whitelist, but is necessary to ensure that\n     * the tickets can be retried in the case of a temporary failure, and to ensure the atomicity of callhooks\n     * with token transfers.\n     * @param _l1Token L1 Address of the GRT contract (needed for compatibility with Arbitrum Gateway Router)\n     * @param _to Recipient address on L2\n     * @param _amount Amount of tokens to tranfer\n     * @param _maxGas Gas limit for L2 execution of the ticket\n     * @param _gasPriceBid Price per gas on L2\n     * @param _data Encoded maxSubmissionCost and sender address along with additional calldata\n     * @return Sequence number of the retryable ticket created by Inbox\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable override notPaused returns (bytes memory) {\n        IGraphToken token = graphToken();\n        require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n        require(_amount > 0, \"INVALID_ZERO_AMOUNT\");\n        require(_to != address(0), \"INVALID_DESTINATION\");\n\n        // nested scopes to avoid stack too deep errors\n        address from;\n        uint256 seqNum;\n        {\n            uint256 maxSubmissionCost;\n            bytes memory outboundCalldata;\n            {\n                bytes memory extraData;\n                (from, maxSubmissionCost, extraData) = parseOutboundData(_data);\n                require(\n                    extraData.length == 0 || callhookWhitelist[msg.sender] == true,\n                    \"CALL_HOOK_DATA_NOT_ALLOWED\"\n                );\n                require(maxSubmissionCost > 0, \"NO_SUBMISSION_COST\");\n\n                {\n                    // makes sure only sufficient ETH is supplied as required for successful redemption on L2\n                    // if a user does not desire immediate redemption they should provide\n                    // a msg.value of AT LEAST maxSubmissionCost\n                    uint256 expectedEth = maxSubmissionCost.add(_maxGas.mul(_gasPriceBid));\n                    require(msg.value >= expectedEth, \"WRONG_ETH_VALUE\");\n                }\n                outboundCalldata = getOutboundCalldata(_l1Token, from, _to, _amount, extraData);\n            }\n            {\n                L2GasParams memory gasParams = L2GasParams(\n                    maxSubmissionCost,\n                    _maxGas,\n                    _gasPriceBid\n                );\n                // transfer tokens to escrow\n                token.transferFrom(from, escrow, _amount);\n                seqNum = sendTxToL2(\n                    inbox,\n                    l2Counterpart,\n                    from,\n                    msg.value,\n                    0,\n                    gasParams,\n                    outboundCalldata\n                );\n            }\n        }\n        emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);\n\n        return abi.encode(seqNum);\n    }\n\n    /**\n     * @notice Receives withdrawn tokens from L2\n     * The equivalent tokens are released from escrow and sent to the destination.\n     * @dev can only accept transactions coming from the L2 GRT Gateway.\n     * The last parameter is unused but kept for compatibility with Arbitrum gateways,\n     * and the encoded exitNum is assumed to be 0.\n     * @param _l1Token L1 Address of the GRT contract (needed for compatibility with Arbitrum Gateway Router)\n     * @param _from Address of the sender\n     * @param _to Recepient address on L1\n     * @param _amount Amount of tokens transferred\n     */\n    function finalizeInboundTransfer(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata // _data, contains exitNum, unused by this contract\n    ) external payable override notPaused onlyL2Counterpart {\n        IGraphToken token = graphToken();\n        require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n\n        uint256 escrowBalance = token.balanceOf(escrow);\n        // If the bridge doesn't have enough tokens, something's very wrong!\n        require(_amount <= escrowBalance, \"BRIDGE_OUT_OF_FUNDS\");\n        token.transferFrom(escrow, _to, _amount);\n\n        emit WithdrawalFinalized(_l1Token, _from, _to, 0, _amount);\n    }\n\n    /**\n     * @notice Decodes calldata required for migration of tokens\n     * @dev Data must include maxSubmissionCost, extraData can be left empty. When the router\n     * sends an outbound message, data also contains the from address.\n     * @param _data encoded callhook data\n     * @return Sender of the tx\n     * @return Base ether value required to keep retryable ticket alive\n     * @return Additional data sent to L2\n     */\n    function parseOutboundData(bytes memory _data)\n        private\n        view\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address from;\n        uint256 maxSubmissionCost;\n        bytes memory extraData;\n        if (msg.sender == l1Router) {\n            // Data encoded by the Gateway Router includes the sender address\n            (from, extraData) = abi.decode(_data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = _data;\n        }\n        // User-encoded data contains the max retryable ticket submission cost\n        // and additional L2 calldata\n        (maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));\n        return (from, maxSubmissionCost, extraData);\n    }\n\n    /**\n     * @notice Creates calldata required to create a retryable ticket\n     * @dev encodes the target function with its params which\n     * will be called on L2 when the retryable ticket is redeemed\n     * @param _l1Token Address of the Graph token contract on L1\n     * @param _from Address on L1 from which we're transferring tokens\n     * @param _to Address on L2 to which we're transferring tokens\n     * @param _amount Amount of GRT to transfer\n     * @param _data Additional call data for the L2 transaction, which must be empty unless the caller is whitelisted\n     * @return Encoded calldata (including function selector) for the L2 transaction\n     */\n    function getOutboundCalldata(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public pure returns (bytes memory) {\n        bytes memory emptyBytes;\n\n        return\n            abi.encodeWithSelector(\n                ITokenGateway.finalizeInboundTransfer.selector,\n                _l1Token,\n                _from,\n                _to,\n                _amount,\n                abi.encode(emptyBytes, _data)\n            );\n    }\n\n    /**\n     * @notice Calculate the L2 address of a bridged token\n     * @dev In our case, this would only work for GRT.\n     * @param _l1ERC20 address of L1 GRT contract\n     * @return L2 address of the bridged GRT token\n     */\n    function calculateL2TokenAddress(address _l1ERC20) external view override returns (address) {\n        IGraphToken token = graphToken();\n        if (_l1ERC20 != address(token)) {\n            return address(0);\n        }\n        return l2GRT;\n    }\n}\n\n\n",
        "CodeNames": [
            "L2GraphToken.sol",
            "L2GraphTokenGateway.sol",
            "BridgeEscrow.sol",
            "L1GraphTokenGateway.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Initialize function in L2GraphToken.sol, BridgeEscrow.sol, L2GraphTokenGateway.sol, L1GraphTokenGateway.sol",
                "Type": "Reinitialization",
                "Description": "Initialize function in L2GraphToken.sol, BridgeEscrow.sol, L2GraphTokenGateway.sol, and L1GraphTokenGateway.sol can be invoked multiple times from the implementation contract. This means a compromised implementation can reinitialize the contract above and become the owner to complete the privilege escalation then drain the user's fund.",
                "Repair": "Use the modifier 'initializer' to protect the initialize function from being reinitiated"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "L1GraphTokenGateway's outboundTransfer function",
                "Type": "Value Loss",
                "Description": "If L1GraphTokenGateway's outboundTransfer is called by a contract, the entire msg.value is blackholed, whether the ticket got redeemed or not.",
                "Repair": "Add a 'refundAddr' address parameter to the API"
            },
            {
                "Location": "L2GraphTokenGateway's onlyL1Counterpart modifier",
                "Type": "Compiler Version",
                "Description": "After proposed 0.8.0 upgrade kicks in, L2 finalizeInboundTransfer might not work.",
                "Repair": "Wrap the calculation in an unchecked block, which will make it behave correctly"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"../upgrades/GraphUpgradeable.sol\";\nimport \"../governance/Managed.sol\";\nimport \"../token/IGraphToken.sol\";\n\n/**\n * @title Bridge Escrow\n * @dev This contracts acts as a gateway for an L2 bridge (or several). It simply holds GRT and has\n * a set of spenders that can transfer the tokens; the L1 side of each L2 bridge has to be\n * approved as a spender.\n */\ncontract BridgeEscrow is GraphUpgradeable, Managed {\n    /**\n     * @dev Initialize this contract.\n     * @param _controller Address of the Controller that manages this contract\n     */\n    function initialize(address _controller) external onlyImpl {\n        Managed._initialize(_controller);\n    }\n\n    /**\n     * @dev Approve a spender (i.e. a bridge that manages the GRT funds held by the escrow)\n     * @param _spender Address of the spender that will be approved\n     */\n    function approveAll(address _spender) external onlyGovernor {\n        graphToken().approve(_spender, type(uint256).max);\n    }\n\n    /**\n     * @dev Revoke a spender (i.e. a bridge that will no longer manage the GRT funds held by the escrow)\n     * @param _spender Address of the spender that will be revoked\n     */\n    function revokeAll(address _spender) external onlyGovernor {\n        IGraphToken grt = graphToken();\n        grt.decreaseAllowance(_spender, grt.allowance(address(this), _spender));\n    }\n}\n\n\n",
        "CodeNames": [
            "BridgeEscrow.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BridgeEscrow.sol#L28-L30",
                "Type": "Governor can rug pull the escrow",
                "Description": "Governor can approve an arbitrary address to spend any amount from BridgeEscrow, which is a severe undermining of decentralization. The escrowed tokens are never burnt, so the users would need to trust the governor perpetually.",
                "Repair": "Restrict access to approveAll() to the \"bridge that manages the GRT funds held by the escrow\" or only allow spending via other protocol functions."
            }
        ]
    }
]