[
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BasePoolV2.sol\";\n\nimport \"../../external/libraries/FixedPoint.sol\";\n\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\n\n/*\n * @dev Implementation of {VaderPoolV2} contract.\n *\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePoolV2` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The LP wrapper contract\n    ILPWrapper public wrapper;\n\n    // The Synth Factory\n    ISynthFactory public synthFactory;\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialised the contract state by passing the native asset's address\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\n     * to the {queueActive} state variable.\n     **/\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns cumulative prices and the timestamp the were last updated\n     * for both native and foreign assets against the pair specified by\n     * parameter {foreignAsset}.\n     **/\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n\n        if (blockTimestampLast < block.timestamp) {\n            uint256 timeElapsed = block.timestamp - blockTimestampLast;\n            unchecked {\n                price0CumulativeLast +=\n                    uint256(\n                        FixedPoint\n                            .fraction(\n                                pairInfo[foreignAsset].reserveForeign,\n                                pairInfo[foreignAsset].reserveNative\n                            )\n                            ._x\n                    ) *\n                    timeElapsed;\n                price1CumulativeLast +=\n                    uint256(\n                        FixedPoint\n                            .fraction(\n                                pairInfo[foreignAsset].reserveNative,\n                                pairInfo[foreignAsset].reserveForeign\n                            )\n                            ._x\n                    ) *\n                    timeElapsed;\n            }\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Initializes contract's state with LP wrapper, synth factory\n     * and router addresses.\n     *\n     * Requirements:\n     * - None of the parameters are zero addresses.\n     * - The parameters are not already set.\n     * - Only callable by contract owner.\n     **/\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n\n    /*\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\n     * on the native asset amount deposited and returns the minted synth asset amount.\n     *\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must be a supported token.\n     **/\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n\n    /*\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\n     * and returns the redeemed amount of native asset.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must have a valid synthetic asset against it.\n     * - {synthAmount} must be greater than zero.\n     **/\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePoolV2} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     *\n     * Requirements:\n     * - Can only be called by the Router.\n     **/\n    // NOTE: IL is only covered via router!\n    // NOTE: Loss is in terms of USDV\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /*\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\n     * tracked within this contract along with liquidity issued against non-fungible\n     * token.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'mint' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     **/\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n\n    /*\n     * @dev Allows burning of liquidity issued in fungible tokens.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'burn' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\n     **/\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setQueue(bool _queueActive) external override onlyOwner {\n        require(\n            _queueActive != queueActive,\n            \"VaderPoolV2::setQueue: Already At Desired State\"\n        );\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setTokenSupport(\n        IERC20 foreignAsset,\n        bool support,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override onlyOwner returns (uint256 liquidity) {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n        if (!support) {\n            PairInfo storage pair = pairInfo[foreignAsset];\n            require(\n                pair.reserveNative == 0 && pair.reserveForeign == 0,\n                \"VaderPoolV2::supportToken: Cannot Unsupport Token w/ Liquidity\"\n            );\n        } else {\n            require(\n                nativeDeposit != 0 && foreignDeposit != 0,\n                \"VaderPoolV2::supportToken: Improper First-Time Liquidity Provision\"\n            );\n            liquidity = _mint(\n                foreignAsset,\n                nativeDeposit,\n                foreignDeposit,\n                from,\n                to\n            );\n        }\n    }\n\n    /*\n     * @dev Allows the gas throttle to be toggled on/off in case of emergency\n     **/\n    function setGasThrottle(bool _gasThrottleEnabled)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            gasThrottleEnabled != _gasThrottleEnabled,\n            \"VaderPoolV2::setGasThrottle: Already At Desired State\"\n        );\n        gasThrottleEnabled = _gasThrottleEnabled;\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderPoolV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderPoolV2.mintFungible function",
                "Type": "Medium Severity",
                "Description": "Frontrunners can extract up to 100% of the value provided by LPs to VaderPoolV2 as fungible liquidity.",
                "Repair": "Add a user-specified minimum amount of LP tokens to mint."
            },
            {
                "Location": "VaderPoolV2.mintSynth and mintFungible functions",
                "Type": "High Severity",
                "Description": "VaderPoolV2 minting synths & fungibles can be frontrun.",
                "Repair": "Remove the 'from' parameter and always perform the 'safeTransferFrom' call with 'from=msg.sender'."
            },
            {
                "Location": "VaderPoolV2.sol",
                "Type": "High Severity",
                "Description": "Denial of service.",
                "Repair": "Add a user-specified minimum amount of LP tokens to mint."
            },
            {
                "Location": "VaderPoolV2.burn",
                "Type": "High Severity",
                "Description": "LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve.",
                "Repair": "Use a manipulation resistant oracle for the relative prices of the pool's assets (TWAP, etc.)"
            },
            {
                "Location": "VaderPoolV2.setTokenSupport",
                "Type": "High Severity",
                "Description": "VaderPoolV2 owner can steal all user assets which are approved VaderPoolV2.",
                "Repair": "Enforce that the initial liquidity is provided by the VaderPoolV2 owner."
            },
            {
                "Location": "VaderPoolV2.sol",
                "Type": "Losses for synth holders",
                "Description": "Using single total native reserve variable for synth and non-synth reserves of VaderPoolV2 can lead to losses for synth holders.",
                "Repair": "Account for LP provided liquidity separately from total amount variables in LP shares mint and burn calculations."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"../interfaces/external/chainlink/IAggregatorV3.sol\";\nimport \"../interfaces/external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public immutable vader;\n    IVaderPoolV2 public immutable vaderPool;\n\n    IUniswapV2Pair[] public vaderPairs;\n    IERC20[] public usdvPairs;\n\n    uint256 public override maxUpdateWindow;\n    uint256[2] public totalLiquidityWeight;\n    uint256[2] public override previousPrices;\n    mapping(address => ExchangePair) public twapData;\n    mapping(address => IAggregatorV3) public oracles;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _vader, IVaderPoolV2 _vaderPool) {\n        require(\n            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),\n            \"LBTWAP::construction: Zero Address\"\n        );\n        vader = _vader;\n        vaderPool = _vaderPool;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getStaleVaderPrice() external view returns (uint256) {\n        uint256 totalPairs = vaderPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.VADER)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(vaderPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function getStaleUSDVPrice() external view returns (uint256) {\n        uint256 totalPairs = usdvPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.USDV)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(usdvPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function getChainlinkPrice(address asset) public view returns (uint256) {\n        IAggregatorV3 oracle = oracles[asset];\n\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = oracle\n            .latestRoundData();\n\n        require(\n            answeredInRound >= roundID,\n            \"LBTWAP::getChainlinkPrice: Stale Chainlink Price\"\n        );\n\n        require(price > 0, \"LBTWAP::getChainlinkPrice: Chainlink Malfunction\");\n\n        return uint256(price);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function getVaderPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncVaderPrice();\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n\n    function _calculateVaderPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalVaderLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalVader;\n        uint256 totalPairs = vaderPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n\n            uint256 foreignPrice = getChainlinkPrice(pairData.foreignAsset);\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n\n            totalVader +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalVader;\n    }\n\n    function setupVader(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 vaderPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] == 0,\n            \"LBTWAP::setupVader: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.VADER)] = vaderPrice;\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] != 0,\n            \"LBTWAP::addVaderPair: Vader Uninitialized\"\n        );\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    function _addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addVaderPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");\n\n        ExchangePair storage pairData = twapData[address(pair)];\n\n        bool isFirst = pair.token0() == vader;\n\n        (address nativeAsset, address foreignAsset) = isFirst\n            ? (pair.token0(), pair.token1())\n            : (pair.token1(), pair.token0());\n\n        oracles[foreignAsset] = oracle;\n\n        require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");\n\n        pairData.foreignAsset = foreignAsset;\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(foreignAsset).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        pairData.nativeTokenPriceCumulative = isFirst\n            ? pair.price0CumulativeLast()\n            : pair.price1CumulativeLast();\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(foreignAsset));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;\n\n        vaderPairs.push(pair);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n\n    function getUSDVPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncUSDVPrice();\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function syncUSDVPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = usdvPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.USDV)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateUSDVPrice(\n                foreignAsset,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.USDV)] = _totalLiquidityWeight;\n    }\n\n    function _updateUSDVPrice(\n        IERC20 foreignAsset,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        (\n            uint256 nativeTokenPriceCumulative,\n            ,\n            uint256 currentMeasurement\n        ) = vaderPool.cumulativePrices(foreignAsset);\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n    }\n\n    function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }\n\n    function setupUSDV(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 usdvPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] == 0,\n            \"LBTWAP::setupUSDV: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.USDV)] = usdvPrice;\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] != 0,\n            \"LBTWAP::addUSDVPair: USDV Uninitialized\"\n        );\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    function _addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addUSDVPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addUSDVPair: Non-USD Oracle\");\n\n        oracles[address(foreignAsset)] = oracle;\n\n        ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n        // NOTE: Redundant\n        // pairData.foreignAsset = foreignAsset;\n\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(address(foreignAsset)).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        (uint256 nativeTokenPriceCumulative, , ) = vaderPool.cumulativePrices(\n            foreignAsset\n        );\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.USDV)] += pairLiquidityEvaluation;\n\n        usdvPairs.push(foreignAsset);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityBasedTWAP.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LiquidityBasedTWAP.sol",
                "Type": "High Severity",
                "Description": "Invalid values returned from oracle for USDV and VADER prices in situations where the oracle uses more than one foreign asset.",
                "Repair": "Review the algorithm used for calculating the prices of assets and ensure that it's calculating what you expect."
            },
            {
                "Location": "LiquidityBasedTWAP.sol",
                "Type": "Medium Severity",
                "Description": "Oracle can be manipulated to consider only a single pair for pricing.",
                "Repair": "Calculate fair reserves using the pool invariant and the fair prices of the two assets."
            },
            {
                "Location": "LiquidityBasedTWAP.sol",
                "Type": "Improperly scaled oracle price",
                "Description": "Oracle returns an improperly scaled USDV/VADER price.",
                "Repair": "Update oracle calculation to properly account for scale factors and handle difference in decimals between oracle and foreign asset. Build a test suite to ensure expected values are returned."
            },
            {
                "Location": "LiquidityBasedTWAP.sol",
                "Type": "Replacing oracle of earlier entry",
                "Description": "Adding pair of the same foreignAsset would replace oracle of earlier entry.",
                "Repair": "Bind the oracle to pair instead of foreignAsset."
            },
            {
                "Location": "LiquidityBasedTWAP.sol",
                "Type": "Not updating previousPrices upon syncing token price",
                "Description": "previousPrices is never updated upon syncing token price.",
                "Repair": "Update previousPrices after syncing the respective prices for VADER and USDV."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\ncontract VaderReserve is IVaderReserve, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe VADER transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The Vader token the reserve is handling\n    IERC20 public immutable vader;\n\n    // Router address for IL awards\n    address public router;\n\n    // Tracks last grant time for throttling\n    uint256 public lastGrant;\n\n    // LBT used for loss reimbursement\n    ILiquidityBasedTWAP public lbt;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20 _vader) {\n        require(\n            _vader != IERC20(_ZERO_ADDRESS),\n            \"VaderReserve::constructor: Incorrect Arguments\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function reserve() public view override returns (uint256) {\n        return vader.balanceOf(address(this));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function grant(address recipient, uint256 amount)\n        external\n        override\n        onlyOwner\n        throttle\n    {\n        amount = _min(\n            (reserve() * _MAX_GRANT_BASIS_POINTS) / _MAX_BASIS_POINTS,\n            amount\n        );\n        vader.safeTransfer(recipient, amount);\n\n        emit GrantDistributed(recipient, amount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function initialize(\n        ILiquidityBasedTWAP _lbt,\n        address _router,\n        address _dao\n    ) external onlyOwner {\n        require(\n            _router != _ZERO_ADDRESS &&\n                _dao != _ZERO_ADDRESS &&\n                _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"VaderReserve::initialize: Incorrect Arguments\"\n        );\n        router = _router;\n        lbt = _lbt;\n        transferOwnership(_dao);\n    }\n\n    function reimburseImpermanentLoss(address recipient, uint256 amount)\n        external\n        override\n    {\n        require(\n            msg.sender == router,\n            \"VaderReserve::reimburseImpermanentLoss: Insufficient Priviledges\"\n        );\n\n        // NOTE: Loss is in USDV, reimbursed in VADER\n        // NOTE: If USDV LBT is working, prefer it otherwise use VADER price\n        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {\n            uint256 usdvPrice = lbt.getUSDVPrice();\n\n            amount = amount / usdvPrice;\n        } else {\n            uint256 vaderPrice = lbt.getVaderPrice();\n\n            amount = amount * vaderPrice;\n        }\n\n        uint256 actualAmount = _min(reserve(), amount);\n\n        vader.safeTransfer(recipient, actualAmount);\n\n        emit LossCovered(recipient, amount, actualAmount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier throttle() {\n        require(\n            lastGrant + _GRANT_DELAY <= block.timestamp,\n            \"VaderReserve::throttle: Grant Too Fast\"\n        );\n        lastGrant = block.timestamp;\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderReserve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderReserve.sol",
                "Type": "High Severity",
                "Description": "Reserve pays out vastly higher (or lower) IL protection than it should.",
                "Repair": "Apply a fixed scaling factor to convert back from a fixed point number to a standard integer."
            },
            {
                "Location": "VaderReserve.reimburseImpermanentLoss",
                "Type": "Medium Severity",
                "Description": "VaderReserve.reimburseImpermanentLoss improperly converts USDV to VADER.",
                "Repair": "Care should be taken so that the calculation being performed is the expected one."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../interfaces/tokens/converter/IConverter.sol\";\nimport \"../../interfaces/tokens/vesting/ILinearVesting.sol\";\n\n/**\n * @dev Implementation of the {IConverter} interface.\n *\n * A simple converter contract that allows users to convert\n * their Vether tokens by \"burning\" them (See {convert}) to\n * acquire their equivalent Vader tokens based on the constant\n * {VADER_VETHER_CONVERSION_RATE}.\n *\n * The contract assumes that it has been sufficiently funded with\n * Vader tokens and will fail to execute trades if it has not been\n * done so yet.\n */\ncontract Converter is IConverter, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Using MerkleProof for validating claims\n    using MerkleProof for bytes32[];\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The VETHER token\n    IERC20 public immutable vether;\n\n    // The VADER token\n    IERC20 public immutable vader;\n\n    // The VADER vesting contract\n    ILinearVesting public vesting;\n\n    // The merkle proof root for validating claims\n    bytes32 public immutable root;\n\n    // Unique deployment salt\n    uint256 public immutable salt;\n\n    // Signals whether a particular leaf has been claimed of the merkle proof\n    mapping(bytes32 => bool) public claimed;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @dev Initializes the contract's {vether} and {vader} addresses.\n     *\n     * Performs rudimentary checks to ensure that the variables haven't\n     * been declared incorrectly.\n     */\n    constructor(\n        IERC20 _vether,\n        IERC20 _vader,\n        bytes32 _root,\n        uint256 _salt\n    ) {\n        require(\n            _vether != IERC20(_ZERO_ADDRESS) && _vader != IERC20(_ZERO_ADDRESS),\n            \"Converter::constructor: Misconfiguration\"\n        );\n\n        vether = _vether;\n        vader = _vader;\n\n        root = _root;\n        salt = _salt;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /*\n     * @dev Sets address of vesting contract.\n     *\n     * The LinearVesting and Converter contracts are dependent upon\n     * each other, hence this setter is introduced.\n     *\n     * Also approves Vesting to spend Vader tokens on its behalf.\n     *\n     **/\n    function setVesting(ILinearVesting _vesting) external onlyOwner {\n        require(\n            vesting == ILinearVesting(_ZERO_ADDRESS),\n            \"Converter::setVesting: Vesting is already set\"\n        );\n        require(\n            _vesting != ILinearVesting(_ZERO_ADDRESS),\n            \"Converter::setVesting: Cannot Set Zero Vesting Address\"\n        );\n        vader.approve(address(_vesting), type(uint256).max);\n        vesting = _vesting;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @dev Allows a user to convert their Vether to Vader.\n     *\n     * Emits a {Conversion} event indicating the amount of Vether the user\n     * \"burned\" and the amount of Vader that they acquired.\n     *\n     * Here, \"burned\" refers to the action of transferring them to an irrecoverable\n     * address, the {BURN} address.\n     *\n     * Requirements:\n     *\n     * - the caller has approved the contract for the necessary amount via Vether\n     * - the amount specified is non-zero\n     * - the contract has been supplied with the necessary Vader amount to fulfill the trade\n     */\n    function convert(bytes32[] calldata proof, uint256 amount, uint256 minVader)\n        external\n        override\n        returns (uint256 vaderReceived)\n    {\n        require(\n            amount != 0,\n            \"Converter::convert: Non-Zero Conversion Amount Required\"\n        );\n\n        ILinearVesting _vesting = vesting;\n\n        require(\n            _vesting != ILinearVesting(_ZERO_ADDRESS),\n            \"Converter::convert: Vesting is not set\"\n        );\n\n        bytes32 leaf = keccak256(\n            abi.encodePacked(msg.sender, amount, salt, getChainId())\n        );\n        require(\n            !claimed[leaf] && proof.verify(root, leaf),\n            \"Converter::convert: Incorrect Proof Provided\"\n        );\n        claimed[leaf] = true;\n\n        uint256 allowance = vether.allowance(msg.sender, address(this));\n\n        amount = amount > allowance ? allowance : amount;\n\n        // NOTE: FoT is ignored as units are meant to be burned anyway\n        vether.transferFrom(msg.sender, _BURN, amount);\n\n        vaderReceived = amount * _VADER_VETHER_CONVERSION_RATE;\n        require(vaderReceived >= minVader, \"Converter::convert: Vader < min\");\n\n        emit Conversion(msg.sender, amount, vaderReceived);\n\n        uint256 half = vaderReceived / 2;\n        vader.transfer(msg.sender, half);\n        _vesting.vestFor(msg.sender, vaderReceived - half);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n    /*\n     * @dev Returns the {chainId} of current network.\n     **/\n    function getChainId() internal view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Converter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Converter.sol",
                "Type": "Medium Severity",
                "Description": "Users can lock themselves out of being able to convert VETH, becoming stuck with the deprecated asset.",
                "Repair": "Decouple the merkle proof from conversion of VETH to VADER."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"./BasePool.sol\";\n\nimport \"../../interfaces/dex/pool/IVaderPool.sol\";\n\n/*\n * @dev Implementation of {VaderPool} contract.\n *\n * The contract VaderPool inherits from {BasePool} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePool` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPool is IVaderPool, BasePool {\n    /* ========== STATE VARIABLES ========== */\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes contract's state by passing addresses of\n     * native and foreign assets to {BasePool} contract and setting\n     * active status of queue.\n     **/\n    constructor(\n        bool _queueActive,\n        IERC20Extended _nativeAsset,\n        IERC20Extended _foreignAsset\n    ) BasePool(_nativeAsset, _foreignAsset) {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePool} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     **/\n    // NOTE: IL is only covered via router!\n    function burn(uint256 id, address to)\n        external\n        override\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        // NOTE: Validate it behaves as expected for non-18 decimal tokens\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // TODO: Investigate Necessity\n    function toggleQueue() external override onlyOwner {\n        bool _queueActive = !queueActive;\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Ensures only the DAO is able to invoke a particular function by validating that\n     * the owner is the msg.sender, equivalent to the DAO address\n     */\n    function _onlyDAO() private view {\n        require(\n            owner() == _msgSender(),\n            \"BasePool::_onlyDAO: Insufficient Privileges\"\n        );\n    }\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /**\n     * @dev Throws if invoked by anyone else other than the DAO\n     */\n    modifier onlyDAO() {\n        _onlyDAO();\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderPool.mintSynth",
                "Type": "High Severity",
                "Description": "Redemption value of synths can be manipulated to drain VaderPoolV2 of all native assets in the associated pair.",
                "Repair": "Tie the exchange rate use for minting/burning synths to a manipulation resistant oracle."
            },
            {
                "Location": "VaderPool.sol",
                "Type": "No way to remove GasThrottle",
                "Description": "No way to remove GasThrottle from VaderPool after deployment.",
                "Repair": "Either remove GasThrottle.sol entirely or allow governance to turn it off."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/governance/ITimelock.sol\";\nimport \"../interfaces/x-vader/IXVader.sol\";\n\n/**\n * @dev Implementation of {GovernorAlpha} contract.\n *\n * The GovernorAlpha contract allows creation of proposals by anyone\n * by depositing xVader (1000 xVader initially).\n *\n * Anyone can vote on the created proposals utilizing their xVader weight in\n * xVader contract.\n *\n * Only 1 proposal can be active at a time by a particular proposer.\n *\n * A proposal is queued when it succeeds and can be executed after a cool-off\n * time period specified by {delay} in the Timelock contract.\n *\n * A proposal can be cancelled by a {guardian} if it has not been already\n * executed.\n *\n * A proposal can be vetoed by {council} while its state is active/pending\n * and a proposal vetoed with success is also queued at the same time.\n */\ncontract GovernorAlpha {\n    // The name of this contract\n    string public constant NAME = \"Vader Governor Alpha\";\n\n    // The maximum number of actions that can be included in a proposal\n    uint256 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n    // The delay before voting on a proposal may take place, once proposed\n    uint256 public constant VOTING_DELAY = 1;\n\n    // The duration of voting on a proposal, in blocks\n    uint256 public immutable VOTING_PERIOD;\n\n    // The address of the Vader Protocol Timelock\n    ITimelock public timelock;\n\n    // The address of the Governor Guardian\n    address public guardian;\n\n    // The total number of proposals\n    uint256 public proposalCount;\n\n    // address of xVader token\n    IXVader public immutable xVader;\n\n    // address of fee receiver\n    address public feeReceiver;\n\n    // amount of fee deducted when proposing proposal\n    uint256 public feeAmount;\n\n    // address of council that is allowed to veto on proposals\n    address public council;\n\n    /**\n     * @dev {Proposal} struct contains parameters for a single proposal.\n     * id: Unique id for looking up a proposal.\n     * canceled: Flag marking whether the proposal has been canceled.\n     * executed: Flag marking whether the proposal has been executed.\n     * proposer: Creator of the proposal\n     * eta: The timestamp that the proposal will be available for execution, set once the vote succeeds\n     * targets: the ordered list of target addresses for calls to be made\n     * values: The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n     * signatures: The ordered list of function signatures to be called\n     * calldatas: The ordered list of calldata to be passed to each call\n     * startBlock: startBlock: The block at which voting begins: holders must delegate their votes prior to this block\n     * endBlock: The block at which voting ends: votes must be cast prior to this block\n     * forVotes: Current number of votes in favor of this proposal\n     * againstVotes: Current number of votes in opposition to this proposal\n     * vetoStatus: Veto status if the proposal has been vetoed by council in favor or against\n     // C4-Audit Fix for Issue # 141\n     * receipts: Receipts of ballots for the entire set of voters\n     */\n    struct Proposal {\n        uint256 id;\n        bool canceled;\n        bool executed;\n        address proposer;\n        uint256 eta;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint224 forVotes;\n        uint224 againstVotes;\n        VetoStatus vetoStatus;\n        mapping(address => Receipt) receipts;\n    }\n\n    /**\n     * @dev {Receipt} struct contains parameters for a voter against a particular proposal\n     * and is a ballot receipt record for a voter.\n     *\n     * hasVoted: Whether or not a vote has been casted\n     * support: Whether or not the voter supports the proposal\n     * votes: The number of votes the voter had, which were cast\n     */\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n        uint224 votes;\n    }\n\n    /**\n     * @dev {VetoStatus} contains parameters representing if a proposal has been vetoed by council\n     *\n     * hasBeenVetoed: Whether proposal has been vetoed or not\n     // C4-Audit Fix for Issue # 142\n     * support: Whether veto is in favor of or against proposal\n     */\n    struct VetoStatus {\n        bool hasBeenVetoed;\n        bool support;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    // The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    // The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    // The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n        );\n\n    // The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    // An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    // An event emitted when a vote has been cast on a proposal\n    event VoteCast(\n        address voter,\n        uint256 proposalId,\n        bool support,\n        uint256 votes\n    );\n\n    // An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    // An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    // An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    // An event emitted when fee receiver is changed\n    event FeeReceiverChanged(address oldFeeReceiver, address newFeeReceiver);\n\n    // An event emitted when fee amount is changed\n    event FeeAmountChanged(uint256 oldFeeAmount, uint256 newFeeAmount);\n\n    // An event emitted when a proposal has been vetoed by the council\n    event ProposalVetoed(uint256 proposalId, bool support);\n\n    // An event emitted when council is changed\n    event CouncilChanged(address oldCouncil, address newCouncil);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @dev Initializes the contract's state setting xVader, fee receiver,\n     * council and guardian addresses along with the fee amount.\n     *\n     * It performs sanity checks for the address type parameters against zero\n     * address values.\n     */\n    constructor(\n        address guardian_,\n        address xVader_,\n        address feeReceiver_,\n        uint256 feeAmount_,\n        address council_,\n        uint256 votingPeriod_\n    ) {\n        require(\n            xVader_ != address(0),\n            \"GovernorAlpha::constructor: xVader address is zero\"\n        );\n\n        require(\n            guardian_ != address(0) &&\n                feeReceiver_ != address(0) &&\n                council_ != address(0),\n            \"GovernorAlpha::constructor: guardian, feeReceiver or council cannot be zero\"\n        );\n\n        guardian = guardian_;\n        xVader = IXVader(xVader_);\n        feeReceiver = feeReceiver_;\n        feeAmount = feeAmount_;\n        council = council_;\n\n        VOTING_PERIOD = votingPeriod_ == 0\n            ? 17280 // ~3 days in blocks (assuming 15s blocks)\n            : votingPeriod_;\n\n        emit FeeReceiverChanged(address(0), feeReceiver_);\n        emit FeeAmountChanged(0, feeAmount_);\n    }\n\n    /* ========== VIEWS ========== */\n\n    // The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes(uint256 blockNumber) public view returns (uint256) {\n        return (xVader.getPastTotalSupply(blockNumber) * 4) / 100; // 4% of xVader's supply at the time of proposal creation.\n    }\n\n    /**\n     * @dev Returns the actions contained in a proposal with id {proposalId}.\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @dev Returns receipt of the {voter} against the proposal with id {proposalId}.\n     */\n    function getReceipt(uint256 proposalId, address voter)\n        public\n        view\n        returns (Receipt memory)\n    {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @dev Returns the current state of the proposal with id {proposalId}.\n     *\n     * Requirements:\n     * - The {proposalId} should be greater than 0\n     * - The {proposalId} should be less than or equal to {proposalCount}\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"GovernorAlpha::state: invalid proposal id\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) return ProposalState.Canceled;\n\n        if (proposal.vetoStatus.hasBeenVetoed) {\n            // proposal has been vetoed\n            uint256 _eta = proposal.eta;\n\n            // proposal has been vetoed in favor, so considered succeeded\n            if (proposal.vetoStatus.support && _eta == 0)\n                return ProposalState.Succeeded;\n\n            // proposal has been vetoed against, so considered defeated\n            if (_eta == 0) return ProposalState.Defeated;\n        } else {\n            // proposal has not been vetoed, normal flow ensues\n            if (block.number <= proposal.startBlock)\n                return ProposalState.Pending;\n\n            if (block.number <= proposal.endBlock) return ProposalState.Active;\n\n            if (\n                proposal.forVotes <= proposal.againstVotes ||\n                proposal.forVotes < quorumVotes(proposal.startBlock)\n            ) return ProposalState.Defeated;\n\n            if (proposal.eta == 0) return ProposalState.Succeeded;\n        }\n\n        if (proposal.executed) return ProposalState.Executed;\n\n        // C4-Audit Fix for Issue # 177\n        unchecked {\n            if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD())\n                return ProposalState.Expired;\n        }\n\n        return ProposalState.Queued;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @dev Sets timelock state variable. Contracts {GovernorAlpha} and\n     * {Timelock} have circular dependencies upon each other and constructors\n     * cannot be used to set them, hence this function is introduced to set\n     * {Timelock} in {GovernorAlpha} after it has been deployed.\n     *\n     * Requirements:\n     * - only guardian can call this function\n     */\n    function setTimelock(address _timelock) external onlyGuardian {\n        require(\n            _timelock != address(0),\n            \"GovernorAlpha::initTimelock: _timelock cannot be zero address\"\n        );\n        timelock = ITimelock(_timelock);\n    }\n\n    /**\n     * @dev Allows any to make a proposal by depositing {feeAmount} xVader.\n     * It accepts targets along with the values, signature and calldatas\n     * for the actions to perform if the proposal succeeds.\n     *\n     * Requirements:\n     * - targets, values, signatures and calldatas arrays' lengths must be greater\n     // C4-Audit Fix for Issue # 141\n     *   than zero, less than or equal to {proposalMaxOperations} and are the same lengths.\n     * - the caller must approve {feeAmount} xVader to this contract prior to call.\n     * - the caller must not have an active/pending proposal.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256 proposalId) {\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(\n            targets.length != 0,\n            \"GovernorAlpha::propose: must provide actions\"\n        );\n        require(\n            targets.length <= PROPOSAL_MAX_OPERATIONS,\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        xVader.transferFrom(msg.sender, feeReceiver, feeAmount);\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(\n                latestProposalId\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n            );\n        }\n\n        // C4-Audit Fix for Issue # 177\n        uint256 startBlock;\n        uint256 endBlock;\n        unchecked {\n            startBlock = block.number + VOTING_DELAY;\n            endBlock = startBlock + VOTING_PERIOD;\n        }\n\n        proposalId = ++proposalCount;\n        Proposal storage newProposal = proposals[proposalId];\n        newProposal.id = proposalId;\n        newProposal.proposer = msg.sender;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n\n        latestProposalIds[msg.sender] = proposalId;\n\n        emit ProposalCreated(\n            proposalId,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n    }\n\n    /**\n     * @dev Queues a proposal by setting the hashes of its actions in {Timelock} contract.\n     * It also determines 'eta' for the proposal by adding timestamp to {delay} in {Timelock}\n     * and sets it against the proposal in question.\n     *\n     * Requirements:\n     * - the proposal in question must have succeeded either through majority for-votes\n     *   or has been vetoed in its favour.\n     */\n    function queue(uint256 proposalId) public {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        // C4-Audit Fix for Issue # 177\n        uint256 eta;\n        unchecked{\n            eta = block.timestamp + timelock.delay();\n        }\n\n        uint256 length = proposal.targets.length;\n        // C4-Audit Fix for Issue # 81\n        for (uint256 i = 0; i < length; ++i) {\n            _queueOrRevert(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    /**\n     * @dev Executes a proposal after it has been queued and cool-off time has elapsed.\n     * It sets the {executed} status of the proposal to 'true'.\n     *\n     * Requirements:\n     // C4-Audit Fix for Issue # 142\n     * - the proposal in question must have been queued and cool-off time has elapsed\n     * - none of the actions of the proposal revert upon execution\n     */\n    function execute(uint256 proposalId) public payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        uint256 length = proposal.targets.length;\n        // C4-Audit Fix for Issue # 81\n        for (uint256 i = 0; i < length; ++i) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @dev Casts vote by {msg.sender}.\n     * It calls the internal function `_castVote` to perform vote casting.\n     */\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /**\n     * @dev Called by a relayer to cast vote by a message signer.\n     *\n     * Requirements:\n     * - {signatory} retrieved must not be a zero address\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(NAME)),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(BALLOT_TYPEHASH, proposalId, support)\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(\n            signatory != address(0),\n            \"GovernorAlpha::castVoteBySig: invalid signature\"\n        );\n\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /**\n     * @dev Changes the {feeReceiver}.\n     *\n     * Requirements:\n     * - only guardian can call\n     */\n    function changeFeeReceiver(address feeReceiver_) external onlyGuardian {\n        emit FeeReceiverChanged(feeReceiver, feeReceiver_);\n        feeReceiver = feeReceiver_;\n    }\n\n    /**\n     * @dev Changes the {feeAmount}.\n     *\n     * Requirements:\n     * - only guardian can call\n     */\n    function changeFeeAmount(uint256 feeAmount_) external onlyGuardian {\n        emit FeeAmountChanged(feeAmount, feeAmount_);\n        feeAmount = feeAmount_;\n    }\n\n    // C4-Audit Fix for Issue # 142\n    /**\n     * @dev Allows vetoing of a proposal in favor or against it.\n     * It also queues a proposal if it has been vetoed in favor of it and.\n     * sets the veto status of the proposal.\n     *\n     * Requirements:\n     * - can only be called by {council}\n     * - proposal being vetoed must be active or pending\n     * - none of the actions in proposal being vetoed point to the contract\n     *   itself. This to restrict council from vetoing a proposal intended\n     *   to change council.\n     */\n    function veto(uint256 proposalId, bool support) external onlyCouncil {\n        ProposalState _state = state(proposalId);\n        require(\n            _state == ProposalState.Active || _state == ProposalState.Pending,\n            \"GovernorAlpha::veto: Proposal can only be vetoed when active\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        address[] memory _targets = proposal.targets;\n        // C4-Audit Fix for Issue # 81\n        for (uint256 i = 0; i < _targets.length; ++i) {\n            if (_targets[i] == address(this)) {\n                // C4-Audit Fix for Issue # 167\n                bytes memory callData = proposal.calldatas[i];\n                bytes4 sig;\n                assembly {\n                    sig := mload(add(callData, 0x20))\n                }\n                require(\n                    sig != this.changeCouncil.selector,\n                    \"GovernorAlpha::veto: council cannot veto a council changing proposal\"\n                );\n            }\n        }\n\n        VetoStatus storage _vetoStatus = proposal.vetoStatus;\n        _vetoStatus.hasBeenVetoed = true;\n        _vetoStatus.support = support;\n\n        if (support) {\n            queue(proposalId);\n        }\n\n        emit ProposalVetoed(proposalId, support);\n    }\n\n    /**\n     * @dev Changes the {council}.\n     *\n     * Requirements:\n     // C4-Audit Fix for Issue # 142\n     * - can only be called by {Timelock} contract through a non-vetoable proposal\n     */\n    function changeCouncil(address council_) external onlyTimelock {\n        emit CouncilChanged(council, council_);\n        council = council_;\n    }\n\n    /**\n     * @dev Cancels the proposal with id {proposalId}.\n     * It also sets the {canceled} property of {Proposal} to `true` and\n     * removes the proposal's corresponding actions from {Timelock} contract.\n     *\n     * Requirements:\n     * - proposal must not be already executed\n     */\n    function cancel(uint256 proposalId) public onlyGuardian {\n        ProposalState _state = state(proposalId);\n        require(\n            _state != ProposalState.Executed,\n            \"GovernorAlpha::cancel: cannot cancel executed proposal\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        proposal.canceled = true;\n        uint256 length = proposal.targets.length;\n        // C4-Audit Fix for Issue # 81\n        for (uint256 i = 0; i < length; ++i) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @dev Calls {acceptAdmin} on {Timelock} contract and makes the current contract\n     * the admin of {Timelock} contract.\n     *\n     * Requirements:\n     * - only guardian can call it\n     * - current contract must be the `pendingAdmin` in {Timelock} contract\n     */\n    function __acceptAdmin() public onlyGuardian {\n        timelock.acceptAdmin();\n    }\n\n    /**\n     * @dev Gives up the guardian role associated with the contract.\n     *\n     * Requirements:\n     * - only callable by guardian\n     */\n    function __abdicate() public onlyGuardian {\n        guardian = address(0);\n    }\n\n    /**\n     * @dev Queues the transaction to set `pendingAdmin` in {Timelock}.\n     *\n     * Requirements:\n     * - only callable by guardian\n     */\n    function __queueSetTimelockPendingAdmin(\n        address newPendingAdmin,\n        uint256 eta\n    ) public onlyGuardian {\n        timelock.queueTransaction(\n            address(timelock),\n            0,\n            \"setPendingAdmin(address)\",\n            abi.encode(newPendingAdmin),\n            eta\n        );\n    }\n\n    /**\n     * @dev Executes the transaction to set `pendingAdmin` in {Timelock}.\n     *\n     * Requirements:\n     * - only callable by guardian\n     */\n    function __executeSetTimelockPendingAdmin(\n        address newPendingAdmin,\n        uint256 eta\n    ) public onlyGuardian {\n        timelock.executeTransaction(\n            address(timelock),\n            0,\n            \"setPendingAdmin(address)\",\n            abi.encode(newPendingAdmin),\n            eta\n        );\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /**\n     * @dev Queues a transaction in {Timelock}.\n     *\n     * Requirements:\n     * - transaction is not already queued in {Timelock}\n     */\n    function _queueOrRevert(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(\n                keccak256(abi.encode(target, value, signature, data, eta))\n            ),\n            \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @dev Casts vote against proposal with id {proposalId}.\n     * It gets the voting weight of voter from {xVader} token contract corresponding to\n     * the blocknumber when proposal started and adds those votes to either\n     * {forVotes} or {againstVotes} property of {Proposal} depending upon if\n     * the voter is voting in favor of or against the proposal.\n     *\n     * Requirements:\n     * - proposal being voted must be active\n     * - voter has not already voted against the proposal\n     */\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorAlpha::_castVote: voting is closed\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n\n        require(\n            !receipt.hasVoted,\n            \"GovernorAlpha::_castVote: voter already voted\"\n        );\n\n        // optimistically casting to uint224 as xVader contract performs the checks for\n        // votes to not overflow uint224.\n        uint224 votes = uint224(\n            xVader.getPastVotes(voter, proposal.startBlock)\n        );\n\n        // C4-Audit Fix for Issue # 177\n        unchecked {\n            if (support) {\n                proposal.forVotes = proposal.forVotes + votes;\n            } else {\n                proposal.againstVotes = proposal.againstVotes + votes;\n            }\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    // gets the chainid from current network\n    function getChainId() internal view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n    // C4-Audit Fix for Issue # 142\n    // ensures only {guardian} is able to call a particular function.\n    function _onlyGuardian() private view {\n        require(\n            msg.sender == guardian,\n            \"GovernorAlpha::_onlyGuardian: only guardian can call\"\n        );\n    }\n\n    // C4-Audit Fix for Issue # 142\n    // ensures only {timelock} is able to call a particular function.\n    function _onlyTimelock() private view {\n        require(\n            msg.sender == address(timelock),\n            \"GovernorAlpha::_onlyTimelock: only timelock can call\"\n        );\n    }\n\n    // C4-Audit Fix for Issue # 142\n    // ensures only {council} is able to call a particular function.\n    function _onlyCouncil() private view {\n        require(\n            msg.sender == council,\n            \"GovernorAlpha::_onlyCouncil: only council can call\"\n        );\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /**\n     * @dev Throws if invoked by anyone else other than the {guardian}\n     */\n    modifier onlyGuardian() {\n        _onlyGuardian();\n        _;\n    }\n\n    /**\n     * @dev Throws if invoked by anyone else other than the {timelock}\n     */\n    modifier onlyTimelock() {\n        _onlyTimelock();\n        _;\n    }\n\n    /**\n     * @dev Throws if invoked by anyone else other than the {council}\n     */\n    modifier onlyCouncil() {\n        _onlyCouncil();\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "GovernorAlpha.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GovernorAlpha.veto",
                "Type": "High Severity",
                "Description": "Council veto protection does not work.",
                "Repair": "Hash the function signatures to calculate function selectors and then check those rather than the calldata."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/shared/IERC20Extended.sol\";\nimport \"../interfaces/tokens/IUSDV.sol\";\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\n// TBD\ncontract USDV is IUSDV, ProtocolConstants, ERC20, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20Extended;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The VADER token used for burns and mints\n    IERC20Extended public immutable vader;\n\n    // The LBT pricing mechanism for the conversion\n    ILiquidityBasedTWAP public lbt;\n\n    // The exchange fee if any applied to burns and mints\n    uint256 public exchangeFee;\n\n    // The 24 hour limit on USDV mints\n    uint256 public dailyLimit = type(uint256).max;\n\n    // The current cycle end timestamp\n    uint256 public cycleTimestamp;\n\n    // The current cycle cumulative mints\n    uint256 public cycleMints;\n\n    // All mint/burn locks\n    mapping(address => Lock[]) public locks;\n\n    // Guardian Account\n    address public guardian;\n\n    // Lock system\n    bool private isLocked;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20Extended _vader) ERC20(\"Vader USD\", \"USDV\") {\n        require(\n            _vader != IERC20Extended(_ZERO_ADDRESS),\n            \"USDV::constructor: Improper Configuration\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function mint(uint256 vAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 uAmount)\n    {\n        uint256 vPrice = lbt.getVaderPrice();\n\n        vader.transferFrom(msg.sender, address(this), vAmount);\n        vader.burn(vAmount);\n\n        uAmount = (vPrice * vAmount) / 1e18;\n\n        if (cycleTimestamp <= block.timestamp) {\n            cycleTimestamp = block.timestamp + 24 hours;\n            cycleMints = uAmount;\n        } else {\n            cycleMints += uAmount;\n            require(\n                cycleMints <= dailyLimit,\n                \"USDV::mint: 24 Hour Limit Reached\"\n            );\n        }\n\n        if (exchangeFee != 0) {\n            uint256 fee = (uAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            uAmount = uAmount - fee;\n            _mint(owner(), fee);\n        }\n\n        _mint(address(this), uAmount);\n\n        _createLock(LockTypes.USDV, uAmount);\n    }\n\n    function burn(uint256 uAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 vAmount)\n    {\n        uint256 uPrice = lbt.getUSDVPrice();\n\n        _burn(msg.sender, uAmount);\n\n        vAmount = (uPrice * uAmount) / 1e18;\n\n        if (exchangeFee != 0) {\n            uint256 fee = (vAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            vAmount = vAmount - fee;\n            vader.mint(owner(), fee);\n        }\n\n        vader.mint(address(this), vAmount);\n\n        _createLock(LockTypes.VADER, vAmount);\n    }\n\n    function claim(uint256 i) external onlyWhenNotLocked returns (uint256) {\n        Lock[] storage userLocks = locks[msg.sender];\n        Lock memory lock = userLocks[i];\n\n        require(lock.release <= block.timestamp, \"USDV::claim: Vesting\");\n\n        uint256 last = userLocks.length - 1;\n        if (i != last) {\n            userLocks[i] = userLocks[last];\n        }\n\n        userLocks.pop();\n\n        if (lock.token == LockTypes.USDV)\n            _transfer(address(this), msg.sender, lock.amount);\n        else vader.transfer(msg.sender, lock.amount);\n\n        emit LockClaimed(msg.sender, lock.token, lock.amount, lock.release);\n\n        return lock.amount;\n    }\n\n    function claimAll()\n        external\n        onlyWhenNotLocked\n        returns (uint256 usdvAmount, uint256 vaderAmount)\n    {\n        Lock[] memory userLocks = locks[msg.sender];\n        delete locks[msg.sender];\n\n        for (uint256 i = 0; i < userLocks.length; i++) {\n            Lock memory lock = userLocks[i];\n\n            require(lock.release <= block.timestamp, \"USDV::claimAll: Vesting\");\n\n            if (lock.token == LockTypes.USDV) {\n                _transfer(address(this), msg.sender, lock.amount);\n                usdvAmount += lock.amount;\n            } else {\n                vader.transfer(msg.sender, lock.amount);\n                vaderAmount += lock.amount;\n            }\n\n            emit LockClaimed(msg.sender, lock.token, lock.amount, lock.release);\n        }\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setLBTwap(ILiquidityBasedTWAP _lbt) external onlyOwner {\n        require(\n            _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"USDV::initialize: Improper Configuration\"\n        );\n        lbt = _lbt;\n    }\n\n    function setFee(uint256 _exchangeFee) external onlyOwner {\n        require(\n            _exchangeFee <= _MAX_BASIS_POINTS,\n            \"USDV::setFee: Fee Out of Bounds\"\n        );\n        emit ExchangeFeeChanged(exchangeFee, _exchangeFee);\n        exchangeFee = _exchangeFee;\n    }\n\n    function setDailyLimit(uint256 _dailyLimit) external onlyOwner {\n        emit DailyLimitChanged(dailyLimit, _dailyLimit);\n        dailyLimit = _dailyLimit;\n    }\n\n    function setGuardian(address _guardian) external onlyOwner {\n        require(_guardian != address(0), \"USDV::setGuardian: Zero address\");\n        guardian = _guardian;\n    }\n\n    function setLock(bool _lock) external {\n        require(\n            msg.sender == owner() || msg.sender == guardian,\n            \"USDV::setLock: Insufficient Privileges\"\n        );\n        isLocked = _lock;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    function _createLock(LockTypes lockType, uint256 amount) private {\n        uint256 release = block.timestamp + lbt.maxUpdateWindow();\n\n        locks[msg.sender].push(Lock(lockType, amount, release));\n\n        emit LockCreated(msg.sender, lockType, amount, release);\n    }\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyWhenNotLocked() {\n        require(!isLocked);\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "USDV.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "USDV.mint and USDV.burn",
                "Type": "High Severity",
                "Description": "USDV.sol Mint and Burn Amounts Are Incorrect.",
                "Repair": "Consider utilising both getVaderPrice and getUSDVPrice when calculating the expected uAmount and vAmount to mint or burn."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function _addVaderPair",
                "Type": "totalLiquidityWeight is updated when adding new token pairs which skews price data",
                "Description": "Newly added token pairs will increase pastTotalLiquidityWeight while leaving pastLiquidityWeights underrepresented.",
                "Repair": "Remove the line totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation; in _addVaderPair"
            },
            {
                "Location": "function syncVaderPrice",
                "Type": "Vader TWAP averages wrong",
                "Description": "An attacker can break the price functions and make them revert. _totalLiquidityWeight never increases and the storage variable totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight = 0; is set to zero.",
                "Repair": "Move the _totalLiquidityWeight += currentLiquidityEvaluation and the pastLiquidityWeights[i] = pastLiquidityEvaluation assignments before the continue."
            }
        ]
    }
]