[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BuyCrowdfund and CollectionBuyCrowdfund contracts",
                "Type": "Fund Theft",
                "Description": "An attacker can list an NFT they own and inflate to zero all users' contributions, keeping the NFT and all the money.",
                "Repair": "Disable the option to have unlimited maximumPrice for BuyCrowdfund and CollectionBuyCrowdfund contracts"
            },
            {
                "Location": "TokenDistributor.sol",
                "Type": "Reentrancy",
                "Description": "ERC777 tokensToSend hook can be exploited to drain contract.",
                "Repair": "Do not allow reentrancy in these functions"
            },
            {
                "Location": "Crowdfund.sol and TokenDistributor.sol",
                "Type": "Collision Attack",
                "Description": "Only part of keccak256() is used as hash, making it susceptible to collision attacks.",
                "Repair": "Use the standard, 32-bytes, output of keccak256()"
            },
            {
                "Location": "ProposalExecutionEngine.sol, FractionalizeProposal.sol",
                "Type": "Majority Attack",
                "Description": "A majority attack can steal precious NFT from the party by crafting and chaining two proposals.",
                "Repair": "Enforce a minimum cooldown between proposals. A specific fix here would be to call distribute() at the end of FractionalizeProposal so that there is no window to steal the funds."
            },
            {
                "Location": "BuyCrowdfund / CollectionBuyCrowdfund",
                "Type": "Majority Attack",
                "Description": "Early contributor can always become majority of crowdfund leading to rugging risks.",
                "Repair": "Add a Crowdfund property called minimumPrice, which will be visible to all. Buy() function should not accept NFT price < minimumPrice."
            },
            {
                "Location": "Crowdfund.sol, BuyCrowdfundBase.sol",
                "Type": "DOS Attack",
                "Description": "Attacker can DOS private party by donating ETH then calling buy.",
                "Repair": "Permission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper. Cap the callValue (and therefore final price) to totalContributions."
            },
            {
                "Location": "AuctionCrowdfund contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "If the contract was bid on before the NFT was gifted to the contract, lastBid will not be totalContributions",
                "Repair": "Check if the NFT was acquired for free by verifying that the contract balance is equal to totalContributions before determining whether the NFT was gifted to the contract or not"
            },
            {
                "Location": "Crowdfund contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "Possibility to burn all ETH in Crowdfund under some circumstances",
                "Repair": "Disallow an initial contribution when opts.initialContributor is not set"
            },
            {
                "Location": "AuctionCrowdfund contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "NFT Owner can stuck Crowdfund user funds",
                "Repair": "Remove the line lastBid_ = totalContributions; and let it be the last bid amount which crowdfund users actually bided with"
            },
            {
                "Location": "AuctionCrowdfund's bid() function",
                "Type": "Smart Contract Vulnerability",
                "Description": "An attacker can force AuctionCrowdfunds to bid their entire contribution up to maxBid.",
                "Repair": "Introduce a new option variable to AuctionCrowdfunds called speedBump. Inside the bid() function, calculate seconds since last bid, multiplied by the price change factor. This product must be smaller than the chosen speedBump. Using this scheme, the protocol would have resistance to sudden bid spikes. Optionally, allow a majority funder to override the speed bump."
            },
            {
                "Location": "ArbitraryCallsProposal.sol and ListOnOpenseaProposal.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "Safeguards can be bypassed by cancelling in-progress proposal allowing the majority to steal NFT.",
                "Repair": "Block calls to opensea.validate() in Arbitrary call proposals. When a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc."
            },
            {
                "Location": "transferEth function",
                "Type": "Smart Contract Vulnerability",
                "Description": "Calling transferEth function can revert if receiver input corresponds to a contract that is unable to receive ETH through its receive or fallback function.",
                "Repair": "Use WETH to deposit the corresponding ETH amount, and the deposited amount can be transferred to the receiver contract. Escrow the ETH refund and/or the governance NFT to be claimed by the contributor later (possibly to a different address) if either transfer fails."
            },
            {
                "Location": "ListOnOpenseaProposal contract",
                "Type": "Majority attack",
                "Description": "A majority attack can easily bypass Zora auction stage and steal the NFT from the party.",
                "Repair": "Pass a revertOnFail flag to _settleZoraAuction and handle it differently for each proposal type"
            },
            {
                "Location": "Crowdfund.sol and PartyGovernance.sol contracts",
                "Type": "Rounding error",
                "Description": "Possible that unanimous votes is unachievable",
                "Repair": "Ensure that the individual votingPower sum to the total contribution"
            },
            {
                "Location": "ArbitraryCallsProposal contract",
                "Type": "Value leakage",
                "Description": "Excess eth is not refunded",
                "Repair": "Refund the remaining ethAvailable back to the user at the end of _executeArbitraryCalls function"
            },
            {
                "Location": "PartyGovernanceNFT contract",
                "Type": "Double voting",
                "Description": "Can vote multiple times by transferring NFT in same block as proposal",
                "Repair": "Query the voting power at values.proposedTime 1"
            },
            {
                "Location": "Crowdfund.sol burn() function, PartyGovernanceNFT.sol mint() and _adjustVotingPower() functions",
                "Type": "Smart Contract Logic",
                "Description": "Previously nominated delegate can reset the delegation.",
                "Repair": "Add a check to see if the delegate is already set before resetting it in the mint() function or track the most recent request via contribute()/delegateVotingPower() calls timestamps. "
            },
            {
                "Location": "AuctionCrowdfund.sol _buy() function",
                "Type": "Smart Contract Logic",
                "Description": "The settledPrice maybe exceed maximumPrice.",
                "Repair": "Cap the callValue to maximumPrice in the _buy() function."
            },
            {
                "Location": "AuctionCrowdfund.sol _buy() function",
                "Type": "Smart Contract Logic",
                "Description": "Maximum bid will always be used in Auction.",
                "Repair": "Restrict who can call the bid() function to host-only in some crowdfunds."
            }
        ]
    }
]