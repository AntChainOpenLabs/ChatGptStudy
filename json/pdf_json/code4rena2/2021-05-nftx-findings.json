[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.8;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXEligibility.sol\";\nimport \"./interface/INFTXEligibilityManager.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/IPrevNftxContract.sol\";\nimport \"./interface/IRewardDistributionToken.sol\";\nimport \"./token/ERC20BurnableUpgradeable.sol\";\nimport \"./token/ERC20FlashMintUpgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./token/IERC721Upgradeable.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/SafeMathUpgradeable.sol\";\nimport \"./util/ReentrancyGuardUpgradeable.sol\";\nimport \"./util/EnumerableSetUpgradeable.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract NFTXVaultUpgradeable is\n    PausableUpgradeable,\n    ERC20BurnableUpgradeable,\n    ERC20FlashMintUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC721HolderUpgradeable,\n    ERC1155HolderUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    uint256 constant base = 10**18;\n\n    uint256 public vaultId;\n    address public manager;\n    address public assetAddress;\n    INFTXVaultFactory public vaultFactory;\n    INFTXEligibility public eligibilityStorage;\n\n    uint256 randNonce;\n    uint256 public mintFee;\n    uint256 public redeemFee;\n    uint256 public directRedeemFee;\n    uint256 public swapFee;\n\n    // Purposely putting these on a new slot to make sure they're together.\n    bool public is1155;\n    bool public allowAllItems;\n    bool public enableMint;\n    bool public enableRedeem;\n    bool public enableDirectRedeem;\n    bool public enableSwap;\n    bool[20] _bool_gap;\n\n    string public description;\n\n    EnumerableSetUpgradeable.UintSet holdings;\n    mapping(uint256 => uint256) quantity1155;\n\n    event VaultInit(\n        uint256 indexed vaultId,\n        address assetAddress,\n        bool is1155,\n        bool allowAllItems\n    );\n\n    event ManagerSet(address manager);\n    event EligibilityDeployed(address eligibilityAddr);\n\n    event EnableMintUpdated(bool enabled);\n    event EnableRedeemUpdated(bool enabled);\n    event EnableDirectRedeemUpdated(bool enabled);\n    event EnableSwapUpdated(bool enabled);\n\n    event MintFeeUpdated(uint256 mintFee);\n    event RedeemFeeUpdated(uint256 redeemFee);\n    event DirectRedeemFeeUpdated(uint256 directRedeemFee);\n    event SwapFeeUpdated(uint256 swapFee);\n\n    event Minted(uint256[] nftIds, uint256[] amounts, address sender);\n    event Redeemed(uint256[] nftIds, address sender);\n    event Swapped(\n        uint256[] nftIds,\n        uint256[] amounts,\n        uint256[] specificIds,\n        address sender\n    );\n\n    constructor() public {\n        __Pausable_init();\n        __ERC20_init(\"\", \"\");\n        __ERC20Burnable_init_unchained();\n        __ERC20FlashMint_init();\n    }\n\n    function __NFTXVault_init(\n        string memory _name,\n        string memory _symbol,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) public initializer {\n        __Pausable_init();\n        __ERC20_init(_name, _symbol);\n        __ERC20Burnable_init_unchained();\n        __ERC20FlashMint_init();\n        assetAddress = _assetAddress;\n        vaultFactory = INFTXVaultFactory(msg.sender);\n        vaultId = vaultFactory.numVaults();\n        is1155 = _is1155;\n        allowAllItems = _allowAllItems;\n        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);\n    }\n\n    function finalizeFund() external virtual {\n        setManager(address(0));\n    }\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRedeem,\n        bool _enableDirectRedeem,\n        bool _enableSwap\n    ) external virtual {\n        onlyPrivileged();\n        enableMint = _enableMint;\n        enableRedeem = _enableRedeem;\n        enableDirectRedeem = _enableDirectRedeem;\n        enableSwap = _enableSwap;\n\n        emit EnableMintUpdated(enableMint);\n        emit EnableRedeemUpdated(enableRedeem);\n        emit EnableDirectRedeemUpdated(enableDirectRedeem);\n        emit EnableSwapUpdated(enableSwap);\n    }\n\n    // Should we do defaults?\n    function setFees(\n        uint256 _mintFee,\n        uint256 _redeemFee,\n        uint256 _directRedeemFee,\n        uint256 _swapFee\n    ) external virtual {\n        onlyPrivileged();\n        mintFee = _mintFee;\n        redeemFee = _redeemFee;\n        directRedeemFee = _directRedeemFee;\n        swapFee = _swapFee;\n\n        emit MintFeeUpdated(_mintFee);\n        emit RedeemFeeUpdated(_redeemFee);\n        emit DirectRedeemFeeUpdated(_directRedeemFee);\n        emit SwapFeeUpdated(_swapFee);\n    }\n\n    // This function alls for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow \n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external virtual returns (address) {\n        onlyPrivileged();\n        INFTXEligibilityManager eligManager = INFTXEligibilityManager(\n            vaultFactory.eligibilityManager()\n        );\n        address _eligibility = eligManager.deployEligibility(\n            moduleIndex,\n            initData\n        );\n        setEligibilityStorage(_eligibility);\n        return _eligibility;\n    }\n\n    // This function allows for the manager to set their own arbitrary eligibility contract.\n    // Once eligiblity is set, it cannot be unset or changed.\n    function setEligibilityStorage(address _newEligibility) public virtual {\n        onlyPrivileged();\n        require(\n            address(eligibilityStorage) == address(0),\n            \"NFTXVault: eligibility already set\"\n        );\n        eligibilityStorage = INFTXEligibility(_newEligibility);\n        // Toggle this to let the contract know to check eligibility now.\n        allowAllItems = false;\n        emit EligibilityDeployed(address(_newEligibility));\n    }\n\n    // The manager has control over options like fees and features\n    function setManager(address _manager) public virtual {\n        onlyPrivileged();\n        manager = _manager;\n        emit ManagerSet(_manager);\n    }\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external virtual returns (uint256) {\n        return mintTo(tokenIds, amounts, msg.sender);\n    }\n\n    function mintTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        address to\n    ) public virtual nonReentrant returns (uint256) {\n        onlyOwnerIfPaused(1);\n        require(enableMint, \"Minting not enabled\");\n        require(allValidNFTs(tokenIds), \"NFTXVault: not eligible\");\n        uint256 count = receiveNFTs(tokenIds, amounts);\n\n        uint256 fee = mintFee.mul(count);\n        _mint(to, base.mul(count).sub(fee));\n        _distributeFees(fee);\n\n        emit Minted(tokenIds, amounts, to);\n        return count;\n    }\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        virtual\n        returns (uint256[] memory)\n    {\n        return redeemTo(amount, specificIds, msg.sender);\n    }\n\n    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        onlyOwnerIfPaused(2);\n        require(enableRedeem, \"Redeeming not enabled\");\n        require(\n            specificIds.length == 0 || enableDirectRedeem,\n            \"Direct redeem not enabled\"\n        );\n        uint256 fee = directRedeemFee.mul(specificIds.length).add(\n            redeemFee.mul(amount.sub(specificIds.length))\n        );\n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burnFrom(msg.sender, base.mul(amount).add(fee));\n        _distributeFees(fee);\n\n        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);\n        afterRedeemHook(redeemedIds);\n\n        emit Redeemed(redeemedIds, to);\n        return redeemedIds;\n    }\n\n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external virtual nonReentrant returns (uint256[] memory) {\n        return swapTo(tokenIds, amounts, specificIds, msg.sender);\n    }\n\n    function swapTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        uint256[] memory specificIds,\n        address to\n    ) public virtual returns (uint256[] memory) {\n        onlyOwnerIfPaused(3);\n        require(enableSwap, \"Swapping not enabled\");\n        require(\n            specificIds.length == 0 || enableDirectRedeem,\n            \"Direct redeem not enabled\"\n        );\n        uint256 count = receiveNFTs(tokenIds, amounts);\n        uint256 fee = directRedeemFee.mul(specificIds.length).add(\n            swapFee.mul(count.sub(specificIds.length))\n        );\n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burnFrom(msg.sender, fee);\n        _distributeFees(fee);\n        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);\n        emit Swapped(tokenIds, amounts, specificIds, to);\n        return ids;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override returns (bool) {\n        onlyOwnerIfPaused(4);\n        super.flashLoan(receiver, token, amount, data);\n    }\n\n    function allValidNFTs(uint256[] memory tokenIds)\n        public\n        view\n        returns (bool)\n    {\n        // add allow all check here\n        if (allowAllItems) {\n            return true;\n        }\n\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return false;\n        }\n        return _eligibilityStorage.checkAllEligible(tokenIds);\n    }\n\n    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.\n    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return;\n        }\n        _eligibilityStorage.afterRedeemHook(tokenIds);\n    }\n\n    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)\n        internal\n        virtual\n        returns (uint256)\n    {\n        if (is1155) {\n            // This is technically a check, so placing it before the effect.\n            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(\n                msg.sender,\n                address(this),\n                tokenIds,\n                amounts,\n                \"\"\n            );\n\n            uint256 count;\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                uint256 amount = amounts[i];\n                if (quantity1155[tokenId] == 0) {\n                    holdings.add(tokenId);\n                }\n                quantity1155[tokenId] = quantity1155[tokenId].add(amount);\n                count = count.add(amount);\n            }\n            return count;\n        } else {\n            IERC721Upgradeable erc721 = IERC721Upgradeable(assetAddress);\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                erc721.safeTransferFrom(msg.sender, address(this), tokenId);\n                holdings.add(tokenId);\n            }\n            return tokenIds.length;\n        }\n    }\n\n    function withdrawNFTsTo(\n        uint256 amount,\n        uint256[] memory specificIds,\n        address to\n    ) internal virtual returns (uint256[] memory) {\n        bool _is1155 = is1155;\n        address _assetAddress = assetAddress;\n        uint256[] memory redeemedIds = new uint256[](amount);\n\n        for (uint256 i = 0; i < amount; i++) {\n            uint256 tokenId = i < specificIds.length\n                ? specificIds[i]\n                : getRandomTokenIdFromFund();\n            redeemedIds[i] = tokenId;\n\n            if (_is1155) {\n                IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    to,\n                    tokenId,\n                    1,\n                    \"\"\n                );\n\n                quantity1155[tokenId] = quantity1155[tokenId].sub(1);\n                if (quantity1155[tokenId] == 0) {\n                    holdings.remove(tokenId);\n                }\n            } else {\n                IERC721Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    to,\n                    tokenId\n                );\n                holdings.remove(tokenId);\n            }\n        }\n        return redeemedIds;\n    }\n\n    function _distributeFees(uint256 amount) internal virtual {\n        // Mint fees directly to the distributor and distribute.\n        if (amount > 0) {\n            address feeReceiver = vaultFactory.feeReceiver();\n            _mint(feeReceiver, amount);\n            INFTXFeeDistributor(feeReceiver).distribute(vaultId);\n        }\n    }\n\n    function getRandomTokenIdFromFund() internal virtual returns (uint256) {\n        uint256 randomIndex = getPseudoRand(holdings.length());\n        return holdings.at(randomIndex);\n    }\n\n    function getPseudoRand(uint256 modulus) internal virtual returns (uint256) {\n        randNonce += 1;\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(blockhash(block.number - 1), randNonce)\n                )\n            ) %\n            modulus;\n    }\n\n    function onlyPrivileged() internal view {\n        if (manager == address(0)) {\n            require(msg.sender == owner(), \"Not owner\");\n        } else {\n            require(msg.sender == manager, \"Not manager\");\n        }\n    }\n\n    // TODO: recount this.\n    uint256[25] ___gap;\n}\n\n\n",
        "CodeNames": [
            "NFTXVaultUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXVaultUpgradeable.sol",
                "Type": "Direct redeem fee circumvention",
                "Description": "A malicious actor can revert a transaction if they did not get the NFT they wanted, combined with utilizing Flashbots miners which do not publish transactions which revert with FlashbotsCheckAndSend, there would be no cost to constantly attempting this every block or after the nonce is updated from getPseudoRand().",
                "Repair": "Use a commit-reveal pattern for NFT swaps and redemptions"
            },
            {
                "Location": "NFTXVaultUpgradeable.sol",
                "Type": "Brute-forcing randomization",
                "Description": "Users can brute-force the on-chain randomization (using nonce + blockhash) by repeatedly trying to redeem/swap from a contract, checking the NFT IDs returned from the function and reverting the transaction if those are not the NFT IDs of specific interest.",
                "Repair": "Consider only EOA (external only account) for redeem/swap operations to prevent brute-forcing via contracts. Alternatively, make the user commit to pseudo-random IDs before revealing them."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./token/IERC20Upgradeable.sol\";\nimport \"./util/SafeERC20Upgradeable.sol\";\nimport \"./util/SafeMathUpgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract NFTXFeeDistributor is INFTXFeeDistributor, PausableUpgradeable {\n\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  bool public distributionPaused;\n\n  address public override nftxVaultFactory;\n  address public override lpStaking;\n  address public override treasury;\n  uint256 public override defaultTreasuryAlloc;\n  uint256 public override defaultLPAlloc;\n\n  mapping(uint256 => uint256) public override allocTotal;\n  mapping(uint256 => uint256) public override specificTreasuryAlloc;\n  mapping(uint256 => FeeReceiver[]) feeReceivers;\n\n  event AddFeeReceiver(uint256 vaultId, address receiver, uint256 allocPoint);\n  event FeeReceiverAllocChange(uint256 vaultId, address receiver, uint256 allocPoint);\n  event RemoveFeeReceiver(uint256 vaultId, address receiver);\n  \n  function __FeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {\n    __Pausable_init();\n    lpStaking = _lpStaking;\n    treasury = _treasury; \n    defaultTreasuryAlloc = 0.2 ether;\n    defaultLPAlloc = 0.5 ether;\n  }\n\n  function rescue(address token) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n    IERC20Upgradeable(token).transfer(msg.sender, balance);\n  }\n\n  function distribute(uint256 vaultId) external override {\n    require(nftxVaultFactory != address(0));\n    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    if (tokenBalance <= 10**9) {\n      return;\n    }\n    // Leave some balance for dust since we know we have more than 10**9.\n    tokenBalance -= 1000;\n    \n    uint256 _treasuryAlloc = specificTreasuryAlloc[vaultId];\n    if (_treasuryAlloc == 0) {\n      _treasuryAlloc = defaultTreasuryAlloc;\n    }\n\n    uint256 _allocTotal = allocTotal[vaultId] + _treasuryAlloc;\n    uint256 amountToSend = tokenBalance * _treasuryAlloc / _allocTotal;\n    amountToSend = amountToSend > tokenBalance ? tokenBalance : amountToSend;\n    IERC20Upgradeable(_vault).safeTransfer(treasury, amountToSend);\n\n    if (distributionPaused) {\n      return;\n    } \n\n    FeeReceiver[] memory _feeReceivers = feeReceivers[vaultId];\n    for (uint256 i = 0; i < _feeReceivers.length; i++) {\n      _sendForReceiver(_feeReceivers[i], vaultId, _vault, tokenBalance, _allocTotal);\n    } \n  }\n\n  function addReceiver(uint256 _vaultId, uint256 _allocPoint, address _receiver, bool _isContract) external override onlyOwner  {\n    _addReceiver(_vaultId, _allocPoint, _receiver, _isContract);\n  }\n\n  function initializeVaultReceivers(uint256 _vaultId) external override {\n    require(msg.sender == nftxVaultFactory, \"FeeReceiver: not factory\");\n    _addReceiver(_vaultId, defaultLPAlloc, lpStaking, true);\n    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);\n  }\n\n  function changeReceiverAlloc(uint256 _vaultId, uint256 _receiverIdx, uint256 _allocPoint) external override onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_vaultId][_receiverIdx];\n    allocTotal[_vaultId] -= feeReceiver.allocPoint;\n    feeReceiver.allocPoint = _allocPoint;\n    allocTotal[_vaultId] += _allocPoint;\n    emit FeeReceiverAllocChange(_vaultId, feeReceiver.receiver, _allocPoint);\n  }\n\n  function changeReceiverAddress(uint256 _vaultId, uint256 _receiverIdx, address _address, bool _isContract) external override onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_vaultId][_receiverIdx];\n    feeReceiver.receiver = _address;\n    feeReceiver.isContract = _isContract;\n  }\n\n  function removeReceiver(uint256 _vaultId, uint256 _receiverIdx) external override onlyOwner {\n    FeeReceiver[] storage feeReceiversForVault = feeReceivers[_vaultId];\n    uint256 arrLength = feeReceiversForVault.length;\n    require(_receiverIdx < arrLength, \"FeeDistributor: Out of bounds\");\n    emit RemoveFeeReceiver(_vaultId, feeReceiversForVault[_receiverIdx].receiver);\n    allocTotal[_vaultId] -= feeReceiversForVault[_receiverIdx].allocPoint;\n    feeReceiversForVault[_receiverIdx] = feeReceiversForVault[arrLength-1];\n    feeReceiversForVault.pop();\n  }\n\n  function setTreasuryAddress(address _treasury) external override onlyOwner {\n    treasury = _treasury;\n  }\n\n  function setDefaultTreasuryAlloc(uint256 _allocPoint) external override onlyOwner {\n    defaultTreasuryAlloc = _allocPoint;\n  }\n\n  function setSpecificTreasuryAlloc(uint256 vaultId, uint256 _allocPoint) external override onlyOwner {\n    specificTreasuryAlloc[vaultId] = _allocPoint;\n  }\n\n  function setLPStakingAddress(address _lpStaking) external override onlyOwner {\n    lpStaking = _lpStaking;\n  }\n\n  function setNFTXVaultFactory(address _factory) external override onlyOwner {\n    nftxVaultFactory = _factory;\n  }\n\n  function setDefaultLPAlloc(uint256 _allocPoint) external override onlyOwner {\n    defaultLPAlloc = _allocPoint;\n  }\n\n  function pauseFeeDistribution(bool pause) external onlyOwner {\n    distributionPaused = pause;\n  }\n\n  function rescueTokens(uint256 _address) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\n    IERC20Upgradeable(_address).transfer(msg.sender, balance);\n  }\n\n  function _addReceiver(uint256 _vaultId, uint256 _allocPoint, address _receiver, bool _isContract) internal  {\n    allocTotal[_vaultId] += _allocPoint;\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\n    feeReceivers[_vaultId].push(_feeReceiver);\n    emit AddFeeReceiver(_vaultId, _receiver, _allocPoint);\n  }\n\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 _tokenBalance, uint256 _allocTotal) internal {\n    uint256 amountToSend = _tokenBalance * _receiver.allocPoint / _allocTotal;\n    // If we're at this point we know we have more than enough to perform this safely.\n    uint256 balance = IERC20Upgradeable(_vault).balanceOf(address(this)) - 1000;\n    amountToSend = amountToSend > balance ? balance : amountToSend;\n    if (_receiver.isContract) {\n      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n      // If the receive is not properly processed, send it to the treasury instead.\n       \n      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n      (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);\n      bool tokensReceived = abi.decode(returnData, (bool));\n      if (!success || !tokensReceived) {\n        console.log(\"treasury fallback\");\n        IERC20Upgradeable(_vault).safeTransfer(treasury, amountToSend);\n      }\n    } else {\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    }\n  }\n} \n\n",
        "CodeNames": [
            "NFTXFeeDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTXFeeDistributor",
                "Type": "Fee distribution re-entrancy",
                "Description": "A smart contract with a malicious receiveRewards function can re-enter the distribute function with the same vault ID, thereby causing the exploit.",
                "Repair": "Incorporate re-entrancy protection into the distribute function by not trusting return data from externally called contracts and only utilizing whether the transaction succeeds to determine if the treasury fallback should be called."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Withdrawal of staking token and rescue of arbitrary tokens sent to the FeeDistributor contract",
                "Type": "Unchecked return value for token transfers",
                "Description": "Failure to check the return value of token transfers or to use safeTransfer/safeTransferFrom can cause silent failures of transfers and affect token accounting in contract.",
                "Repair": "Use safeTransfer/safeTransferFrom or require() consistently."
            }
        ]
    }
]