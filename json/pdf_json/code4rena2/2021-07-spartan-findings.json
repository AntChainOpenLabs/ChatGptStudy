[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function",
                "Type": "Missing slippage checks",
                "Description": "There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated.This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%.",
                "Repair": "Add a minimum amount out parameter. The function reverts if the minimum amount isn't obtained."
            },
            {
                "Location": "call to transferFrom or transfer",
                "Type": "Result of transfer / transferFrom not checked",
                "Description": "A call to transferFrom or transfer is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of 'false' is returned.",
                "Repair": "Always check the result of transferFrom and transfer."
            },
            {
                "Location": "new*Proposal() functions",
                "Type": "Insufficient validation for proposal creation",
                "Description": "Creating invalid proposals is easy due to the lack of validation in the new*Proposal() functions.",
                "Repair": "1. Restrict and validate the typeStr submitted. 2. Have a 'catch-all-else' proposal that will only call _completeProposal() in finaliseProposal(). 3. Do null validation checks in newAddressProposal() and newParamProposal()."
            },
            {
                "Location": "_deposit function in SynthVault contract",
                "Type": "SynthVault rewards can be gamed",
                "Description": "The spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity.",
                "Repair": "Track a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit."
            },
            {
                "Location": "_deposit and depositForMember functions in SynthVault contract",
                "Type": "Resetting user rewards can be used to grief them and make them loose rewards",
                "Description": "The function _deposit sets mapMemberSynth_lastTime to a date in the future in synthVault.sol.",
                "Repair": "Harvest for the user right before changing mapMemberSynth_lastTime"
            },
            {
                "Location": "Several contracts implement an onlyDAO modifier",
                "Type": "Misleading modifier",
                "Description": "Some implementations are wrong and either allow the DAO or the deployer to execute, or even only the deployer.",
                "Repair": "Rename it to onlyDeployer or onlyDeployerOrDAO depending on who has access."
            },
            {
                "Location": "SynthVault.withdraw function",
                "Type": "Loss of rewards",
                "Description": "The SynthVault.withdraw function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards.",
                "Repair": "Recommend claiming the rewards with the user's deposited balance first in withdraw."
            },
            {
                "Location": "DAOVault",
                "Type": "Fund Drainage and Proposal Manipulation",
                "Description": "The DEPLOYER can drain the funds in the DAOVault and manipulate proposal results.",
                "Repair": "Create a separate role and modifier for the DEPLOYER, so that he is only able to call withdraw() but not depositLP(). Include the missing purgeDeployer() function."
            },
            {
                "Location": "Pool's mintSynth logic, Synth's mintSynth logic, and Synth's authorization logic",
                "Type": "arbitrary synth mint/burn",
                "Description": "Pool can mint arbitrary Synth provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.",
                "Repair": "Check the provided synth's underlying token in mintSynth"
            },
            {
                "Location": "curatedPoolCount() function and addCuratedPool() function",
                "Type": "block usage of addCuratedPool",
                "Description": "The function curatedPoolCount() contains a for loop over the array arrayPools. If arrayPools would be too big then the loop would run out of gas and curatedPoolCount() would revert. This would mean that addCuratedPool() cannot be executed anymore (because it calls curatedPoolCount() ).",
                "Repair": "Create a variable curatedPoolCount and increase it in addCuratedPool and decrease it in removeCuratedPool"
            },
            {
                "Location": "PoolFactory.createPoolADD function",
                "Type": "pools can be created without initial liquidity",
                "Description": "The protocol differentiates between public pool creations and private ones (starting without liquidity). However, this is not effective as anyone can just flashloan the required initial pool liquidity, call PoolFactory.createPoolADD, receive the LP tokens in addForMember and withdraw liquidity again.",
                "Repair": "Burn some initial LP tokens or take a pool creation fee instead"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./Pool.sol\";  \nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract Synth is iBEP20 {\n    address public BASE;\n    address public LayerONE; // Underlying relevant layer1 token\n    uint public genesis;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n    mapping(address => uint) public mapSynth_LPBalance;\n    mapping(address => uint) public mapSynth_LPDebt;\n   \n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n    \n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER, \"!DAO\");\n        _;\n    }\n\n    // Restrict access\n    modifier onlyPool() {\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, \"!curated\");\n        _;\n    }\n    \n    constructor (address _base, address _token) {\n        BASE = _base;\n        LayerONE = _token;\n        string memory synthName = \"-SpartanProtocolSynthetic\";\n        string memory synthSymbol = \"-SPS\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));\n        decimals = iBEP20(_token).decimals();\n        DEPLOYER = msg.sender;\n        genesis = block.timestamp;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    // iBEP20 Transfer function\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // iBEP20 Approve, change allowance functions\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n    \n    // iBEP20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Unlimited approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n        _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n        return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    // Burn supply\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //==================================== SYNTH FUNCTIONS =================================//\n\n    // Handle received LP tokens and mint Synths\n    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){\n        uint lpUnits = _getAddedLPAmount(msg.sender); // Get the received LP units\n        mapSynth_LPDebt[msg.sender] += amount; // Increase debt by synth amount\n        mapSynth_LPBalance[msg.sender] += lpUnits; // Increase lp balance by LPs received\n        _mint(member, amount); // Mint the synths & tsf to user\n        return amount;\n    }\n    \n    // Handle received Synths and burn the LPs and Synths\n    function burnSynth() external returns (bool){\n        uint _syntheticAmount = balanceOf(address(this)); // Get the received synth units\n        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; // share = amount * part/total\n        mapSynth_LPBalance[msg.sender] -= _amountUnits; // Reduce lp balance\n        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; // Reduce debt by synths being burnt\n        if(_amountUnits > 0){\n            _burn(address(this), _syntheticAmount); // Burn the synths\n            Pool(msg.sender).burn(_amountUnits); // Burn the LP tokens\n        }\n        return true;\n    }\n\n    // Burn LPs to if their value outweights the synths supply value (Ensures incentives are funnelled to existing LPers)\n    function realise(address pool) external {\n        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); // Get the SPARTA value of the LP tokens\n        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); // Get the SPARTA value of the synths\n        if(baseValueLP > baseValueSynth){\n            uint premium = baseValueLP - baseValueSynth; // Get the premium between the two values\n            if(premium > 10**18){\n                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); // Get the LP value of the premium\n                mapSynth_LPBalance[pool] -= premiumLP; // Reduce the LP balance\n                Pool(pool).burn(premiumLP); // Burn the premium of the LP tokens\n            }\n        }\n    }\n\n    // Check the received token amount\n    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){\n        if(_amount > 0) {\n            uint startBal = iBEP20(_token).balanceOf(address(this)); // Get existing balance\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in\n            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; // Calculate received amount\n        }\n        return _actual;\n    }\n\n    // Check the received LP tokens amount\n    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){\n        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); // Get total balance held\n        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){\n            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; // Get received amount\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    function getmapAddress_LPBalance(address pool) external view returns (uint){\n        return mapSynth_LPBalance[pool];\n    }\n\n    function getmapAddress_LPDebt(address pool) external view returns (uint){\n        return mapSynth_LPDebt[pool];\n    }\n}\n\n\n",
        "CodeNames": [
            "Synth.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Synth.sol L187-L199",
                "Type": "Synth realise is vulnerable to flash loan attacks",
                "Description": "Synth realise function calculates baseValueLP and baseValueSynth base on AMM spot price which is vulnerable to flash loan attack.",
                "Repair": "1. Calculate token's price from a reliable source. Implement a TWAP oracle or uses chainlink oracle. 2. Calculate lp token value based on anti-flashloan formula."
            },
            {
                "Location": "Synth.approveAndCall",
                "Type": "Unnecessary approval",
                "Description": "The Synth.approveAndCall function approves the recipient contract with the max value instead of only the required amount.",
                "Repair": "Only approve amount instead of max value"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iDAO.sol\";\nimport \"./Pool.sol\";  \n\ncontract PoolFactory { \n    address public BASE;\n    address public WBNB;\n    address public DEPLOYER;\n    uint public curatedPoolSize;    // Max amount of pools that can be curated status\n    address[] public arrayPools;    // Array of all deployed pools\n    address[] public arrayTokens;   // Array of all listed tokens\n\n    mapping(address=>address) private mapToken_Pool;\n    mapping(address=>bool) public isListedPool;\n    mapping(address=>bool) public isCuratedPool;\n\n    event CreatePool(address indexed token, address indexed pool);\n    event AddCuratePool(address indexed pool, bool Curated);\n    event RemoveCuratePool(address indexed pool, bool Curated);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER || msg.sender == _DAO().DAO());\n        _;\n    }\n\n    constructor (address _base, address _wbnb) {\n        BASE = _base;\n        WBNB = _wbnb;\n        curatedPoolSize = 10;\n        DEPLOYER = msg.sender;\n    }\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Anyone can create a pool and add liquidity at the same time\n    function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){\n        require(getPool(token) == address(0)); // Must be a valid token\n        require((inputToken > 0 && inputBase >= (10000*10**18)), \"!min\"); // User must add at least 10,000 SPARTA liquidity & ratio must be finite\n        Pool newPool; address _token = token;\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18\n        newPool = new Pool(BASE, _token); // Deploy new pool\n        pool = address(newPool); // Get address of new pool\n        mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory\n        _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool\n        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool\n        arrayPools.push(pool); // Add pool address to the pool array\n        arrayTokens.push(_token); // Add token to the listed array\n        isListedPool[pool] = true; // Record pool as currently listed\n        Pool(pool).addForMember(msg.sender); // Perform the liquidity-add for the user\n        emit CreatePool(token, pool);\n        return pool;\n    }\n\n    // Can create pools initially with no liquidity (not public)\n    function createPool(address token) external onlyDAO returns(address pool){\n        require(getPool(token) == address(0)); // Must be a valid token\n        Pool newPool; address _token = token;\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        newPool = new Pool(BASE, _token); // Deploy new pool\n        pool = address(newPool); // Get address of new pool\n        mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory\n        arrayPools.push(pool); // Add pool address to the pool array\n        arrayTokens.push(_token); // Add token to the listed array\n        isListedPool[pool] = true; // Record pool as currently listed\n        emit CreatePool(token, pool);\n        return pool;\n    }\n\n    // Add pool to the Curated list, enabling it's synths & dividends & dao/vault weight\n    function addCuratedPool(address token) external onlyDAO {\n        require(token != BASE); // Token must not be SPARTA\n        address _pool = getPool(token); // Get pool address\n        require(isListedPool[_pool] == true); // Pool must be valid\n        require(curatedPoolCount() < curatedPoolSize, \"maxCurated\"); // Must be room in the Curated list\n        isCuratedPool[_pool] = true; // Record pool as Curated\n        emit AddCuratePool(_pool, isCuratedPool[_pool]);\n    }\n\n    // Remove pool from the Curated list\n    function removeCuratedPool(address token) external onlyDAO {\n        require(token != BASE); // Token must not be SPARTA\n        address _pool = getPool(token); // Get pool address\n        require(isCuratedPool[_pool] == true); // Pool must be Curated\n        isCuratedPool[_pool] = false; // Record pool as not curated\n        emit RemoveCuratePool(_pool, isCuratedPool[_pool]);\n    }\n\n    function curatedPoolCount() internal view returns (uint){\n        uint cPoolCount; \n        for(uint i = 0; i< arrayPools.length; i++){\n            if(isCuratedPool[arrayPools[i]] == true){\n                cPoolCount += 1;\n            }\n        }\n        return cPoolCount;\n    }\n\n    // Transfer assets into new pool\n    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){\n        if(_amount > 0) {\n            uint startBal = iBEP20(_token).balanceOf(_pool); \n            iBEP20(_token).transferFrom(msg.sender, _pool, _amount); \n            actual = iBEP20(_token).balanceOf(_pool) - (startBal);\n        }\n    }\n\n    //======================================HELPERS========================================//\n\n    function getPool(address token) public view returns(address pool){\n        if(token == address(0)){\n            pool = mapToken_Pool[WBNB];   // Handle BNB\n        } else {\n            pool = mapToken_Pool[token];  // Handle normal token\n        } \n        return pool;\n    }\n\n    function isPool(address pool) external view returns (bool){\n        if(isListedPool[pool] == true){\n            return true;\n        }\n        return  false;\n    }\n\n    function poolCount() external view returns(uint256){\n        return arrayPools.length;\n    }\n\n    function tokenCount() external view returns(uint256){\n        return arrayTokens.length;\n    }\n\n    function getToken(uint256 i) external view returns(address){\n        return arrayTokens[i];\n    }\n\n    function getPoolArray(uint256 i) external view returns(address){\n        return arrayPools[i];\n    }\n}\n\n",
        "CodeNames": [
            "poolFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "poolFactory.sol L45-L62",
                "Type": "Vulnerable Pool initial rate",
                "Description": "Pool is created in function createPoolADD. The price (rate) of the token is determined in this function. Since the address is deterministic, the attacker can front-run the createPoolADD transaction and sends tokens to Pool's address.",
                "Repair": "Add a require statement in createPoolADD to check that initial balance is zero."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\nimport \"./interfaces/iPOOL.sol\";\nimport \"./interfaces/iSYNTH.sol\";\nimport \"./interfaces/iBEP20.sol\";\n\ncontract Utils {\n    address public BASE;\n    uint public one = 10**18;\n\n    constructor (address _base) {\n        BASE = _base;\n    }\n\n    struct PoolDataStruct {\n        address tokenAddress;\n        address poolAddress;\n        uint genesis;\n        uint baseAmount;\n        uint tokenAmount;\n        uint fees;\n        uint volume;\n        uint txCount;\n        uint poolUnits;\n    }\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    //================================== HELPERS ================================//\n\n    function getPoolData(address token) external view returns(PoolDataStruct memory poolData){\n        address pool = getPool(token);\n        poolData.poolAddress = pool;\n        poolData.tokenAddress = token;\n        poolData.genesis = iPOOL(pool).genesis();\n        poolData.baseAmount = iPOOL(pool).baseAmount();\n        poolData.tokenAmount = iPOOL(pool).tokenAmount();\n        poolData.poolUnits = iBEP20(pool).totalSupply();\n        return poolData;\n    }\n\n    function getPoolShareWeight(address token, uint units) external view returns(uint weight){\n        address pool = getPool(token);\n        weight = calcShare(units, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());\n        return (weight);\n    }\n\n    function getPool(address token) public view returns(address pool){\n        return iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);\n    }\n\n    //================================== CORE-MATH ==================================//\n    \n    // Calculate the feeBurn's feeOnTransfer based on total supply\n    function getFeeOnTransfer(uint256 totalSupply, uint256 maxSupply) external pure returns (uint256) {\n        return calcShare(totalSupply, maxSupply, 100); // 0 -> 100bp\n    }\n\n    // Calculate 'part' of a total using basis points | 10,000 basis points = 100.00%\n    function calcPart(uint256 bp, uint256 total) external pure returns (uint256) {\n        require(bp <= 10000, \"!bp\"); // basis points must be valid\n        return calcShare(bp, 10000, total);\n    }\n\n    // Calc share | share = amount * part / total\n    function calcShare(uint256 part, uint256 total, uint256 amount) public pure returns (uint256 share) {\n        if (part > total) {\n            part = total; // Part cant be greater than the total\n        }\n        if (total > 0) {\n            share = (amount * part) / total;\n        }\n    }\n\n    // Calculate liquidity units\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint units){\n        if(P == 0){\n            return b; // If pool is empty; use b as initial units\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = t*(B);\n            uint part2 = T*(b);\n            uint part3 = T*(B)*(2);\n            uint _units = (P * (part1 + (part2))) / (part3);\n            return _units * slipAdjustment / one;  // Divide by 10**18\n        }\n    }\n\n    // Get slip adjustment\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint slipAdjustment){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * (t);\n        uint part2 = b * (T);\n        uint part3 = b * (2) + (B);\n        uint part4 = t + (T);\n        uint numerator;\n        if(part1 > part2){\n            numerator = part1 - (part2);\n        } else {\n            numerator = part2 - (part1);\n        }\n        uint denominator = part3 * (part4);\n        return one - ((numerator * (one)) / (denominator)); // Multiply by 10**18\n    }\n\n    // Calculate symmetrical redemption value of LP tokens (per side)\n    function calcLiquidityHoldings(uint units, address token, address pool) external view returns (uint share){\n        // share = amount * part / total\n        // address pool = getPool(token);\n        uint amount;\n        if(token == BASE){\n            amount = iPOOL(pool).baseAmount();\n        } else {\n            amount = iPOOL(pool).tokenAmount();\n        }\n        uint totalSupply = iBEP20(pool).totalSupply();\n        return(amount*(units))/(totalSupply);\n    }\n\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint output){\n        // y = (x * X * Y )/(x + X)^2\n        uint numerator = x * (X * (Y));\n        uint denominator = (x + (X)) * (x + (X));\n        return numerator / (denominator);\n    }\n\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint output){\n        // y = (x * x * Y) / (x + X)^2\n        uint numerator = x * (x * (Y));\n        uint denominator = (x + (X)) * (x + (X));\n        return numerator / (denominator);\n    }\n\n    // Calculate asymmetrical redemption value of LP tokens (remove all to TOKEN)\n    function calcAsymmetricValueToken(address pool, uint amount) external view returns (uint tokenValue){\n        uint baseAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());\n        uint tokenAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).tokenAmount());\n        uint baseSwapped = calcSwapValueInTokenWithPool(pool, baseAmount);\n        tokenValue = tokenAmount + baseSwapped;\n        return tokenValue;\n    }\n\n    function calcLiquidityUnitsAsym(uint amount, address pool) external view returns (uint units){\n        // synthUnits += (P b)/(2 (b + B))\n        uint baseAmount = iPOOL(pool).baseAmount();\n        uint totalSupply = iBEP20(pool).totalSupply();\n        uint two = 2;\n        return (totalSupply * amount) / (two * (amount + baseAmount));\n    }\n\n    //==================================== PRICING ====================================//\n\n    function calcSpotValueInBase(address token, uint amount) external view returns (uint value){\n        address pool = getPool(token);\n        return calcSpotValueInBaseWithPool(pool, amount);\n    }\n\n    function calcSpotValueInToken(address token, uint amount) external view returns (uint value){\n        address pool = getPool(token);\n        return calcSpotValueInTokenWithPool(pool, amount);\n    }\n\n    function calcSwapValueInBase(address token, uint amount) external view returns (uint _output){\n        address pool = getPool(token);\n        return  calcSwapValueInBaseWithPool(pool, amount);\n    }\n\n    function calcSwapValueInBaseWithSYNTH(address synth, uint amount) external view returns (uint _output){\n        address token = iSYNTH(synth).LayerONE();\n        address pool = getPool(token);\n        return  calcSwapValueInBaseWithPool(pool, amount);\n    }\n\n    function calcSwapValueInToken(address token, uint amount) external view returns (uint _output){\n        address pool = getPool(token);\n        return  calcSwapValueInTokenWithPool(pool, amount);\n    }\n\n    function calcSpotValueInBaseWithPool(address pool, uint amount) public view returns (uint value){\n        uint _baseAmount = iPOOL(pool).baseAmount();\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\n        return (amount*(_baseAmount))/(_tokenAmount);\n    }\n\n    function calcSpotValueInTokenWithPool(address pool, uint amount) public view returns (uint value){\n        uint _baseAmount = iPOOL(pool).baseAmount();\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\n        return (amount*(_tokenAmount))/(_baseAmount);\n    }\n\n    function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){\n        uint _baseAmount = iPOOL(pool).baseAmount();\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\n        return  calcSwapOutput(amount, _tokenAmount, _baseAmount);\n    }\n\n    function calcSwapValueInTokenWithPool(address pool, uint amount) public view returns (uint _output){\n        uint _baseAmount = iPOOL(pool).baseAmount();\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\n        return  calcSwapOutput(amount, _baseAmount, _tokenAmount);\n    }\n\n    function calcActualSynthUnits(uint amount, address synth) external view returns (uint _output) {\n        address token = iSYNTH(synth).LayerONE();\n        address pool = getPool(token);\n        uint _baseAmount = iPOOL(pool).baseAmount();\n        uint _tokenAmount = iPOOL(pool).tokenAmount();\n        return ((amount * _baseAmount) / (2 * _tokenAmount));\n    }\n}\n\n",
        "CodeNames": [
            "Utils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "getPoolShareWeight function in Utils contract",
                "Type": "Flash loan manipulation",
                "Description": "An attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.",
                "Repair": "Record the current timestamp when a user's weight in the DaoVault or BondVault is recalculated and force the new weight to take effect only after a certain period, e.g., a block time."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iSYNTH.sol\"; \nimport \"./interfaces/iSYNTHFACTORY.sol\"; \nimport \"./interfaces/iBEP677.sol\"; \n\ncontract Pool is iBEP20 {  \n    address public BASE;\n    address public TOKEN;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    uint256 public baseAmount; // SPARTA amount that should be in the pool\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\n\n    uint private lastMonth; // Timestamp of the start of current metric period (For UI)\n    uint public genesis; // Timestamp from when the pool was first deployed (For UI)\n\n    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);\n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    constructor (address _base, address _token) {\n        BASE = _base;\n        TOKEN = _token;\n        string memory poolName = \"-SpartanProtocolPool\";\n        string memory poolSymbol = \"-SPP\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n        decimals = 18;\n        genesis = block.timestamp;\n        DEPLOYER = msg.sender;\n        lastMonth = 0;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Max approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n      return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n      return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //====================================POOL FUNCTIONS =================================//\n\n    // User adds liquidity to the pool\n    function add() external returns(uint liquidityUnits){\n        liquidityUnits = addForMember(msg.sender);\n        return liquidityUnits;\n    }\n\n    // Contract adds liquidity for user \n    function addForMember(address member) public returns(uint liquidityUnits){\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\n        if(baseAmount == 0 || tokenAmount == 0){\n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n        }\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\n        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n        return liquidityUnits;\n    }\n    \n    // User removes liquidity from the pool \n    function remove() external returns (uint outputBase, uint outputToken) {\n        return removeForMember(msg.sender);\n    } \n\n    // Contract removes liquidity for the user\n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\n        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user\n        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user\n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\n        return (outputBase, outputToken);\n    }\n\n    // Caller swaps tokens\n    function swap(address token) external returns (uint outputAmount, uint fee){\n        (outputAmount, fee) = swapTo(token, msg.sender);\n        return (outputAmount, fee);\n    }\n\n    // Contract swaps tokens for the member\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); // Must be SPARTA or the pool's relevant TOKEN\n        address _fromToken; uint _amount;\n        if(token == BASE){\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\n        } else {\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\n        }\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user\n        return (outputAmount, fee);\n    }\n\n    // Swap SPARTA for Synths\n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n      return (output, fee);\n    }\n    \n    // Swap Synths for SPARTA\n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); // Must be a valid Synth\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA\n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA\n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract\n        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\n        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\n      return (outputBase, fee);\n    }\n\n    //=======================================INTERNAL MATHS======================================//\n\n    // Check the SPARTA amount received by this Pool\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n        if(_baseBalance > baseAmount){\n            _actual = _baseBalance-(baseAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n  \n    // Check the TOKEN amount received by this Pool\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \n        if(_tokenBalance > tokenAmount){\n            _actual = _tokenBalance-(tokenAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = baseAmount;\n        uint256 _Y = tokenAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee\n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = tokenAmount;\n        uint256 _Y = baseAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output\n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    //=======================================BALANCES=========================================//\n\n    // Sync internal balances to actual\n    function sync() external {\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\n    }\n\n    // Increment internal balances\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount += _baseAmount;\n        tokenAmount += _tokenAmount;\n    }\n\n    // Set internal balances\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\n        baseAmount = _baseAmount;\n        tokenAmount = _tokenAmount; \n    }\n\n    // Decrement internal balances\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount -= _baseAmount;\n        tokenAmount -= _tokenAmount; \n    }\n\n    //===========================================POOL FEE ROI=================================//\n\n    function _addPoolMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30Days\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DPoolRevenue = map30DPoolRevenue;\n            addRevenue(mapPast30DPoolRevenue);\n            map30DPoolRevenue = 0;\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}\n\n\n",
        "CodeNames": [
            "Pool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "calcLiquidityHoldings function in Pool contract",
                "Type": "Dead fund in the Pool",
                "Description": "The lpToken minted by the Pool contract is actually the mix of two types of tokens. One is the original lpTokens user get by calling addForMember. This lpToken is similar to lp of Uniswap, Crv, Sushi, ... etc. The other one is the debt-lp token the Synth contract will get when the user calls mintSynth.",
                "Repair": "Unknown"
            },
            {
                "Location": "burn function in Pool contract",
                "Type": "Hijack token pool by burning liquidity token",
                "Description": "Pool allows users to burn lp tokens without withdrawing the tokens.",
                "Repair": "Remove burn or restrict it to privileged users only."
            },
            {
                "Location": "Pool.sol",
                "Type": "Misuse of AMM model",
                "Description": "The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.",
                "Repair": "Maintain a debt variable in the Pool and use tokenAmount debt when the Pool calculates the token price"
            },
            {
                "Location": "Pool.approveAndCall",
                "Type": "Unnecessary approval",
                "Description": "The Pool.approveAndCall function approves the recipient contract with the max value instead of only the required amount.",
                "Repair": "Only approve amount instead of max value"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iBONDVAULT.sol\";\nimport \"./interfaces/iBASE.sol\"; \nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iSYNTHVAULT.sol\";\n\ncontract Dao {\n    address public DEPLOYER;\n    address public BASE;\n\n    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)\n    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised\n    uint256 public proposalCount;   // Count of proposals\n    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3\n    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\n    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially\n    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially\n    uint256 public currentProposal; // The most recent proposal; should be === proposalCount\n    \n    struct MemberDetails {\n        bool isMember;\n        uint weight;\n        uint lastBlock;\n        uint poolCount;\n    }\n    struct ProposalDetails {\n        uint id;\n        string proposalType;\n        uint votes;\n        uint coolOffTime;\n        bool finalising;\n        bool finalised;\n        uint param;\n        address proposedAddress;\n        bool open;\n        uint startTime;\n    }\n\n    bool public daoHasMoved;\n    address public DAO;\n\n    iROUTER private _ROUTER;\n    iUTILS private _UTILS;\n    iBONDVAULT private _BONDVAULT;\n    iDAOVAULT private _DAOVAULT;\n    iPOOLFACTORY private _POOLFACTORY;\n    iSYNTHFACTORY private _SYNTHFACTORY;\n    iRESERVE private _RESERVE;\n    iSYNTHVAULT private _SYNTHVAULT;\n\n    address[] public arrayMembers;\n    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets\n    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)\n    \n    mapping(address => bool) public isMember;\n    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets\n    mapping(address => uint256) public mapMember_lastTime;\n\n    mapping(uint256 => uint256) public mapPID_param;\n    mapping(uint256 => address) public mapPID_address;\n    mapping(uint256 => string) public mapPID_type;\n    mapping(uint256 => uint256) public mapPID_votes;\n    mapping(uint256 => uint256) public mapPID_coolOffTime;\n    mapping(uint256 => bool) public mapPID_finalising;\n    mapping(uint256 => bool) public mapPID_finalised;\n    mapping(uint256 => bool) public mapPID_open;\n    mapping(uint256 => uint256) public mapPID_startTime;\n    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;\n\n    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);\n    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);\n\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\n    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);\n    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);\n    event CancelProposal(address indexed member, uint indexed proposalID);\n    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);\n    event ListedAsset(address indexed DAO, address indexed asset);\n    event DelistedAsset(address indexed DAO, address indexed asset);\n    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base){\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        DAO = address(this);\n        coolOffPeriod = 259200;\n        erasToEarn = 30;\n        majorityFactor = 6666;\n        daoClaim = 1000;\n        daoFee = 100;\n        proposalCount = 0;\n        secondsPerEra = iBASE(BASE).secondsPerEra();\n    }\n\n    //==================================== PROTOCOL CONTRACTs SETTER =================================//\n\n    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {\n        _ROUTER = iROUTER(_router);\n        _UTILS = iUTILS(_utils);\n        _RESERVE = iRESERVE(_reserve);\n    }\n\n    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {\n        _DAOVAULT = iDAOVAULT(_daovault);\n        _BONDVAULT = iBONDVAULT(_bondvault);\n        _SYNTHVAULT = iSYNTHVAULT(_synthVault); \n    }\n    \n    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {\n        _POOLFACTORY = iPOOLFACTORY(_poolFactory);\n        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);\n    }\n\n    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {\n        coolOffPeriod = _coolOff;\n        erasToEarn = _daysToEarn;\n        majorityFactor = _majorityFactor;\n        daoClaim = _daoClaim;\n        daoFee = _daoFee;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Can change vesting period for bonders\n    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{\n        bondingPeriodSeconds = bondingSeconds;\n    }\n\n    //============================== USER - DEPOSIT/WITHDRAW ================================//\n\n    // User deposits LP tokens in the DAOVault\n    function deposit(address pool, uint256 amount) external {\n        depositLPForMember(pool, amount, msg.sender);\n    }\n\n    // Contract deposits LP tokens for member\n    function depositLPForMember(address pool, uint256 amount, address member) public {\n        require(_POOLFACTORY.isCuratedPool(pool) == true, \"!curated\"); // Pool must be Curated\n        require(amount > 0, \"!amount\"); // Deposit amount must be valid\n        if (isMember[member] != true) {\n            arrayMembers.push(member); // If not a member; add user to member array\n            isMember[member] = true; // If not a member; register the user as member\n        }\n        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault\n        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight\n        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time\n        emit MemberDeposits(member, pool, amount);\n    }\n    \n    // User withdraws all of their selected asset from the DAOVault\n    function withdraw(address pool) external {\n        removeVote(); // Users weight is removed from the current open DAO proposal\n        require(_DAOVAULT.withdraw(pool, msg.sender), \"!transfer\"); // User receives their withdrawal\n    }\n\n    //============================== REWARDS ================================//\n    \n    // User claims their DAOVault incentives\n    function harvest() public {\n        require(_RESERVE.emissions(), \"!emissions\"); // Reserve must have emissions turned on\n        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\n        if(reward > daoReward){\n            reward = daoReward; // User cannot claim more than the daoReward limit\n        }\n        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user\n    }\n\n    // Calculate the user's current incentive-claim per era\n    function calcCurrentReward(address member) public view returns(uint){\n        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim\n        uint share = calcReward(member); // Get share of rewards for user\n        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed\n        return reward;\n    }\n\n    // Calculate the user's current total claimable incentive\n    function calcReward(address member) public view returns(uint){\n        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days\n        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that\n        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)\n    }\n\n    //================================ BOND Feature ==================================//\n\n    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)\n    function burnBalance() external onlyDAO returns (bool){\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBASE(BASE).burn(baseBal);   \n        return true;\n    }\n\n    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)\n    function moveBASEBalance(address newDAO) external onlyDAO {\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\n        iBEP20(BASE).transfer(newDAO, baseBal);\n    }\n\n    // List an asset to be enabled for Bonding\n    function listBondAsset(address asset) external onlyDAO {\n        if(!isListed[asset]){\n            isListed[asset] = true; // Register as a currently enabled asset\n            listedBondAssets.push(asset); // Add to historical record of past Bond assets\n        }\n        emit ListedAsset(msg.sender, asset);\n    }\n\n    // Delist an asset from the Bond program\n    function delistBondAsset(address asset) external onlyDAO {\n        isListed[asset] = false; // Unregister as a currently enabled asset\n        emit DelistedAsset(msg.sender, asset);\n    }\n\n    // User deposits assets to be Bonded\n    function bond(address asset, uint256 amount) external payable returns (bool success) {\n        require(amount > 0, '!amount'); // Amount must be valid\n        require(isListed[asset], '!listed'); // Asset must be listed for Bond\n        if (isMember[msg.sender] != true) {\n            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array\n            isMember[msg.sender] = true; // Register user as a member\n        }\n        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {\n            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest\n        }\n        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units\n        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\n        emit DepositAsset(msg.sender, amount, liquidityUnits);\n        return true;\n    }\n\n    // Add Bonded assets as liquidity and calculate LP units\n    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){\n        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets\n        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){\n            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required\n        }\n        if(_token == address(0)){\n            require((_amount == msg.value), \"!amount\");\n            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens\n        } else {\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract\n            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){\n                uint256 approvalTNK = iBEP20(_token).totalSupply();\n                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required\n            }\n            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens\n        } \n    }\n\n    // User claims all of their unlocked Bonded LPs\n    function claimAllForMember(address member) external returns (bool){\n        address [] memory listedAssets = listedBondAssets; // Get array of bond assets\n        for(uint i = 0; i < listedAssets.length; i++){\n            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset\n            if(claimA > 0){\n               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked\n            }\n        }\n        return true;\n    }\n\n    // User claims unlocked Bond units of a selected asset\n    function claimForMember(address asset) external returns (bool){\n        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs\n        if(claimA > 0){\n            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked\n        }\n        return true;\n    }\n    \n    // Calculate user's unlocked Bond units of a selected asset\n    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){\n        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs\n        return claimAmount;\n    }\n\n    //============================== CREATE PROPOSALS ================================//\n\n    // New ID, but specify type, one type for each function call\n    // Votes counted to IDs\n    // IDs are finalised\n    // IDs are executed, but type specifies unique logic\n\n    // New DAO proposal: Simple action\n    function newActionProposal(string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: uint parameter\n    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_param[currentProposal] = param; // Set the proposed parameter\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Address parameter\n    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // New DAO proposal: Grant SPARTA to wallet\n    function newGrantProposal(address recipient, uint amount) external returns(uint) {\n        checkProposal(); // If no open proposal; construct new one\n        payFee(); // Pay SPARTA fee for new proposal\n        string memory typeStr = \"GRANT\";\n        mapPID_type[currentProposal] = typeStr; // Set the proposal type\n        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient\n        mapPID_param[currentProposal] = amount; // Set the proposed grant amount\n        emit NewProposal(msg.sender, currentProposal, typeStr);\n        return currentProposal;\n    }\n\n    // If no existing open DAO proposal; register a new one\n    function checkProposal() internal {\n        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal\n        proposalCount += 1; // Increase proposal count\n        currentProposal = proposalCount; // Set current proposal to the new count\n        mapPID_open[currentProposal] = true; // Set new proposal as open status\n        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now\n    }\n    \n    // Pay the fee for a new DAO proposal\n    function payFee() internal returns(bool){\n        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI\n        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee\n        return true;\n    } \n\n    //============================== VOTE && FINALISE ================================//\n\n    // Vote for a proposal\n    function voteProposal() external returns (uint voteWeight) {\n        require(mapPID_open[currentProposal] == true, \"!open\"); // Proposal must be open status\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeight = countVotes(); // Vote for proposal and recount\n        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){\n                if(hasMajority(currentProposal)){\n                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase\n                }\n            } else {\n                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase\n            }\n        }\n        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));\n    }\n\n    // Remove vote from a proposal\n    function removeVote() public returns (uint voteWeightRemoved){\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight\n        if(mapPID_open[currentProposal]){\n            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)\n        }\n        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)\n        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));\n        return voteWeightRemoved;\n    }\n\n    // Push the proposal into 'finalising' status\n    function _finalise() internal {\n        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n        mapPID_finalising[currentProposal] = true; // Set finalising status to true\n        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from\n        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));\n    }\n\n    // Attempt to cancel the open proposal\n    function cancelProposal() external {\n        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), \"!days\"); // Proposal must not be new\n        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal\n        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)\n        emit CancelProposal(msg.sender, currentProposal);\n    }\n\n    // A finalising-stage proposal can be finalised after the cool off period\n    function finaliseProposal() external {\n        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, \"!cooloff\"); // Must be past cooloff period\n        require(mapPID_finalising[currentProposal] == true, \"!finalising\"); // Must be in finalising stage\n        if(!hasQuorum(currentProposal)){\n            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage\n        } else {\n            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type\n            if(isEqual(_type, 'DAO')){\n                moveDao(currentProposal);\n            } else if (isEqual(_type, 'ROUTER')) {\n                moveRouter(currentProposal);\n            } else if (isEqual(_type, 'UTILS')){\n                moveUtils(currentProposal);\n            } else if (isEqual(_type, 'RESERVE')){\n                moveReserve(currentProposal);\n            } else if (isEqual(_type, 'FLIP_EMISSIONS')){\n                flipEmissions(currentProposal);\n            } else if (isEqual(_type, 'COOL_OFF')){\n                changeCooloff(currentProposal);\n            } else if (isEqual(_type, 'ERAS_TO_EARN')){\n                changeEras(currentProposal);\n            } else if (isEqual(_type, 'GRANT')){\n                grantFunds(currentProposal);\n            } else if (isEqual(_type, 'GET_SPARTA')){\n                _increaseSpartaAllocation(currentProposal);\n            } else if (isEqual(_type, 'LIST_BOND')){\n                _listBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'DELIST_BOND')){\n                _delistBondingAsset(currentProposal);\n            } else if (isEqual(_type, 'ADD_CURATED_POOL')){\n                _addCuratedPool(currentProposal);\n            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\n                _removeCuratedPool(currentProposal);\n            } \n        }\n    }\n\n    // Change the DAO to a new contract address\n    function moveDao(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        DAO = _proposedAddress; // Change the DAO to point to the new DAO address\n        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\n        daoHasMoved = true; // Set status of this old DAO\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the ROUTER to a new contract address\n    function moveRouter(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the UTILS to a new contract address\n    function moveUtils(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change the RESERVE to a new contract address\n    function moveReserve(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n        require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Flip the BASE emissions on/off\n    function flipEmissions(uint _proposalID) internal {\n        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change cool off period (Period of time until a finalising proposal can be finalised)\n    function changeCooloff(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        coolOffPeriod = _proposedParam; // Change coolOffPeriod\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Change erasToEarn (Used to regulate the incentives flow)\n    function changeEras(uint _proposalID) internal {\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\n        require(_proposedParam != 0, \"!param\"); // Proposed param must be valid\n        erasToEarn = _proposedParam; // Change erasToEarn\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Grant SPARTA to the proposed recipient\n    function grantFunds(uint _proposalID) internal {\n        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\n        require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid\n        require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid\n        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Mint a 2.5M SPARTA allocation for the Bond program\n    function _increaseSpartaAllocation(uint _proposalID) internal {\n        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m\n        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // List an asset to be enabled for Bonding\n    function _listBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        if(!isListed[_proposedAddress]){\n            isListed[_proposedAddress] = true; // Register asset as listed for Bond\n            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets\n        }\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Delist an asset from being allowed to Bond\n    function _delistBondingAsset(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Add a pool as 'Curated' to enable synths, weight and incentives\n    function _addCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\n        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n\n    // Remove a pool from Curated status\n    function _removeCuratedPool(uint _proposalID) internal {\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal\n        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated\n        completeProposal(_proposalID); // Finalise the proposal\n    }\n    \n    // After completing the proposal's action; close it\n    function completeProposal(uint _proposalID) internal {\n        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type\n        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);\n        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0\n        mapPID_finalised[_proposalID] = true; // Finalise the proposal\n        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage\n        mapPID_open[_proposalID] = false; // Close the proposal\n    }\n\n    //============================== CONSENSUS ================================//\n    \n    // Add user's total weight to proposal and recount\n    function countVotes() internal returns (uint voteWeight){\n        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal\n        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights\n        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)\n        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)\n        return voteWeight;\n    }\n\n    // Check if a proposal has Majority consensus\n    function hasMajority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Quorum consensus\n    function hasQuorum(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 2; // Quorum > 50%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check if a proposal has Minority consensus\n    function hasMinority(uint _proposalID) public view returns(bool){\n        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight\n        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights\n        uint consensus = _totalWeight / 6; // Minority > 16.6%\n        if(votes > consensus){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //======================================PROTOCOL CONTRACTs GETTER=================================//\n    \n    // Get the ROUTER address that the DAO currently points to\n    function ROUTER() public view returns(iROUTER){\n        if(daoHasMoved){\n            return Dao(DAO).ROUTER();\n        } else {\n            return _ROUTER;\n        }\n    }\n\n    // Get the UTILS address that the DAO currently points to\n    function UTILS() public view returns(iUTILS){\n        if(daoHasMoved){\n            return Dao(DAO).UTILS();\n        } else {\n            return _UTILS;\n        }\n    }\n\n    // Get the BONDVAULT address that the DAO currently points to\n    function BONDVAULT() public view returns(iBONDVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).BONDVAULT();\n        } else {\n            return _BONDVAULT;\n        }\n    }\n\n    // Get the DAOVAULT address that the DAO currently points to\n    function DAOVAULT() public view returns(iDAOVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).DAOVAULT();\n        } else {\n            return _DAOVAULT;\n        }\n    }\n\n    // Get the POOLFACTORY address that the DAO currently points to\n    function POOLFACTORY() public view returns(iPOOLFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).POOLFACTORY();\n        } else {\n            return _POOLFACTORY;\n        }\n    }\n\n    // Get the SYNTHFACTORY address that the DAO currently points to\n    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHFACTORY();\n        } else {\n            return _SYNTHFACTORY;\n        }\n    }\n\n    // Get the RESERVE address that the DAO currently points to\n    function RESERVE() public view returns(iRESERVE){\n        if(daoHasMoved){\n            return Dao(DAO).RESERVE();\n        } else {\n            return _RESERVE;\n        }\n    }\n\n    // Get the SYNTHVAULT address that the DAO currently points to\n    function SYNTHVAULT() public view returns(iSYNTHVAULT){\n        if(daoHasMoved){\n            return Dao(DAO).SYNTHVAULT();\n        } else {\n            return _SYNTHVAULT;\n        }\n    }\n\n    //============================== HELPERS ================================//\n    \n    function memberCount() external view returns(uint){\n        return arrayMembers.length;\n    }\n\n    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){\n        proposalDetails.id = proposalID;\n        proposalDetails.proposalType = mapPID_type[proposalID];\n        proposalDetails.votes = mapPID_votes[proposalID];\n        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];\n        proposalDetails.finalising = mapPID_finalising[proposalID];\n        proposalDetails.finalised = mapPID_finalised[proposalID];\n        proposalDetails.param = mapPID_param[proposalID];\n        proposalDetails.proposedAddress = mapPID_address[proposalID];\n        proposalDetails.open = mapPID_open[proposalID];\n        proposalDetails.startTime = mapPID_startTime[proposalID];\n        return proposalDetails;\n    }\n\n    function assetListedCount() external view returns (uint256 count){\n        return listedBondAssets.length;\n    }\n\n    function allListedAssets() external view returns (address[] memory _allListedAssets){\n        return listedBondAssets;\n    }\n    \n    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n   \n\n",
        "CodeNames": [
            "Dao.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Dao.claimAllForMember()",
                "Type": "Improper access control",
                "Description": "The claimAllForMember function of Dao is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member.",
                "Repair": "Remove the member parameter in the claimAllForMember function and replace all member to msg.sender to allow only the user himself to claim unlocked bonded LP tokens."
            },
            {
                "Location": "Dao.sol",
                "Type": "in the beginning its relatively easy to gain majority share",
                "Description": "When the DAO is just deployed it is relatively easy to gain a large (majority) share, by depositing a lot in the DAOVault and/of BONDVault. Then you could submit a proposal and vote it in. Luckily there is a coolOffPeriod of 3 days. But if others are not paying attention in these 3 days you might get your vote passed by voting for it with your majority share. The riskiest proposal would be to replace the DAO (moveDao), because that way you could take over everything.",
                "Repair": "Make sure you initially have a majority vote"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOL.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract BondVault {\n    address public BASE;\n    address public DEPLOYER;\n    uint256 public totalWeight;\n    bool private bondRelease;\n    address [] public arrayMembers;\n\n    struct ListedAssets {\n        bool isListed;\n        address[] members;\n        mapping(address => bool) isMember;\n        mapping(address => uint256) bondedLP;\n        mapping(address => uint256) claimRate;\n        mapping(address => uint256) lastBlockTime;\n    }\n    struct MemberDetails {\n        bool isMember;\n        uint256 bondedLP;\n        uint256 claimRate;\n        uint256 lastBlockTime;\n    }\n\n    mapping(address => ListedAssets) public mapBondAsset_memberDetails;\n    mapping(address => uint256) private mapMember_weight; // Value of users weight (scope: user)\n    mapping(address => mapping(address => uint256)) private mapMemberPool_weight; // Value of users weight (scope: pool)\n\n    constructor (address _base) {\n        BASE = _base;\n        DEPLOYER = msg.sender;\n        bondRelease = false;\n    }\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() public onlyDAO {\n        DEPLOYER = address(0);\n    }\n\n    // Get the current DAO address as reported by the BASE contract\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // Deposit LPs in the BondVault for a user (Called from DAO)\n    function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){\n        if(!mapBondAsset_memberDetails[asset].isMember[member]){\n            mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)\n            arrayMembers.push(member); // Add user to member array (scope: vault)\n            mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)\n        }\n        if(mapBondAsset_memberDetails[asset].bondedLP[member] != 0){\n            claimForMember(asset, member); // Force claim if member has an existing remainder\n        }\n        mapBondAsset_memberDetails[asset].bondedLP[member] += LPS; // Add new deposit to users remainder\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].claimRate[member] = mapBondAsset_memberDetails[asset].bondedLP[member] / iDAO(_DAO().DAO()).bondingPeriodSeconds(); // Set claim rate per second\n        increaseWeight(asset, member); // Update user's weight\n        return true;\n    }\n\n    // Increase user's weight in the BondVault\n    function increaseWeight(address asset, address member) internal{\n        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        if (mapMemberPool_weight[member][pool] > 0) {\n            totalWeight -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: vault)\n            mapMember_weight[member] -= mapMemberPool_weight[member][pool]; // Remove user weight from totalWeight (scope: user)\n            mapMemberPool_weight[member][pool] = 0; // Zero out user weight (scope: user -> pool)\n        }\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Calculate the user's current available claim amount\n    function calcBondedLP(address member, address asset) public view returns (uint claimAmount){ \n        if(mapBondAsset_memberDetails[asset].isMember[member]){\n            uint256 _secondsSinceClaim = block.timestamp - mapBondAsset_memberDetails[asset].lastBlockTime[member]; // Get seconds passed since last claim\n            uint256 rate = mapBondAsset_memberDetails[asset].claimRate[member]; // Get user's claim rate\n            claimAmount = _secondsSinceClaim * rate; // Set claim amount\n            if(claimAmount >= mapBondAsset_memberDetails[asset].bondedLP[member] || bondRelease){\n                claimAmount = mapBondAsset_memberDetails[asset].bondedLP[member]; // If final claim; set claimAmount as remainder\n            }\n            return claimAmount;\n        }\n    }\n\n    // Perform a claim of the users's current available claim amount\n    function claimForMember(address asset, address member) public onlyDAO returns (bool){\n        require(mapBondAsset_memberDetails[asset].bondedLP[member] > 0, '!bonded'); // They must have remaining unclaimed LPs\n        require(mapBondAsset_memberDetails[asset].isMember[member], '!member'); // They must be a member (scope: user -> asset)\n        uint256 _claimable = calcBondedLP(member, asset); // Get the current claimable amount\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get the pool address\n        mapBondAsset_memberDetails[asset].lastBlockTime[member] = block.timestamp; // Set lastBlockTime to current time\n        mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder\n        if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){\n            mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate\n        }\n        decreaseWeight(asset, member); // Update user's weight\n        iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user\n        return true;\n    }\n\n    // Decrease user's weight in the BondVault\n    function decreaseWeight(address asset, address member) internal {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(asset); // Get pool address\n        totalWeight -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: vault)\n        mapMember_weight[member] -= mapMemberPool_weight[member][_pool]; // Remove user weight from totalWeight (scope: user)\n        mapMemberPool_weight[member][_pool] = 0; // Zero out user weight (scope: user -> pool)\n        uint256 weight = iUTILS(_DAO().UTILS()).getPoolShareWeight(asset, mapBondAsset_memberDetails[asset].bondedLP[member]); // Calculate user's bonded weight\n        mapMemberPool_weight[member][_pool] = weight; // Set new weight (scope: user -> pool)\n        mapMember_weight[member] += weight; // Add new weight to totalWeight (scope: user)\n        totalWeight += weight; // // Add new weight to totalWeight (scope: vault)\n    }\n\n    // Get the total count of all existing & past BondVault members\n    function memberCount() external view returns (uint256 count){\n        return arrayMembers.length;\n    }\n\n    // Get array of all existing & past BondVault members\n    function allMembers() external view returns (address[] memory _allMembers){\n        return arrayMembers;\n    }\n\n    function release() external onlyDAO {\n        bondRelease = true;\n    }\n\n    // Get a bond details (scope: user -> asset)\n    function getMemberDetails(address member, address asset) external view returns (MemberDetails memory memberDetails){\n        memberDetails.isMember = mapBondAsset_memberDetails[asset].isMember[member];\n        memberDetails.bondedLP = mapBondAsset_memberDetails[asset].bondedLP[member];\n        memberDetails.claimRate = mapBondAsset_memberDetails[asset].claimRate[member];\n        memberDetails.lastBlockTime = mapBondAsset_memberDetails[asset].lastBlockTime[member];\n        return memberDetails;\n    }\n\n    // Get a users's totalWeight (scope: user)\n    function getMemberWeight(address member) external view returns (uint256) {\n        if (mapMember_weight[member] > 0) {\n            return mapMember_weight[member];\n        } else {\n            return 0;\n        }\n    } \n}\n\n",
        "CodeNames": [
            "BondVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BondVault deposits match any deposited token amount with the BASE amount to provide liquidity",
                "Type": "Manipulation of incentives",
                "Description": "An attacker can manipulate the pool and have the DAO commit BASE at bad prices which they then later buy back to receive a profit on BASE.",
                "Repair": "Track a TWAP spot price of the TOKEN < BASE pair and check if the BASE incentive is within a range of the TWAP. This circumvents that the DAO commits BASE at bad prices."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./Pool.sol\";\nimport \"./interfaces/iRESERVE.sol\"; \nimport \"./interfaces/iPOOLFACTORY.sol\";  \nimport \"./interfaces/iWBNB.sol\";\n\ncontract Router {\n    address public BASE;\n    address public WBNB;\n    address public DEPLOYER;\n\n    uint private maxTrades;         // Amount of dividend events per era\n    uint private eraLength;         // Dividend factor to regulate the max percentage of RESERVE balance\n    uint public normalAverageFee;   // The average fee size (dividend smoothing)\n    uint private arrayFeeSize;      // The size of the average window used for normalAverageFee\n    uint [] private feeArray;       // The array used to calc normalAverageFee\n    uint private lastMonth;         // Timestamp of the start of current metric period (For UI)\n\n    mapping(address=> uint) public mapAddress_30DayDividends;\n    mapping(address=> uint) public mapAddress_Past30DayPoolDividends;\n\n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n        _;\n    }\n\n    constructor (address _base, address _wbnb) {\n        BASE = _base;\n        WBNB = _wbnb;\n        arrayFeeSize = 20;\n        eraLength = 30;\n        maxTrades = 100;\n        lastMonth = 0;\n        DEPLOYER = msg.sender;\n    }\n\n    receive() external payable {}\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    // User adds liquidity\n    function addLiquidity(uint inputBase, uint inputToken, address token) external payable{\n        addLiquidityForMember(inputBase, inputToken, token, msg.sender);\n    }\n\n    // Contract adds liquidity for user\n    function addLiquidityForMember(uint inputBase, uint inputToken, address token, address member) public payable{\n        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);  // Get pool address\n        _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA to pool\n        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN to pool\n        Pool(pool).addForMember(member); // Add liquidity to pool for user\n    }\n\n    // Trade LP tokens for another type of LP tokens\n    function zapLiquidity(uint unitsInput, address fromPool, address toPool) external {\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(fromPool) == true); // FromPool must be a valid pool\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(toPool) == true); // ToPool must be a valid pool\n        address _fromToken = Pool(fromPool).TOKEN(); // Get token underlying the fromPool\n        address _member = msg.sender; // Get user's address\n        require(unitsInput <= iBEP20(fromPool).totalSupply()); // Input must be valid\n        iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool\n        Pool(fromPool).remove(); // Remove liquidity to ROUTER\n        iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool\n        Pool(fromPool).swapTo(BASE, toPool); // Swap the received TOKENs for SPARTA then transfer to the toPool\n        iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool\n        Pool(toPool).addForMember(_member); // Add liquidity and send the LPs to user\n    }\n\n    // User adds liquidity asymetrically (one asset)\n    function addLiquiditySingle(uint inputToken, bool fromBase, address token) external payable{\n        addLiquiditySingleForMember(inputToken, fromBase, token, msg.sender);\n    }\n\n    // Contract adds liquidity asymetrically for user (one asset)\n    function addLiquiditySingleForMember(uint inputToken, bool fromBase, address token, address member) public payable{\n        require(inputToken > 0); // Must be valid input amount\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n        address _token = token;\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        if(fromBase){\n            _handleTransferIn(BASE, inputToken, _pool); // Transfer SPARTA into pool\n            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user\n        } else {\n            _handleTransferIn(token, inputToken, _pool); // Transfer TOKEN into pool\n            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user\n        }\n    }\n\n    // User removes liquidity - redeems a percentage of their balance\n    function removeLiquidity(uint basisPoints, address token) external{\n        require((basisPoints > 0 && basisPoints <= 10000)); // Must be valid basis points\n        uint _units = iUTILS(_DAO().UTILS()).calcPart(basisPoints, iBEP20(iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token)).balanceOf(msg.sender));\n        removeLiquidityExact(_units, token);\n    }\n\n    // User removes liquidity - redeems exact qty of LP tokens\n    function removeLiquidityExact(uint units, address token) public {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address\n        address _member = msg.sender; // The the user's address\n        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool\n        if(token != address(0)){\n            Pool(_pool).removeForMember(_member); // Remove liquidity and send assets directly to user\n        } else {\n            Pool(_pool).remove(); // If BNB; remove liquidity and send to ROUTER instead\n            uint outputBase = iBEP20(BASE).balanceOf(address(this)); // Get the received SPARTA amount\n            uint outputToken = iBEP20(WBNB).balanceOf(address(this)); // Get the received WBNB amount\n            _handleTransferOut(token, outputToken, _member); // Unwrap to BNB & tsf it to user\n            _handleTransferOut(BASE, outputBase, _member); // Transfer SPARTA to user\n        }\n    }\n\n    // User removes liquidity asymetrically (one asset)\n    function removeLiquiditySingle(uint units, bool toBase, address token) external{\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(_pool) == true); // Pool must be valid\n        address _member = msg.sender; // Get user's address\n        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool\n        Pool(_pool).remove(); // Remove liquidity & tsf to ROUTER\n        address _token = token; // Get token address\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        if(toBase){\n            iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool\n            Pool(_pool).swapTo(BASE, _member); // Swap TOKEN for SPARTA & tsf to user\n        } else {\n            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool\n            Pool(_pool).swap(_token); // Swap SPARTA for TOKEN & transfer to ROUTER\n            _handleTransferOut(token, iBEP20(_token).balanceOf(address(this)), _member); // Send TOKEN to user\n        } \n    }\n\n    //============================== Swapping Functions ====================================//\n    \n    // Swap SPARTA for TOKEN\n    function buyTo(uint amount, address token, address member) public {\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address\n        _handleTransferIn(BASE, amount, _pool); // Transfer SPARTA to pool\n        uint fee;\n        if(token != address(0)){\n            (, uint feey) = Pool(_pool).swapTo(token, member); // Swap SPARTA to TOKEN & tsf to user\n            fee = feey;\n        } else {\n            (uint outputAmount, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB\n            _handleTransferOut(token, outputAmount, member); // Unwrap to BNB & tsf to user\n            fee = feez;\n        }\n        getsDividend(_pool, fee); // Check for dividend & tsf it to pool\n    }\n\n    // Swap TOKEN for SPARTA\n    function sellTo(uint amount, address token, address member) public payable returns (uint){\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n        _handleTransferIn(token, amount, _pool); // Transfer TOKEN to pool\n        (, uint fee) = Pool(_pool).swapTo(BASE, member); // Swap TOKEN to SPARTA & transfer to user\n        getsDividend(_pool, fee); // Check for dividend & tsf it to pool\n        return fee;\n    }\n\n    // User performs a simple swap (to -> from)\n    function swap(uint256 inputAmount, address fromToken, address toToken) external payable{\n        swapTo(inputAmount, fromToken, toToken, msg.sender);\n    }\n\n    // Contract checks which swap function the user will require\n    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member) public payable{\n        require(fromToken != toToken); // Tokens must not be the same\n        if(fromToken == BASE){\n            buyTo(inputAmount, toToken, member); // Swap SPARTA to TOKEN & tsf to user\n        } else if(toToken == BASE) {\n            sellTo(inputAmount, fromToken, member); // Swap TOKEN to SPARTA & tsf to user\n        } else {\n            address _poolTo = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get pool address\n            uint feey = sellTo(inputAmount, fromToken, _poolTo); // Swap TOKEN to SPARTA & tsf to pool\n            address _toToken = toToken;\n            if(toToken == address(0)){_toToken = WBNB;} // Handle BNB -> WBNB\n            (uint _zz, uint _feez) = Pool(_poolTo).swap(_toToken); // Swap SPARTA to TOKEN & tsf to ROUTER\n            uint fee = feey+(_feez); // Get total slip fees\n            getsDividend(_poolTo, fee); // Check for dividend & tsf it to pool\n            _handleTransferOut(toToken, _zz, member); // Transfer TOKEN to user\n        }\n    }\n\n    // Check if fee should generate a dividend & send it to the pool\n    function getsDividend(address _pool, uint fee) internal {\n        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true){\n            addTradeFee(fee); // Add fee to array for avgFee calcs etc\n            addDividend(_pool, fee); // Check and tsf dividend to pool\n        }\n    }\n\n    //============================== Token Transfer Functions ======================================//\n    \n    // Handle the transfer of assets into the pool\n    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){\n        if(_amount > 0) {\n            if(_token == address(0)){\n                require((_amount == msg.value));\n                (bool success, ) = payable(WBNB).call{value: _amount}(\"\"); // Wrap BNB\n                require(success, \"!send\");\n                iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool\n                actual = _amount;\n            } else {\n                uint startBal = iBEP20(_token).balanceOf(_pool); // Get prior TOKEN balance of pool\n                iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool\n                actual = iBEP20(_token).balanceOf(_pool)-(startBal); // Get received TOKEN amount\n            }\n        }\n    }\n\n    // Handle the transfer of assets out of the ROUTER\n    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal {\n        if(_amount > 0) {\n            if (_token == address(0)) {\n                iWBNB(WBNB).withdraw(_amount); // Unwrap WBNB to BNB\n                (bool success, ) = payable(_recipient).call{value:_amount}(\"\");  // Send BNB to recipient\n                require(success, \"!send\");\n            } else {\n                iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient\n            }\n        }\n    }\n\n    //================================ Swap Synths ========================================//\n    \n    // Swap TOKEN to Synth\n    function swapAssetToSynth(uint inputAmount, address fromToken, address toSynth) external payable {\n        require(fromToken != toSynth); // Tokens must not be the same\n        address _synthLayer1 = iSYNTH(toSynth).LayerONE(); // Get underlying token's address\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthLayer1); // Get relevant pool address\n        if(fromToken != BASE){\n            sellTo(inputAmount, fromToken, address(this)); // Swap TOKEN to SPARTA & tsf to ROUTER\n            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool\n        } else {\n            iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool\n        }\n        (, uint fee) = Pool(_pool).mintSynth(toSynth, msg.sender); // Mint synths & tsf to user\n        getsDividend(_pool, fee); // Check and tsf dividend to pool\n    }\n   \n    // Swap Synth to TOKEN\n    function swapSynthToAsset(uint inputAmount, address fromSynth, address toToken) external {\n        require(fromSynth != toToken); // Tokens must not be the same\n        address _synthINLayer1 = iSYNTH(fromSynth).LayerONE(); // Get synth's underlying token's address\n        address _poolIN = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthINLayer1); // Get synth's relevant pool address\n        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get TOKEN's relevant pool address\n        iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool\n        uint outputAmount; uint fee;\n        if(toToken == BASE){\n            Pool(_poolIN).burnSynth(fromSynth, msg.sender); // Swap Synths for SPARTA & tsf to user\n        } else {\n            (outputAmount,fee) = Pool(_poolIN).burnSynth(fromSynth, address(this)); // Swap Synths to SPARTA & tsf to ROUTER\n            if(toToken != address(0)){\n                (, uint feey) = Pool(_pool).swapTo(toToken, msg.sender); // Swap SPARTA to TOKEN & transfer to user\n                fee = feey + fee;\n            } else {\n                (uint outputAmountY, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB & tsf to ROUTER\n                _handleTransferOut(toToken, outputAmountY, msg.sender); // Unwrap to BNB & tsf to user\n                fee = feez + fee;\n            }\n        }\n        getsDividend(_pool, fee); // Check and tsf dividend to pool\n    }\n    \n    //============================= Token Dividends / Curated Pools =================================//\n    \n    // Calculate the Dividend and transfer it to the pool\n    function addDividend(address _pool, uint256 _fees) internal {\n        if(!(normalAverageFee == 0)){\n            uint reserve = iBEP20(BASE).balanceOf(_DAO().RESERVE()); // Get SPARTA balance in the RESERVE contract\n            if(!(reserve == 0)){\n                uint dailyAllocation = (reserve / eraLength) / maxTrades; // Calculate max dividend\n                uint numerator = _fees * dailyAllocation;\n                uint feeDividend = numerator / (_fees + normalAverageFee); // Calculate actual dividend\n                revenueDetails(feeDividend, _pool); // Add to revenue metrics\n                iRESERVE(_DAO().RESERVE()).grantFunds(feeDividend, _pool); // Transfer dividend from RESERVE to POOL\n                Pool(_pool).sync(); // Sync the pool balances to attribute the dividend to the existing LPers\n            }\n        }\n    }\n\n    // Add fee to feeArray, used to calculate normalAverageFee\n    function addTradeFee(uint _fee) internal {\n        uint totalTradeFees = 0;\n        uint arrayFeeLength = feeArray.length;\n        if(arrayFeeLength < arrayFeeSize){\n            feeArray.push(_fee); // Build array until it is == arrayFeeSize\n        } else {\n            addFee(_fee); // If array is required length; shift in place of oldest item\n            for(uint i = 0; i < arrayFeeSize; i++){\n                totalTradeFees = totalTradeFees + feeArray[i]; // NET sum of feeArray\n            }\n        }\n        normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee\n    }\n\n    // Shift out oldest fee item and add newest\n    function addFee(uint _fee) internal {\n        uint n = feeArray.length; // 20\n        for (uint i = n - 1; i > 0; i--) {\n            feeArray[i] = feeArray[i - 1];\n        }\n        feeArray[0] = _fee;\n    }\n\n    function revenueDetails(uint _fees, address _pool) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30 days\n            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;\n        } else {\n            lastMonth = block.timestamp;\n            mapAddress_Past30DayPoolDividends[_pool] = mapAddress_30DayDividends[_pool];\n            mapAddress_30DayDividends[_pool] = 0;\n            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;\n        }\n    }\n\n    function stringToBytes(string memory s) external pure returns (bytes memory){\n        return bytes(s);\n    }\n\n    function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){\n        if(sha256(part1) == sha256(part2)){\n            return true;\n        }\n    }\n    \n    //======================= Change Dividend Variables ===========================//\n\n    function changeArrayFeeSize(uint _size) external onlyDAO {\n        arrayFeeSize = _size;\n        delete feeArray;\n    }\n\n    function changeMaxTrades(uint _maxtrades) external onlyDAO {\n        maxTrades = _maxtrades;\n    }\n\n    function changeEraLength(uint _eraLength) external onlyDAO {\t\n        eraLength = _eraLength;\t\n    }\n\n    //================================== Helpers =================================//\n\n    function currentPoolRevenue(address pool) external view returns(uint256) {\n        return mapAddress_30DayDividends[pool];\n    }\n\n    function pastPoolRevenue(address pool) external view returns(uint256) {\n        return mapAddress_Past30DayPoolDividends[pool];\n    }\n}\n\n",
        "CodeNames": [
            "Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Router.addDividend function",
                "Type": "dividend reward can be gamed",
                "Description": "The normalAverageFee variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool arrayFeeSize (20) times (use buyTo). The fees of the single wei trades will be zero and thus the normalAverageFee will also be zero as, see addTradeFee. The attacker then does a trade that generates some non-zero fees, setting the normalAverageFee to this trade's fee. The feeDividend is then computed as _fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2. Half of the dailyAllocation is sent to the pool. The attacker repeats the above steps until the reserve is almost empty. Each time the dailyAllocation gets smaller but it's still possible to withdraw almost all of it. The reserve can be emptied by the attacker. Counting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short.",
                "Repair": "Compute the dividends based on volume traded over a timespan instead of looking at individual trades"
            },
            {
                "Location": "Router.sol",
                "Type": "Members lose SPARTA tokens",
                "Description": "When a member calls removeLiquiditySingle() requesting only SPARTA in return, i.e. toBASE = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member\u2019s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.",
                "Repair": "Transfer BASE SPARTA to the Pool before swapTo() so they get sent to the member along with the converted TOKENs via swapTo(). Use swap(BASE) instead of swapTo() so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./Pool.sol\";  \nimport \"./interfaces/iPOOLFACTORY.sol\";\n\ncontract Synth is iBEP20 {\n    address public BASE;\n    address public LayerONE; // Underlying relevant layer1 token\n    uint public genesis;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n    mapping(address => uint) public mapSynth_LPBalance;\n    mapping(address => uint) public mapSynth_LPDebt;\n   \n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n    \n    // Restrict access\n    modifier onlyDAO() {\n        require(msg.sender == DEPLOYER, \"!DAO\");\n        _;\n    }\n\n    // Restrict access\n    modifier onlyPool() {\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, \"!curated\");\n        _;\n    }\n    \n    constructor (address _base, address _token) {\n        BASE = _base;\n        LayerONE = _token;\n        string memory synthName = \"-SpartanProtocolSynthetic\";\n        string memory synthSymbol = \"-SPS\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));\n        decimals = iBEP20(_token).decimals();\n        DEPLOYER = msg.sender;\n        genesis = block.timestamp;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    // iBEP20 Transfer function\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // iBEP20 Approve, change allowance functions\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n    \n    // iBEP20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Unlimited approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n        _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n        return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    // Burn supply\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //==================================== SYNTH FUNCTIONS =================================//\n\n    // Handle received LP tokens and mint Synths\n    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){\n        uint lpUnits = _getAddedLPAmount(msg.sender); // Get the received LP units\n        mapSynth_LPDebt[msg.sender] += amount; // Increase debt by synth amount\n        mapSynth_LPBalance[msg.sender] += lpUnits; // Increase lp balance by LPs received\n        _mint(member, amount); // Mint the synths & tsf to user\n        return amount;\n    }\n    \n    // Handle received Synths and burn the LPs and Synths\n    function burnSynth() external returns (bool){\n        uint _syntheticAmount = balanceOf(address(this)); // Get the received synth units\n        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; // share = amount * part/total\n        mapSynth_LPBalance[msg.sender] -= _amountUnits; // Reduce lp balance\n        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; // Reduce debt by synths being burnt\n        if(_amountUnits > 0){\n            _burn(address(this), _syntheticAmount); // Burn the synths\n            Pool(msg.sender).burn(_amountUnits); // Burn the LP tokens\n        }\n        return true;\n    }\n\n    // Burn LPs to if their value outweights the synths supply value (Ensures incentives are funnelled to existing LPers)\n    function realise(address pool) external {\n        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); // Get the SPARTA value of the LP tokens\n        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); // Get the SPARTA value of the synths\n        if(baseValueLP > baseValueSynth){\n            uint premium = baseValueLP - baseValueSynth; // Get the premium between the two values\n            if(premium > 10**18){\n                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); // Get the LP value of the premium\n                mapSynth_LPBalance[pool] -= premiumLP; // Reduce the LP balance\n                Pool(pool).burn(premiumLP); // Burn the premium of the LP tokens\n            }\n        }\n    }\n\n    // Check the received token amount\n    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){\n        if(_amount > 0) {\n            uint startBal = iBEP20(_token).balanceOf(address(this)); // Get existing balance\n            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in\n            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; // Calculate received amount\n        }\n        return _actual;\n    }\n\n    // Check the received LP tokens amount\n    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){\n        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); // Get total balance held\n        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){\n            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; // Get received amount\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    function getmapAddress_LPBalance(address pool) external view returns (uint){\n        return mapSynth_LPBalance[pool];\n    }\n\n    function getmapAddress_LPDebt(address pool) external view returns (uint){\n        return mapSynth_LPDebt[pool];\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iSYNTH.sol\"; \nimport \"./interfaces/iSYNTHFACTORY.sol\"; \nimport \"./interfaces/iBEP677.sol\"; \n\ncontract Pool is iBEP20 {  \n    address public BASE;\n    address public TOKEN;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    uint256 public baseAmount; // SPARTA amount that should be in the pool\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\n\n    uint private lastMonth; // Timestamp of the start of current metric period (For UI)\n    uint public genesis; // Timestamp from when the pool was first deployed (For UI)\n\n    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);\n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    constructor (address _base, address _token) {\n        BASE = _base;\n        TOKEN = _token;\n        string memory poolName = \"-SpartanProtocolPool\";\n        string memory poolSymbol = \"-SPP\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n        decimals = 18;\n        genesis = block.timestamp;\n        DEPLOYER = msg.sender;\n        lastMonth = 0;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Max approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n      return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n      return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //====================================POOL FUNCTIONS =================================//\n\n    // User adds liquidity to the pool\n    function add() external returns(uint liquidityUnits){\n        liquidityUnits = addForMember(msg.sender);\n        return liquidityUnits;\n    }\n\n    // Contract adds liquidity for user \n    function addForMember(address member) public returns(uint liquidityUnits){\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\n        if(baseAmount == 0 || tokenAmount == 0){\n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n        }\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\n        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n        return liquidityUnits;\n    }\n    \n    // User removes liquidity from the pool \n    function remove() external returns (uint outputBase, uint outputToken) {\n        return removeForMember(msg.sender);\n    } \n\n    // Contract removes liquidity for the user\n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\n        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user\n        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user\n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\n        return (outputBase, outputToken);\n    }\n\n    // Caller swaps tokens\n    function swap(address token) external returns (uint outputAmount, uint fee){\n        (outputAmount, fee) = swapTo(token, msg.sender);\n        return (outputAmount, fee);\n    }\n\n    // Contract swaps tokens for the member\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); // Must be SPARTA or the pool's relevant TOKEN\n        address _fromToken; uint _amount;\n        if(token == BASE){\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\n        } else {\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\n        }\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user\n        return (outputAmount, fee);\n    }\n\n    // Swap SPARTA for Synths\n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n      return (output, fee);\n    }\n    \n    // Swap Synths for SPARTA\n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); // Must be a valid Synth\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA\n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA\n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract\n        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\n        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\n      return (outputBase, fee);\n    }\n\n    //=======================================INTERNAL MATHS======================================//\n\n    // Check the SPARTA amount received by this Pool\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n        if(_baseBalance > baseAmount){\n            _actual = _baseBalance-(baseAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n  \n    // Check the TOKEN amount received by this Pool\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \n        if(_tokenBalance > tokenAmount){\n            _actual = _tokenBalance-(tokenAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = baseAmount;\n        uint256 _Y = tokenAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee\n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = tokenAmount;\n        uint256 _Y = baseAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output\n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    //=======================================BALANCES=========================================//\n\n    // Sync internal balances to actual\n    function sync() external {\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\n    }\n\n    // Increment internal balances\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount += _baseAmount;\n        tokenAmount += _tokenAmount;\n    }\n\n    // Set internal balances\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\n        baseAmount = _baseAmount;\n        tokenAmount = _tokenAmount; \n    }\n\n    // Decrement internal balances\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount -= _baseAmount;\n        tokenAmount -= _tokenAmount; \n    }\n\n    //===========================================POOL FEE ROI=================================//\n\n    function _addPoolMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30Days\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DPoolRevenue = map30DPoolRevenue;\n            addRevenue(mapPast30DPoolRevenue);\n            map30DPoolRevenue = 0;\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}\n\n\n",
        "CodeNames": [
            "Synth.sol",
            "Pool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Pool.sol & Synth.sol",
                "Type": "Failing Max Value Allowance",
                "Description": "This affects the approveAndCall implementation since it uses type(uint256).max as the allowance amount, but the resulting allowance set is zero.",
                "Repair": "Remove the condition in the _approve function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./iBEP20.sol\";\nimport \"./iBASE.sol\";\nimport \"./iDAO.sol\";\n\ncontract Reserve {\n    address public BASE;\n    address public ROUTER;\n    address public LEND;\n    address public DAO;\n    address public SYNTHVAULT;\n    address public DEPLOYER;\n    bool public emissions;\n\n    // Restrict access\n    modifier onlyGrantor() {\n        require(msg.sender == DAO || msg.sender == ROUTER || msg.sender == DEPLOYER || msg.sender == LEND || msg.sender == SYNTHVAULT, \"!DAO\");\n        _; \n    }\n\n    constructor (address _base) {\n        BASE = _base;\n        DEPLOYER = msg.sender;\n    }\n\n    function setIncentiveAddresses(address _router, address _lend, address _synthVault, address _Dao) external onlyGrantor {\n        ROUTER = _router;\n        LEND = _lend;\n        SYNTHVAULT = _synthVault;\n        DAO = _Dao;\n    }\n\n    // Send SPARTA to an incentive address (Vault harvest, dividends etc)\n    function grantFunds(uint amount, address to) external onlyGrantor {\n        uint reserve = iBEP20(BASE).balanceOf(address(this)); // Get RESERVE's SPARTA balance\n        if(amount > 0){ // Skip if amount is not valid\n            if(emissions){ // Skip if emissions are off\n                if(amount > reserve){\n                    iBEP20(BASE).transfer(to, reserve); // Send remainder\n                } else {\n                    iBEP20(BASE).transfer(to, amount); // Send requested amount\n                }\n            }\n        }\n    }\n\n    function flipEmissions() external onlyGrantor {\n        emissions = !emissions; // Flip emissions on/off\n    }\n\n    // Can purge deployer once DAO is stable and final\n    function purgeDeployer() external onlyGrantor {\n        DEPLOYER = address(0);\n    }\n}\n\n",
        "CodeNames": [
            "Reserve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Reserve.sol",
                "Type": "DAO upgrade issue",
                "Description": "When the DAO is upgraded via moveDao, it also updates the DAO address in BASE. However it doesn't update the DAO address in the Reserve.sol contract.",
                "Repair": "Call setIncentiveAddresses(..) when a DAO upgrade is done"
            }
        ]
    }
]