[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SwappableYieldSource.redeemToken function",
                "Type": "ERC20 token transfer vulnerability",
                "Description": "Some deposit token implementations might fail as transferFrom checks if the contract approved itself for the redeemableBalance instead of skipping the allowance check in case the sender is the from address. This can make the transaction revert and the deposited funds will be unrecoverable for the user.",
                "Repair": "Use _depositToken.safeTransfer(msg.sender, redeemableBalance) instead of ERC20.transferFrom(address(this), msg.sender, redeemableBalance)"
            },
            {
                "Location": "SwappableYieldSource.transferFunds function",
                "Type": "Missing deposit token check",
                "Description": "If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.",
                "Repair": "Check that the deposit tokens are the same before transferring funds"
            },
            {
                "Location": "SwappableYieldSource contract",
                "Type": "Single-step ownership transfer/renounce",
                "Description": "Critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.",
                "Repair": "Override the inherited methods to null functions and use separate functions for a two-step address change"
            },
            {
                "Location": "SwappableYieldSource contract",
                "Type": "Infinite approval vulnerability",
                "Description": "After swapping a yield source, the old yield source still has infinite approval.",
                "Repair": "Decrease approval after swapping the yield source"
            },
            {
                "Location": "SwappableYieldSource.swapYieldSource function",
                "Type": "Rug pull vulnerability",
                "Description": "If either the owner or the asset manager have malicious intent, this function allows them to instantly rug all funds.",
                "Repair": "Check that the YieldSource is from a trusted registry before allowing the swap"
            },
            {
                "Location": "setYieldSource function, supplyTokenTo function, balanceOfToken function, _mintShares function, _tokenToShares function, _sharesToToken function",
                "Type": "Temporary Inconsistent State",
                "Description": "The use of setYieldSource leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.",
                "Repair": "Remove setYieldSource function or temporarily disable actions like supplyTokenTo, redeemToken and balanceOfToken after setYieldSource and until transferFunds has been done"
            },
            {
                "Location": "supplyTokenTo function",
                "Type": "Inconsistent Balance",
                "Description": "The supplyTokenTo function of SwappableYieldSource assumes that amount of _depositToken is transferred to itself after calling the safeTransferFrom function (and thus it supplies amount of token to the yield source). However, this may not be true if the _depositToken is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount.",
                "Repair": "Get the actual received amount by calculating the difference of token balance before and after the transfer"
            },
            {
                "Location": "safeApprove function",
                "Type": "Incorrect Usage of Function",
                "Description": "Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin\u2019s safeApprove() which has been documented as (1) Deprecated because of approve-like race condition and (2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.",
                "Repair": "Use logic similar to SwappableYieldSource instead of using safeApprove"
            }
        ]
    }
]