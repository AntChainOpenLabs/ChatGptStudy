[
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\n\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nabstract contract ERC721Payable {\n  uint256 public mintFee;\n  IERC20 public payableToken;\n  bool public isForSale;\n  address public royaltyVault;\n  address public splitFactory;\n  event NewPayment(\n    address from,\n    address to,\n    uint256 amount,\n    bool royaltyVaultPayment\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyVaultUninitialized() {\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n    _;\n  }\n\n  modifier onlyVaultInitialized() {\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function royaltyVaultInitialized() public view returns (bool) {\n    return royaltyVault != address(0);\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  /**\n   * @notice Handles the transfer of ERC20 tokens when a token gets minted\n   * @dev Tokens are transferred to the Royalty Vault if the vault is set\n   * Otherwise, tokens get transferred to the ERC721 collection contract\n   * @param _amount The amount of ERC20 to be transferred\n   */\n  function _handlePayment(uint256 _amount) internal {\n    address recipient = royaltyVaultInitialized()\n      ? royaltyVault\n      : address(this);\n    payableToken.transferFrom(msg.sender, recipient, _amount);\n    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());\n  }\n}\n\n\n",
        "CodeNames": [
            "CoreCollection.sol",
            "ERC721Payable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CoreCollection.sol and ERC721Payable.sol",
                "Type": "Not handling return value",
                "Description": "Not handling return value of transferFrom command can create inconsistency",
                "Repair": "Add a require statement to check the return value of transferFrom command"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\n\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "CoreCollection.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CoreCollection.sol",
                "Type": "ERC20 transferFrom return values not checked",
                "Description": "ERC20 transferFrom return values not checked",
                "Repair": "Check the success boolean of all transferFrom calls or use OZ\u2019s SafeERC20\u2019s safeTransferFrom() function"
            },
            {
                "Location": "CoreCollection.sol",
                "Type": "CoreCollection can be reinitialized",
                "Description": "CoreCollection can be reinitialized",
                "Repair": "Add onlyUnInitialized modifier to the initialize function"
            },
            {
                "Location": "CoreCollection.setRoyaltyVault function",
                "Type": "Potential permanent lock of tokens",
                "Description": "Mismatch between token used in CoreProxy and RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault.",
                "Repair": "Check if payableToken is the same as royaltyVault.royaltyAsset while assigning vaults to CoreProxy"
            },
            {
                "Location": "CoreCollection.withdraw function",
                "Type": "Funds cannot be withdrawn in CoreCollection.withdraw",
                "Description": "The usage of transferFrom can result in serious issues. In fact, many ERC20 always require that in transferFrom allowance[from][msg.sender] = amount, so in this case the call to the withdraw function will revert as the allowance[CoreCollection][CoreCollection] == 0 and therefore the funds cannot be withdrawn and will be locked forever in the contract.",
                "Repair": "Replace transferFrom with transfer"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SplitStorage} from \"./SplitStorage.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Splitter\n * Building on the work from the Uniswap team at Uniswap and Mirror.xyz Team\n */\ncontract Splitter is SplitStorage {\n    /**** Mutable variables ****/\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;\n\n    // The TransferETH event is emitted after each eth transfer in the split is attempted.\n    event TransferETH(\n        // The account to which the transfer was attempted.\n        address account,\n        // The amount for transfer that was attempted.\n        uint256 amount,\n        // Whether or not the transfer succeeded.\n        bool success\n    );\n\n    // Emits when a window is incremented.\n    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);\n\n    /**\n     * @dev Claim the funds from the all windows.\n     * @param percentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claimForAllWindows(\n        uint256 percentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        // Make sure that the user has this allocation granted.\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, percentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < currentWindow; i++) {\n            if (!isClaimed(msg.sender, i)) {\n                setClaimed(msg.sender, i);\n\n                amount += scaleAmountByPercentage(\n                    balanceForWindow[i],\n                    percentageAllocation\n                );\n            }\n        }\n\n        transferSplitAsset(msg.sender, amount);\n    }\n\n    /**\n     * @dev get Node hash of given data.\n     * @param who {address} whitelisted user address\n     * @param percentageAllocation {uint256} percentage of allocation\n     * @return {bytes32} node hash\n     */\n    function getNode(\n        address who,\n        uint256 percentageAllocation\n    ) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    who,\n                    percentageAllocation\n                )\n            );\n    }\n\n    /**\n     * @dev get scaled amount from given amount and percentage.\n     * @param amount {uint256} amount\n     * @param scaledPercent {uint256} scaled percentage\n     * @return scaledAmount {uint256} scaled amount\n     */\n    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n        public\n        pure\n        returns (uint256 scaledAmount)\n    {\n        /*\n            Example:\n                If there is 100 ETH in the account, and someone has \n                an allocation of 2%, we call this with 100 as the amount, and 200\n                as the scaled percent.\n\n                To find out the amount we use, for example: (100 * 200) / (100 * 100)\n                which returns 2 -- i.e. 2% of the 100 ETH balance.\n         */\n        scaledAmount = (amount * scaledPercent) / (10000);\n    }\n\n    /**\n     * @dev claim for the given window.\n     * @param window {uint256} Window to claim\n     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claim(\n        uint256 window,\n        uint256 scaledPercentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(currentWindow > window, \"cannot claim for a future window\");\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n\n        setClaimed(msg.sender, window);\n\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, scaledPercentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        transferSplitAsset(\n            msg.sender,\n            // The absolute amount that's claimable.\n            scaleAmountByPercentage(\n                balanceForWindow[window],\n                scaledPercentageAllocation\n            )\n        );\n    }\n\n    /**\n     * @dev Function which handles increment window and puts amount to current window\n     * @param royaltyAmount {uint256} Amount needs to be added in window.\n     * @return {bool} Whether or not the window was incremented.\n     */\n    function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n        uint256 wethBalance;\n\n        require(\n            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n            \"Royalty Vault not supported\"\n        );\n        require(\n            IRoyaltyVault(msg.sender).getSplitter() == address(this),\n            \"Unauthorised to increment window\"\n        );\n\n        wethBalance = IERC20(splitAsset).balanceOf(address(this));\n        require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n        require(royaltyAmount > 0, \"No additional funds for window\");\n        balanceForWindow.push(royaltyAmount);\n        currentWindow += 1;\n        emit WindowIncremented(currentWindow, royaltyAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bool} Whether or not the window has been claimed.\n     */\n    function isClaimed(\n        address who,\n        uint256 window\n    ) public view returns (bool) {\n        return claimed[getClaimHash(who, window)];\n    }\n\n    /**** Private Functions ****/\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     */\n    function setClaimed(\n        address who,\n        uint256 window\n    ) private {\n        claimed[getClaimHash(who, window)] = true;\n    }\n\n    /**\n     * @dev Function which returns the hash of the given window, tokenId and membershipContract.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bytes32} Hash of the given window, tokenId and membershipContract.\n     */\n    function getClaimHash(\n        address who,\n        uint256 window\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(who, window));\n    }\n\n    /**\n     * @dev Function to convert output amount from percentages.\n     * @param amount {uint256} Amount for which percentage is to be calculated.\n     * @param percent {uint256} Percentage\n     * @return {uint256} Output amount.\n     */\n    function amountFromPercent(uint256 amount, uint32 percent)\n        private\n        pure\n        returns (uint256)\n    {\n        // Solidity 0.8.0 lets us do this without SafeMath.\n        return (amount * percent) / 100;\n    }\n\n    /**\n     * @dev Function to transfer split asset to the given address.\n     * @param to {address} Address to transfer the split asset to.\n     * @param value {uint256} Amount to transfer.\n     */\n    function transferSplitAsset(address to, uint256 value)\n        private\n        returns (bool didSucceed)\n    {\n        // Try to transfer ETH to the given recipient.\n        didSucceed = IERC20(splitAsset).transfer(to, value);\n        require(didSucceed, \"Failed to transfer ETH\");\n\n        emit TransferETH(to, value, didSucceed);\n    }\n\n    /**\n     * @dev transfer given amount of ETH in contract to the given address.\n     * @param to {address} Address to transfer asset\n     * @param value {uint256} Amount to transfer\n     * @return {bool} Whether or not the transfer was successful.\n     */\n    function attemptETHTransfer(address to, uint256 value)\n        private\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n        return success;\n    }\n\n    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol\n    /**\n     * @dev Function to verify the given proof.\n     * @param proof {bytes32[]} Proof to verify\n     * @param root {bytes32} Root of the Merkle tree\n     * @param leaf {bytes32} Leaf to verify\n     * @return {bool} Whether or not the proof is valid.\n     */\n    function verifyProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) private pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}\n\n\n",
        "CodeNames": [
            "Splitter.sol",
            "RoyaltyVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RoyaltyVault.sol and Splitter.sol",
                "Type": "CoreCollection's token transfer can be disabled",
                "Description": "CoreCollection's token transfer can be disabled",
                "Repair": "Introduce action threshold to sendToSplitter() or try to send the fees and record the amounts not yet distributed"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}\n\n\n",
        "CodeNames": [
            "RoyaltyVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RoyaltyVault.sol",
                "Type": "ERC20 tokens with no return value will fail to transfer",
                "Description": "ERC20 tokens with no return value will fail to transfer",
                "Repair": "Consider using OpenZeppelin\u2019s SafeERC20"
            },
            {
                "Location": "RoyaltyVault.sendToSplitter() function",
                "Type": "Ineffective handling of FoT or Rebasing Tokens",
                "Description": "Certain ERC20 tokens may change user's balances over time or charge a fee when a transfer is called and the accounting of these tokens is not handled by RoyaltyVault.sol or Splitter.sol",
                "Repair": "Document clearly that rebasing token should not be used in the protocol or handle rebasing tokens balance checks before and after the transfer to ensure accurate accounting"
            },
            {
                "Location": "RoyaltyVault.sol",
                "Type": "Not Equipped to Handle On-Chain Royalties",
                "Description": "RoyaltyVault.sol is not equipped to handle on-chain royalties from secondary sales.",
                "Repair": "Implement the necessary functionality to allow for the collection of fees through an on-chain mechanism. ERC2981 outlines the appropriate behaviour for this."
            },
            {
                "Location": "RoyaltyVault contract",
                "Type": "Centralization risk",
                "Description": "Owner of RoyaltyVault can take all funds.",
                "Repair": "Add a maximum value for the _platformFee say 5% (or some reasonable value based on the needs of the platform). Also consider calling sendToSplitter() before adjusting the platformFee. This will only allow the owner to change the fee for future value excluding the current contract balance."
            },
            {
                "Location": "RoyaltyVault contract",
                "Type": "Timelock",
                "Description": "Add a timelock to setPlatformFee()",
                "Repair": "Consider adding a timelock to setPlatformFee()"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {ICoreFactory} from \"../interfaces/ICoreFactory.sol\";\n\ncontract CoreProxy is Ownable {\n    address private immutable _implement;\n\n    constructor(address _imp) {\n        _implement = _imp;\n    }\n\n    fallback() external {\n        address _impl = implement();\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    function implement() public view returns (address) {\n        return _implement;\n    }\n}\n\n\n",
        "CodeNames": [
            "CoreProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CoreProxy contract",
                "Type": "Storage collision",
                "Description": "Storage collision because of lack of EIP1967 could cause conflicts and override sensible variables",
                "Repair": "Use EIP1967 to set proxy variables at fixed positions to avoid storage conflicts"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "createSplit() function",
                "Type": "Front-running attack",
                "Description": "An attacker may front-run any createSplit() transaction in the mem pool and create another createSplit() transaction with a higher gas price that uses the same merkleRoot but changes the other fields",
                "Repair": "Use a whitelist on project creation or ask user to sign their address and check the signature against msg.sender"
            },
            {
                "Location": "mintToken() function",
                "Type": "Duplicate NFTs can be minted",
                "Description": "If the user mints the last token, they can reenter and mint duplicate NFTs as the way tokenId is generated will wrap around to the start again",
                "Repair": "Add reentrancy protections to prevent users from abusing this behaviour and follow the checks-effects pattern such that all external/state changing calls are made at the end"
            },
            {
                "Location": "FortuneTeller function predictStartingIndexes",
                "Type": "CoreCollection: Starting index is pseudo-randomly generated, allowing for gameable NFT launches",
                "Description": "The metadata could be scrapped beforehand to determine the rare NFTs. Thus, NFT mints can be gamed / exploited.",
                "Repair": "Consider exploring the use of commit-reveal schemes (eg. blockhash of a future block, less gameable but not foolproof) or VRFs."
            },
            {
                "Location": "attemptETHTransfer function",
                "Type": "Fixed Amount of Gas Sent in Call May Be Insufficient",
                "Description": "If the receiver is a contract this may be insufficient to process the receive() function. As a result, the user would be unable to receive funds from this function.",
                "Repair": "Consider removing the gas field to use the default amount and protect from reentrancy by using reentrancy guards and the check-effects-interaction pattern. Note this pattern is already applied correctly."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SplitStorage} from \"./SplitStorage.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Splitter\n * Building on the work from the Uniswap team at Uniswap and Mirror.xyz Team\n */\ncontract Splitter is SplitStorage {\n    /**** Mutable variables ****/\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;\n\n    // The TransferETH event is emitted after each eth transfer in the split is attempted.\n    event TransferETH(\n        // The account to which the transfer was attempted.\n        address account,\n        // The amount for transfer that was attempted.\n        uint256 amount,\n        // Whether or not the transfer succeeded.\n        bool success\n    );\n\n    // Emits when a window is incremented.\n    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);\n\n    /**\n     * @dev Claim the funds from the all windows.\n     * @param percentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claimForAllWindows(\n        uint256 percentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        // Make sure that the user has this allocation granted.\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, percentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < currentWindow; i++) {\n            if (!isClaimed(msg.sender, i)) {\n                setClaimed(msg.sender, i);\n\n                amount += scaleAmountByPercentage(\n                    balanceForWindow[i],\n                    percentageAllocation\n                );\n            }\n        }\n\n        transferSplitAsset(msg.sender, amount);\n    }\n\n    /**\n     * @dev get Node hash of given data.\n     * @param who {address} whitelisted user address\n     * @param percentageAllocation {uint256} percentage of allocation\n     * @return {bytes32} node hash\n     */\n    function getNode(\n        address who,\n        uint256 percentageAllocation\n    ) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    who,\n                    percentageAllocation\n                )\n            );\n    }\n\n    /**\n     * @dev get scaled amount from given amount and percentage.\n     * @param amount {uint256} amount\n     * @param scaledPercent {uint256} scaled percentage\n     * @return scaledAmount {uint256} scaled amount\n     */\n    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n        public\n        pure\n        returns (uint256 scaledAmount)\n    {\n        /*\n            Example:\n                If there is 100 ETH in the account, and someone has \n                an allocation of 2%, we call this with 100 as the amount, and 200\n                as the scaled percent.\n\n                To find out the amount we use, for example: (100 * 200) / (100 * 100)\n                which returns 2 -- i.e. 2% of the 100 ETH balance.\n         */\n        scaledAmount = (amount * scaledPercent) / (10000);\n    }\n\n    /**\n     * @dev claim for the given window.\n     * @param window {uint256} Window to claim\n     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claim(\n        uint256 window,\n        uint256 scaledPercentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(currentWindow > window, \"cannot claim for a future window\");\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n\n        setClaimed(msg.sender, window);\n\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, scaledPercentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        transferSplitAsset(\n            msg.sender,\n            // The absolute amount that's claimable.\n            scaleAmountByPercentage(\n                balanceForWindow[window],\n                scaledPercentageAllocation\n            )\n        );\n    }\n\n    /**\n     * @dev Function which handles increment window and puts amount to current window\n     * @param royaltyAmount {uint256} Amount needs to be added in window.\n     * @return {bool} Whether or not the window was incremented.\n     */\n    function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n        uint256 wethBalance;\n\n        require(\n            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n            \"Royalty Vault not supported\"\n        );\n        require(\n            IRoyaltyVault(msg.sender).getSplitter() == address(this),\n            \"Unauthorised to increment window\"\n        );\n\n        wethBalance = IERC20(splitAsset).balanceOf(address(this));\n        require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n        require(royaltyAmount > 0, \"No additional funds for window\");\n        balanceForWindow.push(royaltyAmount);\n        currentWindow += 1;\n        emit WindowIncremented(currentWindow, royaltyAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bool} Whether or not the window has been claimed.\n     */\n    function isClaimed(\n        address who,\n        uint256 window\n    ) public view returns (bool) {\n        return claimed[getClaimHash(who, window)];\n    }\n\n    /**** Private Functions ****/\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     */\n    function setClaimed(\n        address who,\n        uint256 window\n    ) private {\n        claimed[getClaimHash(who, window)] = true;\n    }\n\n    /**\n     * @dev Function which returns the hash of the given window, tokenId and membershipContract.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bytes32} Hash of the given window, tokenId and membershipContract.\n     */\n    function getClaimHash(\n        address who,\n        uint256 window\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(who, window));\n    }\n\n    /**\n     * @dev Function to convert output amount from percentages.\n     * @param amount {uint256} Amount for which percentage is to be calculated.\n     * @param percent {uint256} Percentage\n     * @return {uint256} Output amount.\n     */\n    function amountFromPercent(uint256 amount, uint32 percent)\n        private\n        pure\n        returns (uint256)\n    {\n        // Solidity 0.8.0 lets us do this without SafeMath.\n        return (amount * percent) / 100;\n    }\n\n    /**\n     * @dev Function to transfer split asset to the given address.\n     * @param to {address} Address to transfer the split asset to.\n     * @param value {uint256} Amount to transfer.\n     */\n    function transferSplitAsset(address to, uint256 value)\n        private\n        returns (bool didSucceed)\n    {\n        // Try to transfer ETH to the given recipient.\n        didSucceed = IERC20(splitAsset).transfer(to, value);\n        require(didSucceed, \"Failed to transfer ETH\");\n\n        emit TransferETH(to, value, didSucceed);\n    }\n\n    /**\n     * @dev transfer given amount of ETH in contract to the given address.\n     * @param to {address} Address to transfer asset\n     * @param value {uint256} Amount to transfer\n     * @return {bool} Whether or not the transfer was successful.\n     */\n    function attemptETHTransfer(address to, uint256 value)\n        private\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n        return success;\n    }\n\n    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol\n    /**\n     * @dev Function to verify the given proof.\n     * @param proof {bytes32[]} Proof to verify\n     * @param root {bytes32} Root of the Merkle tree\n     * @param leaf {bytes32} Leaf to verify\n     * @return {bool} Whether or not the proof is valid.\n     */\n    function verifyProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) private pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n\n\n",
        "CodeNames": [
            "Splitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Splitter contract",
                "Type": "Gas inefficiency",
                "Description": "Gas costs will likely result in any fees sent to the Splitter being economically unviable to recover.",
                "Repair": "Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function."
            },
            {
                "Location": "Splitter contract",
                "Type": "Unauthorized access",
                "Description": "Anyone can call incrementWindow to steal the tokens in the contract.",
                "Repair": "Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function."
            },
            {
                "Location": "Splitter.sol line 14",
                "Type": "Differing percentage denominators causes confusion and potentially brick claims",
                "Description": "If an incorrect denominator is used, the calculated claimable amount could exceed the actual available funds in the contract, causing claims to fail and funds to be permanently locked.",
                "Repair": "Remove PERCENTAGE_SCALE because it is unused, or replace its value with 10_000 and use that instead."
            },
            {
                "Location": "Splitter.claimForAllWindows() function",
                "Type": "DoS: claimForAllWindows() May Be Made Unusable By An Attacker",
                "Description": "When the value of currentWindow is raised sufficiently high Splitter.claimForAllWindows() will not be able to be called due to the block gas limit.",
                "Repair": "Consider modifying the function claimForAllWindows() to instead claim for range of windows. Pass the function a startWindow and endWindow and only iterate through windows in that range. Ensure that endWindow < currentWindow."
            }
        ]
    }
]