[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./LiquidityReserve.sol\";\nimport \"./StakingStorage.sol\";\nimport \"../interfaces/IYieldy.sol\";\nimport \"../interfaces/ITokeManager.sol\";\nimport \"../interfaces/ITokePool.sol\";\nimport \"../interfaces/ITokeReward.sol\";\nimport \"../interfaces/ILiquidityReserve.sol\";\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ICowSettlement.sol\";\n\ncontract Staking is OwnableUpgradeable, StakingStorage {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event LogSetEpochDuration(uint256 indexed blockNumber, uint256 duration);\n    event LogSetWarmUpPeriod(uint256 indexed blockNumber, uint256 period);\n    event LogSetCoolDownPeriod(uint256 indexed blockNumber, uint256 period);\n    event LogSetPauseStaking(uint256 indexed blockNumber, bool shouldPause);\n    event LogSetPauseUnstaking(uint256 indexed blockNumber, bool shouldPause);\n    event LogSetPauseInstantUnstaking(\n        uint256 indexed blockNumber,\n        bool shouldPause\n    );\n    event LogSetAffiliateAddress(\n        uint256 indexed blockNumber,\n        address affilateAddress\n    );\n    event LogSetAffiliateFee(uint256 indexed blockNumber, uint256 fee);\n\n    event LogSetCurvePool(address indexed curvePool, int128 to, int128 from);\n\n    function initialize(\n        address _stakingToken,\n        address _yieldyToken,\n        address _tokeToken,\n        address _tokePool,\n        address _tokeManager,\n        address _tokeReward,\n        address _liquidityReserve,\n        address _feeAddress,\n        address _curvePool,\n        uint256 _epochDuration,\n        uint256 _firstEpochEndTime\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // must have valid initial addresses\n        require(\n            _stakingToken != address(0) &&\n                _yieldyToken != address(0) &&\n                _tokeToken != address(0) &&\n                _tokePool != address(0) &&\n                _tokeManager != address(0) &&\n                _tokeReward != address(0) &&\n                _liquidityReserve != address(0),\n            \"Invalid address\"\n        );\n        STAKING_TOKEN = _stakingToken;\n        YIELDY_TOKEN = _yieldyToken;\n        TOKE_TOKEN = _tokeToken;\n        TOKE_POOL = _tokePool;\n        TOKE_MANAGER = _tokeManager;\n        TOKE_REWARD = _tokeReward;\n        LIQUIDITY_RESERVE = _liquidityReserve;\n        FEE_ADDRESS = _feeAddress;\n        CURVE_POOL = _curvePool;\n        COW_SETTLEMENT = 0x9008D19f58AAbD9eD0D60971565AA8510560ab41;\n        COW_RELAYER = 0xC92E8bdf79f0507f65a392b0ab4667716BFE0110;\n\n        timeLeftToRequestWithdrawal = 12 hours;\n\n        if (CURVE_POOL != address(0)) {\n            IERC20(TOKE_POOL).approve(CURVE_POOL, type(uint256).max);\n            setToAndFromCurve();\n        }\n\n        IERC20(STAKING_TOKEN).approve(TOKE_POOL, type(uint256).max);\n        IERC20Upgradeable(YIELDY_TOKEN).approve(\n            LIQUIDITY_RESERVE,\n            type(uint256).max\n        );\n        IERC20Upgradeable(YIELDY_TOKEN).approve(\n            LIQUIDITY_RESERVE,\n            type(uint256).max\n        );\n        IERC20Upgradeable(TOKE_TOKEN).approve(COW_RELAYER, type(uint256).max);\n\n        epoch = Epoch({\n            duration: _epochDuration,\n            number: 1,\n            timestamp: block.timestamp, // we know about the issues surrounding block.timestamp, using it here will not cause any problems\n            endTime: _firstEpochEndTime,\n            distribute: 0\n        });\n    }\n\n    /**\n        @notice claim TOKE rewards from Tokemak\n        @dev must get amount through toke reward contract using latest cycle from reward hash contract\n        @param _recipient Recipient struct that contains chainId, cycle, address, and amount \n        @param _v uint - recovery id\n        @param _r bytes - output of ECDSA signature\n        @param _s bytes - output of ECDSA signature\n     */\n    function claimFromTokemak(\n        Recipient calldata _recipient,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // cannot claim 0\n        require(_recipient.amount > 0, \"Must enter valid amount\");\n\n        ITokeReward tokeRewardContract = ITokeReward(TOKE_REWARD);\n        tokeRewardContract.claim(_recipient, _v, _r, _s);\n        _sendAffiliateFee(_recipient.amount);\n    }\n\n    /**\n        @notice send affiliate fee\n        @param _amount uint - total amount to deduct fee from\n     */\n    function _sendAffiliateFee(uint256 _amount) internal {\n        if (affiliateFee != 0 && FEE_ADDRESS != address(0)) {\n            uint256 feeAmount = (_amount * affiliateFee) / BASIS_POINTS;\n            IERC20Upgradeable(TOKE_TOKEN).safeTransfer(FEE_ADDRESS, feeAmount);\n        }\n    }\n\n    /**\n        @notice transfer TOKE from staking contract to address\n        @dev used so DAO can get TOKE and manually trade to return FOX to the staking contract\n        @param _claimAddress address to send TOKE rewards\n     */\n    function transferToke(address _claimAddress) external onlyOwner {\n        // _claimAddress can't be 0x0\n        require(_claimAddress != address(0), \"Invalid address\");\n        uint256 totalTokeAmount = IERC20Upgradeable(TOKE_TOKEN).balanceOf(\n            address(this)\n        );\n        IERC20Upgradeable(TOKE_TOKEN).safeTransfer(\n            _claimAddress,\n            totalTokeAmount\n        );\n    }\n\n    /**\n        @notice sets the curve pool address\n        @param _curvePool uint\n     */\n    function setCurvePool(address _curvePool) external onlyOwner {\n        CURVE_POOL = _curvePool;\n        setToAndFromCurve();\n    }\n\n    /**\n        @notice sets the affiliate fee\n        @dev fee is set in basis points\n        @param _affiliateFee uint\n     */\n    function setAffiliateFee(uint256 _affiliateFee) external onlyOwner {\n        affiliateFee = _affiliateFee;\n        emit LogSetAffiliateFee(block.number, _affiliateFee);\n    }\n\n    /**\n        @notice sets the affiliate address to receive the affiliate fee in TOKE\n        @dev if set to 0x000.. then no affiliate will be sent\n        @param _affiliateAddress address\n     */\n    function setAffiliateAddress(address _affiliateAddress) external onlyOwner {\n        FEE_ADDRESS = _affiliateAddress;\n        emit LogSetAffiliateAddress(block.number, _affiliateAddress);\n    }\n\n    /**\n        @notice override whether or not staking is paused\n        @dev used to pause staking in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseStaking(bool _shouldPause) public onlyOwner {\n        isStakingPaused = _shouldPause;\n        emit LogSetPauseStaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice override whether or not unstake & instantUnstake is paused\n        @dev used to pause unstake & instantUnstake in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseUnstaking(bool _shouldPause) external onlyOwner {\n        isUnstakingPaused = _shouldPause;\n        emit LogSetPauseUnstaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice override whether or not instantUnstake is paused\n        @dev used to pause instantUnstake in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseInstantUnstaking(bool _shouldPause) external onlyOwner {\n        isInstantUnstakingPaused = _shouldPause;\n        emit LogSetPauseInstantUnstaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice set epoch duration\n        @dev epoch's determine how long until a rebase can occur\n        @param duration uint\n     */\n    function setEpochDuration(uint256 duration) external onlyOwner {\n        epoch.duration = duration;\n        emit LogSetEpochDuration(block.number, duration);\n    }\n\n    /**\n     * @notice set warmup period for new stakers\n     * @param _vestingPeriod uint\n     */\n    function setWarmUpPeriod(uint256 _vestingPeriod) external onlyOwner {\n        warmUpPeriod = _vestingPeriod;\n        emit LogSetWarmUpPeriod(block.number, _vestingPeriod);\n    }\n\n    /**\n     * @notice set cooldown period for stakers\n     * @param _vestingPeriod uint\n     */\n    function setCoolDownPeriod(uint256 _vestingPeriod) external onlyOwner {\n        coolDownPeriod = _vestingPeriod;\n        emit LogSetCoolDownPeriod(block.number, _vestingPeriod);\n    }\n\n    /**\n        @notice sets the time before Tokemak cycle ends to requestWithdrawals\n        @dev requestWithdrawals is called once per cycle.\n        @dev this allows us to change how much time before the end of the cycle we send the withdraw requests\n        @param _timestamp uint - time before end of cycle\n     */\n    function setTimeLeftToRequestWithdrawal(uint256 _timestamp)\n        external\n        onlyOwner\n    {\n        timeLeftToRequestWithdrawal = _timestamp;\n    }\n\n    /**\n        @notice returns true if claim is available\n        @dev this shows whether or not our epoch's have passed\n        @param _recipient address - warmup address to check if claim is available\n        @return bool - true if available to claim\n     */\n    function _isClaimAvailable(address _recipient)\n        internal\n        view\n        returns (bool)\n    {\n        Claim memory info = warmUpInfo[_recipient];\n        return epoch.number >= info.expiry && info.expiry != 0;\n    }\n\n    /**\n        @notice returns true if claimWithdraw is available\n        @dev this shows whether or not our epoch's have passed as well as if the cycle has increased\n        @param _recipient address - address that's checking for available claimWithdraw\n        @return bool - true if available to claimWithdraw\n     */\n    function _isClaimWithdrawAvailable(address _recipient)\n        internal\n        returns (bool)\n    {\n        Claim memory info = coolDownInfo[_recipient];\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        RequestedWithdrawalInfo memory requestedWithdrawals = tokePoolContract\n            .requestedWithdrawals(address(this));\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n        return\n            epoch.number >= info.expiry &&\n            info.expiry != 0 &&\n            info.amount != 0 &&\n            ((requestedWithdrawals.minCycle <= currentCycleIndex &&\n                requestedWithdrawals.amount + withdrawalAmount >=\n                info.amount) || withdrawalAmount >= info.amount);\n    }\n\n    /**\n        @notice withdraw stakingTokens from Tokemak\n        @dev needs a valid requestWithdrawal inside Tokemak with a completed cycle rollover to withdraw\n     */\n    function _withdrawFromTokemak() internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        RequestedWithdrawalInfo memory requestedWithdrawals = tokePoolContract\n            .requestedWithdrawals(address(this));\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n\n        if (\n            requestedWithdrawals.amount > 0 &&\n            requestedWithdrawals.minCycle <= currentCycleIndex\n        ) {\n            tokePoolContract.withdraw(requestedWithdrawals.amount);\n            requestWithdrawalAmount -= requestedWithdrawals.amount;\n            withdrawalAmount += requestedWithdrawals.amount;\n        }\n    }\n\n    /**\n        @notice creates a withdrawRequest with Tokemak\n        @dev requestedWithdraws take 1 tokemak cycle to be available for withdraw\n        @param _amount uint - amount to request withdraw\n     */\n    function _requestWithdrawalFromTokemak(uint256 _amount) internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        uint256 balance = ITokePool(TOKE_POOL).balanceOf(address(this));\n\n        // the only way balance < _amount is when using unstakeAllFromTokemak\n        uint256 amountToRequest = balance < _amount ? balance : _amount;\n\n        if (amountToRequest > 0) tokePoolContract.requestWithdrawal(_amount);\n    }\n\n    /**\n        @notice deposit stakingToken to tStakingToken Tokemak reactor\n        @param _amount uint - amount to deposit\n     */\n    function _depositToTokemak(uint256 _amount) internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        tokePoolContract.deposit(_amount);\n    }\n\n    /**\n        @notice gets balance of stakingToken that's locked into the TOKE stakingToken pool\n        @return uint - amount of stakingToken in TOKE pool\n     */\n    function _getTokemakBalance() internal view returns (uint256) {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        return tokePoolContract.balanceOf(address(this));\n    }\n\n    /**\n        @notice checks TOKE's cycleTime is within duration to batch the transactions\n        @dev this function returns true if we are within timeLeftToRequestWithdrawal of the end of the TOKE cycle\n        @dev as well as if the current cycle index is more than the last cycle index\n        @return bool - returns true if can batch transactions\n     */\n    function canBatchTransactions() public view returns (bool) {\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        uint256 duration = tokeManager.getCycleDuration();\n        uint256 currentCycleStart = tokeManager.getCurrentCycle();\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n        uint256 nextCycleStart = currentCycleStart + duration;\n\n        return\n            block.timestamp + timeLeftToRequestWithdrawal >= nextCycleStart &&\n            currentCycleIndex > lastTokeCycleIndex &&\n            requestWithdrawalAmount > 0;\n    }\n\n    /**\n        @notice owner function to requestWithdraw all FOX from tokemak in case of an attack on tokemak\n        @dev this bypasses the normal flow of sending a withdrawal request and allows the owner to requestWithdraw entire pool balance\n     */\n    function unstakeAllFromTokemak() public onlyOwner {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        uint256 tokePoolBalance = ITokePool(tokePoolContract).balanceOf(\n            address(this)\n        );\n        // pause any future staking\n        shouldPauseStaking(true);\n        requestWithdrawalAmount = tokePoolBalance;\n        _requestWithdrawalFromTokemak(tokePoolBalance);\n    }\n\n    /**\n        @notice sends batched requestedWithdrawals due to TOKE's requestWithdrawal overwriting the amount if you call it more than once per cycle\n     */\n    function sendWithdrawalRequests() public {\n        // check to see if near the end of a TOKE cycle\n        if (canBatchTransactions()) {\n            // if has withdrawal amount to be claimed then claim\n            _withdrawFromTokemak();\n\n            // if more requestWithdrawalAmount exists after _withdrawFromTokemak then request the new amount\n            ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n            if (requestWithdrawalAmount > 0) {\n                _requestWithdrawalFromTokemak(requestWithdrawalAmount);\n            }\n\n            uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n            lastTokeCycleIndex = currentCycleIndex;\n        }\n    }\n\n    /**\n        @notice stake staking tokens to receive Yieldy tokens\n        @param _amount uint\n        @param _recipient address\n     */\n    function stake(uint256 _amount, address _recipient) public {\n        // if override staking, then don't allow stake\n        require(!isStakingPaused, \"Staking is paused\");\n        // amount must be non zero\n        require(_amount > 0, \"Must have valid amount\");\n\n        uint256 yieldyTotalSupply = IYieldy(YIELDY_TOKEN).totalSupply();\n\n        // Don't rebase unless tokens are already staked or could get locked out of staking\n        if (yieldyTotalSupply > 0) {\n            rebase();\n        }\n\n        IERC20Upgradeable(STAKING_TOKEN).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        Claim storage info = warmUpInfo[_recipient];\n\n        // if claim is available then auto claim tokens\n        if (_isClaimAvailable(_recipient)) {\n            claim(_recipient);\n        }\n\n        _depositToTokemak(_amount);\n\n        // skip adding to warmup contract if period is 0\n        if (warmUpPeriod == 0) {\n            IYieldy(YIELDY_TOKEN).mint(_recipient, _amount);\n        } else {\n            // create a claim and mint tokens so a user can claim them once warm up has passed\n            warmUpInfo[_recipient] = Claim({\n                amount: info.amount + _amount,\n                credits: info.credits +\n                    IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),\n                expiry: epoch.number + warmUpPeriod\n            });\n\n            IYieldy(YIELDY_TOKEN).mint(address(this), _amount);\n        }\n\n        sendWithdrawalRequests();\n    }\n\n    /**\n        @notice call stake with msg.sender\n        @param _amount uint\n     */\n    function stake(uint256 _amount) external {\n        stake(_amount, msg.sender);\n    }\n\n    /**\n        @notice retrieve reward tokens from warmup\n        @dev if user has funds in warmup then user is able to claim them (including rewards)\n        @param _recipient address\n     */\n    function claim(address _recipient) public {\n        Claim memory info = warmUpInfo[_recipient];\n        if (_isClaimAvailable(_recipient)) {\n            delete warmUpInfo[_recipient];\n\n            if (info.credits > 0) {\n                IYieldy(YIELDY_TOKEN).transfer(\n                    _recipient,\n                    IYieldy(YIELDY_TOKEN).tokenBalanceForCredits(info.credits)\n                );\n            }\n        }\n    }\n\n    /**\n        @notice claims staking tokens after cooldown period\n        @dev if user has a cooldown claim that's past expiry then withdraw staking tokens from tokemak\n        @dev and send them to user\n        @param _recipient address - users unstaking address\n     */\n    function claimWithdraw(address _recipient) public {\n        Claim memory info = coolDownInfo[_recipient];\n        uint256 totalAmountIncludingRewards = IYieldy(YIELDY_TOKEN)\n            .tokenBalanceForCredits(info.credits);\n        if (_isClaimWithdrawAvailable(_recipient)) {\n            // if has withdrawalAmount to be claimed, then claim\n            _withdrawFromTokemak();\n            delete coolDownInfo[_recipient];\n\n            withdrawalAmount -= info.amount;\n\n            // only give amount from when they requested withdrawal since this amount wasn't used in generating rewards\n            // this will later be given to users through addRewardsForStakers\n            IERC20Upgradeable(STAKING_TOKEN).safeTransfer(\n                _recipient,\n                info.amount\n            );\n\n            IYieldy(YIELDY_TOKEN).burn(\n                address(this),\n                totalAmountIncludingRewards\n            );\n        }\n    }\n\n    /**\n        @notice gets reward tokens either from the warmup pool or user's wallet or both\n        @dev when transferring reward tokens the user could have their balance still in the warmup pool\n        @dev this function abstracts the logic to find the correct amount of tokens to use them\n        @param _amount uint\n        @param _user address to pull funds from \n     */\n    function _retrieveBalanceFromUser(uint256 _amount, address _user) internal {\n        Claim memory userWarmInfo = warmUpInfo[_user];\n        uint256 walletBalance = IERC20Upgradeable(YIELDY_TOKEN).balanceOf(\n            _user\n        );\n        uint256 warmUpBalance = IYieldy(YIELDY_TOKEN).tokenBalanceForCredits(\n            userWarmInfo.credits\n        );\n\n        // must have enough funds between wallet and warmup\n        require(\n            _amount <= walletBalance + warmUpBalance,\n            \"Insufficient Balance\"\n        );\n\n        uint256 amountLeft = _amount;\n        if (warmUpBalance > 0) {\n            // remove from warmup first.\n            if (_amount >= warmUpBalance) {\n                // use the entire warmup balance\n                unchecked {\n                    amountLeft -= warmUpBalance;\n                }\n                delete warmUpInfo[_user];\n            } else {\n                // partially consume warmup balance\n                amountLeft = 0;\n                uint256 remainingCreditsAmount = userWarmInfo.credits -\n                    IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount);\n                uint256 remainingAmount = IYieldy(YIELDY_TOKEN)\n                    .tokenBalanceForCredits(remainingCreditsAmount);\n\n                warmUpInfo[_user] = Claim({\n                    amount: remainingAmount,\n                    credits: remainingCreditsAmount,\n                    expiry: userWarmInfo.expiry\n                });\n            }\n        }\n\n        if (amountLeft != 0) {\n            // transfer the rest from the users address\n            IERC20Upgradeable(YIELDY_TOKEN).safeTransferFrom(\n                _user,\n                address(this),\n                amountLeft\n            );\n        }\n    }\n\n    /**\n        @notice instant unstakes from liquidity reserve\n        @param _amount uint - amount to instant unstake\n     */\n    function instantUnstakeReserve(uint256 _amount) external {\n        require(_amount > 0, \"Invalid amount\");\n        // prevent unstaking if override due to vulnerabilities\n        require(\n            !isUnstakingPaused && !isInstantUnstakingPaused,\n            \"Unstaking is paused\"\n        );\n\n        rebase();\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        uint256 reserveBalance = IERC20Upgradeable(STAKING_TOKEN).balanceOf(\n            LIQUIDITY_RESERVE\n        );\n\n        require(reserveBalance >= _amount, \"Not enough funds in reserve\");\n\n        ILiquidityReserve(LIQUIDITY_RESERVE).instantUnstake(\n            _amount,\n            msg.sender\n        );\n    }\n\n    /**\n        @notice instant unstake from curve\n        @param _amount uint - amount to instant unstake\n        @param _minAmount uint - minimum amount with slippage to instant unstake\n        @return uint - amount received\n     */\n    function instantUnstakeCurve(uint256 _amount, uint256 _minAmount)\n        external\n        returns (uint256)\n    {\n        require(_amount > 0, \"Invalid amount\");\n        require(\n            CURVE_POOL != address(0) &&\n                (curvePoolFrom == 1 || curvePoolTo == 1),\n            \"Invalid Curve Pool\"\n        );\n        // prevent unstaking if override due to vulnerabilities\n        require(\n            !isUnstakingPaused && !isInstantUnstakingPaused,\n            \"Unstaking is paused\"\n        );\n\n        rebase();\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        return\n            ICurvePool(CURVE_POOL).exchange(\n                curvePoolFrom,\n                curvePoolTo,\n                _amount,\n                _minAmount,\n                msg.sender\n            );\n    }\n\n    /**\n        @notice sets to and from coin indexes for curve exchange\n     */\n    function setToAndFromCurve() internal {\n        if (CURVE_POOL != address(0)) {\n            address address0 = ICurvePool(CURVE_POOL).coins(0);\n            address address1 = ICurvePool(CURVE_POOL).coins(1);\n            int128 from = 0;\n            int128 to = 0;\n\n            if (TOKE_POOL == address0 && STAKING_TOKEN == address1) {\n                to = 1;\n            } else if (TOKE_POOL == address1 && STAKING_TOKEN == address0) {\n                from = 1;\n            }\n            require(from == 1 || to == 1, \"Invalid Curve Pool\");\n\n            curvePoolFrom = from;\n            curvePoolTo = to;\n\n            emit LogSetCurvePool(CURVE_POOL, curvePoolTo, curvePoolFrom);\n        }\n    }\n\n    /**\n        @notice estimate received using instant unstake from curve\n        @param _amount uint - amount to instant unstake\n        @return uint - estimated amount received\n     */\n    function estimateInstantCurve(uint256 _amount)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            ICurvePool(CURVE_POOL).get_dy(curvePoolFrom, curvePoolTo, _amount);\n    }\n\n    /**\n        @notice redeem Yieldy tokens for staking tokens with a vesting period based on coolDownPeriod\n        @dev this function will retrieve the _amount of Yieldy tokens from the user and transfer them to the cooldown contract.\n        @dev once the period has expired the user will be able to withdraw their staking tokens\n        @param _amount uint - amount of tokens to unstake\n        @param _trigger bool - should trigger a rebase\n     */\n    function unstake(uint256 _amount, bool _trigger) external {\n        // prevent unstaking if override due to vulnerabilities asdf\n        require(!isUnstakingPaused, \"Unstaking is paused\");\n        if (_trigger) {\n            rebase();\n        }\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        Claim storage userCoolInfo = coolDownInfo[msg.sender];\n\n        // try to claim withdraw if user has withdraws to claim function will check if withdraw is valid\n        claimWithdraw(msg.sender);\n\n        coolDownInfo[msg.sender] = Claim({\n            amount: userCoolInfo.amount + _amount,\n            credits: userCoolInfo.credits +\n                IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),\n            expiry: epoch.number + coolDownPeriod\n        });\n\n        requestWithdrawalAmount += _amount;\n        sendWithdrawalRequests();\n    }\n\n    /**\n        @notice trigger rebase if epoch has ended\n     */\n    function rebase() public {\n        // we know about the issues surrounding block.timestamp, using it here will not cause any problems\n        if (epoch.endTime <= block.timestamp) {\n            IYieldy(YIELDY_TOKEN).rebase(epoch.distribute, epoch.number);\n\n            epoch.endTime = epoch.endTime + epoch.duration;\n            epoch.timestamp = block.timestamp;\n            epoch.number++;\n\n            uint256 balance = contractBalance();\n            uint256 staked = IYieldy(YIELDY_TOKEN).totalSupply();\n\n            if (balance <= staked) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance - staked;\n            }\n        }\n    }\n\n    /**\n        @notice returns contract staking tokens holdings \n        @dev gets amount of staking tokens that are a part of this system to calculate rewards\n        @dev the staking tokens will be included in this contract plus inside tokemak\n        @return uint - amount of staking tokens\n     */\n    function contractBalance() internal view returns (uint256) {\n        uint256 tokeBalance = _getTokemakBalance();\n        return\n            IERC20Upgradeable(STAKING_TOKEN).balanceOf(address(this)) +\n            tokeBalance;\n    }\n\n    /**\n     * @notice adds staking tokens for rebase rewards\n     * @dev this is the function that gives rewards so the rebase function can distribute profits to reward token holders\n     * @param _amount uint - amount of tokens to add to rewards\n     * @param _shouldTransfer bool - should transfer tokens before adding rewards\n     * @param _trigger bool - should trigger rebase\n     */\n    function addRewardsForStakers(\n        uint256 _amount,\n        bool _shouldTransfer,\n        bool _trigger\n    ) external {\n        if (_shouldTransfer) {\n            IERC20Upgradeable(STAKING_TOKEN).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _amount\n            );\n        }\n\n        // deposit all staking tokens held in contract to Tokemak minus tokens waiting for claimWithdraw\n        uint256 stakingTokenBalance = IERC20Upgradeable(STAKING_TOKEN)\n            .balanceOf(address(this));\n        uint256 amountToDeposit = stakingTokenBalance - withdrawalAmount;\n        _depositToTokemak(amountToDeposit);\n\n        if (_trigger) {\n            rebase();\n        }\n    }\n\n    /**\n     * @notice trades rewards generated from claimFromTokemak for staking token\n     * @dev this is function is called from claimFromTokemak if the autoRebase bool is set to true\n     */\n    function preSign(bytes calldata orderUid) external onlyOwner {\n        ICowSettlement(COW_SETTLEMENT).setPreSignature(orderUid, true);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldyStorage.sol\";\nimport \"../libraries/ERC20PermitUpgradeable.sol\";\n\ncontract Yieldy is\n    YieldyStorage,\n    ERC20PermitUpgradeable,\n    AccessControlUpgradeable\n{\n    event LogSupply(\n        uint256 indexed epoch,\n        uint256 timestamp,\n        uint256 totalSupply\n    );\n\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n\n    /**\n        @notice initialize function\n        @param _tokenName erc20 token name\n        @param _tokenSymbol erc20 token symbol\n        @param _decimal decimal amount\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _decimal\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        ERC20PermitUpgradeable.__ERC20Permit_init(_tokenName);\n        AccessControlUpgradeable.__AccessControl_init();\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(MINTER_BURNER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(REBASE_ROLE, ADMIN_ROLE);\n\n        decimal = _decimal;\n        WAD = 10**decimal;\n        rebasingCreditsPerToken = WAD;\n        _setIndex(WAD);\n    }\n\n    /**\n        @notice called by the admin role address to set the staking contract. Can only be called\n        once. \n        @param _stakingContract address of the staking contract\n     */\n    function initializeStakingContract(address _stakingContract)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        require(stakingContract == address(0), \"Already Initialized\");\n        require(_stakingContract != address(0), \"Invalid address\");\n        stakingContract = _stakingContract;\n        _setupRole(MINTER_BURNER_ROLE, _stakingContract);\n        _setupRole(REBASE_ROLE, _stakingContract);\n    }\n\n    /**\n        @notice sets index to get the value of rebases from the beginning of the contract\n        @param _index uint - initial index\n     */\n    function _setIndex(uint256 _index) internal {\n        index = creditsForTokenBalance(_index);\n    }\n\n    /**\n        @notice increases Yieldy supply to increase staking balances relative to profit_\n        @param _profit uint256 - amount of rewards to distribute\n        @param _epoch uint256 - epoch number\n     */\n    function rebase(uint256 _profit, uint256 _epoch)\n        external\n        onlyRole(REBASE_ROLE)\n    {\n        uint256 currentTotalSupply = _totalSupply;\n        require(_totalSupply > 0, \"Can't rebase if not circulating\");\n\n        if (_profit == 0) {\n            emit LogSupply(_epoch, block.timestamp, currentTotalSupply);\n            emit LogRebase(_epoch, 0, getIndex());\n        } else {\n            uint256 updatedTotalSupply = currentTotalSupply + _profit;\n\n            if (updatedTotalSupply > MAX_SUPPLY) {\n                updatedTotalSupply = MAX_SUPPLY;\n            }\n\n            rebasingCreditsPerToken = rebasingCredits / updatedTotalSupply;\n            require(rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n            _totalSupply = updatedTotalSupply;\n\n            _storeRebase(updatedTotalSupply, _profit, _epoch);\n        }\n    }\n\n    /**\n        @notice emits event with data about rebase\n        @param _previousCirculating uint\n        @param _profit uint\n        @param _epoch uint\n     */\n    function _storeRebase(\n        uint256 _previousCirculating,\n        uint256 _profit,\n        uint256 _epoch\n    ) internal {\n        uint256 rebasePercent = (_profit * WAD) / _previousCirculating;\n\n        rebases.push(\n            Rebase({\n                epoch: _epoch,\n                rebase: rebasePercent,\n                totalStakedBefore: _previousCirculating,\n                totalStakedAfter: _totalSupply,\n                amountRebased: _profit,\n                index: getIndex(),\n                blockNumberOccurred: block.number\n            })\n        );\n\n        emit LogSupply(_epoch, block.timestamp, _totalSupply);\n        emit LogRebase(_epoch, rebasePercent, getIndex());\n    }\n\n    /**\n        @notice gets balanceOf Yieldy\n        @param _wallet address\n        @return uint\n     */\n    function balanceOf(address _wallet) public view override returns (uint256) {\n        return creditBalances[_wallet] / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate credits based on balance amount\n        @param _amount uint\n        @return uint\n     */\n    function creditsForTokenBalance(uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        return _amount * rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate balance based on _credits amount\n        @param _credits uint\n        @return uint\n     */\n    function tokenBalanceForCredits(uint256 _credits)\n        public\n        view\n        returns (uint256)\n    {\n        return _credits / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice get current index to show what how much Yieldy the user would have gained if staked from the beginning\n        @return uint - current index\n     */\n    function getIndex() public view returns (uint256) {\n        return tokenBalanceForCredits(index);\n    }\n\n    /**\n        @notice transfers to _to address with an amount of _value\n        @param _to address\n        @param _value uint\n        @return bool - transfer succeeded\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        require(_to != address(0), \"Invalid address\");\n\n        uint256 creditAmount = _value * rebasingCreditsPerToken;\n        require(creditAmount <= creditBalances[msg.sender], \"Not enough funds\");\n\n        creditBalances[msg.sender] = creditBalances[msg.sender] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n        @notice transfer from address to address with amount\n        @param _from address\n        @param _to address\n        @param _value uint\n        @return bool\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        require(_allowances[_from][msg.sender] >= _value, \"Allowance too low\");\n\n        uint256 newValue = _allowances[_from][msg.sender] - _value;\n        _allowances[_from][msg.sender] = newValue;\n        emit Approval(_from, msg.sender, newValue);\n\n        uint256 creditAmount = creditsForTokenBalance(_value);\n        creditBalances[_from] = creditBalances[_from] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n        @notice should be same as yield decimal\n     */\n    function decimals() public view override returns (uint8) {\n        return decimal;\n    }\n\n    /**\n        @notice called from the staking contract co create Yieldy tokens\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function mint(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _mint(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 mint functionality\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function _mint(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Mint to the zero address\");\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        creditBalances[_address] = creditBalances[_address] + creditAmount;\n        rebasingCredits = rebasingCredits + creditAmount;\n\n        _totalSupply = _totalSupply + _amount;\n\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _address, _amount);\n    }\n\n    /**\n        @notice called from the staking contract co burn Yieldy tokens\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function burn(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _burn(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 burn functionality\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function _burn(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        uint256 currentCredits = creditBalances[_address];\n        require(currentCredits >= creditAmount, \"Not enough balance\");\n\n        creditBalances[_address] = creditBalances[_address] - creditAmount;\n        rebasingCredits = rebasingCredits - creditAmount;\n        _totalSupply = _totalSupply - _amount;\n\n        emit Transfer(_address, address(0), _amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "Staking.sol",
            "Yieldy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Staking contract's rebase() function and Yieldy contract's rebase() function",
                "Type": "DOS and fund loss",
                "Description": "It's possible to perform DOS and fund loss in Staking by transferring tokens directly to the contract and making rebasingCredits / updatedTotalSupply equal to 0.",
                "Repair": "Set a high initial value for rebasingCredits to prevent the attack"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/ILiquidityReserve.sol\";\nimport \"./LiquidityReserveStorage.sol\";\n\ncontract LiquidityReserve is\n    LiquidityReserveStorage,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    ILiquidityReserve\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event FeeChanged(uint256 fee);\n\n    // check if sender is the stakingContract\n    modifier onlyStakingContract() {\n        require(msg.sender == stakingContract, \"Not staking contract\");\n        _;\n    }\n\n    /**\n        @notice initialize by setting stakingContract & setting initial liquidity\n        @param _tokenName name of the lrToken to be created\n        @param _tokenSymbol symbol of the lrToken to be created.\n        @param _stakingToken the staking token in use\n        @param _rewardToken the reward token in use\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _stakingToken,\n        address _rewardToken\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        OwnableUpgradeable.__Ownable_init();\n        require(\n            _stakingToken != address(0) && _rewardToken != address(0),\n            \"Invalid address\"\n        );\n        stakingToken = _stakingToken;\n        rewardToken = _rewardToken;\n    }\n\n    /**\n        @notice callable once after initialized by the owner to set the staking contract and enable\n        our reserve to be used.\n        @param _stakingContract address of the staking contract\n     */\n    function enableLiquidityReserve(address _stakingContract)\n        external\n        onlyOwner\n    {\n        require(!isReserveEnabled, \"Already enabled\");\n        require(_stakingContract != address(0), \"Invalid address\");\n\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            msg.sender\n        );\n        // require address has minimum liquidity\n        require(\n            stakingTokenBalance >= MINIMUM_LIQUIDITY,\n            \"Not enough staking tokens\"\n        );\n        stakingContract = _stakingContract;\n\n        // permanently lock the first MINIMUM_LIQUIDITY of lrTokens\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            MINIMUM_LIQUIDITY\n        );\n        _mint(address(this), MINIMUM_LIQUIDITY);\n        IERC20Upgradeable(rewardToken).approve(\n            stakingContract,\n            type(uint256).max\n        );\n        isReserveEnabled = true;\n    }\n\n    /**\n        @notice sets Fee (in basis points eg. 100 bps = 1%) for instant unstaking\n        @param _fee uint - fee in basis points\n     */\n    function setFee(uint256 _fee) external onlyOwner {\n        // check range before setting fee\n        require(_fee <= BASIS_POINTS, \"Out of range\");\n        fee = _fee;\n\n        emit FeeChanged(_fee);\n    }\n\n    /**\n        @notice addLiquidity for the stakingToken and receive lrToken in exchange\n        @param _amount uint - amount of staking tokens to add\n     */\n    function addLiquidity(uint256 _amount) external {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 lrFoxSupply = totalSupply();\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n\n        uint256 amountToMint = (_amount * lrFoxSupply) / totalLockedValue;\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice calculate current lrToken withdraw value\n        @param _amount uint - amount of tokens that will be withdrawn\n        @return uint - converted amount of staking tokens to withdraw from lr tokens\n     */\n    function _calculateReserveTokenValue(uint256 _amount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 lrFoxSupply = totalSupply();\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n        uint256 convertedAmount = (_amount * totalLockedValue) / lrFoxSupply;\n\n        return convertedAmount;\n    }\n\n    /**\n        @notice removeLiquidity by swapping your lrToken for stakingTokens\n        @param _amount uint - amount of tokens to remove from liquidity reserve\n     */\n    function removeLiquidity(uint256 _amount) external {\n        // check balance before removing liquidity\n        require(_amount <= balanceOf(msg.sender), \"Not enough lr tokens\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountToWithdraw = _calculateReserveTokenValue(_amount);\n\n        // verify that we have enough stakingTokens\n        require(\n            IERC20Upgradeable(stakingToken).balanceOf(address(this)) >=\n                amountToWithdraw,\n            \"Not enough funds\"\n        );\n\n        _burn(msg.sender, _amount);\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            msg.sender,\n            amountToWithdraw\n        );\n    }\n\n    /**\n        @notice allow instant unstake their stakingToken for a fee paid to the liquidity providers\n        @param _amount uint - amount of tokens to instantly unstake\n        @param _recipient address - address to send staking tokens to\n     */\n    function instantUnstake(uint256 _amount, address _recipient)\n        external\n        onlyStakingContract\n    {\n        require(isReserveEnabled, \"Not enabled yet\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountMinusFee = _amount - ((_amount * fee) / BASIS_POINTS);\n\n        IERC20Upgradeable(rewardToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            _recipient,\n            amountMinusFee\n        );\n        unstakeAllRewardTokens();\n    }\n\n    /**\n        @notice find balance of reward tokens in contract and unstake them from staking contract\n     */\n    function unstakeAllRewardTokens() public {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        if (coolDownAmount == 0) {\n            uint256 amount = IERC20Upgradeable(rewardToken).balanceOf(\n                address(this)\n            );\n            if (amount > 0) IStaking(stakingContract).unstake(amount, false);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityReserve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LiquidityReserve contract's addLiquidity() function",
                "Type": "User fund loss",
                "Description": "It's possible for an attacker to manipulate totalLockedValue and make totalLockedValue/lrFoxSupply very high, causing users to receive very low IrToken and lose funds.",
                "Repair": "Add more precision when calculating IrToken to prevent the attack"
            },
            {
                "Location": "LiquidityReserve.sol",
                "Type": "Yield of LiquidityReserve can be stolen",
                "Description": "Using sandwich attacks and JIT (Just-in-time liquidity), the yield of LiquidityReserve could be extracted for liquidity providers.",
                "Repair": "store the earned fees and distribute them across multiple blocks to make sure the attack wouldn\u2019t be worth it, add a small fee when removing liquidity, which would make the attack unprofitable, prevent users from withdrawing before X blocks or add a locking mechanism"
            },
            {
                "Location": "removeLiquidity function in LiquidityReserve.sol",
                "Type": "MINIMUM_LIQUIDITY checks missing - Bringing Liquidity below required min",
                "Description": "The whale who provided most liquidity to the contract can simply use removeLiquidity function and can remove all of their liquidity. This can leave the residual liquidity to be less than MINIMUM_LIQUIDITY, which is incorrect.",
                "Repair": "Add a check to require that the balance liquidity is greater than MINIMUM_LIQUIDITY"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_mint function in the contract",
                "Type": "Cannot mint to exactly max supply using _mint function",
                "Description": "Cannot mint to exactly max supply using _mint function.",
                "Repair": "Change to require(_totalSupply <= MAX_SUPPLY, \"Max supply\");"
            },
            {
                "Location": "function stake(uint256 _amount, address _recipient) public {",
                "Type": "Arbitrage",
                "Description": "There is a huge arbitrage opportunity for people who deposit 1 block before the rebase(). They can call instantUnstakeReserve or instantUnstakeCurve to unstake the staked amount, increasing the profit that needs to be distributed on the next rebase. The instantUnstakeReserve does not burn the YIELD_TOKEN, and even if there is a fee on it, there is still a chance for profit.",
                "Repair": "Set a high enough fee on instantUnstakeReserve to make arbitrage not profitable. Potentially disallow the warm-up period to be violated for instant unstaking through curve at the very least."
            },
            {
                "Location": "function removeAddress(uint256 _index) public {",
                "Type": "Denial of Service",
                "Description": "The BatchRequests.removeAddress logic is wrong and will produce a denial of service. Removing the element from the array is done using the delete statement, which is not the proper way to remove an entry from an array. It will just set that position to address(0), causing the call to canBatchContracts to address(0) and denying service.",
                "Repair": "Use pop to remove an entry in an array and move the last element to the removed entry position."
            },
            {
                "Location": "function claim(address _recipient) public {",
                "Type": "Logic Flaw",
                "Description": "In the Yieldy contract, functions such as balanceOf/creditsForTokenBalance/tokenBalanceForCredits/transfer/transferFrom/burn/mint will use the rebasingCreditsPerToken variable, so before calling these functions in the Staking contract, make sure that the rebase of this epoch has occurred. Therefore, the rebase function should also be called in the unstake/claim/claimWithdraw function of the Staking contract.",
                "Repair": "Call the rebase function before calling the function in the Yieldy contract that uses the rebasingCreditsPerToken variable."
            },
            {
                "Location": "function withdraw(uint256 _amount, bool asEth) external {",
                "Type": "Withdrawal Issue",
                "Description": "The withdraw function of the ETH Tokemak pool has an additional parameter asEth. When the staking token is ETH/WETH and no withdrawals would be possible, the call to withdraw will fail, leaving the funds locked.",
                "Repair": "Handle the case where the underlying asset is WETH/ETH separately and pass this boolean in that case."
            },
            {
                "Location": "function stake(uint256 _amount, address _recipient) public {",
                "Type": "Denial of Service",
                "Description": "In the Staking.sol#stake() function, you can specify an arbitrary address as the _recipient. When warmUpPeriod > 0, with as little as 1 wei of YIELDY_TOKEN, the _recipient's warmUpInfo will be pushed back until epoch.number + warmUpPeriod. Consider changing to not allow deposit to another address when warmUpPeriod > 0.",
                "Repair": "Disallow deposit to another address when warmUpPeriod > 0."
            },
            {
                "Location": "_requestWithdrawalFromTokemak function",
                "Type": "Incorrect Withdrawal",
                "Description": "Incorrect withdrawal requested.",
                "Repair": "Modify Staking.sol#L326 to if (amountToRequest > 0) tokePoolContract.requestWithdrawal(amountToRequest);"
            },
            {
                "Location": "sendWithdrawalRequest function",
                "Type": "Withdrawal",
                "Description": "Withdrawals initiated after cycle withdrawal request won't be withdrawn in the correct cycle.",
                "Repair": "Remove the requirement in L362 that checks if currentCycleIndex is equal to lastTokeCycleIndex."
            },
            {
                "Location": "unstake function",
                "Type": "Withdrawal",
                "Description": "User can initiate withdraw for previous epoch if rebase hasn't been called since end of epoch.",
                "Repair": "Make rebase() mandatory when calling unstake()."
            },
            {
                "Location": "instantUnstake function",
                "Type": "Frontrunning",
                "Description": "instantUnstake function can be frontrunned with fee increase.",
                "Repair": "Introduce an upper limit for fees and add timelock to change fee size."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./LiquidityReserve.sol\";\nimport \"./StakingStorage.sol\";\nimport \"../interfaces/IYieldy.sol\";\nimport \"../interfaces/ITokeManager.sol\";\nimport \"../interfaces/ITokePool.sol\";\nimport \"../interfaces/ITokeReward.sol\";\nimport \"../interfaces/ILiquidityReserve.sol\";\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ICowSettlement.sol\";\n\ncontract Staking is OwnableUpgradeable, StakingStorage {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event LogSetEpochDuration(uint256 indexed blockNumber, uint256 duration);\n    event LogSetWarmUpPeriod(uint256 indexed blockNumber, uint256 period);\n    event LogSetCoolDownPeriod(uint256 indexed blockNumber, uint256 period);\n    event LogSetPauseStaking(uint256 indexed blockNumber, bool shouldPause);\n    event LogSetPauseUnstaking(uint256 indexed blockNumber, bool shouldPause);\n    event LogSetPauseInstantUnstaking(\n        uint256 indexed blockNumber,\n        bool shouldPause\n    );\n    event LogSetAffiliateAddress(\n        uint256 indexed blockNumber,\n        address affilateAddress\n    );\n    event LogSetAffiliateFee(uint256 indexed blockNumber, uint256 fee);\n\n    event LogSetCurvePool(address indexed curvePool, int128 to, int128 from);\n\n    function initialize(\n        address _stakingToken,\n        address _yieldyToken,\n        address _tokeToken,\n        address _tokePool,\n        address _tokeManager,\n        address _tokeReward,\n        address _liquidityReserve,\n        address _feeAddress,\n        address _curvePool,\n        uint256 _epochDuration,\n        uint256 _firstEpochEndTime\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // must have valid initial addresses\n        require(\n            _stakingToken != address(0) &&\n                _yieldyToken != address(0) &&\n                _tokeToken != address(0) &&\n                _tokePool != address(0) &&\n                _tokeManager != address(0) &&\n                _tokeReward != address(0) &&\n                _liquidityReserve != address(0),\n            \"Invalid address\"\n        );\n        STAKING_TOKEN = _stakingToken;\n        YIELDY_TOKEN = _yieldyToken;\n        TOKE_TOKEN = _tokeToken;\n        TOKE_POOL = _tokePool;\n        TOKE_MANAGER = _tokeManager;\n        TOKE_REWARD = _tokeReward;\n        LIQUIDITY_RESERVE = _liquidityReserve;\n        FEE_ADDRESS = _feeAddress;\n        CURVE_POOL = _curvePool;\n        COW_SETTLEMENT = 0x9008D19f58AAbD9eD0D60971565AA8510560ab41;\n        COW_RELAYER = 0xC92E8bdf79f0507f65a392b0ab4667716BFE0110;\n\n        timeLeftToRequestWithdrawal = 12 hours;\n\n        if (CURVE_POOL != address(0)) {\n            IERC20(TOKE_POOL).approve(CURVE_POOL, type(uint256).max);\n            setToAndFromCurve();\n        }\n\n        IERC20(STAKING_TOKEN).approve(TOKE_POOL, type(uint256).max);\n        IERC20Upgradeable(YIELDY_TOKEN).approve(\n            LIQUIDITY_RESERVE,\n            type(uint256).max\n        );\n        IERC20Upgradeable(YIELDY_TOKEN).approve(\n            LIQUIDITY_RESERVE,\n            type(uint256).max\n        );\n        IERC20Upgradeable(TOKE_TOKEN).approve(COW_RELAYER, type(uint256).max);\n\n        epoch = Epoch({\n            duration: _epochDuration,\n            number: 1,\n            timestamp: block.timestamp, // we know about the issues surrounding block.timestamp, using it here will not cause any problems\n            endTime: _firstEpochEndTime,\n            distribute: 0\n        });\n    }\n\n    /**\n        @notice claim TOKE rewards from Tokemak\n        @dev must get amount through toke reward contract using latest cycle from reward hash contract\n        @param _recipient Recipient struct that contains chainId, cycle, address, and amount \n        @param _v uint - recovery id\n        @param _r bytes - output of ECDSA signature\n        @param _s bytes - output of ECDSA signature\n     */\n    function claimFromTokemak(\n        Recipient calldata _recipient,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // cannot claim 0\n        require(_recipient.amount > 0, \"Must enter valid amount\");\n\n        ITokeReward tokeRewardContract = ITokeReward(TOKE_REWARD);\n        tokeRewardContract.claim(_recipient, _v, _r, _s);\n        _sendAffiliateFee(_recipient.amount);\n    }\n\n    /**\n        @notice send affiliate fee\n        @param _amount uint - total amount to deduct fee from\n     */\n    function _sendAffiliateFee(uint256 _amount) internal {\n        if (affiliateFee != 0 && FEE_ADDRESS != address(0)) {\n            uint256 feeAmount = (_amount * affiliateFee) / BASIS_POINTS;\n            IERC20Upgradeable(TOKE_TOKEN).safeTransfer(FEE_ADDRESS, feeAmount);\n        }\n    }\n\n    /**\n        @notice transfer TOKE from staking contract to address\n        @dev used so DAO can get TOKE and manually trade to return FOX to the staking contract\n        @param _claimAddress address to send TOKE rewards\n     */\n    function transferToke(address _claimAddress) external onlyOwner {\n        // _claimAddress can't be 0x0\n        require(_claimAddress != address(0), \"Invalid address\");\n        uint256 totalTokeAmount = IERC20Upgradeable(TOKE_TOKEN).balanceOf(\n            address(this)\n        );\n        IERC20Upgradeable(TOKE_TOKEN).safeTransfer(\n            _claimAddress,\n            totalTokeAmount\n        );\n    }\n\n    /**\n        @notice sets the curve pool address\n        @param _curvePool uint\n     */\n    function setCurvePool(address _curvePool) external onlyOwner {\n        CURVE_POOL = _curvePool;\n        setToAndFromCurve();\n    }\n\n    /**\n        @notice sets the affiliate fee\n        @dev fee is set in basis points\n        @param _affiliateFee uint\n     */\n    function setAffiliateFee(uint256 _affiliateFee) external onlyOwner {\n        affiliateFee = _affiliateFee;\n        emit LogSetAffiliateFee(block.number, _affiliateFee);\n    }\n\n    /**\n        @notice sets the affiliate address to receive the affiliate fee in TOKE\n        @dev if set to 0x000.. then no affiliate will be sent\n        @param _affiliateAddress address\n     */\n    function setAffiliateAddress(address _affiliateAddress) external onlyOwner {\n        FEE_ADDRESS = _affiliateAddress;\n        emit LogSetAffiliateAddress(block.number, _affiliateAddress);\n    }\n\n    /**\n        @notice override whether or not staking is paused\n        @dev used to pause staking in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseStaking(bool _shouldPause) public onlyOwner {\n        isStakingPaused = _shouldPause;\n        emit LogSetPauseStaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice override whether or not unstake & instantUnstake is paused\n        @dev used to pause unstake & instantUnstake in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseUnstaking(bool _shouldPause) external onlyOwner {\n        isUnstakingPaused = _shouldPause;\n        emit LogSetPauseUnstaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice override whether or not instantUnstake is paused\n        @dev used to pause instantUnstake in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseInstantUnstaking(bool _shouldPause) external onlyOwner {\n        isInstantUnstakingPaused = _shouldPause;\n        emit LogSetPauseInstantUnstaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice set epoch duration\n        @dev epoch's determine how long until a rebase can occur\n        @param duration uint\n     */\n    function setEpochDuration(uint256 duration) external onlyOwner {\n        epoch.duration = duration;\n        emit LogSetEpochDuration(block.number, duration);\n    }\n\n    /**\n     * @notice set warmup period for new stakers\n     * @param _vestingPeriod uint\n     */\n    function setWarmUpPeriod(uint256 _vestingPeriod) external onlyOwner {\n        warmUpPeriod = _vestingPeriod;\n        emit LogSetWarmUpPeriod(block.number, _vestingPeriod);\n    }\n\n    /**\n     * @notice set cooldown period for stakers\n     * @param _vestingPeriod uint\n     */\n    function setCoolDownPeriod(uint256 _vestingPeriod) external onlyOwner {\n        coolDownPeriod = _vestingPeriod;\n        emit LogSetCoolDownPeriod(block.number, _vestingPeriod);\n    }\n\n    /**\n        @notice sets the time before Tokemak cycle ends to requestWithdrawals\n        @dev requestWithdrawals is called once per cycle.\n        @dev this allows us to change how much time before the end of the cycle we send the withdraw requests\n        @param _timestamp uint - time before end of cycle\n     */\n    function setTimeLeftToRequestWithdrawal(uint256 _timestamp)\n        external\n        onlyOwner\n    {\n        timeLeftToRequestWithdrawal = _timestamp;\n    }\n\n    /**\n        @notice returns true if claim is available\n        @dev this shows whether or not our epoch's have passed\n        @param _recipient address - warmup address to check if claim is available\n        @return bool - true if available to claim\n     */\n    function _isClaimAvailable(address _recipient)\n        internal\n        view\n        returns (bool)\n    {\n        Claim memory info = warmUpInfo[_recipient];\n        return epoch.number >= info.expiry && info.expiry != 0;\n    }\n\n    /**\n        @notice returns true if claimWithdraw is available\n        @dev this shows whether or not our epoch's have passed as well as if the cycle has increased\n        @param _recipient address - address that's checking for available claimWithdraw\n        @return bool - true if available to claimWithdraw\n     */\n    function _isClaimWithdrawAvailable(address _recipient)\n        internal\n        returns (bool)\n    {\n        Claim memory info = coolDownInfo[_recipient];\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        RequestedWithdrawalInfo memory requestedWithdrawals = tokePoolContract\n            .requestedWithdrawals(address(this));\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n        return\n            epoch.number >= info.expiry &&\n            info.expiry != 0 &&\n            info.amount != 0 &&\n            ((requestedWithdrawals.minCycle <= currentCycleIndex &&\n                requestedWithdrawals.amount + withdrawalAmount >=\n                info.amount) || withdrawalAmount >= info.amount);\n    }\n\n    /**\n        @notice withdraw stakingTokens from Tokemak\n        @dev needs a valid requestWithdrawal inside Tokemak with a completed cycle rollover to withdraw\n     */\n    function _withdrawFromTokemak() internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        RequestedWithdrawalInfo memory requestedWithdrawals = tokePoolContract\n            .requestedWithdrawals(address(this));\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n\n        if (\n            requestedWithdrawals.amount > 0 &&\n            requestedWithdrawals.minCycle <= currentCycleIndex\n        ) {\n            tokePoolContract.withdraw(requestedWithdrawals.amount);\n            requestWithdrawalAmount -= requestedWithdrawals.amount;\n            withdrawalAmount += requestedWithdrawals.amount;\n        }\n    }\n\n    /**\n        @notice creates a withdrawRequest with Tokemak\n        @dev requestedWithdraws take 1 tokemak cycle to be available for withdraw\n        @param _amount uint - amount to request withdraw\n     */\n    function _requestWithdrawalFromTokemak(uint256 _amount) internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        uint256 balance = ITokePool(TOKE_POOL).balanceOf(address(this));\n\n        // the only way balance < _amount is when using unstakeAllFromTokemak\n        uint256 amountToRequest = balance < _amount ? balance : _amount;\n\n        if (amountToRequest > 0) tokePoolContract.requestWithdrawal(_amount);\n    }\n\n    /**\n        @notice deposit stakingToken to tStakingToken Tokemak reactor\n        @param _amount uint - amount to deposit\n     */\n    function _depositToTokemak(uint256 _amount) internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        tokePoolContract.deposit(_amount);\n    }\n\n    /**\n        @notice gets balance of stakingToken that's locked into the TOKE stakingToken pool\n        @return uint - amount of stakingToken in TOKE pool\n     */\n    function _getTokemakBalance() internal view returns (uint256) {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        return tokePoolContract.balanceOf(address(this));\n    }\n\n    /**\n        @notice checks TOKE's cycleTime is within duration to batch the transactions\n        @dev this function returns true if we are within timeLeftToRequestWithdrawal of the end of the TOKE cycle\n        @dev as well as if the current cycle index is more than the last cycle index\n        @return bool - returns true if can batch transactions\n     */\n    function canBatchTransactions() public view returns (bool) {\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        uint256 duration = tokeManager.getCycleDuration();\n        uint256 currentCycleStart = tokeManager.getCurrentCycle();\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n        uint256 nextCycleStart = currentCycleStart + duration;\n\n        return\n            block.timestamp + timeLeftToRequestWithdrawal >= nextCycleStart &&\n            currentCycleIndex > lastTokeCycleIndex &&\n            requestWithdrawalAmount > 0;\n    }\n\n    /**\n        @notice owner function to requestWithdraw all FOX from tokemak in case of an attack on tokemak\n        @dev this bypasses the normal flow of sending a withdrawal request and allows the owner to requestWithdraw entire pool balance\n     */\n    function unstakeAllFromTokemak() public onlyOwner {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        uint256 tokePoolBalance = ITokePool(tokePoolContract).balanceOf(\n            address(this)\n        );\n        // pause any future staking\n        shouldPauseStaking(true);\n        requestWithdrawalAmount = tokePoolBalance;\n        _requestWithdrawalFromTokemak(tokePoolBalance);\n    }\n\n    /**\n        @notice sends batched requestedWithdrawals due to TOKE's requestWithdrawal overwriting the amount if you call it more than once per cycle\n     */\n    function sendWithdrawalRequests() public {\n        // check to see if near the end of a TOKE cycle\n        if (canBatchTransactions()) {\n            // if has withdrawal amount to be claimed then claim\n            _withdrawFromTokemak();\n\n            // if more requestWithdrawalAmount exists after _withdrawFromTokemak then request the new amount\n            ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n            if (requestWithdrawalAmount > 0) {\n                _requestWithdrawalFromTokemak(requestWithdrawalAmount);\n            }\n\n            uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n            lastTokeCycleIndex = currentCycleIndex;\n        }\n    }\n\n    /**\n        @notice stake staking tokens to receive Yieldy tokens\n        @param _amount uint\n        @param _recipient address\n     */\n    function stake(uint256 _amount, address _recipient) public {\n        // if override staking, then don't allow stake\n        require(!isStakingPaused, \"Staking is paused\");\n        // amount must be non zero\n        require(_amount > 0, \"Must have valid amount\");\n\n        uint256 yieldyTotalSupply = IYieldy(YIELDY_TOKEN).totalSupply();\n\n        // Don't rebase unless tokens are already staked or could get locked out of staking\n        if (yieldyTotalSupply > 0) {\n            rebase();\n        }\n\n        IERC20Upgradeable(STAKING_TOKEN).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        Claim storage info = warmUpInfo[_recipient];\n\n        // if claim is available then auto claim tokens\n        if (_isClaimAvailable(_recipient)) {\n            claim(_recipient);\n        }\n\n        _depositToTokemak(_amount);\n\n        // skip adding to warmup contract if period is 0\n        if (warmUpPeriod == 0) {\n            IYieldy(YIELDY_TOKEN).mint(_recipient, _amount);\n        } else {\n            // create a claim and mint tokens so a user can claim them once warm up has passed\n            warmUpInfo[_recipient] = Claim({\n                amount: info.amount + _amount,\n                credits: info.credits +\n                    IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),\n                expiry: epoch.number + warmUpPeriod\n            });\n\n            IYieldy(YIELDY_TOKEN).mint(address(this), _amount);\n        }\n\n        sendWithdrawalRequests();\n    }\n\n    /**\n        @notice call stake with msg.sender\n        @param _amount uint\n     */\n    function stake(uint256 _amount) external {\n        stake(_amount, msg.sender);\n    }\n\n    /**\n        @notice retrieve reward tokens from warmup\n        @dev if user has funds in warmup then user is able to claim them (including rewards)\n        @param _recipient address\n     */\n    function claim(address _recipient) public {\n        Claim memory info = warmUpInfo[_recipient];\n        if (_isClaimAvailable(_recipient)) {\n            delete warmUpInfo[_recipient];\n\n            if (info.credits > 0) {\n                IYieldy(YIELDY_TOKEN).transfer(\n                    _recipient,\n                    IYieldy(YIELDY_TOKEN).tokenBalanceForCredits(info.credits)\n                );\n            }\n        }\n    }\n\n    /**\n        @notice claims staking tokens after cooldown period\n        @dev if user has a cooldown claim that's past expiry then withdraw staking tokens from tokemak\n        @dev and send them to user\n        @param _recipient address - users unstaking address\n     */\n    function claimWithdraw(address _recipient) public {\n        Claim memory info = coolDownInfo[_recipient];\n        uint256 totalAmountIncludingRewards = IYieldy(YIELDY_TOKEN)\n            .tokenBalanceForCredits(info.credits);\n        if (_isClaimWithdrawAvailable(_recipient)) {\n            // if has withdrawalAmount to be claimed, then claim\n            _withdrawFromTokemak();\n            delete coolDownInfo[_recipient];\n\n            withdrawalAmount -= info.amount;\n\n            // only give amount from when they requested withdrawal since this amount wasn't used in generating rewards\n            // this will later be given to users through addRewardsForStakers\n            IERC20Upgradeable(STAKING_TOKEN).safeTransfer(\n                _recipient,\n                info.amount\n            );\n\n            IYieldy(YIELDY_TOKEN).burn(\n                address(this),\n                totalAmountIncludingRewards\n            );\n        }\n    }\n\n    /**\n        @notice gets reward tokens either from the warmup pool or user's wallet or both\n        @dev when transferring reward tokens the user could have their balance still in the warmup pool\n        @dev this function abstracts the logic to find the correct amount of tokens to use them\n        @param _amount uint\n        @param _user address to pull funds from \n     */\n    function _retrieveBalanceFromUser(uint256 _amount, address _user) internal {\n        Claim memory userWarmInfo = warmUpInfo[_user];\n        uint256 walletBalance = IERC20Upgradeable(YIELDY_TOKEN).balanceOf(\n            _user\n        );\n        uint256 warmUpBalance = IYieldy(YIELDY_TOKEN).tokenBalanceForCredits(\n            userWarmInfo.credits\n        );\n\n        // must have enough funds between wallet and warmup\n        require(\n            _amount <= walletBalance + warmUpBalance,\n            \"Insufficient Balance\"\n        );\n\n        uint256 amountLeft = _amount;\n        if (warmUpBalance > 0) {\n            // remove from warmup first.\n            if (_amount >= warmUpBalance) {\n                // use the entire warmup balance\n                unchecked {\n                    amountLeft -= warmUpBalance;\n                }\n                delete warmUpInfo[_user];\n            } else {\n                // partially consume warmup balance\n                amountLeft = 0;\n                uint256 remainingCreditsAmount = userWarmInfo.credits -\n                    IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount);\n                uint256 remainingAmount = IYieldy(YIELDY_TOKEN)\n                    .tokenBalanceForCredits(remainingCreditsAmount);\n\n                warmUpInfo[_user] = Claim({\n                    amount: remainingAmount,\n                    credits: remainingCreditsAmount,\n                    expiry: userWarmInfo.expiry\n                });\n            }\n        }\n\n        if (amountLeft != 0) {\n            // transfer the rest from the users address\n            IERC20Upgradeable(YIELDY_TOKEN).safeTransferFrom(\n                _user,\n                address(this),\n                amountLeft\n            );\n        }\n    }\n\n    /**\n        @notice instant unstakes from liquidity reserve\n        @param _amount uint - amount to instant unstake\n     */\n    function instantUnstakeReserve(uint256 _amount) external {\n        require(_amount > 0, \"Invalid amount\");\n        // prevent unstaking if override due to vulnerabilities\n        require(\n            !isUnstakingPaused && !isInstantUnstakingPaused,\n            \"Unstaking is paused\"\n        );\n\n        rebase();\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        uint256 reserveBalance = IERC20Upgradeable(STAKING_TOKEN).balanceOf(\n            LIQUIDITY_RESERVE\n        );\n\n        require(reserveBalance >= _amount, \"Not enough funds in reserve\");\n\n        ILiquidityReserve(LIQUIDITY_RESERVE).instantUnstake(\n            _amount,\n            msg.sender\n        );\n    }\n\n    /**\n        @notice instant unstake from curve\n        @param _amount uint - amount to instant unstake\n        @param _minAmount uint - minimum amount with slippage to instant unstake\n        @return uint - amount received\n     */\n    function instantUnstakeCurve(uint256 _amount, uint256 _minAmount)\n        external\n        returns (uint256)\n    {\n        require(_amount > 0, \"Invalid amount\");\n        require(\n            CURVE_POOL != address(0) &&\n                (curvePoolFrom == 1 || curvePoolTo == 1),\n            \"Invalid Curve Pool\"\n        );\n        // prevent unstaking if override due to vulnerabilities\n        require(\n            !isUnstakingPaused && !isInstantUnstakingPaused,\n            \"Unstaking is paused\"\n        );\n\n        rebase();\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        return\n            ICurvePool(CURVE_POOL).exchange(\n                curvePoolFrom,\n                curvePoolTo,\n                _amount,\n                _minAmount,\n                msg.sender\n            );\n    }\n\n    /**\n        @notice sets to and from coin indexes for curve exchange\n     */\n    function setToAndFromCurve() internal {\n        if (CURVE_POOL != address(0)) {\n            address address0 = ICurvePool(CURVE_POOL).coins(0);\n            address address1 = ICurvePool(CURVE_POOL).coins(1);\n            int128 from = 0;\n            int128 to = 0;\n\n            if (TOKE_POOL == address0 && STAKING_TOKEN == address1) {\n                to = 1;\n            } else if (TOKE_POOL == address1 && STAKING_TOKEN == address0) {\n                from = 1;\n            }\n            require(from == 1 || to == 1, \"Invalid Curve Pool\");\n\n            curvePoolFrom = from;\n            curvePoolTo = to;\n\n            emit LogSetCurvePool(CURVE_POOL, curvePoolTo, curvePoolFrom);\n        }\n    }\n\n    /**\n        @notice estimate received using instant unstake from curve\n        @param _amount uint - amount to instant unstake\n        @return uint - estimated amount received\n     */\n    function estimateInstantCurve(uint256 _amount)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            ICurvePool(CURVE_POOL).get_dy(curvePoolFrom, curvePoolTo, _amount);\n    }\n\n    /**\n        @notice redeem Yieldy tokens for staking tokens with a vesting period based on coolDownPeriod\n        @dev this function will retrieve the _amount of Yieldy tokens from the user and transfer them to the cooldown contract.\n        @dev once the period has expired the user will be able to withdraw their staking tokens\n        @param _amount uint - amount of tokens to unstake\n        @param _trigger bool - should trigger a rebase\n     */\n    function unstake(uint256 _amount, bool _trigger) external {\n        // prevent unstaking if override due to vulnerabilities asdf\n        require(!isUnstakingPaused, \"Unstaking is paused\");\n        if (_trigger) {\n            rebase();\n        }\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        Claim storage userCoolInfo = coolDownInfo[msg.sender];\n\n        // try to claim withdraw if user has withdraws to claim function will check if withdraw is valid\n        claimWithdraw(msg.sender);\n\n        coolDownInfo[msg.sender] = Claim({\n            amount: userCoolInfo.amount + _amount,\n            credits: userCoolInfo.credits +\n                IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),\n            expiry: epoch.number + coolDownPeriod\n        });\n\n        requestWithdrawalAmount += _amount;\n        sendWithdrawalRequests();\n    }\n\n    /**\n        @notice trigger rebase if epoch has ended\n     */\n    function rebase() public {\n        // we know about the issues surrounding block.timestamp, using it here will not cause any problems\n        if (epoch.endTime <= block.timestamp) {\n            IYieldy(YIELDY_TOKEN).rebase(epoch.distribute, epoch.number);\n\n            epoch.endTime = epoch.endTime + epoch.duration;\n            epoch.timestamp = block.timestamp;\n            epoch.number++;\n\n            uint256 balance = contractBalance();\n            uint256 staked = IYieldy(YIELDY_TOKEN).totalSupply();\n\n            if (balance <= staked) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance - staked;\n            }\n        }\n    }\n\n    /**\n        @notice returns contract staking tokens holdings \n        @dev gets amount of staking tokens that are a part of this system to calculate rewards\n        @dev the staking tokens will be included in this contract plus inside tokemak\n        @return uint - amount of staking tokens\n     */\n    function contractBalance() internal view returns (uint256) {\n        uint256 tokeBalance = _getTokemakBalance();\n        return\n            IERC20Upgradeable(STAKING_TOKEN).balanceOf(address(this)) +\n            tokeBalance;\n    }\n\n    /**\n     * @notice adds staking tokens for rebase rewards\n     * @dev this is the function that gives rewards so the rebase function can distribute profits to reward token holders\n     * @param _amount uint - amount of tokens to add to rewards\n     * @param _shouldTransfer bool - should transfer tokens before adding rewards\n     * @param _trigger bool - should trigger rebase\n     */\n    function addRewardsForStakers(\n        uint256 _amount,\n        bool _shouldTransfer,\n        bool _trigger\n    ) external {\n        if (_shouldTransfer) {\n            IERC20Upgradeable(STAKING_TOKEN).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _amount\n            );\n        }\n\n        // deposit all staking tokens held in contract to Tokemak minus tokens waiting for claimWithdraw\n        uint256 stakingTokenBalance = IERC20Upgradeable(STAKING_TOKEN)\n            .balanceOf(address(this));\n        uint256 amountToDeposit = stakingTokenBalance - withdrawalAmount;\n        _depositToTokemak(amountToDeposit);\n\n        if (_trigger) {\n            rebase();\n        }\n    }\n\n    /**\n     * @notice trades rewards generated from claimFromTokemak for staking token\n     * @dev this is function is called from claimFromTokemak if the autoRebase bool is set to true\n     */\n    function preSign(bytes calldata orderUid) external onlyOwner {\n        ICowSettlement(COW_SETTLEMENT).setPreSignature(orderUid, true);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/ILiquidityReserve.sol\";\nimport \"./LiquidityReserveStorage.sol\";\n\ncontract LiquidityReserve is\n    LiquidityReserveStorage,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    ILiquidityReserve\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event FeeChanged(uint256 fee);\n\n    // check if sender is the stakingContract\n    modifier onlyStakingContract() {\n        require(msg.sender == stakingContract, \"Not staking contract\");\n        _;\n    }\n\n    /**\n        @notice initialize by setting stakingContract & setting initial liquidity\n        @param _tokenName name of the lrToken to be created\n        @param _tokenSymbol symbol of the lrToken to be created.\n        @param _stakingToken the staking token in use\n        @param _rewardToken the reward token in use\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _stakingToken,\n        address _rewardToken\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        OwnableUpgradeable.__Ownable_init();\n        require(\n            _stakingToken != address(0) && _rewardToken != address(0),\n            \"Invalid address\"\n        );\n        stakingToken = _stakingToken;\n        rewardToken = _rewardToken;\n    }\n\n    /**\n        @notice callable once after initialized by the owner to set the staking contract and enable\n        our reserve to be used.\n        @param _stakingContract address of the staking contract\n     */\n    function enableLiquidityReserve(address _stakingContract)\n        external\n        onlyOwner\n    {\n        require(!isReserveEnabled, \"Already enabled\");\n        require(_stakingContract != address(0), \"Invalid address\");\n\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            msg.sender\n        );\n        // require address has minimum liquidity\n        require(\n            stakingTokenBalance >= MINIMUM_LIQUIDITY,\n            \"Not enough staking tokens\"\n        );\n        stakingContract = _stakingContract;\n\n        // permanently lock the first MINIMUM_LIQUIDITY of lrTokens\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            MINIMUM_LIQUIDITY\n        );\n        _mint(address(this), MINIMUM_LIQUIDITY);\n        IERC20Upgradeable(rewardToken).approve(\n            stakingContract,\n            type(uint256).max\n        );\n        isReserveEnabled = true;\n    }\n\n    /**\n        @notice sets Fee (in basis points eg. 100 bps = 1%) for instant unstaking\n        @param _fee uint - fee in basis points\n     */\n    function setFee(uint256 _fee) external onlyOwner {\n        // check range before setting fee\n        require(_fee <= BASIS_POINTS, \"Out of range\");\n        fee = _fee;\n\n        emit FeeChanged(_fee);\n    }\n\n    /**\n        @notice addLiquidity for the stakingToken and receive lrToken in exchange\n        @param _amount uint - amount of staking tokens to add\n     */\n    function addLiquidity(uint256 _amount) external {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 lrFoxSupply = totalSupply();\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n\n        uint256 amountToMint = (_amount * lrFoxSupply) / totalLockedValue;\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice calculate current lrToken withdraw value\n        @param _amount uint - amount of tokens that will be withdrawn\n        @return uint - converted amount of staking tokens to withdraw from lr tokens\n     */\n    function _calculateReserveTokenValue(uint256 _amount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 lrFoxSupply = totalSupply();\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n        uint256 convertedAmount = (_amount * totalLockedValue) / lrFoxSupply;\n\n        return convertedAmount;\n    }\n\n    /**\n        @notice removeLiquidity by swapping your lrToken for stakingTokens\n        @param _amount uint - amount of tokens to remove from liquidity reserve\n     */\n    function removeLiquidity(uint256 _amount) external {\n        // check balance before removing liquidity\n        require(_amount <= balanceOf(msg.sender), \"Not enough lr tokens\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountToWithdraw = _calculateReserveTokenValue(_amount);\n\n        // verify that we have enough stakingTokens\n        require(\n            IERC20Upgradeable(stakingToken).balanceOf(address(this)) >=\n                amountToWithdraw,\n            \"Not enough funds\"\n        );\n\n        _burn(msg.sender, _amount);\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            msg.sender,\n            amountToWithdraw\n        );\n    }\n\n    /**\n        @notice allow instant unstake their stakingToken for a fee paid to the liquidity providers\n        @param _amount uint - amount of tokens to instantly unstake\n        @param _recipient address - address to send staking tokens to\n     */\n    function instantUnstake(uint256 _amount, address _recipient)\n        external\n        onlyStakingContract\n    {\n        require(isReserveEnabled, \"Not enabled yet\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountMinusFee = _amount - ((_amount * fee) / BASIS_POINTS);\n\n        IERC20Upgradeable(rewardToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            _recipient,\n            amountMinusFee\n        );\n        unstakeAllRewardTokens();\n    }\n\n    /**\n        @notice find balance of reward tokens in contract and unstake them from staking contract\n     */\n    function unstakeAllRewardTokens() public {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        if (coolDownAmount == 0) {\n            uint256 amount = IERC20Upgradeable(rewardToken).balanceOf(\n                address(this)\n            );\n            if (amount > 0) IStaking(stakingContract).unstake(amount, false);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Staking.sol",
            "LiquidityReserve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LiquidityReserve.sol and Staking.sol",
                "Type": "Removal of liquidity from the reserve can be griefed",
                "Description": "Users may be unable to withdraw/remove their liquidity from the LiquidityReserve if a user decides to grief the contract.",
                "Repair": "Keep track of submitted amounts during the cooldown, and batch-submit them during the next open window, rather than making it first-come-first-served"
            },
            {
                "Location": "Staking.sol line 419-445 and LiquidityReserve.sol line 120-126",
                "Type": "Token transfers in LiquidityReserve and Staking contract don't support deflationary ERC20 tokens, and user funds can be lost if stacking token was deflationary",
                "Description": "If the token is deflationary, the contract will receive less token than requested amount, but the contract does not check for the real transferred amount. This can cause other users who staked to lose funds. The protocol logics are not suitable for deflationary tokens and funds would be lost.",
                "Repair": "Do not support deflationary tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldyStorage.sol\";\nimport \"../libraries/ERC20PermitUpgradeable.sol\";\n\ncontract Yieldy is\n    YieldyStorage,\n    ERC20PermitUpgradeable,\n    AccessControlUpgradeable\n{\n    event LogSupply(\n        uint256 indexed epoch,\n        uint256 timestamp,\n        uint256 totalSupply\n    );\n\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n\n    /**\n        @notice initialize function\n        @param _tokenName erc20 token name\n        @param _tokenSymbol erc20 token symbol\n        @param _decimal decimal amount\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _decimal\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        ERC20PermitUpgradeable.__ERC20Permit_init(_tokenName);\n        AccessControlUpgradeable.__AccessControl_init();\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(MINTER_BURNER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(REBASE_ROLE, ADMIN_ROLE);\n\n        decimal = _decimal;\n        WAD = 10**decimal;\n        rebasingCreditsPerToken = WAD;\n        _setIndex(WAD);\n    }\n\n    /**\n        @notice called by the admin role address to set the staking contract. Can only be called\n        once. \n        @param _stakingContract address of the staking contract\n     */\n    function initializeStakingContract(address _stakingContract)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        require(stakingContract == address(0), \"Already Initialized\");\n        require(_stakingContract != address(0), \"Invalid address\");\n        stakingContract = _stakingContract;\n        _setupRole(MINTER_BURNER_ROLE, _stakingContract);\n        _setupRole(REBASE_ROLE, _stakingContract);\n    }\n\n    /**\n        @notice sets index to get the value of rebases from the beginning of the contract\n        @param _index uint - initial index\n     */\n    function _setIndex(uint256 _index) internal {\n        index = creditsForTokenBalance(_index);\n    }\n\n    /**\n        @notice increases Yieldy supply to increase staking balances relative to profit_\n        @param _profit uint256 - amount of rewards to distribute\n        @param _epoch uint256 - epoch number\n     */\n    function rebase(uint256 _profit, uint256 _epoch)\n        external\n        onlyRole(REBASE_ROLE)\n    {\n        uint256 currentTotalSupply = _totalSupply;\n        require(_totalSupply > 0, \"Can't rebase if not circulating\");\n\n        if (_profit == 0) {\n            emit LogSupply(_epoch, block.timestamp, currentTotalSupply);\n            emit LogRebase(_epoch, 0, getIndex());\n        } else {\n            uint256 updatedTotalSupply = currentTotalSupply + _profit;\n\n            if (updatedTotalSupply > MAX_SUPPLY) {\n                updatedTotalSupply = MAX_SUPPLY;\n            }\n\n            rebasingCreditsPerToken = rebasingCredits / updatedTotalSupply;\n            require(rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n            _totalSupply = updatedTotalSupply;\n\n            _storeRebase(updatedTotalSupply, _profit, _epoch);\n        }\n    }\n\n    /**\n        @notice emits event with data about rebase\n        @param _previousCirculating uint\n        @param _profit uint\n        @param _epoch uint\n     */\n    function _storeRebase(\n        uint256 _previousCirculating,\n        uint256 _profit,\n        uint256 _epoch\n    ) internal {\n        uint256 rebasePercent = (_profit * WAD) / _previousCirculating;\n\n        rebases.push(\n            Rebase({\n                epoch: _epoch,\n                rebase: rebasePercent,\n                totalStakedBefore: _previousCirculating,\n                totalStakedAfter: _totalSupply,\n                amountRebased: _profit,\n                index: getIndex(),\n                blockNumberOccurred: block.number\n            })\n        );\n\n        emit LogSupply(_epoch, block.timestamp, _totalSupply);\n        emit LogRebase(_epoch, rebasePercent, getIndex());\n    }\n\n    /**\n        @notice gets balanceOf Yieldy\n        @param _wallet address\n        @return uint\n     */\n    function balanceOf(address _wallet) public view override returns (uint256) {\n        return creditBalances[_wallet] / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate credits based on balance amount\n        @param _amount uint\n        @return uint\n     */\n    function creditsForTokenBalance(uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        return _amount * rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate balance based on _credits amount\n        @param _credits uint\n        @return uint\n     */\n    function tokenBalanceForCredits(uint256 _credits)\n        public\n        view\n        returns (uint256)\n    {\n        return _credits / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice get current index to show what how much Yieldy the user would have gained if staked from the beginning\n        @return uint - current index\n     */\n    function getIndex() public view returns (uint256) {\n        return tokenBalanceForCredits(index);\n    }\n\n    /**\n        @notice transfers to _to address with an amount of _value\n        @param _to address\n        @param _value uint\n        @return bool - transfer succeeded\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        require(_to != address(0), \"Invalid address\");\n\n        uint256 creditAmount = _value * rebasingCreditsPerToken;\n        require(creditAmount <= creditBalances[msg.sender], \"Not enough funds\");\n\n        creditBalances[msg.sender] = creditBalances[msg.sender] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n        @notice transfer from address to address with amount\n        @param _from address\n        @param _to address\n        @param _value uint\n        @return bool\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        require(_allowances[_from][msg.sender] >= _value, \"Allowance too low\");\n\n        uint256 newValue = _allowances[_from][msg.sender] - _value;\n        _allowances[_from][msg.sender] = newValue;\n        emit Approval(_from, msg.sender, newValue);\n\n        uint256 creditAmount = creditsForTokenBalance(_value);\n        creditBalances[_from] = creditBalances[_from] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n        @notice should be same as yield decimal\n     */\n    function decimals() public view override returns (uint8) {\n        return decimal;\n    }\n\n    /**\n        @notice called from the staking contract co create Yieldy tokens\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function mint(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _mint(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 mint functionality\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function _mint(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Mint to the zero address\");\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        creditBalances[_address] = creditBalances[_address] + creditAmount;\n        rebasingCredits = rebasingCredits + creditAmount;\n\n        _totalSupply = _totalSupply + _amount;\n\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _address, _amount);\n    }\n\n    /**\n        @notice called from the staking contract co burn Yieldy tokens\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function burn(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _burn(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 burn functionality\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function _burn(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        uint256 currentCredits = creditBalances[_address];\n        require(currentCredits >= creditAmount, \"Not enough balance\");\n\n        creditBalances[_address] = creditBalances[_address] - creditAmount;\n        rebasingCredits = rebasingCredits - creditAmount;\n        _totalSupply = _totalSupply - _amount;\n\n        emit Transfer(_address, address(0), _amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "Yieldy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Yieldy.sol line 91",
                "Type": "Incorrect rebase percentage calculation",
                "Description": "If updatedTotalSupply is greater than MAX_SUPPLY, the _profit amount is not fully used, but _storeRebase function is still called with _profit amount, leading to incorrect rebasePercent calculation.",
                "Repair": "Check if updatedTotalSupply is greater than MAX_SUPPLY before calling _storeRebase function"
            },
            {
                "Location": "transferFrom function in Yieldy.sol",
                "Type": "Burn access control can be bypassed",
                "Description": "The transferFrom method does not check if the _to argument is the zero address, which can lead to token burns without calling the burn function, bypassing the access control onlyRole(MINTER_BURNER_ROLE).",
                "Repair": "Add a non-zero address check for _to argument in transferFrom function"
            },
            {
                "Location": "Yieldy.sol line 54",
                "Type": "Inconsistent balance when fee-on transfer tokens",
                "Description": "When IERC20Upgradeable(TOKE_TOKEN) is set to totalTokeAmount, it will be different once safetransfer has fees as some types of tokens may charge a certain fee for transfer and transferfrom. It may be better to get the before balance, then safeTransferFrom, and then get the after balance to make sure no fees were added.",
                "Repair": "Get the before balance, then safeTransferFrom, and then get the after balance to make sure no fees were added"
            },
            {
                "Location": "Yieldy.sol",
                "Type": "MINTER_BURNER_ROLE can burn any amount of Yieldy from an arbitrary address",
                "Description": "Using the burn() function of Yieldy, an address with MINTER_BURNER_ROLE can burn an arbitrary amount of tokens from any address, posing a serious centralization risk. Consider removing the MINTER_BURNER_ROLE and changing the burn() function to only allow the caller to burn their own tokens.",
                "Repair": "Change burn() function to only allow the caller to burn their own tokens"
            },
            {
                "Location": "Yieldy.sol#L212",
                "Type": "Unsecure transferFrom",
                "Description": "The security of the Yieldy contract is delegated to the compiler used. The allowance of an account does not have to reflect the real balance of an account, however in the transferFrom method, it is the value that is checked in order to verify that the user has enough balance to make the transfer.",
                "Repair": "Check that the from account has a creditAmount balance."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/IStakingV1.sol\";\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/IYieldy.sol\";\n\ncontract Migration {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public immutable OLD_CONTRACT;\n    address public immutable NEW_CONTRACT;\n    address public immutable OLD_YIELDY_TOKEN;\n\n    constructor(address _oldContract, address _newContract) {\n        // addresses can't be 0x0\n        require(\n            _oldContract != address(0) && _newContract != address(0),\n            \"Invalid address\"\n        );\n\n        OLD_CONTRACT = _oldContract;\n        NEW_CONTRACT = _newContract;\n\n        OLD_YIELDY_TOKEN = IStakingV1(_oldContract).REWARD_TOKEN();\n        address stakingToken = IStaking(_newContract).STAKING_TOKEN();\n\n        IYieldy(OLD_YIELDY_TOKEN).approve(_oldContract, type(uint256).max);\n        IERC20Upgradeable(stakingToken).approve(\n            _newContract,\n            type(uint256).max\n        );\n    }\n\n    /**\n        @notice unstake user's FOXy from the old Staking contract and immediately\n        restake into the upgraded one\n        Note: user needs to approve reward token spend before calling this\n     */\n    function moveFundsToUpgradedContract() external {\n        uint256 userWalletBalance = IYieldy(OLD_YIELDY_TOKEN).balanceOf(\n            msg.sender\n        );\n\n        IYieldy(OLD_YIELDY_TOKEN).transferFrom(\n            msg.sender,\n            address(this),\n            userWalletBalance\n        );\n\n        IStaking(OLD_CONTRACT).instantUnstake(false);\n\n        IStaking(NEW_CONTRACT).stake(userWalletBalance, msg.sender);\n    }\n}\n\n\n",
        "CodeNames": [
            "Migration.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "moveFundsToUpgradedContract function in Migration.sol",
                "Type": "Users of Migration.sol may forfeit rebase rewards",
                "Description": "Users of moveFundsToUpgradedContract function in Migration.sol may forfeit rebase rewards because it calls instantUnstake(false), skipping the optional rebase. Adding an input bool _trigger and calling rebase function if _trigger is true allows users to optionally call rebase if they are concerned about losing pending rebase rewards.",
                "Repair": "Add an input bool _trigger and call rebase function if _trigger is true"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./LiquidityReserve.sol\";\nimport \"./StakingStorage.sol\";\nimport \"../interfaces/IYieldy.sol\";\nimport \"../interfaces/ITokeManager.sol\";\nimport \"../interfaces/ITokePool.sol\";\nimport \"../interfaces/ITokeReward.sol\";\nimport \"../interfaces/ILiquidityReserve.sol\";\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ICowSettlement.sol\";\n\ncontract Staking is OwnableUpgradeable, StakingStorage {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event LogSetEpochDuration(uint256 indexed blockNumber, uint256 duration);\n    event LogSetWarmUpPeriod(uint256 indexed blockNumber, uint256 period);\n    event LogSetCoolDownPeriod(uint256 indexed blockNumber, uint256 period);\n    event LogSetPauseStaking(uint256 indexed blockNumber, bool shouldPause);\n    event LogSetPauseUnstaking(uint256 indexed blockNumber, bool shouldPause);\n    event LogSetPauseInstantUnstaking(\n        uint256 indexed blockNumber,\n        bool shouldPause\n    );\n    event LogSetAffiliateAddress(\n        uint256 indexed blockNumber,\n        address affilateAddress\n    );\n    event LogSetAffiliateFee(uint256 indexed blockNumber, uint256 fee);\n\n    event LogSetCurvePool(address indexed curvePool, int128 to, int128 from);\n\n    function initialize(\n        address _stakingToken,\n        address _yieldyToken,\n        address _tokeToken,\n        address _tokePool,\n        address _tokeManager,\n        address _tokeReward,\n        address _liquidityReserve,\n        address _feeAddress,\n        address _curvePool,\n        uint256 _epochDuration,\n        uint256 _firstEpochEndTime\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // must have valid initial addresses\n        require(\n            _stakingToken != address(0) &&\n                _yieldyToken != address(0) &&\n                _tokeToken != address(0) &&\n                _tokePool != address(0) &&\n                _tokeManager != address(0) &&\n                _tokeReward != address(0) &&\n                _liquidityReserve != address(0),\n            \"Invalid address\"\n        );\n        STAKING_TOKEN = _stakingToken;\n        YIELDY_TOKEN = _yieldyToken;\n        TOKE_TOKEN = _tokeToken;\n        TOKE_POOL = _tokePool;\n        TOKE_MANAGER = _tokeManager;\n        TOKE_REWARD = _tokeReward;\n        LIQUIDITY_RESERVE = _liquidityReserve;\n        FEE_ADDRESS = _feeAddress;\n        CURVE_POOL = _curvePool;\n        COW_SETTLEMENT = 0x9008D19f58AAbD9eD0D60971565AA8510560ab41;\n        COW_RELAYER = 0xC92E8bdf79f0507f65a392b0ab4667716BFE0110;\n\n        timeLeftToRequestWithdrawal = 12 hours;\n\n        if (CURVE_POOL != address(0)) {\n            IERC20(TOKE_POOL).approve(CURVE_POOL, type(uint256).max);\n            setToAndFromCurve();\n        }\n\n        IERC20(STAKING_TOKEN).approve(TOKE_POOL, type(uint256).max);\n        IERC20Upgradeable(YIELDY_TOKEN).approve(\n            LIQUIDITY_RESERVE,\n            type(uint256).max\n        );\n        IERC20Upgradeable(YIELDY_TOKEN).approve(\n            LIQUIDITY_RESERVE,\n            type(uint256).max\n        );\n        IERC20Upgradeable(TOKE_TOKEN).approve(COW_RELAYER, type(uint256).max);\n\n        epoch = Epoch({\n            duration: _epochDuration,\n            number: 1,\n            timestamp: block.timestamp, // we know about the issues surrounding block.timestamp, using it here will not cause any problems\n            endTime: _firstEpochEndTime,\n            distribute: 0\n        });\n    }\n\n    /**\n        @notice claim TOKE rewards from Tokemak\n        @dev must get amount through toke reward contract using latest cycle from reward hash contract\n        @param _recipient Recipient struct that contains chainId, cycle, address, and amount \n        @param _v uint - recovery id\n        @param _r bytes - output of ECDSA signature\n        @param _s bytes - output of ECDSA signature\n     */\n    function claimFromTokemak(\n        Recipient calldata _recipient,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // cannot claim 0\n        require(_recipient.amount > 0, \"Must enter valid amount\");\n\n        ITokeReward tokeRewardContract = ITokeReward(TOKE_REWARD);\n        tokeRewardContract.claim(_recipient, _v, _r, _s);\n        _sendAffiliateFee(_recipient.amount);\n    }\n\n    /**\n        @notice send affiliate fee\n        @param _amount uint - total amount to deduct fee from\n     */\n    function _sendAffiliateFee(uint256 _amount) internal {\n        if (affiliateFee != 0 && FEE_ADDRESS != address(0)) {\n            uint256 feeAmount = (_amount * affiliateFee) / BASIS_POINTS;\n            IERC20Upgradeable(TOKE_TOKEN).safeTransfer(FEE_ADDRESS, feeAmount);\n        }\n    }\n\n    /**\n        @notice transfer TOKE from staking contract to address\n        @dev used so DAO can get TOKE and manually trade to return FOX to the staking contract\n        @param _claimAddress address to send TOKE rewards\n     */\n    function transferToke(address _claimAddress) external onlyOwner {\n        // _claimAddress can't be 0x0\n        require(_claimAddress != address(0), \"Invalid address\");\n        uint256 totalTokeAmount = IERC20Upgradeable(TOKE_TOKEN).balanceOf(\n            address(this)\n        );\n        IERC20Upgradeable(TOKE_TOKEN).safeTransfer(\n            _claimAddress,\n            totalTokeAmount\n        );\n    }\n\n    /**\n        @notice sets the curve pool address\n        @param _curvePool uint\n     */\n    function setCurvePool(address _curvePool) external onlyOwner {\n        CURVE_POOL = _curvePool;\n        setToAndFromCurve();\n    }\n\n    /**\n        @notice sets the affiliate fee\n        @dev fee is set in basis points\n        @param _affiliateFee uint\n     */\n    function setAffiliateFee(uint256 _affiliateFee) external onlyOwner {\n        affiliateFee = _affiliateFee;\n        emit LogSetAffiliateFee(block.number, _affiliateFee);\n    }\n\n    /**\n        @notice sets the affiliate address to receive the affiliate fee in TOKE\n        @dev if set to 0x000.. then no affiliate will be sent\n        @param _affiliateAddress address\n     */\n    function setAffiliateAddress(address _affiliateAddress) external onlyOwner {\n        FEE_ADDRESS = _affiliateAddress;\n        emit LogSetAffiliateAddress(block.number, _affiliateAddress);\n    }\n\n    /**\n        @notice override whether or not staking is paused\n        @dev used to pause staking in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseStaking(bool _shouldPause) public onlyOwner {\n        isStakingPaused = _shouldPause;\n        emit LogSetPauseStaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice override whether or not unstake & instantUnstake is paused\n        @dev used to pause unstake & instantUnstake in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseUnstaking(bool _shouldPause) external onlyOwner {\n        isUnstakingPaused = _shouldPause;\n        emit LogSetPauseUnstaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice override whether or not instantUnstake is paused\n        @dev used to pause instantUnstake in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseInstantUnstaking(bool _shouldPause) external onlyOwner {\n        isInstantUnstakingPaused = _shouldPause;\n        emit LogSetPauseInstantUnstaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice set epoch duration\n        @dev epoch's determine how long until a rebase can occur\n        @param duration uint\n     */\n    function setEpochDuration(uint256 duration) external onlyOwner {\n        epoch.duration = duration;\n        emit LogSetEpochDuration(block.number, duration);\n    }\n\n    /**\n     * @notice set warmup period for new stakers\n     * @param _vestingPeriod uint\n     */\n    function setWarmUpPeriod(uint256 _vestingPeriod) external onlyOwner {\n        warmUpPeriod = _vestingPeriod;\n        emit LogSetWarmUpPeriod(block.number, _vestingPeriod);\n    }\n\n    /**\n     * @notice set cooldown period for stakers\n     * @param _vestingPeriod uint\n     */\n    function setCoolDownPeriod(uint256 _vestingPeriod) external onlyOwner {\n        coolDownPeriod = _vestingPeriod;\n        emit LogSetCoolDownPeriod(block.number, _vestingPeriod);\n    }\n\n    /**\n        @notice sets the time before Tokemak cycle ends to requestWithdrawals\n        @dev requestWithdrawals is called once per cycle.\n        @dev this allows us to change how much time before the end of the cycle we send the withdraw requests\n        @param _timestamp uint - time before end of cycle\n     */\n    function setTimeLeftToRequestWithdrawal(uint256 _timestamp)\n        external\n        onlyOwner\n    {\n        timeLeftToRequestWithdrawal = _timestamp;\n    }\n\n    /**\n        @notice returns true if claim is available\n        @dev this shows whether or not our epoch's have passed\n        @param _recipient address - warmup address to check if claim is available\n        @return bool - true if available to claim\n     */\n    function _isClaimAvailable(address _recipient)\n        internal\n        view\n        returns (bool)\n    {\n        Claim memory info = warmUpInfo[_recipient];\n        return epoch.number >= info.expiry && info.expiry != 0;\n    }\n\n    /**\n        @notice returns true if claimWithdraw is available\n        @dev this shows whether or not our epoch's have passed as well as if the cycle has increased\n        @param _recipient address - address that's checking for available claimWithdraw\n        @return bool - true if available to claimWithdraw\n     */\n    function _isClaimWithdrawAvailable(address _recipient)\n        internal\n        returns (bool)\n    {\n        Claim memory info = coolDownInfo[_recipient];\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        RequestedWithdrawalInfo memory requestedWithdrawals = tokePoolContract\n            .requestedWithdrawals(address(this));\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n        return\n            epoch.number >= info.expiry &&\n            info.expiry != 0 &&\n            info.amount != 0 &&\n            ((requestedWithdrawals.minCycle <= currentCycleIndex &&\n                requestedWithdrawals.amount + withdrawalAmount >=\n                info.amount) || withdrawalAmount >= info.amount);\n    }\n\n    /**\n        @notice withdraw stakingTokens from Tokemak\n        @dev needs a valid requestWithdrawal inside Tokemak with a completed cycle rollover to withdraw\n     */\n    function _withdrawFromTokemak() internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        RequestedWithdrawalInfo memory requestedWithdrawals = tokePoolContract\n            .requestedWithdrawals(address(this));\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n\n        if (\n            requestedWithdrawals.amount > 0 &&\n            requestedWithdrawals.minCycle <= currentCycleIndex\n        ) {\n            tokePoolContract.withdraw(requestedWithdrawals.amount);\n            requestWithdrawalAmount -= requestedWithdrawals.amount;\n            withdrawalAmount += requestedWithdrawals.amount;\n        }\n    }\n\n    /**\n        @notice creates a withdrawRequest with Tokemak\n        @dev requestedWithdraws take 1 tokemak cycle to be available for withdraw\n        @param _amount uint - amount to request withdraw\n     */\n    function _requestWithdrawalFromTokemak(uint256 _amount) internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        uint256 balance = ITokePool(TOKE_POOL).balanceOf(address(this));\n\n        // the only way balance < _amount is when using unstakeAllFromTokemak\n        uint256 amountToRequest = balance < _amount ? balance : _amount;\n\n        if (amountToRequest > 0) tokePoolContract.requestWithdrawal(_amount);\n    }\n\n    /**\n        @notice deposit stakingToken to tStakingToken Tokemak reactor\n        @param _amount uint - amount to deposit\n     */\n    function _depositToTokemak(uint256 _amount) internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        tokePoolContract.deposit(_amount);\n    }\n\n    /**\n        @notice gets balance of stakingToken that's locked into the TOKE stakingToken pool\n        @return uint - amount of stakingToken in TOKE pool\n     */\n    function _getTokemakBalance() internal view returns (uint256) {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        return tokePoolContract.balanceOf(address(this));\n    }\n\n    /**\n        @notice checks TOKE's cycleTime is within duration to batch the transactions\n        @dev this function returns true if we are within timeLeftToRequestWithdrawal of the end of the TOKE cycle\n        @dev as well as if the current cycle index is more than the last cycle index\n        @return bool - returns true if can batch transactions\n     */\n    function canBatchTransactions() public view returns (bool) {\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        uint256 duration = tokeManager.getCycleDuration();\n        uint256 currentCycleStart = tokeManager.getCurrentCycle();\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n        uint256 nextCycleStart = currentCycleStart + duration;\n\n        return\n            block.timestamp + timeLeftToRequestWithdrawal >= nextCycleStart &&\n            currentCycleIndex > lastTokeCycleIndex &&\n            requestWithdrawalAmount > 0;\n    }\n\n    /**\n        @notice owner function to requestWithdraw all FOX from tokemak in case of an attack on tokemak\n        @dev this bypasses the normal flow of sending a withdrawal request and allows the owner to requestWithdraw entire pool balance\n     */\n    function unstakeAllFromTokemak() public onlyOwner {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        uint256 tokePoolBalance = ITokePool(tokePoolContract).balanceOf(\n            address(this)\n        );\n        // pause any future staking\n        shouldPauseStaking(true);\n        requestWithdrawalAmount = tokePoolBalance;\n        _requestWithdrawalFromTokemak(tokePoolBalance);\n    }\n\n    /**\n        @notice sends batched requestedWithdrawals due to TOKE's requestWithdrawal overwriting the amount if you call it more than once per cycle\n     */\n    function sendWithdrawalRequests() public {\n        // check to see if near the end of a TOKE cycle\n        if (canBatchTransactions()) {\n            // if has withdrawal amount to be claimed then claim\n            _withdrawFromTokemak();\n\n            // if more requestWithdrawalAmount exists after _withdrawFromTokemak then request the new amount\n            ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n            if (requestWithdrawalAmount > 0) {\n                _requestWithdrawalFromTokemak(requestWithdrawalAmount);\n            }\n\n            uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n            lastTokeCycleIndex = currentCycleIndex;\n        }\n    }\n\n    /**\n        @notice stake staking tokens to receive Yieldy tokens\n        @param _amount uint\n        @param _recipient address\n     */\n    function stake(uint256 _amount, address _recipient) public {\n        // if override staking, then don't allow stake\n        require(!isStakingPaused, \"Staking is paused\");\n        // amount must be non zero\n        require(_amount > 0, \"Must have valid amount\");\n\n        uint256 yieldyTotalSupply = IYieldy(YIELDY_TOKEN).totalSupply();\n\n        // Don't rebase unless tokens are already staked or could get locked out of staking\n        if (yieldyTotalSupply > 0) {\n            rebase();\n        }\n\n        IERC20Upgradeable(STAKING_TOKEN).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        Claim storage info = warmUpInfo[_recipient];\n\n        // if claim is available then auto claim tokens\n        if (_isClaimAvailable(_recipient)) {\n            claim(_recipient);\n        }\n\n        _depositToTokemak(_amount);\n\n        // skip adding to warmup contract if period is 0\n        if (warmUpPeriod == 0) {\n            IYieldy(YIELDY_TOKEN).mint(_recipient, _amount);\n        } else {\n            // create a claim and mint tokens so a user can claim them once warm up has passed\n            warmUpInfo[_recipient] = Claim({\n                amount: info.amount + _amount,\n                credits: info.credits +\n                    IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),\n                expiry: epoch.number + warmUpPeriod\n            });\n\n            IYieldy(YIELDY_TOKEN).mint(address(this), _amount);\n        }\n\n        sendWithdrawalRequests();\n    }\n\n    /**\n        @notice call stake with msg.sender\n        @param _amount uint\n     */\n    function stake(uint256 _amount) external {\n        stake(_amount, msg.sender);\n    }\n\n    /**\n        @notice retrieve reward tokens from warmup\n        @dev if user has funds in warmup then user is able to claim them (including rewards)\n        @param _recipient address\n     */\n    function claim(address _recipient) public {\n        Claim memory info = warmUpInfo[_recipient];\n        if (_isClaimAvailable(_recipient)) {\n            delete warmUpInfo[_recipient];\n\n            if (info.credits > 0) {\n                IYieldy(YIELDY_TOKEN).transfer(\n                    _recipient,\n                    IYieldy(YIELDY_TOKEN).tokenBalanceForCredits(info.credits)\n                );\n            }\n        }\n    }\n\n    /**\n        @notice claims staking tokens after cooldown period\n        @dev if user has a cooldown claim that's past expiry then withdraw staking tokens from tokemak\n        @dev and send them to user\n        @param _recipient address - users unstaking address\n     */\n    function claimWithdraw(address _recipient) public {\n        Claim memory info = coolDownInfo[_recipient];\n        uint256 totalAmountIncludingRewards = IYieldy(YIELDY_TOKEN)\n            .tokenBalanceForCredits(info.credits);\n        if (_isClaimWithdrawAvailable(_recipient)) {\n            // if has withdrawalAmount to be claimed, then claim\n            _withdrawFromTokemak();\n            delete coolDownInfo[_recipient];\n\n            withdrawalAmount -= info.amount;\n\n            // only give amount from when they requested withdrawal since this amount wasn't used in generating rewards\n            // this will later be given to users through addRewardsForStakers\n            IERC20Upgradeable(STAKING_TOKEN).safeTransfer(\n                _recipient,\n                info.amount\n            );\n\n            IYieldy(YIELDY_TOKEN).burn(\n                address(this),\n                totalAmountIncludingRewards\n            );\n        }\n    }\n\n    /**\n        @notice gets reward tokens either from the warmup pool or user's wallet or both\n        @dev when transferring reward tokens the user could have their balance still in the warmup pool\n        @dev this function abstracts the logic to find the correct amount of tokens to use them\n        @param _amount uint\n        @param _user address to pull funds from \n     */\n    function _retrieveBalanceFromUser(uint256 _amount, address _user) internal {\n        Claim memory userWarmInfo = warmUpInfo[_user];\n        uint256 walletBalance = IERC20Upgradeable(YIELDY_TOKEN).balanceOf(\n            _user\n        );\n        uint256 warmUpBalance = IYieldy(YIELDY_TOKEN).tokenBalanceForCredits(\n            userWarmInfo.credits\n        );\n\n        // must have enough funds between wallet and warmup\n        require(\n            _amount <= walletBalance + warmUpBalance,\n            \"Insufficient Balance\"\n        );\n\n        uint256 amountLeft = _amount;\n        if (warmUpBalance > 0) {\n            // remove from warmup first.\n            if (_amount >= warmUpBalance) {\n                // use the entire warmup balance\n                unchecked {\n                    amountLeft -= warmUpBalance;\n                }\n                delete warmUpInfo[_user];\n            } else {\n                // partially consume warmup balance\n                amountLeft = 0;\n                uint256 remainingCreditsAmount = userWarmInfo.credits -\n                    IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount);\n                uint256 remainingAmount = IYieldy(YIELDY_TOKEN)\n                    .tokenBalanceForCredits(remainingCreditsAmount);\n\n                warmUpInfo[_user] = Claim({\n                    amount: remainingAmount,\n                    credits: remainingCreditsAmount,\n                    expiry: userWarmInfo.expiry\n                });\n            }\n        }\n\n        if (amountLeft != 0) {\n            // transfer the rest from the users address\n            IERC20Upgradeable(YIELDY_TOKEN).safeTransferFrom(\n                _user,\n                address(this),\n                amountLeft\n            );\n        }\n    }\n\n    /**\n        @notice instant unstakes from liquidity reserve\n        @param _amount uint - amount to instant unstake\n     */\n    function instantUnstakeReserve(uint256 _amount) external {\n        require(_amount > 0, \"Invalid amount\");\n        // prevent unstaking if override due to vulnerabilities\n        require(\n            !isUnstakingPaused && !isInstantUnstakingPaused,\n            \"Unstaking is paused\"\n        );\n\n        rebase();\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        uint256 reserveBalance = IERC20Upgradeable(STAKING_TOKEN).balanceOf(\n            LIQUIDITY_RESERVE\n        );\n\n        require(reserveBalance >= _amount, \"Not enough funds in reserve\");\n\n        ILiquidityReserve(LIQUIDITY_RESERVE).instantUnstake(\n            _amount,\n            msg.sender\n        );\n    }\n\n    /**\n        @notice instant unstake from curve\n        @param _amount uint - amount to instant unstake\n        @param _minAmount uint - minimum amount with slippage to instant unstake\n        @return uint - amount received\n     */\n    function instantUnstakeCurve(uint256 _amount, uint256 _minAmount)\n        external\n        returns (uint256)\n    {\n        require(_amount > 0, \"Invalid amount\");\n        require(\n            CURVE_POOL != address(0) &&\n                (curvePoolFrom == 1 || curvePoolTo == 1),\n            \"Invalid Curve Pool\"\n        );\n        // prevent unstaking if override due to vulnerabilities\n        require(\n            !isUnstakingPaused && !isInstantUnstakingPaused,\n            \"Unstaking is paused\"\n        );\n\n        rebase();\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        return\n            ICurvePool(CURVE_POOL).exchange(\n                curvePoolFrom,\n                curvePoolTo,\n                _amount,\n                _minAmount,\n                msg.sender\n            );\n    }\n\n    /**\n        @notice sets to and from coin indexes for curve exchange\n     */\n    function setToAndFromCurve() internal {\n        if (CURVE_POOL != address(0)) {\n            address address0 = ICurvePool(CURVE_POOL).coins(0);\n            address address1 = ICurvePool(CURVE_POOL).coins(1);\n            int128 from = 0;\n            int128 to = 0;\n\n            if (TOKE_POOL == address0 && STAKING_TOKEN == address1) {\n                to = 1;\n            } else if (TOKE_POOL == address1 && STAKING_TOKEN == address0) {\n                from = 1;\n            }\n            require(from == 1 || to == 1, \"Invalid Curve Pool\");\n\n            curvePoolFrom = from;\n            curvePoolTo = to;\n\n            emit LogSetCurvePool(CURVE_POOL, curvePoolTo, curvePoolFrom);\n        }\n    }\n\n    /**\n        @notice estimate received using instant unstake from curve\n        @param _amount uint - amount to instant unstake\n        @return uint - estimated amount received\n     */\n    function estimateInstantCurve(uint256 _amount)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            ICurvePool(CURVE_POOL).get_dy(curvePoolFrom, curvePoolTo, _amount);\n    }\n\n    /**\n        @notice redeem Yieldy tokens for staking tokens with a vesting period based on coolDownPeriod\n        @dev this function will retrieve the _amount of Yieldy tokens from the user and transfer them to the cooldown contract.\n        @dev once the period has expired the user will be able to withdraw their staking tokens\n        @param _amount uint - amount of tokens to unstake\n        @param _trigger bool - should trigger a rebase\n     */\n    function unstake(uint256 _amount, bool _trigger) external {\n        // prevent unstaking if override due to vulnerabilities asdf\n        require(!isUnstakingPaused, \"Unstaking is paused\");\n        if (_trigger) {\n            rebase();\n        }\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        Claim storage userCoolInfo = coolDownInfo[msg.sender];\n\n        // try to claim withdraw if user has withdraws to claim function will check if withdraw is valid\n        claimWithdraw(msg.sender);\n\n        coolDownInfo[msg.sender] = Claim({\n            amount: userCoolInfo.amount + _amount,\n            credits: userCoolInfo.credits +\n                IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),\n            expiry: epoch.number + coolDownPeriod\n        });\n\n        requestWithdrawalAmount += _amount;\n        sendWithdrawalRequests();\n    }\n\n    /**\n        @notice trigger rebase if epoch has ended\n     */\n    function rebase() public {\n        // we know about the issues surrounding block.timestamp, using it here will not cause any problems\n        if (epoch.endTime <= block.timestamp) {\n            IYieldy(YIELDY_TOKEN).rebase(epoch.distribute, epoch.number);\n\n            epoch.endTime = epoch.endTime + epoch.duration;\n            epoch.timestamp = block.timestamp;\n            epoch.number++;\n\n            uint256 balance = contractBalance();\n            uint256 staked = IYieldy(YIELDY_TOKEN).totalSupply();\n\n            if (balance <= staked) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance - staked;\n            }\n        }\n    }\n\n    /**\n        @notice returns contract staking tokens holdings \n        @dev gets amount of staking tokens that are a part of this system to calculate rewards\n        @dev the staking tokens will be included in this contract plus inside tokemak\n        @return uint - amount of staking tokens\n     */\n    function contractBalance() internal view returns (uint256) {\n        uint256 tokeBalance = _getTokemakBalance();\n        return\n            IERC20Upgradeable(STAKING_TOKEN).balanceOf(address(this)) +\n            tokeBalance;\n    }\n\n    /**\n     * @notice adds staking tokens for rebase rewards\n     * @dev this is the function that gives rewards so the rebase function can distribute profits to reward token holders\n     * @param _amount uint - amount of tokens to add to rewards\n     * @param _shouldTransfer bool - should transfer tokens before adding rewards\n     * @param _trigger bool - should trigger rebase\n     */\n    function addRewardsForStakers(\n        uint256 _amount,\n        bool _shouldTransfer,\n        bool _trigger\n    ) external {\n        if (_shouldTransfer) {\n            IERC20Upgradeable(STAKING_TOKEN).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _amount\n            );\n        }\n\n        // deposit all staking tokens held in contract to Tokemak minus tokens waiting for claimWithdraw\n        uint256 stakingTokenBalance = IERC20Upgradeable(STAKING_TOKEN)\n            .balanceOf(address(this));\n        uint256 amountToDeposit = stakingTokenBalance - withdrawalAmount;\n        _depositToTokemak(amountToDeposit);\n\n        if (_trigger) {\n            rebase();\n        }\n    }\n\n    /**\n     * @notice trades rewards generated from claimFromTokemak for staking token\n     * @dev this is function is called from claimFromTokemak if the autoRebase bool is set to true\n     */\n    function preSign(bytes calldata orderUid) external onlyOwner {\n        ICowSettlement(COW_SETTLEMENT).setPreSignature(orderUid, true);\n    }\n}\n\n\n",
        "CodeNames": [
            "Staking.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Staking.sol constructor",
                "Type": "coolDown & warmUp period do not work when a low _firstEpochEndTime is passed to initialize",
                "Description": "In the constructor of Staking.sol, it is not enforced that the _firstEpochEndTime is larger than the current block.timestamp. If a low value is accidentally passed (or even 0), rebase can be called multiple times in succession, causing the epoch.number to increase.",
                "Repair": "Require that _firstEpochEndTime is larger than block.timestamp or set the expiry of the first epoch to block.timestamp + _epochDuration."
            },
            {
                "Location": "Staking.sol#preSign",
                "Type": "Staking preSign could use some basic validations",
                "Description": "The function preSign accepts any orderUid. Because of how Cowswap works, accepting any orderUid can be used as a rug-vector.",
                "Repair": "Add basic validation for tokenOut, minOut and receiver."
            },
            {
                "Location": "Staking.sol#instantUnstakeCurve",
                "Type": "Rebases can be frontrun with very little token downtime even when warmUpPeriod > 0",
                "Description": "Rebases can be frontrun with very little token downtime even when warmUpPeriod > 0. A user can call stake the block before epoch.endTime <= block.timestamp, allowing the user to bypass the forced rebase called in L416 of the the stake function.",
                "Repair": "Tokens unstaked during the warm up period should not be allowed to accumulate any rebases."
            },
            {
                "Location": "Staking.sol#instantUnstake",
                "Type": "instantUnstake fee can be avoided",
                "Description": "Users can utilize the instantUnstake function without paying the liquidity provider fee using rounding errors in the fee calculation.",
                "Repair": "Calculate amount less fee using a muldiv operation over (1 - fee)."
            },
            {
                "Location": "Staking.setCurvePool",
                "Type": "Approval",
                "Description": "No way to set CURVE_POOL approval after setting new curve pool address.",
                "Repair": "Set approvals for the new curve pool address in the same setCurvePool() function."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../structs/Batch.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BatchRequests is Ownable {\n    address[] public contracts;\n\n    /**\n        @notice sendWithdrawalRequests on all addresses in contracts\n     */\n    function sendWithdrawalRequests() external {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (\n                contracts[i] != address(0) &&\n                IStaking(contracts[i]).canBatchTransactions()\n            ) {\n                IStaking(contracts[i]).sendWithdrawalRequests();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n        @notice shows which contracts can batch\n        @return (address, bool)[]\n     */\n    function canBatchContracts() external view returns (Batch[] memory) {\n        uint256 contractsLength = contracts.length;\n        Batch[] memory batch = new Batch[](contractsLength);\n        for (uint256 i; i < contractsLength; ) {\n            bool canBatch = IStaking(contracts[i]).canBatchTransactions();\n            batch[i] = Batch(contracts[i], canBatch);\n            unchecked {\n                ++i;\n            }\n        }\n        return batch;\n    }\n\n    /**\n        @notice shows if contracts can batch by index\n        @return (address, bool)\n     */\n    function canBatchContractByIndex(uint256 _index)\n        external\n        view\n        returns (address, bool)\n    {\n        return (\n            contracts[_index],\n            IStaking(contracts[_index]).canBatchTransactions()\n        );\n    }\n\n    /**\n        @notice get address in contracts by index\n        @return address\n     */\n    function getAddressByIndex(uint256 _index) external view returns (address) {\n        return contracts[_index];\n    }\n\n    /**\n        @notice get addresses in contracts\n        @return address[]\n     */\n    function getAddresses() external view returns (address[] memory) {\n        return contracts;\n    }\n\n    /**\n        @notice add address to contracts array\n        @param _address - address to add\n     */\n    function addAddress(address _address) external onlyOwner {\n        contracts.push(_address);\n    }\n\n    /**\n        @notice remove address to contracts array\n        @param _address - address to remove\n     */\n    function removeAddress(address _address) external onlyOwner {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (contracts[i] == _address) {\n                delete contracts[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "BatchRequests.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BatchRequests.sendWithdrawalRequests",
                "Type": "DoS",
                "Description": "Sending batch withdrawal requests can possibly DoS due to reaching the block gas limit.",
                "Repair": "Add offset and limit function parameters to implement a \"paginated\" for loop."
            },
            {
                "Location": "BatchRequests.sol#L16, BatchRequests.sol#L36, BatchRequests.sol#L91",
                "Type": "Out-of-gas",
                "Description": "Possible DOS (out-of-gas) on loops.",
                "Repair": "Use a pattern that includes from and to parameters to limit the number of iterations in the for loop."
            }
        ]
    }
]