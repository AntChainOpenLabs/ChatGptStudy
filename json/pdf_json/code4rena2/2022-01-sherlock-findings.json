[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function totalTokenBalanceStakers() public view returns (uint256)",
                "Type": "Token stealing",
                "Description": "A user who joins the systems first (stakes first) can steal everybody's tokens by sending tokens to the system externally.",
                "Repair": "Force users to stake at least some amount in the system"
            },
            {
                "Location": "function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal",
                "Type": "Reentrancy",
                "Description": "This is a reentrancy vulnerability that would allow the attacker to drain the entire SHER balance of the contract.",
                "Repair": "Add a reentrancy guard or use the checks-effects-interactions pattern"
            },
            {
                "Location": "function tokenBalanceOfAddress(address _address) public view returns (uint256)",
                "Type": "Incorrect balance reporting",
                "Description": "Part of the funds held with the strategy can be frozen if the current strategy has tight liquidity when updateYieldStrategy is run.",
                "Repair": "Add a flag to _redeemShares indicating that it was called for a partial shares decrease or make stakeShares and addressShares always change simultaneously"
            },
            {
                "Location": "function yieldStrategyWithdrawAll() external override onlyOwner",
                "Type": "Frozen funds",
                "Description": "Part of the funds held with the strategy can be frozen if the current strategy has tight liquidity when updateYieldStrategy is run.",
                "Repair": "Implement a new method that fails whenever a strategy cannot withdraw all what's due now, and rename current implementation to forceUpdateYieldStrategy"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// This contract contains the logic for handling claims\n// The idea is that the first level of handling a claim is the Sherlock Protocol Claims Committee (SPCC)(a multisig)\n// If a protocol agent doesn't like that result, they can escalate the claim to UMA's Optimistic Oracle (OO), who will be the final decision\n// We also build in a multisig (controlled by UMA) to give the final approve to pay out after the OO approves a claim\n\nimport './Manager.sol';\nimport '../interfaces/managers/ISherlockClaimManager.sol';\nimport '../interfaces/managers/ISherlockProtocolManager.sol';\nimport '../interfaces/UMAprotocol/SkinnyOptimisticOracleInterface.sol';\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\n/// @dev expects 6 decimals input tokens\ncontract SherlockClaimManager is ISherlockClaimManager, ReentrancyGuard, Manager {\n  using SafeERC20 for IERC20;\n\n  // The bond required for a protocol agent to escalate a claim to UMA Optimistic Oracle (OO)\n  /// @dev at time of writing will result in a 20k cost of escalating\n  /// @dev the actual amount is based on the value returned here https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/Store.sol#L131\n  uint256 internal constant BOND = 9_600 * 10**6; // 20k bond\n\n  // The amount of time the protocol agent has to escalate a claim\n  uint256 public constant ESCALATE_TIME = 4 weeks;\n\n  // The UMA Halt Operator (UMAHO) is the multisig (controlled by UMA) who gives final approval to pay out a claim\n  // After the OO has voted to pay out\n  // This variable represents the amount of time during which UMAHO can block a claim that was approved by the OO\n  // After this time period, the claim (which was approved by the OO) is inferred to be approved by UMAHO as well\n  uint256 public constant UMAHO_TIME = 24 hours;\n\n  // The amount of time the Sherlock Protocol Claims Committee (SPCC) gets to decide on a claim\n  // If no action is taken by SPCC during this time, then the protocol agent can escalate the decision to the UMA OO\n  uint256 public constant SPCC_TIME = 7 days;\n\n  // A pre-defined amount of time for the proposed price ($0) to be disputed within the OO\n  // Note This value is not important as we immediately dispute the proposed price\n  // 7200 represents 2 hours\n  uint256 internal constant LIVENESS = 7200;\n\n  // This is how UMA will know that Sherlock is requesting a decision from the OO\n  // This is \"SHERLOCK_CLAIM\" in hex value\n  bytes32 public constant override UMA_IDENTIFIER =\n    bytes32(0x534845524c4f434b5f434c41494d000000000000000000000000000000000000);\n\n  uint256 public constant MAX_CALLBACKS = 4;\n\n  // The Optimistic Oracle contract that we interact with\n  SkinnyOptimisticOracleInterface public constant UMA =\n    SkinnyOptimisticOracleInterface(0xeE3Afe347D5C74317041E2618C49534dAf887c24);\n\n  // USDC\n  IERC20 public constant TOKEN = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n  // The address of the multisig controlled by UMA that can emergency halt a claim that was approved by the OO\n  address public override umaHaltOperator;\n  // The address of the multisig controlled by Sherlock advisors who make the first judgment on a claim\n  address public immutable override sherlockProtocolClaimsCommittee;\n\n  // Takes a protocol's internal ID as a key and whether or not the protocol has a claim active as the value\n  // Note Each protocol can only have one claim active at a time (this prevents spam)\n  mapping(bytes32 => bool) public protocolClaimActive;\n\n  // A protocol's public claim ID is simply incremented by 1 from the last claim ID made by any protocol (1, 2, 3, etc.)\n  // A protocol's internal ID is the keccak256() of a protocol's ancillary data field\n  // A protocol's ancillary data field will contain info like the hash of the protocol's coverage agreement (each will be unique)\n  // The public ID (1, 2, 3, etc.) is easy to track while the internal ID is used for interacting with UMA\n  mapping(uint256 => bytes32) internal publicToInternalID;\n\n  // Opposite of the last field, allows us to move between a protocol's public ID and internal ID\n  mapping(bytes32 => uint256) internal internalToPublicID;\n\n  // Protocol's internal ID is the key, active claim is the value\n  // Claim object is initialized in startClaim() below\n  // See ISherlockClaimManager.sol for Claim struct\n  mapping(bytes32 => Claim) internal claims_;\n\n  // The last claim ID we used for a claim (ID is incremented by 1 each time)\n  uint256 internal lastClaimID;\n\n  // A request object used in the UMA OO\n  SkinnyOptimisticOracleInterface.Request private umaRequest;\n\n  // An array of contracts that implement the callback provided in this contract\n  ISherlockClaimManagerCallbackReceiver[] public claimCallbacks;\n\n  // Used for callbacks on UMA functions\n  // This modifier is used for a function being called by the OO contract, requires this contract as caller\n  // Requires the OO contract to pass in the Sherlock identifier\n  modifier onlyUMA(bytes32 identifier) {\n    if (identifier != UMA_IDENTIFIER) revert InvalidArgument();\n    if (msg.sender != address(UMA)) revert InvalidSender();\n    _;\n  }\n\n  // Only the Sherlock Claims Committee multisig can call a function with this modifier\n  modifier onlySPCC() {\n    if (msg.sender != sherlockProtocolClaimsCommittee) revert InvalidSender();\n    _;\n  }\n\n  // Only the UMA Halt Operator multisig can call a function with this modifier\n  modifier onlyUMAHO() {\n    if (msg.sender != umaHaltOperator) revert InvalidSender();\n    _;\n  }\n\n  // We pass in the contract addresses (both will be multisigs) in the constructor\n  constructor(address _umaho, address _spcc) {\n    if (_umaho == address(0)) revert ZeroArgument();\n    if (_spcc == address(0)) revert ZeroArgument();\n\n    umaHaltOperator = _umaho;\n    sherlockProtocolClaimsCommittee = _spcc;\n  }\n\n  // Checks to see if a claim can be escalated to the UMA OO\n  // Claim must be either\n  // 1) Denied by SPCC and within 4 weeks after denial\n  // 2) Beyond the designated time window for SPCC to respond\n  function _isEscalateState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccDenied && block.timestamp <= updated + ESCALATE_TIME) return true;\n\n    uint256 spccDeadline = updated + SPCC_TIME;\n    if (\n      _oldState == State.SpccPending &&\n      spccDeadline < block.timestamp &&\n      block.timestamp <= spccDeadline + ESCALATE_TIME\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // Checks to see if a claim can be paid out\n  // Will be paid out if:\n  // 1) SPCC approved it\n  // 2) UMA OO approved it and there is no UMAHO anymore\n  // 3) UMA OO approved it and the designated window for the UMAHO to block it has passed\n  function _isPayoutState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccApproved) return true;\n\n    // If there is no UMA Halt Operator, then it can be paid out on UmaApproved state\n    if (umaHaltOperator == address(0)) {\n      if (_oldState == State.UmaApproved) return true;\n    } else {\n      // If there IS a nonzero UMAHO address, must wait for UMAHO halt period to pass\n      if (_oldState == State.UmaApproved && updated + UMAHO_TIME < block.timestamp) return true;\n    }\n    return false;\n  }\n\n  function _isCleanupState(State _oldState) internal pure returns (bool) {\n    if (_oldState == State.SpccDenied) return true;\n    if (_oldState == State.SpccPending) return true;\n    return false;\n  }\n\n  // Deletes the data associated with a claim (after claim has reached its final state)\n  // _claimIdentifier is the internal claim ID\n  function _cleanUpClaim(bytes32 _claimIdentifier) internal {\n    // Protocol no longer has an active claim associated with it\n    delete protocolClaimActive[claims_[_claimIdentifier].protocol];\n    // Claim object is deleted\n    delete claims_[_claimIdentifier];\n\n    uint256 publicID = internalToPublicID[_claimIdentifier];\n    // Deletes the public and internal ID key mappings\n    delete publicToInternalID[publicID];\n    delete internalToPublicID[_claimIdentifier];\n  }\n\n  // Each claim has a state that represents what part of the claims process it is in\n  // _claimIdentifier is the internal claim ID\n  // _state represents the state to which a protocol's state field will be changed\n  // See ISherlockClaimManager.sol for the State enum\n  function _setState(bytes32 _claimIdentifier, State _state) internal returns (State _oldState) {\n    // retrieves the Claim object\n    Claim storage claim = claims_[_claimIdentifier];\n    // retrieves the current state (which we preemptively set to the old state)\n    _oldState = claim.state;\n\n    emit ClaimStatusChanged(internalToPublicID[_claimIdentifier], _oldState, _state);\n\n    // If the new state is NonExistent, then we clean up this claim (delete the claim effectively)\n    // Else we update the state to the new state and record the last updated timestamp\n    if (_state == State.NonExistent) {\n      _cleanUpClaim(_claimIdentifier);\n    } else {\n      claims_[_claimIdentifier].state = _state;\n      claims_[_claimIdentifier].updated = block.timestamp;\n    }\n  }\n\n  // Allows us to remove the UMA Halt Operator multisig address if we decide we no longer need UMAHO's services\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external override onlyOwner {\n    if (umaHaltOperator == address(0)) revert InvalidConditions();\n\n    delete umaHaltOperator;\n    emit UMAHORenounced();\n  }\n\n  // Returns the Claim struct for a given claim ID (function takes public ID but converts to internal ID)\n  function claim(uint256 _claimID) external view override returns (Claim memory claim_) {\n    bytes32 id_ = publicToInternalID[_claimID];\n    if (id_ == bytes32(0)) revert InvalidArgument();\n\n    claim_ = claims_[id_];\n    if (claim_.state == State.NonExistent) revert InvalidArgument();\n  }\n\n  // This function allows a new contract to be added that will implement PreCorePayoutCallback()\n  // The intention of this callback is to allow other contracts to trigger payouts, etc. when Sherlock triggers one\n  // This would be helpful for a reinsurer who should pay out when Sherlock pays out\n  // Data is passed to the \"reinsurer\" so it can know if it should pay out and how much\n  /// @dev only add trusted and gas verified callbacks.\n  function addCallback(ISherlockClaimManagerCallbackReceiver _callback)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // Checks to see if the max amount of callback contracts has been reached\n    if (claimCallbacks.length == MAX_CALLBACKS) revert InvalidState();\n    // Checks to see if this callback contract already exists\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      if (claimCallbacks[i] == _callback) revert InvalidArgument();\n    }\n\n    claimCallbacks.push(_callback);\n    emit CallbackAdded(_callback);\n  }\n\n  // This removes a contract from the claimCallbacks array\n  function removeCallback(ISherlockClaimManagerCallbackReceiver _callback, uint256 _index)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // If the index and the callback contract don't line up, revert\n    if (claimCallbacks[_index] != _callback) revert InvalidArgument();\n\n    // Move last index to index of _callback\n    // Creates a copy of the last index value and pastes it over the _index value\n    claimCallbacks[_index] = claimCallbacks[claimCallbacks.length - 1];\n    // Remove last index (because it is now a duplicate)\n    claimCallbacks.pop();\n    emit CallbackRemoved(_callback);\n  }\n\n  /// @notice Cleanup claim if escalation is not pursued\n  /// @param _protocol protocol ID\n  /// @param _claimID public claim ID\n  /// @dev Retrieves current protocol agent for cleanup\n  /// @dev State is either SpccPending or SpccDenied\n  function cleanUp(bytes32 _protocol, uint256 _claimID) external whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_claimID == uint256(0)) revert ZeroArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    // If there is no active claim\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // verify if claim belongs to protocol agent\n    if (claim.protocol != _protocol) revert InvalidArgument();\n\n    State _oldState = _setState(claimIdentifier, State.Cleaned);\n    if (_isCleanupState(_oldState) == false) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Cleaned) revert InvalidState();\n  }\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  /// @dev This is done because a protocols coverage can end after an exploit, either wilfully or forcefully.\n  /// @dev The protocol agent is still active for 7 days after coverage ends, so a claim can still be submitted.\n  /// @dev But in case the claim is approved after the 7 day period, `payoutClaim()` can not be called as the protocol agent is 0\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external override nonReentrant whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (_timestamp == uint32(0)) revert ZeroArgument();\n    if (_timestamp >= block.timestamp) revert InvalidArgument();\n    if (ancillaryData.length == 0) revert ZeroArgument();\n    if (address(sherlockCore) == address(0)) revert InvalidConditions();\n    // Protocol must not already have another claim active\n    if (protocolClaimActive[_protocol]) revert ClaimActive();\n\n    // Creates the internal ID for this claim\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n    // State for this newly created claim must be equal to the default state (NonExistent)\n    if (claims_[claimIdentifier].state != State.NonExistent) revert InvalidArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    // Gets the current and previous coverage amount for this protocol\n    (uint256 current, uint256 previous) = protocolManager.coverageAmounts(_protocol);\n    // The max amount a protocol can claim is the higher of the current and previous coverage amounts\n    uint256 maxClaim = current > previous ? current : previous;\n    // True if a protocol is claiming based on its previous coverage amount (only used in event emission)\n    bool prevCoverage = _amount > current;\n    // Requires the amount claimed is less than or equal to the higher of the current and previous coverage amounts\n    if (_amount > maxClaim) revert InvalidArgument();\n\n    // Increments the last claim ID by 1 to get the public claim ID\n    // Note initial claimID will be 1\n    uint256 claimID = ++lastClaimID;\n    // Protocol now has an active claim\n    protocolClaimActive[_protocol] = true;\n    // Sets the mappings for public and internal claim IDs\n    publicToInternalID[claimID] = claimIdentifier;\n    internalToPublicID[claimIdentifier] = claimID;\n\n    // Initializes a Claim object and adds it to claims_ mapping\n    // Created and updated fields are set to current time\n    // State is updated to SpccPending (waiting on SPCC decision now)\n    claims_[claimIdentifier] = Claim(\n      block.timestamp,\n      block.timestamp,\n      msg.sender,\n      _protocol,\n      _amount,\n      _receiver,\n      _timestamp,\n      State.SpccPending,\n      ancillaryData\n    );\n\n    emit ClaimCreated(claimID, _protocol, _amount, _receiver, prevCoverage);\n    emit ClaimStatusChanged(claimID, State.NonExistent, State.SpccPending);\n  }\n\n  // Only SPCC can call this\n  // SPCC approves the claim and it can now be paid out\n  // Requires that the last state of the claim was SpccPending\n  function spccApprove(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccApproved) != State.SpccPending) revert InvalidState();\n  }\n\n  // Only SPCC can call this\n  // SPCC denies the claim and now the protocol agent can escalate to UMA OO if they desire\n  function spccRefuse(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccDenied) != State.SpccPending) revert InvalidState();\n  }\n\n  // If SPCC denied (or didn't respond to) the claim, a protocol agent can now escalate it to UMA's OO\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev Requires the caller to be the account that initially started the claim\n  // Amount sent needs to be at least equal to the BOND amount required\n  function escalate(uint256 _claimID, uint256 _amount)\n    external\n    override\n    nonReentrant\n    whenNotPaused\n  {\n    if (_amount < BOND) revert InvalidArgument();\n\n    // Gets the internal ID of the claim\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Retrieves the claim struct\n    Claim storage claim = claims_[claimIdentifier];\n    // Requires the caller to be the account that initially started the claim\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    // Timestamp when claim was last updated\n    uint256 updated = claim.updated;\n    // Sets the state to UmaPriceProposed\n    State _oldState = _setState(claimIdentifier, State.UmaPriceProposed);\n\n    // Can this claim be updated (based on its current state)? If no, revert\n    if (_isEscalateState(_oldState, updated) == false) revert InvalidState();\n\n    // Transfers the bond amount from the protocol agent to this address\n    TOKEN.safeTransferFrom(msg.sender, address(this), _amount);\n    // Approves the OO contract to spend the bond amount\n    TOKEN.safeApprove(address(UMA), _amount);\n\n    // Sherlock protocol proposes a claim amount of $0 to the UMA OO to begin with\n    // This line https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L585\n    // Will result in disputeSuccess=true if the DVM resolved price != 0\n    // Note: The resolved price needs to exactly match the claim amount\n    // Otherwise the `umaApproved` in our settled callback will be false\n    UMA.requestAndProposePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      TOKEN, // USDC\n      0, // Reward is 0, Sherlock handles rewards on its own\n      BOND, // Cost of making a request to the UMA OO (as decided by Sherlock)\n      LIVENESS, // Proposal liveness\n      address(sherlockCore), // Sherlock core address\n      0 // price\n    );\n\n    // If the state is not equal to ReadyToProposeUmaDispute, revert\n    // Then set the new state to UmaDisputeProposed\n    // Note State gets set to ReadyToProposeUmaDispute in the callback function from requestAndProposePriceFor()\n    if (_setState(claimIdentifier, State.UmaDisputeProposed) != State.ReadyToProposeUmaDispute) {\n      revert InvalidState();\n    }\n\n    // The protocol agent is now disputing Sherlock's proposed claim amount of $0\n    UMA.disputePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      umaRequest, // Refers to the original request made by Sherlock in requestAndProposePriceFor()\n      msg.sender, // Protocol agent, known as the disputer (the one who is disputing Sherlock's $0 proposed claim amount)\n      address(this) // This contract's address is the requester (Sherlock made the original request and proposed $0 claim amount)\n    );\n\n    // State gets updated to UmaPending in the disputePriceFor() callback (priceDisputed())\n    if (claim.state != State.UmaPending) revert InvalidState();\n\n    // Deletes the original request made by Sherlock\n    delete umaRequest;\n    // Approves the OO to spend $0\n    // This is just out of caution, don't want UMA to be approved for any amount of tokens they shouldn't be\n    TOKEN.safeApprove(address(UMA), 0);\n    // Checks for remaining balance in the contract\n    uint256 remaining = TOKEN.balanceOf(address(this));\n    // Sends remaining balance to the protocol agent\n    // A protocol agent should be able to send the exact amount to avoid the extra gas from this function\n    if (remaining != 0) TOKEN.safeTransfer(msg.sender, remaining);\n  }\n\n  // Checks to make sure a payout is valid, then calls the core Sherlock payout function\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  // We are ok with spending the extra time to wait for the UMAHO time to expire before paying out\n  // We could have UMAHO multisig send a tx to confirm the payout (payout would happen sooner),\n  // But doesn't seem worth it to save half a day or so\n  function payoutClaim(uint256 _claimID) external override nonReentrant whenNotPaused {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // Only the claim initiator can call this, and payout gets sent to receiver address\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    bytes32 protocol = claim.protocol;\n    // Address to receive the payout\n    // Note We could make the receiver a param in this function, but we want it to be known asap\n    // Can find and correct problems if the receiver is specified when the claim is initiated\n    address receiver = claim.receiver;\n    // Amount (in USDC) to be paid out\n    uint256 amount = claim.amount;\n    // Time when claim was last updated\n    uint256 updated = claim.updated;\n\n    // Sets new state to NonExistent as the claim is over once it is paid out\n    State _oldState = _setState(claimIdentifier, State.NonExistent);\n    // Checks to make sure this claim can be paid out\n    if (_isPayoutState(_oldState, updated) == false) revert InvalidState();\n\n    // Calls the PreCorePayoutCallback function on any contracts in claimCallbacks\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      claimCallbacks[i].PreCorePayoutCallback(protocol, _claimID, amount);\n    }\n\n    emit ClaimPayout(_claimID, receiver, amount);\n\n    // We could potentially transfer more than `amount` in case balance > amount\n    // We are leaving this as is for simplicity's sake\n    // We don't expect to have tokens in this contract unless a reinsurer is providing them for a payout\n    // In which case they should provide the exact amount, and balance == amount is true\n    uint256 balance = TOKEN.balanceOf(address(this));\n    if (balance != 0) TOKEN.safeTransfer(receiver, balance);\n    if (balance < amount) sherlockCore.payoutClaim(receiver, amount - balance);\n  }\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  // Once the UMAHO_TIME is up, UMAHO can still halt the claim, but only if the claim hasn't been paid out yet\n  function executeHalt(uint256 _claimID) external override whenNotPaused onlyUMAHO nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Sets state of claim to nonexistent, reverts if the old state was anything but UmaApproved\n    if (_setState(claimIdentifier, State.Halted) != State.UmaApproved) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Halted) revert InvalidState();\n\n    emit ClaimHalted(_claimID);\n  }\n\n  //\n  // UMA callbacks\n  //\n\n  // Once requestAndProposePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaPriceProposed to ReadyToProposeUmaDispute\n  // Then we call the next function in the process, disputePriceFor()\n  // @note reentrancy is allowed for this call\n  function priceProposed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to ReadyToProposeUmaDispute\n    if (_setState(claimIdentifier, State.ReadyToProposeUmaDispute) != State.UmaPriceProposed) {\n      revert InvalidState();\n    }\n    // Sets global umaRequest variable to the request coming from this price proposal\n    umaRequest = request;\n  }\n\n  // Once disputePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaDisputeProposed to UmaPending\n  // Then we call the next function in the process, priceSettled()\n  // @note reentrancy is allowed for this call\n  function priceDisputed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to UmaPending\n    if (_setState(claimIdentifier, State.UmaPending) != State.UmaDisputeProposed) {\n      revert InvalidState();\n    }\n  }\n\n  // Once priceSettled() is executed in UMA's contracts, this function gets called\n  // UMA OO gives back a resolved price (either 0 or claim.amount) and\n  // Claim's state is changed to either UmaApproved or UmaDenied\n  // If UmaDenied, the claim is dead and state is immediately changed to NonExistent and cleaned up\n  /// @dev still want to capture settled price in a paused state. Otherwise claim is stuck.\n  function priceSettled(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override onlyUMA(identifier) nonReentrant {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n\n    // Retrives the resolved price for this claim (either 0 if Sherlock wins, or the amount of the claim as proposed by the protocol agent)\n    uint256 resolvedPrice = uint256(request.resolvedPrice);\n    // UMA approved the claim if the resolved price is equal to the claim amount set by the protocol agent\n    bool umaApproved = resolvedPrice == claim.amount;\n\n    // If UMA approves the claim, set state to UmaApproved\n    // If UMA denies, set state to UmaDenied, then to NonExistent (deletes the claim data)\n    if (umaApproved) {\n      if (_setState(claimIdentifier, State.UmaApproved) != State.UmaPending) revert InvalidState();\n    } else {\n      if (_setState(claimIdentifier, State.UmaDenied) != State.UmaPending) revert InvalidState();\n      if (_setState(claimIdentifier, State.NonExistent) != State.UmaDenied) revert InvalidState();\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "SherlockClaimManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SherlockClaimManager contract",
                "Type": "Incorrect amounts needed and paid for escalated claims",
                "Description": "The protocol agent is required to pay and stake a certain amount for the process of escalating claims. However, the actual amount required from the protocol agent is more than what is expected due to UMA burning half of the BOND collected + final fee. The documentation is also incorrect about the burned amount.",
                "Repair": "Change the parameters of requestAndProposePriceFor() to set BOND as the reward and the actual bond for UMA as 1. Update the documentation to reflect the correct burned amount."
            }
        ]
    }
]