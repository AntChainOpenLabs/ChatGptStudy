[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IStableVault.sol\";\n\ninterface IERC20Mintable is IERC20 {\n    function mintFor(address, uint256) external;\n    function burnFrom(address, uint256) external;\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract StableVault is MetaContext, IStableVault {\n\n    mapping(address => bool) public allowed;\n    mapping(address => uint) private tokenIndex;\n    address[] public tokens;\n\n    address public immutable stable;\n\n    constructor(address _stable) {\n        stable = _stable;\n    }\n\n    /**\n    * @notice deposit an allowed token and receive tigAsset\n    * @param _token address of the allowed token\n    * @param _amount amount of _token\n    */\n    function deposit(address _token, uint256 _amount) public {\n        require(allowed[_token], \"Token not listed\");\n        IERC20(_token).transferFrom(_msgSender(), address(this), _amount);\n        IERC20Mintable(stable).mintFor(\n            _msgSender(),\n            _amount*(10**(18-IERC20Mintable(_token).decimals()))\n        );\n    }\n\n    function depositWithPermit(address _token, uint256 _amount, uint256 _deadline, bool _permitMax, uint8 v, bytes32 r, bytes32 s) external {\n        uint _toAllow = _amount;\n        if (_permitMax) _toAllow = type(uint).max;\n        ERC20Permit(_token).permit(_msgSender(), address(this), _toAllow, _deadline, v, r, s);\n        deposit(_token, _amount);\n    }\n\n    /**\n    * @notice swap tigAsset to _token\n    * @param _token address of the token to receive\n    * @param _amount amount of _token\n    */\n    function withdraw(address _token, uint256 _amount) external returns (uint256 _output) {\n        IERC20Mintable(stable).burnFrom(_msgSender(), _amount);\n        _output = _amount/10**(18-IERC20Mintable(_token).decimals());\n        IERC20(_token).transfer(\n            _msgSender(),\n            _output\n        );\n    }\n\n    /**\n    * @notice allow a token to be used in vault\n    * @param _token address of the token\n    */\n    function listToken(address _token) external onlyOwner {\n        require(!allowed[_token], \"Already added\");\n        tokenIndex[_token] = tokens.length;\n        tokens.push(_token);\n        allowed[_token] = true;\n    }\n\n    /**\n    * @notice stop a token from being allowed in vault\n    * @param _token address of the token\n    */\n    function delistToken(address _token) external onlyOwner {\n        require(allowed[_token], \"Not added\");\n        tokenIndex[tokens[tokens.length-1]] = tokenIndex[_token];\n        tokens[tokenIndex[_token]] = tokens[tokens.length-1];\n        delete tokenIndex[_token];\n        tokens.pop();\n        allowed[_token] = false;\n    }\n}\n\n",
        "CodeNames": [
            "StableVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StableVault.sol",
                "Type": "Arbitrage",
                "Description": "The StableVault contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices, the balance sheet of the contract can be arbitraged (especially by flash-loans) to swap an undesirable asset for a more desirable asset acquiring an arbitrage in the price by selling the traded asset.",
                "Repair": "Utilize Chainlink oracles for evaluating the inflow of assets instead, ensuring that all inflows and outflows of stablecoins are fairly evaluated based on their \"neutral\" USD price rather than their subjective on-chain price or equality assumption."
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/IPosition.sol\";\n\ninterface IPrice {\n    function latestAnswer() external view returns (int256);\n    function decimals() external view returns (uint256);\n}\n\nstruct PriceData {\n    address provider;\n    uint256 asset;\n    uint256 price;\n    uint256 spread;\n    uint256 timestamp;\n    bool isClosed;\n}\n\nlibrary TradingLibrary {\n\n    using ECDSA for bytes32;\n\n    /**\n    * @notice returns position profit or loss\n    * @param _direction true if long\n    * @param _currentPrice current price\n    * @param _price opening price\n    * @param _leverage position leverage\n    * @param _margin collateral amount\n    * @param accInterest funding fees\n    * @return _positionSize position size\n    * @return _payout payout trader should get\n    */\n    function pnl(bool _direction, uint _currentPrice, uint _price, uint _margin, uint _leverage, int256 accInterest) external pure returns (uint256 _positionSize, int256 _payout) {\n        unchecked {\n            uint _initPositionSize = _margin * _leverage / 1e18;\n            if (_direction && _currentPrice >= _price) {\n                _payout = int256(_margin) + int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;\n            } else if (_direction && _currentPrice < _price) {\n                _payout = int256(_margin) - int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;\n            } else if (!_direction && _currentPrice <= _price) {\n                _payout = int256(_margin) + int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;\n            } else {\n                _payout = int256(_margin) - int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;\n            }\n            _positionSize = _initPositionSize * _currentPrice / _price;\n        }\n    }\n\n    /**\n    * @notice returns position liquidation price\n    * @param _direction true if long\n    * @param _tradePrice opening price\n    * @param _leverage position leverage\n    * @param _margin collateral amount\n    * @param _accInterest funding fees\n    * @param _liqPercent liquidation percent\n    * @return _liqPrice liquidation price\n    */\n    function liqPrice(bool _direction, uint _tradePrice, uint _leverage, uint _margin, int _accInterest, uint _liqPercent) public pure returns (uint256 _liqPrice) {\n        if (_direction) {\n            _liqPrice = _tradePrice - ((_tradePrice*1e18/_leverage) * uint(int(_margin)+_accInterest) / _margin) * _liqPercent / 1e10;\n        } else {\n            _liqPrice = _tradePrice + ((_tradePrice*1e18/_leverage) * uint(int(_margin)+_accInterest) / _margin) * _liqPercent / 1e10;\n        }\n    }\n\n    /**\n    * @notice uses liqPrice() and returns position liquidation price\n    * @param _positions positions contract address\n    * @param _id position id\n    * @param _liqPercent liquidation percent\n    */\n    function getLiqPrice(address _positions, uint _id, uint _liqPercent) external view returns (uint256) {\n        IPosition.Trade memory _trade = IPosition(_positions).trades(_id);\n        return liqPrice(_trade.direction, _trade.price, _trade.leverage, _trade.margin, _trade.accInterest, _liqPercent);\n    }\n\n    /**\n    * @notice verifies that price is signed by a whitelisted node\n    * @param _validSignatureTimer seconds allowed before price is old\n    * @param _asset position asset\n    * @param _chainlinkEnabled is chainlink verification is on\n    * @param _chainlinkFeed address of chainlink price feed\n    * @param _priceData PriceData object\n    * @param _signature signature returned from oracle\n    * @param _isNode mapping of allowed nodes\n    */\n    function verifyPrice(\n        uint256 _validSignatureTimer,\n        uint256 _asset,\n        bool _chainlinkEnabled,\n        address _chainlinkFeed,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        mapping(address => bool) storage _isNode\n    )\n        external view\n    {\n        address _provider = (\n            keccak256(abi.encode(_priceData))\n        ).toEthSignedMessageHash().recover(_signature);\n        require(_provider == _priceData.provider, \"BadSig\");\n        require(_isNode[_provider], \"!Node\");\n        require(_asset == _priceData.asset, \"!Asset\");\n        require(!_priceData.isClosed, \"Closed\");\n        require(block.timestamp >= _priceData.timestamp, \"FutSig\");\n        require(block.timestamp <= _priceData.timestamp + _validSignatureTimer, \"ExpSig\");\n        require(_priceData.price > 0, \"NoPrice\");\n        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {\n            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n            if (assetChainlinkPriceInt != 0) {\n                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n                require(\n                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n                );\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "TradingLibrary.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TradingLibrary.pnl()",
                "Type": "Overflow",
                "Description": "An overflow in TradingLibrary.pnl() enables all funds from the vault contracts to be drained given a certain fee configuration is present.",
                "Repair": "Remove the unchecked block."
            },
            {
                "Location": "TradingLibrary.sol#verifyPrice()",
                "Type": "Stale price feed",
                "Description": "The Chainlink price verification logic in the following TradingLibrary.verifyPrice function serves this purpose. However, besides that IPrice(_chainlinkFeed).latestAnswer() uses Chainlink's deprecated latestAnswer function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale.",
                "Repair": "Check for updatedAt to not be too far in the past or check answeredInRound against the current roundId to avoid using a stale price returned by the Chainlink price feed"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "addToPosition() function",
                "Type": "Bypassing maximum PnL check",
                "Description": "An attacker can exploit the implementation missing to check the maximum PnL limitation while addToPosition() to get more profit than expected.",
                "Repair": "Add a check for addToPosition() function, revert if PnL = 500%, enforce users to close the order to take a limited profit."
            },
            {
                "Location": "_checkDelay() function",
                "Type": "Bypass delay security check",
                "Description": "The protection provided by the current implementation is not enough, an attacker can long with low price and short with high price at the same transaction but two orders to lock profit and take risk-free funds.",
                "Repair": "Implement additional security measures to prevent profitable opening and closing in the same transaction with two different prices in the 'valid signature pool'"
            },
            {
                "Location": "function _transfer(address from, address to, uint256 _id) internal override",
                "Type": "Transfer restriction bypass",
                "Description": "BondNFTs can revert when transferred if epoch[tigAsset] is not updated to the current day, which can happen if rewards are not distributed in the same day. This can cause BondNFTs listed on open markets to not fulfill orders and BondNFTs deposited as collateral to not release the collateral.",
                "Repair": "Replace require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\"); with require(bond.expireEpoch <= block.timestamp/DAY, \"Transfer after expired not allowed\");"
            },
            {
                "Location": "addToPosition function",
                "Type": "Incorrect calculation of new price while adding position",
                "Description": "The vulnerability occurs due to the incorrect calculation of PnL payout while adding a position in the addToPosition function. The expected PnL payout is calculated using an incorrect formula, which can result in incorrect payouts to users.",
                "Repair": "Use the correct formula for calculating PnL payout"
            },
            {
                "Location": "function claimGovFees() public",
                "Type": "Approval vulnerability",
                "Description": "Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.",
                "Repair": "Add an approve(0) before approving"
            },
            {
                "Location": "GovNFT: setMaxBridge function",
                "Type": "Unused Variable",
                "Description": "The maxBridge variable is not used to limit the number of GovNFTs crossing chain, even though the setMaxBridge function is provided.",
                "Repair": "Consider applying the maxBridge variable"
            },
            {
                "Location": "Trading: limitClose() function",
                "Type": "Bot Fee Manipulation",
                "Description": "A user can use a proxy contract to update the stop-loss value and then limitClose() the order, taking the bot fees to themselves.",
                "Repair": "Don't allow updating sl or tp and executing limitClose() at the same block"
            },
            {
                "Location": "function limitClose()",
                "Type": "Abuse of stop losses and high leverage",
                "Description": "User can abuse how stop losses are priced to open high leverage trades with huge upside and very little downside.",
                "Repair": "Execute take profit and stop loss trades at the current price rather than the price specified by the user"
            },
            {
                "Location": "function _checkDelay()",
                "Type": "Incorrect use of block.number for trade delay",
                "Description": "_checkDelay will not work correctly on Arbitrum allowing users to exploit multiple valid prices.",
                "Repair": "Measure delay using block.timestamp rather than block.number"
            },
            {
                "Location": "Trading#initiateMarketOrder",
                "Type": "Calculation Error",
                "Description": "The _handleOpenFees function does not consider referral fees when calculating fees, leading to the opening of a position greater than expected.",
                "Repair": "Consider referral fees when calculating fees in _handleOpenFees function"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract PairsContract is Ownable, IPairsContract {\n\n    address public protocol;\n\n    mapping(uint256 => bool) public allowedAsset;\n\n    uint256 private maxBaseFundingRate = 1e10;\n\n    mapping(uint256 => Asset) private _idToAsset;\n    function idToAsset(uint256 _asset) public view returns (Asset memory) {\n        return _idToAsset[_asset];\n    }\n\n    mapping(uint256 => mapping(address => OpenInterest)) private _idToOi;\n    function idToOi(uint256 _asset, address _tigAsset) public view returns (OpenInterest memory) {\n        return _idToOi[_asset][_tigAsset];\n    }\n\n    // OWNER\n\n    /**\n     * @dev Update the Chainlink price feed of an asset\n     * @param _asset index of the requested asset\n     * @param _feed contract address of the Chainlink price feed\n     */\n    function setAssetChainlinkFeed(uint256 _asset, address _feed) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        _idToAsset[_asset].chainlinkFeed = _feed;\n    }\n\n    /**\n     * @dev Add an allowed asset to fetch prices for\n     * @param _asset index of the requested asset\n     * @param _name name of the asset\n     * @param _chainlinkFeed optional address of the respective Chainlink price feed\n     * @param _maxLeverage maximimum allowed leverage\n     * @param _maxLeverage minimum allowed leverage\n     * @param _feeMultiplier percent value that the opening/closing fee is multiplied by in BP\n     */\n    function addAsset(uint256 _asset, string memory _name, address _chainlinkFeed, uint256 _minLeverage, uint256 _maxLeverage, uint256 _feeMultiplier, uint256 _baseFundingRate) external onlyOwner {\n        bytes memory _assetName  = bytes(_idToAsset[_asset].name);\n        require(_assetName.length == 0, \"Already exists\");\n        require(bytes(_name).length > 0, \"No name\");\n        require(_maxLeverage >= _minLeverage && _minLeverage > 0, \"Wrong leverage values\");\n\n        allowedAsset[_asset] = true;\n        _idToAsset[_asset].name = _name;\n\n        _idToAsset[_asset].chainlinkFeed = _chainlinkFeed;\n\n        _idToAsset[_asset].minLeverage = _minLeverage;\n        _idToAsset[_asset].maxLeverage = _maxLeverage;\n        _idToAsset[_asset].feeMultiplier = _feeMultiplier;\n        _idToAsset[_asset].baseFundingRate = _baseFundingRate;\n\n        emit AssetAdded(_asset, _name);\n    }\n\n    /**\n     * @dev Update the leverage allowed per asset\n     * @param _asset index of the asset\n     * @param _minLeverage minimum leverage allowed\n     * @param _maxLeverage Maximum leverage allowed\n     */\n    function updateAssetLeverage(uint256 _asset, uint256 _minLeverage, uint256 _maxLeverage) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n\n        if (_maxLeverage > 0) {\n            _idToAsset[_asset].maxLeverage = _maxLeverage;\n        }\n        if (_minLeverage > 0) {\n            _idToAsset[_asset].minLeverage = _minLeverage;\n        }\n        \n        require(_idToAsset[_asset].maxLeverage >= _idToAsset[_asset].minLeverage, \"Wrong leverage values\");\n    }\n\n    /**\n     * @notice update the base rate for funding fees per asset\n     * @param _asset index of the asset\n     * @param _baseFundingRate the rate to set\n     */\n    function setAssetBaseFundingRate(uint256 _asset, uint256 _baseFundingRate) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        require(_baseFundingRate <= maxBaseFundingRate, \"baseFundingRate too high\");\n        _idToAsset[_asset].baseFundingRate = _baseFundingRate;\n    }\n\n    /**\n     * @notice update the fee multiplier per asset\n     * @param _asset index of the asset\n     * @param _feeMultiplier the fee multiplier\n     */\n    function updateAssetFeeMultiplier(uint256 _asset, uint256 _feeMultiplier) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        _idToAsset[_asset].feeMultiplier = _feeMultiplier;\n    }\n\n     /**\n     * @notice pause an asset from being traded\n     * @param _asset index of the asset\n     * @param _isPaused paused if true\n     */\n    function pauseAsset(uint256 _asset, bool _isPaused) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        allowedAsset[_asset] = !_isPaused;\n    }\n\n    /**\n     * @notice sets the max rate for funding fees\n     * @param _maxBaseFundingRate max base funding rate\n     */\n    function setMaxBaseFundingRate(uint256 _maxBaseFundingRate) external onlyOwner {\n        maxBaseFundingRate = _maxBaseFundingRate;\n    }\n\n    function setProtocol(address _protocol) external onlyOwner {\n        protocol = _protocol;\n    }\n\n    /**\n     * @dev Update max open interest limits\n     * @param _asset index of the asset\n     * @param _tigAsset contract address of the tigAsset\n     * @param _maxOi Maximum open interest value per side\n     */\n    function setMaxOi(uint256 _asset, address _tigAsset, uint256 _maxOi) external onlyOwner {\n        bytes memory _name  = bytes(_idToAsset[_asset].name);\n        require(_name.length > 0, \"!Asset\");\n        _idToOi[_asset][_tigAsset].maxOi = _maxOi;\n    }\n\n    // Protocol-only\n\n    /**\n     * @dev edits the current open interest for long\n     * @param _asset index of the asset\n     * @param _tigAsset contract address of the tigAsset\n     * @param _onOpen true if adding to open interesr\n     * @param _amount amount to be added/removed from open interest\n     */\n    function modifyLongOi(uint256 _asset, address _tigAsset, bool _onOpen, uint256 _amount) external onlyProtocol {\n        if (_onOpen) {\n            _idToOi[_asset][_tigAsset].longOi += _amount;\n            require(_idToOi[_asset][_tigAsset].longOi <= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0, \"MaxLongOi\");\n        }\n        else {\n            _idToOi[_asset][_tigAsset].longOi -= _amount;\n            if (_idToOi[_asset][_tigAsset].longOi < 1e9) {\n                _idToOi[_asset][_tigAsset].longOi = 0;\n            }\n        }\n    }\n\n     /**\n     * @dev edits the current open interest for short\n     * @param _asset index of the asset\n     * @param _tigAsset contract address of the tigAsset\n     * @param _onOpen true if adding to open interesr\n     * @param _amount amount to be added/removed from open interest\n     */\n    function modifyShortOi(uint256 _asset, address _tigAsset, bool _onOpen, uint256 _amount) external onlyProtocol {\n        if (_onOpen) {\n            _idToOi[_asset][_tigAsset].shortOi += _amount;\n            require(_idToOi[_asset][_tigAsset].shortOi <= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0, \"MaxShortOi\");\n            }\n        else {\n            _idToOi[_asset][_tigAsset].shortOi -= _amount;\n            if (_idToOi[_asset][_tigAsset].shortOi < 1e9) {\n                _idToOi[_asset][_tigAsset].shortOi = 0;\n            }\n        }\n    }\n\n    // Modifiers\n\n    modifier onlyProtocol() {\n        require(_msgSender() == address(protocol), \"!Protocol\");\n        _;\n    }\n\n    // EVENTS\n\n    event AssetAdded(\n        uint _asset,\n        string _name\n    );\n\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"./utils/MetaContext.sol\";\n\ncontract StableToken is ERC20Permit, MetaContext {\n\n    mapping(address => bool) public isMinter;\n\n    constructor(string memory name_, string memory symbol_) ERC20Permit(name_) ERC20(name_, symbol_) {}\n\n    function burnFrom(\n        address account,\n        uint256 amount\n    ) \n        public \n        virtual \n        onlyMinter() \n    {\n        _burn(account, amount);\n    }\n\n    function mintFor(\n        address account,\n        uint256 amount\n    ) \n        public \n        virtual \n        onlyMinter() \n    {  \n        _mint(account, amount);\n    }\n\n    /**\n     * @dev Sets the status of minter.\n     */\n    function setMinter(\n        address _address,\n        bool _status\n    ) \n        public\n        onlyOwner()\n    {\n        isMinter[_address] = _status;\n    }\n\n    /**\n     * @dev Throws if called by any account that is not minter.\n     */\n    modifier onlyMinter() {\n        require(isMinter[_msgSender()], \"!Minter\");\n        _;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n\n    // Unreachable\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/ITrading.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./interfaces/IReferrals.sol\";\nimport \"./interfaces/IPosition.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./interfaces/IStableVault.sol\";\nimport \"./utils/TradingLibrary.sol\";\n\ninterface ITradingExtension {\n    function getVerifiedPrice(\n        uint _asset,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        uint _withSpreadIsLong\n    ) external returns(uint256 _price, uint256 _spread);\n    function getRef(\n        address _trader\n    ) external pure returns(address);\n    function _setReferral(\n        bytes32 _referral,\n        address _trader\n    ) external;\n    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;\n    function isPaused() external view returns(bool);\n    function minPos(address) external view returns(uint);\n    function modifyLongOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function modifyShortOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function paused() external returns(bool);\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external returns(uint _limitPrice, address _tigAsset);\n    function _checkGas() external view;\n    function _closePosition(\n        uint _id,\n        uint _price,\n        uint _percent\n    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);\n}\n\ninterface IStable is IERC20 {\n    function burnFrom(address account, uint amount) external;\n    function mintFor(address account, uint amount) external;\n}\n\ninterface ExtendedIERC20 is IERC20 {\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract Trading is MetaContext, ITrading {\n\n    error LimitNotSet(); //7\n    error NotLiquidatable();\n    error TradingPaused();\n    error BadDeposit();\n    error BadWithdraw();\n    error ValueNotEqualToMargin();\n    error BadLeverage();\n    error NotMargin();\n    error NotAllowedPair();\n    error BelowMinPositionSize();\n    error BadClosePercent();\n    error NoPrice();\n    error LiqThreshold();\n\n    uint constant private DIVISION_CONSTANT = 1e10; // 100%\n    uint private constant liqPercent = 9e9; // 90%\n\n    struct Fees {\n        uint daoFees;\n        uint burnFees;\n        uint referralFees;\n        uint botFees;\n    }\n    Fees public openFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    Fees public closeFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    uint public limitOrderPriceRange = 1e8; // 1%\n\n    uint public maxWinPercent;\n    uint public vaultFundingPercent;\n\n    IPairsContract private pairsContract;\n    IPosition private position;\n    IGovNFT private gov;\n    ITradingExtension private tradingExtension;\n\n    struct Delay {\n        uint delay; // Block number where delay ends\n        bool actionType; // True for open, False for close\n    }\n    mapping(uint => Delay) public blockDelayPassed; // id => Delay\n    uint public blockDelay;\n    mapping(uint => uint) public limitDelay; // id => block.timestamp\n\n    mapping(address => bool) public allowedVault;\n\n    struct Proxy {\n        address proxy;\n        uint256 time;\n    }\n\n    mapping(address => Proxy) public proxyApprovals;\n\n    constructor(\n        address _position,\n        address _gov,\n        address _pairsContract\n    )\n    {\n        position = IPosition(_position);\n        gov = IGovNFT(_gov);\n        pairsContract = IPairsContract(_pairsContract);\n    }\n\n    // ===== END-USER FUNCTIONS =====\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateMarketOrder(\n        TradeInfo calldata _tradeInfo,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(position.getCount(), true);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\n        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        uint256 _isLong = _tradeInfo.direction ? 1 : 2;\n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);\n        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(\n            _trader,\n            _marginAfterFees,\n            _tradeInfo.leverage,\n            _tradeInfo.asset,\n            _tradeInfo.direction,\n            _price,\n            _tradeInfo.tpPrice,\n            _tradeInfo.slPrice,\n            0,\n            _tigAsset\n        );\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        unchecked {\n            if (_tradeInfo.direction) {\n                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            }\n        }\n        _updateFunding(_tradeInfo.asset, _tigAsset);\n        position.mint(\n            _mintTrade\n        );\n        unchecked {\n            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n        }   \n    }\n\n    /**\n     * @dev initiate closing position\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed in BP\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _outputToken Token received upon closing trade\n     * @param _trader address the trade is initiated for\n     */\n    function initiateCloseOrder(\n        uint _id,\n        uint _percent,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _outputToken,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(_id, false);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit        \n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n\n        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();\n        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); \n    }\n\n    /**\n     * @param _id position id\n     * @param _addMargin margin amount used to add to the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _marginAsset Token being used to add to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n        position.setAccInterest(_id);\n        unchecked {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);\n            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     \n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _addMargin -= _fee;\n            uint _newMargin = _trade.margin + _addMargin;\n            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\n            position.addToPosition(\n                _trade.id,\n                _newMargin,\n                _newPrice\n            );\n            \n            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);\n        }\n    }\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _orderType type of limit order used to open the position\n     * @param _price limit price\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateLimitOrder(\n        TradeInfo calldata _tradeInfo,\n        uint256 _orderType, // 1 limit, 2 stop\n        uint256 _price,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        if (_orderType == 0) revert(\"5\");\n        if (_price == 0) revert NoPrice();\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        uint256 _id = position.getCount();\n        position.mint(\n            IPosition.MintTrade(\n                _trader,\n                _tradeInfo.margin,\n                _tradeInfo.leverage,\n                _tradeInfo.asset,\n                _tradeInfo.direction,\n                _price,\n                _tradeInfo.tpPrice,\n                _tradeInfo.slPrice,\n                _orderType,\n                _tigAsset\n            )\n        );\n        limitDelay[_id] = block.timestamp + 4;\n        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);\n    }\n\n    /**\n     * @param _id position ID\n     * @param _trader address the trade is initiated for\n     */\n    function cancelLimitOrder(\n        uint256 _id,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType == 0) revert();\n        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);\n        position.burn(_id);\n        emit LimitCancelled(_id, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _marginAsset Token being used to add to the position\n     * @param _stableVault StableVault address\n     * @param _addMargin margin amount being added to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addMargin(\n        uint256 _id,\n        address _marginAsset,\n        address _stableVault,\n        uint256 _addMargin,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _marginAsset);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);\n        unchecked {\n            uint256 _newMargin = _trade.margin + _addMargin;\n            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n            if (_newLeverage < asset.minLeverage) revert(\"!lev\");\n            position.modifyMargin(_id, _newMargin, _newLeverage);\n            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);\n        }\n    }\n\n    /**\n     * @param _id position id\n     * @param _stableVault StableVault address\n     * @param _outputToken token the trader will receive\n     * @param _removeMargin margin amount being removed from the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function removeMargin(\n        uint256 _id,\n        address _stableVault,\n        address _outputToken,\n        uint256 _removeMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        uint256 _newMargin = _trade.margin - _removeMargin;\n        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n        if (_newLeverage > asset.maxLeverage) revert(\"!lev\");\n        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);\n        unchecked {\n            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();\n        }\n        position.modifyMargin(_trade.id, _newMargin, _newLeverage);\n        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);\n        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);\n    }\n\n    /**\n     * @param _type true for TP, false for SL\n     * @param _id position id\n     * @param _limitPrice TP/SL trigger price\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function updateTpSl(\n        bool _type,\n        uint _id,\n        uint _limitPrice,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        if (_type) {\n            position.modifyTp(_id, _limitPrice);\n        } else {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            _checkSl(_limitPrice, _trade.direction, _price);\n            position.modifySl(_id, _limitPrice);\n        }\n        emit UpdateTPSL(_id, _type, _limitPrice, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function executeLimitOrder(\n        uint _id, \n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) \n        external\n    {\n        unchecked {\n            _checkDelay(_id, true);\n            tradingExtension._checkGas();\n            if (tradingExtension.paused()) revert TradingPaused();\n            require(block.timestamp >= limitDelay[_id]);\n            IPosition.Trade memory trade = position.trades(_id);\n            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n            if (trade.orderType == 0) revert(\"5\");\n            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n            if (trade.direction && trade.orderType == 1) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 1) {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 2) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } else {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } \n            if(trade.direction) {\n                trade.price += trade.price * _spread / DIVISION_CONSTANT;\n            } else {\n                trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n            }\n            if (trade.direction) {\n                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            } else {\n                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            }\n            _updateFunding(trade.asset, trade.tigAsset);\n            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);\n            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @notice liquidate position\n     * @param _id id of the position NFT\n     * @param _priceData verifiable off-chain data\n     * @param _signature node signature\n     */\n    function liquidatePosition(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        unchecked {\n            tradingExtension._checkGas();\n            IPosition.Trade memory _trade = position.trades(_id);\n            if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);\n            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;\n            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);\n            position.burn(_id);\n            emit PositionLiquidated(_id, _trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @dev close position at a pre-set price\n     * @param _id id of the position NFT\n     * @param _tp true if take profit\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    /**\n     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.\n     * @param _proxy proxy wallet address\n     * @param _timestamp end timestamp of approval period\n     */\n    function approveProxy(address _proxy, uint256 _timestamp) external payable {\n        proxyApprovals[_msgSender()] = Proxy(\n            _proxy,\n            _timestamp\n        );\n        payable(_proxy).transfer(msg.value);\n    }\n\n    // ===== INTERNAL FUNCTIONS =====\n\n    /**\n     * @dev close the initiated position.\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed\n     * @param _price pair price\n     * @param _stableVault StableVault address\n     * @param _outputToken Token that trader will receive\n     * @param _isBot false if closed via market order\n     */\n    function _closePosition(\n        uint _id,\n        uint _percent,\n        uint _price,\n        address _stableVault,\n        address _outputToken,\n        bool _isBot\n    )\n        internal\n    {\n        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);\n        position.setAccInterest(_id);\n        _updateFunding(_trade.asset, _trade.tigAsset);\n        if (_percent < DIVISION_CONSTANT) {\n            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n            position.reducePosition(_id, _percent);\n        } else {\n            position.burn(_id);\n        }\n        uint256 _toMint;\n        if (_payout > 0) {\n            unchecked {\n                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n                }\n            }\n            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);\n        }\n        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n    }\n\n    /**\n     * @dev handle stablevault deposits for different trading functions\n     * @param _tigAsset tigAsset token address\n     * @param _marginAsset token being deposited into stablevault\n     * @param _margin amount being deposited\n     * @param _stableVault StableVault address\n     * @param _permitData Data for approval via permit\n     * @param _trader Trader address to take tokens from\n     */\n    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {\n        IStable tigAsset = IStable(_tigAsset);\n        if (_tigAsset != _marginAsset) {\n            if (_permitData.usePermit) {\n                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);\n            }\n            uint256 _balBefore = tigAsset.balanceOf(address(this));\n            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();\n            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));\n        } else {\n            tigAsset.burnFrom(_trader, _margin);\n        }        \n    }\n\n    /**\n     * @dev handle stablevault withdrawals for different trading functions\n     * @param _trade Position info\n     * @param _stableVault StableVault address\n     * @param _outputToken Output token address\n     * @param _toMint Amount of tigAsset minted to be used for withdrawal\n     */\n    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {\n        IStable(_trade.tigAsset).mintFor(address(this), _toMint);\n        if (_outputToken == _trade.tigAsset) {\n            IERC20(_outputToken).transfer(_trade.trader, _toMint);\n        } else {\n            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n            IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n        }        \n    }\n\n    /**\n     * @dev handle fees distribution for opening\n     * @param _asset asset id\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _tigAsset tigAsset address\n     * @param _isBot false if opened via market order\n     * @return _feePaid total fees paid during opening\n     */\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = openFees;\n        unchecked {\n            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;\n        }\n        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _referrer,\n                    _positionSize\n                    * _fees.referralFees // get referral fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;\n        }\n        if (_isBot) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _positionSize\n                    * _fees.botFees // get bot fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.botFees;\n        } else {\n            _fees.botFees = 0;\n        }\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n            emit FeesDistributed(\n                _tigAsset,\n                _daoFeesPaid,\n                _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n                _positionSize * _fees.botFees / DIVISION_CONSTANT,\n                _referrer\n            );\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev handle fees distribution for closing\n     * @param _asset asset id\n     * @param _payout payout to trader before fees\n     * @param _tigAsset margin asset\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _isBot false if closed via market order\n     * @return payout_ payout to trader after fees\n     */\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = closeFees;\n        uint _daoFeesPaid;\n        uint _burnFeesPaid;\n        uint _referralFeesPaid;\n        unchecked {\n            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n        }\n        uint _botFeesPaid;\n        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            }\n            IStable(_tigAsset).mintFor(\n                _referrer,\n                _referralFeesPaid\n            );\n             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;\n        }\n        if (_isBot) {\n            unchecked {\n                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _botFeesPaid\n                );\n            }\n            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;\n        }\n        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);\n        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n\n    /**\n     * @dev update funding rates after open interest changes\n     * @param _asset asset id\n     * @param _tigAsset tigAsset used for OI\n     */\n    function _updateFunding(uint256 _asset, address _tigAsset) internal {\n        position.updateFunding(\n            _asset,\n            _tigAsset,\n            pairsContract.idToOi(_asset, _tigAsset).longOi,\n            pairsContract.idToOi(_asset, _tigAsset).shortOi,\n            pairsContract.idToAsset(_asset).baseFundingRate,\n            vaultFundingPercent\n        );\n    }\n\n    /**\n     * @dev check that SL price is valid compared to market price\n     * @param _sl SL price\n     * @param _direction long/short\n     * @param _price market price\n     */\n    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {\n        if (_direction) {\n            if (_sl > _price) revert(\"3\"); //BadStopLoss\n        } else {\n            if (_sl < _price && _sl != 0) revert(\"3\"); //BadStopLoss\n        }\n    }\n\n    /**\n     * @dev check that trader address owns the position\n     * @param _id position id\n     * @param _trader trader address\n     */\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n\n    /**\n     * @notice Check that sufficient time has passed between opening and closing\n     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the \"valid signature pool\".\n     * @param _id position id\n     * @param _type true for opening, false for closing\n     */\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n    /**\n     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault\n     * @param _stableVault StableVault address\n     * @param _token Margin asset token address\n     */\n    function _checkVault(address _stableVault, address _token) internal view {\n        require(allowedVault[_stableVault], \"Unapproved stablevault\");\n        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n    }\n\n    /**\n     * @dev Check that the trader has approved the proxy address to trade for it\n     * @param _trader Trader address\n     */\n    function _validateProxy(address _trader) internal view {\n        if (_trader != _msgSender()) {\n            Proxy memory _proxy = proxyApprovals[_trader];\n            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n        }\n    }\n\n    // ===== GOVERNANCE-ONLY =====\n\n    /**\n     * @dev Sets block delay between opening and closing\n     * @notice In blocks not seconds\n     * @param _blockDelay delay amount\n     */\n    function setBlockDelay(\n        uint _blockDelay\n    )\n        external\n        onlyOwner\n    {\n        blockDelay = _blockDelay;\n    }\n\n    /**\n     * @dev Whitelists a stablevault contract address\n     * @param _stableVault StableVault address\n     * @param _bool true if allowed\n     */\n    function setAllowedVault(\n        address _stableVault,\n        bool _bool\n    )\n        external\n        onlyOwner\n    {\n        allowedVault[_stableVault] = _bool;\n    }\n\n    /**\n     * @dev Sets max payout % compared to margin\n     * @param _maxWinPercent payout %\n     */\n    function setMaxWinPercent(\n        uint _maxWinPercent\n    )\n        external\n        onlyOwner\n    {\n        maxWinPercent = _maxWinPercent;\n    }\n\n    /**\n     * @dev Sets executable price range for limit orders\n     * @param _range price range in %\n     */\n    function setLimitOrderPriceRange(uint _range) external onlyOwner {\n        limitOrderPriceRange = _range;\n    }\n\n    /**\n     * @dev Sets the fees for the trading protocol\n     * @param _open True if open fees are being set\n     * @param _daoFees Fees distributed to the DAO\n     * @param _burnFees Fees which get burned\n     * @param _referralFees Fees given to referrers\n     * @param _botFees Fees given to bots that execute limit orders\n     * @param _percent Percent of earned funding fees going to StableVault\n     */\n    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {\n        unchecked {\n            require(_daoFees >= _botFees+_referralFees*2);\n            if (_open) {\n                openFees.daoFees = _daoFees;\n                openFees.burnFees = _burnFees;\n                openFees.referralFees = _referralFees;\n                openFees.botFees = _botFees;\n            } else {\n                closeFees.daoFees = _daoFees;\n                closeFees.burnFees = _burnFees;\n                closeFees.referralFees = _referralFees;\n                closeFees.botFees = _botFees;                \n            }\n            require(_percent <= DIVISION_CONSTANT);\n            vaultFundingPercent = _percent;\n        }\n    }\n\n    /**\n     * @dev Sets the extension contract address for trading\n     * @param _ext extension contract address\n     */\n    function setTradingExtension(\n        address _ext\n    ) external onlyOwner() {\n        tradingExtension = ITradingExtension(_ext);\n    }\n\n    // ===== EVENTS =====\n\n    event PositionOpened(\n        TradeInfo _tradeInfo,\n        uint _orderType,\n        uint _price,\n        uint _id,\n        address _trader,\n        uint _marginAfterFees\n    );\n\n    event PositionClosed(\n        uint _id,\n        uint _closePrice,\n        uint _percent,\n        uint _payout,\n        address _trader,\n        address _executor\n    );\n\n    event PositionLiquidated(\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event LimitOrderExecuted(\n        uint _asset,\n        bool _direction,\n        uint _openPrice,\n        uint _lev,\n        uint _margin,\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event UpdateTPSL(\n        uint _id,\n        bool _isTp,\n        uint _price,\n        address _trader\n    );\n\n    event LimitCancelled(\n        uint _id,\n        address _trader\n    );\n\n    event MarginModified(\n        uint _id,\n        uint _newMargin,\n        uint _newLeverage,\n        bool _isMarginAdded,\n        address _trader\n    );\n\n    event AddToPosition(\n        uint _id,\n        uint _newMargin,\n        uint _newPrice,\n        address _trader\n    );\n\n    event FeesDistributed(\n        address _tigAsset,\n        uint _daoFees,\n        uint _burnFees,\n        uint _refFees,\n        uint _botFees,\n        address _referrer\n    );\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IStableVault.sol\";\n\ninterface IERC20Mintable is IERC20 {\n    function mintFor(address, uint256) external;\n    function burnFrom(address, uint256) external;\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract StableVault is MetaContext, IStableVault {\n\n    mapping(address => bool) public allowed;\n    mapping(address => uint) private tokenIndex;\n    address[] public tokens;\n\n    address public immutable stable;\n\n    constructor(address _stable) {\n        stable = _stable;\n    }\n\n    /**\n    * @notice deposit an allowed token and receive tigAsset\n    * @param _token address of the allowed token\n    * @param _amount amount of _token\n    */\n    function deposit(address _token, uint256 _amount) public {\n        require(allowed[_token], \"Token not listed\");\n        IERC20(_token).transferFrom(_msgSender(), address(this), _amount);\n        IERC20Mintable(stable).mintFor(\n            _msgSender(),\n            _amount*(10**(18-IERC20Mintable(_token).decimals()))\n        );\n    }\n\n    function depositWithPermit(address _token, uint256 _amount, uint256 _deadline, bool _permitMax, uint8 v, bytes32 r, bytes32 s) external {\n        uint _toAllow = _amount;\n        if (_permitMax) _toAllow = type(uint).max;\n        ERC20Permit(_token).permit(_msgSender(), address(this), _toAllow, _deadline, v, r, s);\n        deposit(_token, _amount);\n    }\n\n    /**\n    * @notice swap tigAsset to _token\n    * @param _token address of the token to receive\n    * @param _amount amount of _token\n    */\n    function withdraw(address _token, uint256 _amount) external returns (uint256 _output) {\n        IERC20Mintable(stable).burnFrom(_msgSender(), _amount);\n        _output = _amount/10**(18-IERC20Mintable(_token).decimals());\n        IERC20(_token).transfer(\n            _msgSender(),\n            _output\n        );\n    }\n\n    /**\n    * @notice allow a token to be used in vault\n    * @param _token address of the token\n    */\n    function listToken(address _token) external onlyOwner {\n        require(!allowed[_token], \"Already added\");\n        tokenIndex[_token] = tokens.length;\n        tokens.push(_token);\n        allowed[_token] = true;\n    }\n\n    /**\n    * @notice stop a token from being allowed in vault\n    * @param _token address of the token\n    */\n    function delistToken(address _token) external onlyOwner {\n        require(allowed[_token], \"Not added\");\n        tokenIndex[tokens[tokens.length-1]] = tokenIndex[_token];\n        tokens[tokenIndex[_token]] = tokens[tokens.length-1];\n        delete tokenIndex[_token];\n        tokens.pop();\n        allowed[_token] = false;\n    }\n}\n\n",
        "CodeNames": [
            "PairsContract.sol",
            "StableToken.sol",
            "Trading.sol",
            "StableVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Trading.sol, StableVault.sol, StableToken.sol, PairsContract.sol",
                "Type": "Centralization risks",
                "Description": "The owner can freeze withdraws and use timelock to steal all funds. The project heavily relies on nodes/oracles, which are EOAs that sign the current price. The owner has a few ways to drain all funds.",
                "Repair": "Add functionality to withdraw funds at the last given price in case no signed data is given for a certain period"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/ITrading.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./interfaces/IReferrals.sol\";\nimport \"./interfaces/IPosition.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./interfaces/IStableVault.sol\";\nimport \"./utils/TradingLibrary.sol\";\n\ninterface ITradingExtension {\n    function getVerifiedPrice(\n        uint _asset,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        uint _withSpreadIsLong\n    ) external returns(uint256 _price, uint256 _spread);\n    function getRef(\n        address _trader\n    ) external pure returns(address);\n    function _setReferral(\n        bytes32 _referral,\n        address _trader\n    ) external;\n    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;\n    function isPaused() external view returns(bool);\n    function minPos(address) external view returns(uint);\n    function modifyLongOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function modifyShortOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function paused() external returns(bool);\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external returns(uint _limitPrice, address _tigAsset);\n    function _checkGas() external view;\n    function _closePosition(\n        uint _id,\n        uint _price,\n        uint _percent\n    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);\n}\n\ninterface IStable is IERC20 {\n    function burnFrom(address account, uint amount) external;\n    function mintFor(address account, uint amount) external;\n}\n\ninterface ExtendedIERC20 is IERC20 {\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract Trading is MetaContext, ITrading {\n\n    error LimitNotSet(); //7\n    error NotLiquidatable();\n    error TradingPaused();\n    error BadDeposit();\n    error BadWithdraw();\n    error ValueNotEqualToMargin();\n    error BadLeverage();\n    error NotMargin();\n    error NotAllowedPair();\n    error BelowMinPositionSize();\n    error BadClosePercent();\n    error NoPrice();\n    error LiqThreshold();\n\n    uint constant private DIVISION_CONSTANT = 1e10; // 100%\n    uint private constant liqPercent = 9e9; // 90%\n\n    struct Fees {\n        uint daoFees;\n        uint burnFees;\n        uint referralFees;\n        uint botFees;\n    }\n    Fees public openFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    Fees public closeFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    uint public limitOrderPriceRange = 1e8; // 1%\n\n    uint public maxWinPercent;\n    uint public vaultFundingPercent;\n\n    IPairsContract private pairsContract;\n    IPosition private position;\n    IGovNFT private gov;\n    ITradingExtension private tradingExtension;\n\n    struct Delay {\n        uint delay; // Block number where delay ends\n        bool actionType; // True for open, False for close\n    }\n    mapping(uint => Delay) public blockDelayPassed; // id => Delay\n    uint public blockDelay;\n    mapping(uint => uint) public limitDelay; // id => block.timestamp\n\n    mapping(address => bool) public allowedVault;\n\n    struct Proxy {\n        address proxy;\n        uint256 time;\n    }\n\n    mapping(address => Proxy) public proxyApprovals;\n\n    constructor(\n        address _position,\n        address _gov,\n        address _pairsContract\n    )\n    {\n        position = IPosition(_position);\n        gov = IGovNFT(_gov);\n        pairsContract = IPairsContract(_pairsContract);\n    }\n\n    // ===== END-USER FUNCTIONS =====\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateMarketOrder(\n        TradeInfo calldata _tradeInfo,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(position.getCount(), true);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\n        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        uint256 _isLong = _tradeInfo.direction ? 1 : 2;\n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);\n        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(\n            _trader,\n            _marginAfterFees,\n            _tradeInfo.leverage,\n            _tradeInfo.asset,\n            _tradeInfo.direction,\n            _price,\n            _tradeInfo.tpPrice,\n            _tradeInfo.slPrice,\n            0,\n            _tigAsset\n        );\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        unchecked {\n            if (_tradeInfo.direction) {\n                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            }\n        }\n        _updateFunding(_tradeInfo.asset, _tigAsset);\n        position.mint(\n            _mintTrade\n        );\n        unchecked {\n            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n        }   \n    }\n\n    /**\n     * @dev initiate closing position\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed in BP\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _outputToken Token received upon closing trade\n     * @param _trader address the trade is initiated for\n     */\n    function initiateCloseOrder(\n        uint _id,\n        uint _percent,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _outputToken,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(_id, false);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit        \n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n\n        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();\n        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); \n    }\n\n    /**\n     * @param _id position id\n     * @param _addMargin margin amount used to add to the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _marginAsset Token being used to add to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n        position.setAccInterest(_id);\n        unchecked {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);\n            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     \n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _addMargin -= _fee;\n            uint _newMargin = _trade.margin + _addMargin;\n            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\n            position.addToPosition(\n                _trade.id,\n                _newMargin,\n                _newPrice\n            );\n            \n            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);\n        }\n    }\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _orderType type of limit order used to open the position\n     * @param _price limit price\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateLimitOrder(\n        TradeInfo calldata _tradeInfo,\n        uint256 _orderType, // 1 limit, 2 stop\n        uint256 _price,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        if (_orderType == 0) revert(\"5\");\n        if (_price == 0) revert NoPrice();\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        uint256 _id = position.getCount();\n        position.mint(\n            IPosition.MintTrade(\n                _trader,\n                _tradeInfo.margin,\n                _tradeInfo.leverage,\n                _tradeInfo.asset,\n                _tradeInfo.direction,\n                _price,\n                _tradeInfo.tpPrice,\n                _tradeInfo.slPrice,\n                _orderType,\n                _tigAsset\n            )\n        );\n        limitDelay[_id] = block.timestamp + 4;\n        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);\n    }\n\n    /**\n     * @param _id position ID\n     * @param _trader address the trade is initiated for\n     */\n    function cancelLimitOrder(\n        uint256 _id,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType == 0) revert();\n        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);\n        position.burn(_id);\n        emit LimitCancelled(_id, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _marginAsset Token being used to add to the position\n     * @param _stableVault StableVault address\n     * @param _addMargin margin amount being added to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addMargin(\n        uint256 _id,\n        address _marginAsset,\n        address _stableVault,\n        uint256 _addMargin,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _marginAsset);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);\n        unchecked {\n            uint256 _newMargin = _trade.margin + _addMargin;\n            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n            if (_newLeverage < asset.minLeverage) revert(\"!lev\");\n            position.modifyMargin(_id, _newMargin, _newLeverage);\n            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);\n        }\n    }\n\n    /**\n     * @param _id position id\n     * @param _stableVault StableVault address\n     * @param _outputToken token the trader will receive\n     * @param _removeMargin margin amount being removed from the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function removeMargin(\n        uint256 _id,\n        address _stableVault,\n        address _outputToken,\n        uint256 _removeMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        uint256 _newMargin = _trade.margin - _removeMargin;\n        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n        if (_newLeverage > asset.maxLeverage) revert(\"!lev\");\n        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);\n        unchecked {\n            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();\n        }\n        position.modifyMargin(_trade.id, _newMargin, _newLeverage);\n        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);\n        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);\n    }\n\n    /**\n     * @param _type true for TP, false for SL\n     * @param _id position id\n     * @param _limitPrice TP/SL trigger price\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function updateTpSl(\n        bool _type,\n        uint _id,\n        uint _limitPrice,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        if (_type) {\n            position.modifyTp(_id, _limitPrice);\n        } else {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            _checkSl(_limitPrice, _trade.direction, _price);\n            position.modifySl(_id, _limitPrice);\n        }\n        emit UpdateTPSL(_id, _type, _limitPrice, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function executeLimitOrder(\n        uint _id, \n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) \n        external\n    {\n        unchecked {\n            _checkDelay(_id, true);\n            tradingExtension._checkGas();\n            if (tradingExtension.paused()) revert TradingPaused();\n            require(block.timestamp >= limitDelay[_id]);\n            IPosition.Trade memory trade = position.trades(_id);\n            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n            if (trade.orderType == 0) revert(\"5\");\n            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n            if (trade.direction && trade.orderType == 1) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 1) {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 2) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } else {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } \n            if(trade.direction) {\n                trade.price += trade.price * _spread / DIVISION_CONSTANT;\n            } else {\n                trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n            }\n            if (trade.direction) {\n                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            } else {\n                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            }\n            _updateFunding(trade.asset, trade.tigAsset);\n            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);\n            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @notice liquidate position\n     * @param _id id of the position NFT\n     * @param _priceData verifiable off-chain data\n     * @param _signature node signature\n     */\n    function liquidatePosition(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        unchecked {\n            tradingExtension._checkGas();\n            IPosition.Trade memory _trade = position.trades(_id);\n            if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);\n            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;\n            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);\n            position.burn(_id);\n            emit PositionLiquidated(_id, _trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @dev close position at a pre-set price\n     * @param _id id of the position NFT\n     * @param _tp true if take profit\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    /**\n     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.\n     * @param _proxy proxy wallet address\n     * @param _timestamp end timestamp of approval period\n     */\n    function approveProxy(address _proxy, uint256 _timestamp) external payable {\n        proxyApprovals[_msgSender()] = Proxy(\n            _proxy,\n            _timestamp\n        );\n        payable(_proxy).transfer(msg.value);\n    }\n\n    // ===== INTERNAL FUNCTIONS =====\n\n    /**\n     * @dev close the initiated position.\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed\n     * @param _price pair price\n     * @param _stableVault StableVault address\n     * @param _outputToken Token that trader will receive\n     * @param _isBot false if closed via market order\n     */\n    function _closePosition(\n        uint _id,\n        uint _percent,\n        uint _price,\n        address _stableVault,\n        address _outputToken,\n        bool _isBot\n    )\n        internal\n    {\n        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);\n        position.setAccInterest(_id);\n        _updateFunding(_trade.asset, _trade.tigAsset);\n        if (_percent < DIVISION_CONSTANT) {\n            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n            position.reducePosition(_id, _percent);\n        } else {\n            position.burn(_id);\n        }\n        uint256 _toMint;\n        if (_payout > 0) {\n            unchecked {\n                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n                }\n            }\n            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);\n        }\n        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n    }\n\n    /**\n     * @dev handle stablevault deposits for different trading functions\n     * @param _tigAsset tigAsset token address\n     * @param _marginAsset token being deposited into stablevault\n     * @param _margin amount being deposited\n     * @param _stableVault StableVault address\n     * @param _permitData Data for approval via permit\n     * @param _trader Trader address to take tokens from\n     */\n    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {\n        IStable tigAsset = IStable(_tigAsset);\n        if (_tigAsset != _marginAsset) {\n            if (_permitData.usePermit) {\n                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);\n            }\n            uint256 _balBefore = tigAsset.balanceOf(address(this));\n            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();\n            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));\n        } else {\n            tigAsset.burnFrom(_trader, _margin);\n        }        \n    }\n\n    /**\n     * @dev handle stablevault withdrawals for different trading functions\n     * @param _trade Position info\n     * @param _stableVault StableVault address\n     * @param _outputToken Output token address\n     * @param _toMint Amount of tigAsset minted to be used for withdrawal\n     */\n    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {\n        IStable(_trade.tigAsset).mintFor(address(this), _toMint);\n        if (_outputToken == _trade.tigAsset) {\n            IERC20(_outputToken).transfer(_trade.trader, _toMint);\n        } else {\n            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n            IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n        }        \n    }\n\n    /**\n     * @dev handle fees distribution for opening\n     * @param _asset asset id\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _tigAsset tigAsset address\n     * @param _isBot false if opened via market order\n     * @return _feePaid total fees paid during opening\n     */\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = openFees;\n        unchecked {\n            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;\n        }\n        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _referrer,\n                    _positionSize\n                    * _fees.referralFees // get referral fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;\n        }\n        if (_isBot) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _positionSize\n                    * _fees.botFees // get bot fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.botFees;\n        } else {\n            _fees.botFees = 0;\n        }\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n            emit FeesDistributed(\n                _tigAsset,\n                _daoFeesPaid,\n                _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n                _positionSize * _fees.botFees / DIVISION_CONSTANT,\n                _referrer\n            );\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev handle fees distribution for closing\n     * @param _asset asset id\n     * @param _payout payout to trader before fees\n     * @param _tigAsset margin asset\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _isBot false if closed via market order\n     * @return payout_ payout to trader after fees\n     */\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = closeFees;\n        uint _daoFeesPaid;\n        uint _burnFeesPaid;\n        uint _referralFeesPaid;\n        unchecked {\n            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n        }\n        uint _botFeesPaid;\n        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            }\n            IStable(_tigAsset).mintFor(\n                _referrer,\n                _referralFeesPaid\n            );\n             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;\n        }\n        if (_isBot) {\n            unchecked {\n                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _botFeesPaid\n                );\n            }\n            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;\n        }\n        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);\n        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n\n    /**\n     * @dev update funding rates after open interest changes\n     * @param _asset asset id\n     * @param _tigAsset tigAsset used for OI\n     */\n    function _updateFunding(uint256 _asset, address _tigAsset) internal {\n        position.updateFunding(\n            _asset,\n            _tigAsset,\n            pairsContract.idToOi(_asset, _tigAsset).longOi,\n            pairsContract.idToOi(_asset, _tigAsset).shortOi,\n            pairsContract.idToAsset(_asset).baseFundingRate,\n            vaultFundingPercent\n        );\n    }\n\n    /**\n     * @dev check that SL price is valid compared to market price\n     * @param _sl SL price\n     * @param _direction long/short\n     * @param _price market price\n     */\n    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {\n        if (_direction) {\n            if (_sl > _price) revert(\"3\"); //BadStopLoss\n        } else {\n            if (_sl < _price && _sl != 0) revert(\"3\"); //BadStopLoss\n        }\n    }\n\n    /**\n     * @dev check that trader address owns the position\n     * @param _id position id\n     * @param _trader trader address\n     */\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n\n    /**\n     * @notice Check that sufficient time has passed between opening and closing\n     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the \"valid signature pool\".\n     * @param _id position id\n     * @param _type true for opening, false for closing\n     */\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n    /**\n     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault\n     * @param _stableVault StableVault address\n     * @param _token Margin asset token address\n     */\n    function _checkVault(address _stableVault, address _token) internal view {\n        require(allowedVault[_stableVault], \"Unapproved stablevault\");\n        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n    }\n\n    /**\n     * @dev Check that the trader has approved the proxy address to trade for it\n     * @param _trader Trader address\n     */\n    function _validateProxy(address _trader) internal view {\n        if (_trader != _msgSender()) {\n            Proxy memory _proxy = proxyApprovals[_trader];\n            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n        }\n    }\n\n    // ===== GOVERNANCE-ONLY =====\n\n    /**\n     * @dev Sets block delay between opening and closing\n     * @notice In blocks not seconds\n     * @param _blockDelay delay amount\n     */\n    function setBlockDelay(\n        uint _blockDelay\n    )\n        external\n        onlyOwner\n    {\n        blockDelay = _blockDelay;\n    }\n\n    /**\n     * @dev Whitelists a stablevault contract address\n     * @param _stableVault StableVault address\n     * @param _bool true if allowed\n     */\n    function setAllowedVault(\n        address _stableVault,\n        bool _bool\n    )\n        external\n        onlyOwner\n    {\n        allowedVault[_stableVault] = _bool;\n    }\n\n    /**\n     * @dev Sets max payout % compared to margin\n     * @param _maxWinPercent payout %\n     */\n    function setMaxWinPercent(\n        uint _maxWinPercent\n    )\n        external\n        onlyOwner\n    {\n        maxWinPercent = _maxWinPercent;\n    }\n\n    /**\n     * @dev Sets executable price range for limit orders\n     * @param _range price range in %\n     */\n    function setLimitOrderPriceRange(uint _range) external onlyOwner {\n        limitOrderPriceRange = _range;\n    }\n\n    /**\n     * @dev Sets the fees for the trading protocol\n     * @param _open True if open fees are being set\n     * @param _daoFees Fees distributed to the DAO\n     * @param _burnFees Fees which get burned\n     * @param _referralFees Fees given to referrers\n     * @param _botFees Fees given to bots that execute limit orders\n     * @param _percent Percent of earned funding fees going to StableVault\n     */\n    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {\n        unchecked {\n            require(_daoFees >= _botFees+_referralFees*2);\n            if (_open) {\n                openFees.daoFees = _daoFees;\n                openFees.burnFees = _burnFees;\n                openFees.referralFees = _referralFees;\n                openFees.botFees = _botFees;\n            } else {\n                closeFees.daoFees = _daoFees;\n                closeFees.burnFees = _burnFees;\n                closeFees.referralFees = _referralFees;\n                closeFees.botFees = _botFees;                \n            }\n            require(_percent <= DIVISION_CONSTANT);\n            vaultFundingPercent = _percent;\n        }\n    }\n\n    /**\n     * @dev Sets the extension contract address for trading\n     * @param _ext extension contract address\n     */\n    function setTradingExtension(\n        address _ext\n    ) external onlyOwner() {\n        tradingExtension = ITradingExtension(_ext);\n    }\n\n    // ===== EVENTS =====\n\n    event PositionOpened(\n        TradeInfo _tradeInfo,\n        uint _orderType,\n        uint _price,\n        uint _id,\n        address _trader,\n        uint _marginAfterFees\n    );\n\n    event PositionClosed(\n        uint _id,\n        uint _closePrice,\n        uint _percent,\n        uint _payout,\n        address _trader,\n        address _executor\n    );\n\n    event PositionLiquidated(\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event LimitOrderExecuted(\n        uint _asset,\n        bool _direction,\n        uint _openPrice,\n        uint _lev,\n        uint _margin,\n        uint _id,\n        address _trader,\n        address _executor\n    );\n\n    event UpdateTPSL(\n        uint _id,\n        bool _isTp,\n        uint _price,\n        address _trader\n    );\n\n    event LimitCancelled(\n        uint _id,\n        address _trader\n    );\n\n    event MarginModified(\n        uint _id,\n        uint _newMargin,\n        uint _newLeverage,\n        bool _isMarginAdded,\n        address _trader\n    );\n\n    event AddToPosition(\n        uint _id,\n        uint _newMargin,\n        uint _newPrice,\n        address _trader\n    );\n\n    event FeesDistributed(\n        address _tigAsset,\n        uint _daoFees,\n        uint _burnFees,\n        uint _refFees,\n        uint _botFees,\n        address _referrer\n    );\n}\n\n\n",
        "CodeNames": [
            "Trading.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Trading.sol",
                "Type": "Token decimal underflow",
                "Description": "A deposit or withdrawal of tokens with decimals higher than 18 will always revert.",
                "Repair": "Update calculations in the contract to account for tokens with decimals higher than 18"
            },
            {
                "Location": "Trading.sol",
                "Type": "Race Condition",
                "Description": "Traders will not be able to initiate a market order, add margin, add to position, or initiate limit order if USDT is set as the margin asset and protocol is deployed on Ethereum due to the _handleDeposit function calling the USDT margin asset approve function with type(uint).max, causing the transaction to revert from the second time approve is called.",
                "Repair": "Keep a record if allowance was already set on an address and create an external function that can be called by the owner to approve the a token address"
            },
            {
                "Location": "Trading.addToPosition function",
                "Type": "Incorrect computation",
                "Description": "When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of tigAsset.",
                "Repair": "Call the _handleDeposit function with the correct margin value that the user has input on and is supposed to pay, instead of using _addMargin _fee as the third parameter to _handleDeposit function."
            },
            {
                "Location": "_closePosition() function in Trading.sol",
                "Type": "Bypassing limit vulnerability",
                "Description": "Users can bypass the maxWinPercent limit using a partial closing.",
                "Repair": "Check the maxWinPercent between the partial payout and partial margin"
            },
            {
                "Location": "addToPosition() function of Trading.sol",
                "Type": "Incorrect calculation",
                "Description": "The formula used for calculating _newPrice in addToPosition() function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.",
                "Repair": "Replace the formula in line 734 with the corrected formula"
            },
            {
                "Location": "Line 734 of Trading.sol",
                "Type": "Incorrect fee calculation",
                "Description": "Formula for fee paid in Line 734 is incorrect leading to incorrect margin calculations.",
                "Repair": "Replace the formula in line 734 with the corrected formula"
            },
            {
                "Location": "Trading.limitClose() function",
                "Type": "Riskless trades due to delay check",
                "Description": "The position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking in limitClose() should be modified to also consider whether the position is below the stop-loss.",
                "Repair": "Modify delay checking in limitClose() function to also consider whether the position is below the stop-loss"
            },
            {
                "Location": "Trading.initiateCloseOrder",
                "Type": "Approved operators cannot call certain functions",
                "Description": "Functions that accept Position token in Trading are checking that the caller is owner of token using _checkOwner function. This function doesn't allow approved operators of token's owner to pass the check. As a result, functions are not possible to call for them on behalf of owner.",
                "Repair": "Allow operators of token's owner to call functions on behalf of owner."
            },
            {
                "Location": "Trading._handleOpenFees function",
                "Type": "Lack of Approval",
                "Description": "Governance NFT holder, whose NFT was minted before Trading._handleOpenFees function is called, can lose deserved rewards after Trading._handleOpenFees function is called due to lack of approval for spending any of the Trading contract's _tigAsset balance.",
                "Repair": "Add IStable(_tigAsset).approve(address(gov), type(uint).max) in the _handleOpenFees function"
            },
            {
                "Location": "Trading.executeLimitOrder",
                "Type": "Validation Error",
                "Description": "StopLoss/TakeProfit is not validated again for the new price in Trading.executeLimitOrder, leading to unexpected losses for users.",
                "Repair": "Validate StopLoss/TakeProfit for the new price in Trading.executeLimitOrder"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBondNFT.sol\";\nimport \"./interfaces/IGovNFT.sol\";\n\ncontract Lock is Ownable{\n\n    uint public constant minPeriod = 7;\n    uint public constant maxPeriod = 365;\n\n    IBondNFT public immutable bondNFT;\n    IGovNFT public immutable govNFT;\n\n    mapping(address => bool) public allowedAssets;\n    mapping(address => uint) public totalLocked;\n\n    constructor(\n        address _bondNFTAddress,\n        address _govNFT\n    ) {\n        bondNFT = IBondNFT(_bondNFTAddress);\n        govNFT = IGovNFT(_govNFT);\n    }\n\n    /**\n     * @notice Claim pending rewards from a bond\n     * @param _id Bond NFT id\n     * @return address claimed tigAsset address\n     */\n    function claim(\n        uint256 _id\n    ) public returns (address) {\n        claimGovFees();\n        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);\n        IERC20(_tigAsset).transfer(msg.sender, _amount);\n        return _tigAsset;\n    }\n\n    /**\n     * @notice Claim pending rewards left over from a bond transfer\n     * @param _tigAsset token address being claimed\n     */\n    function claimDebt(\n        address _tigAsset\n    ) external {\n        claimGovFees();\n        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);\n        IERC20(_tigAsset).transfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Lock up tokens to create a bond\n     * @param _asset tigAsset being locked\n     * @param _amount tigAsset amount\n     * @param _period number of days to be locked for\n     */\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Reset the lock time and extend the period and/or token amount\n     * @param _id Bond id being extended\n     * @param _amount tigAsset amount being added\n     * @param _period number of days being added\n     */\n    function extendLock(\n        uint _id,\n        uint _amount,\n        uint _period\n    ) public {\n        address _asset = claim(_id);\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Release the bond once it's expired\n     * @param _id Bond id being released\n     */\n    function release(\n        uint _id\n    ) public {\n        claimGovFees();\n        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);\n        totalLocked[asset] -= lockAmount;\n        IERC20(asset).transfer(_owner, amount);\n    }\n\n    /**\n     * @notice Claim rewards from gov nfts and distribute them to bonds\n     */\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n\n    /**\n     * @notice Whitelist an asset\n     * @param _tigAsset tigAsset token address\n     * @param _isAllowed set tigAsset as allowed\n     */\n    function editAsset(\n        address _tigAsset,\n        bool _isAllowed\n    ) external onlyOwner() {\n        allowedAssets[_tigAsset] = _isAllowed;\n    }\n\n    /**\n     * @notice Owner can retreive Gov NFTs\n     * @param _ids array of gov nft ids\n     */\n    function sendNFTs(\n        uint[] memory _ids\n    ) external onlyOwner() {\n        govNFT.safeTransferMany(msg.sender, _ids);\n    }\n}\n\n\n",
        "CodeNames": [
            "Lock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Lock.sol",
                "Type": "Accounting",
                "Description": "Assets deposited using Lock.extendLock can never be released again because reducing totalLocked[_asset] will cause a revert due to underflow, resulting in the amount of assets deposited using Lock.extendLock being lost.",
                "Repair": "Add totalLocked[_asset] += amount to the Lock.extendLock function"
            },
            {
                "Location": "Lock.sol: claimGovFees function",
                "Type": "assets stuck in contract",
                "Description": "When calling Lock.claimGovFees, assets that are set to be not allowed or assets that don't have any shares yet in the BondNFT contract will cause a silent failure in BondNFT.distribute. The funds from the GovNFT contract will get transferred into the Lock contract and then will be stuck there. They cannot be recovered.",
                "Repair": "Allow the owner to rescue stuck tokens from the Lock contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./utils/ExcessivelySafeCall.sol\";\n\ncontract GovNFT is ERC721Enumerable, ILayerZeroReceiver, MetaContext, IGovNFT {\n    using ExcessivelySafeCall for address;\n    \n    uint256 private counter = 1;\n    uint256 private constant MAX = 10000;\n    uint256 public gas = 150000;\n    string public baseURI;\n    uint256 public maxBridge = 20;\n    ILayerZeroEndpoint public endpoint;\n\n    mapping(uint16 => mapping(address => bool)) public isTrustedAddress;\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n    event ReceiveNFT(\n        uint16 _srcChainId,\n        address _from,\n        uint256[] _tokenId\n    );\n\n    constructor(\n        address _endpoint,\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        baseURI = _setBaseURI;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function _mint(address to, uint256 tokenId) internal override {\n        require(counter <= MAX, \"Exceeds supply\");\n        counter += 1;\n        for (uint i=0; i<assetsLength(); i++) {\n            userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n        }\n        super._mint(to, tokenId);\n    }\n\n    /**\n     * @dev should only be called by layer zero\n     * @param to the address to receive the bridged NFTs\n     * @param tokenId the NFT id\n     */\n    function _bridgeMint(address to, uint256 tokenId) public {\n        require(msg.sender == address(this) || _msgSender() == owner(), \"NotBridge\");\n        require(tokenId <= 10000, \"BadID\");\n        for (uint i=0; i<assetsLength(); i++) {\n            userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n        }\n        super._mint(to, tokenId);\n    }\n\n    /**\n    * @notice updates userDebt \n    */\n    function _burn(uint256 tokenId) internal override {\n        address owner = ownerOf(tokenId);\n        for (uint i=0; i<assetsLength(); i++) {\n            userDebt[owner][assets[i]] += accRewardsPerNFT[assets[i]];\n            userDebt[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);\n            userPaid[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);            \n        }\n        super._burn(tokenId);\n    }\n\n    /**\n    * @notice updates userDebt for both to and from\n    */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        require(ownerOf(tokenId) == from, \"!Owner\");\n        for (uint i=0; i<assetsLength(); i++) {\n            userDebt[from][assets[i]] += accRewardsPerNFT[assets[i]];\n            userDebt[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n            userPaid[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n            userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n        }\n        super._transfer(from, to, tokenId);\n    }\n\n    function mintMany(uint _amount) external onlyOwner {\n        for (uint i=0; i<_amount; i++) {\n            _mint(_msgSender(), counter);\n        }\n    }\n\n    function mint() external onlyOwner {\n        _mint(_msgSender(), counter);\n    }\n\n    function setTrustedAddress(uint16 _chainId, address _contract, bool _bool) external onlyOwner {\n        isTrustedAddress[_chainId][_contract] = _bool;\n    }\n\n    /**\n    * @notice used to bridge NFTs crosschain using layer zero\n    * @param _dstChainId the layer zero id of the dest chain\n    * @param _to receiving address on dest chain\n    * @param tokenId array of the ids of the NFTs to be bridged\n    */\n    function crossChain(\n        uint16 _dstChainId,\n        bytes memory _destination,\n        address _to,\n        uint256[] memory tokenId\n    ) public payable {\n        require(tokenId.length > 0, \"Not bridging\");\n        for (uint i=0; i<tokenId.length; i++) {\n            require(_msgSender() == ownerOf(tokenId[i]), \"Not the owner\");\n            // burn NFT\n            _burn(tokenId[i]);\n        }\n        address targetAddress;\n        assembly {\n            targetAddress := mload(add(_destination, 20))\n        }\n        require(isTrustedAddress[_dstChainId][targetAddress], \"!Trusted\");\n        bytes memory payload = abi.encode(_to, tokenId);\n        // encode adapterParams to specify more gas for the destination\n        uint16 version = 1;\n        uint256 _gas = 500_000 + gas*tokenId.length;\n        bytes memory adapterParams = abi.encodePacked(version, _gas);\n        (uint256 messageFee, ) = endpoint.estimateFees(\n            _dstChainId,\n            address(this),\n            payload,\n            false,\n            adapterParams\n        );\n        require(\n            msg.value >= messageFee,\n            \"Must send enough value to cover messageFee\"\n        );\n        endpoint.send{value: msg.value}(\n            _dstChainId,\n            _destination,\n            payload,\n            payable(_msgSender()),\n            address(0x0),\n            adapterParams\n        );\n    }\n\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public {\n        // only internal transaction\n        require(msg.sender == address(this), \"NonblockingLzApp: caller must be app\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64, bytes memory _payload) internal {\n        address fromAddress;\n        assembly {\n            fromAddress := mload(add(_srcAddress, 20))\n        }\n        require(isTrustedAddress[_srcChainId][fromAddress], \"!TrustedAddress\");\n        (address toAddress, uint256[] memory tokenId) = abi.decode(\n            _payload,\n            (address, uint256[])\n        );\n        // mint the tokens\n        for (uint i=0; i<tokenId.length; i++) {\n            _bridgeMint(toAddress, tokenId[i]);\n        }\n        emit ReceiveNFT(_srcChainId, toAddress, tokenId);\n    }\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n\n    // Endpoint.sol estimateFees() returns the fees for the message\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view returns (uint256 nativeFee, uint256 zroFee) {\n        return\n            endpoint.estimateFees(\n                _dstChainId,\n                _userApplication,\n                _payload,\n                _payInZRO,\n                _adapterParams\n            );\n    }\n\n    function setGas(uint _gas) external onlyOwner {\n        gas = _gas;\n    }\n\n    function setEndpoint(ILayerZeroEndpoint _endpoint) external onlyOwner {\n        require(address(_endpoint) != address(0), \"ZeroAddress\");\n        endpoint = _endpoint;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            _transfer(_msgSender(), _to, _ids[i]);\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            safeTransferFrom(_from, _to, _ids[i]);\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            approve(_to, _ids[i]);\n        }\n    }\n\n    // Rewards\n    address[] public assets;\n    mapping(address => bool) private _allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(address => mapping(address => uint256)) private userPaid;\n    mapping(address => mapping(address => uint256)) private userDebt;\n    mapping(address => uint256) private accRewardsPerNFT;\n\n    /**\n    * @notice claimable by anyone to claim pending rewards tokens\n    * @param _tigAsset reward token address\n    */\n    function claim(address _tigAsset) external {\n        address _msgsender = _msgSender();\n        uint256 amount = pending(_msgsender, _tigAsset);\n        userPaid[_msgsender][_tigAsset] += amount;\n        IERC20(_tigAsset).transfer(_msgsender, amount);\n    }\n\n    /**\n    * @notice add rewards for NFT holders\n    * @param _tigAsset reward token address\n    * @param _amount amount to be distributed\n    */\n    function distribute(address _tigAsset, uint _amount) external {\n        if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;\n        try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n            accRewardsPerNFT[_tigAsset] += _amount/totalSupply();\n        } catch {\n            return;\n        }\n    }\n\n    function pending(address user, address _tigAsset) public view returns (uint256) {\n        return userDebt[user][_tigAsset] + balanceOf(user)*accRewardsPerNFT[_tigAsset] - userPaid[user][_tigAsset]; \n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        _allowedAsset[_asset] = true;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        _allowedAsset[_asset] = _bool;\n    }\n\n    function setMaxBridge(uint256 _max) external onlyOwner {\n        maxBridge = _max;\n    }\n\n    function assetsLength() public view returns (uint256) {\n        return assets.length;\n    }\n\n    function allowedAsset(address _asset) external view returns (bool) {\n        return _allowedAsset[_asset];\n    }\n\n    function balanceIds(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}\n\n",
        "CodeNames": [
            "GovNFT.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GovNFT contract",
                "Type": "Minting multiple NFTs with the same token id",
                "Description": "Failure in endpoint can cause minting more than one NFT with the same token id in different chains.",
                "Repair": "Track the consumed messages, and add a consumed flag whenever the function lzReceive is called, because it will either immediately mint the NFT or add it to the failed messages to be minted later."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract Position is ERC721Enumerable, MetaContext, IPosition {\n\n    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) {\n        return ERC721.ownerOf(_id);\n    }\n\n    using Counters for Counters.Counter;\n    uint constant public DIVISION_CONSTANT = 1e10; // 100%\n\n    mapping(uint => mapping(address => uint)) public vaultFundingPercent;\n\n    mapping(address => bool) private _isMinter; // Trading contract should be minter\n    mapping(uint256 => Trade) private _trades; // NFT id to Trade\n\n    uint256[] private _openPositions;\n    mapping(uint256 => uint256) private _openPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _assetOpenPositions;\n    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset\n    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index\n\n    // Funding\n    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;\n    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n    mapping(uint256 => mapping(address => uint256)) private lastUpdate;\n    mapping(uint256 => int256) private initId;\n    mapping(uint256 => mapping(address => uint256)) private longOi;\n    mapping(uint256 => mapping(address => uint256)) private shortOi;\n\n    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; }\n    function trades(uint _id) public view returns (Trade memory) {\n        Trade memory _trade = _trades[_id];\n        _trade.trader = ownerOf(_id);\n        if (_trade.orderType > 0) return _trade;\n        \n        int256 _pendingFunding;\n        if (_trade.direction && longOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(longOi[_trade.asset][_trade.tigAsset]);\n            if (longOi[_trade.asset][_trade.tigAsset] > shortOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        } else if (shortOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(shortOi[_trade.asset][_trade.tigAsset]);\n            if (shortOi[_trade.asset][_trade.tigAsset] > longOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        }\n        _trade.accInterest += (int256(_trade.margin*_trade.leverage/1e18)*(accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]+_pendingFunding)/1e18)-initId[_id];\n        \n        return _trade;\n    }\n    function openPositions() public view returns (uint256[] memory) { return _openPositions; }\n    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; }\n    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; }\n    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; }\n    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; }\n    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; }\n\n    Counters.Counter private _tokenIds;\n    string public baseURI;\n\n    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n        _tokenIds.increment();\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    /**\n    * @notice Update funding rate after open interest change\n    * @dev only callable by minter\n    * @param _asset pair id\n    * @param _tigAsset tigAsset token address\n    * @param _longOi long open interest\n    * @param _shortOi short open interest\n    * @param _baseFundingRate base funding rate of a pair\n    * @param _vaultFundingPercent percent of earned funding going to the stablevault\n    */\n    function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {\n        if(longOi[_asset][_tigAsset] < shortOi[_asset][_tigAsset]) {\n            if (longOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][true] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n            accInterestPerOi[_asset][_tigAsset][false] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]);\n\n        } else if(longOi[_asset][_tigAsset] > shortOi[_asset][_tigAsset]) {\n            accInterestPerOi[_asset][_tigAsset][true] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]);\n            if (shortOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][false] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n        }\n        lastUpdate[_asset][_tigAsset] = block.timestamp;\n        int256 _oiDelta;\n        if (_longOi > _shortOi) {\n            _oiDelta = int256(_longOi)-int256(_shortOi);\n        } else {\n            _oiDelta = int256(_shortOi)-int256(_longOi);\n        }\n        \n        fundingDeltaPerSec[_asset][_tigAsset] = (_oiDelta*int256(_baseFundingRate)/int256(DIVISION_CONSTANT))/31536000;\n        longOi[_asset][_tigAsset] = _longOi;\n        shortOi[_asset][_tigAsset] = _shortOi;\n        vaultFundingPercent[_asset][_tigAsset] = _vaultFundingPercent;\n    }\n\n    /**\n    * @notice mint a new position nft\n    * @dev only callable by minter\n    * @param _mintTrade New trade params in struct\n    */\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);\n        if (_mintTrade.orderType > 0) {\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n\n    /**\n     * @param _id id of the position NFT\n     * @param _price price used for execution\n     * @param _newMargin margin after fees\n     */\n    function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {\n        Trade storage _trade = _trades[_id];\n        if (_trade.orderType == 0) {\n            return;\n        }\n        _trade.orderType = 0;\n        _trade.price = _price;\n        _trade.margin = _newMargin;\n        uint _asset = _trade.asset;\n        _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n        delete _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset].pop();\n\n        _openPositions.push(_id);\n        _openPositionsIndexes[_id] = _openPositions.length-1;\n        _assetOpenPositions[_asset].push(_id);\n        _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;\n\n        initId[_id] = accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]*int256(_trade.margin*_trade.leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice modifies margin and leverage\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newLeverage new leverage amount\n    */\n    function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].leverage = _newLeverage;\n    }\n\n    /**\n    * @notice modifies margin and entry price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newPrice new entry price\n    */\n    function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].price = _newPrice;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice Called before updateFunding for reducing position or adding to position, to store accumulated funding\n    * @dev only callable by minter\n    * @param _id position id\n    */\n    function setAccInterest(uint256 _id) external onlyMinter {\n        _trades[_id].accInterest = trades(_id).accInterest;\n    }\n\n    /**\n    * @notice Reduces position size by %\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _percent percent of a position being closed\n    */\n    function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {\n        _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);\n        _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice change a position tp price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _tpPrice tp price\n    */\n    function modifyTp(uint _id, uint _tpPrice) external onlyMinter {\n        _trades[_id].tpPrice = _tpPrice;\n    }\n\n    /**\n    * @notice change a position sl price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _slPrice sl price\n    */\n    function modifySl(uint _id, uint _slPrice) external onlyMinter {\n        _trades[_id].slPrice = _slPrice;\n    }\n\n    /**\n    * @dev Burns an NFT and it's data\n    * @param _id ID of the trade\n    */\n    function burn(uint _id) external onlyMinter {\n        _burn(_id);\n        uint _asset = _trades[_id].asset;\n        if (_trades[_id].orderType > 0) {\n            _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n            delete _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset].pop();            \n        } else {\n            _assetOpenPositionsIndexes[_asset][_assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1]] = _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];\n            delete _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset].pop();  \n\n            _openPositionsIndexes[_openPositions[_openPositions.length-1]] = _openPositionsIndexes[_id];\n            _openPositions[_openPositionsIndexes[_id]] = _openPositions[_openPositions.length-1];\n            delete _openPositionsIndexes[_id];\n            _openPositions.pop();              \n        }\n        delete _trades[_id];\n    }\n\n    function assetOpenPositionsLength(uint _asset) external view returns (uint256) {\n        return _assetOpenPositions[_asset].length;\n    }\n\n    function limitOrdersLength(uint _asset) external view returns (uint256) {\n        return _limitOrders[_asset].length;\n    }\n\n    function getCount() external view returns (uint) {\n        return _tokenIds.current();\n    }\n\n    function userTrades(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    function openPositionsSelection(uint _from, uint _to) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](_to-_from);\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = _openPositions[i+_from];\n        }\n        return _ids;\n    }\n\n    function setMinter(address _minter, bool _bool) external onlyOwner {\n        _isMinter[_minter] = _bool;\n    }    \n\n    modifier onlyMinter() {\n        require(_isMinter[_msgSender()], \"!Minter\");\n        _;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}\n\n",
        "CodeNames": [
            "Position.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Position contract's mint() function",
                "Type": "Reentrancy Attack",
                "Description": "The mint() function in the Position contract doesn't follow check-effect-interaction pattern and it's possible to perform reentrancy attack during mint() function which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value.",
                "Repair": "Follow the check-effect-interaction pattern"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}\n\n",
        "CodeNames": [
            "BondNFT.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BondNFT.sol#claim()",
                "Type": "Inaccurate reward calculation",
                "Description": "In BondNFT.sol#claim(), accRewardsPerShare[][] is amended to reflect the expired shares. But only accRewardsPerShare[bond.asset][epoch[bond.asset]] is updated. All the epochs between bond.expireEpoch-1 and epoch[bond.asset] are missed.",
                "Repair": "Update all the epochs between bond.expireEpoch-1 and epoch[bond.asset] in accRewardsPerShare[][]"
            },
            {
                "Location": "BondNFT.claim() function",
                "Type": "Reentrancy",
                "Description": "A malicious user can exploit this vulnerability to steal all assets in BondNFT contract by repeatedly calling claim() function of an expired bond, which updates accRewardsPerShare and increases pending rewards of all other users.",
                "Repair": "Forcing an expired bond to release() and adding a check to claim() function to revert if an expired bond is claimed"
            },
            {
                "Location": "BondNFT contract, unreleased locks",
                "Type": "Flawed reward distribution",
                "Description": "Unreleased locks cause other existing bonds to not receive the full amount of tokens, resulting in bond owners receiving less rewards than they should. The issue is that as long as the bond is not released, the totalShares value isn't updated. This causes a loss of funds for every bond holder.",
                "Repair": "Update the totalShares value for active bonds only"
            },
            {
                "Location": "BondNFT.extendLock",
                "Type": "Bond lock extension forces user to extend for at least current period",
                "Description": "The current implementation forces a user to extend their bonds for at least their current bond period. This means that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.",
                "Repair": "Change the current implementation to allow extending the bond for any period, as long as it respects the minimum bond period."
            },
            {
                "Location": "BondNFT.distribute() function",
                "Type": "Incorrect state variable update",
                "Description": "When totalShares[_tigAsset] is equal to 0, epoch[asset] won't get updated in distribute() function, leading to wrong values for bond's mint epoch when createLock() is called.",
                "Repair": "Update epoch[asset] in distribute() function even when totalShares[_tigAsset] is equal to 0. Only the division by zero and fund transfer should be prevented when totalShare is zero and epoch[asset] index should be updated."
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IReferrals.sol\";\n\ncontract Referrals is Ownable, IReferrals {\n\n    bool private isInit;\n\n    address public protocol;\n\n    mapping(bytes32 => address) private _referral;\n    mapping(address => bytes32) private _referred;\n\n    /**\n    * @notice used by any address to create a ref code\n    * @param _hash hash of the string code\n    */\n    function createReferralCode(bytes32 _hash) external {\n        require(_referral[_hash] == address(0), \"Referral code already exists\");\n        _referral[_hash] = _msgSender();\n        emit ReferralCreated(_msgSender(), _hash);\n    }\n\n    /**\n    * @notice set the ref data\n    * @dev only callable by trading\n    * @param _referredTrader address of the trader\n    * @param _hash ref hash\n    */\n    function setReferred(address _referredTrader, bytes32 _hash) external onlyProtocol {\n        if (_referred[_referredTrader] != bytes32(0)) {\n            return;\n        }\n        if (_referredTrader == _referral[_hash]) {\n            return;\n        }\n        _referred[_referredTrader] = _hash;\n        emit Referred(_referredTrader, _hash);\n    }\n\n    function getReferred(address _trader) external view returns (bytes32) {\n        return _referred[_trader];\n    }\n\n    function getReferral(bytes32 _hash) external view returns (address) {\n        return _referral[_hash];\n    }\n\n    // Owner\n\n    function setProtocol(address _protocol) external onlyOwner {\n        protocol = _protocol;\n    }\n\n    /**\n    * @notice deprecated\n    */\n    function initRefs(\n        address[] memory _codeOwners,\n        bytes32[] memory _ownedCodes,\n        address[] memory _referredA,\n        bytes32[] memory _referredTo\n    ) external onlyOwner {\n        require(!isInit);\n        isInit = true;\n        uint _codeOwnersL = _codeOwners.length;\n        uint _referredAL = _referredA.length;\n        for (uint i=0; i<_codeOwnersL; i++) {\n            _referral[_ownedCodes[i]] = _codeOwners[i];\n        }\n        for (uint i=0; i<_referredAL; i++) {\n            _referred[_referredA[i]] = _referredTo[i];\n        }\n    }\n\n    // Modifiers\n\n    modifier onlyProtocol() {\n        require(_msgSender() == address(protocol), \"!Protocol\");\n        _;\n    }\n\n    event ReferralCreated(address _referrer, bytes32 _hash);\n    event Referred(address _referredTrader, bytes32 _hash);\n\n}\n\n",
        "CodeNames": [
            "Referrals.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "createReferralCode() function in Referrals.sol",
                "Type": "Referral vulnerability",
                "Description": "One can become referral of hash 0x0 and because all users default referral hash is 0x0 so he would become all users referral by default and earn a lot of fees while users didn't approve it.",
                "Repair": "Prevent someone from setting 0x0 hash for their referral code"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./utils/ExcessivelySafeCall.sol\";\n\ncontract GovNFT is ERC721Enumerable, ILayerZeroReceiver, MetaContext, IGovNFT {\n    using ExcessivelySafeCall for address;\n    \n    uint256 private counter = 1;\n    uint256 private constant MAX = 10000;\n    uint256 public gas = 150000;\n    string public baseURI;\n    uint256 public maxBridge = 20;\n    ILayerZeroEndpoint public endpoint;\n\n    mapping(uint16 => mapping(address => bool)) public isTrustedAddress;\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n    event ReceiveNFT(\n        uint16 _srcChainId,\n        address _from,\n        uint256[] _tokenId\n    );\n\n    constructor(\n        address _endpoint,\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        baseURI = _setBaseURI;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function _mint(address to, uint256 tokenId) internal override {\n        require(counter <= MAX, \"Exceeds supply\");\n        counter += 1;\n        for (uint i=0; i<assetsLength(); i++) {\n            userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n        }\n        super._mint(to, tokenId);\n    }\n\n    /**\n     * @dev should only be called by layer zero\n     * @param to the address to receive the bridged NFTs\n     * @param tokenId the NFT id\n     */\n    function _bridgeMint(address to, uint256 tokenId) public {\n        require(msg.sender == address(this) || _msgSender() == owner(), \"NotBridge\");\n        require(tokenId <= 10000, \"BadID\");\n        for (uint i=0; i<assetsLength(); i++) {\n            userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n        }\n        super._mint(to, tokenId);\n    }\n\n    /**\n    * @notice updates userDebt \n    */\n    function _burn(uint256 tokenId) internal override {\n        address owner = ownerOf(tokenId);\n        for (uint i=0; i<assetsLength(); i++) {\n            userDebt[owner][assets[i]] += accRewardsPerNFT[assets[i]];\n            userDebt[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);\n            userPaid[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);            \n        }\n        super._burn(tokenId);\n    }\n\n    /**\n    * @notice updates userDebt for both to and from\n    */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        require(ownerOf(tokenId) == from, \"!Owner\");\n        for (uint i=0; i<assetsLength(); i++) {\n            userDebt[from][assets[i]] += accRewardsPerNFT[assets[i]];\n            userDebt[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n            userPaid[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n            userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n        }\n        super._transfer(from, to, tokenId);\n    }\n\n    function mintMany(uint _amount) external onlyOwner {\n        for (uint i=0; i<_amount; i++) {\n            _mint(_msgSender(), counter);\n        }\n    }\n\n    function mint() external onlyOwner {\n        _mint(_msgSender(), counter);\n    }\n\n    function setTrustedAddress(uint16 _chainId, address _contract, bool _bool) external onlyOwner {\n        isTrustedAddress[_chainId][_contract] = _bool;\n    }\n\n    /**\n    * @notice used to bridge NFTs crosschain using layer zero\n    * @param _dstChainId the layer zero id of the dest chain\n    * @param _to receiving address on dest chain\n    * @param tokenId array of the ids of the NFTs to be bridged\n    */\n    function crossChain(\n        uint16 _dstChainId,\n        bytes memory _destination,\n        address _to,\n        uint256[] memory tokenId\n    ) public payable {\n        require(tokenId.length > 0, \"Not bridging\");\n        for (uint i=0; i<tokenId.length; i++) {\n            require(_msgSender() == ownerOf(tokenId[i]), \"Not the owner\");\n            // burn NFT\n            _burn(tokenId[i]);\n        }\n        address targetAddress;\n        assembly {\n            targetAddress := mload(add(_destination, 20))\n        }\n        require(isTrustedAddress[_dstChainId][targetAddress], \"!Trusted\");\n        bytes memory payload = abi.encode(_to, tokenId);\n        // encode adapterParams to specify more gas for the destination\n        uint16 version = 1;\n        uint256 _gas = 500_000 + gas*tokenId.length;\n        bytes memory adapterParams = abi.encodePacked(version, _gas);\n        (uint256 messageFee, ) = endpoint.estimateFees(\n            _dstChainId,\n            address(this),\n            payload,\n            false,\n            adapterParams\n        );\n        require(\n            msg.value >= messageFee,\n            \"Must send enough value to cover messageFee\"\n        );\n        endpoint.send{value: msg.value}(\n            _dstChainId,\n            _destination,\n            payload,\n            payable(_msgSender()),\n            address(0x0),\n            adapterParams\n        );\n    }\n\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public {\n        // only internal transaction\n        require(msg.sender == address(this), \"NonblockingLzApp: caller must be app\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64, bytes memory _payload) internal {\n        address fromAddress;\n        assembly {\n            fromAddress := mload(add(_srcAddress, 20))\n        }\n        require(isTrustedAddress[_srcChainId][fromAddress], \"!TrustedAddress\");\n        (address toAddress, uint256[] memory tokenId) = abi.decode(\n            _payload,\n            (address, uint256[])\n        );\n        // mint the tokens\n        for (uint i=0; i<tokenId.length; i++) {\n            _bridgeMint(toAddress, tokenId[i]);\n        }\n        emit ReceiveNFT(_srcChainId, toAddress, tokenId);\n    }\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n\n    // Endpoint.sol estimateFees() returns the fees for the message\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view returns (uint256 nativeFee, uint256 zroFee) {\n        return\n            endpoint.estimateFees(\n                _dstChainId,\n                _userApplication,\n                _payload,\n                _payInZRO,\n                _adapterParams\n            );\n    }\n\n    function setGas(uint _gas) external onlyOwner {\n        gas = _gas;\n    }\n\n    function setEndpoint(ILayerZeroEndpoint _endpoint) external onlyOwner {\n        require(address(_endpoint) != address(0), \"ZeroAddress\");\n        endpoint = _endpoint;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            _transfer(_msgSender(), _to, _ids[i]);\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            safeTransferFrom(_from, _to, _ids[i]);\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            approve(_to, _ids[i]);\n        }\n    }\n\n    // Rewards\n    address[] public assets;\n    mapping(address => bool) private _allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(address => mapping(address => uint256)) private userPaid;\n    mapping(address => mapping(address => uint256)) private userDebt;\n    mapping(address => uint256) private accRewardsPerNFT;\n\n    /**\n    * @notice claimable by anyone to claim pending rewards tokens\n    * @param _tigAsset reward token address\n    */\n    function claim(address _tigAsset) external {\n        address _msgsender = _msgSender();\n        uint256 amount = pending(_msgsender, _tigAsset);\n        userPaid[_msgsender][_tigAsset] += amount;\n        IERC20(_tigAsset).transfer(_msgsender, amount);\n    }\n\n    /**\n    * @notice add rewards for NFT holders\n    * @param _tigAsset reward token address\n    * @param _amount amount to be distributed\n    */\n    function distribute(address _tigAsset, uint _amount) external {\n        if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;\n        try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n            accRewardsPerNFT[_tigAsset] += _amount/totalSupply();\n        } catch {\n            return;\n        }\n    }\n\n    function pending(address user, address _tigAsset) public view returns (uint256) {\n        return userDebt[user][_tigAsset] + balanceOf(user)*accRewardsPerNFT[_tigAsset] - userPaid[user][_tigAsset]; \n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        _allowedAsset[_asset] = true;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        _allowedAsset[_asset] = _bool;\n    }\n\n    function setMaxBridge(uint256 _max) external onlyOwner {\n        maxBridge = _max;\n    }\n\n    function assetsLength() public view returns (uint256) {\n        return assets.length;\n    }\n\n    function allowedAsset(address _asset) external view returns (bool) {\n        return _allowedAsset[_asset];\n    }\n\n    function balanceIds(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}\n\n",
        "CodeNames": [
            "GovNFT.sol",
            "BondNFT.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GovNFT.safeTransferMany() and BondNFT.safeTransferMany()",
                "Type": "safeTransferMany() function doesn't actually use safe transfer",
                "Description": "Both BondNFT and GovNFT have a function named safeTransferMany() which its name implies is supposed to safe transfer many tokens at once. However, the function doesn't actually safe transfer. Users might use this function, expecting it to verify that the receiver is an ERC721Receiver, but will get their funds stuck in a contract that doesn't support ERC721.",
                "Repair": "Call _safeTransfer() instead of _transfer()."
            }
        ]
    }
]