[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function claim(address to) external",
                "Type": "ERC20 transfer function not checked for return value",
                "Description": "The claim function performs an ERC20 transfer rewardsToken.transfer(to, claiming); but does not check the return value, nor does it work with all legacy tokens.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens."
            },
            {
                "Location": "function setRewards(address _rewardsToken, uint256 _rewardsDuration)",
                "Type": "ERC20Rewards breaks when setting a different token",
                "Description": "The setRewards function allows setting a different token. Holders of a previous reward period cannot all be paid out and will receive their old reward amount in the new token.",
                "Repair": "Disallow changing the reward token, or clear user's pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed."
            },
            {
                "Location": "function _updateRewardsPerToken() internal",
                "Type": "Rewards accumulated can stay constant and often not increment",
                "Description": "rewardsPerToken_.accumulated can stay constant while rewardsPerToken_.lastUpdated is continually updated, leading to no actual rewards being distributed.",
                "Repair": "The simplest is to probably not update the rewardsPerToken_.lastUpdated field if rewardsPerToken_.accumulated does not change. Although this change should be closely scrutinized to see it doesn't introduce bugs elsewhere."
            },
            {
                "Location": "function setRewards(address _rewardsToken, uint256 _rewardsDuration)",
                "Type": "Rewards squatting - setting rewards in different ERC20 tokens opens various economic attacks",
                "Description": "Users essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token.",
                "Repair": "Disallow changing the reward token."
            },
            {
                "Location": "CompositeMultiOracle.peek/get functions",
                "Type": "High Severity",
                "Description": "The CompositeMultiOracle.peek/get functions seem to return wrong prices. It's unclear what decimals source.decimals refers to in this case.",
                "Repair": "Scale the prices to 1e18 by dividing by the oracle precision (IOracle(source.source).decimals())"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"./ERC20Permit.sol\";\nimport \"../access/AccessControl.sol\";\nimport \"../RevertMsgExtractor.sol\";\n\n\nlibrary CastU256U32 {\n    /// @dev Safely cast an uint256 to an uint32\n    function u32(uint256 x) internal pure returns (uint32 y) {\n        require (x <= type(uint32).max, \"Cast overflow\");\n        y = uint32(x);\n    }\n}\n\nlibrary CastU256U128 {\n    /// @dev Safely cast an uint256 to an uint128\n    function u128(uint256 x) internal pure returns (uint128 y) {\n        require (x <= type(uint128).max, \"Cast overflow\");\n        y = uint128(x);\n    }\n}\n\n/// @dev A token inheriting from ERC20Rewards will reward token holders with a rewards token.\n/// The rewarded amount will be a fixed wei per second, distributed proportionally to token holders\n/// by the size of their holdings.\ncontract ERC20Rewards is AccessControl, ERC20Permit {\n    using CastU256U32 for uint256;\n    using CastU256U128 for uint256;\n\n    event RewardsSet(IERC20 rewardsToken, uint32 start, uint32 end, uint256 rate);\n    event RewardsPerTokenUpdated(uint256 accumulated);\n    event UserRewardsUpdated(address user, uint256 userRewards, uint256 paidRewardPerToken);\n    event Claimed(address receiver, uint256 claimed);\n\n    struct RewardsPeriod {\n        uint32 start;                                   // Start time for the current rewardsToken schedule\n        uint32 end;                                     // End time for the current rewardsToken schedule\n    }\n\n    struct RewardsPerToken {\n        uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18\n        uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated\n        uint96 rate;                                    // Wei rewarded per second among all token holders\n    }\n\n    struct UserRewards {\n        uint128 accumulated;                            // Accumulated rewards for the user until the checkpoint\n        uint128 checkpoint;                             // RewardsPerToken the last time the user rewards were updated\n    }\n\n    IERC20 public rewardsToken;                         // Token used as rewards\n    RewardsPeriod public rewardsPeriod;                 // Period in which rewards are accumulated by users\n\n    RewardsPerToken public rewardsPerToken;             // Accumulator to track rewards per token               \n    mapping (address => UserRewards) public rewards;    // Rewards accumulated by users\n    \n    constructor(string memory name, string memory symbol, uint8 decimals)\n        ERC20Permit(name, symbol, decimals)\n    { }\n\n    /// @dev Return the earliest of two timestamps\n    function earliest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x < y) ? x : y;\n    }\n\n    /// @dev Return the latest of two timestamps\n    function latest(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        z = (x > y) ? x : y;\n    }\n\n    /// @dev Set a rewards schedule\n    function setRewards(IERC20 rewardsToken_, uint32 start, uint32 end, uint96 rate)\n        public\n        auth\n    {\n        // A new rewards program can be set if one is not running\n        require(\n            block.timestamp.u32() < rewardsPeriod.start || block.timestamp.u32() > rewardsPeriod.end,\n            \"Ongoing rewards\"\n        );\n\n        // If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token\n        rewardsToken = rewardsToken_;\n\n        rewardsPeriod.start = start;\n        rewardsPeriod.end = end;\n\n        // If setting up a new rewards program, the rewardsPerToken.accumulated is used and built upon\n        // New rewards start accumulating from the new rewards program start\n        // Any unaccounted rewards from last program can still be added to the user rewards\n        // Any unclaimed rewards can still be claimed\n        rewardsPerToken.lastUpdated = start;\n        rewardsPerToken.rate = rate;\n\n        emit RewardsSet(rewardsToken, start, end, rate);\n    }\n\n    /// @dev Update the rewards per token accumulator.\n    /// @notice Needs to be called on each liquidity event\n    function _updateRewardsPerToken() internal returns (uint128) {\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        RewardsPeriod memory rewardsPeriod_ = rewardsPeriod;\n\n        // We skip the calculations if we can\n        if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod_.start) return 0;\n        if (rewardsPerToken_.lastUpdated >= rewardsPeriod_.end) return rewardsPerToken_.accumulated;\n\n        // Find out the unaccounted period\n        uint32 end = earliest(block.timestamp.u32(), rewardsPeriod_.end);\n        uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated; // Cast to uint256 to avoid overflows later on\n\n        // Calculate and update the new value of the accumulator. timeSinceLastUpdated casts it into uint256, which is desired.\n        rewardsPerToken_.accumulated = (rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply).u128(); // The rewards per token are scaled up for precision\n        rewardsPerToken_.lastUpdated = end;\n        rewardsPerToken = rewardsPerToken_;\n        \n        emit RewardsPerTokenUpdated(rewardsPerToken_.accumulated);\n\n        return rewardsPerToken_.accumulated;\n    }\n\n    /// @dev Accumulate rewards for an user.\n    /// @notice Needs to be called on each liquidity event, or when user balances change.\n    function _updateUserRewards(address user) internal returns (uint128) {\n        UserRewards memory userRewards_ = rewards[user];\n        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n        \n        // Calculate and update the new value user reserves. _balanceOf[user] casts it into uint256, which is desired.\n        userRewards_.accumulated = (userRewards_.accumulated + _balanceOf[user] * (rewardsPerToken_.accumulated - userRewards_.checkpoint) / 1e18).u128(); // We must scale down the rewards by the precision factor\n        userRewards_.checkpoint = rewardsPerToken_.accumulated;\n        rewards[user] = userRewards_;\n        emit UserRewardsUpdated(user, userRewards_.accumulated, userRewards_.checkpoint);\n\n        return userRewards_.accumulated;\n    }\n\n    /// @dev Mint tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _mint(address dst, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(dst);\n        return super._mint(dst, wad);\n    }\n\n    /// @dev Burn tokens, after accumulating rewards for an user and update the rewards per token accumulator.\n    function _burn(address src, uint256 wad)\n        internal virtual override\n        returns (bool)\n    {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        return super._burn(src, wad);\n    }\n\n    /// @dev Transfer tokens, after updating rewards for source and destination.\n    function _transfer(address src, address dst, uint wad) internal virtual override returns (bool) {\n        _updateRewardsPerToken();\n        _updateUserRewards(src);\n        _updateUserRewards(dst);\n        return super._transfer(src, dst, wad);\n    }\n\n    /// @dev Claim all rewards from caller into a given address\n    function claim(address to)\n        external\n        returns (uint256 claiming)\n    {\n        _updateRewardsPerToken();\n        claiming = _updateUserRewards(msg.sender);\n        rewards[msg.sender].accumulated = 0; // A Claimed event implies the rewards were set to zero\n        rewardsToken.transfer(to, claiming);\n        emit Claimed(to, claiming);\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC20Rewards.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ERC20Rewards.sol L175",
                "Type": "Medium Severity",
                "Description": "Tokens not compliant with the ERC20 specification could return false from the transfer function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked.",
                "Repair": "Use the SafeERC20 library implementation from OpenZeppelin and calling safeTransfer or safeTransferFrom when transferring ERC20 tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// Inspired on TimeLock.sol from Compound.\n\npragma solidity ^0.8.0;\nimport \"./access/AccessControl.sol\";\nimport \"./RevertMsgExtractor.sol\";\n\ninterface ITimeLock {\n    function setDelay(uint256 delay_) external;\n    function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta) external returns (bytes32 txHash);\n    function cancel(address[] calldata targets, bytes[] calldata data) external;\n    function execute(address[] calldata targets, bytes[] calldata data) external returns (bytes[] calldata results);\n}\n\ncontract TimeLock is ITimeLock, AccessControl {\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    event DelaySet(uint256 indexed delay);\n    event Cancelled(bytes32 indexed txHash, address[] indexed targets, bytes[] data);\n    event Executed(bytes32 indexed txHash, address[] indexed targets, bytes[] data);\n    event Scheduled(bytes32 indexed txHash, address[] indexed targets, bytes[] data, uint256 eta);\n\n    uint256 public delay;\n    mapping (bytes32 => uint256) public transactions;\n\n    constructor(address scheduler, address executor) AccessControl() {\n        delay = MINIMUM_DELAY;\n\n        // scheduler can schedule and cancel, executor can execute\n        _grantRole(ITimeLock.schedule.selector, scheduler); // bytes4(keccak256(\"schedule(address[],bytes[],uint256)\"))\n        _grantRole(ITimeLock.cancel.selector, scheduler); // bytes4(keccak256(\"cancel(address[],bytes[],uint256)\"))\n        _grantRole(ITimeLock.execute.selector, executor); // bytes4(keccak256(\"execute(address[],bytes[],uint256)\"))\n\n        // Changing the delay must now be executed through this TimeLock contract\n        _grantRole(ITimeLock.setDelay.selector, address(this)); // bytes4(keccak256(\"setDelay(uint256)\"))\n\n        // Granting roles (schedule, cancel, execute, setDelay) must now be executed through this TimeLock contract\n        _grantRole(ROOT, address(this));\n        _revokeRole(ROOT, msg.sender);\n    }\n\n    /// @dev Change the delay for queueing and executing transactions\n    function setDelay(uint256 delay_) external override auth {\n        require(delay_ >= MINIMUM_DELAY, \"Must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit DelaySet(delay);\n    }\n\n    /// @dev Schedule a transaction batch for execution between `eta` and `eta + GRACE_PERIOD`\n    function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta)\n        external override auth returns (bytes32 txHash)\n    {\n        require(targets.length == data.length, \"Mismatched inputs\");\n        require(eta >= block.timestamp + delay, \"Must satisfy delay.\"); // This also prevents setting eta = 0 and messing up the state\n        txHash = keccak256(abi.encode(targets, data));\n        require(transactions[txHash] == 0, \"Transaction not unknown.\");\n        transactions[txHash] = eta;\n        emit Scheduled(txHash, targets, data, eta);\n    }\n\n    /// @dev Cancel a scheduled transaction batch\n    function cancel(address[] calldata targets, bytes[] calldata data)\n        external override auth\n    {\n        require(targets.length == data.length, \"Mismatched inputs\");\n        bytes32 txHash = keccak256(abi.encode(targets, data));\n        require(transactions[txHash] != 0, \"Transaction hasn't been scheduled.\");\n        delete transactions[txHash];\n        emit Cancelled(txHash, targets, data);\n    }\n\n    /// @dev Execute a transaction batch\n    function execute(address[] calldata targets, bytes[] calldata data)\n        external override auth returns (bytes[] memory results)\n    {\n        require(targets.length == data.length, \"Mismatched inputs\");\n        bytes32 txHash = keccak256(abi.encode(targets, data));\n        uint256 eta = transactions[txHash];\n\n        require(eta != 0, \"Transaction hasn't been scheduled.\");\n        require(block.timestamp >= eta, \"ETA not reached.\");\n        require(block.timestamp <= eta + GRACE_PERIOD, \"Transaction is stale.\");\n\n        delete transactions[txHash];\n\n        results = new bytes[](targets.length);\n        for (uint256 i = 0; i < targets.length; i++){\n            (bool success, bytes memory result) = targets[i].call(data[i]);\n            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n            results[i] = result;\n        }\n        emit Executed(txHash, targets, data);\n    }\n}\n\n",
        "CodeNames": [
            "TimeLock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TimeLock.schedule function",
                "Type": "Medium Severity",
                "Description": "The TimeLock.schedule function reverts if the same targets and data fields are used as the txHash will be the same.",
                "Repair": "Include eta in the hash to allow scheduling the same transactions multiple times"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"../../utils/access/AccessControl.sol\";\nimport \"../../interfaces/vault/IOracle.sol\";\nimport \"../../constants/Constants.sol\";\nimport \"../../math/CastBytes32Bytes6.sol\";\nimport \"./CTokenInterface.sol\";\n\n\ncontract CTokenMultiOracle is IOracle, AccessControl, Constants {\n    using CastBytes32Bytes6 for bytes32;\n\n    uint8 public constant override decimals = 18;   // All prices are converted to 18 decimals\n\n    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);\n\n    struct Source {\n        address source;\n        uint8 decimals;\n        bool inverse;\n    }\n\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n\n    /**\n     * @notice Set or reset an oracle source and its inverse\n     */\n    function setSource(bytes6 cTokenId, bytes6 underlying, address cToken) external auth {\n        _setSource(cTokenId, underlying, cToken);\n    }\n\n    /**\n     * @notice Set or reset a number of oracle sources and their inverses\n     */\n    function setSources(bytes6[] memory cTokenIds, bytes6[] memory underlyings, address[] memory cTokens) external auth {\n        require(\n            cTokenIds.length == underlyings.length && \n            cTokenIds.length == cTokens.length,\n            \"Mismatched inputs\"\n        );\n        for (uint256 i = 0; i < cTokenIds.length; i++) {\n            _setSource(cTokenIds[i], underlyings[i], cTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount)\n        external view virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), quote.b6());\n        value = price * amount / 1e18;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount)\n        external virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price;\n        (price, updateTime) = _get(base.b6(), quote.b6());\n        value = price * amount / 1e18;\n    }\n\n    function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {\n        uint256 rawPrice;\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n\n        rawPrice = CTokenInterface(source.source).exchangeRateStored();\n\n        require(rawPrice > 0, \"Compound price is zero\");\n\n        if (source.inverse == true) {\n            price = 10 ** (source.decimals + 18) / uint(rawPrice);\n        } else {\n            price = uint(rawPrice) * 10 ** (18 - source.decimals);\n        }\n\n        updateTime = block.timestamp; // We should get the timestamp\n    }\n\n    function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {\n        uint256 rawPrice;\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n\n        rawPrice = CTokenInterface(source.source).exchangeRateCurrent();\n\n        require(rawPrice > 0, \"Compound price is zero\");\n\n        if (source.inverse == true) {\n            price = 10 ** (source.decimals + 18) / uint(rawPrice);\n        } else {\n            price = uint(rawPrice) * 10 ** (18 - source.decimals);\n        }\n\n        updateTime = block.timestamp; // We should get the timestamp\n    }\n\n    function _setSource(bytes6 cTokenId, bytes6 underlying, address source) internal {\n        uint8 decimals_ = 18; // Does the borrowing rate have 18 decimals?\n        require (decimals_ <= 18, \"Unsupported decimals\");\n        sources[cTokenId][underlying] = Source({\n            source: source,\n            decimals: decimals_,\n            inverse: false\n        });\n        sources[underlying][cTokenId] = Source({\n            source: source,\n            decimals: decimals_,\n            inverse: true\n        });\n        emit SourceSet(cTokenId, underlying, source);\n        emit SourceSet(underlying, cTokenId, source);\n    }\n}\n\n",
        "CodeNames": [
            "CTokenMultiOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CTokenMultiOracle.sol #L110",
                "Type": "High Severity",
                "Description": "The CTokenMultiOracle contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true.",
                "Repair": "Get the decimals of the underlying tokens to set the correct decimal of a Source"
            }
        ]
    }
]