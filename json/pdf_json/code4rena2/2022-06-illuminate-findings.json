[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nlibrary Swivel {\n    // the components of a ECDSA signature\n    struct Components {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct Order {\n        bytes32 key;\n        address maker;\n        address underlying;\n        bool vault;\n        bool exit;\n        uint256 principal;\n        uint256 premium;\n        uint256 maturity;\n        uint256 expiry;\n    }\n}\n\n\n",
        "CodeNames": [
            "Swivel.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Swivel.initiate()",
                "Type": "Calls to function do not verify input parameters",
                "Description": "Swivel lend() does not validate the o.exit and o.vault for each order before making the external call to Swivel.",
                "Repair": "Restrict the values of o.exit and o.vault so only one case can be triggered in Swivel.initiate()"
            },
            {
                "Location": "Swivel lend method",
                "Type": "input validation",
                "Description": "The principals enum p is only used for unpaused(p) modifier, and an attacker can bypass the unpaused(p) modifier check by simply passing an enum of another principle that is not paused.",
                "Repair": "Add a check at the beginning of the function to ensure that p == uint8(MarketPlace.Principals.Swivel)"
            },
            {
                "Location": "Swivel lend method",
                "Type": "arithmetic",
                "Description": "There is a division before multiplication bug that exists in lend() for the Swivel case, which can lead to zero rounding of return amount.",
                "Repair": "Change the order of operations to ((a[i] * fee) * order.premium) / order.principal)"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Sense's redeem function",
                "Type": "Denial of Service (DoS)",
                "Description": "Sense's redeem can be totally DOSd due to user supplied input.",
                "Repair": "Use a whitelisted Sense address, or send to ISense(d).redeem Redeemer's whole principal balance"
            },
            {
                "Location": "maxRedeem function",
                "Type": "Inability to redeem PT from Notional",
                "Description": "The maxRedeem function is a view function which only returns the balance of the Redeemer.sol contract.",
                "Repair": "Call redeem from Notional using the amount from maxRedeem as the shares input after the call to maxRedeem"
            },
            {
                "Location": "sellPrincipalToken, buyPrincipalToken, sellUnderlying, buyUnderlying functions",
                "Type": "Unpermissioned use of marketplace funds",
                "Description": "Fund loss from marketplace.sellPrincipalToken, buyPrincipalToken, sellUnderlying, buyUnderlying are all unpermissioned and use marketplace funds to complete the action but send the resulting tokens to msg.sender.",
                "Repair": "All functions should use safetransfer to get funds from msg.sender not from marketplace"
            },
            {
                "Location": "APWine and Tempus PT redeem function",
                "Type": "Incorrect implementation of redeem function",
                "Description": "Redeeming APWine and Tempus PT will always fail, causing a portion of iPT to not be able to be redeemed for the underlying token.",
                "Repair": "Fix the transfer line: Safe.transferFrom(IERC20(principal), lender, address(this), amount)"
            },
            {
                "Location": "yield function",
                "Type": "Leak of Value",
                "Description": "The function yield is using the input from sellBasePreview and then using it.",
                "Repair": "Add checks, or ideally have a trusted keeper bulk sellBase with an additional slippage check as the function parameter"
            },
            {
                "Location": "withdrawFee function",
                "Type": "Withdrawal of eToken before withdrawFee of eToken",
                "Description": "withdrawFee of eToken requires the amount of eToken in Lender.sol = fees[eToken] so Safe.transfer will not revert.",
                "Repair": "Add fees[eToken] = 0; after withdrawals[e] = 0; in withdraw"
            },
            {
                "Location": "redeem function",
                "Type": "Allowance check always true in ERC5095 redeem",
                "Description": "In redeem, it is checked that the allowance is larger than underlyingAmount, which is the return parameter (i.e., equal to 0 at that point). Therefore, this check is always true and there is no actual allowance check, allowing anyone to redeem for another user.",
                "Repair": "Change the underlyingAmount to principalAmount, which is the intended parameter."
            },
            {
                "Location": "withdraw and redeem functions",
                "Type": "ERC5095 redeem/withdraw does not update allowances",
                "Description": "ERC5095's redeem/withdraw allows an ERC20-approved account to redeem user's tokens, but does not update the allowance after burning.",
                "Repair": "Update the allowances upon spending."
            },
            {
                "Location": "Pendle lend() function",
                "Type": "Incorrect return value usage",
                "Description": "The function swapExactTokensForTokens() will return and array with the 0 index being the input amount follow by each output amount. The 0 index is incorrectly used in Pendle lend() function as the output amount. As a result the value of returned will be the invalid (i.e. the input rather than the output).",
                "Repair": "Use index 1 of the array returned by swapExactTokensForTokens()"
            },
            {
                "Location": "Marketplace and Lender's yield() swapping functions",
                "Type": "Sandwich attacks",
                "Description": "Swapping function in Marketplace and Lender's yield() can be sandwiched as there is no slippage control option. Trades can happen at a manipulated price and end up receiving fewer tokens than current market price dictates.",
                "Repair": "Consider adding minimum accepted return argument to the five mentioned functions and condition execution success on it"
            },
            {
                "Location": "Illuminate and Yield lending",
                "Type": "logic violation/incompleteness",
                "Description": "Lender's Illuminate and Yield lend() mistreats the principal type p requested by a user, producing another type each time.",
                "Repair": "Switch the logic for when p == uint8(MarketPlace.Principals.Yield) and p == uint8(MarketPlace.Principals.Illuminate)"
            },
            {
                "Location": "Tempus lend method",
                "Type": "input validation",
                "Description": "The Tempus lend method calculates the amount of tokens to mint as amountReturnedFromTempus * lenderBalanceOfMetaPrincipalToken, which seems wrong as there's no connection between the two items.",
                "Repair": "Check Lender's x.tempusPool().principalShare() before and after the swap, and the delta is the amount received."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol'; // library of market place specific constructs\nimport './Swivel.sol'; // library of swivel specific constructs\nimport './Element.sol'; // library of element specific constructs\nimport './Safe.sol';\nimport './Cast.sol';\n\n/// @title Lender.sol\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users. \n/// @notice The contract holds the principal tokens for each market and mints an ERC-5095 position to users to represent their lent positions.\ncontract Lender {\n    error Unauthorized();\n    error NotEqual(string);\n    error Exists(address);\n    error Invalid(string);\n\n    /// @notice minimum amount of time the admin must wait before executing a withdrawl\n    uint256 constant public HOLD = 3 days;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace.sol contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal may be used by a lender\n    mapping(uint8 => bool) public paused;\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping (address => uint256) public withdrawals;\n\n    /// @notice emitted upon executed lend\n    event Lend(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 returned);\n    /// @notice emitted upon minted ERC5095 to user\n    event Mint(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n    /// @notice emitted on token withdrawal scheduling\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted on token withdrawal blocking\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted on a change to the feenominators array\n\n    /// @notice initializes the Lender contract\n    /// @param s the swivel contract\n    /// @param p the pendle contract\n    /// @param t the tempus contract\n    constructor(\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u underlying token's address, used to define the market being approved\n    /// @param m maturity of the underlying token, used to define the market being approved\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful, false otherwise\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // max is the maximum integer value for a 256 unsighed integer\n        uint256 max = 2**256 - 1;\n\n        // approve the underlying for max per given principal\n        for (uint8 i; i < 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).markets(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses. \n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a) external authorized(admin) returns (bool) {\n        uint256 len = u.length;\n        if (len != a.length) {\n            revert NotEqual('array length');\n        }\n        uint256 max = 2**256 - 1;\n\n        for (uint256 i; i < len; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        feenominator = f;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists(marketPlace);\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on illuminate\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful, false otherwise\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public returns (bool) {\n        //use market interface to fetch the market for the given market pair\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        //use safe transfer lib and ERC interface...\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n        //use ERC5095 interface...\n        IERC5095(principalToken(u, m)).mint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method signature for both illuminate and yield\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y yieldspace pool that will execute the swap for the principal token\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y\n    ) public unpaused(p) returns (uint256) {\n        // check the principal is illuminate or yield\n        if (p != uint8(MarketPlace.Principals.Illuminate) && p != uint8(MarketPlace.Principals.Yield)) {\n            revert Invalid('principal');\n        }\n\n        // uses yield token interface...\n        IYield pool = IYield(y);\n\n        // the yield token must match the market pair\n        if (address(pool.base()) != u) {\n            revert NotEqual('underlying');\n        } else if (pool.maturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // transfer from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Purchase yield PTs to lender.sol (address(this))\n            uint256 returned = yield(u, y, a - calculateFee(a), address(this));\n            // Mint and distribute equivalent illuminate PTs\n            IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n            \n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n        else {\n            // Purchase illuminate PTs directly to msg.sender\n            uint256 returned = yield(u, y, a - calculateFee(a), msg.sender);\n\n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n    }\n\n    /// @notice lend method signature for swivel\n    /// @dev lends to yield pool. remaining balance is sent to the yield pool\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y yield pool\n    /// @param o array of swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        {\n            // returned represents the number of underlying tokens to lend to yield\n            uint256 returned;\n\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity > m) {\n                    revert NotEqual('maturity');\n                }\n\n                {\n                    uint256 amount = a[i];\n                    // Determine the fee\n                    uint256 fee = calculateFee(amount);\n                    // Track accumulated fees\n                    totalFee += fee;\n                    // Amount lent for this order\n                    uint256 amountLent = amount - fee;\n                    // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                    lent += amountLent;\n                    // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                    returned += amountLent * order.premium / order.principal;\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n      \n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n\n    /// @notice lend method signature for element\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed deadline is a timestamp by which the swap must be executed\n    /// @param e element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) public unpaused(p) returns (uint256) {\n        // Get the principal token for this market for element\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // the element token must match the market pair\n        if (IElementToken(principal).underlying() != u) {\n            revert NotEqual('underlying');\n        } else if (IElementToken(principal).unlockTimestamp() > m) {\n            revert NotEqual('maturity');\n        }\n        // Transfer underlying token from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] += calculateFee(a);\n\n        uint256 purchased;\n        {\n            // Create the variables needed to execute an element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000',\n                poolId: i,\n                amount: a - calculateFee(a),\n                kind: Element.SwapKind.In,\n                assetIn: Any(u),\n                assetOut: Any(principal)\n            });\n\n            // Conduct the swap on element\n            purchased = IElement(e).swap(swap, fund, r, d);\n        }\n\n        emit Lend(p, u, m, purchased);\n        return purchased;\n    }\n\n    /// @notice lend method signature for pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) public unpaused(p) returns (uint256) {\n\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        IPendleToken token = IPendleToken(principal);\n\n        // confirm that we are in the correct market\n        if (token.yieldToken() != u) {\n            revert NotEqual('underlying');\n        } else if (token.expiry() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = calculateFee(a);\n            fees[u] += fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0];\n\n        }\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for tempus\n    /// @dev This method can be called before maturity to lend to Tempus while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param t tempus pool that houses the underlying principal tokens\n    /// @param x tempus amm that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address t,\n        address x\n    ) public unpaused(p) returns (uint256) {\n        {\n            // Instantiate market and tokens\n            address principal = IMarketPlace(marketPlace).markets(u, m, p);\n            if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u)) {\n                revert NotEqual('underlying');\n            } else if (ITempus(principal).maturityTime() > m) {\n                revert NotEqual('maturity');\n            }\n\n            // Get the underlying token\n            IERC20 underlyingToken = IERC20(u);\n\n            // Transfer funds from user to Illuminate, Scope to avoid stack limit\n            Safe.transferFrom(underlyingToken, msg.sender, address(this), a);\n        }\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Tempus Router using the provided market and params\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n        uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -\n            illuminateToken.balanceOf(address(this));\n\n        // Mint Illuminate zero coupons\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r minimum number of tokens to lend (sets a limit on the order)\n    /// @param x amm that is used to conduct the swap\n    /// @param s contract that holds the principal token for this market\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        address s\n    ) public unpaused(p) returns (uint256) {\n\n        // Get the principal token for this market for this market\n        ISenseToken token = ISenseToken(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Verify that the underlying and maturity match up\n        if (token.underlying() != u) { // gauruntee the input token is the right token\n            revert NotEqual('underlying'); \n        } else if (ISense(s).pt() != address(token)) {\n            revert NotEqual('principal token'); \n        } else if (ISense(x).maturity() > m) { // gauruntee the input amm has the correct maturity\n            revert NotEqual('maturity');\n        }\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine lent amount after fees\n            lent = a - fee;\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Swap those tokens for the principal tokens\n        uint256 returned = ISense(x).swapUnderlyingForPTs(s, m, lent, r);\n\n        // Get the address of the ERC5095 token for this market\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n\n        // Mint the illuminate tokens based on the returned amount\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice this method can be called before maturity to lend to APWine while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the minimum amount of zero-coupon tokens to return accounting for slippage\n    /// @param pool the address of a given APWine pool\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        address pool,\n        address aave,\n        uint256 i\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        if (IAPWineToken(principal).getUnderlyingOfIBTAddress() != u) {\n            revert NotEqual('underlying');\n        }\n        // Dont necessarily need to validate APWINE maturity (They have 1 maturity per underlying)\n        // Potentially add redundant implied maturity calculation\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine the amount lent after fees\n            lent = a - fee;\n        }\n\n        // Deposit into aave\n        IAave(aave).deposit(u, lent, address(this), 0);\n\n        // Swap on the APWine Pool using the provided market and params\n        uint256 returned = IAPWineRouter(pool).swapExactAmountIn(i, 1, lent, 0, r, address(this));\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @dev lend method signature for Notional\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        INotional token = INotional(principal);\n\n        // Verify that the underlying and maturity match up\n        (IERC20 underlying, ) = token.getUnderlyingToken();\n        if (address(underlying) != u) {\n            revert NotEqual('underlying');\n        } else if (token.getMaturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Notional Token wrapper\n        uint256 returned = token.deposit(a - fee, address(this));\n\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice transfers excess funds to yield pool after principal tokens have been lent out\n    /// @dev this method is only used by the yield, illuminate and swivel protocols\n    /// @param u address of an underlying asset\n    /// @param y the yield pool to lend to\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the receiving address for PTs\n    /// @return uint256 the amount of tokens sent to the yield pool\n    function yield(\n        address u,\n        address y,\n        uint256 a,\n        address r\n    ) internal returns (uint256) {\n        // preview exact swap slippage on yield\n        uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));\n\n        // send the remaing amount to the given yield pool\n        Safe.transfer(IERC20(u), y, a);\n\n        // lend out the remaining tokens in the yield pool\n        IYield(y).sellBase(r, returned);\n\n        return returned;\n    }\n\n    /// @notice withdraws accumulated lending fees of the underlying token\n    /// @param e address of the underlying token to withdraw\n    /// @return bool true if successful\n    function withdrawFee(address e) external authorized(admin) returns (bool) {\n        // Get the token to be withdrawn\n        IERC20 token = IERC20(e);\n\n        // Get the balance to be transferred\n        uint256 balance = fees[e];\n\n        // Reset accumulated fees of the token to 0\n        fees[e] = 0;\n\n        // Transfer the accumulated fees to the admin\n        Safe.transfer(token, admin, balance);\n        return true;\n    }\n\n    /// @notice this method returns the fee based on the amount passed to it. If the feenominator is 0, then there is no fee.\n    /// @param a amount of underlying tokens to calculate the fee for\n    /// @return uint256 The total for for the given amount\n    function calculateFee(uint256 a) internal view returns (uint256) {\n        return feenominator > 0 ? a / feenominator : 0;\n    }\n\n    /// @notice allows the admin to schedule the withdrawal of tokens\n    /// @param e address of (erc20) token to withdraw\n    /// @return bool true if successful\n    function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n        uint256 when = block.timestamp + HOLD;\n        withdrawals[e] = when;\n\n        emit ScheduleWithdrawal(e, when);\n        return true;\n    }\n\n    /// @notice emergency function to block unplanned withdrawals\n    /// @param e address of token withdrawal to block\n    /// @return bool true if successful\n    function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n        withdrawals[e] = 0;\n\n        emit BlockWithdrawal(e);\n        return true;\n    }\n\n    /// @notice allows the admin to withdraw the given token, provided the holding period has been observed\n    /// @param e Address of token to withdraw\n    /// @return bool true if successful\n    function withdraw(address e) external authorized(admin) returns (bool) {\n        uint256 when = withdrawals[e];\n        require (when != 0, 'no withdrawal scheduled');\n  \n        require (block.timestamp >= when, 'withdrawal still on hold');\n  \n        withdrawals[e] = 0;\n  \n        IERC20 token = IERC20(e);\n        Safe.transfer(token, admin, token.balanceOf(address(this)));\n  \n        return true;\n    }\n\n    /// @notice retrieves the ERC5095 token for the given market\n    /// @param u address of the underlying\n    /// @param m uint256 representing the maturity of the market\n    /// @return address of the ERC5095 token for the market\n    function principalToken(address u, uint256 m) internal returns (address) {\n        return IMarketPlace(marketPlace).markets(u, m, 0);\n    }\n\n    /// @notice pauses a market and prevents execution of all lending for that market\n    /// @param p principal enum value\n    /// @param b bool representing whether to pause or unpause\n    /// @return bool true if successful\n    function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n        paused[p] = b;\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param p principal enum value\n    modifier unpaused(uint8 p) {\n        if (paused[p]) {\n            revert Invalid('paused');\n        }\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Lender.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Lender.sol#L192-L235, Lender.sol#L486-L534, Lender.sol#L545-L589",
                "Type": "Ability to mint any amount of PT",
                "Description": "Some of the lend functions do not validate addresses sent as input which could lead to a malicious user being able to mint more PT tokens than they should.",
                "Repair": "Validate the input addresses of y, x, and pool through a whitelisting procedure if possible or validate that the returned amounts correspond with the amount of PT gained from the protocols by checking the balance before and after the PTs are gained and checking the difference is equal to returned."
            },
            {
                "Location": "Lender.sol#L247-L305, Lender.sol#L317-L367, Lender.sol#L192-L235",
                "Type": "Not minting iPTs for lenders in several lend functions",
                "Description": "Using any of the lend function mentioned, will result in loss of funds to the lender as the funds are transferred from them but no iPTs are sent back to them!",
                "Repair": "Mint the appropriate amount of iPTs to the lender like in the rest of the lend functions."
            },
            {
                "Location": "Lender.sol#L452-L453",
                "Type": "The lend function for tempus uses the wrong return value of depositAndFix",
                "Description": "The depositAndFix function of the TempusController contract returns two uint256 data, the first is the number of shares exchanged for the underlying token, the second is the number of principalToken exchanged for the shares, the second return value should be used in the lend function for tempus.",
                "Repair": "Use the second return value of depositAndFix function for the lend function for tempus."
            },
            {
                "Location": "Lender.sol",
                "Type": "centralisation risk",
                "Description": "There are numerous methods that the admin could apply to rug pull the protocol and take all user funds.",
                "Repair": "Set all admin functions behind either a timelocked DAO or at least a timelocked multisig contract"
            },
            {
                "Location": "Lender.sol",
                "Type": "no check for paused market",
                "Description": "Lender's mint function does not check whether the supplied market is paused. Even if a market is paused due to insolvency/bugs, an attacker can issue iPTs.",
                "Repair": "Check in mint function that the market is not paused"
            },
            {
                "Location": "Lender.sol",
                "Type": "protocol fee not pulled from user",
                "Description": "The Swivel lend method adds to fees[u] the order fee, but does not pull that fee from the user. It only pulls the order-post-fee amount.",
                "Repair": "Pull lent + totalFee from the user"
            },
            {
                "Location": "Lender.mint()",
                "Type": "Infinite token minting",
                "Description": "Lender.mint() may use p = 0 which will mean principal is the same as principalToken(u, m) i.e. the Illuminate PT. The impact is we will transfer some principal to the Lender contract and it will mint us an equivalent amount of principal tokens. This can be repeated indefinitely thereby minting infinite tokens.",
                "Repair": "Ensure p != uint8(MarketPlace.Principals.Illuminate)"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol';\nimport './Safe.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    error Invalid(string);\n    error Unauthorized();\n    error Exists(string);\n\n    /// @notice address that is allowed to set the lender and marketplace\n    address public admin;\n    /// @notice address used to access the MarketPlace's markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n    /// @notice third party contract needed to lend on APWine\n    address public apwineAddr;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    /// @param a the APWine contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t,\n        address a\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        apwineAddr = a;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists('marketplace');\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set, false otherwise\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exists('lender');\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice redeems underlying token for Illuminate, APWine and Tempus protocols\n    /// @dev Illuminate burns its tokens prior to redemption, unlike APWine and\n    /// Tempus, which redeem PTs to the redeemer, transferring the underlying to\n    /// this redeemer contract. Consequently, only Illuminate's redeem returns funds\n    /// to the user.\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u the underlying token being redeemed\n    /// @param m the maturity of the market being redeemed\n    /// @param o address of the controller or contract that manages the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address o\n    ) public returns (bool) {\n        // Get the address of the principal token being redeemed\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            // Get Illuminate's principal token\n            IERC5095 token = IERC5095(principal);\n            // Get the amount of tokens to be redeemed from the sender\n            uint256 amount = token.balanceOf(msg.sender);\n            // Make sure the market has matured\n            if (block.timestamp < token.maturity()) {\n                revert Invalid('not matured');\n            }\n            // Burn the prinicipal token from Illuminate\n            token.burn(o, amount);\n            // Transfer the original underlying token back to the user\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            emit Redeem(0, u, m, amount);\n        }\n        else {\n            // Get the amount of tokens to be redeemed from the principal token\n            uint256 amount = IERC20(principal).balanceOf(lender);\n            // Transfer the principal token from the lender contract to here\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            if (p == uint8(MarketPlace.Principals.Apwine)) {\n                // Redeem the underlying token from APWine to Illuminate\n                IAPWine(apwineAddr).withdraw(o, amount);\n            } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n                // Redeem the tokens from the Tempus contract to Illuminate\n                ITempus(tempusAddr).redeemToBacking(o, amount, 0, address(this));\n            } else {\n                revert Invalid('principal');\n            }\n            emit Redeem(0, u, m, amount);\n        }\n\n        return true;\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element and Notional protocols\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) public returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Make sure we have the correct principal\n        if (\n            p != uint8(MarketPlace.Principals.Swivel) &&\n            p != uint8(MarketPlace.Principals.Element) &&\n            p != uint8(MarketPlace.Principals.Yield) &&\n            p != uint8(MarketPlace.Principals.Notional)\n        ) {\n            revert Invalid('principal');\n        }\n\n        // The amount redeemed should be the balance of the principal token held by the Illuminate contract\n        uint256 amount = IERC20(principal).balanceOf(lender);\n\n        // Transfer the principal token from the lender contract to here\n        Safe.transferFrom(IERC20(principal), lender, address(this), amount);\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems zc tokens to the sender's address\n            ISwivel(swivelAddr).redeemZcToken(u, m, amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from element\n            IElementToken(principal).withdrawPrincipal(amount, marketPlace);\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems prinicipal tokens from yield\n            IYieldToken(principal).redeem(address(this), address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems the principal token from notional\n            amount = INotional(principal).maxRedeem(address(this));\n        }\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param i forge id used by Pendle to redeem the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        bytes32 i\n    ) public returns (bool) {\n        // Check the principal is Pendle\n        if (p != uint8(MarketPlace.Principals.Pendle)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token that is being redeemed by the user\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Pendle contract\n        IPendle(pendleAddr).redeemAfterExpiry(i, u, m);\n        \n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param d Sense contract that splits the loan's prinicpal and yield\n    /// @param o Sense contract that [d] calls into to adapt the underlying to Sense\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address d,\n        address o\n    ) public returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token for the given market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Sense contract\n        ISense(d).redeem(o, m, amount);\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of the underlying asset\n    /// @param m maturity of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the underlying asset to be burned and sent to the to\n    /// @return bool true if the underlying asset was burned successfully\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    ) public authorized(IMarketPlace(marketPlace).markets(u, m, 0)) returns (bool) {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).markets(u, m, 0));\n\n        // Make sure the market has matured\n        if (block.timestamp < pt.maturity()) {\n            revert Invalid('not matured');\n        }\n\n        // Burn the user's principal tokens\n        pt.burn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), t, a);\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Redeemer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Redeemer.sol#L116",
                "Type": "Funds may be stuck when redeeming for Illuminate",
                "Description": "Funds may be stuck when redeeming for Illuminate.",
                "Repair": "Clarify the purpose of this function and fix the corresponding bug."
            },
            {
                "Location": "Redeemer.sol#L187",
                "Type": "Redeemer.redeem() for Element withdraws PT to wrong address",
                "Description": "Redeemer.redeem() for Element withdraws PT to wrong address.",
                "Repair": "Modify IElementToken(principal).withdrawPrincipal(amount, marketPlace) like this. IElementToken(principal).withdrawPrincipal(amount, address(this));"
            },
            {
                "Location": "Redeemer.sol#redeem()",
                "Type": "Unauthorized function call",
                "Description": "redeem() is a public function, anyone can call it before maturity, and force the whole protocol to sell it's holdings at a discounted price, causing fund loss to the stake holders.",
                "Repair": "Only allow unauthenticated call after maturity"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol';\nimport './Safe.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    error Invalid(string);\n    error Unauthorized();\n    error Exists(string);\n\n    /// @notice address that is allowed to set the lender and marketplace\n    address public admin;\n    /// @notice address used to access the MarketPlace's markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n    /// @notice third party contract needed to lend on APWine\n    address public apwineAddr;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    /// @param a the APWine contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t,\n        address a\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        apwineAddr = a;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists('marketplace');\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set, false otherwise\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exists('lender');\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice redeems underlying token for Illuminate, APWine and Tempus protocols\n    /// @dev Illuminate burns its tokens prior to redemption, unlike APWine and\n    /// Tempus, which redeem PTs to the redeemer, transferring the underlying to\n    /// this redeemer contract. Consequently, only Illuminate's redeem returns funds\n    /// to the user.\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u the underlying token being redeemed\n    /// @param m the maturity of the market being redeemed\n    /// @param o address of the controller or contract that manages the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address o\n    ) public returns (bool) {\n        // Get the address of the principal token being redeemed\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            // Get Illuminate's principal token\n            IERC5095 token = IERC5095(principal);\n            // Get the amount of tokens to be redeemed from the sender\n            uint256 amount = token.balanceOf(msg.sender);\n            // Make sure the market has matured\n            if (block.timestamp < token.maturity()) {\n                revert Invalid('not matured');\n            }\n            // Burn the prinicipal token from Illuminate\n            token.burn(o, amount);\n            // Transfer the original underlying token back to the user\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            emit Redeem(0, u, m, amount);\n        }\n        else {\n            // Get the amount of tokens to be redeemed from the principal token\n            uint256 amount = IERC20(principal).balanceOf(lender);\n            // Transfer the principal token from the lender contract to here\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            if (p == uint8(MarketPlace.Principals.Apwine)) {\n                // Redeem the underlying token from APWine to Illuminate\n                IAPWine(apwineAddr).withdraw(o, amount);\n            } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n                // Redeem the tokens from the Tempus contract to Illuminate\n                ITempus(tempusAddr).redeemToBacking(o, amount, 0, address(this));\n            } else {\n                revert Invalid('principal');\n            }\n            emit Redeem(0, u, m, amount);\n        }\n\n        return true;\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element and Notional protocols\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) public returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Make sure we have the correct principal\n        if (\n            p != uint8(MarketPlace.Principals.Swivel) &&\n            p != uint8(MarketPlace.Principals.Element) &&\n            p != uint8(MarketPlace.Principals.Yield) &&\n            p != uint8(MarketPlace.Principals.Notional)\n        ) {\n            revert Invalid('principal');\n        }\n\n        // The amount redeemed should be the balance of the principal token held by the Illuminate contract\n        uint256 amount = IERC20(principal).balanceOf(lender);\n\n        // Transfer the principal token from the lender contract to here\n        Safe.transferFrom(IERC20(principal), lender, address(this), amount);\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems zc tokens to the sender's address\n            ISwivel(swivelAddr).redeemZcToken(u, m, amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from element\n            IElementToken(principal).withdrawPrincipal(amount, marketPlace);\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems prinicipal tokens from yield\n            IYieldToken(principal).redeem(address(this), address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems the principal token from notional\n            amount = INotional(principal).maxRedeem(address(this));\n        }\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param i forge id used by Pendle to redeem the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        bytes32 i\n    ) public returns (bool) {\n        // Check the principal is Pendle\n        if (p != uint8(MarketPlace.Principals.Pendle)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token that is being redeemed by the user\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Pendle contract\n        IPendle(pendleAddr).redeemAfterExpiry(i, u, m);\n        \n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param d Sense contract that splits the loan's prinicpal and yield\n    /// @param o Sense contract that [d] calls into to adapt the underlying to Sense\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address d,\n        address o\n    ) public returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token for the given market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Sense contract\n        ISense(d).redeem(o, m, amount);\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of the underlying asset\n    /// @param m maturity of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the underlying asset to be burned and sent to the to\n    /// @return bool true if the underlying asset was burned successfully\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    ) public authorized(IMarketPlace(marketPlace).markets(u, m, 0)) returns (bool) {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).markets(u, m, 0));\n\n        // Make sure the market has matured\n        if (block.timestamp < pt.maturity()) {\n            revert Invalid('not matured');\n        }\n\n        // Burn the user's principal tokens\n        pt.burn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), t, a);\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Interfaces.sol\";\nimport \"./ERC20Permit.sol\";\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    constructor(address _underlying, uint256 _maturity, address _redeemer, address l, string memory name_, string memory symbol_, uint8 decimals_) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = l;\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, underlyingAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, underlyingAmount);     \n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, principalAmount);     \n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function mint(address t, uint256 a) external onlyAdmin(lender) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    /// @param a Admin address\n    modifier onlyAdmin(address a) {\n    require(msg.sender == a, 'sender must be admin');\n    _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Redeemer.sol",
            "ERC5095.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Redeemer.sol and ERC5095.sol",
                "Type": "burning tokens from other accounts",
                "Description": "Illuminate PT burns shares from a user supplied address account instead of user's account. With such a discrepancy a malicious user can burn all other's user shares by having the necessary shares on her balance, while burning them from everyone else.",
                "Repair": "Validate and use msg.sender instead of user supplied address"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nlibrary MarketPlace {\n    /// @dev this enum must match the Principals enum in the MarketPlace's contract\n    enum Principals {\n        Illuminate,\n        Swivel,\n        Yield,\n        Element,\n        Pendle,\n        Tempus,\n        Sense,\n        Apwine,\n        Notional\n    }\n}\n\n\n",
        "CodeNames": [
            "MarketPlace.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MarketPlace.sol",
                "Type": "unimplemented function",
                "Description": "safe.sol never implements a transferFrom function meaning it will revert whenever a user calls either function.",
                "Repair": "Implement the missing transferFrom function in safe.sol"
            }
        ]
    }
]