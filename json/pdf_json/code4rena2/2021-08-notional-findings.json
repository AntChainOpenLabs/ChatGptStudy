[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is ERC1967Upgrade {\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n\n\n",
        "CodeNames": [
            "UUPSUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Contracts inheriting UUPSUpgradeable.sol",
                "Type": "Potential DOS",
                "Description": "If the implementation contract is left uninitialized, it is possible for any user to gain ownership of the onlyOwner role in the implementation contract for NoteERC20.sol.",
                "Repair": "Initialize the implementation contract for NoteERC20.sol and check the correct permissions before deploying the proxy contract or performing any contract upgrades"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"../markets/CashGroup.sol\";\nimport \"../markets/AssetRate.sol\";\nimport \"../portfolio/PortfolioHandler.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../math/ABDKMath64x64.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary AssetHandler {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using CashGroup for CashGroupParameters;\n    using AssetRate for AssetRateParameters;\n\n    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\n        return\n            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\n    }\n\n    /// @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method\n    /// calculates the settlement date for any PortfolioAsset.\n    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\n        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: settlement date invalid asset type\n        // 3 month tokens and fCash tokens settle at maturity\n        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\n\n        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\n        // Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:\n        // maturity = tRef + marketLength\n        // Here we calculate:\n        // tRef = maturity - marketLength + 90 days\n        return asset.maturity.sub(marketLength).add(Constants.QUARTER);\n    }\n\n    /// @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.\n    /// The formula is: notional * e^(-rate * timeToMaturity).\n    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)\n        internal\n        pure\n        returns (int256)\n    {\n        int128 expValue =\n            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));\n        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\n        expValue = ABDKMath64x64.exp(expValue * -1);\n        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);\n        int256 discountFactor = ABDKMath64x64.toInt(expValue);\n\n        return discountFactor;\n    }\n\n    /// @notice Present value of an fCash asset without any risk adjustments.\n    function getPresentValue(\n        int256 notional,\n        uint256 maturity,\n        uint256 blockTime,\n        uint256 oracleRate\n    ) internal pure returns (int256) {\n        if (notional == 0) return 0;\n\n        uint256 timeToMaturity = maturity.sub(blockTime);\n        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);\n\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor\n        return notional.mulInRatePrecision(discountFactor);\n    }\n\n    /// @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more\n    /// heavily than the oracle rate given and vice versa for negative fCash.\n    function getRiskAdjustedPresentValue(\n        CashGroupParameters memory cashGroup,\n        int256 notional,\n        uint256 maturity,\n        uint256 blockTime,\n        uint256 oracleRate\n    ) internal pure returns (int256) {\n        if (notional == 0) return 0;\n        uint256 timeToMaturity = maturity.sub(blockTime);\n\n        int256 discountFactor;\n        if (notional > 0) {\n            discountFactor = getDiscountFactor(\n                timeToMaturity,\n                oracleRate.add(cashGroup.getfCashHaircut())\n            );\n        } else {\n            uint256 debtBuffer = cashGroup.getDebtBuffer();\n            // If the adjustment exceeds the oracle rate we floor the value of the fCash\n            // at the notional value. We don't want to require the account to hold more than\n            // absolutely required.\n            if (debtBuffer >= oracleRate) return notional;\n\n            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);\n        }\n\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor\n        return notional.mulInRatePrecision(discountFactor);\n    }\n\n    /// @notice Returns the non haircut claims on cash and fCash by the liquidity token.\n    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\n        internal\n        pure\n        returns (int256 assetCash, int256 fCash)\n    {\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset, get cash claims\n\n        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\n        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\n    }\n\n    /// @notice Returns the haircut claims on cash and fCash\n    /// @return (assetCash, fCash)\n    function getHaircutCashClaims(\n        PortfolioAsset memory token,\n        MarketParameters memory market,\n        CashGroupParameters memory cashGroup\n    ) internal pure returns (int256, int256) {\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset get haircut cash claims\n\n        require(token.currencyId == cashGroup.currencyId); // dev: haircut cash claims, currency id mismatch\n        // This won't overflow, the liquidity token haircut is stored as an uint8\n        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));\n\n        int256 assetCash =\n            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);\n\n        int256 fCash =\n            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);\n\n        return (assetCash, fCash);\n    }\n\n    /// @dev This is here to clean up the stack in getHaircutCashClaims\n    function _calcToken(\n        int256 numerator,\n        int256 tokens,\n        int256 haircut,\n        int256 liquidity\n    ) private pure returns (int256) {\n        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);\n    }\n\n    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\n    function getLiquidityTokenValue(\n        uint256 index,\n        CashGroupParameters memory cashGroup,\n        MarketParameters memory market,\n        PortfolioAsset[] memory assets,\n        uint256 blockTime,\n        bool riskAdjusted\n    ) internal view returns (int256, int256) {\n        PortfolioAsset memory liquidityToken = assets[index];\n        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); // dev: get liquidity token value, not liquidity token\n\n        {\n            (uint256 marketIndex, bool idiosyncratic) =\n                DateTime.getMarketIndex(\n                    cashGroup.maxMarketIndex,\n                    liquidityToken.maturity,\n                    blockTime\n                );\n            // Liquidity tokens can never be idiosyncratic\n            require(!idiosyncratic); // dev: idiosyncratic liquidity token\n\n            // This market will always be initialized, if a liquidity token exists that means the market has some liquidity in it.\n            cashGroup.loadMarket(market, marketIndex, true, blockTime);\n        }\n\n        int256 assetCashClaim;\n        int256 fCashClaim;\n        if (riskAdjusted) {\n            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);\n        } else {\n            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);\n        }\n\n        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and\n        // in that case we know the previous asset will be the matching fCash asset\n        if (\n            index > 0 &&\n            assets[index - 1].currencyId == liquidityToken.currencyId &&\n            assets[index - 1].maturity == liquidityToken.maturity &&\n            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE\n        ) {\n            // Net off the fCashClaim here and we will discount it to present value in the second pass.\n            // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!\n            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);\n            return (assetCashClaim, 0);\n        }\n\n        // If not matching fCash asset found then get the pv directly\n        if (riskAdjusted) {\n            int256 pv =\n                getRiskAdjustedPresentValue(\n                    cashGroup,\n                    fCashClaim,\n                    liquidityToken.maturity,\n                    blockTime,\n                    market.oracleRate\n                );\n\n            return (assetCashClaim, pv);\n        } else {\n            int256 pv =\n                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);\n\n            return (assetCashClaim, pv);\n        }\n    }\n\n    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\n    function getNetCashGroupValue(\n        PortfolioAsset[] memory assets,\n        CashGroupParameters memory cashGroup,\n        MarketParameters memory market,\n        uint256 blockTime,\n        uint256 portfolioIndex\n    ) internal view returns (int256, uint256) {\n        int256 presentValueAsset;\n        int256 presentValueUnderlying;\n\n        // First calculate value of liquidity tokens because we need to net off fCash value\n        // before discounting to present value\n        for (uint256 i = portfolioIndex; i < assets.length; i++) {\n            if (!isLiquidityToken(assets[i].assetType)) continue;\n            if (assets[i].currencyId != cashGroup.currencyId) break;\n\n            (int256 assetCashClaim, int256 pv) =\n                getLiquidityTokenValue(\n                    i,\n                    cashGroup,\n                    market,\n                    assets,\n                    blockTime,\n                    true // risk adjusted\n                );\n\n            presentValueAsset = presentValueAsset.add(assetCashClaim);\n            presentValueUnderlying = presentValueUnderlying.add(pv);\n        }\n\n        uint256 j = portfolioIndex;\n        for (; j < assets.length; j++) {\n            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;\n            // If we hit a different currency id then we've accounted for all assets in this currency\n            if (assets[j].currencyId != cashGroup.currencyId) break;\n\n            uint256 maturity = assets[j].maturity;\n            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);\n\n            int256 pv =\n                getRiskAdjustedPresentValue(\n                    cashGroup,\n                    assets[j].notional,\n                    maturity,\n                    blockTime,\n                    oracleRate\n                );\n            presentValueUnderlying = presentValueUnderlying.add(pv);\n        }\n\n        presentValueAsset = presentValueAsset.add(\n            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)\n        );\n\n        return (presentValueAsset, j);\n    }\n}\n\n\n",
        "CodeNames": [
            "AssetHandler.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AssetHandler.getLiquidityTokenValue function",
                "Type": "Manipulation of liquidity token value",
                "Description": "The liquidity token value is the sum of the value of the individual claims on cash and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, which means the value depends on the current market reserves which can be manipulated.",
                "Repair": "Do not use the current market reserves to determine the value of LP tokens. Implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../global/Types.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface WETH9 {\n    function withdraw(uint256 wad) external;\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n}\n\ninterface IEscrow {\n    function getBalances(address account) external view returns (int256[] memory);\n}\n\ninterface INotionalV1Erc1155 {\n    /** Notional V1 Types */\n    struct Deposit {\n        // Currency Id to deposit\n        uint16 currencyId;\n        // Amount of tokens to deposit\n        uint128 amount;\n    }\n\n    /**\n     * Used to describe withdraws in ERC1155.batchOperationWithdraw\n     */\n    struct Withdraw {\n        // Destination of the address to withdraw to\n        address to;\n        // Currency Id to withdraw\n        uint16 currencyId;\n        // Amount of tokens to withdraw\n        uint128 amount;\n    }\n\n    enum TradeType {TakeCurrentCash, TakefCash, AddLiquidity, RemoveLiquidity}\n\n    /**\n     * Used to describe a trade in ERC1155.batchOperation\n     */\n    struct Trade {\n        TradeType tradeType;\n        uint8 cashGroup;\n        uint32 maturity;\n        uint128 amount;\n        bytes slippageData;\n    }\n\n    function batchOperationWithdraw(\n        address account,\n        uint32 maxTime,\n        Deposit[] memory deposits,\n        Trade[] memory trades,\n        Withdraw[] memory withdraws\n    ) external payable;\n}\n\ncontract NotionalV1ToNotionalV2 {\n    IEscrow public immutable Escrow;\n    NotionalProxy public immutable NotionalV2;\n    INotionalV1Erc1155 public immutable NotionalV1Erc1155;\n    WETH9 public immutable WETH;\n    IERC20 public immutable WBTC;\n\n    uint16 internal constant V1_ETH = 0;\n    uint16 internal constant V1_DAI = 1;\n    uint16 internal constant V1_USDC = 2;\n    uint16 internal constant V1_WBTC = 3;\n\n    uint16 public constant V2_ETH = 1;\n    uint16 public immutable V2_DAI;\n    uint16 public immutable V2_USDC;\n    uint16 public immutable V2_WBTC;\n\n    constructor(\n        IEscrow escrow_,\n        NotionalProxy notionalV2_,\n        INotionalV1Erc1155 erc1155_,\n        WETH9 weth_,\n        IERC20 wbtc_,\n        uint16 v2Dai_,\n        uint16 v2USDC_,\n        uint16 v2WBTC_\n    ) {\n        Escrow = escrow_;\n        NotionalV2 = notionalV2_;\n        NotionalV1Erc1155 = erc1155_;\n        WETH = weth_;\n        WBTC = wbtc_;\n        V2_DAI = v2Dai_;\n        V2_USDC = v2USDC_;\n        V2_WBTC = v2WBTC_;\n    }\n\n    function enableWBTC() external {\n        WBTC.approve(address(NotionalV2), type(uint256).max);\n    }\n\n    function migrateDaiEther(\n        uint128 v1RepayAmount,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        // borrow on notional via special flash loan facility\n        //  - borrow repayment amount\n        //  - withdraw to wallet\n        // receive callback (tokens transferred to borrowing account)\n        //   -> inside callback\n        //   -> repay Notional V1\n        //   -> deposit collateral to notional v2 (account needs to have set approvals)\n        //   -> exit callback\n        // inside original borrow, check FC\n        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_ETH, V2_ETH);\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function migrateUSDCEther(\n        uint128 v1RepayAmount,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_ETH, V2_ETH);\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function migrateDaiWBTC(\n        uint128 v1RepayAmount,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_WBTC, V2_WBTC);\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function migrateUSDCWBTC(\n        uint128 v1RepayAmount,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_WBTC, V2_WBTC);\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n        (\n            uint16 v1DebtCurrencyId,\n            uint128 v1RepayAmount,\n            uint16 v1CollateralId,\n            uint16 v2CollateralId\n        ) = abi.decode(callbackData, (uint16, uint128, uint16, uint16));\n\n        int256[] memory balances = Escrow.getBalances(account);\n        int256 collateralBalance =\n            (v1CollateralId == V1_ETH ? balances[V1_ETH] : balances[V1_WBTC]);\n        require(collateralBalance > 0);\n\n        {\n            INotionalV1Erc1155.Deposit[] memory deposits = new INotionalV1Erc1155.Deposit[](1);\n            INotionalV1Erc1155.Trade[] memory trades = new INotionalV1Erc1155.Trade[](0);\n            INotionalV1Erc1155.Withdraw[] memory withdraws = new INotionalV1Erc1155.Withdraw[](1);\n\n            // This will deposit what was borrowed from the account's wallet\n            deposits[0].currencyId = v1DebtCurrencyId;\n            deposits[0].amount = v1RepayAmount;\n\n            // This will withdraw to the current contract the collateral to repay the flash loan\n            withdraws[0].currencyId = v1CollateralId;\n            withdraws[0].to = address(this);\n            withdraws[0].amount = uint128(collateralBalance);\n\n            NotionalV1Erc1155.batchOperationWithdraw(\n                account,\n                uint32(block.timestamp),\n                deposits,\n                trades,\n                withdraws\n            );\n        }\n\n        // Overflow checked above, cannot be negative\n        uint256 v2CollateralBalance = uint256(collateralBalance);\n        if (v2CollateralId == V2_ETH) {\n            // Notional V1 uses WETH, but V2 uses ETH\n            WETH.withdraw(v2CollateralBalance);\n            NotionalV2.depositUnderlyingToken{value: v2CollateralBalance}(\n                account,\n                v2CollateralId,\n                v2CollateralBalance\n            );\n        } else {\n            NotionalV2.depositUnderlyingToken(account, v2CollateralId, v2CollateralBalance);\n        }\n\n        // When this exits it will do a free collateral check\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "NotionalV1ToNotionalV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NotionalV1ToNotionalV2.notionalCallback function",
                "Type": "Access restriction bypass",
                "Description": "The access restrictions on NotionalV1ToNotionalV2.notionalCallback can be circumvented by simply providing sender = this as sender is a parameter of the function that can be chosen by the attacker.",
                "Repair": "Fix the authorization check"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/nTokenERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice ERC20 proxy for nToken contracts that forwards calls to the Router, all nToken\n/// balances and allowances are stored in at single address for gas efficiency. This contract\n/// is used simply for ERC20 compliance.\ncontract nTokenERC20Proxy is IERC20 {\n    /// @notice Will be \"nToken {Underlying Token}.name()\"\n    string public name;\n\n    /// @notice Will be \"n{Underlying Token}.symbol()\"\n    string public symbol;\n\n    /// @notice Inherits from Constants.INTERNAL_TOKEN_DECIMALS\n    uint8 public constant decimals = 8;\n\n    /// @notice Address of the notional proxy\n    nTokenERC20 public immutable proxy;\n\n    /// @notice Currency id that this nToken refers to\n    uint16 public immutable currencyId;\n\n    constructor(\n        nTokenERC20 proxy_,\n        uint16 currencyId_,\n        string memory underlyingName_,\n        string memory underlyingSymbol_\n    ) {\n        proxy = proxy_;\n        currencyId = currencyId_;\n        name = string(abi.encodePacked(\"nToken \", underlyingName_));\n        symbol = string(abi.encodePacked(\"n\", underlyingSymbol_));\n    }\n\n    /// @notice Total number of tokens in circulation\n    function totalSupply() external view override returns (uint256) {\n        // Total supply is looked up via the token address\n        return proxy.nTokenTotalSupply(address(this));\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function balanceOf(address account) external view override returns (uint256) {\n        return proxy.nTokenBalanceOf(currencyId, account);\n    }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param account The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function allowance(address account, address spender) external view override returns (uint256) {\n        return proxy.nTokenTransferAllowance(currencyId, account, spender);\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev This will overwrite the approval amount for `spender`\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n    ///  emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        // Emit approvals here so that they come from the correct contract address\n        emit Approval(msg.sender, spender, amount);\n        return proxy.nTokenTransferApprove(currencyId, msg.sender, spender, amount);\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev emit:Transfer\n    /// @param to The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        // Emit transfer events here so they come from the correct contract\n        emit Transfer(msg.sender, to, amount);\n        return proxy.nTokenTransfer(currencyId, msg.sender, to, amount);\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev emit:Transfer emit:Approval\n    /// @param from The address of the source account\n    /// @param to The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        (bool success, uint256 newAllowance) =\n            proxy.nTokenTransferFrom(currencyId, msg.sender, from, to, amount);\n\n        // Emit transfer events here so they come from the correct contract\n        emit Transfer(from, to, amount);\n        emit Approval(msg.sender, from, newAllowance);\n\n        return success;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in asset tokens\n    function getPresentValueAssetDenominated() external view returns (int256) {\n        return proxy.nTokenPresentValueAssetDenominated(currencyId);\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in underlying\n    function getPresentValueUnderlyingDenominated() external view returns (int256) {\n        return proxy.nTokenPresentValueUnderlyingDenominated(currencyId);\n    }\n\n    /// @dev nTokens should never accept any erc1155 transfers of fCash\n    function onERC1155Received(\n        address, /* _operator */\n        address, /* _from */\n        uint256, /* _id */\n        uint256, /* _value */\n        bytes calldata /* _data */\n    ) external pure returns (bytes4) {\n        return 0;\n    }\n\n    /// @dev nTokens should never accept any erc1155 transfers of fCash\n    function onERC1155BatchReceived(\n        address, /* _operator */\n        address, /* _from */\n        uint256[] calldata, /* _ids */\n        uint256[] calldata, /* _values */\n        bytes calldata /* _data */\n    ) external pure returns (bytes4) {\n        return 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "nTokenERC20Proxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "nTokenERC20Proxy functions",
                "Type": "Event emission on unsuccessful action",
                "Description": "The nTokenERC20Proxy functions emit events all the time, even if the return value from the inner call returns false, indicating an unsuccessful action.",
                "Repair": "Only emit events on success"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/compound/CTokenInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CompoundToNotionalV2 {\n    NotionalProxy public immutable NotionalV2;\n    address public owner;\n\n    constructor(NotionalProxy notionalV2_) {\n        NotionalV2 = notionalV2_;\n        owner = msg.sender;\n    }\n\n    function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n\n    function migrateBorrowFromCompound(\n        address cTokenBorrow,\n        uint256 cTokenRepayAmount,\n        uint16[] memory notionalV2CollateralIds,\n        uint256[] memory notionalV2CollateralAmounts,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        // borrow on notional via special flash loan facility\n        //  - borrow repayment amount\n        //  - withdraw to wallet, redeem to underlying\n        // receive callback (tokens transferred to borrowing account)\n        //   -> inside callback\n        //   -> repayBorrowBehalf(account, repayAmount)\n        //   -> deposit cToken to notional (account needs to have set approvals)\n        //   -> exit callback\n        // inside original borrow, check FC\n        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);\n        if (cTokenRepayAmount == 0) {\n            // Set the entire borrow balance if it is not set\n            cTokenRepayAmount = borrowBalance;\n        } else {\n            // Check that the cToken repayment amount is not more than required\n            require(cTokenRepayAmount <= borrowBalance, \"Invalid repayment amount\");\n        }\n\n        bytes memory encodedData = abi.encode(\n            cTokenBorrow,\n            cTokenRepayAmount,\n            notionalV2CollateralIds,\n            notionalV2CollateralAmounts\n        );\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n\n        // Transfer in the underlying amount that was borrowed\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n\n        // Use the amount transferred to repay the borrow\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            // Transfer the collateral to this contract so we can deposit it\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n\n            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n\n        // When this exits a free collateral check will be triggered\n    }\n\n    receive() external payable {\n        // This contract cannot migrate ETH loans because there is no way\n        // to do transferFrom on ETH\n        revert(\"Cannot transfer ETH\");\n    }\n}\n\n",
        "CodeNames": [
            "CompoundToNotionalV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CompoundToNotionalV2.enableToken",
                "Type": "ERC20 missing return value check",
                "Description": "The enableToken function performs an ERC20.approve() call but does not check the success return value.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens"
            },
            {
                "Location": "CompoundToNotionalV2.notionalCallback",
                "Type": "ERC20 return values not checked",
                "Description": "Some tokens (like USDT) don't correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a success boolean.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens"
            },
            {
                "Location": "CompoundToNotionalV2.notionalCallback",
                "Type": "Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed",
                "Description": "The access restrictions can be circumvented by simply providing sender = this, as sender is a parameter of the function that can be chosen by the attacker.",
                "Repair": "Fix the authorization check"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "N/A",
                "Type": "Forced liquidations by borrowing large amounts of an asset",
                "Description": "Consider an attacker who borrows enough to greatly increase the oracle rate.",
                "Repair": "N/A"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./actions/nTokenAction.sol\";\nimport \"./actions/nTokenMintAction.sol\";\nimport \"./actions/nTokenRedeemAction.sol\";\nimport \"../global/StorageLayoutV1.sol\";\nimport \"../global/Types.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"interfaces/notional/nERC1155Interface.sol\";\nimport \"interfaces/notional/NotionalGovernance.sol\";\n\n/**\n * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage\n * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing\n * contracts.\n *\n * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also\n * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a\n * new Router with the new hardcoded addresses will then be deployed and upgraded into place.\n */\ncontract Router is StorageLayoutV1 {\n    // These contract addresses cannot be changed once set by the constructor\n    address public immutable GOVERNANCE;\n    address public immutable VIEWS;\n    address public immutable INITIALIZE_MARKET;\n    address public immutable NTOKEN_ACTIONS;\n    address public immutable NTOKEN_REDEEM;\n    address public immutable BATCH_ACTION;\n    address public immutable ACCOUNT_ACTION;\n    address public immutable ERC1155;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n    address public immutable cETH;\n\n    constructor(\n        address governance_,\n        address views_,\n        address initializeMarket_,\n        address nTokenActions_,\n        address nTokenRedeem_,\n        address batchAction_,\n        address accountAction_,\n        address erc1155_,\n        address liquidateCurrency_,\n        address liquidatefCash_,\n        address cETH_\n    ) {\n        GOVERNANCE = governance_;\n        VIEWS = views_;\n        INITIALIZE_MARKET = initializeMarket_;\n        NTOKEN_ACTIONS = nTokenActions_;\n        NTOKEN_REDEEM = nTokenRedeem_;\n        BATCH_ACTION = batchAction_;\n        ACCOUNT_ACTION = accountAction_;\n        ERC1155 = erc1155_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n        cETH = cETH_;\n    }\n\n    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {\n        // Cannot re-initialize once the contract has been initialized, ownership transfer does not\n        // allow address to be set back to zero\n        require(owner == address(0), \"R: already initialized\");\n\n        // Allow list currency to be called by this contract for the purposes of\n        // initializing ETH as a currency\n        owner = msg.sender;\n        // List ETH as currency id == 1, NOTE: return value is ignored here\n        (bool status, ) =\n            address(GOVERNANCE).delegatecall(\n                abi.encodeWithSelector(\n                    NotionalGovernance.listCurrency.selector,\n                    TokenStorage(cETH, false, TokenType.cETH),\n                    // No underlying set for cETH\n                    TokenStorage(address(0), false, TokenType.Ether),\n                    address(0),\n                    false,\n                    130, // Initial settings of 130 buffer\n                    70,  // 70% haircut\n                    105  // 105 liquidation discount\n                )\n            );\n        require(status);\n\n        owner = owner_;\n        // The pause guardian may downgrade the router to the pauseRouter\n        pauseRouter = pauseRouter_;\n        pauseGuardian = pauseGuardian_;\n    }\n\n    /// @notice Returns the implementation contract for the method signature\n    /// @param sig method signature to call\n    /// @return implementation address\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        if (\n            sig == NotionalProxy.batchBalanceAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||\n            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector\n        ) {\n            return BATCH_ACTION;\n        }\n\n        if (\n            sig == nTokenAction.nTokenTotalSupply.selector ||\n            sig == nTokenAction.nTokenBalanceOf.selector ||\n            sig == nTokenAction.nTokenTransferAllowance.selector ||\n            sig == nTokenAction.nTokenTransferApprove.selector ||\n            sig == nTokenAction.nTokenTransfer.selector ||\n            sig == nTokenAction.nTokenTransferFrom.selector ||\n            sig == nTokenAction.nTokenClaimIncentives.selector ||\n            sig == nTokenAction.nTokenTransferApproveAll.selector ||\n            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||\n            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector\n        ) {\n            return NTOKEN_ACTIONS;\n        }\n\n        if (\n            sig == NotionalProxy.depositUnderlyingToken.selector ||\n            sig == NotionalProxy.depositAssetToken.selector ||\n            sig == NotionalProxy.withdraw.selector ||\n            sig == NotionalProxy.settleAccount.selector ||\n            sig == NotionalProxy.enableBitmapCurrency.selector\n        ) {\n            return ACCOUNT_ACTION;\n        }\n\n        if (\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\n            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector\n        ) {\n            return NTOKEN_REDEEM;\n        }\n\n        if (\n            sig == nERC1155Interface.supportsInterface.selector ||\n            sig == nERC1155Interface.balanceOf.selector ||\n            sig == nERC1155Interface.balanceOfBatch.selector ||\n            sig == nERC1155Interface.safeTransferFrom.selector ||\n            sig == nERC1155Interface.safeBatchTransferFrom.selector ||\n            sig == nERC1155Interface.decodeToAssets.selector ||\n            sig == nERC1155Interface.encodeToId.selector ||\n            sig == nERC1155Interface.setApprovalForAll.selector ||\n            sig == nERC1155Interface.isApprovedForAll.selector\n        ) {\n            return ERC1155;\n        }\n\n        if (\n            sig == NotionalProxy.liquidateLocalCurrency.selector ||\n            sig == NotionalProxy.liquidateCollateralCurrency.selector ||\n            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            sig == NotionalProxy.liquidatefCashLocal.selector ||\n            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||\n            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            sig == NotionalProxy.initializeMarkets.selector ||\n            sig == NotionalProxy.sweepCashIntoMarkets.selector\n        ) {\n            return INITIALIZE_MARKET;\n        }\n\n        if (\n            sig == NotionalGovernance.listCurrency.selector ||\n            sig == NotionalGovernance.enableCashGroup.selector ||\n            sig == NotionalGovernance.updateCashGroup.selector ||\n            sig == NotionalGovernance.updateAssetRate.selector ||\n            sig == NotionalGovernance.updateETHRate.selector ||\n            sig == NotionalGovernance.transferOwnership.selector ||\n            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||\n            sig == NotionalGovernance.updateDepositParameters.selector ||\n            sig == NotionalGovernance.updateInitializationParameters.selector ||\n            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||\n            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||\n            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||\n            sig == NotionalProxy.upgradeTo.selector ||\n            sig == NotionalProxy.upgradeToAndCall.selector\n        ) {\n            return GOVERNANCE;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n\n    // NOTE: receive() is overridden in \"nProxy\" to allow for eth transfers to succeed\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"../../proxy/utils/UUPSUpgradeable.sol\";\n\n/// @title Note ERC20 Token\n/// Fork of Compound Comp token at commit hash\n/// https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\ncontract NoteERC20 is Initializable, UUPSUpgradeable {\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Notional\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"NOTE\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 8;\n\n    /// @notice Total number of tokens in circulation (100 million NOTE)\n    uint256 public constant totalSupply = 100000000e8;\n\n    /// @notice Notional router address\n    NotionalProxy public notionalProxy;\n\n    // Allowance amounts on behalf of others\n    mapping(address => mapping(address => uint96)) internal allowances;\n\n    // Official record of token balances for each account\n    mapping(address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice Owner address which can upgrade the tokens implementation\n    address public owner;\n\n    /// @notice Emitted when the ownership of the contract is transferred\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @notice Initialize note token with initial grants\n    /// @param initialAccounts initial address to grant tokens to\n    /// @param initialGrantAmount amount to grant address initially\n    function initialize(\n        address[] calldata initialAccounts,\n        uint96[] calldata initialGrantAmount,\n        address owner_\n    ) public initializer {\n        require(initialGrantAmount.length == initialAccounts.length);\n\n        uint96 totalGrants = 0;\n        for (uint256 i = 0; i < initialGrantAmount.length; i++) {\n            totalGrants = _add96(totalGrants, initialGrantAmount[i], \"\");\n            require(balances[initialAccounts[i]] == 0, \"Duplicate account\");\n            balances[initialAccounts[i]] = initialGrantAmount[i];\n\n            emit Transfer(address(0), initialAccounts[i], initialGrantAmount[i]);\n        }\n\n        require(totalGrants == totalSupply);\n        owner = owner_;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function activateNotional(NotionalProxy notionalProxy_) external onlyOwner {\n        require(address(notionalProxy) == address(0), \"Notional Proxy already initialized\");\n        Address.isContract(address(notionalProxy_));\n        notionalProxy = notionalProxy_;\n    }\n\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n    /// Can only be called by the current owner.\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /// @dev Only the owner may upgrade the contract\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner { }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param account The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function allowance(address account, address spender) external view returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev This will overwrite the approval amount for `spender`\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n    ///  emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 rawAmount) external returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = _safe96(rawAmount, \"Note::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function balanceOf(address account) external view returns (uint256) {\n        return balances[account];\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev emit:Transfer\n    /// @param dst The address of the destination account\n    /// @param rawAmount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 rawAmount) external returns (bool) {\n        uint96 amount = _safe96(rawAmount, \"Note::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev emit:Transfer emit:Approval\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param rawAmount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 rawAmount\n    ) external returns (bool) {\n        // Short circuit transfer execution and return true. It may be the case that external\n        // logic tries to execute a zero transfer but don't emit events here.\n        if (rawAmount == 0) {\n            // Emit a zero transfer event for ERC20 token compatibility\n            emit Transfer(src, dst, 0);\n            return true;\n        }\n\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = _safe96(rawAmount, \"Note::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance =\n                _sub96(\n                    spenderAllowance,\n                    amount,\n                    \"Note::transferFrom: transfer amount exceeds spender allowance\"\n                );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /// @notice Delegate votes from `msg.sender` to `delegatee`\n    /// @param delegatee The address to delegate votes to\n    /// @dev emit:DelegatesChanged\n    function delegate(address delegatee) public {\n        _delegate(msg.sender, delegatee);\n    }\n\n    /// @notice Delegates votes from signatory to `delegatee`\n    /// @dev emit:DelegatesChanged\n    /// @param delegatee The address to delegate votes to\n    /// @param nonce The contract state required to match the signature\n    /// @param expiry The time at which to expire the signature\n    /// @param v The recovery byte of the signature\n    /// @param r Half of the ECDSA signature pair\n    /// @param s Half of the ECDSA signature pair\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        // ECDSA will check if address is zero inside\n        address signatory = ECDSA.recover(digest, v, r, s);\n        require(nonce == nonces[signatory]++, \"Note::delegateBySig: invalid nonce\");\n        require(block.timestamp <= expiry, \"Note::delegateBySig: signature expired\");\n        _delegate(signatory, delegatee);\n    }\n\n    /// @notice Gets the current votes balance for `account`\n    /// @param account The address to get votes balance\n    /// @return The number of current votes for `account`\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        uint96 currentVotes = nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n        return\n            _add96(\n                currentVotes,\n                getUnclaimedVotes(account),\n                \"Note::getCurrentVotes: uint96 overflow\"\n            );\n    }\n\n    /// @notice Determine the prior number of votes for an account as of a block number\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    /// @param account The address of the account to check\n    /// @param blockNumber The block number to get the vote balance at\n    /// @return The number of votes the account had as of the given block\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"Note::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return _add96(\n                checkpoints[account][nCheckpoints - 1].votes,\n                getUnclaimedVotes(account),\n                \"Note::getPriorVotes: uint96 overflow\"\n            );\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return\n                    _add96(\n                        cp.votes,\n                        getUnclaimedVotes(account),\n                        \"Note::getPriorVotes: uint96 overflow\"\n                    );\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n\n        return\n            _add96(\n                checkpoints[account][lower].votes,\n                getUnclaimedVotes(account),\n                \"Note::getPriorVotes: uint96 overflow\"\n            );\n    }\n\n    /// @notice Notional counts unclaimed incentives as part of a users' voting power. There is no\n    /// need to checkpoint these values because they cannot be transferred or delegated.\n    /// @param account the address of the Notional account to check\n    /// @return Total number of unclaimed tokens accrued on the Notional account\n    function getUnclaimedVotes(address account) public view returns (uint96) {\n        // If the notional proxy is not set then there are no unclaimed votes\n        if (address(notionalProxy) == address(0)) return 0;\n\n        uint256 votes = notionalProxy.nTokenGetClaimableIncentives(account, block.timestamp);\n        require(votes <= type(uint96).max);\n        return uint96(votes);\n    }\n\n    /// @dev Changes delegates from one address to another\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    /// @dev Transfers tokens and inherits the delegate from the destination address\n    function _transferTokens(\n        address src,\n        address dst,\n        uint96 amount\n    ) internal {\n        require(src != address(0), \"Note::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"Note::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = _sub96(\n            balances[src],\n            amount,\n            \"Note::_transferTokens: transfer amount exceeds balance\"\n        );\n        balances[dst] = _add96(\n            balances[dst],\n            amount,\n            \"Note::_transferTokens: transfer amount overflows\"\n        );\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    /// @dev Transfers delegates and writes a checkpoint for `getPriorVotes` to use\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew =\n                    _sub96(srcRepOld, amount, \"Note::_moveVotes: vote amount underflow\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew =\n                    _add96(dstRepOld, amount, \"Note::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    /// @dev Writes checkpoints for `getPriorVotes`, this is somewhat inefficient as it uses\n    /// 20000 gas per transfer of delegated tokens. The goal is prevent voters from borrowing\n    /// a large number of votes for a short period to vote for or against a proposal. It's unclear\n    /// if there is a better model than this one here. Using only a single checkpoint means that\n    /// a delegate could be the victim of a denial of service attack where an attacker continually\n    /// transfers tokens to them to prevent them from voting.\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber =\n            _safe32(block.number, \"Note::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function _safe32(uint256 n, string memory errorMessage) private pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function _safe96(uint256 n, string memory errorMessage) private pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function _add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) private pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function _sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) private pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function _getChainId() private pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\n\n",
        "CodeNames": [
            "Router.sol",
            "NoteERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NoteERC20.sol and Router.sol",
                "Type": "DOS by Frontrunning NoteERC20 initialize() Function",
                "Description": "The scripts/deployment.py does not follow this pattern when deploying NoteERC20.sol's proxy contract.",
                "Repair": "Ensure the NoteERC20.sol proxy contract is deployed and initialized in the same transaction, or ensure the initialize() function is callable only by the deployer of the NoteERC20.sol contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/compound/CEtherInterface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    currencyId,\n                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))\n                )\n            );\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {\n        bytes32 slot = _getSlot(currencyId, underlying);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n        address tokenAddress = address(bytes20(data << 96));\n        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;\n        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));\n        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));\n\n        return\n            Token({\n                tokenAddress: tokenAddress,\n                hasTransferFee: tokenHasTransferFee,\n                decimals: int256(10**tokenDecimalPlaces),\n                tokenType: tokenType\n            });\n    }\n\n    /// @notice Sets a token for a currency id.\n    function setToken(\n        uint256 currencyId,\n        bool underlying,\n        TokenStorage memory tokenStorage\n    ) internal {\n        bytes32 slot = _getSlot(currencyId, underlying);\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Specific storage for Ether token type\n            bytes32 etherData =\n                ((bytes32(bytes20(address(0))) >> 96) |\n                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |\n                    bytes32(uint256(18) << 168) |\n                    bytes32(uint256(TokenType.Ether) << 176));\n\n            assembly {\n                sstore(slot, etherData)\n            }\n\n            return;\n        }\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n\n        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();\n        require(decimalPlaces != 0, \"TH: decimals is zero\");\n\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = getToken(currencyId, underlying);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        if (tokenStorage.tokenType == TokenType.cToken) {\n            // Set the approval for the underlying so that we can mint cTokens\n            Token memory underlyingToken = getToken(currencyId, true);\n            ERC20(underlyingToken.tokenAddress).approve(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );\n        }\n\n        bytes1 transferFee =\n            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;\n\n        bytes32 data =\n            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |\n                (bytes32(bytes1(transferFee)) >> 88) |\n                bytes32(uint256(decimalPlaces) << 168) |\n                bytes32(uint256(tokenStorage.tokenType) << 176));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }\n\n    /// @notice This method only works with cTokens, it's unclear how we can make this more generic\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\n        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        uint256 success;\n        if (token.tokenType == TokenType.cToken) {\n            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\n        } else if (token.tokenType == TokenType.cETH) {\n            // Reverts on error\n            CEtherInterface(token.tokenAddress).mint{value: msg.value}();\n        } else {\n            revert(); // dev: non mintable token\n        }\n\n        require(success == 0, \"Mint fail\");\n        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        // This is the starting and ending balance in external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    function redeem(\n        Token memory assetToken,\n        Token memory underlyingToken,\n        uint256 assetAmountExternal\n    ) internal returns (int256) {\n        uint256 startingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            startingBalance = address(this).balance;\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        } else {\n            revert(); // dev: non redeemable failure\n        }\n\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\n        require(success == 0, \"Redeem fail\");\n\n        uint256 endingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            endingBalance = address(this).balance;\n        } else {\n            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        }\n\n        // Underlying token external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\n    /// precision.\n    function transfer(\n        Token memory token,\n        address account,\n        int256 netTransferExternal\n    ) internal returns (int256) {\n        if (netTransferExternal > 0) {\n            // Deposits must account for transfer fees.\n            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));\n        } else if (token.tokenType == TokenType.Ether) {\n            require(netTransferExternal < 0); // dev: cannot transfer ether\n            address payable accountPayable = payable(account);\n            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\n            // ETH they will have to withdraw the cETH token and then redeem it manually.\n            accountPayable.transfer(uint256(netTransferExternal.neg()));\n        } else {\n            safeTransferOut(\n                IERC20(token.tokenAddress),\n                account,\n                uint256(netTransferExternal.neg())\n            );\n        }\n\n        return netTransferExternal;\n    }\n\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\n    /// precision.\n    function _deposit(\n        Token memory token,\n        address account,\n        uint256 amount\n    ) private returns (int256) {\n        if (token.hasTransferFee) {\n            // Must deposit from the token and calculate the net transfer\n            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n            safeTransferIn(IERC20(token.tokenAddress), account, amount);\n            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n            return int256(endingBalance.sub(startingBalance));\n        }\n\n        safeTransferIn(IERC20(token.tokenAddress), account, amount);\n        return int256(amount);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);\n    }\n\n    function safeTransferOut(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transfer(account, amount);\n        checkReturnCode();\n    }\n\n    function safeTransferIn(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transferFrom(account, address(this), amount);\n        checkReturnCode();\n    }\n\n    function checkReturnCode() private pure {\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {\n                    // This is a non-standard ERC-20\n                    success := not(0) // set success to true\n                }\n                case 32 {\n                    // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0) // Set `success = returndata` of external call\n                }\n                default {\n                    // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        require(success, \"Transfer Failed\");\n    }\n}\n\n\n",
        "CodeNames": [
            "TokenHandler.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TokenHandler.safeTransferOut",
                "Type": "TokenHandler.safeTransferOut does not work on non-standard compliant tokens like USDT",
                "Description": "The TokenHandler.safeTransferOut function uses the standard IERC20 function for the transfer call and proceeds with a checkReturnCode function to handle non-standard compliant tokens that don't return a return value.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens"
            },
            {
                "Location": "TokenHandler.sol, L174",
                "Type": "bad practice",
                "Description": "The use of .transfer in TokenHandler.sol L174 to send ether is now considered bad practice as gas costs can change which would break the code.",
                "Repair": "Use call instead of .transfer and check for reentrancy"
            },
            {
                "Location": "TokenHandler.safeTransferIn",
                "Type": "non-standard compliant token transfer",
                "Description": "The TokenHandler.safeTransferIn function uses the standard IERC20 function for the transfer call and proceeds with a checkReturnCode function to handle non-standard compliant tokens that don't return a return value. However, this does not work, as calling token.transferFrom(account, amount) already reverts if the token does not return a return value.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens"
            },
            {
                "Location": "TokenHandler.setToken",
                "Type": "missing return value check",
                "Description": "The setToken function performs an ERC20.approve() call but does not check the success return value.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeApprove function that handles the return value check as well as non-standard-compliant tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../internal/nTokenHandler.sol\";\nimport \"../../internal/markets/AssetRate.sol\";\nimport \"../../internal/balances/BalanceHandler.sol\";\nimport \"../../internal/balances/Incentives.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"interfaces/notional/nTokenERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract nTokenAction is StorageLayoutV1, nTokenERC20 {\n    using BalanceHandler for BalanceState;\n    using AssetRate for AssetRateParameters;\n    using AccountContextHandler for AccountContext;\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    /// @notice Total number of tokens in circulation\n    /// @param nTokenAddress The address of the nToken\n    /// @return totalSupply number of tokens held\n    function nTokenTotalSupply(address nTokenAddress)\n        external\n        view\n        override\n        returns (uint256 totalSupply)\n    {\n        // prettier-ignore\n        (\n            totalSupply,\n            /* integralTotalSupply */,\n            /* lastSupplyChangeTime */\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function nTokenBalanceOf(uint16 currencyId, address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // prettier-ignore\n        (\n            /* int cashBalance */,\n            int256 nTokenBalance,\n            /* uint lastClaimTime */,\n            /* uint lastClaimIntegralSupply */\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\n\n        require(nTokenBalance >= 0); // dev: negative nToken balance\n        return uint256(nTokenBalance);\n    }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param owner The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function nTokenTransferAllowance(\n        uint16 currencyId,\n        address owner,\n        address spender\n    ) external view override returns (uint256) {\n        // This whitelist allowance supersedes any specific allowances\n        uint256 allowance = nTokenWhitelist[owner][spender];\n        if (allowance > 0) return allowance;\n\n        return nTokenAllowance[owner][spender][currencyId];\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev Can only be called via the nToken proxy\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApprove(\n        uint16 currencyId,\n        address owner,\n        address spender,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        nTokenAllowance[owner][spender][currencyId] = amount;\n\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param from The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransfer(\n        uint16 currencyId,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        return _transfer(currencyId, from, to, amount);\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param currencyId Currency id of the nToken\n    /// @param spender The address of the original caller\n    /// @param from The address of the source account\n    /// @param to The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransferFrom(\n        uint16 currencyId,\n        address spender,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool, uint256) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        uint256 allowance = nTokenWhitelist[from][spender];\n\n        if (allowance > 0) {\n            // This whitelist allowance supersedes any specific allowances\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenWhitelist[from][spender] = allowance;\n        } else {\n            // This is the specific allowance for the nToken.\n            allowance = nTokenAllowance[from][spender][currencyId];\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenAllowance[from][spender][currencyId] = allowance;\n        }\n\n        bool success = _transfer(currencyId, from, to, amount);\n        return (success, allowance);\n    }\n\n    /// @notice Will approve all nToken transfers to the specific sender. This is used for simplifying UX, a user can approve\n    /// all token transfers to an external exchange or protocol in a single txn. This must be called directly\n    /// on the Notional contract, not available via the ERC20 proxy.\n    /// @dev emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApproveAll(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        nTokenWhitelist[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /// @notice Claims incentives accrued on all nToken balances and transfers them to the msg.sender\n    /// @dev auth:msg.sender\n    /// @return Total amount of incentives claimed\n    function nTokenClaimIncentives() external override returns (uint256) {\n        address account = msg.sender;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        uint256 totalIncentivesClaimed;\n        BalanceState memory balanceState;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));\n\n            balanceState.loadBalanceState(account, currencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n\n            currencies = currencies << 16;\n        }\n\n        // NOTE: no need to set account context after claiming incentives\n        return totalIncentivesClaimed;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in asset tokens\n    function nTokenPresentValueAssetDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* portfolio */\n        ) = _getNTokenPV(currencyId);\n\n        return totalAssetPV;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in underlying\n    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);\n\n        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);\n    }\n\n    function _getNTokenPV(uint256 currencyId)\n        private\n        view\n        returns (int256, nTokenPortfolio memory)\n    {\n        uint256 blockTime = block.timestamp;\n        nTokenPortfolio memory nToken;\n        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);\n\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* ifCashMapping */\n        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);\n\n        return (totalAssetPV, nToken);\n    }\n\n    /// @notice Transferring tokens will also claim incentives at the same time\n    function _transfer(\n        uint256 currencyId,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        {\n            // prettier-ignore\n            (\n                uint256 isNToken,\n                /* incentiveAnnualEmissionRate */,\n                /* lastInitializedTime */,\n                /* parameters */\n            ) = nTokenHandler.getNTokenContext(recipient);\n            // nTokens cannot hold nToken balances\n            require(isNToken == 0, \"Cannot transfer to nToken\");\n        }\n\n        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);\n        BalanceState memory senderBalance;\n        senderBalance.loadBalanceState(sender, currencyId, senderContext);\n\n        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);\n        BalanceState memory recipientBalance;\n        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);\n\n        int256 amountInt = SafeCast.toInt256(amount);\n        senderBalance.netNTokenTransfer = amountInt.neg();\n        recipientBalance.netNTokenTransfer = amountInt;\n\n        senderBalance.finalize(sender, senderContext, false);\n        recipientBalance.finalize(recipient, recipientContext, false);\n        senderContext.setAccountContext(sender);\n        recipientContext.setAccountContext(recipient);\n\n        emit Transfer(sender, recipient, amount);\n\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "nTokenAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "nTokenAction",
                "Type": "allowance check",
                "Description": "The nTokenAction implements two token approvals, the nTokenWhitelist which is always used first, and the nTokenAllowance which is checked second. If the nTokenWhitelist does _not_ have enough allowance for the transfer, the transaction fails, even in the case where nTokenAllowance still has enough allowance.",
                "Repair": "Default to the nTokenAllowance case instead of reverting if the nTokenWhitelist allowance is not enough"
            },
            {
                "Location": "nTokenAction.sol",
                "Type": "unlimited mint",
                "Description": "The implementation of the transfer function in nTokenAction.sol is different from the usual erc20 token transfer function. This happens because it counts the incentive that the user gets, but with a self-transfer, it can lead to unlimited mint.",
                "Repair": "Add (sender != recipient)"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../balances/TokenHandler.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\nlibrary ExchangeRate {\n    using SafeInt256 for int256;\n\n    uint256 private constant ETH_RATE_STORAGE_SLOT = 1;\n\n    /// @notice Converts a balance to ETH from a base currency. Buffers or haircuts are\n    /// always applied in this method.\n    /// @param er exchange rate object from base to ETH\n    /// @return the converted balance denominated in ETH with Constants.INTERNAL_TOKEN_PRECISION\n    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {\n        if (balance == 0) return 0;\n        int256 multiplier = balance > 0 ? er.haircut : er.buffer;\n\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\n        // internalDecimals * rateDecimals * multiplier /  (rateDecimals * multiplierDecimals)\n        // Therefore the result is in ethDecimals\n        int256 result =\n            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(\n                er.rateDecimals\n            );\n\n        return result;\n    }\n\n    /// @notice Converts the balance denominated in ETH to the equivalent value in a base currency.\n    /// Buffers and haircuts ARE NOT applied in this method.\n    /// @param er exchange rate object from base to ETH\n    /// @param balance amount (denominated in ETH) to convert\n    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {\n        if (balance == 0) return 0;\n\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\n        // internalDecimals * rateDecimals / rateDecimals\n        int256 result = balance.mul(er.rateDecimals).div(er.rate);\n\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate between two currencies via ETH. Returns the rate denominated in\n    /// base exchange rate decimals: (baseRateDecimals * quoteRateDecimals) / quoteRateDecimals\n    /// @param baseER base exchange rate struct\n    /// @param quoteER quote exchange rate struct\n    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)\n        internal\n        pure\n        returns (int256)\n    {\n        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);\n    }\n\n    /// @notice Returns an ETHRate object used to calculate free collateral\n    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {\n        bytes32 slot = keccak256(abi.encode(currencyId, ETH_RATE_STORAGE_SLOT));\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        int256 rateDecimals;\n        int256 rate;\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\n            // ETH rates will just be 1e18, but will still have buffers, haircuts,\n            // and liquidation discounts\n            rateDecimals = Constants.ETH_DECIMALS;\n            rate = Constants.ETH_DECIMALS;\n        } else {\n            address rateOracle = address(bytes20(data << 96));\n            // prettier-ignore\n            (\n                /* uint80 */,\n                rate,\n                /* uint256 */,\n                /* uint256 */,\n                /* uint80 */\n            ) = AggregatorV2V3Interface(rateOracle).latestRoundData();\n            require(rate > 0, \"ExchangeRate: invalid rate\");\n\n            uint8 rateDecimalPlaces = uint8(bytes1(data << 88));\n            rateDecimals = int256(10**rateDecimalPlaces);\n            if (\n                bytes1(data << 80) != Constants.BOOL_FALSE /* mustInvert */\n            ) {\n                rate = rateDecimals.mul(rateDecimals).div(rate);\n            }\n        }\n\n        int256 buffer = int256(uint8(bytes1(data << 72)));\n        int256 haircut = int256(uint8(bytes1(data << 64)));\n        int256 liquidationDiscount = int256(uint8(bytes1(data << 56)));\n        return\n            ETHRate({\n                rateDecimals: rateDecimals,\n                rate: rate,\n                buffer: buffer,\n                haircut: haircut,\n                liquidationDiscount: liquidationDiscount\n            });\n    }\n}\n\n\n",
        "CodeNames": [
            "ExchangeRate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ExchangeRate.sol",
                "Type": "inaccurate price data",
                "Description": "The method .latestRoundData() on an oracle returns the latest updated price from the oracle, but this is not the current price of an asset.",
                "Repair": "Do not fetch the latest price and wait for the callback instead"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/INoteERC20.sol\";\nimport \"@openzeppelin/contracts/access/TimelockController.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Notional Governor Alpha\n * Fork of Compound Governor Alpha at commit hash\n * https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\n */\ncontract GovernorAlpha is TimelockController {\n    /// @notice The name of this contract\n    string public constant name = \"Notional Governor Alpha\";\n\n    /// @notice The address of the Notional governance token\n    INoteERC20 public immutable note;\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint8 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n    /// @notice The minimum voting period in blocks, about 1 day assuming 13 second blocks. Ensures that proposals will always have\n    /// time to be voted on.\n    uint32 public constant MIN_VOTING_PERIOD_BLOCKS = 6700;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed\n    uint96 public quorumVotes;\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    uint96 public proposalThreshold;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    uint32 public votingDelayBlocks;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint32 public votingPeriodBlocks;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // The timestamp at which voting begins: holders must delegate their votes prior to this block\n        uint32 startBlock;\n        // The timestamp at which voting ends: votes must be cast prior to this block\n        uint32 endBlock;\n        // Current number of votes in favor of this proposal\n        uint96 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint96 againstVotes;\n        // Creator of the proposal\n        address proposer;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n        // Hash of the operation to reduce storage cost\n        bytes32 operationHash;\n    }\n\n    // Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal\n        bool support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice Receipts of ballots for the entire set of voters\n    mapping(uint256 => mapping(address => Receipt)) public receipts;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct uComp by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 indexed id,\n        address indexed proposer,\n        address[] targets,\n        uint256[] values,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address indexed voter, uint256 indexed proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 indexed id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 indexed id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 indexed id);\n\n    /// @notice An event emitted when amount of quorum votes required is updated\n    event UpdateQuorumVotes(uint96 newQuorumVotes);\n\n    /// @notice An event emitted when a new proposal threshold has been set\n    event UpdateProposalThreshold(uint96 newProposalThreshold);\n\n    /// @notice An event emitted when a new voting delay in blocks has been set\n    event UpdateVotingDelayBlocks(uint32 newVotingDelayBlocks);\n\n    /// @notice An event emitted when a new voting period in blocks has been set\n    event UpdateVotingPeriodBlocks(uint32 newVotingPeriodBlocks);\n\n    /// @notice Emitted when the guardian abdicates their role\n    event Abdicate();\n\n    /// @notice An event emitted when guardian is transferred\n    event TransferGuardian(address newGuardian);\n    \n    /// @notice Initializes the GovernorAlpha with initial parameters\n    /// @param quorumVotes_ initial quorum votes value\n    /// @param proposalThreshold_ initial proposal threshold value\n    /// @param votingDelayBlocks_ initial voting delay blocks value\n    /// @param votingPeriodBlocks_ initial voting period blocks value\n    /// @param note_ address of the NOTE token to get voting power\n    /// @param guardian_ address of guardian\n    /// @param minDelay_ initial minimum delay for timelock in seconds\n    constructor(\n        uint96 quorumVotes_,\n        uint96 proposalThreshold_,\n        uint32 votingDelayBlocks_,\n        uint32 votingPeriodBlocks_,\n        address note_,\n        address guardian_,\n        uint256 minDelay_\n    ) TimelockController(minDelay_, new address[](0), new address[](0)) {\n        require(Address.isContract(note_));\n\n        quorumVotes = quorumVotes_;\n        proposalThreshold = proposalThreshold_;\n        votingDelayBlocks = votingDelayBlocks_;\n        // Do not enforce MIN_VOTING_DELAY during constructor so that tests don't require a large number\n        // of blocks for the voting period. During actual mainnet deployment this will be set to a reasonable value.\n        votingPeriodBlocks = votingPeriodBlocks_;\n        note = INoteERC20(note_);\n        guardian = guardian_;\n\n        // Only the external methods can be used to execute governance\n        grantRole(PROPOSER_ROLE, address(this));\n        grantRole(EXECUTOR_ROLE, address(this));\n        revokeRole(TIMELOCK_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @notice Proposes a new governance action\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalCreated\n    /// @return newly created proposal id\n    function propose(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external returns (uint256) {\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber < type(uint32).max);\n\n        require(\n            note.getPriorVotes(msg.sender, blockNumber - 1) > proposalThreshold,\n            \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(\n            targets.length <= PROPOSAL_MAX_OPERATIONS,\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        {\n            uint256 latestProposalId = latestProposalIds[msg.sender];\n            if (latestProposalId != 0) {\n                ProposalState proposersLatestProposalState = state(latestProposalId);\n                require(\n                    proposersLatestProposalState != ProposalState.Active,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n                );\n                require(\n                    proposersLatestProposalState != ProposalState.Pending,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n                );\n            }\n        }\n\n        uint256 newProposalId = proposalCount + 1;\n        proposalCount = newProposalId;\n\n        uint32 startBlock = _add32(uint32(blockNumber), votingDelayBlocks);\n        uint32 endBlock = _add32(startBlock, votingPeriodBlocks);\n        bytes32 operationHash = _computeHash(targets, values, calldatas, newProposalId);\n\n        Proposal memory newProposal =\n            Proposal({\n                id: newProposalId,\n                proposer: msg.sender,\n                startBlock: startBlock,\n                endBlock: endBlock,\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false,\n                operationHash: operationHash\n            });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            calldatas,\n            startBlock,\n            endBlock\n        );\n        return newProposal.id;\n    }\n\n    /// @dev Helper method required to clear the stack for hashing operations\n    function _computeHash(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private pure returns (bytes32) {\n        return hashOperationBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));\n    }\n\n    /// @notice Adds a proposal to the timelock queue only after its vote has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal. All proposals\n    /// will automatically be delayed `getMinDelay()` seconds.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalQueued emit:CallScheduled (per call)\n    function queueProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external {\n        require(state(proposalId) == ProposalState.Succeeded, \"Proposal must be success\");\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        {\n            Proposal storage proposal = proposals[proposalId];\n            require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        }\n\n        _scheduleBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalQueued(proposalId, getMinDelay());\n    }\n\n    /// @dev Required to clear the stack for calling the timelock controller\n    function _scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        // NOTE: this will also emit events\n        this.scheduleBatch(\n            targets,\n            values,\n            calldatas,\n            bytes32(0),\n            bytes32(proposalId),\n            getMinDelay()\n        );\n    }\n\n    /// @notice Executes a proposal in the timelock queue after its delay has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalExecuted emit:CallExecuted (per call)\n    function executeProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external payable {\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        // Execute batch will revert if the call has not been scheduled\n        _executeBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalExecuted(proposalId);\n    }\n\n    /// @dev Helper function to clear the stack for the timelock controller call\n    function _executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        this.executeBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));\n    }\n\n    /// @notice Cancels a proposal after it has been created. Can only be done if the proposer\n    /// no longer has sufficient votes (i.e. they made a proposal and then sold their tokens) or\n    /// by a guardian address if it exists.\n    /// @param proposalId unique identifier for the proposal\n    /// @dev emit:ProposalCanceled emit:Canceled\n    function cancelProposal(uint256 proposalId) public {\n        ProposalState proposalState = state(proposalId);\n        require(proposalState != ProposalState.Executed, \"Proposal already executed\");\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber <= type(uint32).max);\n        require(\n            msg.sender == guardian ||\n                note.getPriorVotes(proposal.proposer, blockNumber - 1) < proposalThreshold,\n            \"GovernorAlpha::cancel: proposer above threshold\"\n        );\n\n        proposal.canceled = true;\n        // Removes the operation hash from the timelock controller if pending.\n        if (isOperationPending(proposal.operationHash)) this.cancel(proposal.operationHash);\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /// @notice Returns the voting receipt for a voter on a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param voter address of the voter\n    /// @return the voting receipt for the voter and proposal\n    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n        return receipts[proposalId][voter];\n    }\n\n    /// @notice Returns the current state of a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @return ProposalState enum for the current state of the proposal\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"GovernorAlpha::state: invalid proposal id\"\n        );\n        Proposal memory proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber <= type(uint32).max);\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (blockNumber <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (blockNumber <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\n            return ProposalState.Defeated;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (isOperationPending(proposal.operationHash)) {\n            return ProposalState.Queued;\n        } else if (\n            proposal.forVotes > proposal.againstVotes &&\n            proposal.forVotes > quorumVotes &&\n            blockNumber > proposal.endBlock\n        ) {\n            return ProposalState.Succeeded;\n        }\n    }\n\n    /// @notice Cast a vote for a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @dev emit:VoteCast\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /// @notice Cast a vote for a proposal via signature\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @param v signature component\n    /// @param r signature component\n    /// @param s signature component\n    /// @dev emit:VoteCast\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        // ECDSA.recover will check if address is zero\n        address signatory = ECDSA.recover(digest, v, r, s);\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /// @dev Registers a vote, calls the NOTE token to get the voting power for the voter\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorAlpha::_castVote: voting is closed\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = receipts[proposalId][voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = note.getPriorVotes(voter, proposal.startBlock);\n        // Short circuit if voter has no votes\n        if (votes == 0) return;\n\n        if (support) {\n            proposal.forVotes = _add96(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = _add96(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    /// @notice Updates the quorum votes required, can only be executed via a proposal\n    /// @param newQuorumVotes new quorum votes required\n    /// @dev emit:UpdateQuorumVotes\n    function updateQuorumVotes(uint96 newQuorumVotes) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        quorumVotes = newQuorumVotes;\n        emit UpdateQuorumVotes(newQuorumVotes);\n    }\n\n    /// @notice Updates the proposal threshold required, can only be executed via a proposal\n    /// @param newProposalThreshold new proposal threshold\n    /// @dev emit:UpdateProposalThreshold\n    function updateProposalThreshold(uint96 newProposalThreshold) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        proposalThreshold = newProposalThreshold;\n        emit UpdateProposalThreshold(newProposalThreshold);\n    }\n\n    /// @notice Updates the voting delay blocks required, can only be executed via a proposal\n    /// @param newVotingDelayBlocks new voting delay blocks\n    /// @dev emit:UpdateVotingDelayBlocks\n    function updateVotingDelayBlocks(uint32 newVotingDelayBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        votingDelayBlocks = newVotingDelayBlocks;\n        emit UpdateVotingDelayBlocks(newVotingDelayBlocks);\n    }\n\n    /// @notice Updates the voting period blocks required, can only be executed via a proposal\n    /// @param newVotingPeriodBlocks new voting period blocks\n    /// @dev emit:UpdateVotingPeriodBlocks\n    function updateVotingPeriodBlocks(uint32 newVotingPeriodBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        require(newVotingPeriodBlocks >= MIN_VOTING_PERIOD_BLOCKS, \"Below min voting period\");\n        votingPeriodBlocks = newVotingPeriodBlocks;\n        emit UpdateVotingPeriodBlocks(newVotingPeriodBlocks);\n    }\n\n    /// @dev Hidden public method\n    function __abdicate() external {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n        emit Abdicate();\n    }\n\n    /// @notice Transfers guardian role to a new guardian\n    /// @param newGuardian address to transfer role to\n    function __transferGuardian(address newGuardian) external {\n        require(\n            msg.sender == guardian,\n            \"GovernorAlpha::__transferGuardian: sender must be gov guardian\"\n        );\n        require(newGuardian != address(0), \"Cannot transfer to zero address\");\n\n        guardian = newGuardian;\n        emit TransferGuardian(newGuardian);\n    }\n\n    /// @dev Overflow check for adding votes\n    function _add96(uint96 a, uint96 b) private pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Overflow check for adding block numbers\n    function _add32(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Helper method for signature check\n    function _getChainId() private pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\n\n",
        "CodeNames": [
            "GovernorAlpha.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GovernorAlpha",
                "Type": "privilege escalation",
                "Description": "The GovernorAlpha inherits from a vulnerable TimelockController. This TimelockController allows an EXECUTOR role to escalate privileges and also gain the proposer role.",
                "Repair": "Update the vulnerable contract to TimelockController v3.4.2"
            }
        ]
    }
]