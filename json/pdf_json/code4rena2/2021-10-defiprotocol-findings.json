[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "setBondPercentDiv, addBounty, setMinLicenseFee, mintTo, validateWeights, proposeBasketLicense",
                "Type": "Validation",
                "Description": "Functions lack necessary validation checks",
                "Repair": "Add appropriate validation checks to the functions"
            },
            {
                "Location": "Bonding mechanism in publishAllIndex, settleAuction, bondBurn",
                "Type": "Denial of Service",
                "Description": "Malicious user can DOS auctions using the bonding mechanism",
                "Repair": "Consider de-prioritizing bonding to rebalance or remove the bonding mechanism altogether"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24; // 1 day in blocks\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {\n        return (pendingWeights.tokens, pendingWeights.weights);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public nonReentrant override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        handleFees();\n        uint256 startSupply = totalSupply();\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees() private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else {\n            uint256 startSupply = totalSupply();\n\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.block = block.number;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.block = block.number;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.block = block.number;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.block = block.number;\n\n            emit NewIndexSubmitted();\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(publisher);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).safeApprove(spender, 0);\n            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\n",
        "CodeNames": [
            "Basket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Basket.sol#mint()",
                "Type": "Malfunction",
                "Description": "Extra nonReentrant modifier causes malfunction in the mint() function",
                "Repair": "Remove the nonReentrant modifier from the mint() function"
            },
            {
                "Location": "Basket.sol#transferFrom()",
                "Type": "Incorrect Calculation",
                "Description": "Fee on transfer tokens transfer less tokens than expected",
                "Repair": "Use stored token balances instead of transfer for calculating amounts"
            },
            {
                "Location": "Basket.handleFees()",
                "Type": "Division by zero",
                "Description": "Basket becomes unusable if everybody burns their shares",
                "Repair": "Add a check to handleFees: if totalSupply= 0, return and reset ibRatio to BASE"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport \"hardhat/console.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\n\ncontract Factory is IFactory, Ownable {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n\n    constructor (IAuction _auctionImpl, IBasket _basketImpl) {\n        auctionImpl = _auctionImpl;\n        basketImpl = _basketImpl;\n        ownerSplit = 0; //TODO: needed?\n    }\n\n    Proposal[] private _proposals;\n\n    IAuction public override auctionImpl;\n    IBasket public override basketImpl;\n\n    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%\n    uint256 public override auctionDecrement = 10000;\n    uint256 public override auctionMultiplier = 2;\n    uint256 public override bondPercentDiv = 400;\n    uint256 public override ownerSplit;\n\n    function proposal(uint256 proposalId) external override view returns (Proposal memory) {\n        return _proposals[proposalId];\n    }\n\n    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {\n        minLicenseFee = newMinLicenseFee;\n    }\n\n    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {\n        auctionDecrement = newAuctionDecrement;\n    }\n\n    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {\n        auctionMultiplier = newAuctionMultiplier;\n    }\n\n    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {\n        bondPercentDiv = newBondPercentDiv;\n    }\n\n    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {\n        require(newOwnerSplit <= 2e17); // 20%\n\n        ownerSplit = newOwnerSplit;\n    }\n\n    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {\n        return (_proposals[id].tokens, _proposals[id].weights);\n    }\n\n    function proposeBasketLicense(\n        uint256 licenseFee, \n        string memory tokenName, \n        string memory tokenSymbol, \n        address[] memory tokens,\n        uint256[] memory weights\n    ) public override returns (uint256 id) {\n        basketImpl.validateWeights(tokens, weights);\n\n        require(licenseFee >= minLicenseFee);\n\n        // create proposal object\n        Proposal memory proposal = Proposal({\n            licenseFee: licenseFee,\n            tokenName: tokenName,\n            tokenSymbol: tokenSymbol,\n            proposer: address(msg.sender),\n            tokens: tokens,\n            weights: weights,\n            basket: address(0)\n        });\n\n        emit BasketLicenseProposed(msg.sender, tokenName);\n        _proposals.push(proposal);\n\n        return _proposals.length - 1;\n    }\n\n    function createBasket(uint256 idNumber) external override returns (IBasket) {\n        Proposal memory bProposal = _proposals[idNumber];\n        require(bProposal.basket == address(0));\n\n        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));\n        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));\n\n        _proposals[idNumber].basket = address(newBasket);\n\n        newAuction.initialize(address(newBasket), address(this));\n        newBasket.initialize(bProposal, newAuction);\n\n        for (uint256 i = 0; i < bProposal.weights.length; i++) {\n            IERC20 token = IERC20(bProposal.tokens[i]);\n            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n            token.safeApprove(address(newBasket), bProposal.weights[i]);\n        }\n\n        newBasket.mintTo(BASE, msg.sender);\n\n        emit BasketCreated(address(newBasket));\n\n        return newBasket;\n    }\n}\n\n\n",
        "CodeNames": [
            "Factory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Factory.createBasket",
                "Type": "Re-entrancy",
                "Description": "createBasket function is vulnerable to re-entrancy",
                "Repair": "Add nonReentrant modifier to the createBasket function"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport \"hardhat/console.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\n\ncontract Factory is IFactory, Ownable {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n\n    constructor (IAuction _auctionImpl, IBasket _basketImpl) {\n        auctionImpl = _auctionImpl;\n        basketImpl = _basketImpl;\n        ownerSplit = 0; //TODO: needed?\n    }\n\n    Proposal[] private _proposals;\n\n    IAuction public override auctionImpl;\n    IBasket public override basketImpl;\n\n    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%\n    uint256 public override auctionDecrement = 10000;\n    uint256 public override auctionMultiplier = 2;\n    uint256 public override bondPercentDiv = 400;\n    uint256 public override ownerSplit;\n\n    function proposal(uint256 proposalId) external override view returns (Proposal memory) {\n        return _proposals[proposalId];\n    }\n\n    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {\n        minLicenseFee = newMinLicenseFee;\n    }\n\n    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {\n        auctionDecrement = newAuctionDecrement;\n    }\n\n    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {\n        auctionMultiplier = newAuctionMultiplier;\n    }\n\n    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {\n        bondPercentDiv = newBondPercentDiv;\n    }\n\n    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {\n        require(newOwnerSplit <= 2e17); // 20%\n\n        ownerSplit = newOwnerSplit;\n    }\n\n    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {\n        return (_proposals[id].tokens, _proposals[id].weights);\n    }\n\n    function proposeBasketLicense(\n        uint256 licenseFee, \n        string memory tokenName, \n        string memory tokenSymbol, \n        address[] memory tokens,\n        uint256[] memory weights\n    ) public override returns (uint256 id) {\n        basketImpl.validateWeights(tokens, weights);\n\n        require(licenseFee >= minLicenseFee);\n\n        // create proposal object\n        Proposal memory proposal = Proposal({\n            licenseFee: licenseFee,\n            tokenName: tokenName,\n            tokenSymbol: tokenSymbol,\n            proposer: address(msg.sender),\n            tokens: tokens,\n            weights: weights,\n            basket: address(0)\n        });\n\n        emit BasketLicenseProposed(msg.sender, tokenName);\n        _proposals.push(proposal);\n\n        return _proposals.length - 1;\n    }\n\n    function createBasket(uint256 idNumber) external override returns (IBasket) {\n        Proposal memory bProposal = _proposals[idNumber];\n        require(bProposal.basket == address(0));\n\n        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));\n        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));\n\n        _proposals[idNumber].basket = address(newBasket);\n\n        newAuction.initialize(address(newBasket), address(this));\n        newBasket.initialize(bProposal, newAuction);\n\n        for (uint256 i = 0; i < bProposal.weights.length; i++) {\n            IERC20 token = IERC20(bProposal.tokens[i]);\n            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n            token.safeApprove(address(newBasket), bProposal.weights[i]);\n        }\n\n        newBasket.mintTo(BASE, msg.sender);\n\n        emit BasketCreated(address(newBasket));\n\n        return newBasket;\n    }\n}\n\n\npragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24; // one day in blocks\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondBlock;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    bool public override initialized;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondBlock = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public nonReentrant override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondBlock + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n        require(inputTokens.length == inputWeights.length);\n        require(outputTokens.length == outputWeights.length);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        //TODO: name a and b or further split up\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        basketAsERC20.safeTransfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondBlock + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty storage bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).safeTransfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\n",
        "CodeNames": [
            "Factory.sol",
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Factory.setBondPercentDiv and Auction.bondForRebalance()",
                "Type": "Division by Zero",
                "Description": "Setting bondPercentDiv to zero causes division by zero error",
                "Repair": "Add a require statement to disallow setting bondPercentDiv to zero"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24; // one day in blocks\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondBlock;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    bool public override initialized;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondBlock = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public nonReentrant override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondBlock + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n        require(inputTokens.length == inputWeights.length);\n        require(outputTokens.length == outputWeights.length);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        //TODO: name a and b or further split up\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        basketAsERC20.safeTransfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondBlock + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty storage bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).safeTransfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\n",
        "CodeNames": [
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Auction.settleAuction()",
                "Type": "Division by zero",
                "Description": "Setting Factory.auctionDecrement to zero causes Denial of Service in Auction.settleAuction()",
                "Repair": "Add an appropriate require statement to disallow setting Factory.auctionDecrement to zero"
            },
            {
                "Location": "Auction.sol",
                "Type": "Smart contract vulnerability",
                "Description": "Auction bonder can steal user funds if bond block is high enough",
                "Repair": "Add a sanity check in settleAuction to require (newRatio > basket.ibRatio())"
            }
        ]
    }
]