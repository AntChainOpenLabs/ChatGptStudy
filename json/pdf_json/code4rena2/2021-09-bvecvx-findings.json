[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"../deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/uniswap/IUniswapRouterV2.sol\";\nimport \"../interfaces/badger/ISettV3.sol\";\nimport \"../interfaces/badger/IController.sol\";\nimport \"../interfaces/cvx/ICvxLocker.sol\";\nimport \"../interfaces/snapshot/IDelegateRegistry.sol\";\n\nimport {BaseStrategy} from \"../deps/BaseStrategy.sol\";\n\ncontract MyStrategy is BaseStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using SafeMathUpgradeable for uint256;\n\n    uint256 MAX_BPS = 10_000;\n\n    // address public want // Inherited from BaseStrategy, the token the strategy wants, swaps into and tries to grow\n    address public lpComponent; // Token we provide liquidity with\n    address public reward; // Token we farm and swap to want / lpComponent\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n\n    address public constant SUSHI_ROUTER =\n        0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n\n    IDelegateRegistry public constant SNAPSHOT =\n        IDelegateRegistry(0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446);\n\n    // The address this strategies delegates voting to\n    address public constant DELEGATE =\n        0xB65cef03b9B89f99517643226d76e286ee999e77;\n\n    bytes32 public constant DELEGATED_SPACE =\n        0x6376782e65746800000000000000000000000000000000000000000000000000;\n\n    ICvxLocker public LOCKER;\n\n    ISettV3 public CVX_VAULT =\n        ISettV3(0x53C8E199eb2Cb7c01543C137078a038937a68E40);\n\n    bool public withdrawalSafetyCheck = true;\n    bool public harvestOnRebalance = true;\n    // If nothing is unlocked, processExpiredLocks will revert\n    bool public processLocksOnReinvest = true;\n    bool public processLocksOnRebalance = true;\n\n    event Debug(string name, uint256 value);\n\n    // Used to signal to the Badger Tree that rewards where sent to it\n    event TreeDistribution(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    function initialize(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _keeper,\n        address _guardian,\n        address[3] memory _wantConfig,\n        uint256[3] memory _feeConfig,\n        address _locker ///@dev TODO: Add this to deploy\n    ) public initializer {\n        __BaseStrategy_init(\n            _governance,\n            _strategist,\n            _controller,\n            _keeper,\n            _guardian\n        );\n\n        /// @dev Add config here\n        want = _wantConfig[0];\n        lpComponent = _wantConfig[1];\n        reward = _wantConfig[2];\n\n        performanceFeeGovernance = _feeConfig[0];\n        performanceFeeStrategist = _feeConfig[1];\n        withdrawalFee = _feeConfig[2];\n\n        LOCKER = ICvxLocker(_locker); //TODO: Make locker hardcoded at top of file\n\n        /// @dev do one off approvals here\n        // IERC20Upgradeable(want).safeApprove(gauge, type(uint256).max);\n        // Permissions for Locker\n        IERC20Upgradeable(CVX).safeApprove(_locker, type(uint256).max);\n        IERC20Upgradeable(CVX).safeApprove(\n            address(CVX_VAULT),\n            type(uint256).max\n        );\n\n        // Permissions for Sushiswap\n        IERC20Upgradeable(reward).safeApprove(SUSHI_ROUTER, type(uint256).max);\n\n        // Delegate voting to DELEGATE\n        SNAPSHOT.setDelegate(DELEGATED_SPACE, DELEGATE);\n    }\n\n    /// ===== Extra Functions =====\n    ///@dev Should we check if the amount requested is more than what we can return on withdrawal?\n    function setWithdrawalSafetyCheck(bool newWithdrawalSafetyCheck) public {\n        _onlyGovernance();\n        withdrawalSafetyCheck = newWithdrawalSafetyCheck;\n    }\n\n    ///@dev Should we harvest before doing manual rebalancing\n    ///@notice you most likely want to skip harvest if everything is unlocked, or there's something wrong and you just want out\n    function setHarvestOnRebalance(bool newHarvestOnRebalance) public {\n        _onlyGovernance();\n        harvestOnRebalance = newHarvestOnRebalance;\n    }\n\n    ///@dev Should we processExpiredLocks during reinvest?\n    function setProcessLocksOnReinvest(bool newProcessLocksOnReinvest) public {\n        _onlyGovernance();\n        processLocksOnReinvest = newProcessLocksOnReinvest;\n    }\n\n    ///@dev Should we processExpiredLocks during manualRebalance?\n    function setProcessLocksOnRebalance(bool newProcessLocksOnRebalance)\n        public\n    {\n        _onlyGovernance();\n        processLocksOnRebalance = newProcessLocksOnRebalance;\n    }\n\n    /// ===== View Functions =====\n\n    /// @dev Specify the name of the strategy\n    function getName() external pure override returns (string memory) {\n        return \"veCVX Voting Strategy\";\n    }\n\n    /// @dev Specify the version of the Strategy, for upgrades\n    function version() external pure returns (string memory) {\n        return \"1.0\";\n    }\n\n    /// @dev From CVX Token to Helper Vault Token\n    function CVXToWant(uint256 cvx) public view returns (uint256) {\n        uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare();\n        return cvx.mul(10**18).div(bCVXToCVX);\n    }\n\n    /// @dev From Helper Vault Token to CVX Token\n    function wantToCVX(uint256 want) public view returns (uint256) {\n        uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare();\n        return want.mul(bCVXToCVX).div(10**18);\n    }\n\n    /// @dev Balance of want currently held in strategy positions\n    function balanceOfPool() public view override returns (uint256) {\n        if (withdrawalSafetyCheck) {\n            uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals\n            require(bCVXToCVX > 10**18, \"Loss Of Peg\"); // Avoid trying to redeem for less / loss of peg\n        }\n\n        // Return the balance in locker + unlocked but not withdrawn, better estimate to allow some withdrawals\n        // then multiply it by the price per share as we need to convert CVX to bCVX\n        uint256 valueInLocker =\n            CVXToWant(LOCKER.lockedBalanceOf(address(this))).add(\n                CVXToWant(IERC20Upgradeable(CVX).balanceOf(address(this)))\n            );\n\n        return (valueInLocker);\n    }\n\n    /// @dev Returns true if this strategy requires tending\n    function isTendable() public view override returns (bool) {\n        return false;\n    }\n\n    // @dev These are the tokens that cannot be moved except by the vault\n    function getProtectedTokens()\n        public\n        view\n        override\n        returns (address[] memory)\n    {\n        address[] memory protectedTokens = new address[](4);\n        protectedTokens[0] = want;\n        protectedTokens[1] = lpComponent;\n        protectedTokens[2] = reward;\n        protectedTokens[3] = CVX;\n        return protectedTokens;\n    }\n\n    /// ===== Permissioned Actions: Governance =====\n    /// @notice Delete if you don't need!\n    function setKeepReward(uint256 _setKeepReward) external {\n        _onlyGovernance();\n    }\n\n    /// ===== Internal Core Implementations =====\n\n    /// @dev security check to avoid moving tokens that would cause a rugpull, edit based on strat\n    function _onlyNotProtectedTokens(address _asset) internal override {\n        address[] memory protectedTokens = getProtectedTokens();\n\n        for (uint256 x = 0; x < protectedTokens.length; x++) {\n            require(\n                address(protectedTokens[x]) != _asset,\n                \"Asset is protected\"\n            );\n        }\n    }\n\n    /// @dev invest the amount of want\n    /// @notice When this function is called, the controller has already sent want to this\n    /// @notice Just get the current balance and then invest accordingly\n    function _deposit(uint256 _amount) internal override {\n        // We receive bCVX -> Convert to bCVX\n        CVX_VAULT.withdraw(_amount);\n\n        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));\n\n        // Lock tokens for 17 weeks, send credit to strat, always use max boost cause why not?\n        LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());\n    }\n\n    /// @dev utility function to convert all we can to bCVX\n    /// @notice You may want to harvest before calling this to maximize the amount of bCVX you'll have\n    function prepareWithdrawAll() external {\n        _onlyGovernance();\n\n        LOCKER.processExpiredLocks(false);\n\n        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));\n        if (toDeposit > 0) {\n            CVX_VAULT.deposit(toDeposit);\n        }\n    }\n\n    /// @dev utility function to withdraw everything for migration\n    /// @dev NOTE: You cannot call this unless you have rebalanced to have only bCVX left in the vault\n    function _withdrawAll() internal override {\n        //NOTE: This probably will always fail unless we have all tokens expired\n        require(\n            LOCKER.lockedBalanceOf(address(this)) == 0 &&\n                LOCKER.balanceOf(address(this)) == 0,\n            \"You have to wait for unlock and have to manually rebalance out of it\"\n        );\n\n        // NO-OP because you can't deposit AND transfer with bCVX\n        // See prepareWithdrawAll above\n    }\n\n    /// @dev withdraw the specified amount of want, liquidate from lpComponent to want, paying off any necessary debt for the conversion\n    function _withdrawSome(uint256 _amount)\n        internal\n        override\n        returns (uint256)\n    {\n        uint256 max = IERC20Upgradeable(want).balanceOf(address(this));\n\n        if (withdrawalSafetyCheck) {\n            uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals\n            require(bCVXToCVX > 10**18, \"Loss Of Peg\"); // Avoid trying to redeem for less / loss of peg\n            require(\n                max >= _amount.mul(9_980).div(MAX_BPS),\n                \"Withdrawal Safety Check\"\n            ); // 20 BP of slippage\n        }\n\n        if (max < _amount) {\n            return max;\n        }\n\n        return _amount;\n    }\n\n    /// @dev Harvest from strategy mechanics, realizing increase in underlying position\n    function harvest() public whenNotPaused returns (uint256 harvested) {\n        _onlyAuthorizedActors();\n\n        uint256 _before = IERC20Upgradeable(want).balanceOf(address(this));\n\n        uint256 _beforeCVX = IERC20Upgradeable(reward).balanceOf(address(this));\n\n        // Get cvxCRV\n        LOCKER.getReward(address(this), false);\n\n        // Rewards Math\n        uint256 earnedReward =\n            IERC20Upgradeable(reward).balanceOf(address(this)).sub(_beforeCVX);\n\n        // Because we are using bCVX we take fees in reward\n        //NOTE: This will probably revert because we deposit and transfer on same block\n        (uint256 governancePerformanceFee, uint256 strategistPerformanceFee) =\n            _processRewardsFees(earnedReward, reward);\n\n        // Swap cvxCRV for want (bCVX)\n        _swapcvxCRVToWant();\n\n        uint256 earned =\n            IERC20Upgradeable(want).balanceOf(address(this)).sub(_before);\n\n        /// @dev Harvest event that every strategy MUST have, see BaseStrategy\n        emit Harvest(earned, block.number);\n\n        /// @dev Harvest must return the amount of want increased\n        return earned;\n    }\n\n    /// @dev Rebalance, Compound or Pay off debt here\n    function tend() external whenNotPaused {\n        _onlyAuthorizedActors();\n        revert(); // NOTE: For now tend is replaced by manualRebalance\n    }\n\n    /// @dev Swap from reward to CVX, then deposit into bCVX vault\n    function _swapcvxCRVToWant() internal {\n        uint256 toSwap = IERC20Upgradeable(reward).balanceOf(address(this));\n\n        if (toSwap == 0) {\n            return;\n        }\n\n        // Sushi reward to WETH to want\n        address[] memory path = new address[](3);\n        path[0] = reward;\n        path[1] = WETH;\n        path[2] = CVX;\n        IUniswapRouterV2(SUSHI_ROUTER).swapExactTokensForTokens(\n            toSwap,\n            0,\n            path,\n            address(this),\n            now\n        );\n\n        // Deposit into vault\n        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));\n        if (toDeposit > 0) {\n            CVX_VAULT.deposit(toDeposit);\n        }\n    }\n\n    /// ===== Internal Helper Functions =====\n\n    /// @dev used to manage the governance and strategist fee, make sure to use it to get paid!\n    function _processPerformanceFees(uint256 _amount)\n        internal\n        returns (\n            uint256 governancePerformanceFee,\n            uint256 strategistPerformanceFee\n        )\n    {\n        governancePerformanceFee = _processFee(\n            want,\n            _amount,\n            performanceFeeGovernance,\n            IController(controller).rewards()\n        );\n\n        strategistPerformanceFee = _processFee(\n            want,\n            _amount,\n            performanceFeeStrategist,\n            strategist\n        );\n    }\n\n    /// @dev used to manage the governance and strategist fee on earned rewards, make sure to use it to get paid!\n    function _processRewardsFees(uint256 _amount, address _token)\n        internal\n        returns (uint256 governanceRewardsFee, uint256 strategistRewardsFee)\n    {\n        governanceRewardsFee = _processFee(\n            _token,\n            _amount,\n            performanceFeeGovernance,\n            IController(controller).rewards()\n        );\n\n        strategistRewardsFee = _processFee(\n            _token,\n            _amount,\n            performanceFeeStrategist,\n            strategist\n        );\n    }\n\n    /// MANUAL FUNCTIONS ///\n\n    /// @dev manual function to reinvest all CVX that was locked\n    function reinvest() external whenNotPaused returns (uint256 reinvested) {\n        _onlyGovernance();\n\n        if (processLocksOnReinvest) {\n            // Withdraw all we can\n            LOCKER.processExpiredLocks(false);\n        }\n\n        // Redeposit all into veCVX\n        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));\n\n        // Redeposit into veCVX\n        LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());\n    }\n\n    /// @dev process all locks, to redeem\n    function manualProcessExpiredLocks() external whenNotPaused {\n        _onlyGovernance();\n        LOCKER.processExpiredLocks(false);\n        // Unlock veCVX that is expired and redeem CVX back to this strat\n        // Processed in the next harvest or during prepareMigrateAll\n    }\n\n    /// @dev Take all CVX and deposits in the CVX_VAULT\n    function manualDepositCVXIntoVault() external whenNotPaused {\n        _onlyGovernance();\n\n        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));\n        if (toDeposit > 0) {\n            CVX_VAULT.deposit(toDeposit);\n        }\n    }\n\n    /// @dev Send all available bCVX to the Vault\n    /// @notice you can do this so you can earn again (re-lock), or just to add to the redemption pool\n    function manualSendbCVXToVault() external whenNotPaused {\n        _onlyGovernance();\n        uint256 bCvxAmount = IERC20Upgradeable(want).balanceOf(address(this));\n        _transferToVault(bCvxAmount);\n    }\n\n    /// @dev use the currently available CVX to either lock or add to bCVX\n    /// @notice toLock = 0, lock nothing, deposit in bCVX as much as you can\n    /// @notice toLock = 100, lock everything (CVX) you have\n    function manualRebalance(uint256 toLock) external whenNotPaused {\n        _onlyGovernance();\n        require(toLock <= MAX_BPS, \"Max is 100%\");\n\n        if (processLocksOnRebalance) {\n            // manualRebalance will revert if you have no expired locks\n            LOCKER.processExpiredLocks(false);\n        }\n\n        if (harvestOnRebalance) {\n            harvest();\n        }\n\n        // Token that is highly liquid\n        uint256 balanceOfWant =\n            IERC20Upgradeable(want).balanceOf(address(this));\n        // CVX uninvested we got from harvest and unlocks\n        uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));\n        // Locked CVX in the locker\n        uint256 balanceInLock = LOCKER.balanceOf(address(this));\n        uint256 totalCVXBalance =\n            balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));\n\n        //Ratios\n        uint256 currentLockRatio =\n            balanceInLock.mul(10**18).div(totalCVXBalance);\n        // Amount we want to have in lock\n        uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);\n        // Amount we want to have in bCVX\n        uint256 toWantRatio =\n            totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);\n\n        // We can't unlock enough, just deposit rest into bCVX\n        if (newLockRatio <= currentLockRatio) {\n            // Deposit into vault\n            uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));\n            if (toDeposit > 0) {\n                CVX_VAULT.deposit(toDeposit);\n            }\n\n            return;\n        }\n\n        // If we're continuing, then we are going to lock something (unless it's zero)\n        uint256 cvxToLock = newLockRatio.sub(currentLockRatio);\n\n        // NOTE: We only lock the CVX we have and not the bCVX\n        // bCVX should be sent back to vault and then go through earn\n        // We do this because bCVX has \"blockLock\" and we can't both deposit and withdraw on the same block\n        uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));\n        if (cvxToLock > maxCVX) {\n            // Just lock what we can\n            LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());\n        } else {\n            // Lock proper\n            LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());\n        }\n\n        // If anything else is left, deposit into vault\n        uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));\n        if (cvxLeft > 0) {\n            CVX_VAULT.deposit(cvxLeft);\n        }\n        // At the end of the rebalance, there won't be any balanceOfCVX as that token is not considered by our strat\n    }\n}\n\n\n",
        "CodeNames": [
            "veCVXStrategy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "veCVXStrategy.manualRebalance function",
                "Type": "Wrong logic",
                "Description": "The rebalancing is broken and does not correctly rebalance. It usually leads to locking nearly everything if totalCVXBalance is high.",
                "Repair": "Rewrite the code for manualRebalance"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.11;\n\nimport \"../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport \"interfaces/badger/IController.sol\";\nimport \"interfaces/erc20/IERC20Detailed.sol\";\nimport \"../../deps/SettAccessControlDefended.sol\";\nimport \"interfaces/yearn/BadgerGuestlistApi.sol\";\n\n/* \n    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol\n    \n    Changelog:\n\n    V1.1\n    * Strategist no longer has special function calling permissions\n    * Version function added to contract\n    * All write functions, with the exception of transfer, are pausable\n    * Keeper or governance can pause\n    * Only governance can unpause\n\n    V1.2\n    * Transfer functions are now pausable along with all other non-permissioned write functions\n    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well\n\n    V1.3\n    * Add guest list functionality\n    * All deposits can be optionally gated by external guestList approval logic on set guestList contract\n*/\n\ncontract SettV3 is\n    ERC20Upgradeable,\n    SettAccessControlDefended,\n    PausableUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using SafeMathUpgradeable for uint256;\n\n    IERC20Upgradeable public token;\n\n    uint256 public min;\n    uint256 public constant max = 10000;\n\n    address public controller;\n\n    mapping(address => uint256) public blockLock;\n\n    string internal constant _defaultNamePrefix = \"Badger Sett \";\n    string internal constant _symbolSymbolPrefix = \"b\";\n\n    address public guardian;\n\n    BadgerGuestListAPI public guestList;\n\n    event FullPricePerShareUpdated(\n        uint256 value,\n        uint256 indexed timestamp,\n        uint256 indexed blockNumber\n    );\n\n    function initialize(\n        address _token,\n        address _controller,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        bool _overrideTokenName,\n        string memory _namePrefix,\n        string memory _symbolPrefix\n    ) public initializer whenNotPaused {\n        IERC20Detailed namedToken = IERC20Detailed(_token);\n        string memory tokenName = namedToken.name();\n        string memory tokenSymbol = namedToken.symbol();\n\n        string memory name;\n        string memory symbol;\n\n        if (_overrideTokenName) {\n            name = string(abi.encodePacked(_namePrefix, tokenName));\n            symbol = string(abi.encodePacked(_symbolPrefix, tokenSymbol));\n        } else {\n            name = string(abi.encodePacked(_defaultNamePrefix, tokenName));\n            symbol = string(abi.encodePacked(_symbolSymbolPrefix, tokenSymbol));\n        }\n\n        __ERC20_init(name, symbol);\n\n        token = IERC20Upgradeable(_token);\n        governance = _governance;\n        strategist = address(0);\n        keeper = _keeper;\n        controller = _controller;\n        guardian = _guardian;\n\n        min = 9500;\n\n        emit FullPricePerShareUpdated(\n            getPricePerFullShare(),\n            now,\n            block.number\n        );\n\n        // Paused on launch\n        _pause();\n    }\n\n    /// ===== Modifiers =====\n\n    function _onlyController() internal view {\n        require(msg.sender == controller, \"onlyController\");\n    }\n\n    function _onlyAuthorizedPausers() internal view {\n        require(\n            msg.sender == guardian || msg.sender == governance,\n            \"onlyPausers\"\n        );\n    }\n\n    function _blockLocked() internal view {\n        require(blockLock[msg.sender] < block.number, \"blockLocked\");\n    }\n\n    /// ===== View Functions =====\n\n    function version() public view returns (string memory) {\n        return \"1.3\";\n    }\n\n    function getPricePerFullShare() public view virtual returns (uint256) {\n        if (totalSupply() == 0) {\n            return 1e18;\n        }\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /// @notice Return the total balance of the underlying token within the system\n    /// @notice Sums the balance in the Sett, the Controller, and the Strategy\n    function balance() public view virtual returns (uint256) {\n        return\n            token.balanceOf(address(this)).add(\n                IController(controller).balanceOf(address(token))\n            );\n    }\n\n    /// @notice Defines how much of the Setts' underlying can be borrowed by the Strategy for use\n    /// @notice Custom logic in here for how much the vault allows to be borrowed\n    /// @notice Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public view virtual returns (uint256) {\n        return token.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    /// ===== Public Actions =====\n\n    /// @notice Deposit assets into the Sett, and return corresponding shares to the user\n    /// @notice Only callable by EOA accounts that pass the _defend() check\n    function deposit(uint256 _amount) public whenNotPaused {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _depositWithAuthorization(_amount, new bytes32[](0));\n    }\n\n    /// @notice Deposit variant with proof for merkle guest list\n    function deposit(uint256 _amount, bytes32[] memory proof)\n        public\n        whenNotPaused\n    {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _depositWithAuthorization(_amount, proof);\n    }\n\n    /// @notice Convenience function: Deposit entire balance of asset into the Sett, and return corresponding shares to the user\n    /// @notice Only callable by EOA accounts that pass the _defend() check\n    function depositAll() external whenNotPaused {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _depositWithAuthorization(\n            token.balanceOf(msg.sender),\n            new bytes32[](0)\n        );\n    }\n\n    /// @notice DepositAll variant with proof for merkle guest list\n    function depositAll(bytes32[] memory proof) external whenNotPaused {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _depositWithAuthorization(token.balanceOf(msg.sender), proof);\n    }\n\n    /// @notice No rebalance implementation for lower fees and faster swaps\n    function withdraw(uint256 _shares) public whenNotPaused {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _withdraw(_shares);\n    }\n\n    /// @notice Convenience function: Withdraw all shares of the sender\n    function withdrawAll() external whenNotPaused {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _withdraw(balanceOf(msg.sender));\n    }\n\n    /// ===== Permissioned Actions: Governance =====\n\n    function setGuestList(address _guestList) external whenNotPaused {\n        _onlyGovernance();\n        guestList = BadgerGuestListAPI(_guestList);\n    }\n\n    /// @notice Set minimum threshold of underlying that must be deposited in strategy\n    /// @notice Can only be changed by governance\n    function setMin(uint256 _min) external whenNotPaused {\n        _onlyGovernance();\n        min = _min;\n    }\n\n    /// @notice Change controller address\n    /// @notice Can only be changed by governance\n    function setController(address _controller) public whenNotPaused {\n        _onlyGovernance();\n        controller = _controller;\n    }\n\n    /// @notice Change guardian address\n    /// @notice Can only be changed by governance\n    function setGuardian(address _guardian) external whenNotPaused {\n        _onlyGovernance();\n        guardian = _guardian;\n    }\n\n    /// ===== Permissioned Actions: Controller =====\n\n    /// @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n    /// @notice Only controller can trigger harvests\n    function harvest(address reserve, uint256 amount) external whenNotPaused {\n        _onlyController();\n        require(reserve != address(token), \"token\");\n        IERC20Upgradeable(reserve).safeTransfer(controller, amount);\n    }\n\n    /// ===== Permissioned Functions: Trusted Actors =====\n\n    /// @notice Transfer the underlying available to be claimed to the controller\n    /// @notice The controller will deposit into the Strategy for yield-generating activities\n    /// @notice Permissionless operation\n    function earn() public whenNotPaused {\n        _onlyAuthorizedActors();\n\n        uint256 _bal = available();\n        token.safeTransfer(controller, _bal);\n        IController(controller).earn(address(token), _bal);\n    }\n\n    /// @notice Transfer the specified amount\n    /// @notice used so you can specify how many tokens to lock\n    function earn(uint256 amount) public whenNotPaused {\n        _onlyAuthorizedActors();\n\n        token.safeTransfer(controller, amount);\n        IController(controller).earn(address(token), amount);\n    }\n\n    /// @dev Emit event tracking current full price per share\n    /// @dev Provides a pure on-chain way of approximating APY\n    function trackFullPricePerShare() external whenNotPaused {\n        _onlyAuthorizedActors();\n        emit FullPricePerShareUpdated(\n            getPricePerFullShare(),\n            now,\n            block.number\n        );\n    }\n\n    function pause() external {\n        _onlyAuthorizedPausers();\n        _pause();\n    }\n\n    function unpause() external {\n        _onlyGovernance();\n        _unpause();\n    }\n\n    /// ===== Internal Implementations =====\n\n    /// @dev Calculate the number of shares to issue for a given deposit\n    /// @dev This is based on the realized value of underlying assets between Sett & associated Strategy\n    function _deposit(uint256 _amount) internal virtual {\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    function _depositWithAuthorization(uint256 _amount, bytes32[] memory proof)\n        internal\n        virtual\n    {\n        if (address(guestList) != address(0)) {\n            require(\n                guestList.authorized(msg.sender, _amount, proof),\n                \"guest-list-authorization\"\n            );\n        }\n        _deposit(_amount);\n    }\n\n    // No rebalance implementation for lower fees and faster swaps\n    function _withdraw(uint256 _shares) internal virtual {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 b = token.balanceOf(address(this));\n        if (b < r) {\n            uint256 _toWithdraw = r.sub(b);\n            IController(controller).withdraw(address(token), _toWithdraw);\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    function _lockForBlock(address account) internal {\n        blockLock[account] = block.number;\n    }\n\n    /// ===== ERC20 Overrides =====\n\n    /// @dev Add blockLock to transfers, users cannot transfer tokens in the same block as a deposit or withdrawal.\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        whenNotPaused\n        returns (bool)\n    {\n        _blockLocked();\n        return super.transfer(recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override whenNotPaused returns (bool) {\n        _blockLocked();\n        return super.transferFrom(sender, recipient, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "SettV3.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SettV3.transferFrom function",
                "Type": "Block lock circumvention",
                "Description": "The protection desired from the blockLocked call does not work for this function.",
                "Repair": "Parameterize blockLocked to take an account parameter instead"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/cvx/MathUtil.sol\";\nimport \"../../interfaces/cvx/IStakingProxy.sol\";\nimport \"../../interfaces/cvx/IRewardStaking.sol\";\nimport \"../../interfaces/cvx/BoringMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n// CVX Locking contract for https://www.convexfinance.com/\n// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform\n// Based on EPS Staking contract for http://ellipsis.finance/\n// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\ncontract CvxLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    struct Reward {\n        bool useBoost;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n    }\n    struct Balances {\n        uint112 locked;\n        uint112 boosted;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint112 boosted;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply; //epoch boosted supply\n        uint32 date; //epoch start date\n    }\n\n    //token constants\n    IERC20 public constant stakingToken =\n        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx\n    address public constant cvxCrv =\n        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address => Reward) public rewardData;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n\n    // user -> reward token -> amount\n    mapping(address => mapping(address => uint256))\n        public userRewardPerTokenPaid;\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    uint256 public boostedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    //boost\n    address public boostPayment =\n        address(0x1389388d01708118b497f59521f6943Be2541bb7);\n    uint256 public maximumBoostPayment = 0;\n    uint256 public boostRate = 10000;\n    uint256 public nextMaximumBoostPayment = 0;\n    uint256 public nextBoostRate = 10000;\n    uint256 public constant denominator = 10000;\n\n    //staking\n    uint256 public minimumStake = 10000;\n    uint256 public maximumStake = 10000;\n    address public stakingProxy;\n    address public constant cvxcrvStaking =\n        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor() public Ownable() {\n        _name = \"Vote Locked Convex Token\";\n        _symbol = \"vlCVX\";\n        _decimals = 18;\n\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /* ========== ADMIN CONFIGURATION ========== */\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _distributor,\n        bool _useBoost\n    ) public onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardData[_rewardsToken].useBoost = _useBoost;\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //Set the staking contract for the underlying cvx. immutable to avoid foul play\n    function setStakingContract(address _staking) external onlyOwner {\n        require(stakingProxy == address(0), \"staking contract immutable\");\n\n        stakingProxy = _staking;\n    }\n\n    //set staking limits. will stake the mean of the two once either ratio is crossed\n    function setStakeLimits(uint256 _minimum, uint256 _maximum)\n        external\n        onlyOwner\n    {\n        require(_minimum <= denominator, \"min range\");\n        require(_maximum <= denominator, \"max range\");\n        minimumStake = _minimum;\n        maximumStake = _maximum;\n        updateStakeRatio(0);\n    }\n\n    //set boost parameters\n    function setBoost(\n        uint256 _max,\n        uint256 _rate,\n        address _receivingAddress\n    ) external onlyOwner {\n        require(maximumBoostPayment < 1500, \"over max payment\"); //max 15%\n        require(boostRate < 30000, \"over max rate\"); //max 3x\n        require(_receivingAddress != address(0), \"invalid address\"); //must point somewhere valid\n        nextMaximumBoostPayment = _max;\n        nextBoostRate = _rate;\n        boostPayment = _receivingAddress;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay)\n        external\n        onlyOwner\n    {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        if (stakingProxy != address(0)) {\n            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();\n            IStakingProxy(stakingProxy).withdraw(stakeBalance);\n        }\n        isShutdown = true;\n    }\n\n    //set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));\n\n        IERC20(stakingToken).safeApprove(stakingProxy, 0);\n        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));\n    }\n\n    /* ========== VIEWS ========== */\n\n    function _rewardPerToken(address _rewardsToken)\n        internal\n        view\n        returns (uint256)\n    {\n        if (boostedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(\n                    rewardData[_rewardsToken]\n                        .periodFinish\n                )\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(\n                    rewardData[_rewardsToken].useBoost\n                        ? boostedSupply\n                        : lockedSupply\n                )\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                _rewardPerToken(_rewardsToken).sub(\n                    userRewardPerTokenPaid[_user][_rewardsToken]\n                )\n            )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime)\n        internal\n        view\n        returns (uint256)\n    {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData[](rewardTokens.length);\n        Balances storage userBalance = balances[_account];\n        uint256 boostedBal = userBalance.boosted;\n        for (uint256 i = 0; i < userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(\n                _account,\n                token,\n                rewardData[token].useBoost ? boostedBal : userBalance.locked\n            );\n        }\n        return userRewards;\n    }\n\n    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens\n    function rewardWeightOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].boosted;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].locked;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n\n        //start with current boosted amount\n        amount = balances[_user].boosted;\n\n        uint256 locksLength = locks.length;\n        //remove old records only (will be better gas-wise than adding up)\n        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {\n            if (locks[i].unlockTime <= block.timestamp) {\n                amount = amount.sub(locks[i].boosted);\n            } else {\n                //stop now as no futher checks are needed\n                break;\n            }\n        }\n\n        //also remove amount in the current epoch\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength > 0 &&\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==\n            currentEpoch\n        ) {\n            amount = amount.sub(locks[locksLength - 1].boosted);\n        }\n\n        return amount;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //current epoch is not counted\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we're basing from.\n            //also not include the current epoch\n            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {\n                if (lockEpoch > cutoffEpoch) {\n                    amount = amount.add(locks[i].boosted);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //supply of all properly locked BOOSTED balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include current epoch's supply\n        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked BOOSTED balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch)\n        external\n        view\n        returns (uint256 supply)\n    {\n        uint256 epochStart =\n            uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n                rewardsDuration\n            );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //do not include current epoch's supply\n        if (uint256(epochs[_epoch].date) == currentEpoch) {\n            _epoch--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) external view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock < _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user's locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date < currentEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate =\n                    uint256(epochs[epochs.length - 1].date).add(\n                        rewardsDuration\n                    );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n\n            //update boost parameters on a new epoch\n            if (boostRate != nextBoostRate) {\n                boostRate = nextBoostRate;\n            }\n            if (maximumBoostPayment != nextMaximumBoostPayment) {\n                maximumBoostPayment = nextMaximumBoostPayment;\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, _spendRatio);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(_spendRatio <= maximumBoostPayment, \"over max spend\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //calc lock and boosted amount\n        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);\n        uint256 boostRatio =\n            boostRate.mul(_spendRatio).div(\n                maximumBoostPayment == 0 ? 1 : maximumBoostPayment\n            );\n        uint112 lockAmount = _amount.sub(spendAmount).to112();\n        uint112 boostedAmount =\n            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();\n\n        //add user balances\n        bal.locked = bal.locked.add(lockAmount);\n        bal.boosted = bal.boosted.add(boostedAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n        boostedSupply = boostedSupply.add(boostedAmount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({\n                    amount: lockAmount,\n                    boosted: boostedAmount,\n                    unlockTime: uint32(unlockTime)\n                })\n            );\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n            userL.boosted = userL.boosted.add(boostedAmount);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(uint224(boostedAmount));\n\n        //send boost payment\n        if (spendAmount > 0) {\n            stakingToken.safeTransfer(boostPayment, spendAmount);\n        }\n\n        //update staking, allow a bit of leeway for smaller deposits to reduce gas\n        updateStakeRatio(stakeOffsetOnLock);\n\n        emit Staked(_account, _amount, lockAmount, boostedAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint112 boostedAmount;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n\n        if (\n            isShutdown ||\n            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)\n        ) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n            boostedAmount = userBalance.boosted;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch =\n                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                        rewardsDuration\n                    );\n                uint256 epochsover =\n                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                        rewardsDuration\n                    );\n                uint256 rRate =\n                    MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(\n                    denominator\n                );\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))\n                    break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n                boostedAmount = boostedAmount.add(locks[i].boosted);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch =\n                        block\n                            .timestamp\n                            .sub(_checkDelay)\n                            .div(rewardsDuration)\n                            .mul(rewardsDuration);\n                    uint256 epochsover =\n                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                            rewardsDuration\n                        );\n                    uint256 rRate =\n                        MathUtil.min(\n                            kickRewardPerEpoch.mul(epochsover + 1),\n                            denominator\n                        );\n                    reward = reward.add(\n                        uint256(locks[i].amount).mul(rRate).div(denominator)\n                    );\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        userBalance.boosted = userBalance.boosted.sub(boostedAmount);\n        lockedSupply = lockedSupply.sub(locked);\n        boostedSupply = boostedSupply.sub(boostedAmount);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //if theres a reward(kicked), it will always be a withdraw only\n            //preallocate enough cvx from stake contract to pay for both reward and withdraw\n            allocateCVXForTransfer(uint256(locked));\n\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            transferCVX(_rewardAddress, reward, false);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        } else if (_spendRatio > 0) {\n            //preallocate enough cvx to transfer the boost cost\n            allocateCVXForTransfer(\n                uint256(locked).mul(_spendRatio).div(denominator)\n            );\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, _spendRatio);\n        } else {\n            transferCVX(_withdrawTo, locked, true);\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo\n    ) external nonReentrant {\n        _processExpiredLocks(\n            msg.sender,\n            _relock,\n            _spendRatio,\n            _withdrawTo,\n            msg.sender,\n            0\n        );\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(\n            _account,\n            false,\n            0,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n\n    //pull required amount of cvx from staking for an upcoming transfer\n    function allocateCVXForTransfer(uint256 _amount) internal {\n        uint256 balance = stakingToken.balanceOf(address(this));\n        if (_amount > balance) {\n            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));\n        }\n    }\n\n    //transfer helper: pull enough from staking, transfer, updating staking ratio\n    function transferCVX(\n        address _account,\n        uint256 _amount,\n        bool _updateStake\n    ) internal {\n        //allocate enough cvx from staking for the transfer\n        allocateCVXForTransfer(_amount);\n        //transfer\n        stakingToken.safeTransfer(_account, _amount);\n\n        //update staking\n        if (_updateStake) {\n            updateStakeRatio(0);\n        }\n    }\n\n    //calculate how much cvx should be staked. update if needed\n    function updateStakeRatio(uint256 _offset) internal {\n        if (isShutdown) return;\n\n        //get balances\n        uint256 local = stakingToken.balanceOf(address(this));\n        uint256 staked = IStakingProxy(stakingProxy).getBalance();\n        uint256 total = local.add(staked);\n\n        if (total == 0) return;\n\n        //current staked ratio\n        uint256 ratio = staked.mul(denominator).div(total);\n        //mean will be where we reset to if unbalanced\n        uint256 mean = maximumStake.add(minimumStake).div(2);\n        uint256 max = maximumStake.add(_offset);\n        uint256 min = Math.min(minimumStake, minimumStake - _offset);\n        if (ratio > max) {\n            //remove\n            uint256 remove = staked.sub(total.mul(mean).div(denominator));\n            IStakingProxy(stakingProxy).withdraw(remove);\n        } else if (ratio < min) {\n            //add\n            uint256 increase = total.mul(mean).div(denominator).sub(staked);\n            stakingToken.safeTransfer(stakingProxy, increase);\n            IStakingProxy(stakingProxy).stake();\n        }\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake)\n        public\n        nonReentrant\n        updateReward(_account)\n    {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward > 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (_rewardsToken == cvxCrv && _stake) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp >= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining =\n                uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward\n                .add(leftover)\n                .div(rewardsDuration)\n                .to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n        require(_reward > 0, \"No reward\");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _reward\n        );\n\n        emit RewardAdded(_rewardsToken, _reward);\n\n        if (_rewardsToken == cvxCrv) {\n            //update staking ratio if main reward\n            updateStakeRatio(0);\n        }\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            _tokenAddress != address(stakingToken),\n            \"Cannot withdraw staking token\"\n        );\n        require(\n            rewardData[_tokenAddress].lastUpdateTime == 0,\n            \"Cannot withdraw reward token\"\n        );\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n            uint256 boostedBal = userBalance.boosted;\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)\n                    .to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token]\n                        .periodFinish\n                )\n                    .to40();\n                if (_account != address(0)) {\n                    //check if reward is boostable or not. use boosted or locked balance accordingly\n                    rewards[_account][token] = _earned(\n                        _account,\n                        token,\n                        rewardData[token].useBoost\n                            ? boostedBal\n                            : userBalance.locked\n                    );\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 _paidAmount,\n        uint256 _lockedAmount,\n        uint256 _boostedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(\n        address indexed _user,\n        address indexed _kicked,\n        uint256 _reward\n    );\n    event RewardPaid(\n        address indexed _user,\n        address indexed _rewardsToken,\n        uint256 _reward\n    );\n    event Recovered(address _token, uint256 _amount);\n}\n\n\n",
        "CodeNames": [
            "CvxLocker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CvxLocker.setBoost function",
                "Type": "Wrong validation",
                "Description": "Once wrong boost values are set (which are not validated when they are set), they cannot be set to new values anymore, breaking core contract functionality.",
                "Repair": "Implement the correct checks for _max and _rate parameters"
            }
        ]
    }
]