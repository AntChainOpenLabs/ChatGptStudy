[
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\nimport {ModuleTestFixtureGenerator} from \"../lib/ModuleTestFixtureGenerator.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\n\nimport \"policies/Governance.sol\";\nimport {VoterRegistration} from \"policies/VoterRegistration.sol\";\n\ncontract GovernanceTest is Test {\n    using ModuleTestFixtureGenerator for OlympusVotes;\n\n    Kernel internal kernel;\n\n    OlympusInstructions internal INSTR;\n    OlympusVotes internal VOTES;\n\n    OlympusGovernance internal governance;\n    OlympusGovernance internal newProposedPolicy;\n\n    UserFactory public userCreator;\n    address internal voter0;\n    address internal voter1;\n    address internal voter2;\n    address internal voter3;\n    address internal voter4;\n    address internal voter5;\n\n    address internal godmode;\n\n    event InstructionsStored(uint256);\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n    event Transfer(address indexed, address indexed, uint256);\n\n    function setUp() public {\n        vm.warp(block.timestamp + 200 weeks);\n\n        userCreator = new UserFactory();\n\n        /// Create Voters\n        address[] memory users = userCreator.create(7);\n        voter0 = users[0];\n        voter1 = users[1];\n        voter2 = users[2];\n        voter3 = users[3];\n        voter4 = users[4];\n        voter5 = users[5];\n\n        /// Deploy kernel\n        kernel = new Kernel(); // this contract will be the executor\n\n        /// Deploy modules\n        INSTR = new OlympusInstructions(kernel);\n        VOTES = new OlympusVotes(kernel);\n\n        /// Deploy policies\n        governance = new OlympusGovernance(kernel);\n        newProposedPolicy = new OlympusGovernance(kernel);\n\n        /// Install modules\n        kernel.executeAction(Actions.InstallModule, address(INSTR));\n        kernel.executeAction(Actions.InstallModule, address(VOTES));\n\n        /// Approve policies\n        kernel.executeAction(Actions.ActivatePolicy, address(governance));\n\n        // Generate test fixture policy addresses with different authorizations\n        godmode = VOTES.generateGodmodeFixture(type(OlympusVotes).name);\n        kernel.executeAction(Actions.ActivatePolicy, godmode);\n\n        // Change executor\n        kernel.executeAction(Actions.ChangeExecutor, address(governance));\n\n        // Mint tokens to users for testing\n        vm.startPrank(godmode);\n        VOTES.mintTo(voter1, 100);\n        VOTES.mintTo(voter2, 200);\n        VOTES.mintTo(voter3, 300);\n        VOTES.mintTo(voter4, 400);\n        VOTES.mintTo(voter5, 500);\n        vm.stopPrank();\n\n        // approve token governance for transfers\n        vm.prank(voter1);\n        VOTES.approve(address(governance), type(uint256).max);\n        vm.prank(voter2);\n        VOTES.approve(address(governance), type(uint256).max);\n        vm.prank(voter3);\n        VOTES.approve(address(governance), type(uint256).max);\n        vm.prank(voter4);\n        VOTES.approve(address(governance), type(uint256).max);\n        vm.prank(voter5);\n        VOTES.approve(address(governance), type(uint256).max);\n    }\n\n    ////////////////////////////////\n    //    SUBMITTING PROPOSALS    //\n    ////////////////////////////////\n\n    function _submitProposal() internal {\n        // create valid instructions\n        Instruction[] memory instructions_ = new Instruction[](1);\n        instructions_[0] = Instruction(Actions.ActivatePolicy, address(newProposedPolicy));\n\n        // submit proposal as voter1 (100/1500 votes)\n        vm.prank(voter1);\n        governance.submitProposal(instructions_, \"proposalName\", \"This is the proposal URI\");\n    }\n\n    function testRevert_NotEnoughVotesToPropose() public {\n        Instruction[] memory instructions_ = new Instruction[](1);\n        instructions_[0] = Instruction(Actions.ActivatePolicy, address(governance));\n\n        // submit proposal as invalid voter (0/1500 votes)\n        vm.expectRevert(NotEnoughVotesToPropose.selector);\n        vm.prank(voter0);\n        governance.submitProposal(instructions_, \"proposalName\", \"This is the proposal URI\");\n    }\n\n    function testEvent_ProposalSubmitted() public {\n        Instruction[] memory instructions_ = new Instruction[](1);\n        instructions_[0] = Instruction(Actions.ActivatePolicy, address(governance));\n\n        vm.expectEmit(true, true, true, true);\n        emit ProposalSubmitted(1);\n\n        vm.prank(voter1);\n        governance.submitProposal(instructions_, \"proposalName\", \"This is the proposal URI\");\n    }\n\n    function testCorrectness_SuccessfullySubmitProposal() public {\n        Instruction[] memory instructions_ = new Instruction[](1);\n        instructions_[0] = Instruction(Actions.ActivatePolicy, address(governance));\n\n        vm.expectEmit(true, true, true, true);\n        emit InstructionsStored(1);\n\n        vm.prank(voter1);\n        governance.submitProposal(instructions_, \"proposalName\", \"This is the proposal URI\");\n\n        // get the proposal metadata\n        ProposalMetadata memory pls = governance.getMetadata(1);\n        assertEq(pls.submissionTimestamp, block.timestamp);\n        assertEq(pls.title, \"proposalName\");\n        assertEq(pls.submitter, voter1);\n        assertEq(pls.proposalURI, \"This is the proposal URI\");\n    }\n\n    // ////////////////////////////////\n    // //     ENDORSING PROPOSALS    //\n    // ////////////////////////////////\n\n    function testRevert_CannotEndorseNullProposal() public {\n        vm.expectRevert(CannotEndorseNullProposal.selector);\n\n        vm.prank(voter1);\n        governance.endorseProposal(0);\n    }\n\n    function testRevert_CannotEndorseInvalidProposal() public {\n        vm.expectRevert(CannotEndorseInvalidProposal.selector);\n\n        // endorse a proposal that doesn't exist\n        vm.prank(voter1);\n        governance.endorseProposal(1);\n    }\n\n    function testEvent_ProposalEndorsed() public {\n        _submitProposal();\n\n        vm.expectEmit(true, true, true, true);\n        emit ProposalEndorsed(1, voter1, 100);\n\n        vm.prank(voter1);\n        governance.endorseProposal(1);\n    }\n\n    function testCorrectness_UserEndorsesProposal() public {\n        _submitProposal();\n\n        // endorse 100 vote as voter1\n        vm.prank(voter1);\n        governance.endorseProposal(1);\n\n        // check that the contract state is updated correctly\n        assertEq(governance.userEndorsementsForProposal(1, voter1), 100);\n        assertEq(governance.totalEndorsementsForProposal(1), 100);\n\n        // endorse 200 votes as voter2\n        vm.prank(voter2);\n        governance.endorseProposal(1);\n\n        // check that the contract state is updated conrrectly\n        assertEq(governance.totalEndorsementsForProposal(1), 300);\n\n        // issue 5 more votes to voter1\n        vm.prank(godmode);\n        VOTES.mintTo(voter1, 500);\n\n        // reendorse proposal as voter1 with 600 total votes\n        vm.prank(voter1);\n        governance.endorseProposal(1);\n\n        // check that the contract state is updated conrrectly\n        assertEq(governance.userEndorsementsForProposal(1, voter1), 600);\n        assertEq(governance.totalEndorsementsForProposal(1), 800);\n    }\n\n    // ////////////////////////////////\n    // //    ACTIVATING PROPOSALS    //\n    // ////////////////////////////////\n\n    function _createEndorsedProposal() public {\n        _submitProposal();\n\n        // give 300/1500 endorsements to the submitted proposal (20%)\n        vm.prank(voter1);\n        governance.endorseProposal(1);\n\n        vm.prank(voter2);\n        governance.endorseProposal(1);\n    }\n\n    function testRevert_NotAuthorizedToActivateProposal() public {\n        _createEndorsedProposal();\n\n        vm.expectRevert(NotAuthorizedToActivateProposal.selector);\n\n        // call function from not the proposer's wallet\n        vm.prank(voter2);\n        governance.activateProposal(1);\n    }\n\n    function testRevert_SubmittedProposalHasExpired() public {\n        _submitProposal();\n\n        // fast forward 2 weeks and 1 second\n        vm.warp(block.timestamp + 2 weeks + 1);\n\n        vm.expectRevert(SubmittedProposalHasExpired.selector);\n\n        vm.prank(voter1);\n        governance.activateProposal(1);\n    }\n\n    function testRevert_NotEnoughEndorsementsToActivateProposal() public {\n        _submitProposal();\n\n        // give the proposal 200/300 necessary endorsements\n        vm.prank(voter2);\n        governance.endorseProposal(1);\n\n        vm.expectRevert(NotEnoughEndorsementsToActivateProposal.selector);\n\n        vm.prank(voter1);\n        governance.activateProposal(1);\n    }\n\n    function testRevert_ProposalAlreadyActivated() public {\n        _createEndorsedProposal();\n\n        vm.prank(voter1);\n        governance.activateProposal(1);\n\n        vm.expectRevert(ProposalAlreadyActivated.selector);\n\n        // activate the proposal again\n        vm.prank(voter1);\n        governance.activateProposal(1);\n    }\n\n    function testRevert_ActiveProposalNotExpired() public {\n        _createEndorsedProposal();\n        vm.prank(voter1);\n        governance.activateProposal(1);\n\n        // submit & endorse a second proposal\n        _submitProposal();\n        vm.prank(voter1);\n        governance.endorseProposal(2);\n        vm.prank(voter2);\n        governance.endorseProposal(2);\n\n        vm.expectRevert(ActiveProposalNotExpired.selector);\n\n        // try to activate the second proposal\n        vm.prank(voter1);\n        governance.activateProposal(2);\n    }\n\n    function testEvent_ProposalActivated() public {\n        _createEndorsedProposal();\n\n        vm.expectEmit(true, true, true, true);\n        emit ProposalActivated(1, block.timestamp);\n\n        vm.prank(voter1);\n        governance.activateProposal(1);\n    }\n\n    function testCorrectness_ProposerActivatesSubmittedProposal() public {\n        _createEndorsedProposal();\n        vm.prank(voter1);\n        governance.activateProposal(1);\n\n        // check that the active proposal data is correct\n        ActivatedProposal memory activeProposal = governance.getActiveProposal();\n\n        assertEq(activeProposal.proposalId, 1);\n        assertEq(activeProposal.activationTimestamp, block.timestamp);\n        assertTrue(governance.proposalHasBeenActivated(1));\n\n        // submit another valid proposal and endorse it to 20% (300/1500 total votes)\n        _submitProposal();\n        vm.prank(voter1);\n        governance.endorseProposal(2);\n        vm.prank(voter2);\n        governance.endorseProposal(2);\n\n        // expire the first proposal by moving forward 1 week + 1 second\n        vm.warp(block.timestamp + 1 weeks + 3);\n\n        // activate the second proposal\n        vm.prank(voter1);\n        governance.activateProposal(2);\n\n        // check that the new proposal has been activated\n        activeProposal = governance.getActiveProposal();\n\n        assertEq(activeProposal.proposalId, 2);\n        assertTrue(governance.proposalHasBeenActivated(2));\n    }\n\n    ////////////////////////////////\n    //    VOTING ON EXECTUTION    //\n    ////////////////////////////////\n\n    function _createActiveProposal() public {\n        _createEndorsedProposal();\n        vm.prank(voter1);\n        governance.activateProposal(1);\n    }\n\n    function testRevert_NoActiveProposalDetected() public {\n        vm.expectRevert(NoActiveProposalDetected.selector);\n\n        vm.prank(voter1);\n        governance.vote(true);\n    }\n\n    function testRevert_UserAlreadyVoted() public {\n        _createActiveProposal();\n\n        vm.prank(voter1);\n        governance.vote(true);\n\n        vm.expectRevert(UserAlreadyVoted.selector);\n\n        // try to vote again\n        vm.prank(voter1);\n        governance.vote(true);\n    }\n\n    function testEvent_WalletVoted() public {\n        _createActiveProposal();\n\n        vm.expectEmit(true, true, true, true);\n        emit WalletVoted(1, voter1, false, 100);\n\n        vm.prank(voter1);\n        governance.vote(false);\n    }\n\n    function testCorrectness_UserVotesForProposal() public {\n        _createActiveProposal();\n\n        // vm.expectEmit(true, true, true, true);\n        // emit Transfer(voter1, address(governance), 1);\n\n        vm.prank(voter1);\n        governance.vote(true);\n\n        // check voting state\n        assertEq(governance.userVotesForProposal(1, voter1), 100);\n        assertEq(governance.yesVotesForProposal(1), 100);\n\n        // // test token transfer\n        assertEq(VOTES.balanceOf(address(voter1)), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 100);\n\n        // vm.expectEmit(true, true, true, true);\n        // emit Transfer(voter2, address(governance), 2);\n\n        vm.prank(voter2);\n        governance.vote(false);\n\n        // check voting state\n        assertEq(governance.userVotesForProposal(1, voter2), 200);\n        assertEq(governance.noVotesForProposal(1), 200);\n\n        // test token transfer\n        assertEq(VOTES.balanceOf(address(voter2)), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n    }\n\n    ////////////////////////////////\n    //   EXECUTING INSTRUCTIONS   //\n    ////////////////////////////////\n\n    function _createApprovedInstructions() public {\n        _createActiveProposal();\n        vm.prank(voter5);\n        governance.vote(true);\n    }\n\n    function testRevert_NotEnoughVotesToExecute() public {\n        // submit, endorse, and activate a proposal\n        _createActiveProposal();\n\n        // cast 4 net votes for the proposal (5 needed)\n        vm.prank(voter4);\n        governance.vote(true);\n\n        vm.prank(voter3);\n        governance.vote(true);\n\n        vm.prank(voter2);\n        governance.vote(false);\n\n        vm.prank(voter1);\n        governance.vote(false);\n\n        vm.expectRevert(NotEnoughVotesToExecute.selector);\n        governance.executeProposal();\n    }\n\n    function testRevert_ExecutionTimelockStillActive() public {\n        _createApprovedInstructions();\n\n        vm.expectRevert(ExecutionTimelockStillActive.selector);\n        governance.executeProposal();\n    }\n\n    function testEvent_ProposalExecuted() public {\n        _createApprovedInstructions();\n\n        // move 3 days + 1 second into the future\n        vm.warp(block.timestamp + 3 days + 1);\n\n        vm.expectEmit(true, true, true, true);\n        emit ProposalExecuted(1);\n\n        governance.executeProposal();\n    }\n\n    function testCorrectness_executeInstructions() public {\n        _createApprovedInstructions();\n\n        // move 3 days + 1 second into the future\n        vm.warp(block.timestamp + 3 days + 1);\n\n        vm.expectEmit(true, true, true, true);\n        emit ProposalExecuted(1);\n\n        governance.executeProposal();\n\n        // check that the proposal is no longer active\n        ActivatedProposal memory activeProposal = governance.getActiveProposal();\n\n        assertEq(activeProposal.proposalId, 0);\n        assertEq(activeProposal.activationTimestamp, 0);\n\n        // check that the proposed contracts are approved in the kernel\n        assertTrue(Policy(newProposedPolicy).isActive());\n    }\n\n    ////////////////////////////////\n    //   RECLAIMING VOTE TOKENS   //\n    ////////////////////////////////\n\n    function _executeProposal() public {\n        _createApprovedInstructions();\n        vm.warp(block.timestamp + 3 days + 1);\n        governance.executeProposal();\n        assertEq(VOTES.balanceOf(voter5), 0);\n    }\n\n    function testRevert_CannotReclaimZeroVotes() public {\n        _executeProposal();\n        vm.expectRevert(CannotReclaimZeroVotes.selector);\n\n        vm.prank(voter4);\n        governance.reclaimVotes(1);\n    }\n\n    function testRevert_CannotReclaimTokensForActiveVote() public {\n        _createApprovedInstructions();\n\n        vm.expectRevert(CannotReclaimTokensForActiveVote.selector);\n\n        vm.prank(voter5);\n        governance.reclaimVotes(1);\n    }\n\n    function testRevert_VotingTokensAlreadyReclaimed() public {\n        _executeProposal();\n\n        vm.prank(voter5);\n        governance.reclaimVotes(1);\n\n        vm.expectRevert(VotingTokensAlreadyReclaimed.selector);\n\n        vm.prank(voter5);\n        governance.reclaimVotes(1);\n    }\n\n    function testCorrectness_SuccessfullyReclaimVotes() public {\n        _executeProposal();\n\n        // vm.expectEmit(true, true, true, true);\n        // emit Transfer(address(governance), voter5, 5);\n\n        vm.prank(voter5);\n        governance.reclaimVotes(1);\n\n        // check that the claim has been recorded\n        assertTrue(governance.tokenClaimsForProposal(1, voter5));\n\n        // check that the voting tokens are successfully returned to the user from the contract\n        assertEq(VOTES.balanceOf(voter5), 500);\n        assertEq(VOTES.balanceOf(address(governance)), 0);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// The Governance Policy submits & activates instructions in a INSTR module\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n// proposing\nerror NotEnoughVotesToPropose();\n\n// endorsing\nerror CannotEndorseNullProposal();\nerror CannotEndorseInvalidProposal();\n\n// activating\nerror NotAuthorizedToActivateProposal();\nerror NotEnoughEndorsementsToActivateProposal();\nerror ProposalAlreadyActivated();\nerror ActiveProposalNotExpired();\nerror SubmittedProposalHasExpired();\n\n// voting\nerror NoActiveProposalDetected();\nerror UserAlreadyVoted();\n\n// executing\nerror NotEnoughVotesToExecute();\nerror ExecutionTimelockStillActive();\n\n// claiming\nerror VotingTokensAlreadyReclaimed();\nerror CannotReclaimTokensForActiveVote();\nerror CannotReclaimZeroVotes();\n\nstruct ProposalMetadata {\n    bytes32 title;\n    address submitter;\n    uint256 submissionTimestamp;\n    string proposalURI;\n}\n\nstruct ActivatedProposal {\n    uint256 proposalId;\n    uint256 activationTimestamp;\n}\n\n/// @notice OlympusGovernance\n/// @dev The Governor Policy is also the Kernel's Executor.\ncontract OlympusGovernance is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"INSTR\");\n        dependencies[1] = toKeycode(\"VOTES\");\n\n        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));\n        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));\n    }\n\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                             Policy Variables                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n\n    /// @notice The currently activated proposal in the governance system.\n    ActivatedProposal public activeProposal;\n\n    /// @notice Return a proposal metadata object for a given proposal id.\n    mapping(uint256 => ProposalMetadata) public getProposalMetadata;\n\n    /// @notice Return the total endorsements for a proposal id.\n    mapping(uint256 => uint256) public totalEndorsementsForProposal;\n\n    /// @notice Return the number of endorsements a user has given a proposal id.\n    mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal;\n\n    /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false.\n    mapping(uint256 => bool) public proposalHasBeenActivated;\n\n    /// @notice Return the total yes votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public yesVotesForProposal;\n\n    /// @notice Return the total no votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public noVotesForProposal;\n\n    /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted.\n    mapping(uint256 => mapping(address => uint256)) public userVotesForProposal;\n\n    /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id.\n    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\n\n    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n    /// @dev    This is set to 1% of the total supply.\n    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n\n    /// @notice Amount of time a submitted proposal has to activate before it expires.\n    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n\n    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n\n    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n    uint256 public constant EXECUTION_THRESHOLD = 33;\n\n    /// @notice Required time for a proposal to be active before it can be executed.\n    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                               User Actions                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the metadata for a proposal.\n    /// @dev    Used to return & access the entire metadata struct in solidity\n    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {\n        return getProposalMetadata[proposalId_];\n    }\n\n    /// @notice Return the currently active proposal in governance.\n    /// @dev    Used to return & access the entire struct active proposal struct in solidity.\n    function getActiveProposal() public view returns (ActivatedProposal memory) {\n        return activeProposal;\n    }\n\n    /// @notice Submit an on chain governance proposal.\n    /// @param  instructions_ - an array of Instruction objects each containing a Kernel Action and a target Contract address.\n    /// @param  title_ - a human-readable title of the proposal \u2014 i.e. \"OIP XX - My Proposal Title\".\n    /// @param  proposalURI_ - an arbitrary url linking to a human-readable description of the proposal - i.e. Snapshot, Discourse, Google Doc.\n    function submitProposal(\n        Instruction[] calldata instructions_,\n        bytes32 title_,\n        string memory proposalURI_\n    ) external {\n        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\n            revert NotEnoughVotesToPropose();\n\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n\n        emit ProposalSubmitted(proposalId);\n    }\n\n    /// @notice Endorse a proposal.\n    /// @param  proposalId_ - The ID of the proposal being endorsed.\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n\n    /// @notice Activate a proposal.\n    /// @param  proposalId_ - The ID of the proposal being activated.\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    /// @notice Cast a vote for the currently active proposal.\n    /// @param  for_ - A boolean representing the vote: true for yes, false for no.\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n    /// @notice Execute the currently active proposal.\n    function executeProposal() external {\n        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -\n            noVotesForProposal[activeProposal.proposalId];\n        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\n            revert NotEnoughVotesToExecute();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {\n            revert ExecutionTimelockStillActive();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);\n\n        for (uint256 step; step < instructions.length; ) {\n            kernel.executeAction(instructions[step].action, instructions[step].target);\n            unchecked {\n                ++step;\n            }\n        }\n\n        emit ProposalExecuted(activeProposal.proposalId);\n\n        // deactivate the active proposal\n        activeProposal = ActivatedProposal(0, 0);\n    }\n\n    /// @notice Reclaim locked votes from the contract after the proposal is no longer active.\n    /// @dev    The governance contract locks casted votes into the contract until the proposal\n    ///         is no longer active to prevent repeated voting with the same tokens.\n    /// @param  proposalId_ - The proposal that the user is reclaiming tokens for.\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            revert CannotReclaimTokensForActiveVote();\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n}\n\n\n",
        "CodeNames": [
            "Governance.t.sol",
            "Governance.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Governance.sol",
                "Type": "High Severity",
                "Description": "Anyone can pass any proposal alone before first VOTES are minted.",
                "Repair": "Add a check for minimum VOTES totalSupply before allowing proposal submission and execution"
            },
            {
                "Location": "Governance.sol",
                "Type": "Medium Severity",
                "Description": "It is possible to overwrite proposals in certain circumstances.",
                "Repair": "Store the proposal metadata in the same INSTR contract or ensure that the proposal doesn't exist"
            },
            {
                "Location": "Governance.sol",
                "Type": "governance vulnerability",
                "Description": "A malicious user with a relatively low voting power can prevent any other proposal from being activated, potentially holding the governance system hostage.",
                "Repair": "Increase the endorsement threshold or implement other solutions to temporarily liberate the governance system"
            },
            {
                "Location": "Governance.sol",
                "Type": "Impossible to activate a new proposal",
                "Description": "In Governance.sol, it might be impossible to activate a new proposal forever after failed to execute the previous active proposal.",
                "Repair": "Add a constant like EXECUTION_EXPIRE and modify reclaimVotes() function"
            },
            {
                "Location": "endorseProposal function in Governance.sol and activateProposal function in Governance.sol",
                "Type": "Transferring votes to another user for endorsing the same proposal again",
                "Description": "One user can first use her or his votes to endorse a proposal and then transfer these votes to another user. The other user can use these votes to endorse the same proposal again afterwards.",
                "Repair": "Add an additional function for reclaiming the endorsed votes back to the user and reducing the proposal's endorsed votes accordingly before the proposal is activated. After the proposal is activated, the endorsed votes should be counted as the voted votes."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\nimport \"src/Kernel.sol\";\n\n// ERRORS\nerror TRSRY_NotApproved();\nerror TRSRY_NoDebtOutstanding();\n\n/// @notice Treasury holds reserves, LP tokens and all other assets under the control\n///         of the protocol.\ncontract OlympusTreasury is Module, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    event ApprovedForWithdrawal(address indexed policy_, ERC20 indexed token_, uint256 amount_);\n    event Withdrawal(\n        address indexed policy_,\n        address indexed withdrawer_,\n        ERC20 indexed token_,\n        uint256 amount_\n    );\n    event DebtIncurred(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtRepaid(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtSet(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n\n    /// @notice Mapping of who is approved for withdrawal.\n    /// @dev    withdrawer -> token -> amount. Infinite approval is max(uint256).\n    mapping(address => mapping(ERC20 => uint256)) public withdrawApproval;\n\n    /// @notice Total debt for token across all withdrawals.\n    mapping(ERC20 => uint256) public totalDebt;\n\n    /// @notice Debt for particular token and debtor address\n    mapping(ERC20 => mapping(address => uint256)) public reserveDebt;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"TRSRY\");\n    }\n\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function getReserveBalance(ERC20 token_) external view returns (uint256) {\n        return token_.balanceOf(address(this)) + totalDebt[token_];\n    }\n\n    /// @notice Sets approval for specific withdrawer addresses\n    function setApprovalFor(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) external permissioned {\n        withdrawApproval[withdrawer_][token_] = amount_;\n\n        emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n    }\n\n    /// @notice Allow withdrawal of reserve funds from pre-approved addresses.\n    function withdrawReserves(\n        address to_,\n        ERC20 token_,\n        uint256 amount_\n    ) public {\n        _checkApproval(msg.sender, token_, amount_);\n\n        token_.safeTransfer(to_, amount_);\n\n        emit Withdrawal(msg.sender, to_, token_, amount_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             DEBT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pre-approved policies can get a loan to perform operations on treasury assets.\n    function getLoan(ERC20 token_, uint256 amount_) external permissioned {\n        _checkApproval(msg.sender, token_, amount_);\n\n        // Add debt to caller\n        reserveDebt[token_][msg.sender] += amount_;\n        totalDebt[token_] += amount_;\n\n        token_.safeTransfer(msg.sender, amount_);\n\n        emit DebtIncurred(token_, msg.sender, amount_);\n    }\n\n    /// @notice Lets an address with debt repay their loan.\n    function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {\n        if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();\n\n        // Deposit from caller first (to handle nonstandard token transfers)\n        uint256 prevBalance = token_.balanceOf(address(this));\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n\n        uint256 received = token_.balanceOf(address(this)) - prevBalance;\n\n        // Subtract debt from caller\n        reserveDebt[token_][msg.sender] -= received;\n        totalDebt[token_] -= received;\n\n        emit DebtRepaid(token_, msg.sender, received);\n    }\n\n    /// @notice An escape hatch for setting debt in special cases, like swapping reserves to another token.\n    function setDebt(\n        ERC20 token_,\n        address debtor_,\n        uint256 amount_\n    ) external permissioned {\n        uint256 oldDebt = reserveDebt[token_][debtor_];\n\n        reserveDebt[token_][debtor_] = amount_;\n\n        if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;\n        else totalDebt[token_] -= oldDebt - amount_;\n\n        emit DebtSet(token_, debtor_, amount_);\n    }\n\n    function _checkApproval(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) internal {\n        // Must be approved\n        uint256 approval = withdrawApproval[withdrawer_][token_];\n        if (approval < amount_) revert TRSRY_NotApproved();\n\n        // Check for infinite approval\n        if (approval != type(uint256).max) {\n            unchecked {\n                withdrawApproval[withdrawer_][token_] = approval - amount_;\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\nimport {console2 as console} from \"forge-std/console2.sol\";\nimport {ModuleTestFixtureGenerator} from \"test/lib/ModuleTestFixtureGenerator.sol\";\n\nimport {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\nimport {MockPolicy} from \"test/mocks/KernelTestMocks.sol\";\n\nimport \"src/modules/TRSRY.sol\";\nimport \"src/Kernel.sol\";\n\ncontract TRSRYTest is Test {\n    using ModuleTestFixtureGenerator for OlympusTreasury;\n\n    Kernel internal kernel;\n    OlympusTreasury public TRSRY;\n    MockERC20 public ngmi;\n    address public testUser;\n    address public godmode;\n    address public debtor;\n\n    uint256 internal constant INITIAL_TOKEN_AMOUNT = 100e18;\n\n    function setUp() public {\n        kernel = new Kernel();\n        TRSRY = new OlympusTreasury(kernel);\n        ngmi = new MockERC20(\"not gonna make it\", \"NGMI\", 18);\n\n        address[] memory users = (new UserFactory()).create(3);\n        testUser = users[0];\n\n        kernel.executeAction(Actions.InstallModule, address(TRSRY));\n\n        // Generate test fixture policy addresses with different authorizations\n        godmode = TRSRY.generateGodmodeFixture(type(OlympusTreasury).name);\n        kernel.executeAction(Actions.ActivatePolicy, godmode);\n\n        debtor = TRSRY.generateFunctionFixture(TRSRY.getLoan.selector);\n        kernel.executeAction(Actions.ActivatePolicy, debtor);\n\n        // Give TRSRY some tokens\n        ngmi.mint(address(TRSRY), INITIAL_TOKEN_AMOUNT);\n    }\n\n    function testCorrectness_KEYCODE() public {\n        assertEq32(\"TRSRY\", Keycode.unwrap(TRSRY.KEYCODE()));\n    }\n\n    function testCorrectness_WithdrawApproval(uint256 amount_) public {\n        vm.prank(godmode);\n        TRSRY.setApprovalFor(testUser, ngmi, amount_);\n\n        assertEq(TRSRY.withdrawApproval(testUser, ngmi), amount_);\n    }\n\n    /*\n    function testCorrectness_RevokeApprovals() public {\n        TRSRY.setApprovalFor(testUser, ngmi, INITIAL_TOKEN_AMOUNT);\n        assertEq(TRSRY.withdrawApproval(testUser, ngmi), INITIAL_TOKEN_AMOUNT);\n\n        ERC20[] memory revokeTokens = new ERC20[](2);\n        revokeTokens[0] = ERC20(ngmi);\n\n        kernel.executeAction(Actions.DeactivatePolicy, address(this));\n\n        TRSRY.revokeApprovals(testUser, revokeTokens);\n        assertEq(TRSRY.withdrawApproval(testUser, ngmi), 0);\n    }\n    */\n\n    function testCorrectness_GetReserveBalance() public {\n        assertEq(TRSRY.getReserveBalance(ngmi), INITIAL_TOKEN_AMOUNT);\n    }\n\n    function testCorrectness_ApprovedCanWithdrawToken(uint256 amount_) public {\n        vm.assume(amount_ < INITIAL_TOKEN_AMOUNT);\n\n        vm.prank(godmode);\n        TRSRY.setApprovalFor(testUser, ngmi, amount_);\n\n        assertEq(TRSRY.withdrawApproval(testUser, ngmi), amount_);\n\n        vm.prank(testUser);\n        TRSRY.withdrawReserves(address(this), ngmi, amount_);\n\n        assertEq(ngmi.balanceOf(address(this)), amount_);\n    }\n\n    // TODO test if can withdraw more than allowed amount\n    //function testRevert_WithdrawMoreThanApproved(uint256 amount_) public {}\n\n    function testRevert_UnauthorizedCannotWithdrawToken(uint256 amount_) public {\n        vm.assume(amount_ < INITIAL_TOKEN_AMOUNT);\n        vm.assume(amount_ > 0);\n\n        // Fail when withdrawal using policy without write access\n        vm.expectRevert(TRSRY_NotApproved.selector);\n        vm.prank(testUser);\n        TRSRY.withdrawReserves(address(this), ngmi, amount_);\n    }\n\n    function testCorrectness_GetLoan(uint256 amount_) public {\n        vm.assume(amount_ < INITIAL_TOKEN_AMOUNT);\n        vm.assume(amount_ > 0);\n\n        vm.prank(godmode);\n        TRSRY.setApprovalFor(debtor, ngmi, amount_);\n\n        vm.prank(debtor);\n        TRSRY.getLoan(ngmi, amount_);\n\n        assertEq(ngmi.balanceOf(debtor), amount_);\n        assertEq(TRSRY.reserveDebt(ngmi, debtor), amount_);\n        assertEq(TRSRY.totalDebt(ngmi), amount_);\n\n        // Reserve balance should remain the same, since we withdrew as debt\n        assertEq(TRSRY.getReserveBalance(ngmi), INITIAL_TOKEN_AMOUNT);\n    }\n\n    function testRevert_UnauthorizedCannotGetLoan(uint256 amount_) public {\n        vm.assume(amount_ < INITIAL_TOKEN_AMOUNT);\n        vm.assume(amount_ > 0);\n\n        address unapprovedPolicy = address(new MockPolicy(kernel));\n\n        vm.prank(godmode);\n        TRSRY.setApprovalFor(unapprovedPolicy, ngmi, amount_);\n\n        bytes memory err = abi.encodeWithSelector(\n            Module_PolicyNotPermitted.selector,\n            unapprovedPolicy\n        );\n        vm.expectRevert(err);\n        vm.prank(unapprovedPolicy);\n        TRSRY.getLoan(ngmi, amount_);\n    }\n\n    function testCorrectness_RepayLoan(uint256 amount_) public {\n        vm.assume(amount_ > 0);\n        vm.assume(amount_ < INITIAL_TOKEN_AMOUNT);\n\n        vm.prank(godmode);\n        TRSRY.setApprovalFor(debtor, ngmi, amount_);\n\n        vm.startPrank(debtor);\n        TRSRY.getLoan(ngmi, amount_);\n\n        assertEq(ngmi.balanceOf(debtor), amount_);\n        assertEq(TRSRY.reserveDebt(ngmi, debtor), amount_);\n\n        // Repay loan\n        ngmi.approve(address(TRSRY), amount_);\n        TRSRY.repayLoan(ngmi, amount_);\n        vm.stopPrank();\n\n        assertEq(ngmi.balanceOf(debtor), 0);\n    }\n\n    // TODO test RepayLoan with no loan outstanding. should revert\n\n    function testCorrectness_SetDebt() public {\n        vm.prank(godmode);\n        TRSRY.setApprovalFor(debtor, ngmi, INITIAL_TOKEN_AMOUNT);\n\n        vm.prank(debtor);\n        TRSRY.getLoan(ngmi, INITIAL_TOKEN_AMOUNT);\n\n        // Change the debt amount of the debtor to half\n        vm.prank(godmode);\n        TRSRY.setDebt(ngmi, debtor, INITIAL_TOKEN_AMOUNT / 2);\n\n        assertEq(TRSRY.reserveDebt(ngmi, debtor), INITIAL_TOKEN_AMOUNT / 2);\n        assertEq(TRSRY.totalDebt(ngmi), INITIAL_TOKEN_AMOUNT / 2);\n    }\n\n    function testRevert_UnauthorizedPolicyCannotSetDebt() public {\n        vm.prank(godmode);\n        TRSRY.setApprovalFor(debtor, ngmi, INITIAL_TOKEN_AMOUNT);\n\n        vm.prank(debtor);\n        TRSRY.getLoan(ngmi, INITIAL_TOKEN_AMOUNT);\n\n        // Fail when calling setDebt from debtor (policy without setDebt permissions)\n        bytes memory err = abi.encodeWithSelector(Module_PolicyNotPermitted.selector, debtor);\n        vm.expectRevert(err);\n        vm.prank(debtor);\n        TRSRY.setDebt(ngmi, debtor, INITIAL_TOKEN_AMOUNT / 2);\n    }\n\n    function testCorrectness_ClearDebt() public {\n        vm.prank(godmode);\n        TRSRY.setApprovalFor(debtor, ngmi, INITIAL_TOKEN_AMOUNT);\n\n        vm.prank(debtor);\n        TRSRY.getLoan(ngmi, INITIAL_TOKEN_AMOUNT);\n\n        assertEq(TRSRY.reserveDebt(ngmi, debtor), INITIAL_TOKEN_AMOUNT);\n        assertEq(TRSRY.totalDebt(ngmi), INITIAL_TOKEN_AMOUNT);\n\n        vm.prank(godmode);\n        TRSRY.setDebt(ngmi, debtor, 0);\n\n        assertEq(TRSRY.reserveDebt(ngmi, debtor), 0);\n        assertEq(TRSRY.totalDebt(ngmi), 0);\n    }\n}\n\n\n",
        "CodeNames": [
            "TRSRY.sol",
            "TRSRY.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TRSRY.sol",
                "Type": "Medium Severity",
                "Description": "Solmate safetransfer and safetransferfrom does not check the codesize of the token address, which may lead to fund loss.",
                "Repair": "Use openzeppelin's safeERC20 or implement a code existence check"
            },
            {
                "Location": "TRSRY.sol",
                "Type": "Low market bonds/swaps not working",
                "Description": "Low market bonds/swaps not working after loan is taken from treasury.",
                "Repair": "Determine capacity from actual tokens held by treasury"
            },
            {
                "Location": "TRSRY susceptible to loan / withdraw confusion",
                "Type": "Confusion between loan and withdraw approval",
                "Description": "Treasury allocates approvals in the withdrawApproval mapping which is set via setApprovalFor(). In both withdrawReserves() and in getLoan(), _checkApproval() is used to verify user has enough approval and subtracts the withdraw / loan amount. Therefore, there is no differentiation in validation between loan approval and withdraw approval.",
                "Repair": "Implement a separate mapping called loanApproval"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {AggregatorV2V3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport \"src/Kernel.sol\";\n\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n// ERRORS\nerror Price_InvalidParams();\nerror Price_NotInitialized();\nerror Price_AlreadyInitialized();\nerror Price_BadFeed(address priceFeed);\n\n/// @notice Price oracle data storage contract\n/// @dev    The Olympus Price Oracle contract provides a standard interface for OHM price data against a reserve asset.\n///         It also implements a moving average price calculation (same as a TWAP) on the price feed data over a configured\n///         duration and observation frequency. The data provided by this contract is used by the Olympus Range Operator to\n///         perform market operations. The Olympus Price Oracle is updated each epoch by the Olympus Heart contract.\ncontract OlympusPrice is Module {\n    using FullMath for uint256;\n\n    /* ========== EVENTS =========== */\n    event NewObservation(uint256 timestamp_, uint256 price_, uint256 movingAverage_);\n    event MovingAverageDurationChanged(uint48 movingAverageDuration_);\n    event ObservationFrequencyChanged(uint48 observationFrequency_);\n    /* ========== STATE VARIABLES ========== */\n\n    /// @dev    Price feeds. Chainlink typically provides price feeds for an asset in ETH. Therefore, we use two price feeds against ETH, one for OHM and one for the Reserve asset, to calculate the relative price of OHM in the Reserve asset.\n    AggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\n    AggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\n\n    /// @dev Moving average data\n    uint256 internal _movingAverage; /// See getMovingAverage()\n\n    /// @notice Array of price observations. Check nextObsIndex to determine latest data point.\n    /// @dev    Observations are stored in a ring buffer where the moving average is the sum of all observations divided by the number of observations.\n    ///         Observations can be cleared by changing the movingAverageDuration or observationFrequency and must be re-initialized.\n    uint256[] public observations;\n\n    /// @notice Index of the next observation to make. The current value at this index is the oldest observation.\n    uint32 public nextObsIndex;\n\n    /// @notice Number of observations used in the moving average calculation. Computed from movingAverageDuration / observationFrequency.\n    uint32 public numObservations;\n\n    /// @notice Frequency (in seconds) that observations should be stored.\n    uint48 public observationFrequency;\n\n    /// @notice Duration (in seconds) over which the moving average is calculated.\n    uint48 public movingAverageDuration;\n\n    /// @notice Unix timestamp of last observation (in seconds).\n    uint48 public lastObservationTime;\n\n    /// @notice Number of decimals in the price values provided by the contract.\n    uint8 public constant decimals = 18;\n\n    /// @notice Whether the price module is initialized (and therefore active).\n    bool public initialized;\n\n    // Scale factor for converting prices, calculated from decimal values.\n    uint256 internal immutable _scaleFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        AggregatorV2V3Interface ohmEthPriceFeed_,\n        AggregatorV2V3Interface reserveEthPriceFeed_,\n        uint48 observationFrequency_,\n        uint48 movingAverageDuration_\n    ) Module(kernel_) {\n        /// @dev Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency_ != 0)\n            revert Price_InvalidParams();\n\n        // Set price feeds, decimals, and scale factor\n        _ohmEthPriceFeed = ohmEthPriceFeed_;\n        uint8 ohmEthDecimals = _ohmEthPriceFeed.decimals();\n\n        _reserveEthPriceFeed = reserveEthPriceFeed_;\n        uint8 reserveEthDecimals = _reserveEthPriceFeed.decimals();\n\n        uint256 exponent = decimals + reserveEthDecimals - ohmEthDecimals;\n        if (exponent > 38) revert Price_InvalidParams();\n        _scaleFactor = 10**exponent;\n\n        // Set parameters and calculate number of observations\n        observationFrequency = observationFrequency_;\n        movingAverageDuration = movingAverageDuration_;\n\n        numObservations = uint32(movingAverageDuration_ / observationFrequency_);\n\n        // Store blank observations array\n        observations = new uint256[](numObservations);\n        /// nextObsIndex is initialized to 0\n\n        emit MovingAverageDurationChanged(movingAverageDuration_);\n        emit ObservationFrequencyChanged(observationFrequency_);\n    }\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"PRICE\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /* ========== POLICY FUNCTIONS ========== */\n\n    /// @notice Trigger an update of the moving average. Permissioned.\n    /// @dev    This function does not have a time-gating on the observationFrequency on this contract. It is set on the Heart policy contract.\n    ///         The Heart beat frequency should be set to the same value as the observationFrequency.\n    function updateMovingAverage() external permissioned {\n        // Revert if not initialized\n        if (!initialized) revert Price_NotInitialized();\n\n        // Cache numbe of observations to save gas.\n        uint32 numObs = numObservations;\n\n        // Get earliest observation in window\n        uint256 earliestPrice = observations[nextObsIndex];\n\n        uint256 currentPrice = getCurrentPrice();\n\n        // Calculate new moving average\n        if (currentPrice > earliestPrice) {\n            _movingAverage += (currentPrice - earliestPrice) / numObs;\n        } else {\n            _movingAverage -= (earliestPrice - currentPrice) / numObs;\n        }\n\n        // Push new observation into storage and store timestamp taken at\n        observations[nextObsIndex] = currentPrice;\n        lastObservationTime = uint48(block.timestamp);\n        nextObsIndex = (nextObsIndex + 1) % numObs;\n\n        emit NewObservation(block.timestamp, currentPrice, _movingAverage);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the current price of OHM in the Reserve asset from the price feeds\n    function getCurrentPrice() public view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n\n        // Get prices from feeds\n        uint256 ohmEthPrice;\n        uint256 reserveEthPrice;\n        {\n            (, int256 ohmEthPriceInt, , uint256 updatedAt, ) = _ohmEthPriceFeed.latestRoundData();\n            // Use a multiple of observation frequency to determine what is too old to use.\n            // Price feeds will not provide an updated answer if the data doesn't change much.\n            // This would be similar to if the feed just stopped updating; therefore, we need a cutoff.\n            if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))\n                revert Price_BadFeed(address(_ohmEthPriceFeed));\n            ohmEthPrice = uint256(ohmEthPriceInt);\n\n            int256 reserveEthPriceInt;\n            (, reserveEthPriceInt, , updatedAt, ) = _reserveEthPriceFeed.latestRoundData();\n            if (updatedAt < block.timestamp - uint256(observationFrequency))\n                revert Price_BadFeed(address(_reserveEthPriceFeed));\n            reserveEthPrice = uint256(reserveEthPriceInt);\n        }\n\n        // Convert to OHM/RESERVE price\n        uint256 currentPrice = (ohmEthPrice * _scaleFactor) / reserveEthPrice;\n\n        return currentPrice;\n    }\n\n    /// @notice Get the last stored price observation of OHM in the Reserve asset\n    function getLastPrice() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;\n        return observations[lastIndex];\n    }\n\n    /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).\n    function getMovingAverage() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        return _movingAverage;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initialize the price module\n    /// @notice Access restricted to activated policies\n    /// @param  startObservations_ - Array of observations to initialize the moving average with. Must be of length numObservations.\n    /// @param  lastObservationTime_ - Unix timestamp of last observation being provided (in seconds).\n    /// @dev    This function must be called after the Price module is deployed to activate it and after updating the observationFrequency\n    ///         or movingAverageDuration (in certain cases) in order for the Price module to function properly.\n    function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)\n        external\n        permissioned\n    {\n        if (initialized) revert Price_AlreadyInitialized();\n\n        // Cache numObservations to save gas.\n        uint256 numObs = observations.length;\n\n        // Check that the number of start observations matches the number expected\n        if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))\n            revert Price_InvalidParams();\n\n        // Push start observations into storage and total up observations\n        uint256 total;\n        for (uint256 i; i < numObs; ) {\n            if (startObservations_[i] == 0) revert Price_InvalidParams();\n            total += startObservations_[i];\n            observations[i] = startObservations_[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Set moving average, last observation time, and initialized flag\n        _movingAverage = total / numObs;\n        lastObservationTime = lastObservationTime_;\n        initialized = true;\n    }\n\n    /// @notice Change the moving average window (duration)\n    /// @param  movingAverageDuration_ - Moving average duration in seconds, must be a multiple of observation frequency\n    /// @dev    Changing the moving average duration will erase the current observations array\n    ///         and require the initialize function to be called again. Ensure that you have saved\n    ///         the existing data and can re-populate before calling this function.\n    function changeMovingAverageDuration(uint48 movingAverageDuration_) external permissioned {\n        // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)\n            revert Price_InvalidParams();\n\n        // Calculate the new number of observations\n        uint256 newObservations = uint256(movingAverageDuration_ / observationFrequency);\n\n        // Store blank observations array of new size\n        observations = new uint256[](newObservations);\n\n        // Set initialized to false and update state variables\n        initialized = false;\n        lastObservationTime = 0;\n        _movingAverage = 0;\n        nextObsIndex = 0;\n        movingAverageDuration = movingAverageDuration_;\n        numObservations = uint32(newObservations);\n\n        emit MovingAverageDurationChanged(movingAverageDuration_);\n    }\n\n    /// @notice   Change the observation frequency of the moving average (i.e. how often a new observation is taken)\n    /// @param    observationFrequency_ - Observation frequency in seconds, must be a divisor of the moving average duration\n    /// @dev      Changing the observation frequency clears existing observation data since it will not be taken at the right time intervals.\n    ///           Ensure that you have saved the existing data and/or can re-populate before calling this function.\n    function changeObservationFrequency(uint48 observationFrequency_) external permissioned {\n        // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)\n            revert Price_InvalidParams();\n\n        // Calculate the new number of observations\n        uint256 newObservations = uint256(movingAverageDuration / observationFrequency_);\n\n        // Since the old observations will not be taken at the right intervals,\n        // the observations array will need to be reinitialized.\n        // Although, there are a handful of situations that could be handled\n        // (e.g. clean multiples of the old frequency),\n        // it is easier to do so off-chain and reinitialize the array.\n\n        // Store blank observations array of new size\n        observations = new uint256[](newObservations);\n\n        // Set initialized to false and update state variables\n        initialized = false;\n        lastObservationTime = 0;\n        _movingAverage = 0;\n        nextObsIndex = 0;\n        observationFrequency = observationFrequency_;\n        numObservations = uint32(newObservations);\n\n        emit ObservationFrequencyChanged(observationFrequency_);\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\nimport {ModuleTestFixtureGenerator} from \"test/lib/ModuleTestFixtureGenerator.sol\";\n\nimport {MockERC20, ERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\nimport {MockPriceFeed} from \"test/mocks/MockPriceFeed.sol\";\n\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport \"src/Kernel.sol\";\n\ncontract PriceTest is Test {\n    using FullMath for uint256;\n    using ModuleTestFixtureGenerator for OlympusPrice;\n\n    MockPriceFeed internal ohmEthPriceFeed;\n    MockPriceFeed internal reserveEthPriceFeed;\n    MockERC20 internal ohm;\n    MockERC20 internal reserve;\n\n    Kernel internal kernel;\n    OlympusPrice internal price;\n\n    address internal writer;\n\n    int256 internal constant CHANGE_DECIMALS = 1e4;\n\n    function setUp() public {\n        vm.warp(51 * 365 * 24 * 60 * 60); // Set timestamp at roughly Jan 1, 2021 (51 years since Unix epoch)\n\n        {\n            /// Deploy protocol mocks external to guidance\n            ohm = new MockERC20(\"Olympus\", \"OHM\", 9);\n            reserve = new MockERC20(\"Reserve\", \"RSV\", 18);\n\n            ohmEthPriceFeed = new MockPriceFeed();\n            ohmEthPriceFeed.setDecimals(18);\n\n            reserveEthPriceFeed = new MockPriceFeed();\n            reserveEthPriceFeed.setDecimals(18);\n        }\n\n        {\n            /// Deploy kernel\n            kernel = new Kernel(); // this contract will be the executor\n\n            /// Deploy price module\n            price = new OlympusPrice(\n                kernel,\n                ohmEthPriceFeed, // AggregatorInterface ohmEthPriceFeed_,\n                reserveEthPriceFeed, // AggregatorInterface reserveEthPriceFeed_,\n                uint48(8 hours), // uint32 observationFrequency_,\n                uint48(7 days) // uint32 movingAverageDuration_,\n            );\n\n            /// Deploy mock module writer\n            writer = price.generateGodmodeFixture(type(OlympusPrice).name);\n        }\n\n        {\n            /// Initialize system and kernel\n            kernel.executeAction(Actions.InstallModule, address(price));\n            kernel.executeAction(Actions.ActivatePolicy, address(writer));\n        }\n\n        {\n            /// Initialize timestamps on mock price feeds\n            ohmEthPriceFeed.setTimestamp(block.timestamp);\n            reserveEthPriceFeed.setTimestamp(block.timestamp);\n        }\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n    function initializePrice(uint8 nonce) internal {\n        /// Assume that the reserveEth price feed is fixed at 0.0005 ETH = 1 Reserve\n        reserveEthPriceFeed.setLatestAnswer(int256(5e14));\n        uint256 reserveEthPrice = uint256(reserveEthPriceFeed.latestAnswer());\n\n        /// Set ohmEth price to 0.01 ETH = 1 OHM initially\n        int256 ohmEthPrice = int256(1e16);\n\n        /// Set scaling value for calculations\n        uint256 scale = 10 **\n            (price.decimals() + reserveEthPriceFeed.decimals() - ohmEthPriceFeed.decimals());\n\n        /// Calculate the number of observations and initialize the observation array\n        uint48 observationFrequency = price.observationFrequency();\n        uint48 movingAverageDuration = price.movingAverageDuration();\n        uint256 numObservations = movingAverageDuration / observationFrequency;\n        uint256[] memory observations = new uint256[](numObservations);\n\n        /// Perform a random walk to initialize the observations\n        int256 change; // percentage with two decimals\n        for (uint256 i; i < numObservations; ++i) {\n            /// Calculate a random percentage change from -10% to + 10% using the nonce and observation number\n            change = int256(uint256(keccak256(abi.encodePacked(nonce, i)))) % int256(1000);\n\n            /// Calculate the new ohmEth price\n            ohmEthPrice = (ohmEthPrice * (CHANGE_DECIMALS + change)) / CHANGE_DECIMALS;\n\n            /// Update price feed\n            ohmEthPriceFeed.setLatestAnswer(ohmEthPrice);\n\n            /// Get the current price from the price module and store in the observations array\n            observations[i] = uint256(ohmEthPrice).mulDiv(scale, reserveEthPrice);\n        }\n\n        /// Initialize the price module with the observations\n        vm.prank(writer);\n        price.initialize(observations, uint48(block.timestamp));\n    }\n\n    function makeRandomObservations(uint8 nonce, uint256 observations)\n        internal\n        returns (uint48 timeIncrease)\n    {\n        /// Perform a random walk and update the moving average with the supplied number of observations\n        int256 change; // percentage with two decimals\n        int256 ohmEthPrice = ohmEthPriceFeed.latestAnswer();\n        uint48 observationFrequency = price.observationFrequency();\n        for (uint256 i; i < observations; ++i) {\n            /// Calculate a random percentage change from -10% to + 10% using the nonce and observation number\n            change = int256(uint256(keccak256(abi.encodePacked(nonce, i)))) % int256(1000);\n\n            /// Calculate the new ohmEth price\n            ohmEthPrice = (ohmEthPrice * (CHANGE_DECIMALS + change)) / CHANGE_DECIMALS;\n\n            /// Update price feed\n            ohmEthPriceFeed.setLatestAnswer(ohmEthPrice);\n            ohmEthPriceFeed.setTimestamp(block.timestamp);\n            reserveEthPriceFeed.setTimestamp(block.timestamp);\n\n            /// Call update moving average on the price module\n            vm.prank(writer);\n            price.updateMovingAverage();\n\n            /// Shift time forward by the observation frequency\n            timeIncrease += observationFrequency;\n            vm.warp(block.timestamp + observationFrequency);\n        }\n    }\n\n    /* ========== UPDATE TESTS ========== */\n\n    /// DONE\n    /// [X] update moving average cannot be called before price initialization\n    /// [X] update moving average\n    /// [X] update moving average several times and expand observations\n\n    function testCorrectness_cannotUpdateMovingAverageBeforeInitialization() public {\n        bytes memory err = abi.encodeWithSignature(\"Price_NotInitialized()\");\n\n        vm.expectRevert(err);\n        vm.prank(writer);\n        price.updateMovingAverage();\n    }\n\n    function testCorrectness_onlyPermittedPoliciesCanCallUpdateMovingAverage(uint8 nonce) public {\n        bytes memory err = abi.encodeWithSelector(\n            Module_PolicyNotPermitted.selector,\n            address(this)\n        );\n\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Call updateMovingAverage with a non-approved address\n        vm.expectRevert(err);\n        price.updateMovingAverage();\n    }\n\n    function testCorrectness_updateMovingAverage(uint8 nonce) public {\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Get the earliest observation on the price module\n        uint256 earliestPrice = price.observations(0);\n        uint256 numObservations = uint256(price.numObservations());\n\n        /// Get the current price from the price module\n        uint256 currentPrice = price.getCurrentPrice();\n\n        /// Get the current moving average from the price module\n        uint256 movingAverage = price.getMovingAverage();\n\n        /// Calculate the expected moving average\n        uint256 expMovingAverage;\n        if (currentPrice > earliestPrice) {\n            expMovingAverage = movingAverage + ((currentPrice - earliestPrice) / numObservations);\n        } else {\n            expMovingAverage = movingAverage - ((earliestPrice - currentPrice) / numObservations);\n        }\n\n        /// Update the moving average on the price module\n        vm.prank(writer);\n        price.updateMovingAverage();\n\n        /// Check that the moving average was updated correctly\n        console2.log(expMovingAverage);\n        console2.log(price.getMovingAverage());\n        assertEq(expMovingAverage, price.getMovingAverage());\n    }\n\n    function testCorrectness_updateMovingAverageMultipleTimes(uint8 nonce) public {\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Add several random observations\n        makeRandomObservations(nonce, uint256(15));\n\n        /// Expect the nextObsIndex to be 15 places away from the beginning\n        /// Confirm by ensuring the last observation is at that index minus 1 and is the current price\n        assertEq(price.nextObsIndex(), uint32(15));\n        assertEq(price.observations(14), price.getCurrentPrice());\n\n        /// Manually calculate the expected moving average\n        uint256 expMovingAverage;\n        uint256 numObs = uint256(price.numObservations());\n        for (uint256 i; i < numObs; ++i) {\n            expMovingAverage += price.observations(i);\n        }\n        expMovingAverage /= numObs;\n\n        /// Check that the moving average was updated correctly (use a range to account for rounding between two methods)\n        assertGt(expMovingAverage, price.getMovingAverage().mulDiv(999, 1000));\n        assertLt(expMovingAverage, price.getMovingAverage().mulDiv(1001, 1000));\n    }\n\n    /* ========== VIEW TESTS ========== */\n\n    /// DONE\n    /// [X] KEYCODE\n    /// [X] ROLES\n    /// [X] getCurrentPrice\n    /// [X] getLastPrice\n    /// [X] getMovingAverage\n    /// [X] cannot get prices before initialization\n\n    function testCorrectness_KEYCODE() public {\n        assertEq(\"PRICE\", Keycode.unwrap(price.KEYCODE()));\n    }\n\n    function testCorrectness_getCurrentPrice(uint8 nonce) public {\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Get the current price from the price module\n        uint256 currentPrice = price.getCurrentPrice();\n\n        /// Get the current price from the price module\n        uint256 ohmEthPrice = uint256(ohmEthPriceFeed.latestAnswer());\n        uint256 reserveEthPrice = uint256(reserveEthPriceFeed.latestAnswer());\n\n        /// Check that the current price is correct\n        assertEq(\n            currentPrice,\n            ohmEthPrice.mulDiv(\n                10**(reserveEthPriceFeed.decimals() + price.decimals()),\n                reserveEthPrice * 10**ohmEthPriceFeed.decimals()\n            )\n        );\n\n        /// Set the timestamp on each feed to before the acceptable window and expect the call to revert\n        ohmEthPriceFeed.setTimestamp(\n            block.timestamp - 3 * uint256(price.observationFrequency()) - 1\n        );\n\n        bytes memory err = abi.encodeWithSignature(\n            \"Price_BadFeed(address)\",\n            address(ohmEthPriceFeed)\n        );\n        vm.expectRevert(err);\n        price.getCurrentPrice();\n\n        ohmEthPriceFeed.setTimestamp(block.timestamp);\n        reserveEthPriceFeed.setTimestamp(\n            block.timestamp - 3 * uint256(price.observationFrequency()) - 1\n        );\n\n        err = abi.encodeWithSignature(\"Price_BadFeed(address)\", address(reserveEthPriceFeed));\n        vm.expectRevert(err);\n        price.getCurrentPrice();\n    }\n\n    function testCorrectness_getLastPrice(uint8 nonce) public {\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Get the last price from the price module\n        uint256 lastPrice = price.getLastPrice();\n\n        /// Check that it returns the last observation in the observations array\n        uint32 numObservations = price.numObservations();\n        uint32 nextObsIndex = price.nextObsIndex();\n        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;\n        assertEq(lastPrice, price.observations(lastIndex));\n    }\n\n    function testCorrectness_getMovingAverage(uint8 nonce) public {\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Get the moving average from the price module\n        uint256 movingAverage = price.getMovingAverage();\n\n        /// Calculate the expected moving average\n        uint256 expMovingAverage;\n        for (uint256 i; i < price.numObservations(); ++i) {\n            expMovingAverage += price.observations(i);\n        }\n        expMovingAverage /= price.numObservations();\n\n        /// Check that the moving average is correct (use a range since the simpler method missing a little on rounding)\n        assertGt(expMovingAverage, movingAverage.mulDiv(999, 1000));\n        assertLt(expMovingAverage, movingAverage.mulDiv(1001, 1000));\n    }\n\n    function testCorrectness_viewsRevertBeforeInitialization() public {\n        /// Check that the views revert before initialization\n        bytes memory err = abi.encodeWithSignature(\"Price_NotInitialized()\");\n        vm.expectRevert(err);\n        price.getCurrentPrice();\n\n        vm.expectRevert(err);\n        price.getLastPrice();\n\n        vm.expectRevert(err);\n        price.getMovingAverage();\n    }\n\n    /* ========== ADMIN TESTS ========== */\n\n    /// DONE\n    /// [X] initialize the moving average with a set of observations and last observation time\n    /// [X] no observations exist before initialization\n    /// [X] cannot initialize with invalid params\n    /// [X] change moving average duration (shorter than current)\n    /// [X] change moving average duration (longer than current)\n    /// [X] cannot change moving average duration with invalid params\n    /// [X] change observation frequency\n    /// [X] cannot change observation frequency with invalid params\n\n    function testCorrectness_initialize(uint8 nonce) public {\n        /// Check that the module is not initialized\n        assertTrue(!price.initialized());\n\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Check the the module is initialized\n        assertTrue(price.initialized());\n\n        /// Check that the observations array is filled with the correct number of observations\n        /// Do so by ensuring the last observation is at the right index and is the current price\n        uint256 numObservations = uint256(price.numObservations());\n        assertEq(price.observations(numObservations - 1), price.getCurrentPrice());\n\n        /// Check that the last observation time is set to the current time\n        assertEq(price.lastObservationTime(), block.timestamp);\n    }\n\n    /// For some reason vm.expectRevert would not work here\n    /// TODO: convert to vm.expectRevert\n    function testFail_cannotReinitialize(uint8 nonce) public {\n        /// Check that the module is not initialized\n        assertTrue(!price.initialized());\n\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Check the the module is initialized\n        assertTrue(price.initialized());\n\n        initializePrice(nonce);\n    }\n\n    function testCorrectness_noObservationsBeforeInitialized() public {\n        /// Check that the oberservations array is empty (all values initialized to 0)\n        uint256 numObservations = uint256(price.numObservations());\n        uint256 zero = uint256(0);\n        for (uint256 i; i < numObservations; ++i) {\n            assertEq(price.observations(i), zero);\n        }\n    }\n\n    function testCorrectness_cannotInitializeWithInvalidParams() public {\n        /// Check that the module is not initialized\n        assertTrue(!price.initialized());\n\n        /// Try to initialize price module with invalid params\n        bytes memory err = abi.encodeWithSignature(\"Price_InvalidParams()\");\n\n        /// Case 1: array has fewer observations than numObservations\n        uint256[] memory observations = new uint256[](10);\n        vm.startPrank(writer);\n        vm.expectRevert(err);\n        price.initialize(observations, uint48(block.timestamp));\n\n        /// Case 2: array has more observations than numObservations\n        observations = new uint256[](30);\n        vm.expectRevert(err);\n        price.initialize(observations, uint48(block.timestamp));\n\n        /// Case 3: last observation time is in the future\n        observations = new uint256[](21);\n        vm.expectRevert(err);\n        price.initialize(observations, uint48(block.timestamp + 1));\n        vm.stopPrank();\n    }\n\n    function testCorrectness_changeMovingAverageDuration(uint8 nonce) public {\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Change from a seven day window to a ten day window and same frequency window\n        vm.prank(writer);\n        price.changeMovingAverageDuration(uint48(10 days));\n\n        /// Check the the module is not still initialized\n        assertTrue(!price.initialized());\n        assertEq(price.lastObservationTime(), uint48(0));\n\n        /// Re-initialize price module\n        initializePrice(nonce);\n\n        /// Check that the window variables and moving average are updated correctly\n        assertEq(price.numObservations(), uint48(30));\n        assertEq(price.movingAverageDuration(), uint48(10 days));\n    }\n\n    function testCorrectness_cannotChangeMovingAverageDurationWithInvalidParams() public {\n        /// Try to change moving average duration with invalid params\n        bytes memory err = abi.encodeWithSignature(\"Price_InvalidParams()\");\n\n        vm.startPrank(writer);\n        /// Case 1: moving average duration is set to zero\n        vm.expectRevert(err);\n        price.changeMovingAverageDuration(uint48(0));\n\n        /// Case 2: moving average duration not a multiple of observation frequency\n        vm.expectRevert(err);\n        price.changeMovingAverageDuration(uint48(20 hours));\n        vm.stopPrank();\n    }\n\n    function testCorrectness_changeObservationFrequency(uint8 nonce) public {\n        /// Initialize price module\n        initializePrice(nonce);\n\n        /// Change observation frequency to a different value (smaller than current)\n        vm.prank(writer);\n        price.changeObservationFrequency(uint48(4 hours));\n\n        /// Check the the module is not still initialized\n        assertTrue(!price.initialized());\n\n        /// Re-initialize price module\n        initializePrice(nonce);\n\n        /// Check that the window variables and moving average are updated correctly\n        assertEq(price.numObservations(), uint48(42));\n        assertEq(price.observationFrequency(), uint48(4 hours));\n\n        /// Change observation frequency to a different value (larger than current)\n        vm.prank(writer);\n        price.changeObservationFrequency(uint48(12 hours));\n\n        /// Check the the module is not still initialized\n        assertTrue(!price.initialized());\n\n        /// Re-initialize price module\n        initializePrice(nonce);\n\n        /// Check that the window variables and moving average are updated correctly\n        assertEq(price.numObservations(), uint48(14));\n        assertEq(price.observationFrequency(), uint48(12 hours));\n    }\n\n    function testCorrectness_cannotChangeObservationFrequencyWithInvalidParams() public {\n        /// Try to change moving average duration with invalid params\n        bytes memory err = abi.encodeWithSignature(\"Price_InvalidParams()\");\n\n        vm.startPrank(writer);\n        /// Case 1: observation frequency is set to zero\n        vm.expectRevert(err);\n        price.changeObservationFrequency(uint48(0));\n\n        /// Case 2: moving average duration not a multiple of observation frequency\n        vm.expectRevert(err);\n        price.changeObservationFrequency(uint48(23 hours));\n        vm.stopPrank();\n    }\n\n    function testCorrectness_onlyPermittedPoliciesCanCallAdminFunctions() public {\n        /// Try to call functions as a non-permitted policy with correct params and expect reverts\n        bytes memory err = abi.encodeWithSelector(\n            Module_PolicyNotPermitted.selector,\n            address(this)\n        );\n\n        /// initialize\n        uint256[] memory obs = new uint256[](21);\n        uint48 lastObTime = uint48(block.timestamp - 1);\n        vm.expectRevert(err);\n        price.initialize(obs, lastObTime);\n\n        /// changeMovingAverageDuration\n        vm.expectRevert(err);\n        price.changeMovingAverageDuration(uint48(5 days));\n\n        /// changeObservationFrequency\n        vm.expectRevert(err);\n        price.changeObservationFrequency(uint48(4 hours));\n    }\n}\n\n\n",
        "CodeNames": [
            "PRICE.sol",
            "PRICE.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PRICE.sol",
                "Type": "Medium Severity",
                "Description": "Using Chainlink's latestRoundData API without checking for stale prices can lead to loss of funds to end-users.",
                "Repair": "Add the missing checks for stale data"
            },
            {
                "Location": "PRICE.sol",
                "Type": "inconsistency in staleness checks",
                "Description": "The freshness requirements for OHM and reserve token oracles are inconsistent, which may cause the getCurrentPrice() function to revert.",
                "Repair": "Make the freshness requirements consistent for OHM and reserve token oracles"
            },
            {
                "Location": "PRICE.sol lines 1134-144",
                "Type": "Observation-weighted-average-price used instead of time-weighted one",
                "Description": "The algorithm does not take into account the time between observations, leading to the TWAP price being incorrect.",
                "Repair": "Call an internal version of beat() that doesn't revert in functions that swap user assets. Track the timestamps of when each beat() is called, and include the amount of time that has passed since the last beat, in the TWAP calculation"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TRSRY: front-runnable setApprovalFor",
                "Type": "front-running vulnerability",
                "Description": "An attacker may be able to withdraw more than intended by front-running the setApprovalFor function.",
                "Repair": "Change the logic to increase/decrease allowances"
            },
            {
                "Location": "RBS may redeploy funds automatically if price stays above or below wall for longer than _config.regenWait",
                "Type": "funds redeployment vulnerability",
                "Description": "The system may redeploy funds even if the price never comes back inside the wall price, leading to a loss of treasury funds.",
                "Repair": "Add a check to verify that the price is within the wall price before regenerating or reset the count and observations array to clear out positive values"
            },
            {
                "Location": "OlympusGovernance#executeProposal",
                "Type": "Reentrancy attack",
                "Description": "Given that the activeProposal change is done before the for loop, if this function is call through one kernel.executeAction(instruction,target) we can call the same instructions (in the same order) again and again, which may or may not affect funds (depending on the instructions).",
                "Repair": "Use nonReentrant modifier or move the line activeProposal = ActivatedProposal(0, 0); before the for loop."
            },
            {
                "Location": "TRSRY: reenter from  OlympusTreasury::repayLoan  to  Operator::swap",
                "Type": "Reentrancy attack",
                "Description": "One can repay loan to the treasury with the value from the Operator::swap. If the attacker can take debt of the reserve currency for the attack contract Reenterer, the contract can call OlympusTreasury::repayLoan and in the middle of repay call Operator::swap function.",
                "Repair": "Unknown"
            },
            {
                "Location": "Moving average precision is lost",
                "Type": "Loss of precision",
                "Description": "The precision is lost in moving average calculations as the difference is calculated separately and added each time, while it typically can be small enough to lose precision in the division involved.",
                "Repair": "Store the cumulative sum and return sum / numObs on request"
            },
            {
                "Location": "Protocol's Walls / cushion bonds remain active even if heart is not beating",
                "Type": "Lack of synchronization check",
                "Description": "The Walls of the RBS mechanism offer zero slippage swaps at the high and low of the moving average spread. The capacity to be swapped at these prices is usually very large, so it must make sure to only be enabled when the prices are guaranteed to be synced. However, there is no such check.",
                "Repair": "Add a check for beat out of sync"
            },
            {
                "Location": "activateProposal() need time delay",
                "Type": "Lack of time delay",
                "Description": "There is no time lock or delay when activating a proposal, the previous one could be replaced immediately.",
                "Repair": "Add time delay when activating a proposal"
            },
            {
                "Location": "Griefing/DOS of withdrawals by EOAs from treasury (TRSRY) possible",
                "Type": "Denial of Service",
                "Description": "Any withdrawals from the treasury by an approved EOA can be denied by a malicious actor that watches the mempool.",
                "Repair": "Add a mapping(address = bool) of all addresses that have been active policies some time in the past to the kernel"
            },
            {
                "Location": "M-07",
                "Type": "Inconsistent State",
                "Description": "Endorsed votes by a user do not decrease after the user's votes are revoked.",
                "Repair": "Remove the endorsed votes for the user from the proposal's endorsed votes when the user's votes are revoked"
            },
            {
                "Location": "M-10",
                "Type": "Inconsistent State",
                "Description": "Voted votes cannot change after the user is issued new votes or the user's old votes are revoked during voting.",
                "Repair": "Add or remove the corresponding votes to or from the proposal's voted votes for the user when issueVotesTo or revokeVotesFrom is called during voting, or disable issueVotesTo and revokeVotesFrom when an active proposal exists"
            },
            {
                "Location": "M-21",
                "Type": "Missing Feature",
                "Description": "Active proposal does not expire.",
                "Repair": "Add expiration for the active proposal, for example, 2 weeks, and allow users to reject the proposal and reclaim VOTES tokens after the expiration time"
            },
            {
                "Location": "M-20",
                "Type": "smart contract vulnerability",
                "Description": "The beat cannot be called anymore and price information will not be updated if the wallspread is set to 10000 (100%) and lower wall is active.",
                "Repair": "Forbid wallSpread to be 100%"
            },
            {
                "Location": "M-27",
                "Type": "smart contract vulnerability",
                "Description": "The DeactivatePolicy action tries to call setActiveStatus on the policy. However, this has a onlyKernel modifier and the call will therefore fail when it is done after the value of kernel was changed.",
                "Repair": "Perform the same check for MigrateKernel"
            },
            {
                "Location": "M-01",
                "Type": "smart contract vulnerability",
                "Description": "Operator::setReserveFactor sets new reserveFactor value. This parameter is used in fullCapacity function to calculate how much capacity is available by high/low side. Changing this value means that the capacity of sides has changed and the sides should be regenerated to include this changes.",
                "Repair": "Conditionally regenerate each side if they are active"
            },
            {
                "Location": "M-17",
                "Type": "smart contract vulnerability",
                "Description": "Because VOTES can be minted by voter_admin, and there is no cap on totalSupply, the voter_admin has the privileged ability to mint as many VOTES as they want in order to get any proposal to pass or veto it.",
                "Repair": "Add a total supply cap to VOTES"
            },
            {
                "Location": "M-30",
                "Type": "smart contract vulnerability",
                "Description": "beat() function is allowed to be called by anyone once in frequency() period. However if beat() was last time called more then frequency() time ago then user can execute beat() function (block.timestamp lastBeat)/frequency() times in a row in same block and get rewards.",
                "Repair": "Change this line to lastBeat = block.timestamp (block.timestamp lastBeat) % frequency();"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n/// @notice Policy to mint and burn votes to arbitrary addresses\n/// @dev A policy to distribute votes for OlympusGovernance\ncontract VoterRegistration is Policy {\n    OlympusVotes public VOTES;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"VOTES\");\n\n        VOTES = OlympusVotes(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](2);\n        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector);\n        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Issue votes to a wallet\n    /// @param  wallet_ - The address receiving the votes.\n    /// @param  amount_ - The amount of votes to mint to the wallet.\n    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Issue the votes in the VOTES module\n        VOTES.mintTo(wallet_, amount_);\n    }\n\n    /// @notice Burn votes from a wallet\n    /// @param  wallet_ - The address losing the votes.\n    /// @param  amount_ - The amount of votes to burn from the wallet.\n    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Revoke the votes in the VOTES module\n        VOTES.burnFrom(wallet_, amount_);\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {OlympusVotes} from \"modules/VOTES.sol\";\n\nimport {VoterRegistration} from \"policies/VoterRegistration.sol\";\n\ncontract VoterRegistrationTest is Test {\n    UserFactory public userCreator;\n    address internal randomWallet;\n    address internal govMultisig;\n\n    Kernel internal kernel;\n\n    OlympusVotes internal votes;\n    VoterRegistration internal voterRegistration;\n\n    function setUp() public {\n        userCreator = new UserFactory();\n\n        /// Create Voters\n        address[] memory users = userCreator.create(2);\n        randomWallet = users[0];\n        govMultisig = users[1];\n\n        /// Deploy kernel\n        kernel = new Kernel(); // this contract will be the executor\n\n        /// Deploy modules\n        votes = new OlympusVotes(kernel);\n\n        /// Deploy policies\n        voterRegistration = new VoterRegistration(kernel);\n\n        /// Install modules\n        kernel.executeAction(Actions.InstallModule, address(votes));\n\n        /// Approve policies`\n        kernel.executeAction(Actions.ActivatePolicy, address(voterRegistration));\n\n        /// Configure access control\n        kernel.grantRole(toRole(\"voter_admin\"), govMultisig);\n    }\n\n    ////////////////////////////////\n    //   ISSUING/REVOKING VOTES   //\n    ////////////////////////////////\n\n    function testRevert_WhenCalledByRandomWallet() public {\n        bytes memory err = abi.encodeWithSelector(Policy_OnlyRole.selector, toRole(\"voter_admin\"));\n        vm.expectRevert(err);\n        vm.prank(randomWallet);\n        voterRegistration.issueVotesTo(randomWallet, 1000);\n    }\n\n    function testCorrectness_WhenCalledByProperAuthority() public {\n        vm.prank(govMultisig);\n        voterRegistration.issueVotesTo(randomWallet, 110);\n        assertEq(votes.balanceOf(randomWallet), 110);\n\n        vm.prank(govMultisig);\n        voterRegistration.revokeVotesFrom(randomWallet, 110);\n        assertEq(votes.balanceOf(randomWallet), 0);\n    }\n}\n\n\n",
        "CodeNames": [
            "VoterRegistration.sol",
            "VoterRegistration.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VoterRegistration contract",
                "Type": "Preventing vote revocation",
                "Description": "There is a way for users to prevent their votes from being revoked by voter_admin.",
                "Repair": "Consider allowing to call the reclaimVotes function to reclaim any user's vote, thus avoiding the user storing his VOTES tokens in userVotesForProposal"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\nimport {ModuleTestFixtureGenerator} from \"test/lib/ModuleTestFixtureGenerator.sol\";\n\nimport {MockERC20, ERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\n\nimport {FullMath} from \"libraries/FullMath.sol\";\n\nimport \"src/Kernel.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\n\ncontract RangeTest is Test {\n    using FullMath for uint256;\n    using ModuleTestFixtureGenerator for OlympusRange;\n\n    UserFactory public userCreator;\n    address internal alice;\n    address internal bob;\n    address internal guardian;\n    address internal policy;\n    address internal heart;\n\n    MockERC20 internal ohm;\n    MockERC20 internal reserve;\n\n    Kernel internal kernel;\n    OlympusRange internal range;\n\n    address internal writer;\n\n    function setUp() public {\n        vm.warp(51 * 365 * 24 * 60 * 60); // Set timestamp at roughly Jan 1, 2021 (51 years since Unix epoch)\n        userCreator = new UserFactory();\n        {\n            address[] memory users = userCreator.create(5);\n            alice = users[0];\n            bob = users[1];\n            guardian = users[2];\n            policy = users[3];\n            heart = users[4];\n        }\n\n        {\n            /// Deploy protocol mocks external to guidance\n            ohm = new MockERC20(\"Olympus\", \"OHM\", 9);\n            reserve = new MockERC20(\"Reserve\", \"RSV\", 18);\n        }\n\n        {\n            /// Deploy kernel\n            kernel = new Kernel(); // this contract will be the executor\n\n            /// Deploy module\n            range = new OlympusRange(\n                kernel,\n                [ERC20(ohm), ERC20(reserve)],\n                [uint256(100), uint256(1000), uint256(2000)]\n            );\n\n            // Deploy mock module writer\n            writer = range.generateGodmodeFixture(type(OlympusRange).name);\n        }\n\n        {\n            /// Initialize system and kernel\n\n            /// Install modules\n            kernel.executeAction(Actions.InstallModule, address(range));\n\n            /// Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(writer));\n        }\n\n        {\n            /// Initialize variables on module\n            vm.startPrank(writer);\n            range.updatePrices(100 * 1e18);\n            range.regenerate(true, 10_000_000 * 1e18);\n            range.regenerate(false, 10_000_000 * 1e18);\n            vm.stopPrank();\n        }\n    }\n\n    /* ========== POLICY FUNCTION TESTS ========== */\n\n    /// DONE\n    /// [X] updateCapacity\n    ///     [X] updating capacity above the threshold\n    ///     [X] updating capacity below the threshold\n    /// [X] updatePrices\n    /// [X] regenerate\n    /// [X] updateMarket\n    ///     [X] updating with non-max market ID and positive capacity creates a cushion\n    ///     [X] updating with max-market ID takes down a cushion and sets last market capacity to zero\n    /// [X] setSpreads\n    /// [X] setThresholdFactor\n    /// [X] cannot set parameters with invalid params\n    /// [X] only permitted policies can call these functions\n\n    event WallUp(bool high, uint256 timestamp, uint256 capacity);\n    event WallDown(bool high, uint256 timestamp, uint256 capacity);\n\n    function testCorrectness_updateCapacity() public {\n        /// Confirm that the capacities are initialiized\n        assertEq(range.capacity(true), 10_000_000 * 1e18);\n        assertEq(range.capacity(false), 10_000_000 * 1e18);\n\n        /// Update the capacities without breaking the thresholds\n        vm.startPrank(writer);\n        range.updateCapacity(true, 9_000_000 * 1e18);\n        range.updateCapacity(false, 8_000_000 * 1e18);\n        vm.stopPrank();\n\n        /// Check that the capacities are updated\n        assertEq(range.capacity(true), 9_000_000 * 1e18);\n        assertEq(range.capacity(false), 8_000_000 * 1e18);\n\n        /// Confirm the range sides are active\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n\n        /// Update the capacities to below the threshold, expect events to emit, and the wall to be inactive\n        vm.expectEmit(false, false, false, true);\n        emit WallDown(true, block.timestamp, 10_000 * 1e18);\n        vm.prank(writer);\n        range.updateCapacity(true, 10_000 * 1e18);\n\n        vm.expectEmit(false, false, false, true);\n        emit WallDown(false, block.timestamp, 10_000 * 1e18);\n        vm.prank(writer);\n        range.updateCapacity(false, 10_000 * 1e18);\n\n        /// Check that the sides are inactive and capacity is updated\n        assertTrue(!range.active(true));\n        assertTrue(!range.active(false));\n        assertEq(range.capacity(true), 10_000 * 1e18);\n        assertEq(range.capacity(false), 10_000 * 1e18);\n    }\n\n    function testCorrectness_updatePrices() public {\n        /// Store the starting bands\n        OlympusRange.Range memory startRange = range.range();\n\n        /// Update the prices with a new moving average above the initial one\n        vm.prank(writer);\n        range.updatePrices(110 * 1e18);\n\n        /// Check that the bands have updated\n        assertGt(range.price(false, false), startRange.cushion.low.price);\n        assertGt(range.price(true, false), startRange.wall.low.price);\n        assertGt(range.price(false, true), startRange.cushion.high.price);\n        assertGt(range.price(true, true), startRange.wall.high.price);\n\n        /// Update prices with a new moving average below the initial one\n        vm.prank(writer);\n        range.updatePrices(90 * 1e18);\n\n        /// Check that the bands have updated\n        assertLt(range.price(false, false), startRange.cushion.low.price);\n        assertLt(range.price(true, false), startRange.wall.low.price);\n        assertLt(range.price(false, true), startRange.cushion.high.price);\n        assertLt(range.price(true, true), startRange.wall.high.price);\n    }\n\n    function testCorrectness_regenerate() public {\n        /// Confirm that the capacities and thresholds are set to initial values\n        OlympusRange.Range memory startRange = range.range();\n        assertEq(startRange.low.capacity, 10_000_000 * 1e18);\n        assertEq(startRange.high.capacity, 10_000_000 * 1e18);\n        assertEq(startRange.low.threshold, 100_000 * 1e18);\n        assertEq(startRange.high.threshold, 100_000 * 1e18);\n\n        /// Update capacities on both sides with lower values\n        vm.startPrank(writer);\n        range.updateCapacity(true, 9_000_000 * 1e18);\n        range.updateCapacity(false, 8_000_000 * 1e18);\n        vm.stopPrank();\n\n        /// Regenerate each side of the range and confirm values are set to the regenerated values\n        vm.expectEmit(false, false, false, true);\n        emit WallUp(true, block.timestamp, 20_000_000 * 1e18);\n        vm.prank(writer);\n        range.regenerate(true, 20_000_000 * 1e18);\n\n        vm.expectEmit(false, false, false, true);\n        emit WallUp(false, block.timestamp, 20_000_000 * 1e18);\n        vm.prank(writer);\n        range.regenerate(false, 20_000_000 * 1e18);\n\n        /// Check that the capacities and thresholds are set to the regenerated values\n        OlympusRange.Range memory endRange = range.range();\n        assertEq(endRange.low.capacity, 20_000_000 * 1e18);\n        assertEq(endRange.high.capacity, 20_000_000 * 1e18);\n        assertEq(endRange.low.threshold, 200_000 * 1e18);\n        assertEq(endRange.high.threshold, 200_000 * 1e18);\n    }\n\n    event CushionUp(bool high, uint256 timestamp, uint256 capacity);\n    event CushionDown(bool high, uint256 timestamp);\n\n    function testCorrectness_updateMarket() public {\n        /// Confirm that there is no market set for each side (max value) to start\n        assertEq(range.market(false), type(uint256).max);\n        assertEq(range.market(true), type(uint256).max);\n\n        /// Update the low side of the range with a new market deployed\n        vm.expectEmit(false, false, false, true);\n        emit CushionUp(false, block.timestamp, 2_000_000 * 1e18);\n        vm.prank(writer);\n        range.updateMarket(false, 2, 2_000_000 * 1e18);\n\n        /// Check that the market is updated\n        assertEq(range.market(false), 2);\n\n        /// Take down the market that was deployed\n        vm.expectEmit(false, false, false, true);\n        emit CushionDown(false, block.timestamp);\n        vm.prank(writer);\n        range.updateMarket(false, type(uint256).max, 0);\n\n        /// Check that the market is updated\n        assertEq(range.market(false), type(uint256).max);\n\n        /// Update the high side of the range with a new market deployed\n        vm.expectEmit(false, false, false, true);\n        emit CushionUp(true, block.timestamp, 1_000_000 * 1e18);\n        vm.prank(writer);\n        range.updateMarket(true, 1, 1_000_000 * 1e18);\n\n        /// Check that the market is updated\n        assertEq(range.market(true), 1);\n\n        /// Take down the market that was deployed\n        vm.expectEmit(false, false, false, true);\n        emit CushionDown(true, block.timestamp);\n        vm.prank(writer);\n        range.updateMarket(true, type(uint256).max, 0);\n\n        /// Check that the market is updated\n        assertEq(range.market(true), type(uint256).max);\n    }\n\n    function testCorrectness_cannotUpdateMarketWithInvalidParams() public {\n        /// Try to update market with a max ID and non-zero capacity\n        bytes memory err = abi.encodeWithSignature(\"RANGE_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(writer);\n        range.updateMarket(false, type(uint256).max, 1_000_000 * 1e18);\n\n        vm.expectRevert(err);\n        vm.prank(writer);\n        range.updateMarket(true, type(uint256).max, 1_000_000 * 1e18);\n    }\n\n    function testCorrectness_setSpreads() public {\n        /// Confirm that the spreads are set with the initial values\n        assertEq(range.spread(false), 1000);\n        assertEq(range.spread(true), 2000);\n\n        /// Store initial prices. These should not update immediately when the spreads are updated because they require update prices to be called first.\n        OlympusRange.Range memory startRange = range.range();\n\n        /// Update the spreads with valid parameters from an approved address\n        vm.prank(writer);\n        range.setSpreads(500, 1000);\n\n        /// Expect the spreads to be updated and the prices to be the same\n        assertEq(range.spread(false), 500);\n        assertEq(range.spread(true), 1000);\n        assertEq(range.price(false, false), startRange.cushion.low.price);\n        assertEq(range.price(true, false), startRange.wall.low.price);\n        assertEq(range.price(false, true), startRange.cushion.high.price);\n        assertEq(range.price(true, true), startRange.wall.high.price);\n\n        /// Call updatePrices and check that the new spreads are applied\n        vm.prank(writer);\n        range.updatePrices(100 * 1e18);\n\n        /// Expect the prices to be updated now (range is tighter so they should be inside the new spreads)\n        assertGt(range.price(false, false), startRange.cushion.low.price);\n        assertGt(range.price(true, false), startRange.wall.low.price);\n        assertLt(range.price(false, true), startRange.cushion.high.price);\n        assertLt(range.price(true, true), startRange.wall.high.price);\n    }\n\n    function testCorrectness_setThresholdFactor() public {\n        /// Confirm that the threshold factor is set with the initial value\n        assertEq(range.thresholdFactor(), uint256(100));\n\n        /// Store current threshold for each side\n        OlympusRange.Range memory startRange = range.range();\n\n        /// Update the threshold factor with valid parameters from an approved address\n        vm.prank(writer);\n        range.setThresholdFactor(uint256(200));\n\n        /// Expect the threshold factor to be updated and the thresholds to be the same\n        assertEq(range.thresholdFactor(), uint256(200));\n        OlympusRange.Range memory newRange = range.range();\n        assertEq(newRange.low.threshold, startRange.low.threshold);\n        assertEq(newRange.high.threshold, startRange.high.threshold);\n\n        /// Call regenerate on each side with the same capacity as initialized and expect the threshold to be updated\n        vm.startPrank(writer);\n        range.regenerate(false, 10_000_000 * 1e18);\n        range.regenerate(true, 10_000_000 * 1e18);\n        vm.stopPrank();\n\n        /// Expect the thresholds to be updated\n        newRange = range.range();\n        assertGt(newRange.low.threshold, startRange.low.threshold);\n        assertGt(newRange.high.threshold, startRange.high.threshold);\n    }\n\n    function testCorrectness_cannotSetParametersWithInvalidParams() public {\n        bytes memory err = abi.encodeWithSignature(\"RANGE_InvalidParams()\");\n\n        /// Try to call setSpreads with invalid parameters from an approved address\n        /// Case 1: wallSpread > 10000\n        vm.startPrank(writer);\n        vm.expectRevert(err);\n        range.setSpreads(1000, 20000);\n\n        /// Case 2: wallSpread < 100\n        vm.expectRevert(err);\n        range.setSpreads(1000, 50);\n\n        /// Case 3: cushionSpread > 10000\n        vm.expectRevert(err);\n        range.setSpreads(20000, 1000);\n\n        /// Case 4: cushionSpread < 100\n        vm.expectRevert(err);\n        range.setSpreads(50, 1000);\n\n        /// Case 5: cushionSpread > wallSpread (with in bounds values)\n        vm.expectRevert(err);\n        range.setSpreads(2000, 1000);\n\n        /// Try to call setThresholdFactor with invalid parameters from an approved address\n        /// Case 1: thresholdFactor > 10000\n        vm.expectRevert(err);\n        range.setThresholdFactor(uint256(20000));\n\n        /// Case 2: thresholdFactor < 100\n        vm.expectRevert(err);\n        range.setThresholdFactor(uint256(50));\n\n        vm.stopPrank();\n    }\n\n    function testCorrectness_onlyPermittedPoliciesCanCallGatedFunctions() public {\n        /// Try to call functions as a non-permitted policy with correct params and expect reverts\n        bytes memory err = abi.encodeWithSelector(\n            Module_PolicyNotPermitted.selector,\n            address(this)\n        );\n\n        /// updatePrices\n        vm.expectRevert(err);\n        range.updatePrices(110 * 1e18);\n\n        /// updateCapacity\n        vm.expectRevert(err);\n        range.updateCapacity(true, 9_000_000 * 1e18);\n\n        /// updateMarket\n        vm.expectRevert(err);\n        range.updateMarket(false, 2, 2_000_000 * 1e18);\n\n        /// regenerate\n        vm.expectRevert(err);\n        range.regenerate(false, 10_000_000 * 1e18);\n\n        /// setSpreads\n        vm.expectRevert(err);\n        range.setSpreads(500, 1000);\n\n        /// setThresholdFactor\n        vm.expectRevert(err);\n        range.setThresholdFactor(uint256(200));\n    }\n\n    /* ========== VIEW TESTS ========== */\n\n    /// DONE\n    /// [X] range\n    /// [X] capacity\n    /// [X] active\n    /// [X] price\n    /// [X] spread\n    /// [X] market\n\n    function testCorrectness_viewRange() public {\n        /// Get range data\n        OlympusRange.Range memory _range = range.range();\n\n        /// Confirm it matches initialized variables\n        assertTrue(_range.low.active);\n        assertEq(_range.low.lastActive, block.timestamp);\n        assertEq(_range.low.capacity, 10_000_000 * 1e18);\n        assertEq(_range.low.threshold, 100_000 * 1e18);\n        assertEq(_range.low.market, type(uint256).max);\n\n        assertTrue(_range.high.active);\n        assertEq(_range.high.lastActive, block.timestamp);\n        assertEq(_range.high.capacity, 10_000_000 * 1e18);\n        assertEq(_range.high.threshold, 100_000 * 1e18);\n        assertEq(_range.high.market, type(uint256).max);\n\n        assertEq(_range.cushion.low.price, (100 * 1e18 * (1e4 - 1000)) / 1e4);\n        assertEq(_range.cushion.high.price, (100 * 1e18 * (1e4 + 1000)) / 1e4);\n        assertEq(_range.cushion.spread, 1000);\n\n        assertEq(_range.wall.low.price, (100 * 1e18 * (1e4 - 2000)) / 1e4);\n        assertEq(_range.wall.high.price, (100 * 1e18 * (1e4 + 2000)) / 1e4);\n        assertEq(_range.wall.spread, 2000);\n    }\n\n    function testCorrectness_viewCapacity() public {\n        /// Load the sides directly from the range\n        OlympusRange.Range memory _range = range.range();\n\n        /// Check that capacity returns the capacity value in the range\n        assertEq(range.capacity(false), _range.low.capacity);\n        assertEq(range.capacity(true), _range.high.capacity);\n    }\n\n    function testCorrectness_viewActive() public {\n        /// Load the sides directly from the range\n        OlympusRange.Range memory _range = range.range();\n\n        /// Check that wallUp returns the same result as the struct\n        assertTrue(range.active(false) == _range.low.active);\n        assertTrue(range.active(true) == _range.high.active);\n    }\n\n    function testCorrectness_viewPrice() public {\n        /// Load the bands directly from the range\n        OlympusRange.Range memory _range = range.range();\n\n        /// Check that cushion and walls prices match the value returned from price\n        assertEq(range.price(false, false), _range.cushion.low.price);\n        assertEq(range.price(true, false), _range.wall.low.price);\n        assertEq(range.price(false, true), _range.cushion.high.price);\n        assertEq(range.price(true, true), _range.wall.high.price);\n    }\n\n    function testCorrectness_viewSpread() public {\n        /// Load the bands directly from the range\n        OlympusRange.Range memory _range = range.range();\n\n        /// Check that cushion and walls prices match the value returned from price\n        assertEq(range.spread(false), _range.cushion.spread);\n        assertEq(range.spread(true), _range.wall.spread);\n    }\n\n    function testCorrectness_viewMarket() public {\n        /// Load the sides directly from the range\n        OlympusRange.Range memory _range = range.range();\n\n        /// Check that wallUp returns the same result as the struct\n        assertEq(range.market(false), _range.low.market);\n        assertEq(range.market(true), _range.high.market);\n    }\n\n    function testCorrectness_viewLastActive() public {\n        /// Load the sides directly from the range\n        OlympusRange.Range memory _range = range.range();\n\n        /// Check that lastActive returns the same result as the struct\n        assertEq(range.lastActive(false), _range.low.lastActive);\n        assertEq(range.lastActive(true), _range.high.lastActive);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport \"src/Kernel.sol\";\n\nerror RANGE_InvalidParams();\n\n/// @notice Olympus Range data storage module\n/// @dev    The Olympus Range contract stores information about the Olympus Range market operations status.\n///         It provides a standard interface for Range data, including range prices and capacities of each range side.\n///         The data provided by this contract is used by the Olympus Range Operator to perform market operations.\n///         The Olympus Range Data is updated each epoch by the Olympus Range Operator contract.\ncontract OlympusRange is Module {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    event WallUp(bool high_, uint256 timestamp_, uint256 capacity_);\n    event WallDown(bool high_, uint256 timestamp_, uint256 capacity_);\n    event CushionUp(bool high_, uint256 timestamp_, uint256 capacity_);\n    event CushionDown(bool high_, uint256 timestamp_);\n    event PricesChanged(\n        uint256 wallLowPrice_,\n        uint256 cushionLowPrice_,\n        uint256 cushionHighPrice_,\n        uint256 wallHighPrice_\n    );\n    event SpreadsChanged(uint256 cushionSpread_, uint256 wallSpread_);\n    event ThresholdFactorChanged(uint256 thresholdFactor_);\n\n    struct Line {\n        uint256 price; // Price for the specified level\n    }\n\n    struct Band {\n        Line high; // Price of the high side of the band\n        Line low; // Price of the low side of the band\n        uint256 spread; // Spread of the band (increase/decrease from the moving average to set the band prices), percent with 2 decimal places (i.e. 1000 = 10% spread)\n    }\n\n    struct Side {\n        bool active; // Whether or not the side is active (i.e. the Operator is performing market operations on this side, true = active, false = inactive)\n        uint48 lastActive; // Unix timestamp when the side was last active (in seconds)\n        uint256 capacity; // Amount of tokens that can be used to defend the side of the range. Specified in OHM tokens on the high side and Reserve tokens on the low side.\n        uint256 threshold; // Amount of tokens under which the side is taken down. Specified in OHM tokens on the high side and Reserve tokens on the low side.\n        uint256 market; // Market ID of the cushion bond market for the side. If no market is active, the market ID is set to max uint256 value.\n    }\n\n    struct Range {\n        Side low; // Data specific to the low side of the range\n        Side high; // Data specific to the high side of the range\n        Band cushion; // Data relevant to cushions on both sides of the range\n        Band wall; // Data relevant to walls on both sides of the range\n    }\n\n    // Range data singleton. See range().\n    Range internal _range;\n\n    /// @notice Threshold factor for the change, a percent in 2 decimals (i.e. 1000 = 10%). Determines how much of the capacity must be spent before the side is taken down.\n    /// @dev    A threshold is required so that a wall is not \"active\" with a capacity near zero, but unable to be depleted practically (dust).\n    uint256 public thresholdFactor;\n\n    uint256 public constant FACTOR_SCALE = 1e4;\n\n    /// @notice OHM token contract address\n    ERC20 public immutable ohm;\n\n    /// @notice Reserve token contract address\n    ERC20 public immutable reserve;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        ERC20[2] memory tokens_,\n        uint256[3] memory rangeParams_ // [thresholdFactor, cushionSpread, wallSpread]\n    ) Module(kernel_) {\n        _range = Range({\n            low: Side({\n                active: false,\n                lastActive: uint48(block.timestamp),\n                capacity: 0,\n                threshold: 0,\n                market: type(uint256).max\n            }),\n            high: Side({\n                active: false,\n                lastActive: uint48(block.timestamp),\n                capacity: 0,\n                threshold: 0,\n                market: type(uint256).max\n            }),\n            cushion: Band({low: Line({price: 0}), high: Line({price: 0}), spread: rangeParams_[1]}),\n            wall: Band({low: Line({price: 0}), high: Line({price: 0}), spread: rangeParams_[2]})\n        });\n\n        thresholdFactor = rangeParams_[0];\n        ohm = tokens_[0];\n        reserve = tokens_[1];\n\n        emit SpreadsChanged(rangeParams_[1], rangeParams_[2]);\n        emit ThresholdFactorChanged(rangeParams_[0]);\n    }\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"RANGE\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Update the capacity for a side of the range.\n    /// @notice Access restricted to activated policies.\n    /// @param  high_ - Specifies the side of the range to update capacity for (true = high side, false = low side).\n    /// @param  capacity_ - Amount to set the capacity to (OHM tokens for high side, Reserve tokens for low side).\n    function updateCapacity(bool high_, uint256 capacity_) external permissioned {\n        if (high_) {\n            // Update capacity\n            _range.high.capacity = capacity_;\n\n            // If the new capacity is below the threshold, deactivate the wall if they are currently active\n            if (capacity_ < _range.high.threshold && _range.high.active) {\n                // Set wall to inactive\n                _range.high.active = false;\n                _range.high.lastActive = uint48(block.timestamp);\n\n                emit WallDown(true, block.timestamp, capacity_);\n            }\n        } else {\n            // Update capacity\n            _range.low.capacity = capacity_;\n\n            // If the new capacity is below the threshold, deactivate the wall if they are currently active\n            if (capacity_ < _range.low.threshold && _range.low.active) {\n                // Set wall to inactive\n                _range.low.active = false;\n                _range.low.lastActive = uint48(block.timestamp);\n\n                emit WallDown(false, block.timestamp, capacity_);\n            }\n        }\n    }\n\n    /// @notice Update the prices for the low and high sides.\n    /// @notice Access restricted to activated policies.\n    /// @param  movingAverage_ - Current moving average price to set range prices from.\n    function updatePrices(uint256 movingAverage_) external permissioned {\n        // Cache the spreads\n        uint256 wallSpread = _range.wall.spread;\n        uint256 cushionSpread = _range.cushion.spread;\n\n        // Calculate new wall and cushion values from moving average and spread\n        _range.wall.low.price = (movingAverage_ * (FACTOR_SCALE - wallSpread)) / FACTOR_SCALE;\n        _range.wall.high.price = (movingAverage_ * (FACTOR_SCALE + wallSpread)) / FACTOR_SCALE;\n\n        _range.cushion.low.price = (movingAverage_ * (FACTOR_SCALE - cushionSpread)) / FACTOR_SCALE;\n        _range.cushion.high.price =\n            (movingAverage_ * (FACTOR_SCALE + cushionSpread)) /\n            FACTOR_SCALE;\n\n        emit PricesChanged(\n            _range.wall.low.price,\n            _range.cushion.low.price,\n            _range.cushion.high.price,\n            _range.wall.high.price\n        );\n    }\n\n    /// @notice Regenerate a side of the range to a specific capacity.\n    /// @notice Access restricted to activated policies.\n    /// @param  high_ - Specifies the side of the range to regenerate (true = high side, false = low side).\n    /// @param  capacity_ - Amount to set the capacity to (OHM tokens for high side, Reserve tokens for low side).\n    function regenerate(bool high_, uint256 capacity_) external permissioned {\n        uint256 threshold = (capacity_ * thresholdFactor) / FACTOR_SCALE;\n\n        if (high_) {\n            // Re-initialize the high side\n            _range.high = Side({\n                active: true,\n                lastActive: uint48(block.timestamp),\n                capacity: capacity_,\n                threshold: threshold,\n                market: _range.high.market\n            });\n        } else {\n            // Reinitialize the low side\n            _range.low = Side({\n                active: true,\n                lastActive: uint48(block.timestamp),\n                capacity: capacity_,\n                threshold: threshold,\n                market: _range.low.market\n            });\n        }\n\n        emit WallUp(high_, block.timestamp, capacity_);\n    }\n\n    /// @notice Update the market ID (cushion) for a side of the range.\n    /// @notice Access restricted to activated policies.\n    /// @param  high_ - Specifies the side of the range to update market for (true = high side, false = low side).\n    /// @param  market_ - Market ID to set for the side.\n    /// @param  marketCapacity_ - Amount to set the last market capacity to (OHM tokens for high side, Reserve tokens for low side).\n    function updateMarket(\n        bool high_,\n        uint256 market_,\n        uint256 marketCapacity_\n    ) public permissioned {\n        // If market id is max uint256, then marketCapacity must be 0\n        if (market_ == type(uint256).max && marketCapacity_ != 0) revert RANGE_InvalidParams();\n\n        // Store updated state\n        if (high_) {\n            _range.high.market = market_;\n        } else {\n            _range.low.market = market_;\n        }\n\n        if (market_ == type(uint256).max) {\n            emit CushionDown(high_, block.timestamp);\n        } else {\n            emit CushionUp(high_, block.timestamp, marketCapacity_);\n        }\n    }\n\n    /// @notice Set the wall and cushion spreads.\n    /// @notice Access restricted to activated policies.\n    /// @param  cushionSpread_ - Percent spread to set the cushions at above/below the moving average, assumes 2 decimals (i.e. 1000 = 10%).\n    /// @param  wallSpread_ - Percent spread to set the walls at above/below the moving average, assumes 2 decimals (i.e. 1000 = 10%).\n    /// @dev    The new spreads will not go into effect until the next time updatePrices() is called.\n    function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n        // Confirm spreads are within allowed values\n        if (\n            wallSpread_ > 10000 ||\n            wallSpread_ < 100 ||\n            cushionSpread_ > 10000 ||\n            cushionSpread_ < 100 ||\n            cushionSpread_ > wallSpread_\n        ) revert RANGE_InvalidParams();\n\n        // Set spreads\n        _range.wall.spread = wallSpread_;\n        _range.cushion.spread = cushionSpread_;\n\n        emit SpreadsChanged(wallSpread_, cushionSpread_);\n    }\n\n    /// @notice Set the threshold factor for when a wall is considered \"down\".\n    /// @notice Access restricted to activated policies.\n    /// @param  thresholdFactor_ - Percent of capacity that the wall should close below, assumes 2 decimals (i.e. 1000 = 10%).\n    /// @dev    The new threshold factor will not go into effect until the next time regenerate() is called for each side of the wall.\n    function setThresholdFactor(uint256 thresholdFactor_) external permissioned {\n        if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();\n        thresholdFactor = thresholdFactor_;\n\n        emit ThresholdFactorChanged(thresholdFactor_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the full Range data in a struct.\n    function range() external view returns (Range memory) {\n        return _range;\n    }\n\n    /// @notice Get the capacity for a side of the range.\n    /// @param  high_ - Specifies the side of the range to get capacity for (true = high side, false = low side).\n    function capacity(bool high_) external view returns (uint256) {\n        if (high_) {\n            return _range.high.capacity;\n        } else {\n            return _range.low.capacity;\n        }\n    }\n\n    /// @notice Get the status of a side of the range (whether it is active or not).\n    /// @param  high_ - Specifies the side of the range to get status for (true = high side, false = low side).\n    function active(bool high_) external view returns (bool) {\n        if (high_) {\n            return _range.high.active;\n        } else {\n            return _range.low.active;\n        }\n    }\n\n    /// @notice Get the price for the wall or cushion for a side of the range.\n    /// @param  wall_ - Specifies the band to get the price for (true = wall, false = cushion).\n    /// @param  high_ - Specifies the side of the range to get the price for (true = high side, false = low side).\n    function price(bool wall_, bool high_) external view returns (uint256) {\n        if (wall_) {\n            if (high_) {\n                return _range.wall.high.price;\n            } else {\n                return _range.wall.low.price;\n            }\n        } else {\n            if (high_) {\n                return _range.cushion.high.price;\n            } else {\n                return _range.cushion.low.price;\n            }\n        }\n    }\n\n    /// @notice Get the spread for the wall or cushion band.\n    /// @param  wall_ - Specifies the band to get the spread for (true = wall, false = cushion).\n    function spread(bool wall_) external view returns (uint256) {\n        if (wall_) {\n            return _range.wall.spread;\n        } else {\n            return _range.cushion.spread;\n        }\n    }\n\n    /// @notice Get the market ID for a side of the range.\n    /// @param  high_ - Specifies the side of the range to get market for (true = high side, false = low side).\n    function market(bool high_) external view returns (uint256) {\n        if (high_) {\n            return _range.high.market;\n        } else {\n            return _range.low.market;\n        }\n    }\n\n    /// @notice Get the timestamp when the range was last active.\n    /// @param  high_ - Specifies the side of the range to get timestamp for (true = high side, false = low side).\n    function lastActive(bool high_) external view returns (uint256) {\n        if (high_) {\n            return _range.high.lastActive;\n        } else {\n            return _range.low.lastActive;\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\n\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n/// @title  Olympus Range Operator\n/// @notice Olympus Range Operator (Policy) Contract\n/// @dev    The Olympus Range Operator performs market operations to enforce OlympusDAO's OHM price range\n///         guidance policies against a specific reserve asset. The Operator is maintained by a keeper-triggered\n///         function on the Olympus Heart contract, which orchestrates state updates in the correct order to ensure\n///         market operations use up to date information. When the price of OHM against the reserve asset exceeds\n///         the cushion spread, the Operator deploys bond markets to support the price. The Operator also offers\n///         zero slippage swaps at prices dictated by the wall spread from the moving average. These market operations\n///         are performed up to a specific capacity before the market must stabilize to regenerate the capacity.\ncontract Operator is IOperator, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS =========== */\n\n    error Operator_InvalidParams();\n    error Operator_InsufficientCapacity();\n    error Operator_AmountLessThanMinimum(uint256 amountOut, uint256 minAmountOut);\n    error Operator_WallDown();\n    error Operator_AlreadyInitialized();\n    error Operator_NotInitialized();\n    error Operator_Inactive();\n\n    /* ========== EVENTS =========== */\n    event Swap(\n        ERC20 indexed tokenIn_,\n        ERC20 indexed tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOut_\n    );\n    event CushionFactorChanged(uint32 cushionFactor_);\n    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);\n    event ReserveFactorChanged(uint32 reserveFactor_);\n    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// Operator variables, defined in the interface on the external getter functions\n    Status internal _status;\n    Config internal _config;\n\n    /// @notice    Whether the Operator has been initialized\n    bool public initialized;\n\n    /// @notice    Whether the Operator is active\n    bool public active;\n\n    /// Modules\n    OlympusPrice internal PRICE;\n    OlympusRange internal RANGE;\n    OlympusTreasury internal TRSRY;\n    OlympusMinter internal MINTR;\n\n    /// External contracts\n    /// @notice     Auctioneer contract used for cushion bond market deployments\n    IBondAuctioneer public auctioneer;\n    /// @notice     Callback contract used for cushion bond market payouts\n    IBondCallback public callback;\n\n    /// Tokens\n    /// @notice     OHM token contract\n    ERC20 public immutable ohm;\n    uint8 public immutable ohmDecimals;\n    /// @notice     Reserve token contract\n    ERC20 public immutable reserve;\n    uint8 public immutable reserveDecimals;\n\n    /// Constants\n    uint32 public constant FACTOR_SCALE = 1e4;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        Kernel kernel_,\n        IBondAuctioneer auctioneer_,\n        IBondCallback callback_,\n        ERC20[2] memory tokens_, // [ohm, reserve]\n        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]\n    ) Policy(kernel_) {\n        /// Check params are valid\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n\n        if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))\n            revert Operator_InvalidParams();\n\n        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();\n\n        if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])\n            revert Operator_InvalidParams();\n\n        if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();\n\n        if (\n            configParams[5] < 1 hours ||\n            configParams[6] > configParams[7] ||\n            configParams[7] == uint32(0)\n        ) revert Operator_InvalidParams();\n\n        auctioneer = auctioneer_;\n        callback = callback_;\n        ohm = tokens_[0];\n        ohmDecimals = tokens_[0].decimals();\n        reserve = tokens_[1];\n        reserveDecimals = tokens_[1].decimals();\n\n        Regen memory regen = Regen({\n            count: uint32(0),\n            lastRegen: uint48(block.timestamp),\n            nextObservation: uint32(0),\n            observations: new bool[](configParams[7])\n        });\n\n        _config = Config({\n            cushionFactor: configParams[0],\n            cushionDuration: configParams[1],\n            cushionDebtBuffer: configParams[2],\n            cushionDepositInterval: configParams[3],\n            reserveFactor: configParams[4],\n            regenWait: configParams[5],\n            regenThreshold: configParams[6],\n            regenObserve: configParams[7]\n        });\n\n        _status = Status({low: regen, high: regen});\n\n        emit CushionFactorChanged(configParams[0]);\n        emit CushionParamsChanged(configParams[1], configParams[2], configParams[3]);\n        emit ReserveFactorChanged(configParams[4]);\n        emit RegenParamsChanged(configParams[5], configParams[6], configParams[7]);\n    }\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"PRICE\");\n        dependencies[1] = toKeycode(\"RANGE\");\n        dependencies[2] = toKeycode(\"TRSRY\");\n        dependencies[3] = toKeycode(\"MINTR\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n        RANGE = OlympusRange(getModuleAddress(dependencies[1]));\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[2]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\n\n        /// Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](9);\n        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    modifier onlyWhileActive() {\n        if (!active) revert Operator_Inactive();\n        _;\n    }\n\n    /* ========== HEART FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function operate() external override onlyWhileActive onlyRole(\"operator_operate\") {\n        /// Revert if not initialized\n        if (!initialized) revert Operator_NotInitialized();\n\n        /// Update the prices for the range, save new regen observations, and update capacities based on bond market activity\n        _updateRangePrices();\n        _addObservation();\n        _updateCapacity(true, 0);\n        _updateCapacity(false, 0);\n\n        /// Cache config in memory\n        Config memory config_ = _config;\n\n        /// Check if walls can regenerate capacity\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\n            _status.high.count >= config_.regenThreshold\n        ) {\n            _regenerate(true);\n        }\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\n            _status.low.count >= config_.regenThreshold\n        ) {\n            _regenerate(false);\n        }\n\n        /// Cache range data after potential regeneration\n        OlympusRange.Range memory range = RANGE.range();\n\n        /// Get latest price\n        /// See note in addObservation() for more details\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Check if the cushion bond markets are active\n        /// if so, determine if it should stay open or close\n        /// if not, check if a new one should be opened\n        if (range.low.active) {\n            if (auctioneer.isLive(range.low.market)) {\n                /// if active, check if the price is back above the cushion\n                /// or if the price is below the wall\n                /// if so, close the market\n                if (currentPrice > range.cushion.low.price || currentPrice < range.wall.low.price) {\n                    _deactivate(false);\n                }\n            } else {\n                /// if not active, check if the price is below the cushion\n                /// if so, open a new bond market\n                if (currentPrice < range.cushion.low.price && currentPrice > range.wall.low.price) {\n                    _activate(false);\n                }\n            }\n        }\n        if (range.high.active) {\n            if (auctioneer.isLive(range.high.market)) {\n                /// if active, check if the price is back under the cushion\n                /// or if the price is above the wall\n                /// if so, close the market\n                if (\n                    currentPrice < range.cushion.high.price || currentPrice > range.wall.high.price\n                ) {\n                    _deactivate(true);\n                }\n            } else {\n                /// if not active, check if the price is above the cushion\n                /// if so, open a new bond market\n                if (\n                    currentPrice > range.cushion.high.price && currentPrice < range.wall.high.price\n                ) {\n                    _activate(true);\n                }\n            }\n        }\n    }\n\n    /* ========== OPEN MARKET OPERATIONS (WALL) ========== */\n    /// @inheritdoc IOperator\n    function swap(\n        ERC20 tokenIn_,\n        uint256 amountIn_,\n        uint256 minAmountOut_\n    ) external override onlyWhileActive nonReentrant returns (uint256 amountOut) {\n        if (tokenIn_ == ohm) {\n            /// Revert if lower wall is inactive\n            if (!RANGE.active(false)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(false, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(false);\n\n            /// Transfer OHM from sender\n            ohm.safeTransferFrom(msg.sender, address(this), amountIn_);\n\n            /// Burn OHM\n            MINTR.burnOhm(address(this), amountIn_);\n\n            /// Withdraw and transfer reserve to sender\n            TRSRY.withdrawReserves(msg.sender, reserve, amountOut);\n\n            emit Swap(ohm, reserve, amountIn_, amountOut);\n        } else if (tokenIn_ == reserve) {\n            /// Revert if upper wall is inactive\n            if (!RANGE.active(true)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(true, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(true);\n\n            /// Transfer reserves to treasury\n            reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n\n            /// Mint OHM to sender\n            MINTR.mintOhm(msg.sender, amountOut);\n\n            emit Swap(reserve, ohm, amountIn_, amountOut);\n        } else {\n            revert Operator_InvalidParams();\n        }\n    }\n\n    /* ========== BOND MARKET OPERATIONS (CUSHION) ========== */\n    /// @notice             Records a bond purchase and updates capacity correctly\n    /// @notice             Access restricted (BondCallback)\n    /// @param id_          ID of the bond market\n    /// @param amountOut_   Amount of capacity expended\n    function bondPurchase(uint256 id_, uint256 amountOut_)\n        external\n        onlyWhileActive\n        onlyRole(\"operator_reporter\")\n    {\n        if (id_ == RANGE.market(true)) {\n            _updateCapacity(true, amountOut_);\n            _checkCushion(true);\n        }\n        if (id_ == RANGE.market(false)) {\n            _updateCapacity(false, amountOut_);\n            _checkCushion(false);\n        }\n    }\n\n    /// @notice      Activate a cushion by deploying a bond market\n    /// @param high_ Whether the cushion is for the high or low side of the range (true = high, false = low)\n    function _activate(bool high_) internal {\n        OlympusRange.Range memory range = RANGE.range();\n\n        if (high_) {\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecimals = _getPriceDecimals(range.cushion.high.price);\n            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\n\n            /// Calculate oracle scale and bond scale with scale adjustment and format prices for bond market\n            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\n            uint256 bondScale = 10 **\n                uint8(\n                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\n                );\n\n            uint256 initialPrice = range.wall.high.price.mulDiv(bondScale, oracleScale);\n            uint256 minimumPrice = range.cushion.high.price.mulDiv(bondScale, oracleScale);\n\n            /// Cache config struct to avoid multiple SLOADs\n            Config memory config_ = _config;\n\n            /// Calculate market capacity from the cushion factor\n            uint256 marketCapacity = range.high.capacity.mulDiv(\n                config_.cushionFactor,\n                FACTOR_SCALE\n            );\n\n            /// Create new bond market to buy the reserve with OHM\n            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\n                payoutToken: ohm,\n                quoteToken: reserve,\n                callbackAddr: address(callback),\n                capacityInQuote: false,\n                capacity: marketCapacity,\n                formattedInitialPrice: initialPrice,\n                formattedMinimumPrice: minimumPrice,\n                debtBuffer: config_.cushionDebtBuffer,\n                vesting: uint48(0), // Instant swaps\n                conclusion: uint48(block.timestamp + config_.cushionDuration),\n                depositInterval: config_.cushionDepositInterval,\n                scaleAdjustment: scaleAdjustment\n            });\n\n            uint256 market = auctioneer.createMarket(params);\n\n            /// Whitelist the bond market on the callback\n            callback.whitelist(address(auctioneer.getTeller()), market);\n\n            /// Update the market information on the range module\n            RANGE.updateMarket(true, market, marketCapacity);\n        } else {\n            /// Calculate inverse prices from the oracle feed for the low side\n            uint8 oracleDecimals = PRICE.decimals();\n            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;\n            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\n\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecimals = _getPriceDecimals(invCushionPrice);\n            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\n\n            /// Calculate oracle scale and bond scale with scale adjustment and format prices for bond market\n            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\n            uint256 bondScale = 10 **\n                uint8(\n                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\n                );\n\n            uint256 initialPrice = invWallPrice.mulDiv(bondScale, oracleScale);\n            uint256 minimumPrice = invCushionPrice.mulDiv(bondScale, oracleScale);\n\n            /// Cache config struct to avoid multiple SLOADs\n            Config memory config_ = _config;\n\n            /// Calculate market capacity from the cushion factor\n            uint256 marketCapacity = range.low.capacity.mulDiv(config_.cushionFactor, FACTOR_SCALE);\n\n            /// Create new bond market to buy OHM with the reserve\n            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\n                payoutToken: reserve,\n                quoteToken: ohm,\n                callbackAddr: address(callback),\n                capacityInQuote: false,\n                capacity: marketCapacity,\n                formattedInitialPrice: initialPrice,\n                formattedMinimumPrice: minimumPrice,\n                debtBuffer: config_.cushionDebtBuffer,\n                vesting: uint48(0), // Instant swaps\n                conclusion: uint48(block.timestamp + config_.cushionDuration),\n                depositInterval: config_.cushionDepositInterval,\n                scaleAdjustment: scaleAdjustment\n            });\n\n            uint256 market = auctioneer.createMarket(params);\n\n            /// Whitelist the bond market on the callback\n            callback.whitelist(address(auctioneer.getTeller()), market);\n\n            /// Update the market information on the range module\n            RANGE.updateMarket(false, market, marketCapacity);\n        }\n    }\n\n    /// @notice      Deactivate a cushion by closing a bond market (if it is active)\n    /// @param high_ Whether the cushion is for the high or low side of the range (true = high, false = low)\n    function _deactivate(bool high_) internal {\n        uint256 market = RANGE.market(high_);\n        if (auctioneer.isLive(market)) {\n            auctioneer.closeMarket(market);\n            RANGE.updateMarket(high_, type(uint256).max, 0);\n        }\n    }\n\n    /// @notice         Helper function to calculate number of price decimals based on the value returned from the price feed.\n    /// @param price_   The price to calculate the number of decimals for\n    /// @return         The number of decimals\n    function _getPriceDecimals(uint256 price_) internal view returns (int8) {\n        int8 decimals;\n        while (price_ >= 10) {\n            price_ = price_ / 10;\n            decimals++;\n        }\n\n        /// Subtract the stated decimals from the calculated decimals to get the relative price decimals.\n        /// Required to do it this way vs. normalizing at the beginning since price decimals can be negative.\n        return decimals - int8(PRICE.decimals());\n    }\n\n    /* ========== OPERATOR CONFIGURATION ========== */\n    /// @inheritdoc IOperator\n    function setSpreads(uint256 cushionSpread_, uint256 wallSpread_)\n        external\n        onlyRole(\"operator_policy\")\n    {\n        /// Set spreads on the range module\n        RANGE.setSpreads(cushionSpread_, wallSpread_);\n\n        /// Update range prices (wall and cushion)\n        _updateRangePrices();\n    }\n\n    /// @inheritdoc IOperator\n    function setThresholdFactor(uint256 thresholdFactor_) external onlyRole(\"operator_policy\") {\n        /// Set threshold factor on the range module\n        RANGE.setThresholdFactor(thresholdFactor_);\n    }\n\n    /// @inheritdoc IOperator\n    function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {\n        /// Confirm factor is within allowed values\n        if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\n\n        /// Set factor\n        _config.cushionFactor = cushionFactor_;\n\n        emit CushionFactorChanged(cushionFactor_);\n    }\n\n    /// @inheritdoc IOperator\n    function setCushionParams(\n        uint32 duration_,\n        uint32 debtBuffer_,\n        uint32 depositInterval_\n    ) external onlyRole(\"operator_policy\") {\n        /// Confirm values are valid\n        if (duration_ > uint256(7 days) || duration_ < uint256(1 days))\n            revert Operator_InvalidParams();\n        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();\n        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)\n            revert Operator_InvalidParams();\n\n        /// Update values\n        _config.cushionDuration = duration_;\n        _config.cushionDebtBuffer = debtBuffer_;\n        _config.cushionDepositInterval = depositInterval_;\n\n        emit CushionParamsChanged(duration_, debtBuffer_, depositInterval_);\n    }\n\n    /// @inheritdoc IOperator\n    function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") {\n        /// Confirm factor is within allowed values\n        if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();\n\n        /// Set factor\n        _config.reserveFactor = reserveFactor_;\n\n        emit ReserveFactorChanged(reserveFactor_);\n    }\n\n    /// @inheritdoc IOperator\n    function setRegenParams(\n        uint32 wait_,\n        uint32 threshold_,\n        uint32 observe_\n    ) external onlyRole(\"operator_policy\") {\n        /// Confirm regen parameters are within allowed values\n        if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0)\n            revert Operator_InvalidParams();\n\n        /// Set regen params\n        _config.regenWait = wait_;\n        _config.regenThreshold = threshold_;\n        _config.regenObserve = observe_;\n\n        /// Re-initialize regen structs with new values (except for last regen)\n        _status.high.count = 0;\n        _status.high.nextObservation = 0;\n        _status.high.observations = new bool[](observe_);\n\n        _status.low.count = 0;\n        _status.low.nextObservation = 0;\n        _status.low.observations = new bool[](observe_);\n\n        emit RegenParamsChanged(wait_, threshold_, observe_);\n    }\n\n    /// @inheritdoc IOperator\n    function setBondContracts(IBondAuctioneer auctioneer_, IBondCallback callback_)\n        external\n        onlyRole(\"operator_admin\")\n    {\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n        /// Set contracts\n        auctioneer = auctioneer_;\n        callback = callback_;\n    }\n\n    /// @inheritdoc IOperator\n    function initialize() external onlyRole(\"operator_admin\") {\n        /// Can only call once\n        if (initialized) revert Operator_AlreadyInitialized();\n\n        /// Request approval for reserves from TRSRY\n        TRSRY.setApprovalFor(address(this), reserve, type(uint256).max);\n\n        /// Update range prices (wall and cushion)\n        _updateRangePrices();\n\n        /// Regenerate sides\n        _regenerate(true);\n        _regenerate(false);\n\n        /// Set initialized and active flags\n        initialized = true;\n        active = true;\n    }\n\n    /// @inheritdoc IOperator\n    function regenerate(bool high_) external onlyRole(\"operator_admin\") {\n        /// Regenerate side\n        _regenerate(high_);\n    }\n\n    /// @inheritdoc IOperator\n    function toggleActive() external onlyRole(\"operator_admin\") {\n        /// Toggle active state\n        active = !active;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /// @notice          Update the capacity on the RANGE module.\n    /// @param high_     Whether to update the high side or low side capacity (true = high, false = low).\n    /// @param reduceBy_ The amount to reduce the capacity by (OHM tokens for high side, Reserve tokens for low side).\n    function _updateCapacity(bool high_, uint256 reduceBy_) internal {\n        /// Initialize update variables, decrement capacity if a reduceBy amount is provided\n        uint256 capacity = RANGE.capacity(high_) - reduceBy_;\n\n        /// Update capacities on the range module for the wall and market\n        RANGE.updateCapacity(high_, capacity);\n    }\n\n    /// @notice Update the prices on the RANGE module\n    function _updateRangePrices() internal {\n        /// Get latest moving average from the price module\n        uint256 movingAverage = PRICE.getMovingAverage();\n\n        /// Update the prices on the range module\n        RANGE.updatePrices(movingAverage);\n    }\n\n    /// @notice Add an observation to the regeneration status variables for each side\n    function _addObservation() internal {\n        /// Get latest moving average from the price module\n        uint256 movingAverage = PRICE.getMovingAverage();\n\n        /// Get latest price\n        /// TODO determine if this should use the last price from the MA or recalculate the current price, ideally last price is ok since it should have been just updated and should include check against secondary?\n        /// Current price is guaranteed to be up to date, but may be a bad value if not checked?\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Store observations and update counts for regeneration\n\n        /// Update low side regen status with a new observation\n        /// Observation is positive if the current price is greater than the MA\n        uint32 observe = _config.regenObserve;\n        Regen memory regen = _status.low;\n        if (currentPrice >= movingAverage) {\n            if (!regen.observations[regen.nextObservation]) {\n                _status.low.observations[regen.nextObservation] = true;\n                _status.low.count++;\n            }\n        } else {\n            if (regen.observations[regen.nextObservation]) {\n                _status.low.observations[regen.nextObservation] = false;\n                _status.low.count--;\n            }\n        }\n        _status.low.nextObservation = (regen.nextObservation + 1) % observe;\n\n        /// Update high side regen status with a new observation\n        /// Observation is positive if the current price is less than the MA\n        regen = _status.high;\n        if (currentPrice <= movingAverage) {\n            if (!regen.observations[regen.nextObservation]) {\n                _status.high.observations[regen.nextObservation] = true;\n                _status.high.count++;\n            }\n        } else {\n            if (regen.observations[regen.nextObservation]) {\n                _status.high.observations[regen.nextObservation] = false;\n                _status.high.count--;\n            }\n        }\n        _status.high.nextObservation = (regen.nextObservation + 1) % observe;\n    }\n\n    /// @notice      Regenerate the wall for a side\n    /// @param high_ Whether to regenerate the high side or low side (true = high, false = low)\n    function _regenerate(bool high_) internal {\n        /// Deactivate cushion if active on the side being regenerated\n        _deactivate(high_);\n\n        if (high_) {\n            /// Reset the regeneration data for the side\n            _status.high.count = uint32(0);\n            _status.high.observations = new bool[](_config.regenObserve);\n            _status.high.nextObservation = uint32(0);\n            _status.high.lastRegen = uint48(block.timestamp);\n\n            /// Calculate capacity\n            uint256 capacity = fullCapacity(true);\n\n            /// Regenerate the side with the capacity\n            RANGE.regenerate(true, capacity);\n        } else {\n            /// Reset the regeneration data for the side\n            _status.low.count = uint32(0);\n            _status.low.observations = new bool[](_config.regenObserve);\n            _status.low.nextObservation = uint32(0);\n            _status.low.lastRegen = uint48(block.timestamp);\n\n            /// Calculate capacity\n            uint256 capacity = fullCapacity(false);\n\n            /// Regenerate the side with the capacity\n            RANGE.regenerate(false, capacity);\n        }\n    }\n\n    /// @notice      Takes down cushions (if active) when a wall is taken down or if available capacity drops below cushion capacity\n    /// @param high_ Whether to check the high side or low side cushion (true = high, false = low)\n    function _checkCushion(bool high_) internal {\n        /// Check if the wall is down, if so ensure the cushion is also down\n        /// Additionally, if wall is not down, but the wall capacity has dropped below the cushion capacity, take the cushion down\n        bool sideActive = RANGE.active(high_);\n        uint256 market = RANGE.market(high_);\n        if (\n            !sideActive ||\n            (sideActive &&\n                auctioneer.isLive(market) &&\n                RANGE.capacity(high_) < auctioneer.currentCapacity(market))\n        ) {\n            _deactivate(high_);\n        }\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function getAmountOut(ERC20 tokenIn_, uint256 amountIn_) public view returns (uint256) {\n        if (tokenIn_ == ohm) {\n            /// Calculate amount out\n            uint256 amountOut = amountIn_.mulDiv(\n                10**reserveDecimals * RANGE.price(true, false),\n                10**ohmDecimals * 10**PRICE.decimals()\n            );\n\n            /// Revert if amount out exceeds capacity\n            if (amountOut > RANGE.capacity(false)) revert Operator_InsufficientCapacity();\n\n            return amountOut;\n        } else if (tokenIn_ == reserve) {\n            /// Calculate amount out\n            uint256 amountOut = amountIn_.mulDiv(\n                10**ohmDecimals * 10**PRICE.decimals(),\n                10**reserveDecimals * RANGE.price(true, true)\n            );\n\n            /// Revert if amount out exceeds capacity\n            if (amountOut > RANGE.capacity(true)) revert Operator_InsufficientCapacity();\n\n            return amountOut;\n        } else {\n            revert Operator_InvalidParams();\n        }\n    }\n\n    /// @inheritdoc IOperator\n    function fullCapacity(bool high_) public view override returns (uint256) {\n        uint256 reservesInTreasury = TRSRY.getReserveBalance(reserve);\n        uint256 capacity = (reservesInTreasury * _config.reserveFactor) / FACTOR_SCALE;\n        if (high_) {\n            capacity =\n                (capacity.mulDiv(\n                    10**ohmDecimals * 10**PRICE.decimals(),\n                    10**reserveDecimals * RANGE.price(true, true)\n                ) * (FACTOR_SCALE + RANGE.spread(true) * 2)) /\n                FACTOR_SCALE;\n        }\n        return capacity;\n    }\n\n    /// @inheritdoc IOperator\n    function status() external view override returns (Status memory) {\n        return _status;\n    }\n\n    /// @inheritdoc IOperator\n    function config() external view override returns (Config memory) {\n        return _config;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\n\nimport {BondFixedTermCDA} from \"test/lib/bonds/BondFixedTermCDA.sol\";\nimport {BondAggregator} from \"test/lib/bonds/BondAggregator.sol\";\nimport {BondFixedTermTeller} from \"test/lib/bonds/BondFixedTermTeller.sol\";\nimport {RolesAuthority, Authority as SolmateAuthority} from \"solmate/auth/authorities/RolesAuthority.sol\";\n\nimport {MockERC20, ERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport {MockPrice} from \"test/mocks/MockPrice.sol\";\n\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondAggregator} from \"interfaces/IBondAggregator.sol\";\n\nimport {FullMath} from \"libraries/FullMath.sol\";\n\nimport \"src/Kernel.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter, OHM} from \"modules/MINTR.sol\";\n\nimport {Operator} from \"policies/Operator.sol\";\nimport {BondCallback} from \"policies/BondCallback.sol\";\n\ncontract MockOhm is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burnFrom(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n\n// solhint-disable-next-line max-states-count\ncontract OperatorTest is Test {\n    using FullMath for uint256;\n\n    UserFactory public userCreator;\n    address internal alice;\n    address internal bob;\n    address internal guardian;\n    address internal policy;\n    address internal heart;\n\n    RolesAuthority internal auth;\n    BondAggregator internal aggregator;\n    BondFixedTermTeller internal teller;\n    BondFixedTermCDA internal auctioneer;\n    MockOhm internal ohm;\n    MockERC20 internal reserve;\n\n    Kernel internal kernel;\n    MockPrice internal price;\n    OlympusRange internal range;\n    OlympusTreasury internal treasury;\n    OlympusMinter internal minter;\n\n    Operator internal operator;\n    BondCallback internal callback;\n\n    function setUp() public {\n        vm.warp(51 * 365 * 24 * 60 * 60); // Set timestamp at roughly Jan 1, 2021 (51 years since Unix epoch)\n        userCreator = new UserFactory();\n        {\n            /// Deploy bond system to test against\n            address[] memory users = userCreator.create(5);\n            alice = users[0];\n            bob = users[1];\n            guardian = users[2];\n            policy = users[3];\n            heart = users[4];\n            auth = new RolesAuthority(guardian, SolmateAuthority(address(0)));\n\n            /// Deploy the bond system\n            aggregator = new BondAggregator(guardian, auth);\n            teller = new BondFixedTermTeller(guardian, aggregator, guardian, auth);\n            auctioneer = new BondFixedTermCDA(teller, aggregator, guardian, auth);\n\n            /// Register auctioneer on the bond system\n            vm.prank(guardian);\n            aggregator.registerAuctioneer(auctioneer);\n        }\n\n        {\n            /// Deploy mock tokens\n            ohm = new MockOhm(\"Olympus\", \"OHM\", 9);\n            reserve = new MockERC20(\"Reserve\", \"RSV\", 18);\n        }\n\n        {\n            /// Deploy kernel\n            kernel = new Kernel(); // this contract will be the executor\n\n            /// Deploy modules (some mocks)\n            price = new MockPrice(kernel, uint48(8 hours));\n            range = new OlympusRange(\n                kernel,\n                [ERC20(ohm), ERC20(reserve)],\n                [uint256(100), uint256(1000), uint256(2000)]\n            );\n            treasury = new OlympusTreasury(kernel);\n            minter = new OlympusMinter(kernel, address(ohm));\n\n            /// Configure mocks\n            price.setMovingAverage(100 * 1e18);\n            price.setLastPrice(100 * 1e18);\n            price.setDecimals(18);\n        }\n\n        {\n            /// Deploy bond callback\n            callback = new BondCallback(kernel, IBondAggregator(address(aggregator)), ohm);\n\n            /// Deploy operator\n            operator = new Operator(\n                kernel,\n                IBondAuctioneer(address(auctioneer)),\n                callback,\n                [ERC20(ohm), ERC20(reserve)],\n                [\n                    uint32(2000), // cushionFactor\n                    uint32(5 days), // duration\n                    uint32(100_000), // debtBuffer\n                    uint32(1 hours), // depositInterval\n                    uint32(1000), // reserveFactor\n                    uint32(1 hours), // regenWait\n                    uint32(5), // regenThreshold\n                    uint32(7) // regenObserve\n                ]\n            );\n\n            /// Registor operator to create bond markets with a callback\n            vm.prank(guardian);\n            auctioneer.setCallbackAuthStatus(address(operator), true);\n        }\n\n        {\n            /// Initialize system and kernel\n\n            /// Install modules\n            kernel.executeAction(Actions.InstallModule, address(price));\n            kernel.executeAction(Actions.InstallModule, address(range));\n            kernel.executeAction(Actions.InstallModule, address(treasury));\n            kernel.executeAction(Actions.InstallModule, address(minter));\n\n            /// Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(operator));\n            kernel.executeAction(Actions.ActivatePolicy, address(callback));\n        }\n        {\n            /// Configure access control\n\n            /// Operator roles\n            kernel.grantRole(toRole(\"operator_operate\"), address(heart));\n            kernel.grantRole(toRole(\"operator_operate\"), guardian);\n            kernel.grantRole(toRole(\"operator_reporter\"), address(callback));\n            kernel.grantRole(toRole(\"operator_policy\"), policy);\n            kernel.grantRole(toRole(\"operator_admin\"), guardian);\n\n            /// Bond callback roles\n            kernel.grantRole(toRole(\"callback_whitelist\"), address(operator));\n            kernel.grantRole(toRole(\"callback_whitelist\"), guardian);\n            kernel.grantRole(toRole(\"callback_admin\"), guardian);\n        }\n\n        /// Set operator on the callback\n        vm.prank(guardian);\n        callback.setOperator(operator);\n\n        // Mint tokens to users and treasury for testing\n        uint256 testOhm = 1_000_000 * 1e9;\n        uint256 testReserve = 1_000_000 * 1e18;\n\n        ohm.mint(alice, testOhm * 20);\n        reserve.mint(alice, testReserve * 20);\n\n        reserve.mint(address(treasury), testReserve * 100);\n\n        // Approve the operator and bond teller for the tokens to swap\n        vm.prank(alice);\n        ohm.approve(address(operator), testOhm * 20);\n        vm.prank(alice);\n        reserve.approve(address(operator), testReserve * 20);\n\n        vm.prank(alice);\n        ohm.approve(address(teller), testOhm * 20);\n        vm.prank(alice);\n        reserve.approve(address(teller), testReserve * 20);\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n    function knockDownWall(bool high_) internal returns (uint256 amountIn, uint256 amountOut) {\n        if (high_) {\n            /// Get current capacity of the high wall\n            /// Set amount in to put capacity 1 below the threshold for shutting down the wall\n            uint256 startCapacity = range.capacity(true);\n            uint256 highWallPrice = range.price(true, true);\n            amountIn = startCapacity.mulDiv(highWallPrice, 1e9).mulDiv(9999, 10000) + 1;\n\n            uint256 expAmountOut = operator.getAmountOut(reserve, amountIn);\n\n            /// Swap at the high wall\n            vm.prank(alice);\n            amountOut = operator.swap(reserve, amountIn, expAmountOut);\n        } else {\n            /// Get current capacity of the low wall\n            /// Set amount in to put capacity 1 below the threshold for shutting down the wall\n            uint256 startCapacity = range.capacity(false);\n            uint256 lowWallPrice = range.price(true, false);\n            amountIn = startCapacity.mulDiv(1e9, lowWallPrice).mulDiv(9999, 10000) + 1;\n\n            uint256 expAmountOut = operator.getAmountOut(ohm, amountIn);\n\n            /// Swap at the low wall\n            vm.prank(alice);\n            amountOut = operator.swap(ohm, amountIn, expAmountOut);\n        }\n    }\n\n    /* ========== WALL TESTS ========== */\n\n    /// DONE\n    /// [X] Able to swap when walls are up\n    /// [X] Splippage check when swapping\n    /// [X] Wall breaks when capacity drops below the configured threshold\n    /// [X] Not able to swap at the walls when they are down\n\n    function testCorrectness_swapHighWall() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get current capacity of the high wall and starting balance for user\n        uint256 startCapacity = range.capacity(true);\n        uint256 amountIn = 100 * 1e18;\n        uint256 ohmBalance = ohm.balanceOf(alice);\n        uint256 reserveBalance = reserve.balanceOf(alice);\n\n        /// Calculate expected difference\n        uint256 highWallPrice = range.price(true, true);\n        uint256 expAmountOut = amountIn.mulDiv(1e9 * 1e18, 1e18 * highWallPrice);\n\n        /// Swap at the high wall\n        vm.prank(alice);\n        uint256 amountOut = operator.swap(reserve, amountIn, expAmountOut);\n\n        /// Get updated capacity of the high wall\n        uint256 endCapacity = range.capacity(true);\n\n        assertEq(amountOut, expAmountOut);\n        assertEq(endCapacity, startCapacity - amountOut);\n        assertEq(ohm.balanceOf(alice), ohmBalance + amountOut);\n        assertEq(reserve.balanceOf(alice), reserveBalance - amountIn);\n    }\n\n    function testCorrectness_swapLowWall() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get current capacity of the high wall and starting balance for user\n        uint256 startCapacity = range.capacity(false);\n        uint256 amountIn = 100 * 1e9;\n        uint256 ohmBalance = ohm.balanceOf(alice);\n        uint256 reserveBalance = reserve.balanceOf(alice);\n\n        /// Calculate expected difference\n        uint256 lowWallPrice = range.price(true, false);\n        uint256 expAmountOut = amountIn.mulDiv(1e18 * lowWallPrice, 1e9 * 1e18);\n\n        /// Swap at the high wall\n        vm.prank(alice);\n        uint256 amountOut = operator.swap(ohm, amountIn, expAmountOut);\n\n        /// Get updated capacity of the high wall\n        uint256 endCapacity = range.capacity(false);\n\n        assertEq(amountOut, expAmountOut);\n        assertEq(endCapacity, startCapacity - amountOut);\n        assertEq(ohm.balanceOf(alice), ohmBalance - amountIn);\n        assertEq(reserve.balanceOf(alice), reserveBalance + amountOut);\n    }\n\n    function testCorrectness_highWallBreaksAtThreshold() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Get initial balances and capacity\n        uint256 ohmBalance = ohm.balanceOf(alice);\n        uint256 reserveBalance = reserve.balanceOf(alice);\n        uint256 startCapacity = range.capacity(true);\n\n        /// Take down wall with helper function\n        (uint256 amountIn, uint256 amountOut) = knockDownWall(true);\n\n        /// Get updated capacity of the high wall\n        uint256 endCapacity = range.capacity(true);\n\n        /// Confirm the wall is down\n        assertTrue(!range.active(true));\n\n        /// Check that capacity and balances are correct\n        assertEq(endCapacity, startCapacity - amountOut);\n        assertEq(ohm.balanceOf(alice), ohmBalance + amountOut);\n        assertEq(reserve.balanceOf(alice), reserveBalance - amountIn);\n    }\n\n    function testCorrectness_lowWallBreaksAtThreshold() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Get initial balances and capacity\n        uint256 ohmBalance = ohm.balanceOf(alice);\n        uint256 reserveBalance = reserve.balanceOf(alice);\n        uint256 startCapacity = range.capacity(false);\n\n        /// Take down wall with helper function\n        (uint256 amountIn, uint256 amountOut) = knockDownWall(false);\n\n        /// Get updated capacity of the high wall\n        uint256 endCapacity = range.capacity(false);\n\n        /// Confirm the wall is down\n        assertTrue(!range.active(false));\n\n        /// Check that capacity and balances are correct\n        assertEq(endCapacity, startCapacity - amountOut);\n        assertEq(ohm.balanceOf(alice), ohmBalance - amountIn);\n        assertEq(reserve.balanceOf(alice), reserveBalance + amountOut);\n    }\n\n    function testCorrectness_cannotSwapHighWallWhenDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down wall with helper function\n        knockDownWall(true);\n\n        /// Try to swap, expect to fail\n        uint256 amountIn = 100 * 1e18;\n        uint256 expAmountOut = amountIn.mulDiv(1e9 * 1e18, 1e18 * range.price(true, true));\n\n        bytes memory err = abi.encodeWithSignature(\"Operator_WallDown()\");\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(reserve, amountIn, expAmountOut);\n    }\n\n    function testCorrectness_cannotSwapLowWallWhenDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down wall with helper function\n        knockDownWall(false);\n\n        /// Try to swap, expect to fail\n        uint256 amountIn = 100 * 1e9;\n        uint256 expAmountOut = amountIn.mulDiv(1e18 * range.price(true, false), 1e9 * 1e18);\n\n        bytes memory err = abi.encodeWithSignature(\"Operator_WallDown()\");\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(ohm, amountIn, expAmountOut);\n    }\n\n    function testCorrectness_swapRevertsOnSlippage() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm walls are up\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n\n        /// Set amounts for high wall swap with minAmountOut greater than expAmountOut\n        uint256 amountIn = 100 * 1e18;\n        uint256 expAmountOut = amountIn.mulDiv(1e9 * 1e18, 1e18 * range.price(true, true));\n        uint256 minAmountOut = expAmountOut + 1;\n\n        /// Try to swap at low wall, expect to fail\n        bytes memory err = abi.encodeWithSignature(\n            \"Operator_AmountLessThanMinimum(uint256,uint256)\",\n            expAmountOut,\n            minAmountOut\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(reserve, amountIn, minAmountOut);\n\n        /// Set amounts for low wall swap with minAmountOut greater than expAmountOut\n        amountIn = 100 * 1e9;\n        expAmountOut = amountIn.mulDiv(1e18 * range.price(true, false), 1e9 * 1e18);\n        minAmountOut = expAmountOut + 1;\n\n        /// Try to swap at low wall, expect to fail\n        err = abi.encodeWithSignature(\n            \"Operator_AmountLessThanMinimum(uint256,uint256)\",\n            expAmountOut,\n            minAmountOut\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(ohm, amountIn, minAmountOut);\n    }\n\n    function testCorrectness_swapRevertsWithInvalidToken() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm walls are up\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n\n        /// Try to swap with invalid token, expect to fail\n        uint256 amountIn = 100 * 1e18;\n        uint256 minAmountOut = 100 * 1e18;\n        ERC20 token = ERC20(bob);\n\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(token, amountIn, minAmountOut);\n    }\n\n    /* ========== CUSHION TESTS ========== */\n\n    /// DONE\n    /// [X] Cushions deployed when price set in the range and operate triggered\n    /// [X] Cushions deactivated when price out of range and operate triggered or when wall goes down\n    /// [X] Cushion doesn't deploy when wall is down\n    /// [X] Bond purchases update capacity\n\n    function testCorrectness_highCushionDeployedInSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        uint256 marketId = range.market(true);\n        assertTrue(auctioneer.isLive(marketId));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(marketId);\n        // console2.log(\"capacity\", marketCapacity);\n        assertEq(marketCapacity, range.capacity(true).mulDiv(config.cushionFactor, 1e4));\n\n        /// Check that the price is set correctly\n        // (, , , , , , , , , , , uint256 scale) = auctioneer.markets(marketId);\n        // uint256 price = auctioneer.marketPrice(marketId);\n        // console2.log(\"price\", price);\n        // console2.log(\"scale\", scale);\n        uint256 payout = auctioneer.payoutFor(120 * 1e18, marketId, alice);\n        assertEq(payout, 1e9);\n    }\n\n    function testCorrectness_highCushionClosedBelowSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        assertTrue(auctioneer.isLive(range.market(true)));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(range.market(true));\n        assertEq(marketCapacity, range.capacity(true).mulDiv(config.cushionFactor, 1e4));\n\n        /// Set price on mock oracle below the high cushion\n        price.setLastPrice(105 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        marketCapacity = auctioneer.currentCapacity(range.market(true));\n        assertEq(marketCapacity, 0);\n    }\n\n    function testCorrectness_highCushionClosedAboveSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        assertTrue(auctioneer.isLive(range.market(true)));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(range.market(true));\n        assertEq(marketCapacity, range.capacity(true).mulDiv(config.cushionFactor, 1e4));\n\n        /// Set price on mock oracle below the high cushion\n        price.setLastPrice(130 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        marketCapacity = auctioneer.currentCapacity(range.market(true));\n        assertEq(marketCapacity, 0);\n    }\n\n    function testCorrectness_highCushionClosedWhenWallDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        assertTrue(auctioneer.isLive(range.market(true)));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n    }\n\n    function testCorrectness_highCushionNotDeployedWhenWallDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Set price on mock oracle into the low cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n    }\n\n    function testCorrectness_lowCushionDeployedInSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        uint256 marketId = range.market(false);\n        assertTrue(auctioneer.isLive(marketId));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(marketId);\n        assertEq(marketCapacity, range.capacity(false).mulDiv(config.cushionFactor, 1e4));\n\n        /// Check that the price is set correctly\n        // (, , , , , , , , , , , uint256 scale) = auctioneer.markets(marketId);\n        // uint256 price = auctioneer.marketPrice(marketId);\n        // console2.log(\"price\", price);\n        // console2.log(\"scale\", scale);\n        uint256 payout = auctioneer.payoutFor(1e9, marketId, alice);\n        assertEq(payout, 80 * 1e18);\n    }\n\n    function testCorrectness_lowCushionClosedBelowSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        assertTrue(auctioneer.isLive(range.market(false)));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(range.market(false));\n        assertEq(marketCapacity, range.capacity(false).mulDiv(config.cushionFactor, 1e4));\n\n        /// Set price on mock oracle below the high cushion\n        price.setLastPrice(79 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        marketCapacity = auctioneer.currentCapacity(range.market(false));\n        assertEq(marketCapacity, 0);\n    }\n\n    function testCorrectness_lowCushionClosedAboveSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        assertTrue(auctioneer.isLive(range.market(false)));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(range.market(false));\n        assertEq(marketCapacity, range.capacity(false).mulDiv(config.cushionFactor, 1e4));\n\n        /// Set price on mock oracle below the high cushion\n        price.setLastPrice(91 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        marketCapacity = auctioneer.currentCapacity(range.market(false));\n        assertEq(marketCapacity, 0);\n    }\n\n    function testCorrectness_lowCushionClosedWhenWallDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Set price on mock oracle into the low cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        assertTrue(auctioneer.isLive(range.market(false)));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n    }\n\n    function testCorrectness_lowCushionNotDeployedWhenWallDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Set price on mock oracle into the low cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n    }\n\n    function test_marketClosesAsExpected1() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Assert high wall is up\n        assertTrue(range.active(true));\n\n        /// Set price below the moving average to almost regenerate high wall\n        price.setLastPrice(99 * 1e18);\n\n        /// Trigger the operator function enough times to almost regenerate the high wall\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Ensure market not live yet\n        uint256 currentMarket = range.market(true);\n        assertEq(type(uint256).max, currentMarket);\n\n        /// Cause price to spike to trigger high cushion\n        uint256 cushionPrice = range.price(false, true);\n        price.setLastPrice(cushionPrice + 500);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check market is live\n        currentMarket = range.market(true);\n        assertTrue(type(uint256).max != currentMarket);\n        assertTrue(auctioneer.isLive(currentMarket));\n\n        /// Cause price to go back down to moving average\n        /// Move time forward past the regen period to trigger high wall regeneration\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Will trigger regeneration of high wall\n        /// Will set the operator market on high side to type(uint256).max\n        /// However, the prior market will still be live when it's supposed to be deactivated\n        price.setLastPrice(95 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n        /// Get latest market\n        uint256 newMarket = range.market(true);\n\n        /// Check market has been updated to non existent market\n        assertTrue(type(uint256).max == newMarket);\n        /// And, the previous market is closed\n        assertTrue(!auctioneer.isLive(currentMarket));\n    }\n\n    function test_marketClosesAsExpected2() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Assert high wall is up\n        assertTrue(range.active(true));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Get current market\n        uint256 currentMarket = range.market(true);\n\n        /// Check market has been updated and is live\n        assertTrue(type(uint256).max != currentMarket);\n        assertTrue(auctioneer.isLive(currentMarket));\n\n        /// Take down wall\n        knockDownWall(true);\n\n        /// Get latest market\n        uint256 newMarket = range.market(true);\n\n        /// Check market has been updated to non existent market\n        assertTrue(type(uint256).max == newMarket);\n        /// And the previous market is closed\n        assertTrue(!auctioneer.isLive(currentMarket));\n    }\n\n    function testCorrectness_highCushionPurchasesReduceCapacity() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get the start capacity of the high side\n        uint256 startCapacity = range.capacity(true);\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        uint256 id = range.market(true);\n        assertTrue(auctioneer.isLive(id));\n\n        /// Set amount to purchase from cushion (which will be at wall price initially)\n        uint256 amountIn = auctioneer.maxAmountAccepted(id, guardian) / 2;\n        uint256 minAmountOut = auctioneer.payoutFor(amountIn, id, guardian);\n\n        /// Purchase from cushion\n        vm.prank(alice);\n        (uint256 payout, ) = teller.purchase(alice, guardian, id, amountIn, minAmountOut);\n\n        /// Check that the side capacity has been reduced by the amount of the payout\n        assertEq(range.capacity(true), startCapacity - payout);\n    }\n\n    function testCorrectness_lowCushionPurchasesReduceCapacity() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get the start capacity of the low side\n        uint256 startCapacity = range.capacity(false);\n\n        /// Set price on mock oracle into the low cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        uint256 id = range.market(false);\n        assertTrue(auctioneer.isLive(id));\n\n        /// Set amount to purchase from cushion (which will be at wall price initially)\n        uint256 amountIn = auctioneer.maxAmountAccepted(id, guardian) / 2;\n        uint256 minAmountOut = auctioneer.payoutFor(amountIn, id, guardian);\n\n        /// Purchase from cushion\n        vm.prank(alice);\n        (uint256 payout, ) = teller.purchase(alice, guardian, id, amountIn, minAmountOut);\n\n        /// Check that the side capacity has been reduced by the amount of the payout\n        assertEq(range.capacity(false), startCapacity - payout);\n    }\n\n    /* ========== REGENERATION TESTS ========== */\n\n    /// DONE\n    /// [X] Wall regenerates when price on other side of MA for enough observations\n    /// [X] Wrap around logic works for counting observations\n    /// [X] Regen period enforces a minimum time to wait for regeneration\n\n    function testCorrectness_lowWallRegenA() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests the simplest case of regen\n        /// Takes down wall, moves price in regen range,\n        /// and hits regen count required with consequtive calls\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is up\n        assertTrue(range.active(false));\n\n        /// Check that the capacity has regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, fullCapacity);\n    }\n\n    function testCorrectness_lowWallRegenB() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests wrap around logic of regen\n        /// Takes down wall, calls operate a few times with price not in regen range,\n        /// moves price into regen range, and hits regen count required with consequtive calls\n        /// that wrap around the count array\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average so regeneration doesn't start\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator function with negative\n        for (uint256 i; i < 8; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(false));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is up\n        assertTrue(range.active(false));\n\n        /// Check that the capacity has regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, fullCapacity);\n    }\n\n    function testCorrectness_lowWallRegenC() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that wall does not regenerate before the required count is reached\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(false));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_lowWallRegenD() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that wall does not regenerate before the required count is reached\n        /// Use more complex logic to ensure wrap around logic is working and\n        /// that positive checks outside the moving window aren't counted\n        /// observations should be: +, -, -, -, +, +, +, +\n        /// last observation wraps around to first and therefore only 4/7 of the observations are counted\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator once to get a positive check\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Set price below the moving average to get negative checks\n        price.setLastPrice(99 * 1e18);\n\n        /// Trigger the operator function several times with negative checks\n        for (uint256 i; i < 3; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function several times with positive checks\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(false));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_lowWallRegenTime() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that the wall won't regenerate before the required time has passed,\n        /// even with enough observations\n        /// Takes down wall, moves price in regen range,\n        /// and hits regen count required with consequtive calls\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Don't move time forward past the regen period so it won't regen\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(false));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_lowCushionClosedOnRegen() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that a manually regenerated wall will close the cushion that is deployed currently\n\n        /// Trigger a cushion\n        price.setLastPrice(89 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        assertTrue(auctioneer.isLive(range.market(false)));\n        assertEq(range.market(false), 0);\n\n        /// Regenerate the wall manually, expect market to close\n        vm.prank(guardian);\n        operator.regenerate(false);\n\n        /// Check that the market is closed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n        assertEq(range.market(false), type(uint256).max);\n    }\n\n    function testCorrectness_highWallRegenA() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests the simplest case of regen\n        /// Takes down wall, moves price in regen range,\n        /// and hits regen count required with consequtive calls\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(99 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is up\n        assertTrue(range.active(true));\n\n        /// Check that the capacity has regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, fullCapacity);\n    }\n\n    function testCorrectness_highWallRegenB() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests wrap around logic of regen\n        /// Takes down wall, calls operate a few times with price not in regen range,\n        /// moves price into regen range, and hits regen count required with consequtive calls\n        /// that wrap around the count array\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average so regeneration doesn't start\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function with negative\n        for (uint256 i; i < 8; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(true));\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is up\n        assertTrue(range.active(true));\n\n        /// Check that the capacity has regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, fullCapacity);\n    }\n\n    function testCorrectness_highWallRegenC() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that wall does not regenerate before the required count is reached\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(true));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_highWallRegenD() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that wall does not regenerate before the required count is reached\n        /// Use more complex logic to ensure wrap around logic is working and\n        /// that positive checks outside the moving window aren't counted\n        /// observations should be: +, -, -, -, +, +, +, +\n        /// last observation wraps around to first and therefore only 4/7 of the observations are counted\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average to regenerate low wall\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator once to get a positive check\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Set price above the moving average to get negative checks\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function several times with negative checks\n        for (uint256 i; i < 3; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator function several times with positive checks\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(true));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_highWallRegenTime() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that the wall won't regenerate before the required time has passed,\n        /// even with enough observations\n        /// Takes down wall, moves price in regen range,\n        /// and hits regen count required with consequtive calls\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Don't move time forward past the regen period so it won't regen\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(99 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(true));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_highCushionClosedOnRegen() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that a manually regenerated wall will close the cushion that is deployed currently\n\n        /// Trigger a cushion\n        price.setLastPrice(111 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        assertTrue(auctioneer.isLive(range.market(true)));\n        assertEq(range.market(true), 0);\n\n        /// Regenerate the wall manually, expect market to close\n        vm.prank(guardian);\n        operator.regenerate(true);\n\n        /// Check that the market is closed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n        assertEq(range.market(true), type(uint256).max);\n    }\n\n    /* ========== ACCESS CONTROL TESTS ========== */\n\n    /// DONE\n    /// [X] operate only callable by heart or guardian\n    /// [X] admin configuration functions only callable by policy or guardian (negative here, positive in ADMIN TESTS sections)\n\n    function testCorrectness_onlyHeartOrGovernanceCanOperate() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Call operate as heart contract\n        vm.prank(heart);\n        operator.operate();\n\n        /// Call operate as governance\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Try to call operate as anyone else\n        bytes memory err = abi.encodeWithSelector(\n            Policy_OnlyRole.selector,\n            toRole(\"operator_operate\")\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.operate();\n    }\n\n    function testCorrectness_cannotOperatorIfNotInitialized() public {\n        /// Toggle operator to active manually erroneously (so it will not revert with inactive)\n        vm.prank(guardian);\n        operator.toggleActive();\n\n        /// Call operate as heart contract and expect to revert\n        bytes memory err = abi.encodeWithSignature(\"Operator_NotInitialized()\");\n        vm.expectRevert(err);\n        vm.prank(heart);\n        operator.operate();\n    }\n\n    function testCorrectness_nonPolicyCannotSetConfig() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Try to set spreads as random user, expect revert\n        bytes memory err = abi.encodeWithSelector(\n            Policy_OnlyRole.selector,\n            toRole(\"operator_policy\")\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setSpreads(1500, 3000);\n\n        /// Try to set cushionFactor as random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setCushionFactor(1500);\n\n        /// Try to set cushionDuration as random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setCushionParams(uint32(6 hours), uint32(50_000), uint32(4 hours));\n\n        /// Try to set cushionFactor as random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setReserveFactor(1500);\n\n        /// Try to set regenParams as a random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setRegenParams(uint32(1 days), uint32(8), uint32(11));\n    }\n\n    function testCorrectness_nonGuardianCannotCall() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Try to set spreads as random user, expect revert\n        bytes memory err = abi.encodeWithSelector(\n            Policy_OnlyRole.selector,\n            toRole(\"operator_admin\")\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setBondContracts(IBondAuctioneer(alice), BondCallback(alice));\n\n        /// Try to initialize as a random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.initialize();\n    }\n\n    /* ========== ADMIN TESTS ========== */\n\n    /// DONE\n    /// [X] setSpreads\n    /// [X] setThresholdFactor (in Range.t.sol) TODO\n    /// [X] setCushionFactor\n    /// [X] setCushionParams\n    /// [X] setReserveFactor\n    /// [X] setRegenParams\n    /// [X] setBondContracts\n    /// [X] initialize\n\n    function testCorrectness_setSpreads() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting bands\n        OlympusRange.Range memory startRange = range.range();\n\n        /// Set spreads larger as admin\n        vm.prank(policy);\n        operator.setSpreads(1500, 3000);\n\n        /// Get new bands\n        OlympusRange.Range memory newRange = range.range();\n\n        /// Check that the spreads have been set and prices are updated\n        assertEq(newRange.cushion.spread, 1500);\n        assertEq(newRange.wall.spread, 3000);\n        assertLt(newRange.cushion.low.price, startRange.cushion.low.price);\n        assertLt(newRange.wall.low.price, startRange.wall.low.price);\n        assertGt(newRange.cushion.high.price, startRange.cushion.high.price);\n        assertGt(newRange.wall.high.price, startRange.wall.high.price);\n\n        /// Set spreads smaller as admin\n        vm.prank(policy);\n        operator.setSpreads(500, 1000);\n\n        /// Get new bands\n        newRange = range.range();\n\n        /// Check that the spreads have been set and prices are updated\n        assertEq(newRange.cushion.spread, 500);\n        assertEq(newRange.wall.spread, 1000);\n        assertGt(newRange.cushion.low.price, startRange.cushion.low.price);\n        assertGt(newRange.wall.low.price, startRange.wall.low.price);\n        assertLt(newRange.cushion.high.price, startRange.cushion.high.price);\n        assertLt(newRange.wall.high.price, startRange.wall.high.price);\n    }\n\n    function testCorrectness_setThresholdFactor() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Check that the threshold factor is the same as initialized\n        assertEq(range.thresholdFactor(), 100);\n\n        /// Set threshold factor larger as admin\n        vm.prank(policy);\n        operator.setThresholdFactor(150);\n\n        /// Check that the threshold factor has been updated\n        assertEq(range.thresholdFactor(), 150);\n    }\n\n    function testCorrectness_cannotSetSpreadWithInvalidParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Set spreads with invalid params as admin (both too low)\n        bytes memory err = abi.encodeWithSignature(\"RANGE_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(99, 99);\n\n        /// Set spreads with invalid params as admin (both too high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(10001, 10001);\n\n        /// Set spreads with invalid params as admin (one high, one low)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(99, 10001);\n\n        /// Set spreads with invalid params as admin (one high, one low)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(10001, 99);\n\n        /// Set spreads with invalid params as admin (cushion > wall)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(2000, 1000);\n\n        /// Set spreads with invalid params as admin (one in, one high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(1000, 10001);\n\n        /// Set spreads with invalid params as admin (one in, one low)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(99, 2000);\n    }\n\n    function testCorrectness_setCushionFactor() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting cushion factor\n        Operator.Config memory startConfig = operator.config();\n\n        /// Set cushion factor as admin\n        vm.prank(policy);\n        operator.setCushionFactor(uint32(1000));\n\n        /// Get new cushion factor\n        Operator.Config memory newConfig = operator.config();\n\n        /// Check that the cushion factor has been set\n        assertEq(newConfig.cushionFactor, uint32(1000));\n        assertLt(newConfig.cushionFactor, startConfig.cushionFactor);\n    }\n\n    function testCorrectness_cannotSetCushionFactorWithInvalidParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Set cushion factor with invalid params as admin (too low)\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionFactor(uint32(99));\n\n        /// Set cushion factor with invalid params as admin (too high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionFactor(uint32(10001));\n    }\n\n    function testCorrectness_setCushionParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting cushion params\n        Operator.Config memory startConfig = operator.config();\n\n        /// Set cushion params as admin\n        vm.prank(policy);\n        operator.setCushionParams(uint32(24 hours), uint32(50_000), uint32(4 hours));\n\n        /// Get new cushion params\n        Operator.Config memory newConfig = operator.config();\n\n        /// Check that the cushion params has been set\n        assertEq(newConfig.cushionDuration, uint32(24 hours));\n        assertLt(newConfig.cushionDuration, startConfig.cushionDuration);\n        assertEq(newConfig.cushionDebtBuffer, uint32(50_000));\n        assertLt(newConfig.cushionDebtBuffer, startConfig.cushionDebtBuffer);\n        assertEq(newConfig.cushionDepositInterval, uint32(4 hours));\n        assertGt(newConfig.cushionDepositInterval, startConfig.cushionDepositInterval);\n    }\n\n    function testCorrectness_cannotSetCushionParamsWithInvalidParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Set cushion params with invalid duration as admin (too low)\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionParams(uint32(1 days) - 1, uint32(100_000), uint32(1 hours));\n\n        /// Set cushion params with invalid duration as admin (too high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionParams(uint32(7 days) + 1, uint32(100_000), uint32(1 hours));\n\n        /// Set cushion params with deposit interval greater than duration as admin\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionParams(uint32(1 days), uint32(100_000), uint32(2 days));\n\n        /// Set cushion params with invalid debt buffer as admin (too low)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionParams(uint32(2 days), uint32(99), uint32(2 hours));\n    }\n\n    function testCorrectness_setReserveFactor() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting reserve factor\n        Operator.Config memory startConfig = operator.config();\n\n        /// Set reserve factor as admin\n        vm.prank(policy);\n        operator.setReserveFactor(uint32(500));\n\n        /// Get new reserve factor\n        Operator.Config memory newConfig = operator.config();\n\n        /// Check that the reserve factor has been set\n        assertEq(newConfig.reserveFactor, uint32(500));\n        assertLt(newConfig.reserveFactor, startConfig.reserveFactor);\n    }\n\n    function testCorrectness_cannotSetReserveFactorWithInvalidParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Set reserve factor with invalid params as admin (too low)\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setReserveFactor(uint32(99));\n\n        /// Set reserve factor with invalid params as admin (too high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setReserveFactor(uint32(10001));\n    }\n\n    function testCorrectness_setRegenParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting regen params\n        Operator.Config memory startConfig = operator.config();\n\n        /// Confirm cannot set with invalid params\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        /// Case 1: wait < 1 hours\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setRegenParams(uint32(1 hours) - 1, uint32(11), uint32(15));\n\n        /// Case 2: observe == 0\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setRegenParams(uint32(1 days), uint32(0), uint32(0));\n\n        /// Case 3: observe < threshold\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setRegenParams(uint32(1 days), uint32(10), uint32(9));\n\n        /// Set regen params as admin with valid params\n        vm.prank(policy);\n        operator.setRegenParams(uint32(1 days), uint32(11), uint32(15));\n\n        /// Get new regen params\n        Operator.Config memory newConfig = operator.config();\n\n        /// Check that the regen params have been set\n        assertEq(newConfig.regenWait, uint256(1 days));\n        assertEq(newConfig.regenThreshold, 11);\n        assertEq(newConfig.regenObserve, 15);\n        assertGt(newConfig.regenWait, startConfig.regenWait);\n        assertGt(newConfig.regenThreshold, startConfig.regenThreshold);\n        assertGt(newConfig.regenObserve, startConfig.regenObserve);\n\n        /// Check that the regen structs have been re-initialized\n        Operator.Status memory status = operator.status();\n        assertEq(status.high.count, 0);\n        assertEq(status.high.nextObservation, 0);\n        assertEq(status.low.count, 0);\n        assertEq(status.low.nextObservation, 0);\n        for (uint256 i; i < 15; ++i) {\n            assertTrue(!status.high.observations[i]);\n            assertTrue(!status.low.observations[i]);\n        }\n    }\n\n    function testCorrectness_setBondContracts() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Attempt to set bond contracts to zero address and expect revert\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(guardian);\n        operator.setBondContracts(IBondAuctioneer(address(0)), BondCallback(address(0)));\n\n        /// Create new bond contracts\n        BondFixedTermCDA newCDA = new BondFixedTermCDA(teller, aggregator, guardian, auth);\n        BondCallback newCb = new BondCallback(kernel, IBondAggregator(address(aggregator)), ohm);\n\n        /// Update the bond contracts as guardian\n        vm.prank(guardian);\n        operator.setBondContracts(IBondAuctioneer(address(newCDA)), newCb);\n\n        /// Check that the bond contracts have been set\n        assertEq(address(operator.auctioneer()), address(newCDA));\n        assertEq(address(operator.callback()), address(newCb));\n    }\n\n    function testCorrectness_initialize() public {\n        /// Confirm that the operator is not initialized yet and walls are down\n        assertTrue(!operator.initialized());\n        assertTrue(!operator.active());\n        assertTrue(!range.active(true));\n        assertTrue(!range.active(false));\n        assertEq(treasury.withdrawApproval(address(operator), reserve), 0);\n        assertEq(range.price(false, false), 0);\n        assertEq(range.price(true, false), 0);\n        assertEq(range.price(false, true), 0);\n        assertEq(range.price(true, true), 0);\n        assertEq(range.capacity(false), 0);\n        assertEq(range.capacity(true), 0);\n\n        /// Initialize the operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the operator is initialized and walls are up\n        assertTrue(operator.initialized());\n        assertTrue(operator.active());\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n        assertEq(treasury.withdrawApproval(address(operator), reserve), type(uint256).max);\n        assertGt(range.price(false, false), 0);\n        assertGt(range.price(true, false), 0);\n        assertGt(range.price(false, true), 0);\n        assertGt(range.price(true, true), 0);\n        assertGt(range.capacity(false), 0);\n        assertGt(range.capacity(true), 0);\n    }\n\n    function testCorrectness_cannotInitializeTwice() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Try to initialize the operator again as guardian\n        bytes memory err = abi.encodeWithSignature(\"Operator_AlreadyInitialized()\");\n        vm.expectRevert(err);\n        vm.prank(guardian);\n        operator.initialize();\n    }\n\n    function testCorrectness_regenerate() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        uint48 startTime = uint48(block.timestamp);\n        vm.warp(block.timestamp + 1 hours);\n        uint48 newTime = uint48(block.timestamp);\n\n        /// Confirm that both sides are currently up\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n\n        /// Confirm that the Regen structs are at the initial state\n        Operator.Status memory status = operator.status();\n        assertEq(status.high.count, uint32(0));\n        assertEq(status.high.nextObservation, uint32(0));\n        assertEq(status.high.lastRegen, startTime);\n        assertEq(status.low.count, uint32(0));\n        assertEq(status.low.nextObservation, uint32(0));\n        assertEq(status.low.lastRegen, startTime);\n\n        /// Call operate twice, at different price points, to make the regen counts higher than zero\n        price.setLastPrice(105 * 1e18);\n        vm.prank(heart);\n        operator.operate();\n\n        price.setLastPrice(95 * 1e18);\n        vm.prank(heart);\n        operator.operate();\n\n        /// Confirm that the Regen structs are updated\n        status = operator.status();\n        assertEq(status.high.count, uint32(1));\n        assertEq(status.high.nextObservation, uint32(2));\n        assertEq(status.high.lastRegen, startTime);\n        assertEq(status.low.count, uint32(1));\n        assertEq(status.low.nextObservation, uint32(2));\n        assertEq(status.low.lastRegen, startTime);\n\n        /// Knock down both walls\n        knockDownWall(true);\n        knockDownWall(false);\n\n        /// Confirm that both sides are now down\n        assertTrue(!range.active(true));\n        assertTrue(!range.active(false));\n\n        /// Try to call regenerate without being guardian and expect revert\n        bytes memory err = abi.encodeWithSelector(\n            Policy_OnlyRole.selector,\n            toRole(\"operator_admin\")\n        );\n\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.regenerate(true);\n\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.regenerate(false);\n\n        /// Confirm that the Regen structs are the same as before and walls are still down\n        status = operator.status();\n        assertEq(status.high.count, uint32(1));\n        assertEq(status.high.nextObservation, uint32(2));\n        assertEq(status.low.count, uint32(1));\n        assertEq(status.low.nextObservation, uint32(2));\n        assertTrue(!range.active(true));\n        assertTrue(!range.active(false));\n\n        /// Call regenerate as guardian and confirm each side is updated\n        vm.prank(guardian);\n        operator.regenerate(true);\n\n        vm.prank(guardian);\n        operator.regenerate(false);\n\n        /// Confirm that the sides have regenerated and the Regen structs are reset\n        status = operator.status();\n        assertEq(status.high.count, uint32(0));\n        assertEq(status.high.nextObservation, uint32(0));\n        assertEq(status.high.lastRegen, newTime);\n        assertEq(status.low.count, uint32(0));\n        assertEq(status.low.nextObservation, uint32(0));\n        assertEq(status.low.lastRegen, newTime);\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n    }\n\n    function testCorrectness_cannotPerformMarketOpsWhileInactive() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Toggle the operator to inactive\n        vm.prank(guardian);\n        operator.toggleActive();\n\n        /// Try to call operator, swap, and bondPurchase, expect reverts\n        bytes memory err = abi.encodeWithSignature(\"Operator_Inactive()\");\n        vm.expectRevert(err);\n        vm.prank(guardian);\n        operator.operate();\n\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(ohm, 1e9, 1);\n\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(reserve, 1e18, 1);\n\n        vm.expectRevert(err);\n        vm.prank(address(callback));\n        operator.bondPurchase(0, 1e18);\n    }\n\n    /* ========== VIEW TESTS ========== */\n\n    /// DONE\n    /// [X] fullCapacity\n    /// [X] getAmountOut\n\n    function testCorrectness_viewFullCapacity() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Load config\n        Operator.Config memory config = operator.config();\n\n        /// Check that fullCapacity returns the full capacity based on the reserveFactor\n        uint256 resInTreasury = treasury.getReserveBalance(reserve);\n        uint256 lowCapacity = resInTreasury.mulDiv(config.reserveFactor, 1e4);\n        uint256 highCapacity = (lowCapacity.mulDiv(\n            1e9 * 10**price.decimals(),\n            1e18 * range.price(true, true)\n        ) * (1e4 + range.spread(true) * 2)) / 1e4;\n\n        assertEq(operator.fullCapacity(false), lowCapacity);\n        assertEq(operator.fullCapacity(true), highCapacity);\n    }\n\n    function testCorrectness_viewGetAmountOut() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Check that getAmountOut returns the amount of token to receive for different combinations of inputs\n        /// Case 1: OHM In, less than capacity\n        uint256 amountIn = 100 * 1e9;\n        uint256 expAmountOut = amountIn.mulDiv(1e18 * range.price(true, false), 1e9 * 1e18);\n\n        assertEq(expAmountOut, operator.getAmountOut(ohm, amountIn));\n\n        /// Case 2: OHM In, more than capacity\n        amountIn = range.capacity(false).mulDiv(1e9 * 1e18, 1e18 * range.price(true, false)) + 1e9;\n\n        bytes memory err = abi.encodeWithSignature(\"Operator_InsufficientCapacity()\");\n        vm.expectRevert(err);\n        operator.getAmountOut(ohm, amountIn);\n\n        /// Case 3: Reserve In, less than capacity\n        amountIn = 10000 * 1e18;\n        expAmountOut = amountIn.mulDiv(1e9 * 1e18, 1e18 * range.price(true, true));\n\n        assertEq(expAmountOut, operator.getAmountOut(reserve, amountIn));\n\n        /// Case 4: Reserve In, more than capacity\n        amountIn = range.capacity(true).mulDiv(1e18 * range.price(true, true), 1e9 * 1e18) + 1e18;\n\n        vm.expectRevert(err);\n        operator.getAmountOut(reserve, amountIn);\n\n        /// Case 5: Random, non-accepted token\n        err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        ERC20 token = ERC20(bob);\n        amountIn = 100 * 1e18;\n        vm.expectRevert(err);\n        operator.getAmountOut(token, amountIn);\n    }\n\n    /* ========== INTERNAL FUNCTION TESTS ========== */\n\n    /// DONE\n    /// [X] Range updates from new price data when operate is called (triggers _updateRange)\n\n    function testCorrectness_updateRange() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Store the starting bands\n        OlympusRange.Range memory startRange = range.range();\n\n        /// Update moving average upwards and trigger the operator\n        price.setMovingAverage(105 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the bands have updated\n        assertGt(range.price(false, false), startRange.cushion.low.price);\n        assertGt(range.price(true, false), startRange.wall.low.price);\n        assertGt(range.price(false, true), startRange.cushion.high.price);\n        assertGt(range.price(true, true), startRange.wall.high.price);\n\n        /// Update moving average downwards and trigger the operator\n        price.setMovingAverage(95 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the bands have updated\n        assertLt(range.price(false, false), startRange.cushion.low.price);\n        assertLt(range.price(true, false), startRange.wall.low.price);\n        assertLt(range.price(false, true), startRange.cushion.high.price);\n        assertLt(range.price(true, true), startRange.wall.high.price);\n    }\n}\n\n\n",
        "CodeNames": [
            "RANGE.t.sol",
            "RANGE.sol",
            "Operator.sol",
            "Operator.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RANGE.sol and Operator.sol",
                "Type": "Inconsistant parameter requirements",
                "Description": "Inconsistant parameter requirements between constructor() and Set() functions in RANGE.sol and Operator.sol.",
                "Repair": "Add same validation for the parameters between constructor() and Set() functions"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\n\nimport \"./mocks/KernelTestMocks.sol\";\nimport \"src/Kernel.sol\";\n\ncontract KernelTest is Test {\n    Kernel internal kernel;\n    MockPolicy internal policy;\n    MockModule internal MOCKY;\n\n    address public deployer;\n    address public multisig;\n    address public user;\n    UserFactory public userFactory;\n\n    bytes public err;\n    MockPolicy internal policyTest;\n\n    function setUp() public {\n        userFactory = new UserFactory();\n        address[] memory users = userFactory.create(3);\n        deployer = users[0];\n        multisig = users[1];\n        user = users[2];\n\n        vm.startPrank(deployer);\n        kernel = new Kernel();\n        MOCKY = new MockModule(kernel);\n        policy = new MockPolicy(kernel);\n\n        vm.stopPrank();\n    }\n\n    function testCorrectness_InitializeKernel() public {\n        Keycode keycode = Keycode.wrap(0);\n\n        assertEq(kernel.admin(), deployer);\n        assertEq(kernel.executor(), deployer);\n        assertEq(kernel.modulePermissions(keycode, policy, bytes4(0)), false);\n        assertEq(address(kernel.getModuleForKeycode(keycode)), address(0));\n        assertEq(Keycode.unwrap(kernel.getKeycodeForModule(MOCKY)), bytes5(0));\n\n        // Ensure actions cannot be performed by unauthorized addresses\n        err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"executor\"), address(deployer));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"executor\"), address(deployer));\n        //kernel.revokeRole(deployer);\n    }\n\n    function testCorrectness_EnsureContract() public {\n        ensureContract(address(kernel));\n\n        err = abi.encodeWithSignature(\"TargetNotAContract(address)\", address(deployer));\n        vm.expectRevert(err);\n        ensureContract(deployer);\n\n        err = abi.encodeWithSignature(\"TargetNotAContract(address)\", address(0));\n        vm.expectRevert(err);\n        ensureContract(address(0));\n    }\n\n    function testCorrectness_EnsureValidKeycode() public {\n        ensureValidKeycode(Keycode.wrap(\"VALID\"));\n\n        err = abi.encodeWithSignature(\"InvalidKeycode(bytes5)\", Keycode.wrap(\"inval\"));\n        vm.expectRevert(err);\n        ensureValidKeycode(Keycode.wrap(\"inval\"));\n\n        err = abi.encodeWithSignature(\"InvalidKeycode(bytes5)\", Keycode.wrap(\"\"));\n        vm.expectRevert(err);\n        ensureValidKeycode(Keycode.wrap(bytes5(\"\")));\n    }\n\n    function testCorrectness_EnsureValidRole() public {\n        ensureValidRole(Role.wrap(\"valid\"));\n\n        err = abi.encodeWithSignature(\"InvalidRole(bytes32)\", Role.wrap(\"INVALID_ID\"));\n        vm.expectRevert(err);\n        ensureValidRole(Role.wrap(bytes32(\"INVALID_ID\")));\n    }\n\n    function testCorrectness_GrantRole() public {\n        // Ensure role doesn't exist yet\n        assertFalse(kernel.isRole(Role.wrap(\"tester\")));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n\n        vm.prank(deployer);\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n        assertTrue(kernel.isRole(Role.wrap(\"tester\")));\n        assertTrue(kernel.hasRole(multisig, Role.wrap(\"tester\")));\n    }\n\n    function testCorrectness_RevokeRole() public {\n        Role testerRole = toRole(\"tester\");\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.revokeRole(testerRole, deployer);\n\n        // TODO test role not existing\n\n        vm.startPrank(deployer);\n        kernel.grantRole(testerRole, multisig);\n        assertTrue(kernel.hasRole(multisig, testerRole));\n\n        kernel.revokeRole(testerRole, multisig);\n        assertFalse(kernel.hasRole(multisig, testerRole));\n\n        err = abi.encodeWithSelector(Kernel_AddressDoesNotHaveRole.selector, multisig, testerRole);\n        vm.expectRevert(err);\n        kernel.revokeRole(testerRole, multisig);\n    }\n\n    function testCorrectness_InitializeModule() public {\n        assertEq(Keycode.unwrap(MOCKY.KEYCODE()), \"MOCKY\");\n        assertEq(MOCKY.publicState(), 0);\n        assertEq(MOCKY.permissionedState(), 0);\n    }\n\n    function testCorrectness_InstallModule() public {\n        vm.startPrank(deployer);\n\n        // Ensure module is installed properly\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n        assertEq(address(kernel.getModuleForKeycode(Keycode.wrap(\"MOCKY\"))), address(MOCKY));\n        assertEq(Keycode.unwrap(kernel.getKeycodeForModule(MOCKY)), \"MOCKY\");\n\n        // Try installing an EOA as a module\n        err = abi.encodeWithSignature(\"TargetNotAContract(address)\", deployer);\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, deployer);\n\n        // Try installing module with a bad keycode\n        Module invalidModule = new InvalidMockModule(kernel);\n        err = abi.encodeWithSignature(\"InvalidKeycode(bytes5)\", Keycode.wrap(\"badkc\"));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, address(invalidModule));\n\n        // Try installing MOCKY again\n        err = abi.encodeWithSignature(\n            \"Kernel_ModuleAlreadyInstalled(bytes5)\",\n            Keycode.wrap(\"MOCKY\")\n        );\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n\n        vm.stopPrank();\n    }\n\n    function testCorrectness_ActivatePolicy() public {\n        Keycode testKeycode = Keycode.wrap(\"MOCKY\");\n\n        vm.prank(deployer);\n        err = abi.encodeWithSignature(\"Policy_ModuleDoesNotExist(bytes5)\", testKeycode);\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        _initModuleAndPolicy();\n\n        assertEq(\n            kernel.modulePermissions(testKeycode, policy, MOCKY.permissionedCall.selector),\n            true\n        );\n        assertEq(address(kernel.activePolicies(0)), address(policy));\n\n        uint256 depIndex = kernel.getDependentIndex(testKeycode, policy);\n        Policy[] memory dependencies = new Policy[](1);\n        dependencies[0] = policy;\n        assertEq(address(kernel.moduleDependents(testKeycode, depIndex)), address(dependencies[0]));\n\n        vm.prank(deployer);\n        err = abi.encodeWithSignature(\"Kernel_PolicyAlreadyActivated(address)\", address(policy));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n    }\n\n    function testCorrectness_PolicyPermissions() public {\n        _initModuleAndPolicy();\n        Permissions[] memory permissions = policy.requestPermissions();\n\n        assertEq(Keycode.unwrap(permissions[0].keycode), \"MOCKY\");\n        assertEq(permissions[0].funcSelector, MOCKY.permissionedCall.selector);\n    }\n\n    function testCorrectness_CallPublicPolicyFunction() public {\n        _initModuleAndPolicy();\n\n        vm.prank(deployer);\n        policy.callPublicFunction();\n\n        assertEq(MOCKY.publicState(), 1);\n    }\n\n    function testCorrectness_CallPermissionedPolicyFunction() public {\n        _initModuleAndPolicy();\n\n        // Test role-based auth for policy calls\n        Role testerRole = Role.wrap(\"tester\");\n\n        vm.startPrank(deployer);\n\n        err = abi.encodeWithSignature(\"Policy_OnlyRole(bytes32)\", testerRole);\n        vm.expectRevert(err);\n        policy.callPermissionedFunction();\n\n        kernel.grantRole(testerRole, multisig);\n\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        policy.callPermissionedFunction();\n        assertEq(MOCKY.permissionedState(), 1);\n\n        vm.prank(deployer);\n        kernel.revokeRole(testerRole, multisig);\n\n        vm.prank(multisig);\n        err = abi.encodeWithSignature(\"Policy_OnlyRole(bytes32)\", testerRole);\n        vm.expectRevert(err);\n        policy.callPermissionedFunction();\n    }\n\n    function testCorrectness_DeactivatePolicy() public {\n        vm.startPrank(deployer);\n\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n\n        err = abi.encodeWithSignature(\"Kernel_PolicyAlreadyActivated(address)\", address(policy));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        kernel.executeAction(Actions.DeactivatePolicy, address(policy));\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        err = abi.encodeWithSignature(\"Module_PolicyNotPermitted(address)\", address(policy));\n        vm.expectRevert(err);\n        policy.callPermissionedFunction();\n\n        assertEq(\n            kernel.modulePermissions(\n                Keycode.wrap(\"MOCKY\"),\n                policy,\n                MOCKY.permissionedCall.selector\n            ),\n            false\n        );\n        vm.expectRevert();\n        assertEq(address(kernel.activePolicies(0)), address(0));\n    }\n\n    function testCorrectness_UpgradeModule() public {\n        UpgradedMockModule upgradedModule = new UpgradedMockModule(kernel, MOCKY);\n\n        vm.startPrank(deployer);\n\n        err = abi.encodeWithSignature(\"Kernel_InvalidModuleUpgrade(bytes5)\", Keycode.wrap(\"MOCKY\"));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.UpgradeModule, address(upgradedModule));\n\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n\n        err = abi.encodeWithSignature(\"Kernel_InvalidModuleUpgrade(bytes5)\", Keycode.wrap(\"MOCKY\"));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.UpgradeModule, address(MOCKY));\n\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        policy.callPermissionedFunction();\n\n        assertEq(MOCKY.permissionedState(), 1);\n\n        // Upgrade MOCKY\n        vm.prank(deployer);\n        kernel.executeAction(Actions.UpgradeModule, address(upgradedModule));\n\n        // check state is reset\n        assertEq(upgradedModule.permissionedState(), 1);\n\n        // check if permissions persist\n        vm.prank(multisig);\n        policy.callPermissionedFunction();\n\n        assertEq(upgradedModule.permissionedState(), 2);\n    }\n\n    function testCorrectness_ChangeExecutor() public {\n        vm.startPrank(deployer);\n        kernel.executeAction(Actions.ChangeExecutor, address(multisig));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", deployer);\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ChangeExecutor, address(deployer));\n\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        kernel.executeAction(Actions.ChangeExecutor, address(deployer));\n\n        vm.startPrank(deployer);\n        kernel.executeAction(Actions.ChangeExecutor, address(multisig));\n    }\n\n    function testCorrectness_ChangeAdmin() public {\n        err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ChangeAdmin, address(multisig));\n\n        vm.startPrank(deployer);\n\n        {\n            kernel.executeAction(Actions.InstallModule, address(MOCKY));\n            kernel.executeAction(Actions.ActivatePolicy, address(policy));\n            kernel.executeAction(Actions.ChangeAdmin, address(multisig));\n            vm.stopPrank();\n        }\n\n        vm.prank(multisig);\n\n        kernel.grantRole(Role.wrap(\"tester\"), user);\n        vm.prank(user);\n        policy.callPermissionedFunction();\n\n        vm.prank(deployer);\n        kernel.executeAction(Actions.ChangeAdmin, address(user));\n\n        vm.startPrank(multisig);\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", multisig);\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n        vm.stopPrank();\n\n        vm.prank(user);\n        kernel.revokeRole(Role.wrap(\"tester\"), user);\n        assertFalse(kernel.hasRole(user, Role.wrap(\"tester\")));\n\n        err = abi.encodeWithSignature(\"Policy_OnlyRole(bytes32)\", Role.wrap(\"tester\"));\n        vm.expectRevert(err);\n        vm.prank(user);\n        policy.callPermissionedFunction();\n    }\n\n    function testCorrectness_MigrateKernel() public {\n        _initModuleAndPolicy();\n\n        assertEq(address(kernel.getModuleForKeycode(kernel.allKeycodes(0))), address(MOCKY));\n        assertEq(address(kernel.activePolicies(0)), address(policy));\n\n        vm.startPrank(deployer);\n\n        // Create new kernel and migrate to it\n        Kernel newKernel = new Kernel();\n\n        kernel.executeAction(Actions.MigrateKernel, address(newKernel));\n\n        assertEq(address(MOCKY.kernel()), address(newKernel));\n        assertEq(address(policy.kernel()), address(newKernel));\n\n        // Install module and approve policy\n        newKernel.executeAction(Actions.InstallModule, address(MOCKY));\n        newKernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        assertEq(address(newKernel.getModuleForKeycode(newKernel.allKeycodes(0))), address(MOCKY));\n        assertEq(address(newKernel.activePolicies(0)), address(policy));\n    }\n\n    function _initModuleAndPolicy() internal {\n        vm.startPrank(deployer);\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n        vm.stopPrank();\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/utils/KernelUtils.sol\";\n\n// Kernel Adapter errors\nerror KernelAdapter_OnlyKernel(address caller_);\n\n// Module errors\nerror Module_PolicyNotPermitted(address policy_);\n\n// Policy errors\nerror Policy_OnlyRole(Role role_);\nerror Policy_ModuleDoesNotExist(Keycode keycode_);\n\n// Kernel errors\nerror Kernel_OnlyExecutor(address caller_);\nerror Kernel_OnlyAdmin(address caller_);\nerror Kernel_ModuleAlreadyInstalled(Keycode module_);\nerror Kernel_InvalidModuleUpgrade(Keycode module_);\nerror Kernel_PolicyAlreadyActivated(address policy_);\nerror Kernel_PolicyNotActivated(address policy_);\nerror Kernel_AddressAlreadyHasRole(address addr_, Role role_);\nerror Kernel_AddressDoesNotHaveRole(address addr_, Role role_);\nerror Kernel_RoleDoesNotExist(Role role_);\n\n/*//////////////////////////////////////////////////////////////\n                          GLOBAL TYPES\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\nenum Actions {\n    InstallModule,\n    UpgradeModule,\n    ActivatePolicy,\n    DeactivatePolicy,\n    ChangeExecutor,\n    ChangeAdmin,\n    MigrateKernel\n}\n\n/// @notice Used by executor to select an action and a target contract for a kernel action\nstruct Instruction {\n    Actions action;\n    address target;\n}\n\n/// @notice Used to define which module functions a policy needs access to\nstruct Permissions {\n    Keycode keycode;\n    bytes4 funcSelector;\n}\n\ntype Keycode is bytes5;\ntype Role is bytes32;\n\n/*//////////////////////////////////////////////////////////////\n                      COMPONENT ABSTRACTS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Generic adapter interface for kernel access in modules and policies.\nabstract contract KernelAdapter {\n    Kernel public kernel;\n\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /// @notice Modifier to restrict functions to be called only by kernel.\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /// @notice Function used by kernel when migrating to a new kernel.\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\n///         interacted with and mutated through policies.\n/// @dev    Modules are installed and uninstalled via the executor.\nabstract contract Module is KernelAdapter {\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict which policies have access to module functions.\n    modifier permissioned() {\n        if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig))\n            revert Module_PolicyNotPermitted(msg.sender);\n        _;\n    }\n\n    /// @notice 5 byte identifier for a module.\n    function KEYCODE() public pure virtual returns (Keycode) {}\n\n    /// @notice Returns which semantic version of a module is being implemented.\n    /// @return major - Major version upgrade indicates breaking change to the interface.\n    /// @return minor - Minor version change retains backward-compatible interface.\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /// @notice Initialization function for the module\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\n    function INIT() external virtual onlyKernel {}\n}\n\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\nabstract contract Policy is KernelAdapter {\n    /// @notice Denote if a policy is activated or not.\n    bool public isActive;\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict policy function access to certain addresses with a role.\n    /// @dev    Roles are defined in the policy and set by the kernel admin.\n    modifier onlyRole(bytes32 role_) {\n        Role role = toRole(role_);\n        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);\n        _;\n    }\n\n    /// @notice Function to let kernel grant or revoke active status.\n    function setActiveStatus(bool activate_) external onlyKernel {\n        isActive = activate_;\n    }\n\n    /// @notice Function to grab module address from a given keycode.\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /// @notice Define module dependencies for this policy.\n    /// @return dependencies - Keycode array of module dependencies.\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\n\n    /// @notice Function called by kernel to set module function permissions.\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\n}\n\n/// @notice Main contract that acts as a central component registry for the protocol.\n/// @dev    The kernel manages modules, policies and defined roles. The kernel is mutated via predefined Actions,\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\ncontract Kernel {\n    /*//////////////////////////////////////////////////////////////\n                          PRIVILEGED ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\n    address public executor;\n\n    /// @notice Address that is responsible for assigning policy-defined roles to addresses.\n    address public admin;\n\n    /*//////////////////////////////////////////////////////////////\n                           MODULE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Array of all modules currently installed.\n    Keycode[] public allKeycodes;\n\n    /// @notice Mapping of module address to keycode.\n    mapping(Keycode => Module) public getModuleForKeycode;\n\n    /// @notice Mapping of keycode to module address.\n    mapping(Module => Keycode) public getKeycodeForModule;\n\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    /// @notice Module <> Policy Permissions.\n    /// @dev    Policy -> Keycode -> Function Selector -> bool for permission\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\n\n    /*//////////////////////////////////////////////////////////////\n                           POLICY MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of all active policies\n    Policy[] public activePolicies;\n\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    /// @notice Mapping for if an address has a policy-defined role.\n    mapping(address => mapping(Role => bool)) public hasRole;\n\n    /// @notice Mapping for if role exists.\n    mapping(Role => bool) public isRole;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PermissionsUpdated(\n        Keycode indexed keycode_,\n        Policy indexed policy_,\n        bytes4 funcSelector_,\n        bool granted_\n    );\n    event RoleGranted(Role indexed role_, address indexed addr_);\n    event RoleRevoked(Role indexed role_, address indexed addr_);\n    event ActionExecuted(Actions indexed action_, address indexed target_);\n\n    /*//////////////////////////////////////////////////////////////\n                              KERNEL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        executor = msg.sender;\n        admin = msg.sender;\n    }\n\n    /// @notice Modifier to check if caller is the executor.\n    modifier onlyExecutor() {\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n        _;\n    }\n\n    /// @notice Modifier to check if caller is the roles admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);\n        _;\n    }\n\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\n    function executeAction(Actions action_, address target_) external onlyExecutor {\n        if (action_ == Actions.InstallModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _installModule(Module(target_));\n        } else if (action_ == Actions.UpgradeModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _upgradeModule(Module(target_));\n        } else if (action_ == Actions.ActivatePolicy) {\n            ensureContract(target_);\n            _activatePolicy(Policy(target_));\n        } else if (action_ == Actions.DeactivatePolicy) {\n            ensureContract(target_);\n            _deactivatePolicy(Policy(target_));\n        } else if (action_ == Actions.ChangeExecutor) {\n            executor = target_;\n        } else if (action_ == Actions.ChangeAdmin) {\n            admin = target_;\n        } else if (action_ == Actions.MigrateKernel) {\n            ensureContract(target_);\n            _migrateKernel(Kernel(target_));\n        }\n\n        emit ActionExecuted(action_, target_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ACTIONS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _installModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n\n        if (address(getModuleForKeycode[keycode]) != address(0))\n            revert Kernel_ModuleAlreadyInstalled(keycode);\n\n        getModuleForKeycode[keycode] = newModule_;\n        getKeycodeForModule[newModule_] = keycode;\n        allKeycodes.push(keycode);\n\n        newModule_.INIT();\n    }\n\n    function _upgradeModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n        Module oldModule = getModuleForKeycode[keycode];\n\n        if (address(oldModule) == address(0) || oldModule == newModule_)\n            revert Kernel_InvalidModuleUpgrade(keycode);\n\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n        getKeycodeForModule[newModule_] = keycode;\n        getModuleForKeycode[keycode] = newModule_;\n\n        newModule_.INIT();\n\n        _reconfigurePolicies(keycode);\n    }\n\n    function _activatePolicy(Policy policy_) internal {\n        if (policy_.isActive()) revert Kernel_PolicyAlreadyActivated(address(policy_));\n\n        // Add policy to list of active policies\n        activePolicies.push(policy_);\n        getPolicyIndex[policy_] = activePolicies.length - 1;\n\n        // Record module dependencies\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depLength = dependencies.length;\n\n        for (uint256 i; i < depLength; ) {\n            Keycode keycode = dependencies[i];\n\n            moduleDependents[keycode].push(policy_);\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Grant permissions for policy to access restricted module functions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, true);\n\n        // Set policy status to active\n        policy_.setActiveStatus(true);\n    }\n\n    function _deactivatePolicy(Policy policy_) internal {\n        if (!policy_.isActive()) revert Kernel_PolicyNotActivated(address(policy_));\n\n        // Revoke permissions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, false);\n\n        // Remove policy from all policy data structures\n        uint256 idx = getPolicyIndex[policy_];\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\n\n        activePolicies[idx] = lastPolicy;\n        activePolicies.pop();\n        getPolicyIndex[lastPolicy] = idx;\n        delete getPolicyIndex[policy_];\n\n        // Remove policy from module dependents\n        _pruneFromDependents(policy_);\n\n        // Set policy status to inactive\n        policy_.setActiveStatus(false);\n    }\n\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\n    /// @dev    NOTE: Data does not get cleared from this kernel.\n    function _migrateKernel(Kernel newKernel_) internal {\n        uint256 keycodeLen = allKeycodes.length;\n        for (uint256 i; i < keycodeLen; ) {\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n            module.changeKernel(newKernel_);\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 policiesLen = activePolicies.length;\n        for (uint256 j; j < policiesLen; ) {\n            Policy policy = activePolicies[j];\n\n            // Deactivate before changing kernel\n            policy.setActiveStatus(false);\n            policy.changeKernel(newKernel_);\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _reconfigurePolicies(Keycode keycode_) internal {\n        Policy[] memory dependents = moduleDependents[keycode_];\n        uint256 depLength = dependents.length;\n\n        for (uint256 i; i < depLength; ) {\n            dependents[i].configureDependencies();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _setPolicyPermissions(\n        Policy policy_,\n        Permissions[] memory requests_,\n        bool grant_\n    ) internal {\n        uint256 reqLength = requests_.length;\n        for (uint256 i = 0; i < reqLength; ) {\n            Permissions memory request = requests_[i];\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _pruneFromDependents(Policy policy_) internal {\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depcLength = dependencies.length;\n\n        for (uint256 i; i < depcLength; ) {\n            Keycode keycode = dependencies[i];\n            Policy[] storage dependents = moduleDependents[keycode];\n\n            uint256 origIndex = getDependentIndex[keycode][policy_];\n            Policy lastPolicy = dependents[dependents.length - 1];\n\n            // Swap with last and pop\n            dependents[origIndex] = lastPolicy;\n            dependents.pop();\n\n            // Record new index and delete deactivated policy index\n            getDependentIndex[keycode][lastPolicy] = origIndex;\n            delete getDependentIndex[keycode][policy_];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ROLES ADMIN FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function to grant policy-defined roles to some address. Can only be called by admin.\n    function grantRole(Role role_, address addr_) public onlyAdmin {\n        if (hasRole[addr_][role_]) revert Kernel_AddressAlreadyHasRole(addr_, role_);\n\n        ensureValidRole(role_);\n        if (!isRole[role_]) isRole[role_] = true;\n\n        hasRole[addr_][role_] = true;\n\n        emit RoleGranted(role_, addr_);\n    }\n\n    /// @notice Function to revoke policy-defined roles from some address. Can only be called by admin.\n    function revokeRole(Role role_, address addr_) public onlyAdmin {\n        if (!isRole[role_]) revert Kernel_RoleDoesNotExist(role_);\n        if (!hasRole[addr_][role_]) revert Kernel_AddressDoesNotHaveRole(addr_, role_);\n\n        hasRole[addr_][role_] = false;\n\n        emit RoleRevoked(role_, addr_);\n    }\n}\n\n\n",
        "CodeNames": [
            "Kernel.t.sol",
            "Kernel.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Kernel._deactivatePolicy",
                "Type": "Missing checks",
                "Description": "Missing checks in Kernel._deactivatePolicy.",
                "Repair": "Add a check to ascertain that the policy being removed is registered in the Kernel"
            },
            {
                "Location": "Kernel.sol line 296",
                "Type": "Activating same Policy multiple times in Kernel possible",
                "Description": "It is possible to activate the same policy multiple times for the same Kernel, breaking uniqueness invariants and potentially leading to a DoS attack.",
                "Repair": "Check getPolicyIndex[policy_] != 0 instead of relying on a value of an untrusted contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\n\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n/// @title  Olympus Range Operator\n/// @notice Olympus Range Operator (Policy) Contract\n/// @dev    The Olympus Range Operator performs market operations to enforce OlympusDAO's OHM price range\n///         guidance policies against a specific reserve asset. The Operator is maintained by a keeper-triggered\n///         function on the Olympus Heart contract, which orchestrates state updates in the correct order to ensure\n///         market operations use up to date information. When the price of OHM against the reserve asset exceeds\n///         the cushion spread, the Operator deploys bond markets to support the price. The Operator also offers\n///         zero slippage swaps at prices dictated by the wall spread from the moving average. These market operations\n///         are performed up to a specific capacity before the market must stabilize to regenerate the capacity.\ncontract Operator is IOperator, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS =========== */\n\n    error Operator_InvalidParams();\n    error Operator_InsufficientCapacity();\n    error Operator_AmountLessThanMinimum(uint256 amountOut, uint256 minAmountOut);\n    error Operator_WallDown();\n    error Operator_AlreadyInitialized();\n    error Operator_NotInitialized();\n    error Operator_Inactive();\n\n    /* ========== EVENTS =========== */\n    event Swap(\n        ERC20 indexed tokenIn_,\n        ERC20 indexed tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOut_\n    );\n    event CushionFactorChanged(uint32 cushionFactor_);\n    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);\n    event ReserveFactorChanged(uint32 reserveFactor_);\n    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// Operator variables, defined in the interface on the external getter functions\n    Status internal _status;\n    Config internal _config;\n\n    /// @notice    Whether the Operator has been initialized\n    bool public initialized;\n\n    /// @notice    Whether the Operator is active\n    bool public active;\n\n    /// Modules\n    OlympusPrice internal PRICE;\n    OlympusRange internal RANGE;\n    OlympusTreasury internal TRSRY;\n    OlympusMinter internal MINTR;\n\n    /// External contracts\n    /// @notice     Auctioneer contract used for cushion bond market deployments\n    IBondAuctioneer public auctioneer;\n    /// @notice     Callback contract used for cushion bond market payouts\n    IBondCallback public callback;\n\n    /// Tokens\n    /// @notice     OHM token contract\n    ERC20 public immutable ohm;\n    uint8 public immutable ohmDecimals;\n    /// @notice     Reserve token contract\n    ERC20 public immutable reserve;\n    uint8 public immutable reserveDecimals;\n\n    /// Constants\n    uint32 public constant FACTOR_SCALE = 1e4;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        Kernel kernel_,\n        IBondAuctioneer auctioneer_,\n        IBondCallback callback_,\n        ERC20[2] memory tokens_, // [ohm, reserve]\n        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]\n    ) Policy(kernel_) {\n        /// Check params are valid\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n\n        if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))\n            revert Operator_InvalidParams();\n\n        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();\n\n        if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])\n            revert Operator_InvalidParams();\n\n        if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();\n\n        if (\n            configParams[5] < 1 hours ||\n            configParams[6] > configParams[7] ||\n            configParams[7] == uint32(0)\n        ) revert Operator_InvalidParams();\n\n        auctioneer = auctioneer_;\n        callback = callback_;\n        ohm = tokens_[0];\n        ohmDecimals = tokens_[0].decimals();\n        reserve = tokens_[1];\n        reserveDecimals = tokens_[1].decimals();\n\n        Regen memory regen = Regen({\n            count: uint32(0),\n            lastRegen: uint48(block.timestamp),\n            nextObservation: uint32(0),\n            observations: new bool[](configParams[7])\n        });\n\n        _config = Config({\n            cushionFactor: configParams[0],\n            cushionDuration: configParams[1],\n            cushionDebtBuffer: configParams[2],\n            cushionDepositInterval: configParams[3],\n            reserveFactor: configParams[4],\n            regenWait: configParams[5],\n            regenThreshold: configParams[6],\n            regenObserve: configParams[7]\n        });\n\n        _status = Status({low: regen, high: regen});\n\n        emit CushionFactorChanged(configParams[0]);\n        emit CushionParamsChanged(configParams[1], configParams[2], configParams[3]);\n        emit ReserveFactorChanged(configParams[4]);\n        emit RegenParamsChanged(configParams[5], configParams[6], configParams[7]);\n    }\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"PRICE\");\n        dependencies[1] = toKeycode(\"RANGE\");\n        dependencies[2] = toKeycode(\"TRSRY\");\n        dependencies[3] = toKeycode(\"MINTR\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n        RANGE = OlympusRange(getModuleAddress(dependencies[1]));\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[2]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\n\n        /// Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](9);\n        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    modifier onlyWhileActive() {\n        if (!active) revert Operator_Inactive();\n        _;\n    }\n\n    /* ========== HEART FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function operate() external override onlyWhileActive onlyRole(\"operator_operate\") {\n        /// Revert if not initialized\n        if (!initialized) revert Operator_NotInitialized();\n\n        /// Update the prices for the range, save new regen observations, and update capacities based on bond market activity\n        _updateRangePrices();\n        _addObservation();\n        _updateCapacity(true, 0);\n        _updateCapacity(false, 0);\n\n        /// Cache config in memory\n        Config memory config_ = _config;\n\n        /// Check if walls can regenerate capacity\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\n            _status.high.count >= config_.regenThreshold\n        ) {\n            _regenerate(true);\n        }\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\n            _status.low.count >= config_.regenThreshold\n        ) {\n            _regenerate(false);\n        }\n\n        /// Cache range data after potential regeneration\n        OlympusRange.Range memory range = RANGE.range();\n\n        /// Get latest price\n        /// See note in addObservation() for more details\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Check if the cushion bond markets are active\n        /// if so, determine if it should stay open or close\n        /// if not, check if a new one should be opened\n        if (range.low.active) {\n            if (auctioneer.isLive(range.low.market)) {\n                /// if active, check if the price is back above the cushion\n                /// or if the price is below the wall\n                /// if so, close the market\n                if (currentPrice > range.cushion.low.price || currentPrice < range.wall.low.price) {\n                    _deactivate(false);\n                }\n            } else {\n                /// if not active, check if the price is below the cushion\n                /// if so, open a new bond market\n                if (currentPrice < range.cushion.low.price && currentPrice > range.wall.low.price) {\n                    _activate(false);\n                }\n            }\n        }\n        if (range.high.active) {\n            if (auctioneer.isLive(range.high.market)) {\n                /// if active, check if the price is back under the cushion\n                /// or if the price is above the wall\n                /// if so, close the market\n                if (\n                    currentPrice < range.cushion.high.price || currentPrice > range.wall.high.price\n                ) {\n                    _deactivate(true);\n                }\n            } else {\n                /// if not active, check if the price is above the cushion\n                /// if so, open a new bond market\n                if (\n                    currentPrice > range.cushion.high.price && currentPrice < range.wall.high.price\n                ) {\n                    _activate(true);\n                }\n            }\n        }\n    }\n\n    /* ========== OPEN MARKET OPERATIONS (WALL) ========== */\n    /// @inheritdoc IOperator\n    function swap(\n        ERC20 tokenIn_,\n        uint256 amountIn_,\n        uint256 minAmountOut_\n    ) external override onlyWhileActive nonReentrant returns (uint256 amountOut) {\n        if (tokenIn_ == ohm) {\n            /// Revert if lower wall is inactive\n            if (!RANGE.active(false)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(false, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(false);\n\n            /// Transfer OHM from sender\n            ohm.safeTransferFrom(msg.sender, address(this), amountIn_);\n\n            /// Burn OHM\n            MINTR.burnOhm(address(this), amountIn_);\n\n            /// Withdraw and transfer reserve to sender\n            TRSRY.withdrawReserves(msg.sender, reserve, amountOut);\n\n            emit Swap(ohm, reserve, amountIn_, amountOut);\n        } else if (tokenIn_ == reserve) {\n            /// Revert if upper wall is inactive\n            if (!RANGE.active(true)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(true, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(true);\n\n            /// Transfer reserves to treasury\n            reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n\n            /// Mint OHM to sender\n            MINTR.mintOhm(msg.sender, amountOut);\n\n            emit Swap(reserve, ohm, amountIn_, amountOut);\n        } else {\n            revert Operator_InvalidParams();\n        }\n    }\n\n    /* ========== BOND MARKET OPERATIONS (CUSHION) ========== */\n    /// @notice             Records a bond purchase and updates capacity correctly\n    /// @notice             Access restricted (BondCallback)\n    /// @param id_          ID of the bond market\n    /// @param amountOut_   Amount of capacity expended\n    function bondPurchase(uint256 id_, uint256 amountOut_)\n        external\n        onlyWhileActive\n        onlyRole(\"operator_reporter\")\n    {\n        if (id_ == RANGE.market(true)) {\n            _updateCapacity(true, amountOut_);\n            _checkCushion(true);\n        }\n        if (id_ == RANGE.market(false)) {\n            _updateCapacity(false, amountOut_);\n            _checkCushion(false);\n        }\n    }\n\n    /// @notice      Activate a cushion by deploying a bond market\n    /// @param high_ Whether the cushion is for the high or low side of the range (true = high, false = low)\n    function _activate(bool high_) internal {\n        OlympusRange.Range memory range = RANGE.range();\n\n        if (high_) {\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecimals = _getPriceDecimals(range.cushion.high.price);\n            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\n\n            /// Calculate oracle scale and bond scale with scale adjustment and format prices for bond market\n            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\n            uint256 bondScale = 10 **\n                uint8(\n                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\n                );\n\n            uint256 initialPrice = range.wall.high.price.mulDiv(bondScale, oracleScale);\n            uint256 minimumPrice = range.cushion.high.price.mulDiv(bondScale, oracleScale);\n\n            /// Cache config struct to avoid multiple SLOADs\n            Config memory config_ = _config;\n\n            /// Calculate market capacity from the cushion factor\n            uint256 marketCapacity = range.high.capacity.mulDiv(\n                config_.cushionFactor,\n                FACTOR_SCALE\n            );\n\n            /// Create new bond market to buy the reserve with OHM\n            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\n                payoutToken: ohm,\n                quoteToken: reserve,\n                callbackAddr: address(callback),\n                capacityInQuote: false,\n                capacity: marketCapacity,\n                formattedInitialPrice: initialPrice,\n                formattedMinimumPrice: minimumPrice,\n                debtBuffer: config_.cushionDebtBuffer,\n                vesting: uint48(0), // Instant swaps\n                conclusion: uint48(block.timestamp + config_.cushionDuration),\n                depositInterval: config_.cushionDepositInterval,\n                scaleAdjustment: scaleAdjustment\n            });\n\n            uint256 market = auctioneer.createMarket(params);\n\n            /// Whitelist the bond market on the callback\n            callback.whitelist(address(auctioneer.getTeller()), market);\n\n            /// Update the market information on the range module\n            RANGE.updateMarket(true, market, marketCapacity);\n        } else {\n            /// Calculate inverse prices from the oracle feed for the low side\n            uint8 oracleDecimals = PRICE.decimals();\n            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;\n            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\n\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecimals = _getPriceDecimals(invCushionPrice);\n            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\n\n            /// Calculate oracle scale and bond scale with scale adjustment and format prices for bond market\n            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\n            uint256 bondScale = 10 **\n                uint8(\n                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\n                );\n\n            uint256 initialPrice = invWallPrice.mulDiv(bondScale, oracleScale);\n            uint256 minimumPrice = invCushionPrice.mulDiv(bondScale, oracleScale);\n\n            /// Cache config struct to avoid multiple SLOADs\n            Config memory config_ = _config;\n\n            /// Calculate market capacity from the cushion factor\n            uint256 marketCapacity = range.low.capacity.mulDiv(config_.cushionFactor, FACTOR_SCALE);\n\n            /// Create new bond market to buy OHM with the reserve\n            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\n                payoutToken: reserve,\n                quoteToken: ohm,\n                callbackAddr: address(callback),\n                capacityInQuote: false,\n                capacity: marketCapacity,\n                formattedInitialPrice: initialPrice,\n                formattedMinimumPrice: minimumPrice,\n                debtBuffer: config_.cushionDebtBuffer,\n                vesting: uint48(0), // Instant swaps\n                conclusion: uint48(block.timestamp + config_.cushionDuration),\n                depositInterval: config_.cushionDepositInterval,\n                scaleAdjustment: scaleAdjustment\n            });\n\n            uint256 market = auctioneer.createMarket(params);\n\n            /// Whitelist the bond market on the callback\n            callback.whitelist(address(auctioneer.getTeller()), market);\n\n            /// Update the market information on the range module\n            RANGE.updateMarket(false, market, marketCapacity);\n        }\n    }\n\n    /// @notice      Deactivate a cushion by closing a bond market (if it is active)\n    /// @param high_ Whether the cushion is for the high or low side of the range (true = high, false = low)\n    function _deactivate(bool high_) internal {\n        uint256 market = RANGE.market(high_);\n        if (auctioneer.isLive(market)) {\n            auctioneer.closeMarket(market);\n            RANGE.updateMarket(high_, type(uint256).max, 0);\n        }\n    }\n\n    /// @notice         Helper function to calculate number of price decimals based on the value returned from the price feed.\n    /// @param price_   The price to calculate the number of decimals for\n    /// @return         The number of decimals\n    function _getPriceDecimals(uint256 price_) internal view returns (int8) {\n        int8 decimals;\n        while (price_ >= 10) {\n            price_ = price_ / 10;\n            decimals++;\n        }\n\n        /// Subtract the stated decimals from the calculated decimals to get the relative price decimals.\n        /// Required to do it this way vs. normalizing at the beginning since price decimals can be negative.\n        return decimals - int8(PRICE.decimals());\n    }\n\n    /* ========== OPERATOR CONFIGURATION ========== */\n    /// @inheritdoc IOperator\n    function setSpreads(uint256 cushionSpread_, uint256 wallSpread_)\n        external\n        onlyRole(\"operator_policy\")\n    {\n        /// Set spreads on the range module\n        RANGE.setSpreads(cushionSpread_, wallSpread_);\n\n        /// Update range prices (wall and cushion)\n        _updateRangePrices();\n    }\n\n    /// @inheritdoc IOperator\n    function setThresholdFactor(uint256 thresholdFactor_) external onlyRole(\"operator_policy\") {\n        /// Set threshold factor on the range module\n        RANGE.setThresholdFactor(thresholdFactor_);\n    }\n\n    /// @inheritdoc IOperator\n    function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {\n        /// Confirm factor is within allowed values\n        if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\n\n        /// Set factor\n        _config.cushionFactor = cushionFactor_;\n\n        emit CushionFactorChanged(cushionFactor_);\n    }\n\n    /// @inheritdoc IOperator\n    function setCushionParams(\n        uint32 duration_,\n        uint32 debtBuffer_,\n        uint32 depositInterval_\n    ) external onlyRole(\"operator_policy\") {\n        /// Confirm values are valid\n        if (duration_ > uint256(7 days) || duration_ < uint256(1 days))\n            revert Operator_InvalidParams();\n        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();\n        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)\n            revert Operator_InvalidParams();\n\n        /// Update values\n        _config.cushionDuration = duration_;\n        _config.cushionDebtBuffer = debtBuffer_;\n        _config.cushionDepositInterval = depositInterval_;\n\n        emit CushionParamsChanged(duration_, debtBuffer_, depositInterval_);\n    }\n\n    /// @inheritdoc IOperator\n    function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") {\n        /// Confirm factor is within allowed values\n        if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();\n\n        /// Set factor\n        _config.reserveFactor = reserveFactor_;\n\n        emit ReserveFactorChanged(reserveFactor_);\n    }\n\n    /// @inheritdoc IOperator\n    function setRegenParams(\n        uint32 wait_,\n        uint32 threshold_,\n        uint32 observe_\n    ) external onlyRole(\"operator_policy\") {\n        /// Confirm regen parameters are within allowed values\n        if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0)\n            revert Operator_InvalidParams();\n\n        /// Set regen params\n        _config.regenWait = wait_;\n        _config.regenThreshold = threshold_;\n        _config.regenObserve = observe_;\n\n        /// Re-initialize regen structs with new values (except for last regen)\n        _status.high.count = 0;\n        _status.high.nextObservation = 0;\n        _status.high.observations = new bool[](observe_);\n\n        _status.low.count = 0;\n        _status.low.nextObservation = 0;\n        _status.low.observations = new bool[](observe_);\n\n        emit RegenParamsChanged(wait_, threshold_, observe_);\n    }\n\n    /// @inheritdoc IOperator\n    function setBondContracts(IBondAuctioneer auctioneer_, IBondCallback callback_)\n        external\n        onlyRole(\"operator_admin\")\n    {\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n        /// Set contracts\n        auctioneer = auctioneer_;\n        callback = callback_;\n    }\n\n    /// @inheritdoc IOperator\n    function initialize() external onlyRole(\"operator_admin\") {\n        /// Can only call once\n        if (initialized) revert Operator_AlreadyInitialized();\n\n        /// Request approval for reserves from TRSRY\n        TRSRY.setApprovalFor(address(this), reserve, type(uint256).max);\n\n        /// Update range prices (wall and cushion)\n        _updateRangePrices();\n\n        /// Regenerate sides\n        _regenerate(true);\n        _regenerate(false);\n\n        /// Set initialized and active flags\n        initialized = true;\n        active = true;\n    }\n\n    /// @inheritdoc IOperator\n    function regenerate(bool high_) external onlyRole(\"operator_admin\") {\n        /// Regenerate side\n        _regenerate(high_);\n    }\n\n    /// @inheritdoc IOperator\n    function toggleActive() external onlyRole(\"operator_admin\") {\n        /// Toggle active state\n        active = !active;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /// @notice          Update the capacity on the RANGE module.\n    /// @param high_     Whether to update the high side or low side capacity (true = high, false = low).\n    /// @param reduceBy_ The amount to reduce the capacity by (OHM tokens for high side, Reserve tokens for low side).\n    function _updateCapacity(bool high_, uint256 reduceBy_) internal {\n        /// Initialize update variables, decrement capacity if a reduceBy amount is provided\n        uint256 capacity = RANGE.capacity(high_) - reduceBy_;\n\n        /// Update capacities on the range module for the wall and market\n        RANGE.updateCapacity(high_, capacity);\n    }\n\n    /// @notice Update the prices on the RANGE module\n    function _updateRangePrices() internal {\n        /// Get latest moving average from the price module\n        uint256 movingAverage = PRICE.getMovingAverage();\n\n        /// Update the prices on the range module\n        RANGE.updatePrices(movingAverage);\n    }\n\n    /// @notice Add an observation to the regeneration status variables for each side\n    function _addObservation() internal {\n        /// Get latest moving average from the price module\n        uint256 movingAverage = PRICE.getMovingAverage();\n\n        /// Get latest price\n        /// TODO determine if this should use the last price from the MA or recalculate the current price, ideally last price is ok since it should have been just updated and should include check against secondary?\n        /// Current price is guaranteed to be up to date, but may be a bad value if not checked?\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Store observations and update counts for regeneration\n\n        /// Update low side regen status with a new observation\n        /// Observation is positive if the current price is greater than the MA\n        uint32 observe = _config.regenObserve;\n        Regen memory regen = _status.low;\n        if (currentPrice >= movingAverage) {\n            if (!regen.observations[regen.nextObservation]) {\n                _status.low.observations[regen.nextObservation] = true;\n                _status.low.count++;\n            }\n        } else {\n            if (regen.observations[regen.nextObservation]) {\n                _status.low.observations[regen.nextObservation] = false;\n                _status.low.count--;\n            }\n        }\n        _status.low.nextObservation = (regen.nextObservation + 1) % observe;\n\n        /// Update high side regen status with a new observation\n        /// Observation is positive if the current price is less than the MA\n        regen = _status.high;\n        if (currentPrice <= movingAverage) {\n            if (!regen.observations[regen.nextObservation]) {\n                _status.high.observations[regen.nextObservation] = true;\n                _status.high.count++;\n            }\n        } else {\n            if (regen.observations[regen.nextObservation]) {\n                _status.high.observations[regen.nextObservation] = false;\n                _status.high.count--;\n            }\n        }\n        _status.high.nextObservation = (regen.nextObservation + 1) % observe;\n    }\n\n    /// @notice      Regenerate the wall for a side\n    /// @param high_ Whether to regenerate the high side or low side (true = high, false = low)\n    function _regenerate(bool high_) internal {\n        /// Deactivate cushion if active on the side being regenerated\n        _deactivate(high_);\n\n        if (high_) {\n            /// Reset the regeneration data for the side\n            _status.high.count = uint32(0);\n            _status.high.observations = new bool[](_config.regenObserve);\n            _status.high.nextObservation = uint32(0);\n            _status.high.lastRegen = uint48(block.timestamp);\n\n            /// Calculate capacity\n            uint256 capacity = fullCapacity(true);\n\n            /// Regenerate the side with the capacity\n            RANGE.regenerate(true, capacity);\n        } else {\n            /// Reset the regeneration data for the side\n            _status.low.count = uint32(0);\n            _status.low.observations = new bool[](_config.regenObserve);\n            _status.low.nextObservation = uint32(0);\n            _status.low.lastRegen = uint48(block.timestamp);\n\n            /// Calculate capacity\n            uint256 capacity = fullCapacity(false);\n\n            /// Regenerate the side with the capacity\n            RANGE.regenerate(false, capacity);\n        }\n    }\n\n    /// @notice      Takes down cushions (if active) when a wall is taken down or if available capacity drops below cushion capacity\n    /// @param high_ Whether to check the high side or low side cushion (true = high, false = low)\n    function _checkCushion(bool high_) internal {\n        /// Check if the wall is down, if so ensure the cushion is also down\n        /// Additionally, if wall is not down, but the wall capacity has dropped below the cushion capacity, take the cushion down\n        bool sideActive = RANGE.active(high_);\n        uint256 market = RANGE.market(high_);\n        if (\n            !sideActive ||\n            (sideActive &&\n                auctioneer.isLive(market) &&\n                RANGE.capacity(high_) < auctioneer.currentCapacity(market))\n        ) {\n            _deactivate(high_);\n        }\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function getAmountOut(ERC20 tokenIn_, uint256 amountIn_) public view returns (uint256) {\n        if (tokenIn_ == ohm) {\n            /// Calculate amount out\n            uint256 amountOut = amountIn_.mulDiv(\n                10**reserveDecimals * RANGE.price(true, false),\n                10**ohmDecimals * 10**PRICE.decimals()\n            );\n\n            /// Revert if amount out exceeds capacity\n            if (amountOut > RANGE.capacity(false)) revert Operator_InsufficientCapacity();\n\n            return amountOut;\n        } else if (tokenIn_ == reserve) {\n            /// Calculate amount out\n            uint256 amountOut = amountIn_.mulDiv(\n                10**ohmDecimals * 10**PRICE.decimals(),\n                10**reserveDecimals * RANGE.price(true, true)\n            );\n\n            /// Revert if amount out exceeds capacity\n            if (amountOut > RANGE.capacity(true)) revert Operator_InsufficientCapacity();\n\n            return amountOut;\n        } else {\n            revert Operator_InvalidParams();\n        }\n    }\n\n    /// @inheritdoc IOperator\n    function fullCapacity(bool high_) public view override returns (uint256) {\n        uint256 reservesInTreasury = TRSRY.getReserveBalance(reserve);\n        uint256 capacity = (reservesInTreasury * _config.reserveFactor) / FACTOR_SCALE;\n        if (high_) {\n            capacity =\n                (capacity.mulDiv(\n                    10**ohmDecimals * 10**PRICE.decimals(),\n                    10**reserveDecimals * RANGE.price(true, true)\n                ) * (FACTOR_SCALE + RANGE.spread(true) * 2)) /\n                FACTOR_SCALE;\n        }\n        return capacity;\n    }\n\n    /// @inheritdoc IOperator\n    function status() external view override returns (Status memory) {\n        return _status;\n    }\n\n    /// @inheritdoc IOperator\n    function config() external view override returns (Config memory) {\n        return _config;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\n\nimport {BondFixedTermCDA} from \"test/lib/bonds/BondFixedTermCDA.sol\";\nimport {BondAggregator} from \"test/lib/bonds/BondAggregator.sol\";\nimport {BondFixedTermTeller} from \"test/lib/bonds/BondFixedTermTeller.sol\";\nimport {RolesAuthority, Authority as SolmateAuthority} from \"solmate/auth/authorities/RolesAuthority.sol\";\n\nimport {MockERC20, ERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport {MockPrice} from \"test/mocks/MockPrice.sol\";\n\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondAggregator} from \"interfaces/IBondAggregator.sol\";\n\nimport {FullMath} from \"libraries/FullMath.sol\";\n\nimport \"src/Kernel.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter, OHM} from \"modules/MINTR.sol\";\n\nimport {Operator} from \"policies/Operator.sol\";\nimport {BondCallback} from \"policies/BondCallback.sol\";\n\ncontract MockOhm is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burnFrom(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n\n// solhint-disable-next-line max-states-count\ncontract OperatorTest is Test {\n    using FullMath for uint256;\n\n    UserFactory public userCreator;\n    address internal alice;\n    address internal bob;\n    address internal guardian;\n    address internal policy;\n    address internal heart;\n\n    RolesAuthority internal auth;\n    BondAggregator internal aggregator;\n    BondFixedTermTeller internal teller;\n    BondFixedTermCDA internal auctioneer;\n    MockOhm internal ohm;\n    MockERC20 internal reserve;\n\n    Kernel internal kernel;\n    MockPrice internal price;\n    OlympusRange internal range;\n    OlympusTreasury internal treasury;\n    OlympusMinter internal minter;\n\n    Operator internal operator;\n    BondCallback internal callback;\n\n    function setUp() public {\n        vm.warp(51 * 365 * 24 * 60 * 60); // Set timestamp at roughly Jan 1, 2021 (51 years since Unix epoch)\n        userCreator = new UserFactory();\n        {\n            /// Deploy bond system to test against\n            address[] memory users = userCreator.create(5);\n            alice = users[0];\n            bob = users[1];\n            guardian = users[2];\n            policy = users[3];\n            heart = users[4];\n            auth = new RolesAuthority(guardian, SolmateAuthority(address(0)));\n\n            /// Deploy the bond system\n            aggregator = new BondAggregator(guardian, auth);\n            teller = new BondFixedTermTeller(guardian, aggregator, guardian, auth);\n            auctioneer = new BondFixedTermCDA(teller, aggregator, guardian, auth);\n\n            /// Register auctioneer on the bond system\n            vm.prank(guardian);\n            aggregator.registerAuctioneer(auctioneer);\n        }\n\n        {\n            /// Deploy mock tokens\n            ohm = new MockOhm(\"Olympus\", \"OHM\", 9);\n            reserve = new MockERC20(\"Reserve\", \"RSV\", 18);\n        }\n\n        {\n            /// Deploy kernel\n            kernel = new Kernel(); // this contract will be the executor\n\n            /// Deploy modules (some mocks)\n            price = new MockPrice(kernel, uint48(8 hours));\n            range = new OlympusRange(\n                kernel,\n                [ERC20(ohm), ERC20(reserve)],\n                [uint256(100), uint256(1000), uint256(2000)]\n            );\n            treasury = new OlympusTreasury(kernel);\n            minter = new OlympusMinter(kernel, address(ohm));\n\n            /// Configure mocks\n            price.setMovingAverage(100 * 1e18);\n            price.setLastPrice(100 * 1e18);\n            price.setDecimals(18);\n        }\n\n        {\n            /// Deploy bond callback\n            callback = new BondCallback(kernel, IBondAggregator(address(aggregator)), ohm);\n\n            /// Deploy operator\n            operator = new Operator(\n                kernel,\n                IBondAuctioneer(address(auctioneer)),\n                callback,\n                [ERC20(ohm), ERC20(reserve)],\n                [\n                    uint32(2000), // cushionFactor\n                    uint32(5 days), // duration\n                    uint32(100_000), // debtBuffer\n                    uint32(1 hours), // depositInterval\n                    uint32(1000), // reserveFactor\n                    uint32(1 hours), // regenWait\n                    uint32(5), // regenThreshold\n                    uint32(7) // regenObserve\n                ]\n            );\n\n            /// Registor operator to create bond markets with a callback\n            vm.prank(guardian);\n            auctioneer.setCallbackAuthStatus(address(operator), true);\n        }\n\n        {\n            /// Initialize system and kernel\n\n            /// Install modules\n            kernel.executeAction(Actions.InstallModule, address(price));\n            kernel.executeAction(Actions.InstallModule, address(range));\n            kernel.executeAction(Actions.InstallModule, address(treasury));\n            kernel.executeAction(Actions.InstallModule, address(minter));\n\n            /// Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(operator));\n            kernel.executeAction(Actions.ActivatePolicy, address(callback));\n        }\n        {\n            /// Configure access control\n\n            /// Operator roles\n            kernel.grantRole(toRole(\"operator_operate\"), address(heart));\n            kernel.grantRole(toRole(\"operator_operate\"), guardian);\n            kernel.grantRole(toRole(\"operator_reporter\"), address(callback));\n            kernel.grantRole(toRole(\"operator_policy\"), policy);\n            kernel.grantRole(toRole(\"operator_admin\"), guardian);\n\n            /// Bond callback roles\n            kernel.grantRole(toRole(\"callback_whitelist\"), address(operator));\n            kernel.grantRole(toRole(\"callback_whitelist\"), guardian);\n            kernel.grantRole(toRole(\"callback_admin\"), guardian);\n        }\n\n        /// Set operator on the callback\n        vm.prank(guardian);\n        callback.setOperator(operator);\n\n        // Mint tokens to users and treasury for testing\n        uint256 testOhm = 1_000_000 * 1e9;\n        uint256 testReserve = 1_000_000 * 1e18;\n\n        ohm.mint(alice, testOhm * 20);\n        reserve.mint(alice, testReserve * 20);\n\n        reserve.mint(address(treasury), testReserve * 100);\n\n        // Approve the operator and bond teller for the tokens to swap\n        vm.prank(alice);\n        ohm.approve(address(operator), testOhm * 20);\n        vm.prank(alice);\n        reserve.approve(address(operator), testReserve * 20);\n\n        vm.prank(alice);\n        ohm.approve(address(teller), testOhm * 20);\n        vm.prank(alice);\n        reserve.approve(address(teller), testReserve * 20);\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n    function knockDownWall(bool high_) internal returns (uint256 amountIn, uint256 amountOut) {\n        if (high_) {\n            /// Get current capacity of the high wall\n            /// Set amount in to put capacity 1 below the threshold for shutting down the wall\n            uint256 startCapacity = range.capacity(true);\n            uint256 highWallPrice = range.price(true, true);\n            amountIn = startCapacity.mulDiv(highWallPrice, 1e9).mulDiv(9999, 10000) + 1;\n\n            uint256 expAmountOut = operator.getAmountOut(reserve, amountIn);\n\n            /// Swap at the high wall\n            vm.prank(alice);\n            amountOut = operator.swap(reserve, amountIn, expAmountOut);\n        } else {\n            /// Get current capacity of the low wall\n            /// Set amount in to put capacity 1 below the threshold for shutting down the wall\n            uint256 startCapacity = range.capacity(false);\n            uint256 lowWallPrice = range.price(true, false);\n            amountIn = startCapacity.mulDiv(1e9, lowWallPrice).mulDiv(9999, 10000) + 1;\n\n            uint256 expAmountOut = operator.getAmountOut(ohm, amountIn);\n\n            /// Swap at the low wall\n            vm.prank(alice);\n            amountOut = operator.swap(ohm, amountIn, expAmountOut);\n        }\n    }\n\n    /* ========== WALL TESTS ========== */\n\n    /// DONE\n    /// [X] Able to swap when walls are up\n    /// [X] Splippage check when swapping\n    /// [X] Wall breaks when capacity drops below the configured threshold\n    /// [X] Not able to swap at the walls when they are down\n\n    function testCorrectness_swapHighWall() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get current capacity of the high wall and starting balance for user\n        uint256 startCapacity = range.capacity(true);\n        uint256 amountIn = 100 * 1e18;\n        uint256 ohmBalance = ohm.balanceOf(alice);\n        uint256 reserveBalance = reserve.balanceOf(alice);\n\n        /// Calculate expected difference\n        uint256 highWallPrice = range.price(true, true);\n        uint256 expAmountOut = amountIn.mulDiv(1e9 * 1e18, 1e18 * highWallPrice);\n\n        /// Swap at the high wall\n        vm.prank(alice);\n        uint256 amountOut = operator.swap(reserve, amountIn, expAmountOut);\n\n        /// Get updated capacity of the high wall\n        uint256 endCapacity = range.capacity(true);\n\n        assertEq(amountOut, expAmountOut);\n        assertEq(endCapacity, startCapacity - amountOut);\n        assertEq(ohm.balanceOf(alice), ohmBalance + amountOut);\n        assertEq(reserve.balanceOf(alice), reserveBalance - amountIn);\n    }\n\n    function testCorrectness_swapLowWall() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get current capacity of the high wall and starting balance for user\n        uint256 startCapacity = range.capacity(false);\n        uint256 amountIn = 100 * 1e9;\n        uint256 ohmBalance = ohm.balanceOf(alice);\n        uint256 reserveBalance = reserve.balanceOf(alice);\n\n        /// Calculate expected difference\n        uint256 lowWallPrice = range.price(true, false);\n        uint256 expAmountOut = amountIn.mulDiv(1e18 * lowWallPrice, 1e9 * 1e18);\n\n        /// Swap at the high wall\n        vm.prank(alice);\n        uint256 amountOut = operator.swap(ohm, amountIn, expAmountOut);\n\n        /// Get updated capacity of the high wall\n        uint256 endCapacity = range.capacity(false);\n\n        assertEq(amountOut, expAmountOut);\n        assertEq(endCapacity, startCapacity - amountOut);\n        assertEq(ohm.balanceOf(alice), ohmBalance - amountIn);\n        assertEq(reserve.balanceOf(alice), reserveBalance + amountOut);\n    }\n\n    function testCorrectness_highWallBreaksAtThreshold() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Get initial balances and capacity\n        uint256 ohmBalance = ohm.balanceOf(alice);\n        uint256 reserveBalance = reserve.balanceOf(alice);\n        uint256 startCapacity = range.capacity(true);\n\n        /// Take down wall with helper function\n        (uint256 amountIn, uint256 amountOut) = knockDownWall(true);\n\n        /// Get updated capacity of the high wall\n        uint256 endCapacity = range.capacity(true);\n\n        /// Confirm the wall is down\n        assertTrue(!range.active(true));\n\n        /// Check that capacity and balances are correct\n        assertEq(endCapacity, startCapacity - amountOut);\n        assertEq(ohm.balanceOf(alice), ohmBalance + amountOut);\n        assertEq(reserve.balanceOf(alice), reserveBalance - amountIn);\n    }\n\n    function testCorrectness_lowWallBreaksAtThreshold() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Get initial balances and capacity\n        uint256 ohmBalance = ohm.balanceOf(alice);\n        uint256 reserveBalance = reserve.balanceOf(alice);\n        uint256 startCapacity = range.capacity(false);\n\n        /// Take down wall with helper function\n        (uint256 amountIn, uint256 amountOut) = knockDownWall(false);\n\n        /// Get updated capacity of the high wall\n        uint256 endCapacity = range.capacity(false);\n\n        /// Confirm the wall is down\n        assertTrue(!range.active(false));\n\n        /// Check that capacity and balances are correct\n        assertEq(endCapacity, startCapacity - amountOut);\n        assertEq(ohm.balanceOf(alice), ohmBalance - amountIn);\n        assertEq(reserve.balanceOf(alice), reserveBalance + amountOut);\n    }\n\n    function testCorrectness_cannotSwapHighWallWhenDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down wall with helper function\n        knockDownWall(true);\n\n        /// Try to swap, expect to fail\n        uint256 amountIn = 100 * 1e18;\n        uint256 expAmountOut = amountIn.mulDiv(1e9 * 1e18, 1e18 * range.price(true, true));\n\n        bytes memory err = abi.encodeWithSignature(\"Operator_WallDown()\");\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(reserve, amountIn, expAmountOut);\n    }\n\n    function testCorrectness_cannotSwapLowWallWhenDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down wall with helper function\n        knockDownWall(false);\n\n        /// Try to swap, expect to fail\n        uint256 amountIn = 100 * 1e9;\n        uint256 expAmountOut = amountIn.mulDiv(1e18 * range.price(true, false), 1e9 * 1e18);\n\n        bytes memory err = abi.encodeWithSignature(\"Operator_WallDown()\");\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(ohm, amountIn, expAmountOut);\n    }\n\n    function testCorrectness_swapRevertsOnSlippage() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm walls are up\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n\n        /// Set amounts for high wall swap with minAmountOut greater than expAmountOut\n        uint256 amountIn = 100 * 1e18;\n        uint256 expAmountOut = amountIn.mulDiv(1e9 * 1e18, 1e18 * range.price(true, true));\n        uint256 minAmountOut = expAmountOut + 1;\n\n        /// Try to swap at low wall, expect to fail\n        bytes memory err = abi.encodeWithSignature(\n            \"Operator_AmountLessThanMinimum(uint256,uint256)\",\n            expAmountOut,\n            minAmountOut\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(reserve, amountIn, minAmountOut);\n\n        /// Set amounts for low wall swap with minAmountOut greater than expAmountOut\n        amountIn = 100 * 1e9;\n        expAmountOut = amountIn.mulDiv(1e18 * range.price(true, false), 1e9 * 1e18);\n        minAmountOut = expAmountOut + 1;\n\n        /// Try to swap at low wall, expect to fail\n        err = abi.encodeWithSignature(\n            \"Operator_AmountLessThanMinimum(uint256,uint256)\",\n            expAmountOut,\n            minAmountOut\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(ohm, amountIn, minAmountOut);\n    }\n\n    function testCorrectness_swapRevertsWithInvalidToken() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm walls are up\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n\n        /// Try to swap with invalid token, expect to fail\n        uint256 amountIn = 100 * 1e18;\n        uint256 minAmountOut = 100 * 1e18;\n        ERC20 token = ERC20(bob);\n\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(token, amountIn, minAmountOut);\n    }\n\n    /* ========== CUSHION TESTS ========== */\n\n    /// DONE\n    /// [X] Cushions deployed when price set in the range and operate triggered\n    /// [X] Cushions deactivated when price out of range and operate triggered or when wall goes down\n    /// [X] Cushion doesn't deploy when wall is down\n    /// [X] Bond purchases update capacity\n\n    function testCorrectness_highCushionDeployedInSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        uint256 marketId = range.market(true);\n        assertTrue(auctioneer.isLive(marketId));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(marketId);\n        // console2.log(\"capacity\", marketCapacity);\n        assertEq(marketCapacity, range.capacity(true).mulDiv(config.cushionFactor, 1e4));\n\n        /// Check that the price is set correctly\n        // (, , , , , , , , , , , uint256 scale) = auctioneer.markets(marketId);\n        // uint256 price = auctioneer.marketPrice(marketId);\n        // console2.log(\"price\", price);\n        // console2.log(\"scale\", scale);\n        uint256 payout = auctioneer.payoutFor(120 * 1e18, marketId, alice);\n        assertEq(payout, 1e9);\n    }\n\n    function testCorrectness_highCushionClosedBelowSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        assertTrue(auctioneer.isLive(range.market(true)));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(range.market(true));\n        assertEq(marketCapacity, range.capacity(true).mulDiv(config.cushionFactor, 1e4));\n\n        /// Set price on mock oracle below the high cushion\n        price.setLastPrice(105 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        marketCapacity = auctioneer.currentCapacity(range.market(true));\n        assertEq(marketCapacity, 0);\n    }\n\n    function testCorrectness_highCushionClosedAboveSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        assertTrue(auctioneer.isLive(range.market(true)));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(range.market(true));\n        assertEq(marketCapacity, range.capacity(true).mulDiv(config.cushionFactor, 1e4));\n\n        /// Set price on mock oracle below the high cushion\n        price.setLastPrice(130 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        marketCapacity = auctioneer.currentCapacity(range.market(true));\n        assertEq(marketCapacity, 0);\n    }\n\n    function testCorrectness_highCushionClosedWhenWallDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        assertTrue(auctioneer.isLive(range.market(true)));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n    }\n\n    function testCorrectness_highCushionNotDeployedWhenWallDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Set price on mock oracle into the low cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n    }\n\n    function testCorrectness_lowCushionDeployedInSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        uint256 marketId = range.market(false);\n        assertTrue(auctioneer.isLive(marketId));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(marketId);\n        assertEq(marketCapacity, range.capacity(false).mulDiv(config.cushionFactor, 1e4));\n\n        /// Check that the price is set correctly\n        // (, , , , , , , , , , , uint256 scale) = auctioneer.markets(marketId);\n        // uint256 price = auctioneer.marketPrice(marketId);\n        // console2.log(\"price\", price);\n        // console2.log(\"scale\", scale);\n        uint256 payout = auctioneer.payoutFor(1e9, marketId, alice);\n        assertEq(payout, 80 * 1e18);\n    }\n\n    function testCorrectness_lowCushionClosedBelowSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        assertTrue(auctioneer.isLive(range.market(false)));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(range.market(false));\n        assertEq(marketCapacity, range.capacity(false).mulDiv(config.cushionFactor, 1e4));\n\n        /// Set price on mock oracle below the high cushion\n        price.setLastPrice(79 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        marketCapacity = auctioneer.currentCapacity(range.market(false));\n        assertEq(marketCapacity, 0);\n    }\n\n    function testCorrectness_lowCushionClosedAboveSpread() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed and capacity is set to the correct amount\n        assertTrue(auctioneer.isLive(range.market(false)));\n\n        Operator.Config memory config = operator.config();\n        uint256 marketCapacity = auctioneer.currentCapacity(range.market(false));\n        assertEq(marketCapacity, range.capacity(false).mulDiv(config.cushionFactor, 1e4));\n\n        /// Set price on mock oracle below the high cushion\n        price.setLastPrice(91 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        marketCapacity = auctioneer.currentCapacity(range.market(false));\n        assertEq(marketCapacity, 0);\n    }\n\n    function testCorrectness_lowCushionClosedWhenWallDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Set price on mock oracle into the low cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        assertTrue(auctioneer.isLive(range.market(false)));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the cushion is closed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n    }\n\n    function testCorrectness_lowCushionNotDeployedWhenWallDown() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Set price on mock oracle into the low cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n    }\n\n    function test_marketClosesAsExpected1() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Assert high wall is up\n        assertTrue(range.active(true));\n\n        /// Set price below the moving average to almost regenerate high wall\n        price.setLastPrice(99 * 1e18);\n\n        /// Trigger the operator function enough times to almost regenerate the high wall\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Ensure market not live yet\n        uint256 currentMarket = range.market(true);\n        assertEq(type(uint256).max, currentMarket);\n\n        /// Cause price to spike to trigger high cushion\n        uint256 cushionPrice = range.price(false, true);\n        price.setLastPrice(cushionPrice + 500);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check market is live\n        currentMarket = range.market(true);\n        assertTrue(type(uint256).max != currentMarket);\n        assertTrue(auctioneer.isLive(currentMarket));\n\n        /// Cause price to go back down to moving average\n        /// Move time forward past the regen period to trigger high wall regeneration\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Will trigger regeneration of high wall\n        /// Will set the operator market on high side to type(uint256).max\n        /// However, the prior market will still be live when it's supposed to be deactivated\n        price.setLastPrice(95 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n        /// Get latest market\n        uint256 newMarket = range.market(true);\n\n        /// Check market has been updated to non existent market\n        assertTrue(type(uint256).max == newMarket);\n        /// And, the previous market is closed\n        assertTrue(!auctioneer.isLive(currentMarket));\n    }\n\n    function test_marketClosesAsExpected2() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Assert high wall is up\n        assertTrue(range.active(true));\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Get current market\n        uint256 currentMarket = range.market(true);\n\n        /// Check market has been updated and is live\n        assertTrue(type(uint256).max != currentMarket);\n        assertTrue(auctioneer.isLive(currentMarket));\n\n        /// Take down wall\n        knockDownWall(true);\n\n        /// Get latest market\n        uint256 newMarket = range.market(true);\n\n        /// Check market has been updated to non existent market\n        assertTrue(type(uint256).max == newMarket);\n        /// And the previous market is closed\n        assertTrue(!auctioneer.isLive(currentMarket));\n    }\n\n    function testCorrectness_highCushionPurchasesReduceCapacity() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get the start capacity of the high side\n        uint256 startCapacity = range.capacity(true);\n\n        /// Set price on mock oracle into the high cushion\n        price.setLastPrice(111 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        uint256 id = range.market(true);\n        assertTrue(auctioneer.isLive(id));\n\n        /// Set amount to purchase from cushion (which will be at wall price initially)\n        uint256 amountIn = auctioneer.maxAmountAccepted(id, guardian) / 2;\n        uint256 minAmountOut = auctioneer.payoutFor(amountIn, id, guardian);\n\n        /// Purchase from cushion\n        vm.prank(alice);\n        (uint256 payout, ) = teller.purchase(alice, guardian, id, amountIn, minAmountOut);\n\n        /// Check that the side capacity has been reduced by the amount of the payout\n        assertEq(range.capacity(true), startCapacity - payout);\n    }\n\n    function testCorrectness_lowCushionPurchasesReduceCapacity() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get the start capacity of the low side\n        uint256 startCapacity = range.capacity(false);\n\n        /// Set price on mock oracle into the low cushion\n        price.setLastPrice(89 * 1e18);\n\n        /// Trigger the operate function manually\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        uint256 id = range.market(false);\n        assertTrue(auctioneer.isLive(id));\n\n        /// Set amount to purchase from cushion (which will be at wall price initially)\n        uint256 amountIn = auctioneer.maxAmountAccepted(id, guardian) / 2;\n        uint256 minAmountOut = auctioneer.payoutFor(amountIn, id, guardian);\n\n        /// Purchase from cushion\n        vm.prank(alice);\n        (uint256 payout, ) = teller.purchase(alice, guardian, id, amountIn, minAmountOut);\n\n        /// Check that the side capacity has been reduced by the amount of the payout\n        assertEq(range.capacity(false), startCapacity - payout);\n    }\n\n    /* ========== REGENERATION TESTS ========== */\n\n    /// DONE\n    /// [X] Wall regenerates when price on other side of MA for enough observations\n    /// [X] Wrap around logic works for counting observations\n    /// [X] Regen period enforces a minimum time to wait for regeneration\n\n    function testCorrectness_lowWallRegenA() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests the simplest case of regen\n        /// Takes down wall, moves price in regen range,\n        /// and hits regen count required with consequtive calls\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is up\n        assertTrue(range.active(false));\n\n        /// Check that the capacity has regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, fullCapacity);\n    }\n\n    function testCorrectness_lowWallRegenB() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests wrap around logic of regen\n        /// Takes down wall, calls operate a few times with price not in regen range,\n        /// moves price into regen range, and hits regen count required with consequtive calls\n        /// that wrap around the count array\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average so regeneration doesn't start\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator function with negative\n        for (uint256 i; i < 8; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(false));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is up\n        assertTrue(range.active(false));\n\n        /// Check that the capacity has regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, fullCapacity);\n    }\n\n    function testCorrectness_lowWallRegenC() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that wall does not regenerate before the required count is reached\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(false));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_lowWallRegenD() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that wall does not regenerate before the required count is reached\n        /// Use more complex logic to ensure wrap around logic is working and\n        /// that positive checks outside the moving window aren't counted\n        /// observations should be: +, -, -, -, +, +, +, +\n        /// last observation wraps around to first and therefore only 4/7 of the observations are counted\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator once to get a positive check\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Set price below the moving average to get negative checks\n        price.setLastPrice(99 * 1e18);\n\n        /// Trigger the operator function several times with negative checks\n        for (uint256 i; i < 3; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function several times with positive checks\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(false));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_lowWallRegenTime() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that the wall won't regenerate before the required time has passed,\n        /// even with enough observations\n        /// Takes down wall, moves price in regen range,\n        /// and hits regen count required with consequtive calls\n\n        /// Confirm wall is up\n        assertTrue(range.active(false));\n\n        /// Take down the wall\n        knockDownWall(false);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(false));\n\n        /// Don't move time forward past the regen period so it won't regen\n\n        /// Get capacity of the low wall and verify under threshold\n        uint256 startCapacity = range.capacity(false);\n        uint256 fullCapacity = operator.fullCapacity(false);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average to regenerate low wall\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(false));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(false);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_lowCushionClosedOnRegen() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that a manually regenerated wall will close the cushion that is deployed currently\n\n        /// Trigger a cushion\n        price.setLastPrice(89 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        assertTrue(auctioneer.isLive(range.market(false)));\n        assertEq(range.market(false), 0);\n\n        /// Regenerate the wall manually, expect market to close\n        vm.prank(guardian);\n        operator.regenerate(false);\n\n        /// Check that the market is closed\n        assertTrue(!auctioneer.isLive(range.market(false)));\n        assertEq(range.market(false), type(uint256).max);\n    }\n\n    function testCorrectness_highWallRegenA() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests the simplest case of regen\n        /// Takes down wall, moves price in regen range,\n        /// and hits regen count required with consequtive calls\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(99 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is up\n        assertTrue(range.active(true));\n\n        /// Check that the capacity has regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, fullCapacity);\n    }\n\n    function testCorrectness_highWallRegenB() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests wrap around logic of regen\n        /// Takes down wall, calls operate a few times with price not in regen range,\n        /// moves price into regen range, and hits regen count required with consequtive calls\n        /// that wrap around the count array\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price above the moving average so regeneration doesn't start\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function with negative\n        for (uint256 i; i < 8; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(true));\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is up\n        assertTrue(range.active(true));\n\n        /// Check that the capacity has regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, fullCapacity);\n    }\n\n    function testCorrectness_highWallRegenC() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that wall does not regenerate before the required count is reached\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(true));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_highWallRegenD() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that wall does not regenerate before the required count is reached\n        /// Use more complex logic to ensure wrap around logic is working and\n        /// that positive checks outside the moving window aren't counted\n        /// observations should be: +, -, -, -, +, +, +, +\n        /// last observation wraps around to first and therefore only 4/7 of the observations are counted\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Move time forward past the regen period\n        vm.warp(block.timestamp + 1 hours);\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average to regenerate low wall\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator once to get a positive check\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Set price above the moving average to get negative checks\n        price.setLastPrice(101 * 1e18);\n\n        /// Trigger the operator function several times with negative checks\n        for (uint256 i; i < 3; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(98 * 1e18);\n\n        /// Trigger the operator function several times with positive checks\n        for (uint256 i; i < 4; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(true));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_highWallRegenTime() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that the wall won't regenerate before the required time has passed,\n        /// even with enough observations\n        /// Takes down wall, moves price in regen range,\n        /// and hits regen count required with consequtive calls\n\n        /// Confirm wall is up\n        assertTrue(range.active(true));\n\n        /// Take down the wall\n        knockDownWall(true);\n\n        /// Check that the wall is down\n        assertTrue(!range.active(true));\n\n        /// Don't move time forward past the regen period so it won't regen\n\n        /// Get capacity of the high wall and verify under threshold\n        uint256 startCapacity = range.capacity(true);\n        uint256 fullCapacity = operator.fullCapacity(true);\n        assertLe(startCapacity, fullCapacity.mulDiv(range.thresholdFactor(), 1e4));\n\n        /// Set price below the moving average to regenerate high wall\n        price.setLastPrice(99 * 1e18);\n\n        /// Trigger the operator function enough times to regenerate the wall\n        for (uint256 i; i < 5; ++i) {\n            vm.prank(guardian);\n            operator.operate();\n        }\n\n        /// Check that the wall is still down\n        assertTrue(!range.active(true));\n\n        /// Check that the capacity hasn't regenerated\n        uint256 endCapacity = range.capacity(true);\n        assertEq(endCapacity, startCapacity);\n    }\n\n    function testCorrectness_highCushionClosedOnRegen() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Tests that a manually regenerated wall will close the cushion that is deployed currently\n\n        /// Trigger a cushion\n        price.setLastPrice(111 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the cushion is deployed\n        assertTrue(auctioneer.isLive(range.market(true)));\n        assertEq(range.market(true), 0);\n\n        /// Regenerate the wall manually, expect market to close\n        vm.prank(guardian);\n        operator.regenerate(true);\n\n        /// Check that the market is closed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n        assertEq(range.market(true), type(uint256).max);\n    }\n\n    /* ========== ACCESS CONTROL TESTS ========== */\n\n    /// DONE\n    /// [X] operate only callable by heart or guardian\n    /// [X] admin configuration functions only callable by policy or guardian (negative here, positive in ADMIN TESTS sections)\n\n    function testCorrectness_onlyHeartOrGovernanceCanOperate() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Call operate as heart contract\n        vm.prank(heart);\n        operator.operate();\n\n        /// Call operate as governance\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Try to call operate as anyone else\n        bytes memory err = abi.encodeWithSelector(\n            Policy_OnlyRole.selector,\n            toRole(\"operator_operate\")\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.operate();\n    }\n\n    function testCorrectness_cannotOperatorIfNotInitialized() public {\n        /// Toggle operator to active manually erroneously (so it will not revert with inactive)\n        vm.prank(guardian);\n        operator.toggleActive();\n\n        /// Call operate as heart contract and expect to revert\n        bytes memory err = abi.encodeWithSignature(\"Operator_NotInitialized()\");\n        vm.expectRevert(err);\n        vm.prank(heart);\n        operator.operate();\n    }\n\n    function testCorrectness_nonPolicyCannotSetConfig() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Try to set spreads as random user, expect revert\n        bytes memory err = abi.encodeWithSelector(\n            Policy_OnlyRole.selector,\n            toRole(\"operator_policy\")\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setSpreads(1500, 3000);\n\n        /// Try to set cushionFactor as random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setCushionFactor(1500);\n\n        /// Try to set cushionDuration as random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setCushionParams(uint32(6 hours), uint32(50_000), uint32(4 hours));\n\n        /// Try to set cushionFactor as random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setReserveFactor(1500);\n\n        /// Try to set regenParams as a random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setRegenParams(uint32(1 days), uint32(8), uint32(11));\n    }\n\n    function testCorrectness_nonGuardianCannotCall() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Try to set spreads as random user, expect revert\n        bytes memory err = abi.encodeWithSelector(\n            Policy_OnlyRole.selector,\n            toRole(\"operator_admin\")\n        );\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.setBondContracts(IBondAuctioneer(alice), BondCallback(alice));\n\n        /// Try to initialize as a random user, expect revert\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.initialize();\n    }\n\n    /* ========== ADMIN TESTS ========== */\n\n    /// DONE\n    /// [X] setSpreads\n    /// [X] setThresholdFactor (in Range.t.sol) TODO\n    /// [X] setCushionFactor\n    /// [X] setCushionParams\n    /// [X] setReserveFactor\n    /// [X] setRegenParams\n    /// [X] setBondContracts\n    /// [X] initialize\n\n    function testCorrectness_setSpreads() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting bands\n        OlympusRange.Range memory startRange = range.range();\n\n        /// Set spreads larger as admin\n        vm.prank(policy);\n        operator.setSpreads(1500, 3000);\n\n        /// Get new bands\n        OlympusRange.Range memory newRange = range.range();\n\n        /// Check that the spreads have been set and prices are updated\n        assertEq(newRange.cushion.spread, 1500);\n        assertEq(newRange.wall.spread, 3000);\n        assertLt(newRange.cushion.low.price, startRange.cushion.low.price);\n        assertLt(newRange.wall.low.price, startRange.wall.low.price);\n        assertGt(newRange.cushion.high.price, startRange.cushion.high.price);\n        assertGt(newRange.wall.high.price, startRange.wall.high.price);\n\n        /// Set spreads smaller as admin\n        vm.prank(policy);\n        operator.setSpreads(500, 1000);\n\n        /// Get new bands\n        newRange = range.range();\n\n        /// Check that the spreads have been set and prices are updated\n        assertEq(newRange.cushion.spread, 500);\n        assertEq(newRange.wall.spread, 1000);\n        assertGt(newRange.cushion.low.price, startRange.cushion.low.price);\n        assertGt(newRange.wall.low.price, startRange.wall.low.price);\n        assertLt(newRange.cushion.high.price, startRange.cushion.high.price);\n        assertLt(newRange.wall.high.price, startRange.wall.high.price);\n    }\n\n    function testCorrectness_setThresholdFactor() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Check that the threshold factor is the same as initialized\n        assertEq(range.thresholdFactor(), 100);\n\n        /// Set threshold factor larger as admin\n        vm.prank(policy);\n        operator.setThresholdFactor(150);\n\n        /// Check that the threshold factor has been updated\n        assertEq(range.thresholdFactor(), 150);\n    }\n\n    function testCorrectness_cannotSetSpreadWithInvalidParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Set spreads with invalid params as admin (both too low)\n        bytes memory err = abi.encodeWithSignature(\"RANGE_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(99, 99);\n\n        /// Set spreads with invalid params as admin (both too high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(10001, 10001);\n\n        /// Set spreads with invalid params as admin (one high, one low)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(99, 10001);\n\n        /// Set spreads with invalid params as admin (one high, one low)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(10001, 99);\n\n        /// Set spreads with invalid params as admin (cushion > wall)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(2000, 1000);\n\n        /// Set spreads with invalid params as admin (one in, one high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(1000, 10001);\n\n        /// Set spreads with invalid params as admin (one in, one low)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setSpreads(99, 2000);\n    }\n\n    function testCorrectness_setCushionFactor() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting cushion factor\n        Operator.Config memory startConfig = operator.config();\n\n        /// Set cushion factor as admin\n        vm.prank(policy);\n        operator.setCushionFactor(uint32(1000));\n\n        /// Get new cushion factor\n        Operator.Config memory newConfig = operator.config();\n\n        /// Check that the cushion factor has been set\n        assertEq(newConfig.cushionFactor, uint32(1000));\n        assertLt(newConfig.cushionFactor, startConfig.cushionFactor);\n    }\n\n    function testCorrectness_cannotSetCushionFactorWithInvalidParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Set cushion factor with invalid params as admin (too low)\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionFactor(uint32(99));\n\n        /// Set cushion factor with invalid params as admin (too high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionFactor(uint32(10001));\n    }\n\n    function testCorrectness_setCushionParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting cushion params\n        Operator.Config memory startConfig = operator.config();\n\n        /// Set cushion params as admin\n        vm.prank(policy);\n        operator.setCushionParams(uint32(24 hours), uint32(50_000), uint32(4 hours));\n\n        /// Get new cushion params\n        Operator.Config memory newConfig = operator.config();\n\n        /// Check that the cushion params has been set\n        assertEq(newConfig.cushionDuration, uint32(24 hours));\n        assertLt(newConfig.cushionDuration, startConfig.cushionDuration);\n        assertEq(newConfig.cushionDebtBuffer, uint32(50_000));\n        assertLt(newConfig.cushionDebtBuffer, startConfig.cushionDebtBuffer);\n        assertEq(newConfig.cushionDepositInterval, uint32(4 hours));\n        assertGt(newConfig.cushionDepositInterval, startConfig.cushionDepositInterval);\n    }\n\n    function testCorrectness_cannotSetCushionParamsWithInvalidParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Set cushion params with invalid duration as admin (too low)\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionParams(uint32(1 days) - 1, uint32(100_000), uint32(1 hours));\n\n        /// Set cushion params with invalid duration as admin (too high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionParams(uint32(7 days) + 1, uint32(100_000), uint32(1 hours));\n\n        /// Set cushion params with deposit interval greater than duration as admin\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionParams(uint32(1 days), uint32(100_000), uint32(2 days));\n\n        /// Set cushion params with invalid debt buffer as admin (too low)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setCushionParams(uint32(2 days), uint32(99), uint32(2 hours));\n    }\n\n    function testCorrectness_setReserveFactor() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting reserve factor\n        Operator.Config memory startConfig = operator.config();\n\n        /// Set reserve factor as admin\n        vm.prank(policy);\n        operator.setReserveFactor(uint32(500));\n\n        /// Get new reserve factor\n        Operator.Config memory newConfig = operator.config();\n\n        /// Check that the reserve factor has been set\n        assertEq(newConfig.reserveFactor, uint32(500));\n        assertLt(newConfig.reserveFactor, startConfig.reserveFactor);\n    }\n\n    function testCorrectness_cannotSetReserveFactorWithInvalidParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Set reserve factor with invalid params as admin (too low)\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setReserveFactor(uint32(99));\n\n        /// Set reserve factor with invalid params as admin (too high)\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setReserveFactor(uint32(10001));\n    }\n\n    function testCorrectness_setRegenParams() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Get starting regen params\n        Operator.Config memory startConfig = operator.config();\n\n        /// Confirm cannot set with invalid params\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        /// Case 1: wait < 1 hours\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setRegenParams(uint32(1 hours) - 1, uint32(11), uint32(15));\n\n        /// Case 2: observe == 0\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setRegenParams(uint32(1 days), uint32(0), uint32(0));\n\n        /// Case 3: observe < threshold\n        vm.expectRevert(err);\n        vm.prank(policy);\n        operator.setRegenParams(uint32(1 days), uint32(10), uint32(9));\n\n        /// Set regen params as admin with valid params\n        vm.prank(policy);\n        operator.setRegenParams(uint32(1 days), uint32(11), uint32(15));\n\n        /// Get new regen params\n        Operator.Config memory newConfig = operator.config();\n\n        /// Check that the regen params have been set\n        assertEq(newConfig.regenWait, uint256(1 days));\n        assertEq(newConfig.regenThreshold, 11);\n        assertEq(newConfig.regenObserve, 15);\n        assertGt(newConfig.regenWait, startConfig.regenWait);\n        assertGt(newConfig.regenThreshold, startConfig.regenThreshold);\n        assertGt(newConfig.regenObserve, startConfig.regenObserve);\n\n        /// Check that the regen structs have been re-initialized\n        Operator.Status memory status = operator.status();\n        assertEq(status.high.count, 0);\n        assertEq(status.high.nextObservation, 0);\n        assertEq(status.low.count, 0);\n        assertEq(status.low.nextObservation, 0);\n        for (uint256 i; i < 15; ++i) {\n            assertTrue(!status.high.observations[i]);\n            assertTrue(!status.low.observations[i]);\n        }\n    }\n\n    function testCorrectness_setBondContracts() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Attempt to set bond contracts to zero address and expect revert\n        bytes memory err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        vm.expectRevert(err);\n        vm.prank(guardian);\n        operator.setBondContracts(IBondAuctioneer(address(0)), BondCallback(address(0)));\n\n        /// Create new bond contracts\n        BondFixedTermCDA newCDA = new BondFixedTermCDA(teller, aggregator, guardian, auth);\n        BondCallback newCb = new BondCallback(kernel, IBondAggregator(address(aggregator)), ohm);\n\n        /// Update the bond contracts as guardian\n        vm.prank(guardian);\n        operator.setBondContracts(IBondAuctioneer(address(newCDA)), newCb);\n\n        /// Check that the bond contracts have been set\n        assertEq(address(operator.auctioneer()), address(newCDA));\n        assertEq(address(operator.callback()), address(newCb));\n    }\n\n    function testCorrectness_initialize() public {\n        /// Confirm that the operator is not initialized yet and walls are down\n        assertTrue(!operator.initialized());\n        assertTrue(!operator.active());\n        assertTrue(!range.active(true));\n        assertTrue(!range.active(false));\n        assertEq(treasury.withdrawApproval(address(operator), reserve), 0);\n        assertEq(range.price(false, false), 0);\n        assertEq(range.price(true, false), 0);\n        assertEq(range.price(false, true), 0);\n        assertEq(range.price(true, true), 0);\n        assertEq(range.capacity(false), 0);\n        assertEq(range.capacity(true), 0);\n\n        /// Initialize the operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Confirm that the operator is initialized and walls are up\n        assertTrue(operator.initialized());\n        assertTrue(operator.active());\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n        assertEq(treasury.withdrawApproval(address(operator), reserve), type(uint256).max);\n        assertGt(range.price(false, false), 0);\n        assertGt(range.price(true, false), 0);\n        assertGt(range.price(false, true), 0);\n        assertGt(range.price(true, true), 0);\n        assertGt(range.capacity(false), 0);\n        assertGt(range.capacity(true), 0);\n    }\n\n    function testCorrectness_cannotInitializeTwice() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Try to initialize the operator again as guardian\n        bytes memory err = abi.encodeWithSignature(\"Operator_AlreadyInitialized()\");\n        vm.expectRevert(err);\n        vm.prank(guardian);\n        operator.initialize();\n    }\n\n    function testCorrectness_regenerate() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        uint48 startTime = uint48(block.timestamp);\n        vm.warp(block.timestamp + 1 hours);\n        uint48 newTime = uint48(block.timestamp);\n\n        /// Confirm that both sides are currently up\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n\n        /// Confirm that the Regen structs are at the initial state\n        Operator.Status memory status = operator.status();\n        assertEq(status.high.count, uint32(0));\n        assertEq(status.high.nextObservation, uint32(0));\n        assertEq(status.high.lastRegen, startTime);\n        assertEq(status.low.count, uint32(0));\n        assertEq(status.low.nextObservation, uint32(0));\n        assertEq(status.low.lastRegen, startTime);\n\n        /// Call operate twice, at different price points, to make the regen counts higher than zero\n        price.setLastPrice(105 * 1e18);\n        vm.prank(heart);\n        operator.operate();\n\n        price.setLastPrice(95 * 1e18);\n        vm.prank(heart);\n        operator.operate();\n\n        /// Confirm that the Regen structs are updated\n        status = operator.status();\n        assertEq(status.high.count, uint32(1));\n        assertEq(status.high.nextObservation, uint32(2));\n        assertEq(status.high.lastRegen, startTime);\n        assertEq(status.low.count, uint32(1));\n        assertEq(status.low.nextObservation, uint32(2));\n        assertEq(status.low.lastRegen, startTime);\n\n        /// Knock down both walls\n        knockDownWall(true);\n        knockDownWall(false);\n\n        /// Confirm that both sides are now down\n        assertTrue(!range.active(true));\n        assertTrue(!range.active(false));\n\n        /// Try to call regenerate without being guardian and expect revert\n        bytes memory err = abi.encodeWithSelector(\n            Policy_OnlyRole.selector,\n            toRole(\"operator_admin\")\n        );\n\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.regenerate(true);\n\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.regenerate(false);\n\n        /// Confirm that the Regen structs are the same as before and walls are still down\n        status = operator.status();\n        assertEq(status.high.count, uint32(1));\n        assertEq(status.high.nextObservation, uint32(2));\n        assertEq(status.low.count, uint32(1));\n        assertEq(status.low.nextObservation, uint32(2));\n        assertTrue(!range.active(true));\n        assertTrue(!range.active(false));\n\n        /// Call regenerate as guardian and confirm each side is updated\n        vm.prank(guardian);\n        operator.regenerate(true);\n\n        vm.prank(guardian);\n        operator.regenerate(false);\n\n        /// Confirm that the sides have regenerated and the Regen structs are reset\n        status = operator.status();\n        assertEq(status.high.count, uint32(0));\n        assertEq(status.high.nextObservation, uint32(0));\n        assertEq(status.high.lastRegen, newTime);\n        assertEq(status.low.count, uint32(0));\n        assertEq(status.low.nextObservation, uint32(0));\n        assertEq(status.low.lastRegen, newTime);\n        assertTrue(range.active(true));\n        assertTrue(range.active(false));\n    }\n\n    function testCorrectness_cannotPerformMarketOpsWhileInactive() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Toggle the operator to inactive\n        vm.prank(guardian);\n        operator.toggleActive();\n\n        /// Try to call operator, swap, and bondPurchase, expect reverts\n        bytes memory err = abi.encodeWithSignature(\"Operator_Inactive()\");\n        vm.expectRevert(err);\n        vm.prank(guardian);\n        operator.operate();\n\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(ohm, 1e9, 1);\n\n        vm.expectRevert(err);\n        vm.prank(alice);\n        operator.swap(reserve, 1e18, 1);\n\n        vm.expectRevert(err);\n        vm.prank(address(callback));\n        operator.bondPurchase(0, 1e18);\n    }\n\n    /* ========== VIEW TESTS ========== */\n\n    /// DONE\n    /// [X] fullCapacity\n    /// [X] getAmountOut\n\n    function testCorrectness_viewFullCapacity() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Load config\n        Operator.Config memory config = operator.config();\n\n        /// Check that fullCapacity returns the full capacity based on the reserveFactor\n        uint256 resInTreasury = treasury.getReserveBalance(reserve);\n        uint256 lowCapacity = resInTreasury.mulDiv(config.reserveFactor, 1e4);\n        uint256 highCapacity = (lowCapacity.mulDiv(\n            1e9 * 10**price.decimals(),\n            1e18 * range.price(true, true)\n        ) * (1e4 + range.spread(true) * 2)) / 1e4;\n\n        assertEq(operator.fullCapacity(false), lowCapacity);\n        assertEq(operator.fullCapacity(true), highCapacity);\n    }\n\n    function testCorrectness_viewGetAmountOut() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Check that getAmountOut returns the amount of token to receive for different combinations of inputs\n        /// Case 1: OHM In, less than capacity\n        uint256 amountIn = 100 * 1e9;\n        uint256 expAmountOut = amountIn.mulDiv(1e18 * range.price(true, false), 1e9 * 1e18);\n\n        assertEq(expAmountOut, operator.getAmountOut(ohm, amountIn));\n\n        /// Case 2: OHM In, more than capacity\n        amountIn = range.capacity(false).mulDiv(1e9 * 1e18, 1e18 * range.price(true, false)) + 1e9;\n\n        bytes memory err = abi.encodeWithSignature(\"Operator_InsufficientCapacity()\");\n        vm.expectRevert(err);\n        operator.getAmountOut(ohm, amountIn);\n\n        /// Case 3: Reserve In, less than capacity\n        amountIn = 10000 * 1e18;\n        expAmountOut = amountIn.mulDiv(1e9 * 1e18, 1e18 * range.price(true, true));\n\n        assertEq(expAmountOut, operator.getAmountOut(reserve, amountIn));\n\n        /// Case 4: Reserve In, more than capacity\n        amountIn = range.capacity(true).mulDiv(1e18 * range.price(true, true), 1e9 * 1e18) + 1e18;\n\n        vm.expectRevert(err);\n        operator.getAmountOut(reserve, amountIn);\n\n        /// Case 5: Random, non-accepted token\n        err = abi.encodeWithSignature(\"Operator_InvalidParams()\");\n        ERC20 token = ERC20(bob);\n        amountIn = 100 * 1e18;\n        vm.expectRevert(err);\n        operator.getAmountOut(token, amountIn);\n    }\n\n    /* ========== INTERNAL FUNCTION TESTS ========== */\n\n    /// DONE\n    /// [X] Range updates from new price data when operate is called (triggers _updateRange)\n\n    function testCorrectness_updateRange() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// Store the starting bands\n        OlympusRange.Range memory startRange = range.range();\n\n        /// Update moving average upwards and trigger the operator\n        price.setMovingAverage(105 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the bands have updated\n        assertGt(range.price(false, false), startRange.cushion.low.price);\n        assertGt(range.price(true, false), startRange.wall.low.price);\n        assertGt(range.price(false, true), startRange.cushion.high.price);\n        assertGt(range.price(true, true), startRange.wall.high.price);\n\n        /// Update moving average downwards and trigger the operator\n        price.setMovingAverage(95 * 1e18);\n        vm.prank(guardian);\n        operator.operate();\n\n        /// Check that the bands have updated\n        assertLt(range.price(false, false), startRange.cushion.low.price);\n        assertLt(range.price(true, false), startRange.wall.low.price);\n        assertLt(range.price(false, true), startRange.cushion.high.price);\n        assertLt(range.price(true, true), startRange.wall.high.price);\n    }\n}\n\n\n",
        "CodeNames": [
            "Operator.sol",
            "Operator.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Operator.sol lines 363-469",
                "Type": "Incorrect initial bond market price",
                "Description": "Initial bond market price is set to wall price rather than current price as indicated in documentation.",
                "Repair": "Update initial price to open bond market at current price rather than wall price"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IHeart} from \"policies/interfaces/IHeart.sol\";\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\n\nimport {OlympusPrice} from \"modules/PRICE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title  Olympus Heart\n/// @notice Olympus Heart (Policy) Contract\n/// @dev    The Olympus Heart contract provides keeper rewards to call the heart beat function which fuels\n///         Olympus market operations. The Heart orchestrates state updates in the correct order to ensure\n///         market operations use up to date information.\ncontract OlympusHeart is IHeart, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    error Heart_OutOfCycle();\n    error Heart_BeatStopped();\n    error Heart_InvalidParams();\n\n    event Beat(uint256 timestamp_);\n    event RewardIssued(address to_, uint256 rewardAmount_);\n    event RewardUpdated(ERC20 token_, uint256 rewardAmount_);\n\n    /// @notice Status of the Heart, false = stopped, true = beating\n    bool public active;\n\n    /// @notice Timestamp of the last beat (UTC, in seconds)\n    uint256 public lastBeat;\n\n    /// @notice Reward for beating the Heart (in reward token decimals)\n    uint256 public reward;\n\n    /// @notice Reward token address that users are sent for beating the Heart\n    ERC20 public rewardToken;\n\n    // Modules\n    OlympusPrice internal PRICE;\n\n    // Policies\n    IOperator internal _operator;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IOperator operator_,\n        ERC20 rewardToken_,\n        uint256 reward_\n    ) Policy(kernel_) {\n        _operator = operator_;\n\n        active = true;\n        lastBeat = block.timestamp;\n        rewardToken = rewardToken_;\n        reward = reward_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"PRICE\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](1);\n        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.updateMovingAverage.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function beat() external nonReentrant {\n        if (!active) revert Heart_BeatStopped();\n        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n\n        // Update the moving average on the Price module\n        PRICE.updateMovingAverage();\n\n        // Trigger price range update and market operations\n        _operator.operate();\n\n        // Update the last beat timestamp\n        lastBeat += frequency();\n\n        // Issue reward to sender\n        _issueReward(msg.sender);\n\n        emit Beat(block.timestamp);\n    }\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function frequency() public view returns (uint256) {\n        return uint256(PRICE.observationFrequency());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function resetBeat() external onlyRole(\"heart_admin\") {\n        lastBeat = block.timestamp - frequency();\n    }\n\n    /// @inheritdoc IHeart\n    function toggleBeat() external onlyRole(\"heart_admin\") {\n        active = !active;\n    }\n\n    /// @inheritdoc IHeart\n    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n        external\n        onlyRole(\"heart_admin\")\n    {\n        rewardToken = token_;\n        reward = reward_;\n        emit RewardUpdated(token_, reward_);\n    }\n\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\nimport {console2} from \"forge-std/console2.sol\";\n\nimport {MockERC20, ERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport {MockPrice} from \"test/mocks/MockPrice.sol\";\n\nimport {FullMath} from \"libraries/FullMath.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {OlympusHeart} from \"policies/Heart.sol\";\n\nimport {IOperator, ERC20, IBondAuctioneer, IBondCallback} from \"policies/interfaces/IOperator.sol\";\n\n/**\n * @notice Mock Operator to test Heart\n */\ncontract MockOperator is Policy {\n    bool public result;\n    error Operator_CustomError();\n\n    constructor(Kernel kernel_) Policy(kernel_) {\n        result = true;\n    }\n\n    /* ========== FRAMEWORK CONFIFURATION ========== */\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {}\n\n    function requestPermissions() external view override returns (Permissions[] memory requests) {}\n\n    /* ========== HEART FUNCTIONS ========== */\n    function operate() external view onlyRole(\"operator_operate\") {\n        if (!result) revert Operator_CustomError();\n    }\n\n    function setResult(bool result_) external {\n        result = result_;\n    }\n}\n\ncontract HeartTest is Test {\n    using FullMath for uint256;\n\n    UserFactory public userCreator;\n    address internal alice;\n    address internal bob;\n    address internal guardian;\n    address internal policy;\n\n    MockERC20 internal rewardToken;\n\n    Kernel internal kernel;\n    MockPrice internal price;\n\n    MockOperator internal operator;\n\n    OlympusHeart internal heart;\n\n    function setUp() public {\n        vm.warp(51 * 365 * 24 * 60 * 60); // Set timestamp at roughly Jan 1, 2021 (51 years since Unix epoch)\n        userCreator = new UserFactory();\n        {\n            address[] memory users = userCreator.create(5);\n            alice = users[0];\n            bob = users[1];\n            guardian = users[2];\n            policy = users[3];\n        }\n        {\n            /// Deploy token mocks\n            rewardToken = new MockERC20(\"Reward Token\", \"RWD\", 18);\n        }\n\n        {\n            /// Deploy kernel\n            kernel = new Kernel(); // this contract will be the executor\n\n            /// Deploy modules (some mocks)\n            price = new MockPrice(kernel, uint48(8 hours));\n\n            /// Configure mocks\n            price.setMovingAverage(100 * 1e18);\n            price.setLastPrice(100 * 1e18);\n            price.setCurrentPrice(100 * 1e18);\n            price.setDecimals(18);\n        }\n\n        {\n            /// Deploy mock operator\n            operator = new MockOperator(kernel);\n\n            /// Deploy heart\n            heart = new OlympusHeart(\n                kernel,\n                IOperator(address(operator)),\n                rewardToken,\n                uint256(1e18) // 1 reward token\n            );\n        }\n\n        {\n            /// Initialize system and kernel\n\n            /// Install modules\n            kernel.executeAction(Actions.InstallModule, address(price));\n\n            /// Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(operator));\n            kernel.executeAction(Actions.ActivatePolicy, address(heart));\n\n            /// Configure access control\n\n            /// Heart roles\n            kernel.grantRole(toRole(\"heart_admin\"), guardian);\n\n            /// Operator roles\n            kernel.grantRole(toRole(\"operator_operate\"), address(heart));\n            kernel.grantRole(toRole(\"operator_operate\"), guardian);\n        }\n\n        {\n            /// Mint reward tokens to heart contract\n            rewardToken.mint(address(heart), uint256(1000 * 1e18));\n        }\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n\n    /* ========== KEEPER FUNCTIONS ========== */\n    /// DONE\n    /// [X] beat\n    ///     [X] active and frequency has passed\n    ///     [X] cannot beat if not active\n    ///     [X] cannot beat if not enough time has passed\n    ///     [X] fails if price or operator revert\n\n    function testCorrectness_beat() public {\n        /// Get the beat frequency of the heart and wait that amount of time\n        uint256 frequency = heart.frequency();\n        vm.warp(block.timestamp + frequency);\n\n        /// Store this contract's current reward token balance\n        uint256 startBalance = rewardToken.balanceOf(address(this));\n\n        /// Beat the heart\n        heart.beat();\n\n        /// Check that the contract's reward token balance has increased by the reward amount\n        uint256 endBalance = rewardToken.balanceOf(address(this));\n        assertEq(endBalance, startBalance + heart.reward());\n    }\n\n    function testCorrectness_cannotBeatIfInactive() public {\n        /// Set the heart to inactive\n        vm.prank(guardian);\n        heart.toggleBeat();\n\n        /// Try to beat the heart and expect revert\n        bytes memory err = abi.encodeWithSignature(\"Heart_BeatStopped()\");\n        vm.expectRevert(err);\n        heart.beat();\n    }\n\n    function testCorrectness_cannotBeatIfTooEarly() public {\n        /// Try to beat the heart and expect revert since it hasn't been more than the frequency since the last beat (deployment)\n        bytes memory err = abi.encodeWithSignature(\"Heart_OutOfCycle()\");\n        vm.expectRevert(err);\n        heart.beat();\n    }\n\n    function testFail_beatFailsIfPriceReverts() public {\n        /// Get the beat frequency of the heart and wait that amount of time\n        uint256 frequency = heart.frequency();\n        vm.warp(block.timestamp + frequency);\n\n        /// Set the price mock to return false\n        price.setResult(false);\n\n        /// Try to beat the heart and expect revert\n        heart.beat();\n    }\n\n    function testFail_beatFailsIfOperateReverts() public {\n        /// Get the beat frequency of the heart and wait that amount of time\n        uint256 frequency = heart.frequency();\n        vm.warp(block.timestamp + frequency);\n\n        /// Set the price mock to return false\n        operator.setResult(false);\n\n        /// Try to beat the heart and expect revert\n        heart.beat();\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n    /// [X] frequency\n\n    function testCorrectness_viewFrequency() public {\n        /// Get the beat frequency of the heart\n        uint256 frequency = heart.frequency();\n\n        /// Check that the frequency is correct\n        assertEq(frequency, uint256(8 hours));\n    }\n\n    /* ========== ADMIN FUNCTIONS ========== */\n    /// DONE\n    /// [X] resetBeat\n    /// [X] toggleBeat\n    /// [X] setRewardTokenAndAmount\n    /// [X] withdrawUnspentRewards\n    /// [X] cannot call admin functions without permissions\n\n    function testCorrectness_resetBeat() public {\n        /// Try to beat the heart and expect the revert since not enough time has passed\n        bytes memory err = abi.encodeWithSignature(\"Heart_OutOfCycle()\");\n        vm.expectRevert(err);\n        heart.beat();\n\n        /// Reset the beat so that it can be called without moving the time forward\n        vm.prank(guardian);\n        heart.resetBeat();\n\n        /// Store this contract's current reward token balance\n        uint256 startBalance = rewardToken.balanceOf(address(this));\n\n        /// Beat the heart and expect it to work\n        heart.beat();\n\n        /// Check that the contract's reward token balance has increased by the reward amount\n        uint256 endBalance = rewardToken.balanceOf(address(this));\n        assertEq(endBalance, startBalance + heart.reward());\n    }\n\n    function testCorrectness_toggleBeat() public {\n        /// Expect the heart to be active to begin with\n        assertTrue(heart.active());\n\n        /// Toggle the heart to make it inactive\n        vm.prank(guardian);\n        heart.toggleBeat();\n\n        /// Expect the heart to be inactive\n        assertTrue(!heart.active());\n\n        /// Toggle the heart to make it active again\n        vm.prank(guardian);\n        heart.toggleBeat();\n\n        /// Expect the heart to be active again\n        assertTrue(heart.active());\n    }\n\n    function testCorrectness_setRewardTokenAndAmount() public {\n        /// Set the heart's reward token to a new token and amount to a new amount\n        MockERC20 newToken = new MockERC20(\"New Token\", \"NT\", 18);\n        uint256 newReward = uint256(2e18);\n        vm.prank(guardian);\n        heart.setRewardTokenAndAmount(newToken, newReward);\n\n        /// Expect the heart's reward token and reward to be updated\n        assertEq(address(heart.rewardToken()), address(newToken));\n        assertEq(heart.reward(), newReward);\n\n        /// Mint some new tokens to the heart to pay rewards\n        newToken.mint(address(heart), uint256(1000 * 1e18));\n\n        /// Expect the heart to reward the new token and amount on a beat\n        uint256 startBalance = newToken.balanceOf(address(this));\n        uint256 frequency = heart.frequency();\n        vm.warp(block.timestamp + frequency);\n        heart.beat();\n\n        uint256 endBalance = newToken.balanceOf(address(this));\n        assertEq(endBalance, startBalance + heart.reward());\n    }\n\n    function testCorrectness_withdrawUnspentRewards() public {\n        /// Get the balance of the reward token on the contract\n        uint256 startBalance = rewardToken.balanceOf(address(guardian));\n        uint256 heartBalance = rewardToken.balanceOf(address(heart));\n\n        /// Withdraw the heart's unspent rewards\n        vm.prank(guardian);\n        heart.withdrawUnspentRewards(rewardToken);\n        uint256 endBalance = rewardToken.balanceOf(address(guardian));\n\n        /// Expect the heart's reward token balance to be 0\n        assertEq(rewardToken.balanceOf(address(heart)), uint256(0));\n\n        /// Expect this contract's reward token balance to be increased by the heart's unspent rewards\n        assertEq(endBalance, startBalance + heartBalance);\n    }\n\n    function testCorrectness_cannotCallAdminFunctionsWithoutPermissions() public {\n        /// Try to call admin functions on the heart as non-guardian and expect revert\n        bytes memory err = abi.encodeWithSelector(Policy_OnlyRole.selector, toRole(\"heart_admin\"));\n\n        vm.expectRevert(err);\n        heart.resetBeat();\n\n        vm.expectRevert(err);\n        heart.toggleBeat();\n\n        vm.expectRevert(err);\n        heart.setRewardTokenAndAmount(rewardToken, uint256(2e18));\n\n        vm.expectRevert(err);\n        heart.withdrawUnspentRewards(rewardToken);\n    }\n}\n\n\n",
        "CodeNames": [
            "Heart.sol",
            "Heart.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_issueReward function in Heart.sol and withdrawUnspentRewards function in Heart.sol",
                "Type": "Heart will stop if all rewards are swept",
                "Description": "The function doesn't check for available tokens. In case of calling withdrawUnspentRewards, the heart will stop until a caller incentive is deposited again.",
                "Repair": "Add a check for available tokens min(reward, rewardToken.balanceOf(address(this)));"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/Kernel.sol\";\n\nerror INSTR_InstructionsCannotBeEmpty();\nerror INSTR_InvalidChangeExecutorAction();\n\n/// @notice Caches and executes batched instructions for protocol upgrades in the Kernel.\ncontract OlympusInstructions is Module {\n    event InstructionsStored(uint256 instructionsId);\n\n    uint256 public totalInstructions;\n    mapping(uint256 => Instruction[]) public storedInstructions;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"INSTR\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice View function for retrieving a list of Instructions in an outside contract.\n    function getInstructions(uint256 instructionsId_) public view returns (Instruction[] memory) {\n        return storedInstructions[instructionsId_];\n    }\n\n    /// @notice Store a list of Instructions to be executed in the future.\n    function store(Instruction[] calldata instructions_) external permissioned returns (uint256) {\n        uint256 length = instructions_.length;\n        uint256 instructionsId = ++totalInstructions;\n\n        Instruction[] storage instructions = storedInstructions[instructionsId];\n\n        if (length == 0) revert INSTR_InstructionsCannotBeEmpty();\n\n        for (uint256 i; i < length; ) {\n            Instruction calldata instruction = instructions_[i];\n            ensureContract(instruction.target);\n\n            // If the instruction deals with a module, make sure the module has a valid keycode (UPPERCASE A-Z ONLY)\n            if (\n                instruction.action == Actions.InstallModule ||\n                instruction.action == Actions.UpgradeModule\n            ) {\n                Module module = Module(instruction.target);\n                ensureValidKeycode(module.KEYCODE());\n            } else if (instruction.action == Actions.ChangeExecutor && i != length - 1) {\n                // Throw an error if ChangeExecutor exists and is not the last Action in the instruction list.\n                // This exists because if ChangeExecutor is not the last item in the list of instructions,\n                // the Kernel will not recognize any of the following instructions as valid, since the policy\n                // executing the list of instructions no longer has permissions in the Kernel. To avoid this issue\n                // and prevent invalid proposals from being saved, we perform this check.\n                revert INSTR_InvalidChangeExecutorAction();\n            }\n\n            instructions.push(instructions_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit InstructionsStored(instructionsId);\n\n        return instructionsId;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\n\nimport \"./mocks/KernelTestMocks.sol\";\nimport \"src/Kernel.sol\";\n\ncontract KernelTest is Test {\n    Kernel internal kernel;\n    MockPolicy internal policy;\n    MockModule internal MOCKY;\n\n    address public deployer;\n    address public multisig;\n    address public user;\n    UserFactory public userFactory;\n\n    bytes public err;\n    MockPolicy internal policyTest;\n\n    function setUp() public {\n        userFactory = new UserFactory();\n        address[] memory users = userFactory.create(3);\n        deployer = users[0];\n        multisig = users[1];\n        user = users[2];\n\n        vm.startPrank(deployer);\n        kernel = new Kernel();\n        MOCKY = new MockModule(kernel);\n        policy = new MockPolicy(kernel);\n\n        vm.stopPrank();\n    }\n\n    function testCorrectness_InitializeKernel() public {\n        Keycode keycode = Keycode.wrap(0);\n\n        assertEq(kernel.admin(), deployer);\n        assertEq(kernel.executor(), deployer);\n        assertEq(kernel.modulePermissions(keycode, policy, bytes4(0)), false);\n        assertEq(address(kernel.getModuleForKeycode(keycode)), address(0));\n        assertEq(Keycode.unwrap(kernel.getKeycodeForModule(MOCKY)), bytes5(0));\n\n        // Ensure actions cannot be performed by unauthorized addresses\n        err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"executor\"), address(deployer));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"executor\"), address(deployer));\n        //kernel.revokeRole(deployer);\n    }\n\n    function testCorrectness_EnsureContract() public {\n        ensureContract(address(kernel));\n\n        err = abi.encodeWithSignature(\"TargetNotAContract(address)\", address(deployer));\n        vm.expectRevert(err);\n        ensureContract(deployer);\n\n        err = abi.encodeWithSignature(\"TargetNotAContract(address)\", address(0));\n        vm.expectRevert(err);\n        ensureContract(address(0));\n    }\n\n    function testCorrectness_EnsureValidKeycode() public {\n        ensureValidKeycode(Keycode.wrap(\"VALID\"));\n\n        err = abi.encodeWithSignature(\"InvalidKeycode(bytes5)\", Keycode.wrap(\"inval\"));\n        vm.expectRevert(err);\n        ensureValidKeycode(Keycode.wrap(\"inval\"));\n\n        err = abi.encodeWithSignature(\"InvalidKeycode(bytes5)\", Keycode.wrap(\"\"));\n        vm.expectRevert(err);\n        ensureValidKeycode(Keycode.wrap(bytes5(\"\")));\n    }\n\n    function testCorrectness_EnsureValidRole() public {\n        ensureValidRole(Role.wrap(\"valid\"));\n\n        err = abi.encodeWithSignature(\"InvalidRole(bytes32)\", Role.wrap(\"INVALID_ID\"));\n        vm.expectRevert(err);\n        ensureValidRole(Role.wrap(bytes32(\"INVALID_ID\")));\n    }\n\n    function testCorrectness_GrantRole() public {\n        // Ensure role doesn't exist yet\n        assertFalse(kernel.isRole(Role.wrap(\"tester\")));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n\n        vm.prank(deployer);\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n        assertTrue(kernel.isRole(Role.wrap(\"tester\")));\n        assertTrue(kernel.hasRole(multisig, Role.wrap(\"tester\")));\n    }\n\n    function testCorrectness_RevokeRole() public {\n        Role testerRole = toRole(\"tester\");\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.revokeRole(testerRole, deployer);\n\n        // TODO test role not existing\n\n        vm.startPrank(deployer);\n        kernel.grantRole(testerRole, multisig);\n        assertTrue(kernel.hasRole(multisig, testerRole));\n\n        kernel.revokeRole(testerRole, multisig);\n        assertFalse(kernel.hasRole(multisig, testerRole));\n\n        err = abi.encodeWithSelector(Kernel_AddressDoesNotHaveRole.selector, multisig, testerRole);\n        vm.expectRevert(err);\n        kernel.revokeRole(testerRole, multisig);\n    }\n\n    function testCorrectness_InitializeModule() public {\n        assertEq(Keycode.unwrap(MOCKY.KEYCODE()), \"MOCKY\");\n        assertEq(MOCKY.publicState(), 0);\n        assertEq(MOCKY.permissionedState(), 0);\n    }\n\n    function testCorrectness_InstallModule() public {\n        vm.startPrank(deployer);\n\n        // Ensure module is installed properly\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n        assertEq(address(kernel.getModuleForKeycode(Keycode.wrap(\"MOCKY\"))), address(MOCKY));\n        assertEq(Keycode.unwrap(kernel.getKeycodeForModule(MOCKY)), \"MOCKY\");\n\n        // Try installing an EOA as a module\n        err = abi.encodeWithSignature(\"TargetNotAContract(address)\", deployer);\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, deployer);\n\n        // Try installing module with a bad keycode\n        Module invalidModule = new InvalidMockModule(kernel);\n        err = abi.encodeWithSignature(\"InvalidKeycode(bytes5)\", Keycode.wrap(\"badkc\"));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, address(invalidModule));\n\n        // Try installing MOCKY again\n        err = abi.encodeWithSignature(\n            \"Kernel_ModuleAlreadyInstalled(bytes5)\",\n            Keycode.wrap(\"MOCKY\")\n        );\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n\n        vm.stopPrank();\n    }\n\n    function testCorrectness_ActivatePolicy() public {\n        Keycode testKeycode = Keycode.wrap(\"MOCKY\");\n\n        vm.prank(deployer);\n        err = abi.encodeWithSignature(\"Policy_ModuleDoesNotExist(bytes5)\", testKeycode);\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        _initModuleAndPolicy();\n\n        assertEq(\n            kernel.modulePermissions(testKeycode, policy, MOCKY.permissionedCall.selector),\n            true\n        );\n        assertEq(address(kernel.activePolicies(0)), address(policy));\n\n        uint256 depIndex = kernel.getDependentIndex(testKeycode, policy);\n        Policy[] memory dependencies = new Policy[](1);\n        dependencies[0] = policy;\n        assertEq(address(kernel.moduleDependents(testKeycode, depIndex)), address(dependencies[0]));\n\n        vm.prank(deployer);\n        err = abi.encodeWithSignature(\"Kernel_PolicyAlreadyActivated(address)\", address(policy));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n    }\n\n    function testCorrectness_PolicyPermissions() public {\n        _initModuleAndPolicy();\n        Permissions[] memory permissions = policy.requestPermissions();\n\n        assertEq(Keycode.unwrap(permissions[0].keycode), \"MOCKY\");\n        assertEq(permissions[0].funcSelector, MOCKY.permissionedCall.selector);\n    }\n\n    function testCorrectness_CallPublicPolicyFunction() public {\n        _initModuleAndPolicy();\n\n        vm.prank(deployer);\n        policy.callPublicFunction();\n\n        assertEq(MOCKY.publicState(), 1);\n    }\n\n    function testCorrectness_CallPermissionedPolicyFunction() public {\n        _initModuleAndPolicy();\n\n        // Test role-based auth for policy calls\n        Role testerRole = Role.wrap(\"tester\");\n\n        vm.startPrank(deployer);\n\n        err = abi.encodeWithSignature(\"Policy_OnlyRole(bytes32)\", testerRole);\n        vm.expectRevert(err);\n        policy.callPermissionedFunction();\n\n        kernel.grantRole(testerRole, multisig);\n\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        policy.callPermissionedFunction();\n        assertEq(MOCKY.permissionedState(), 1);\n\n        vm.prank(deployer);\n        kernel.revokeRole(testerRole, multisig);\n\n        vm.prank(multisig);\n        err = abi.encodeWithSignature(\"Policy_OnlyRole(bytes32)\", testerRole);\n        vm.expectRevert(err);\n        policy.callPermissionedFunction();\n    }\n\n    function testCorrectness_DeactivatePolicy() public {\n        vm.startPrank(deployer);\n\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n\n        err = abi.encodeWithSignature(\"Kernel_PolicyAlreadyActivated(address)\", address(policy));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        kernel.executeAction(Actions.DeactivatePolicy, address(policy));\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        err = abi.encodeWithSignature(\"Module_PolicyNotPermitted(address)\", address(policy));\n        vm.expectRevert(err);\n        policy.callPermissionedFunction();\n\n        assertEq(\n            kernel.modulePermissions(\n                Keycode.wrap(\"MOCKY\"),\n                policy,\n                MOCKY.permissionedCall.selector\n            ),\n            false\n        );\n        vm.expectRevert();\n        assertEq(address(kernel.activePolicies(0)), address(0));\n    }\n\n    function testCorrectness_UpgradeModule() public {\n        UpgradedMockModule upgradedModule = new UpgradedMockModule(kernel, MOCKY);\n\n        vm.startPrank(deployer);\n\n        err = abi.encodeWithSignature(\"Kernel_InvalidModuleUpgrade(bytes5)\", Keycode.wrap(\"MOCKY\"));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.UpgradeModule, address(upgradedModule));\n\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n\n        err = abi.encodeWithSignature(\"Kernel_InvalidModuleUpgrade(bytes5)\", Keycode.wrap(\"MOCKY\"));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.UpgradeModule, address(MOCKY));\n\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        policy.callPermissionedFunction();\n\n        assertEq(MOCKY.permissionedState(), 1);\n\n        // Upgrade MOCKY\n        vm.prank(deployer);\n        kernel.executeAction(Actions.UpgradeModule, address(upgradedModule));\n\n        // check state is reset\n        assertEq(upgradedModule.permissionedState(), 1);\n\n        // check if permissions persist\n        vm.prank(multisig);\n        policy.callPermissionedFunction();\n\n        assertEq(upgradedModule.permissionedState(), 2);\n    }\n\n    function testCorrectness_ChangeExecutor() public {\n        vm.startPrank(deployer);\n        kernel.executeAction(Actions.ChangeExecutor, address(multisig));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", deployer);\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ChangeExecutor, address(deployer));\n\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        kernel.executeAction(Actions.ChangeExecutor, address(deployer));\n\n        vm.startPrank(deployer);\n        kernel.executeAction(Actions.ChangeExecutor, address(multisig));\n    }\n\n    function testCorrectness_ChangeAdmin() public {\n        err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ChangeAdmin, address(multisig));\n\n        vm.startPrank(deployer);\n\n        {\n            kernel.executeAction(Actions.InstallModule, address(MOCKY));\n            kernel.executeAction(Actions.ActivatePolicy, address(policy));\n            kernel.executeAction(Actions.ChangeAdmin, address(multisig));\n            vm.stopPrank();\n        }\n\n        vm.prank(multisig);\n\n        kernel.grantRole(Role.wrap(\"tester\"), user);\n        vm.prank(user);\n        policy.callPermissionedFunction();\n\n        vm.prank(deployer);\n        kernel.executeAction(Actions.ChangeAdmin, address(user));\n\n        vm.startPrank(multisig);\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", multisig);\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n        vm.stopPrank();\n\n        vm.prank(user);\n        kernel.revokeRole(Role.wrap(\"tester\"), user);\n        assertFalse(kernel.hasRole(user, Role.wrap(\"tester\")));\n\n        err = abi.encodeWithSignature(\"Policy_OnlyRole(bytes32)\", Role.wrap(\"tester\"));\n        vm.expectRevert(err);\n        vm.prank(user);\n        policy.callPermissionedFunction();\n    }\n\n    function testCorrectness_MigrateKernel() public {\n        _initModuleAndPolicy();\n\n        assertEq(address(kernel.getModuleForKeycode(kernel.allKeycodes(0))), address(MOCKY));\n        assertEq(address(kernel.activePolicies(0)), address(policy));\n\n        vm.startPrank(deployer);\n\n        // Create new kernel and migrate to it\n        Kernel newKernel = new Kernel();\n\n        kernel.executeAction(Actions.MigrateKernel, address(newKernel));\n\n        assertEq(address(MOCKY.kernel()), address(newKernel));\n        assertEq(address(policy.kernel()), address(newKernel));\n\n        // Install module and approve policy\n        newKernel.executeAction(Actions.InstallModule, address(MOCKY));\n        newKernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        assertEq(address(newKernel.getModuleForKeycode(newKernel.allKeycodes(0))), address(MOCKY));\n        assertEq(address(newKernel.activePolicies(0)), address(policy));\n    }\n\n    function _initModuleAndPolicy() internal {\n        vm.startPrank(deployer);\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n        vm.stopPrank();\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\nimport {ModuleTestFixtureGenerator} from \"test/lib/ModuleTestFixtureGenerator.sol\";\n\nimport \"src/Kernel.sol\";\nimport \"modules/INSTR.sol\";\nimport {OlympusGovernance} from \"policies/Governance.sol\";\nimport {MockModuleWriter} from \"test/mocks/MockModuleWriter.sol\";\nimport {MockInvalidModule} from \"test/mocks/MockInvalidModule.sol\";\nimport {MockValidModule} from \"test/mocks/MockValidModule.sol\";\nimport {MockValidUpgradedModule} from \"test/mocks/MockValidUpgradedModule.sol\";\n\ncontract InstructionsTest is Test {\n    Kernel internal kernel;\n    using ModuleTestFixtureGenerator for OlympusInstructions;\n\n    OlympusInstructions internal instr;\n    OlympusGovernance internal governance;\n    address internal writer;\n    Module internal invalidModule;\n\n    event InstructionsStored(uint256);\n\n    function setUp() public {\n        /// Deploy kernel\n        kernel = new Kernel(); // this contract will be the executor\n\n        /// Deploy modules (some mocks)\n        instr = new OlympusInstructions(kernel);\n        invalidModule = new MockInvalidModule(kernel);\n\n        /// Deploy policies\n        writer = instr.generateGodmodeFixture(type(OlympusInstructions).name);\n        governance = new OlympusGovernance(kernel);\n\n        /// Install modules\n        kernel.executeAction(Actions.InstallModule, address(instr));\n\n        /// Approve policies\n        kernel.executeAction(Actions.ActivatePolicy, writer);\n    }\n\n    function testRevert_InstructionsCannotBeEmpty() public {\n        vm.expectRevert(INSTR_InstructionsCannotBeEmpty.selector);\n\n        // create valid instructions\n        Instruction[] memory instructions = new Instruction[](0);\n        vm.prank(writer);\n        instr.store(instructions);\n    }\n\n    function testRevert_InvalidChangeExecutorAction() public {\n        // create invalid instructions\n        Instruction[] memory instructions = new Instruction[](2);\n        instructions[0] = Instruction(Actions.ChangeExecutor, address(governance));\n        instructions[1] = Instruction(Actions.ActivatePolicy, address(governance));\n\n        vm.expectRevert(INSTR_InvalidChangeExecutorAction.selector);\n        vm.prank(writer);\n        instr.store(instructions);\n    }\n\n    function testRevert_InvalidTargetNotAContract() public {\n        // create invalid instructions\n        Instruction[] memory instructions = new Instruction[](1);\n        instructions[0] = Instruction(Actions.InstallModule, address(0));\n\n        vm.expectRevert(abi.encodeWithSelector(TargetNotAContract.selector, address(0)));\n        vm.prank(writer);\n        instr.store(instructions);\n    }\n\n    function testRevert_InvalidModuleKeycode() public {\n        // create invalid instructions\n        Instruction[] memory instructions = new Instruction[](1);\n        instructions[0] = Instruction(Actions.InstallModule, address(invalidModule));\n\n        vm.expectRevert(abi.encodeWithSelector(InvalidKeycode.selector, invalidModule.KEYCODE()));\n        vm.prank(writer);\n        instr.store(instructions);\n    }\n\n    function testCorrectness_InstallModule() public {\n        // deploy new sample module\n        address mockModuleAddress = address(new MockValidModule(kernel));\n\n        // create valid instructions\n        Instruction[] memory instructions = new Instruction[](1);\n        instructions[0] = Instruction(Actions.InstallModule, mockModuleAddress);\n\n        vm.expectEmit(true, true, true, true);\n        emit InstructionsStored(1);\n\n        vm.prank(writer);\n        instr.store(instructions);\n\n        instructions = instr.getInstructions(1);\n\n        assertEq(uint256(instructions[0].action), uint256(Actions.InstallModule));\n        assertEq(instructions[0].target, address(mockModuleAddress));\n    }\n\n    function testCorrectness_UpgradeModule() public {\n        // deploy new sample module and upgrade\n        Module mockModuleAddress = Module(new MockValidModule(kernel));\n        Policy mockModuleWriter = Policy(\n            new MockModuleWriter(kernel, mockModuleAddress, new Permissions[](0))\n        );\n        Module mockUpgradedModuleAddress = Module(new MockValidUpgradedModule(kernel));\n\n        // install a pre-existing module and policy\n        kernel.executeAction(Actions.InstallModule, address(mockModuleAddress));\n        kernel.executeAction(Actions.ActivatePolicy, address(mockModuleWriter));\n\n        // create the upgrade instruction\n        Instruction[] memory instructions = new Instruction[](1);\n        instructions[0] = Instruction(Actions.UpgradeModule, address(mockUpgradedModuleAddress));\n\n        vm.expectEmit(true, true, true, true);\n        emit InstructionsStored(1);\n\n        // store it\n        vm.prank(writer);\n        instr.store(instructions);\n\n        assertEq(uint256(instructions[0].action), uint256(Actions.UpgradeModule));\n        assertEq(instructions[0].target, address(mockUpgradedModuleAddress));\n        assertEq(instr.totalInstructions(), 1);\n\n        // execute the upgrade\n        kernel.executeAction(instructions[0].action, instructions[0].target);\n\n        // ******CHECK IF OLD POLICY CAN CALL THE UPGRADED MODULE WITH NEW ROLES*******\n        // update the mockvalidmodule test\n        // MockValidModule(mockModuleWriter).roleCall();\n        // assertEq(mockUpgradedModuleAddress.counter, 1);\n    }\n\n    function testCorrectness_ActivatePolicy() public {\n        MockValidModule mockModuleAddress = new MockValidModule(kernel);\n        MockValidModule mockModuleWriter = MockValidModule(\n            address(new MockModuleWriter(kernel, mockModuleAddress, new Permissions[](0)))\n        );\n\n        kernel.executeAction(Actions.InstallModule, address(mockModuleAddress));\n\n        // create valid instructions\n        Instruction[] memory instructions = new Instruction[](1);\n        instructions[0] = Instruction(Actions.ActivatePolicy, address(mockModuleWriter));\n\n        vm.expectEmit(true, true, true, true);\n        emit InstructionsStored(1);\n\n        vm.prank(writer);\n        instr.store(instructions);\n        instructions = instr.getInstructions(1);\n\n        kernel.executeAction(instructions[0].action, instructions[0].target);\n\n        assertEq(uint256(instructions[0].action), uint256(Actions.ActivatePolicy));\n        assertEq(instructions[0].target, address(mockModuleWriter));\n        assertEq(instr.totalInstructions(), 1);\n\n        //mockModuleWriter.roleCall();\n        //assertEq(mockModuleAddress.counter(), 1);\n    }\n\n    function testCorrectness_DeactivatePolicy() public {\n        MockValidModule mockModuleAddress = new MockValidModule(kernel);\n        MockValidModule mockModuleWriter = MockValidModule(\n            address(new MockModuleWriter(kernel, mockModuleAddress, new Permissions[](0)))\n        );\n\n        kernel.executeAction(Actions.InstallModule, address(mockModuleAddress));\n        kernel.executeAction(Actions.ActivatePolicy, address(mockModuleWriter));\n\n        // create valid instructions\n        Instruction[] memory instructions = new Instruction[](1);\n        instructions[0] = Instruction(Actions.DeactivatePolicy, address(mockModuleWriter));\n\n        vm.expectEmit(true, true, true, true);\n        emit InstructionsStored(1);\n\n        vm.prank(writer);\n        instr.store(instructions);\n        instructions = instr.getInstructions(1);\n        kernel.executeAction(instructions[0].action, instructions[0].target);\n\n        assertEq(uint256(instructions[0].action), uint256(Actions.DeactivatePolicy));\n        assertEq(instructions[0].target, address(mockModuleWriter));\n\n        // TODO update with correct error message\n        // vm.expectRevert(Module_PolicyNotPermitted.selector);\n        // mockModuleWriter.roleCall();\n    }\n\n    function testCorrectness_ChangeExecutor() public {\n        // create valid instructions\n        Instruction[] memory instructions = new Instruction[](2);\n        instructions[0] = Instruction(Actions.ActivatePolicy, address(governance));\n        instructions[1] = Instruction(Actions.ChangeExecutor, address(governance));\n\n        vm.expectEmit(true, true, true, true);\n        emit InstructionsStored(1);\n\n        vm.prank(writer);\n        instr.store(instructions);\n\n        instructions = instr.getInstructions(1);\n\n        assertEq(uint256(instructions[0].action), uint256(Actions.ActivatePolicy));\n        assertEq(instructions[0].target, address(governance));\n        assertEq(uint256(instructions[1].action), uint256(Actions.ChangeExecutor));\n        assertEq(instructions[1].target, address(governance));\n        assertEq(instr.totalInstructions(), 1);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/utils/KernelUtils.sol\";\n\n// Kernel Adapter errors\nerror KernelAdapter_OnlyKernel(address caller_);\n\n// Module errors\nerror Module_PolicyNotPermitted(address policy_);\n\n// Policy errors\nerror Policy_OnlyRole(Role role_);\nerror Policy_ModuleDoesNotExist(Keycode keycode_);\n\n// Kernel errors\nerror Kernel_OnlyExecutor(address caller_);\nerror Kernel_OnlyAdmin(address caller_);\nerror Kernel_ModuleAlreadyInstalled(Keycode module_);\nerror Kernel_InvalidModuleUpgrade(Keycode module_);\nerror Kernel_PolicyAlreadyActivated(address policy_);\nerror Kernel_PolicyNotActivated(address policy_);\nerror Kernel_AddressAlreadyHasRole(address addr_, Role role_);\nerror Kernel_AddressDoesNotHaveRole(address addr_, Role role_);\nerror Kernel_RoleDoesNotExist(Role role_);\n\n/*//////////////////////////////////////////////////////////////\n                          GLOBAL TYPES\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\nenum Actions {\n    InstallModule,\n    UpgradeModule,\n    ActivatePolicy,\n    DeactivatePolicy,\n    ChangeExecutor,\n    ChangeAdmin,\n    MigrateKernel\n}\n\n/// @notice Used by executor to select an action and a target contract for a kernel action\nstruct Instruction {\n    Actions action;\n    address target;\n}\n\n/// @notice Used to define which module functions a policy needs access to\nstruct Permissions {\n    Keycode keycode;\n    bytes4 funcSelector;\n}\n\ntype Keycode is bytes5;\ntype Role is bytes32;\n\n/*//////////////////////////////////////////////////////////////\n                      COMPONENT ABSTRACTS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Generic adapter interface for kernel access in modules and policies.\nabstract contract KernelAdapter {\n    Kernel public kernel;\n\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /// @notice Modifier to restrict functions to be called only by kernel.\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /// @notice Function used by kernel when migrating to a new kernel.\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\n///         interacted with and mutated through policies.\n/// @dev    Modules are installed and uninstalled via the executor.\nabstract contract Module is KernelAdapter {\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict which policies have access to module functions.\n    modifier permissioned() {\n        if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig))\n            revert Module_PolicyNotPermitted(msg.sender);\n        _;\n    }\n\n    /// @notice 5 byte identifier for a module.\n    function KEYCODE() public pure virtual returns (Keycode) {}\n\n    /// @notice Returns which semantic version of a module is being implemented.\n    /// @return major - Major version upgrade indicates breaking change to the interface.\n    /// @return minor - Minor version change retains backward-compatible interface.\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /// @notice Initialization function for the module\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\n    function INIT() external virtual onlyKernel {}\n}\n\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\nabstract contract Policy is KernelAdapter {\n    /// @notice Denote if a policy is activated or not.\n    bool public isActive;\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict policy function access to certain addresses with a role.\n    /// @dev    Roles are defined in the policy and set by the kernel admin.\n    modifier onlyRole(bytes32 role_) {\n        Role role = toRole(role_);\n        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);\n        _;\n    }\n\n    /// @notice Function to let kernel grant or revoke active status.\n    function setActiveStatus(bool activate_) external onlyKernel {\n        isActive = activate_;\n    }\n\n    /// @notice Function to grab module address from a given keycode.\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /// @notice Define module dependencies for this policy.\n    /// @return dependencies - Keycode array of module dependencies.\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\n\n    /// @notice Function called by kernel to set module function permissions.\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\n}\n\n/// @notice Main contract that acts as a central component registry for the protocol.\n/// @dev    The kernel manages modules, policies and defined roles. The kernel is mutated via predefined Actions,\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\ncontract Kernel {\n    /*//////////////////////////////////////////////////////////////\n                          PRIVILEGED ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\n    address public executor;\n\n    /// @notice Address that is responsible for assigning policy-defined roles to addresses.\n    address public admin;\n\n    /*//////////////////////////////////////////////////////////////\n                           MODULE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Array of all modules currently installed.\n    Keycode[] public allKeycodes;\n\n    /// @notice Mapping of module address to keycode.\n    mapping(Keycode => Module) public getModuleForKeycode;\n\n    /// @notice Mapping of keycode to module address.\n    mapping(Module => Keycode) public getKeycodeForModule;\n\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    /// @notice Module <> Policy Permissions.\n    /// @dev    Policy -> Keycode -> Function Selector -> bool for permission\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\n\n    /*//////////////////////////////////////////////////////////////\n                           POLICY MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of all active policies\n    Policy[] public activePolicies;\n\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    /// @notice Mapping for if an address has a policy-defined role.\n    mapping(address => mapping(Role => bool)) public hasRole;\n\n    /// @notice Mapping for if role exists.\n    mapping(Role => bool) public isRole;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PermissionsUpdated(\n        Keycode indexed keycode_,\n        Policy indexed policy_,\n        bytes4 funcSelector_,\n        bool granted_\n    );\n    event RoleGranted(Role indexed role_, address indexed addr_);\n    event RoleRevoked(Role indexed role_, address indexed addr_);\n    event ActionExecuted(Actions indexed action_, address indexed target_);\n\n    /*//////////////////////////////////////////////////////////////\n                              KERNEL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        executor = msg.sender;\n        admin = msg.sender;\n    }\n\n    /// @notice Modifier to check if caller is the executor.\n    modifier onlyExecutor() {\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n        _;\n    }\n\n    /// @notice Modifier to check if caller is the roles admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);\n        _;\n    }\n\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\n    function executeAction(Actions action_, address target_) external onlyExecutor {\n        if (action_ == Actions.InstallModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _installModule(Module(target_));\n        } else if (action_ == Actions.UpgradeModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _upgradeModule(Module(target_));\n        } else if (action_ == Actions.ActivatePolicy) {\n            ensureContract(target_);\n            _activatePolicy(Policy(target_));\n        } else if (action_ == Actions.DeactivatePolicy) {\n            ensureContract(target_);\n            _deactivatePolicy(Policy(target_));\n        } else if (action_ == Actions.ChangeExecutor) {\n            executor = target_;\n        } else if (action_ == Actions.ChangeAdmin) {\n            admin = target_;\n        } else if (action_ == Actions.MigrateKernel) {\n            ensureContract(target_);\n            _migrateKernel(Kernel(target_));\n        }\n\n        emit ActionExecuted(action_, target_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ACTIONS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _installModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n\n        if (address(getModuleForKeycode[keycode]) != address(0))\n            revert Kernel_ModuleAlreadyInstalled(keycode);\n\n        getModuleForKeycode[keycode] = newModule_;\n        getKeycodeForModule[newModule_] = keycode;\n        allKeycodes.push(keycode);\n\n        newModule_.INIT();\n    }\n\n    function _upgradeModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n        Module oldModule = getModuleForKeycode[keycode];\n\n        if (address(oldModule) == address(0) || oldModule == newModule_)\n            revert Kernel_InvalidModuleUpgrade(keycode);\n\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n        getKeycodeForModule[newModule_] = keycode;\n        getModuleForKeycode[keycode] = newModule_;\n\n        newModule_.INIT();\n\n        _reconfigurePolicies(keycode);\n    }\n\n    function _activatePolicy(Policy policy_) internal {\n        if (policy_.isActive()) revert Kernel_PolicyAlreadyActivated(address(policy_));\n\n        // Add policy to list of active policies\n        activePolicies.push(policy_);\n        getPolicyIndex[policy_] = activePolicies.length - 1;\n\n        // Record module dependencies\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depLength = dependencies.length;\n\n        for (uint256 i; i < depLength; ) {\n            Keycode keycode = dependencies[i];\n\n            moduleDependents[keycode].push(policy_);\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Grant permissions for policy to access restricted module functions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, true);\n\n        // Set policy status to active\n        policy_.setActiveStatus(true);\n    }\n\n    function _deactivatePolicy(Policy policy_) internal {\n        if (!policy_.isActive()) revert Kernel_PolicyNotActivated(address(policy_));\n\n        // Revoke permissions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, false);\n\n        // Remove policy from all policy data structures\n        uint256 idx = getPolicyIndex[policy_];\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\n\n        activePolicies[idx] = lastPolicy;\n        activePolicies.pop();\n        getPolicyIndex[lastPolicy] = idx;\n        delete getPolicyIndex[policy_];\n\n        // Remove policy from module dependents\n        _pruneFromDependents(policy_);\n\n        // Set policy status to inactive\n        policy_.setActiveStatus(false);\n    }\n\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\n    /// @dev    NOTE: Data does not get cleared from this kernel.\n    function _migrateKernel(Kernel newKernel_) internal {\n        uint256 keycodeLen = allKeycodes.length;\n        for (uint256 i; i < keycodeLen; ) {\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n            module.changeKernel(newKernel_);\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 policiesLen = activePolicies.length;\n        for (uint256 j; j < policiesLen; ) {\n            Policy policy = activePolicies[j];\n\n            // Deactivate before changing kernel\n            policy.setActiveStatus(false);\n            policy.changeKernel(newKernel_);\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _reconfigurePolicies(Keycode keycode_) internal {\n        Policy[] memory dependents = moduleDependents[keycode_];\n        uint256 depLength = dependents.length;\n\n        for (uint256 i; i < depLength; ) {\n            dependents[i].configureDependencies();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _setPolicyPermissions(\n        Policy policy_,\n        Permissions[] memory requests_,\n        bool grant_\n    ) internal {\n        uint256 reqLength = requests_.length;\n        for (uint256 i = 0; i < reqLength; ) {\n            Permissions memory request = requests_[i];\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _pruneFromDependents(Policy policy_) internal {\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depcLength = dependencies.length;\n\n        for (uint256 i; i < depcLength; ) {\n            Keycode keycode = dependencies[i];\n            Policy[] storage dependents = moduleDependents[keycode];\n\n            uint256 origIndex = getDependentIndex[keycode][policy_];\n            Policy lastPolicy = dependents[dependents.length - 1];\n\n            // Swap with last and pop\n            dependents[origIndex] = lastPolicy;\n            dependents.pop();\n\n            // Record new index and delete deactivated policy index\n            getDependentIndex[keycode][lastPolicy] = origIndex;\n            delete getDependentIndex[keycode][policy_];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ROLES ADMIN FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function to grant policy-defined roles to some address. Can only be called by admin.\n    function grantRole(Role role_, address addr_) public onlyAdmin {\n        if (hasRole[addr_][role_]) revert Kernel_AddressAlreadyHasRole(addr_, role_);\n\n        ensureValidRole(role_);\n        if (!isRole[role_]) isRole[role_] = true;\n\n        hasRole[addr_][role_] = true;\n\n        emit RoleGranted(role_, addr_);\n    }\n\n    /// @notice Function to revoke policy-defined roles from some address. Can only be called by admin.\n    function revokeRole(Role role_, address addr_) public onlyAdmin {\n        if (!isRole[role_]) revert Kernel_RoleDoesNotExist(role_);\n        if (!hasRole[addr_][role_]) revert Kernel_AddressDoesNotHaveRole(addr_, role_);\n\n        hasRole[addr_][role_] = false;\n\n        emit RoleRevoked(role_, addr_);\n    }\n}\n\n\n",
        "CodeNames": [
            "INSTR.sol",
            "Kernel.t.sol",
            "INSTR.t.sol",
            "Kernel.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "executeAction function in Kernel.sol and store function in INSTR.sol",
                "Type": "Admin cannot be changed to EOA after deployment",
                "Description": "After contracts are deployed and initialized, the admin address in Kernel contract can only be set to a contract.",
                "Repair": "Allow EOA addresses as instruction targets or disallow non-contract admin addresses."
            }
        ]
    }
]