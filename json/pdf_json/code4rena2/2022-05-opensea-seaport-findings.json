[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\n\n// prettier-ignore\nimport {\n    OrderType,\n    ItemType,\n    BasicOrderRouteType\n} from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    AdditionalRecipient,\n    BasicOrderParameters,\n    OfferItem,\n    ConsiderationItem,\n    SpentItem,\n    ReceivedItem\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderValidator } from \"./OrderValidator.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title BasicOrderFulfiller\n * @author 0age\n * @notice BasicOrderFulfiller contains functionality for fulfilling \"basic\"\n *         orders with minimal overhead. See documentation for details on what\n *         qualifies as a basic order.\n */\ncontract BasicOrderFulfiller is OrderValidator {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderValidator(conduitController) {}\n\n    /**\n     * @dev Internal function to fulfill an order offering an ERC20, ERC721, or\n     *      ERC1155 item by supplying Ether (or other native tokens), ERC20\n     *      tokens, an ERC721 item, or an ERC1155 item as consideration. Six\n     *      permutations are supported: Native token to ERC721, Native token to\n     *      ERC1155, ERC20 to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and\n     *      ERC1155 to ERC20 (with native tokens supplied as msg.value). For an\n     *      order to be eligible for fulfillment via this method, it must\n     *      contain a single offer item (though that item may have a greater\n     *      amount if the item is not an ERC721). An arbitrary number of\n     *      \"additional recipients\" may also be supplied which will each receive\n     *      native tokens or ERC20 items from the fulfiller as consideration.\n     *      Refer to the documentation for a more comprehensive summary of how\n     *      to utilize this method and what orders are compatible with it.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer and the fulfiller must first approve\n     *                   this contract (or their chosen conduit if indicated)\n     *                   before any tokens can be transferred. Also note that\n     *                   contract recipients of ERC1155 consideration items must\n     *                   implement `onERC1155Received` in order to receive those\n     *                   items.\n     *\n     * @return A boolean indicating whether the order has been fulfilled.\n     */\n    function _validateAndFulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) internal returns (bool) {\n        // Declare enums for order type & route to extract from basicOrderType.\n        BasicOrderRouteType route;\n        OrderType orderType;\n\n        // Declare additional recipient item type to derive from the route type.\n        ItemType additionalRecipientsItemType;\n\n        // Utilize assembly to extract the order type and the basic order route.\n        assembly {\n            // Mask all but 2 least-significant bits to derive the order type.\n            orderType := and(calldataload(BasicOrder_basicOrderType_cdPtr), 3)\n\n            // Divide basicOrderType by four to derive the route.\n            route := div(calldataload(BasicOrder_basicOrderType_cdPtr), 4)\n\n            // If route > 1 additionalRecipient items are ERC20 (1) else Eth (0)\n            additionalRecipientsItemType := gt(route, 1)\n        }\n\n        {\n            // Declare temporary variable for enforcing payable status.\n            bool correctPayableStatus;\n\n            // Utilize assembly to compare the route to the callvalue.\n            assembly {\n                // route 0 and 1 are payable, otherwise route is not payable.\n                correctPayableStatus := eq(\n                    additionalRecipientsItemType,\n                    iszero(callvalue())\n                )\n            }\n\n            // Revert if msg.value has not been supplied as part of payable\n            // routes or has been supplied as part of non-payable routes.\n            if (!correctPayableStatus) {\n                revert InvalidMsgValue(msg.value);\n            }\n        }\n\n        // Declare more arguments that will be derived from route and calldata.\n        address additionalRecipientsToken;\n        ItemType receivedItemType;\n        ItemType offeredItemType;\n\n        // Utilize assembly to retrieve function arguments and cast types.\n        assembly {\n            // Determine if offered item type == additional recipient item type.\n            let offerTypeIsAdditionalRecipientsType := gt(route, 3)\n\n            // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24.\n            additionalRecipientsToken := calldataload(\n                add(\n                    BasicOrder_considerationToken_cdPtr,\n                    mul(offerTypeIsAdditionalRecipientsType, FiveWords)\n                )\n            )\n\n            // If route > 2, receivedItemType is route - 2. If route is 2, then\n            // receivedItemType is ERC20 (1). Otherwise, it is Eth (0).\n            receivedItemType := add(\n                mul(sub(route, 2), gt(route, 2)),\n                eq(route, 2)\n            )\n\n            // If route > 3, offeredItemType is ERC20 (1). If route is 2 or 3,\n            // offeredItemType = route. If route is 0 or 1, it is route + 2.\n            offeredItemType := sub(\n                add(route, mul(iszero(additionalRecipientsItemType), 2)),\n                mul(\n                    offerTypeIsAdditionalRecipientsType,\n                    add(receivedItemType, 1)\n                )\n            )\n        }\n\n        // Derive & validate order using parameters and update order status.\n        _prepareBasicFulfillmentFromCalldata(\n            parameters,\n            orderType,\n            receivedItemType,\n            additionalRecipientsItemType,\n            additionalRecipientsToken,\n            offeredItemType\n        );\n\n        // Read offerer from calldata and place on the stack.\n        address payable offerer = parameters.offerer;\n\n        // Declare conduitKey argument used by transfer functions.\n        bytes32 conduitKey;\n\n        // Utilize assembly to derive conduit (if relevant) based on route.\n        assembly {\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\n            conduitKey := calldataload(\n                add(BasicOrder_offererConduit_cdPtr, mul(gt(route, 3), OneWord))\n            )\n        }\n\n        // Transfer tokens based on the route.\n        if (additionalRecipientsItemType == ItemType.NATIVE) {\n            _transferIndividual721Or1155Item(\n                offeredItemType,\n                parameters.offerToken,\n                offerer,\n                msg.sender,\n                parameters.offerIdentifier,\n                parameters.offerAmount,\n                conduitKey\n            );\n\n            // Transfer native to recipients, return excess to caller & wrap up.\n            _transferEthAndFinalize(\n                parameters.considerationAmount,\n                offerer,\n                parameters.additionalRecipients\n            );\n        } else {\n            // Initialize an accumulator array. From this point forward, no new\n            // memory regions can be safely allocated until the accumulator is\n            // no longer being utilized, as the accumulator operates in an\n            // open-ended fashion from this memory pointer; existing memory may\n            // still be accessed and modified, however.\n            bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n            if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\n                // Transfer ERC721 to caller using offerer's conduit preference.\n                _transferERC721(\n                    parameters.offerToken,\n                    offerer,\n                    msg.sender,\n                    parameters.offerIdentifier,\n                    parameters.offerAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    msg.sender,\n                    offerer,\n                    parameters.considerationToken,\n                    parameters.considerationAmount,\n                    parameters.additionalRecipients,\n                    false, // Send full amount indicated by consideration items.\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\n                // Transfer ERC1155 to caller with offerer's conduit preference.\n                _transferERC1155(\n                    parameters.offerToken,\n                    offerer,\n                    msg.sender,\n                    parameters.offerIdentifier,\n                    parameters.offerAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    msg.sender,\n                    offerer,\n                    parameters.considerationToken,\n                    parameters.considerationAmount,\n                    parameters.additionalRecipients,\n                    false, // Send full amount indicated by consideration items.\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\n                // Transfer ERC721 to offerer using caller's conduit preference.\n                _transferERC721(\n                    parameters.considerationToken,\n                    msg.sender,\n                    offerer,\n                    parameters.considerationIdentifier,\n                    parameters.considerationAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    offerer,\n                    msg.sender,\n                    parameters.offerToken,\n                    parameters.offerAmount,\n                    parameters.additionalRecipients,\n                    true, // Reduce fulfiller amount sent by additional amounts.\n                    accumulator\n                );\n            } else {\n                // route == BasicOrderRouteType.ERC1155_TO_ERC20\n\n                // Transfer ERC1155 to offerer with caller's conduit preference.\n                _transferERC1155(\n                    parameters.considerationToken,\n                    msg.sender,\n                    offerer,\n                    parameters.considerationIdentifier,\n                    parameters.considerationAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    offerer,\n                    msg.sender,\n                    parameters.offerToken,\n                    parameters.offerAmount,\n                    parameters.additionalRecipients,\n                    true, // Reduce fulfiller amount sent by additional amounts.\n                    accumulator\n                );\n            }\n\n            // Trigger any remaining accumulated transfers via call to conduit.\n            _triggerIfArmed(accumulator);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function to prepare fulfillment of a basic order with\n     *      manual calldata and memory access. This calculates the order hash,\n     *      emits an OrderFulfilled event, and asserts basic order validity.\n     *      Note that calldata offsets must be validated as this function\n     *      accesses constant calldata pointers for dynamic types that match\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\n     *      offsets. Checking that the offsets were produced by default encoding\n     *      will ensure that other functions using Solidity's calldata accessors\n     *      (which calculate pointers from the stored offsets) are reading the\n     *      same data as the order hash is derived from. Also note that This\n     *      function accesses memory directly. It does not clear the expanded\n     *      memory regions used, nor does it update the free memory pointer, so\n     *      other direct memory access must not assume that unused memory is\n     *      empty.\n     *\n     * @param parameters                   The parameters of the basic order.\n     * @param orderType                    The order type.\n     * @param receivedItemType             The item type of the initial\n     *                                     consideration item on the order.\n     * @param additionalRecipientsItemType The item type of any additional\n     *                                     consideration item on the order.\n     * @param additionalRecipientsToken    The ERC20 token contract address (if\n     *                                     applicable) for any additional\n     *                                     consideration item on the order.\n     * @param offeredItemType              The item type of the offered item on\n     *                                     the order.\n     */\n    function _prepareBasicFulfillmentFromCalldata(\n        BasicOrderParameters calldata parameters,\n        OrderType orderType,\n        ItemType receivedItemType,\n        ItemType additionalRecipientsItemType,\n        address additionalRecipientsToken,\n        ItemType offeredItemType\n    ) internal {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard();\n\n        // Ensure current timestamp falls between order start time and end time.\n        _verifyTime(parameters.startTime, parameters.endTime, true);\n\n        // Verify that calldata offsets for all dynamic types were produced by\n        // default encoding. This ensures that the constants we use for calldata\n        // pointers to dynamic types are the same as those calculated by\n        // Solidity using their offsets.\n        _assertValidBasicOrderParameterOffsets();\n\n        // Ensure supplied consideration array length is not less than original.\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n            parameters.additionalRecipients.length + 1,\n            parameters.totalOriginalAdditionalRecipients\n        );\n\n        // Declare stack element for the order hash.\n        bytes32 orderHash;\n\n        {\n            /**\n             * First, handle consideration items. Memory Layout:\n             *  0x60: final hash of the array of consideration item hashes\n             *  0x80-0x160: reused space for EIP712 hashing of each item\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\n             *   - 0xa0: itemType\n             *   - 0xc0: token\n             *   - 0xe0: identifier\n             *   - 0x100: startAmount\n             *   - 0x120: endAmount\n             *   - 0x140: recipient\n             *  0x160-END_ARR: array of consideration item hashes\n             *   - 0x160: primary consideration item EIP712 hash\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\n             *  END_ARR: beginning of data for OrderFulfilled event\n             *   - END_ARR + 0x120: length of ReceivedItem array\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\n             */\n\n            // Load consideration item typehash from runtime and place on stack.\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\n\n            // Utilize assembly to enable reuse of memory regions and use\n            // constant pointers when possible.\n            assembly {\n                /*\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\n                 * primary consideration item of the basic order.\n                 */\n\n                // Write ConsiderationItem type hash and item type to memory.\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    receivedItemType\n                )\n\n                // Copy calldata region with (token, identifier, amount) from\n                // BasicOrderParameters to ConsiderationItem. The\n                // considerationAmount is written to startAmount and endAmount\n                // as basic orders do not have dynamic amounts.\n                calldatacopy(\n                    BasicOrder_considerationItem_token_ptr,\n                    BasicOrder_considerationToken_cdPtr,\n                    ThreeWords\n                )\n\n                // Copy calldata region with considerationAmount and offerer\n                // from BasicOrderParameters to endAmount and recipient in\n                // ConsiderationItem.\n                calldatacopy(\n                    BasicOrder_considerationItem_endAmount_ptr,\n                    BasicOrder_considerationAmount_cdPtr,\n                    TwoWords\n                )\n\n                // Calculate EIP712 ConsiderationItem hash and store it in the\n                // array of EIP712 consideration hashes.\n                mstore(\n                    BasicOrder_considerationHashesArray_ptr,\n                    keccak256(\n                        BasicOrder_considerationItem_typeHash_ptr,\n                        EIP712_ConsiderationItem_size\n                    )\n                )\n\n                /*\n                 * 2. Write a ReceivedItem struct for the primary consideration\n                 * item to the consideration array in OrderFulfilled.\n                 */\n\n                // Get the length of the additional recipients array.\n                let totalAdditionalRecipients := calldataload(\n                    BasicOrder_additionalRecipients_length_cdPtr\n                )\n\n                // Calculate pointer to length of OrderFulfilled consideration\n                // array.\n                let eventConsiderationArrPtr := add(\n                    OrderFulfilled_consideration_length_baseOffset,\n                    mul(totalAdditionalRecipients, OneWord)\n                )\n\n                // Set the length of the consideration array to the number of\n                // additional recipients, plus one for the primary consideration\n                // item.\n                mstore(\n                    eventConsiderationArrPtr,\n                    add(\n                        calldataload(\n                            BasicOrder_additionalRecipients_length_cdPtr\n                        ),\n                        1\n                    )\n                )\n\n                // Overwrite the consideration array pointer so it points to the\n                // body of the first element\n                eventConsiderationArrPtr := add(\n                    eventConsiderationArrPtr,\n                    OneWord\n                )\n\n                // Set itemType at start of the ReceivedItem memory region.\n                mstore(eventConsiderationArrPtr, receivedItemType)\n\n                // Copy calldata region (token, identifier, amount & recipient)\n                // from BasicOrderParameters to ReceivedItem memory.\n                calldatacopy(\n                    add(eventConsiderationArrPtr, Common_token_offset),\n                    BasicOrder_considerationToken_cdPtr,\n                    FourWords\n                )\n\n                /*\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\n                 * additional recipients and add a ReceivedItem for each to the\n                 * consideration array in the OrderFulfilled event. The original\n                 * additional recipients are all the considerations signed by\n                 * the offerer aside from the primary consideration of the\n                 * order. Uses memory region from 0x80-0x160 as a buffer for\n                 * calculating EIP712 ConsiderationItem hashes.\n                 */\n\n                // Put pointer to consideration hashes array on the stack.\n                // This will be updated as each additional recipient is hashed\n                let\n                    considerationHashesPtr\n                := BasicOrder_considerationHashesArray_ptr\n\n                // Write item type, token, & identifier for additional recipient\n                // to memory region for hashing EIP712 ConsiderationItem; these\n                // values will be reused for each recipient.\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    additionalRecipientsItemType\n                )\n                mstore(\n                    BasicOrder_considerationItem_token_ptr,\n                    additionalRecipientsToken\n                )\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\n\n                // Read length of the additionalRecipients array from calldata\n                // and iterate.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\n                )\n                let i := 0\n                // prettier-ignore\n                for {} lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    /*\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\n                     */\n\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        mul(AdditionalRecipients_size, i)\n                    )\n\n                    // Copy startAmount from calldata to the ConsiderationItem\n                    // struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_startAmount_ptr,\n                        additionalRecipientCdPtr,\n                        OneWord\n                    )\n\n                    // Copy endAmount and recipient from calldata to the\n                    // ConsiderationItem struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_endAmount_ptr,\n                        additionalRecipientCdPtr,\n                        AdditionalRecipients_size\n                    )\n\n                    // Add 1 word to the pointer as part of each loop to reduce\n                    // operations needed to get local offset into the array.\n                    considerationHashesPtr := add(\n                        considerationHashesPtr,\n                        OneWord\n                    )\n\n                    // Calculate EIP712 ConsiderationItem hash and store it in\n                    // the array of consideration hashes.\n                    mstore(\n                        considerationHashesPtr,\n                        keccak256(\n                            BasicOrder_considerationItem_typeHash_ptr,\n                            EIP712_ConsiderationItem_size\n                        )\n                    )\n\n                    /*\n                     * Write ReceivedItem to OrderFulfilled data.\n                     */\n\n                    // At this point, eventConsiderationArrPtr points to the\n                    // beginning of the ReceivedItem struct of the previous\n                    // element in the array. Increase it by the size of the\n                    // struct to arrive at the pointer for the current element.\n                    eventConsiderationArrPtr := add(\n                        eventConsiderationArrPtr,\n                        ReceivedItem_size\n                    )\n\n                    // Write itemType to the ReceivedItem struct.\n                    mstore(\n                        eventConsiderationArrPtr,\n                        additionalRecipientsItemType\n                    )\n\n                    // Write token to the next word of the ReceivedItem struct.\n                    mstore(\n                        add(eventConsiderationArrPtr, OneWord),\n                        additionalRecipientsToken\n                    )\n\n                    // Copy endAmount & recipient words to ReceivedItem struct.\n                    calldatacopy(\n                        add(\n                            eventConsiderationArrPtr,\n                            ReceivedItem_amount_offset\n                        ),\n                        additionalRecipientCdPtr,\n                        TwoWords\n                    )\n                }\n\n                /*\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\n                 * Note that it is set at 0x60 \u2014 all other memory begins at\n                 * 0x80. 0x60 is the \"zero slot\" and will be restored at the end\n                 * of the assembly section and before required by the compiler.\n                 */\n                mstore(\n                    receivedItemsHash_ptr,\n                    keccak256(\n                        BasicOrder_considerationHashesArray_ptr,\n                        mul(add(totalAdditionalRecipients, 1), OneWord)\n                    )\n                )\n\n                /*\n                 * 5. Add a ReceivedItem for each tip to the consideration array\n                 * in the OrderFulfilled event. The tips are all the\n                 * consideration items that were not signed by the offerer and\n                 * were provided by the fulfiller.\n                 */\n\n                // Overwrite length to length of the additionalRecipients array.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_additionalRecipients_length_cdPtr\n                )\n                // prettier-ignore\n                for {} lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        mul(AdditionalRecipients_size, i)\n                    )\n\n                    // At this point, eventConsiderationArrPtr points to the\n                    // beginning of the ReceivedItem struct of the previous\n                    // element in the array. Increase it by the size of the\n                    // struct to arrive at the pointer for the current element.\n                    eventConsiderationArrPtr := add(\n                        eventConsiderationArrPtr,\n                        ReceivedItem_size\n                    )\n\n                    // Write itemType to the ReceivedItem struct.\n                    mstore(\n                        eventConsiderationArrPtr,\n                        additionalRecipientsItemType\n                    )\n\n                    // Write token to the next word of the ReceivedItem struct.\n                    mstore(\n                        add(eventConsiderationArrPtr, OneWord),\n                        additionalRecipientsToken\n                    )\n\n                    // Copy endAmount & recipient words to ReceivedItem struct.\n                    calldatacopy(\n                        add(\n                            eventConsiderationArrPtr,\n                            ReceivedItem_amount_offset\n                        ),\n                        additionalRecipientCdPtr,\n                        TwoWords\n                    )\n                }\n            }\n        }\n\n        {\n            /**\n             * Next, handle offered items. Memory Layout:\n             *  EIP712 data for OfferItem\n             *   - 0x80:  OfferItem EIP-712 typehash (constant)\n             *   - 0xa0:  itemType\n             *   - 0xc0:  token\n             *   - 0xe0:  identifier (reused for offeredItemsHash)\n             *   - 0x100: startAmount\n             *   - 0x120: endAmount\n             */\n\n            // Place offer item typehash on the stack.\n            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\n\n            // Utilize assembly to enable reuse of memory regions when possible.\n            assembly {\n                /*\n                 * 1. Calculate OfferItem EIP712 hash\n                 */\n\n                // Write the OfferItem typeHash to memory.\n                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)\n\n                // Write the OfferItem item type to memory.\n                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)\n\n                // Copy calldata region with (offerToken, offerIdentifier,\n                // offerAmount) from OrderParameters to (token, identifier,\n                // startAmount) in OfferItem struct. The offerAmount is written\n                // to startAmount and endAmount as basic orders do not have\n                // dynamic amounts.\n                calldatacopy(\n                    BasicOrder_offerItem_token_ptr,\n                    BasicOrder_offerToken_cdPtr,\n                    ThreeWords\n                )\n\n                // Copy offerAmount from calldata to endAmount in OfferItem\n                // struct.\n                calldatacopy(\n                    BasicOrder_offerItem_endAmount_ptr,\n                    BasicOrder_offerAmount_cdPtr,\n                    OneWord\n                )\n\n                // Compute EIP712 OfferItem hash, write result to scratch space:\n                //   `keccak256(abi.encode(offeredItem))`\n                mstore(\n                    0,\n                    keccak256(\n                        BasicOrder_offerItem_typeHash_ptr,\n                        EIP712_OfferItem_size\n                    )\n                )\n\n                /*\n                 * 2. Calculate hash of array of EIP712 hashes and write the\n                 * result to the corresponding OfferItem struct:\n                 *   `keccak256(abi.encodePacked(offerItemHashes))`\n                 */\n                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0, OneWord))\n\n                /*\n                 * 3. Write SpentItem to offer array in OrderFulfilled event.\n                 */\n                let eventConsiderationArrPtr := add(\n                    OrderFulfilled_offer_length_baseOffset,\n                    mul(\n                        calldataload(\n                            BasicOrder_additionalRecipients_length_cdPtr\n                        ),\n                        OneWord\n                    )\n                )\n\n                // Set a length of 1 for the offer array.\n                mstore(eventConsiderationArrPtr, 1)\n\n                // Write itemType to the SpentItem struct.\n                mstore(add(eventConsiderationArrPtr, OneWord), offeredItemType)\n\n                // Copy calldata region with (offerToken, offerIdentifier,\n                // offerAmount) from OrderParameters to (token, identifier,\n                // amount) in SpentItem struct.\n                calldatacopy(\n                    add(eventConsiderationArrPtr, AdditionalRecipients_size),\n                    BasicOrder_offerToken_cdPtr,\n                    ThreeWords\n                )\n            }\n        }\n\n        {\n            /**\n             * Once consideration items and offer items have been handled,\n             * derive the final order hash. Memory Layout:\n             *  0x80-0x1c0: EIP712 data for order\n             *   - 0x80:   Order EIP-712 typehash (constant)\n             *   - 0xa0:   orderParameters.offerer\n             *   - 0xc0:   orderParameters.zone\n             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\n             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\n             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)\n             *   - 0x140:  orderParameters.startTime\n             *   - 0x160:  orderParameters.endTime\n             *   - 0x180:  orderParameters.zoneHash\n             *   - 0x1a0:  orderParameters.salt\n             *   - 0x1c0:  orderParameters.conduitKey\n             *   - 0x1e0:  _nonces[orderParameters.offerer] (from storage)\n             */\n\n            // Read the offerer from calldata and place on the stack.\n            address offerer;\n            assembly {\n                offerer := calldataload(BasicOrder_offerer_cdPtr)\n            }\n\n            // Read offerer's current nonce from storage and place on the stack.\n            uint256 nonce = _getNonce(offerer);\n\n            // Load order typehash from runtime code and place on stack.\n            bytes32 typeHash = _ORDER_TYPEHASH;\n\n            assembly {\n                // Set the OrderItem typeHash in memory.\n                mstore(BasicOrder_order_typeHash_ptr, typeHash)\n\n                // Copy offerer and zone from OrderParameters in calldata to the\n                // Order struct.\n                calldatacopy(\n                    BasicOrder_order_offerer_ptr,\n                    BasicOrder_offerer_cdPtr,\n                    TwoWords\n                )\n\n                // Copy receivedItemsHash from zero slot to the Order struct.\n                mstore(\n                    BasicOrder_order_considerationHashes_ptr,\n                    mload(receivedItemsHash_ptr)\n                )\n\n                // Write the supplied orderType to the Order struct.\n                mstore(BasicOrder_order_orderType_ptr, orderType)\n\n                // Copy startTime, endTime, zoneHash, salt & conduit from\n                // calldata to the Order struct.\n                calldatacopy(\n                    BasicOrder_order_startTime_ptr,\n                    BasicOrder_startTime_cdPtr,\n                    FiveWords\n                )\n\n                // Take offerer's nonce retrieved from storage, write to struct.\n                mstore(BasicOrder_order_nonce_ptr, nonce)\n\n                // Compute the EIP712 Order hash.\n                orderHash := keccak256(\n                    BasicOrder_order_typeHash_ptr,\n                    EIP712_Order_size\n                )\n            }\n        }\n\n        assembly {\n            /**\n             * After the order hash has been derived, emit OrderFulfilled event:\n             *   event OrderFulfilled(\n             *     bytes32 orderHash,\n             *     address indexed offerer,\n             *     address indexed zone,\n             *     address fulfiller,\n             *     SpentItem[] offer,\n             *       > (itemType, token, id, amount)\n             *     ReceivedItem[] consideration\n             *       > (itemType, token, id, amount, recipient)\n             *   )\n             * topic0 - OrderFulfilled event signature\n             * topic1 - offerer\n             * topic2 - zone\n             * data:\n             *  - 0x00: orderHash\n             *  - 0x20: fulfiller\n             *  - 0x40: offer arr ptr (0x80)\n             *  - 0x60: consideration arr ptr (0x120)\n             *  - 0x80: offer arr len (1)\n             *  - 0xa0: offer.itemType\n             *  - 0xc0: offer.token\n             *  - 0xe0: offer.identifier\n             *  - 0x100: offer.amount\n             *  - 0x120: 1 + recipients.length\n             *  - 0x140: recipient 0\n             */\n\n            // Derive pointer to start of OrderFulfilled event data\n            let eventDataPtr := add(\n                OrderFulfilled_baseOffset,\n                mul(\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\n                    OneWord\n                )\n            )\n\n            // Write the order hash to the head of the event's data region.\n            mstore(eventDataPtr, orderHash)\n\n            // Write the fulfiller (i.e. the caller) next.\n            mstore(add(eventDataPtr, OrderFulfilled_fulfiller_offset), caller())\n\n            // Write the SpentItem and ReceivedItem array offsets (constants).\n            mstore(\n                // SpentItem array offset\n                add(eventDataPtr, OrderFulfilled_offer_head_offset),\n                OrderFulfilled_offer_body_offset\n            )\n            mstore(\n                // ReceivedItem array offset\n                add(eventDataPtr, OrderFulfilled_consideration_head_offset),\n                OrderFulfilled_consideration_body_offset\n            )\n\n            // Derive total data size including SpentItem and ReceivedItem data.\n            // SpentItem portion is already included in the baseSize constant,\n            // as there can only be one element in the array.\n            let dataSize := add(\n                OrderFulfilled_baseSize,\n                mul(\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\n                    ReceivedItem_size\n                )\n            )\n\n            // Emit OrderFulfilled log with three topics (the event signature\n            // as well as the two indexed arguments, the offerer and the zone).\n            log3(\n                // Supply the pointer for event data in memory.\n                eventDataPtr,\n                // Supply the size of event data in memory.\n                dataSize,\n                // Supply the OrderFulfilled event signature.\n                OrderFulfilled_selector,\n                // Supply the first topic (the offerer).\n                calldataload(BasicOrder_offerer_cdPtr),\n                // Supply the second topic (the zone).\n                calldataload(BasicOrder_zone_cdPtr)\n            )\n\n            // Restore the zero slot.\n            mstore(ZeroSlot, 0)\n        }\n\n        // Determine whether order is restricted and, if so, that it is valid.\n        _assertRestrictedBasicOrderValidity(\n            orderHash,\n            parameters.zoneHash,\n            orderType,\n            parameters.offerer,\n            parameters.zone\n        );\n\n        // Verify and update the status of the derived order.\n        _validateBasicOrderAndUpdateStatus(\n            orderHash,\n            parameters.offerer,\n            parameters.signature\n        );\n    }\n\n    /**\n     * @dev Internal function to transfer Ether (or other native tokens) to a\n     *      given recipient as part of basic order fulfillment. Note that\n     *      conduits are not utilized for native tokens as the transferred\n     *      amount must be provided as msg.value.\n     *\n     * @param amount               The amount to transfer.\n     * @param to                   The recipient of the native token transfer.\n     * @param additionalRecipients The additional recipients of the order.\n     */\n    function _transferEthAndFinalize(\n        uint256 amount,\n        address payable to,\n        AdditionalRecipient[] calldata additionalRecipients\n    ) internal {\n        // Put ether value supplied by the caller on the stack.\n        uint256 etherRemaining = msg.value;\n\n        // Retrieve total number of additional recipients and place on stack.\n        uint256 totalAdditionalRecipients = additionalRecipients.length;\n\n        // Iterate over each additional recipient.\n        for (uint256 i = 0; i < totalAdditionalRecipients; ) {\n            // Retrieve the additional recipient.\n            AdditionalRecipient calldata additionalRecipient = (\n                additionalRecipients[i]\n            );\n\n            // Read ether amount to transfer to recipient and place on stack.\n            uint256 additionalRecipientAmount = additionalRecipient.amount;\n\n            // Ensure that sufficient Ether is available.\n            if (additionalRecipientAmount > etherRemaining) {\n                revert InsufficientEtherSupplied();\n            }\n\n            // Transfer Ether to the additional recipient.\n            _transferEth(\n                additionalRecipient.recipient,\n                additionalRecipientAmount\n            );\n\n            // Skip underflow check as subtracted value is less than remaining.\n            unchecked {\n                // Reduce ether value available.\n                etherRemaining -= additionalRecipientAmount;\n            }\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Ensure that sufficient Ether is still available.\n        if (amount > etherRemaining) {\n            revert InsufficientEtherSupplied();\n        }\n\n        // Transfer Ether to the offerer.\n        _transferEth(to, amount);\n\n        // If any Ether remains after transfers, return it to the caller.\n        if (etherRemaining > amount) {\n            // Skip underflow check as etherRemaining > amount.\n            unchecked {\n                // Transfer remaining Ether to the caller.\n                _transferEth(payable(msg.sender), etherRemaining - amount);\n            }\n        }\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    /**\n     * @dev Internal function to transfer ERC20 tokens to a given recipient as\n     *      part of basic order fulfillment.\n     *\n     * @param from                 The originator of the ERC20 token transfer.\n     * @param to                   The recipient of the ERC20 token transfer.\n     * @param erc20Token           The ERC20 token to transfer.\n     * @param amount               The amount of ERC20 tokens to transfer.\n     * @param additionalRecipients The additional recipients of the order.\n     * @param fromOfferer          A boolean indicating whether to decrement\n     *                             amount from the offered amount.\n     */\n    function _transferERC20AndFinalize(\n        address from,\n        address to,\n        address erc20Token,\n        uint256 amount,\n        AdditionalRecipient[] calldata additionalRecipients,\n        bool fromOfferer,\n        bytes memory accumulator\n    ) internal {\n        // Determine the appropriate conduit to utilize.\n        bytes32 conduitKey;\n\n        // Utilize assembly to derive conduit (if relevant) based on route.\n        assembly {\n            // use offerer conduit if fromOfferer, fulfiller conduit otherwise.\n            conduitKey := calldataload(\n                sub(\n                    BasicOrder_fulfillerConduit_cdPtr,\n                    mul(fromOfferer, OneWord)\n                )\n            )\n        }\n\n        // Retrieve total number of additional recipients and place on stack.\n        uint256 totalAdditionalRecipients = additionalRecipients.length;\n\n        // Iterate over each additional recipient.\n        for (uint256 i = 0; i < totalAdditionalRecipients; ) {\n            // Retrieve the additional recipient.\n            AdditionalRecipient calldata additionalRecipient = (\n                additionalRecipients[i]\n            );\n\n            uint256 additionalRecipientAmount = additionalRecipient.amount;\n\n            // Decrement the amount to transfer to fulfiller if indicated.\n            if (fromOfferer) {\n                amount -= additionalRecipientAmount;\n            }\n\n            // Transfer ERC20 tokens to additional recipient given approval.\n            _transferERC20(\n                erc20Token,\n                from,\n                additionalRecipient.recipient,\n                additionalRecipientAmount,\n                conduitKey,\n                accumulator\n            );\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Transfer ERC20 token amount (from account must have proper approval).\n        _transferERC20(erc20Token, from, to, amount, conduitKey, accumulator);\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n}\n\n\n",
        "CodeNames": [
            "BasicOrderFulfiller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_prepareBasicFulfillmentFromCalldata function in BasicOrderFulfiller.sol",
                "Type": "Incorrect assertion",
                "Description": "The assertion _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength in the _prepareBasicFulfillmentFromCalldata function is incorrect and can be exploited to fulfill an order without trading the last consideration item in the list.",
                "Repair": "Remove the +1 at L347"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ItemType, Side } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OfferItem,\n    ConsiderationItem,\n    ReceivedItem,\n    OrderParameters,\n    AdvancedOrder,\n    Execution,\n    FulfillmentComponent\n} from \"./ConsiderationStructs.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n// prettier-ignore\nimport {\n    FulfillmentApplicationErrors\n} from \"../interfaces/FulfillmentApplicationErrors.sol\";\n\n/**\n * @title FulfillmentApplier\n * @author 0age\n * @notice FulfillmentApplier contains logic related to applying fulfillments,\n *         both as part of order matching (where offer items are matched to\n *         consideration items) as well as fulfilling available orders (where\n *         order items and consideration items are independently aggregated).\n */\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\n    /**\n     * @dev Internal view function to match offer items to consideration items\n     *      on a group of orders via a supplied fulfillment.\n     *\n     * @param advancedOrders          The orders to match.\n     * @param offerComponents         An array designating offer components to\n     *                                match to consideration components.\n     * @param considerationComponents An array designating consideration\n     *                                components to match to offer components.\n     *                                Note that each consideration amount must\n     *                                be zero in order for the match operation\n     *                                to be valid.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _applyFulfillment(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] calldata offerComponents,\n        FulfillmentComponent[] calldata considerationComponents\n    ) internal view returns (Execution memory execution) {\n        // Ensure 1+ of both offer and consideration components are supplied.\n        if (\n            offerComponents.length == 0 || considerationComponents.length == 0\n        ) {\n            revert OfferAndConsiderationRequiredOnFulfillment();\n        }\n\n        // Declare a new Execution struct.\n        Execution memory considerationExecution;\n\n        // Validate & aggregate consideration items to new Execution object.\n        _aggregateValidFulfillmentConsiderationItems(\n            advancedOrders,\n            considerationComponents,\n            considerationExecution\n        );\n\n        // Retrieve the consideration item from the execution struct.\n        ReceivedItem memory considerationItem = considerationExecution.item;\n\n        // Validate & aggregate offer items to Execution object.\n        _aggregateValidFulfillmentOfferItems(\n            advancedOrders,\n            offerComponents,\n            execution\n        );\n\n        // Ensure offer and consideration share types, tokens and identifiers.\n        if (\n            execution.item.itemType != considerationItem.itemType ||\n            execution.item.token != considerationItem.token ||\n            execution.item.identifier != considerationItem.identifier\n        ) {\n            revert MismatchedFulfillmentOfferAndConsiderationComponents();\n        }\n\n        // If total consideration amount exceeds the offer amount...\n        if (considerationItem.amount > execution.item.amount) {\n            // Retrieve the first consideration component from the fulfillment.\n            FulfillmentComponent memory targetComponent = (\n                considerationComponents[0]\n            );\n\n            // Add excess consideration item amount to original array of orders.\n            advancedOrders[targetComponent.orderIndex]\n                .parameters\n                .consideration[targetComponent.itemIndex]\n                .startAmount = considerationItem.amount - execution.item.amount;\n\n            // Reduce total consideration amount to equal the offer amount.\n            considerationItem.amount = execution.item.amount;\n        } else {\n            // Retrieve the first offer component from the fulfillment.\n            FulfillmentComponent memory targetComponent = (offerComponents[0]);\n\n            // Add excess offer item amount to the original array of orders.\n            advancedOrders[targetComponent.orderIndex]\n                .parameters\n                .offer[targetComponent.itemIndex]\n                .startAmount = execution.item.amount - considerationItem.amount;\n        }\n\n        // Reuse execution struct with consideration amount and recipient.\n        execution.item.amount = considerationItem.amount;\n        execution.item.recipient = considerationItem.recipient;\n\n        // Return the final execution that will be triggered for relevant items.\n        return execution; // Execution(considerationItem, offerer, conduitKey);\n    }\n\n    /**\n     * @dev Internal view function to aggregate offer or consideration items\n     *      from a group of orders into a single execution via a supplied array\n     *      of fulfillment components. Items that are not available to aggregate\n     *      will not be included in the aggregated execution.\n     *\n     * @param advancedOrders        The orders to aggregate.\n     * @param side                  The side (i.e. offer or consideration).\n     * @param fulfillmentComponents An array designating item components to\n     *                              aggregate if part of an available order.\n     * @param fulfillerConduitKey   A bytes32 value indicating what conduit, if\n     *                              any, to source the fulfiller's token\n     *                              approvals from. The zero hash signifies that\n     *                              no conduit should be used, with approvals\n     *                              set directly on this contract.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _aggregateAvailable(\n        AdvancedOrder[] memory advancedOrders,\n        Side side,\n        FulfillmentComponent[] memory fulfillmentComponents,\n        bytes32 fulfillerConduitKey\n    ) internal view returns (Execution memory execution) {\n        // Skip overflow / underflow checks; conditions checked or unreachable.\n        unchecked {\n            // Retrieve fulfillment components array length and place on stack.\n            // Ensure at least one fulfillment component has been supplied.\n            if (fulfillmentComponents.length == 0) {\n                revert MissingFulfillmentComponentOnAggregation(side);\n            }\n\n            // If the fulfillment components are offer components...\n            if (side == Side.OFFER) {\n                // Return execution for aggregated items provided by offerer.\n                _aggregateValidFulfillmentOfferItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution\n                );\n            } else {\n                // Otherwise, fulfillment components are consideration\n                // components. Return execution for aggregated items provided by\n                // the fulfiller.\n                _aggregateValidFulfillmentConsiderationItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution\n                );\n\n                // Set the caller as the offerer on the execution.\n                execution.offerer = msg.sender;\n\n                // Set fulfiller conduit key as the conduit key on execution.\n                execution.conduitKey = fulfillerConduitKey;\n            }\n\n            // Set the offerer as the receipient if execution amount is nonzero.\n            if (execution.item.amount == 0) {\n                execution.item.recipient = payable(execution.offerer);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of offer items using\n     *      supplied directives on which component items are candidates for\n     *      aggregation, skipping items on orders that are not available.\n     *\n     * @param advancedOrders  The orders to aggregate offer items from.\n     * @param offerComponents An array of FulfillmentComponent structs\n     *                        indicating the order index and item index of each\n     *                        candidate offer item for aggregation.\n     * @param execution       The execution to apply the aggregation to.\n     */\n    function _aggregateValidFulfillmentOfferItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory offerComponents,\n        Execution memory execution\n    ) internal view {\n        assembly {\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store the InvalidFulfillmentComponentData error signature.\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\n\n                // Return, supplying InvalidFulfillmentComponentData signature.\n                revert(0, InvalidFulfillmentComponentData_error_len)\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_signature)\n\n                // Store the arithmetic (0x11) panic code as initial argument.\n                mstore(Panic_error_offset, Panic_arithmetic)\n\n                // Return, supplying Panic signature and arithmetic code.\n                revert(0, Panic_error_length)\n            }\n\n            // Get position in offerComponents head.\n            let fulfillmentHeadPtr := add(offerComponents, OneWord)\n\n            // Retrieve the order index using the fulfillment pointer.\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\n\n            // Ensure that the order index is not out of range.\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Read advancedOrders[orderIndex] pointer from its array head.\n            let orderPtr := mload(\n                // Calculate head position of advancedOrders[orderIndex].\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\n            )\n\n            // Read the pointer to OrderParameters from the AdvancedOrder.\n            let paramsPtr := mload(orderPtr)\n\n            // Load the offer array pointer.\n            let offerArrPtr := mload(\n                add(paramsPtr, OrderParameters_offer_head_offset)\n            )\n\n            // Retrieve item index using an offset of the fulfillment pointer.\n            let itemIndex := mload(\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n            )\n\n            // Only continue if the fulfillment is not invalid.\n            if iszero(lt(itemIndex, mload(offerArrPtr))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Retrieve consideration item pointer using the item index.\n            let offerItemPtr := mload(\n                add(\n                    // Get pointer to beginning of receivedItem.\n                    add(offerArrPtr, OneWord),\n                    // Calculate offset to pointer for desired order.\n                    mul(itemIndex, OneWord)\n                )\n            )\n\n            // Declare a variable for the final aggregated item amount.\n            let amount := 0\n\n            // Create variable to track errors encountered with amount.\n            let errorBuffer := 0\n\n            // Only add offer amount to execution amount on a nonzero numerator.\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\n                // Retrieve amount pointer using consideration item pointer.\n                let amountPtr := add(offerItemPtr, Common_amount_offset)\n\n                // Set the amount.\n                amount := mload(amountPtr)\n\n                // Zero out amount on item to indicate it is credited.\n                mstore(amountPtr, 0)\n\n                // Buffer indicating whether issues were found.\n                errorBuffer := iszero(amount)\n            }\n\n            // Retrieve the received item pointer.\n            let receivedItemPtr := mload(execution)\n\n            // Set the caller as the recipient on the received item.\n            mstore(\n                add(receivedItemPtr, ReceivedItem_recipient_offset),\n                caller()\n            )\n\n            // Set the item type on the received item.\n            mstore(receivedItemPtr, mload(offerItemPtr))\n\n            // Set the token on the received item.\n            mstore(\n                add(receivedItemPtr, Common_token_offset),\n                mload(add(offerItemPtr, Common_token_offset))\n            )\n\n            // Set the identifier on the received item.\n            mstore(\n                add(receivedItemPtr, Common_identifier_offset),\n                mload(add(offerItemPtr, Common_identifier_offset))\n            )\n\n            // Set the offerer on returned execution using order pointer.\n            mstore(add(execution, Execution_offerer_offset), mload(paramsPtr))\n\n            // Set conduitKey on returned execution via offset of order pointer.\n            mstore(\n                add(execution, Execution_conduit_offset),\n                mload(add(paramsPtr, OrderParameters_conduit_offset))\n            )\n\n            // Calculate the hash of (itemType, token, identifier).\n            let dataHash := keccak256(\n                receivedItemPtr,\n                ReceivedItem_CommonParams_size\n            )\n\n            // Get position one word past last element in head of array.\n            let endPtr := add(\n                offerComponents,\n                mul(mload(offerComponents), OneWord)\n            )\n\n            // Iterate over remaining offer components.\n            // prettier-ignore\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\n                // Increment the pointer to the fulfillment head by one word.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Get the order index using the fulfillment pointer.\n                orderIndex := mload(mload(fulfillmentHeadPtr))\n\n                // Ensure the order index is in range.\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\n                  throwInvalidFulfillmentComponentData()\n                }\n\n                // Get pointer to AdvancedOrder element.\n                orderPtr := mload(\n                    add(\n                        add(advancedOrders, OneWord),\n                        mul(orderIndex, OneWord)\n                    )\n                )\n\n                // Only continue if numerator is not zero.\n                if iszero(mload(\n                    add(orderPtr, AdvancedOrder_numerator_offset)\n                )) {\n                  continue\n                }\n\n                // Read the pointer to OrderParameters from the AdvancedOrder.\n                paramsPtr := mload(orderPtr)\n\n                // Load offer array pointer.\n                offerArrPtr := mload(\n                    add(\n                        paramsPtr,\n                        OrderParameters_offer_head_offset\n                    )\n                )\n\n                // Get the item index using the fulfillment pointer.\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\n\n                // Throw if itemIndex is out of the range of array.\n                if iszero(\n                    lt(itemIndex, mload(offerArrPtr))\n                ) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Retrieve offer item pointer using index.\n                offerItemPtr := mload(\n                    add(\n                        // Get pointer to beginning of receivedItem.\n                        add(offerArrPtr, OneWord),\n                        // Use offset to pointer for desired order.\n                        mul(itemIndex, OneWord)\n                    )\n                )\n\n                // Retrieve amount pointer using offer item pointer.\n                let amountPtr := add(\n                      offerItemPtr,\n                      Common_amount_offset\n                )\n\n                // Add offer amount to execution amount.\n                let newAmount := add(amount, mload(amountPtr))\n\n                // Update error buffer (1 = zero amount, 2 = overflow).\n                errorBuffer := or(\n                  errorBuffer,\n                  or(\n                    shl(1, lt(newAmount, amount)),\n                    iszero(mload(amountPtr))\n                  )\n                )\n\n                // Update the amount to the new, summed amount.\n                amount := newAmount\n\n                // Zero out amount on original item to indicate it is credited.\n                mstore(amountPtr, 0)\n\n                // Ensure the indicated item matches original item.\n                if iszero(\n                    and(\n                        and(\n                          // The offerer must match on both items.\n                          eq(\n                              mload(paramsPtr),\n                              mload(\n                                  add(execution, Execution_offerer_offset)\n                              )\n                          ),\n                          // The conduit key must match on both items.\n                          eq(\n                              mload(\n                                  add(\n                                      paramsPtr,\n                                      OrderParameters_conduit_offset\n                                  )\n                              ),\n                              mload(\n                                  add(\n                                      execution,\n                                      Execution_conduit_offset\n                                  )\n                              )\n                          )\n                        ),\n                        // The itemType, token, and identifier must match.\n                        eq(\n                            dataHash,\n                            keccak256(\n                                offerItemPtr,\n                                ReceivedItem_CommonParams_size\n                            )\n                        )\n                    )\n                ) {\n                    // Throw if any of the requirements are not met.\n                    throwInvalidFulfillmentComponentData()\n                }\n            }\n            // Write final amount to execution.\n            mstore(add(mload(execution), Common_amount_offset), amount)\n\n            // Determine if an error code is contained in the error buffer.\n            switch errorBuffer\n            case 1 {\n                // Store the MissingItemAmount error signature.\n                mstore(0, MissingItemAmount_error_signature)\n\n                // Return, supplying MissingItemAmount signature.\n                revert(0, MissingItemAmount_error_len)\n            }\n            case 2 {\n                // If the sum overflowed, panic.\n                throwOverflow()\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of consideration items\n     *      using supplied directives on which component items are candidates\n     *      for aggregation, skipping items on orders that are not available.\n     *\n     * @param advancedOrders          The orders to aggregate consideration\n     *                                items from.\n     * @param considerationComponents An array of FulfillmentComponent structs\n     *                                indicating the order index and item index\n     *                                of each candidate consideration item for\n     *                                aggregation.\n     * @param execution       The execution to apply the aggregation to.\n     */\n    function _aggregateValidFulfillmentConsiderationItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory considerationComponents,\n        Execution memory execution\n    ) internal pure {\n        // Utilize assembly in order to efficiently aggregate the items.\n        assembly {\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store the InvalidFulfillmentComponentData error signature.\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\n\n                // Return, supplying InvalidFulfillmentComponentData signature.\n                revert(0, InvalidFulfillmentComponentData_error_len)\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_signature)\n\n                // Store the arithmetic (0x11) panic code as initial argument.\n                mstore(Panic_error_offset, Panic_arithmetic)\n\n                // Return, supplying Panic signature and arithmetic code.\n                revert(0, Panic_error_length)\n            }\n\n            // Get position in considerationComponents head.\n            let fulfillmentHeadPtr := add(considerationComponents, OneWord)\n\n            // Retrieve the order index using the fulfillment pointer.\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\n\n            // Ensure that the order index is not out of range.\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Read advancedOrders[orderIndex] pointer from its array head.\n            let orderPtr := mload(\n                // Calculate head position of advancedOrders[orderIndex].\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\n            )\n\n            // Load consideration array pointer.\n            let considerationArrPtr := mload(\n                add(\n                    // Read pointer to OrderParameters from the AdvancedOrder.\n                    mload(orderPtr),\n                    OrderParameters_consideration_head_offset\n                )\n            )\n\n            // Retrieve item index using an offset of the fulfillment pointer.\n            let itemIndex := mload(\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n            )\n\n            // Ensure that the order index is not out of range.\n            if iszero(lt(itemIndex, mload(considerationArrPtr))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Retrieve consideration item pointer using the item index.\n            let considerationItemPtr := mload(\n                add(\n                    // Get pointer to beginning of receivedItem.\n                    add(considerationArrPtr, OneWord),\n                    // Calculate offset to pointer for desired order.\n                    mul(itemIndex, OneWord)\n                )\n            )\n\n            // Declare a variable for the final aggregated item amount.\n            let amount := 0\n\n            // Create variable to track errors encountered with amount.\n            let errorBuffer := 0\n\n            // Only add consideration amount to execution amount if numerator is\n            // greater than zero.\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\n                // Retrieve amount pointer using consideration item pointer.\n                let amountPtr := add(considerationItemPtr, Common_amount_offset)\n\n                // Set the amount.\n                amount := mload(amountPtr)\n\n                // Set error bit if amount is zero.\n                errorBuffer := iszero(amount)\n\n                // Zero out amount on item to indicate it is credited.\n                mstore(amountPtr, 0)\n            }\n\n            // Retrieve ReceivedItem pointer from Execution.\n            let receivedItem := mload(execution)\n\n            // Set the item type on the received item.\n            mstore(receivedItem, mload(considerationItemPtr))\n\n            // Set the token on the received item.\n            mstore(\n                add(receivedItem, Common_token_offset),\n                mload(add(considerationItemPtr, Common_token_offset))\n            )\n\n            // Set the identifier on the received item.\n            mstore(\n                add(receivedItem, Common_identifier_offset),\n                mload(add(considerationItemPtr, Common_identifier_offset))\n            )\n\n            // Set the recipient on the received item.\n            mstore(\n                add(receivedItem, ReceivedItem_recipient_offset),\n                mload(\n                    add(\n                        considerationItemPtr,\n                        ConsiderationItem_recipient_offset\n                    )\n                )\n            )\n\n            // Calculate the hash of (itemType, token, identifier).\n            let dataHash := keccak256(\n                receivedItem,\n                ReceivedItem_CommonParams_size\n            )\n\n            // Get position one word past last element in head of array.\n            let endPtr := add(\n                considerationComponents,\n                mul(mload(considerationComponents), OneWord)\n            )\n\n            // Iterate over remaining offer components.\n            // prettier-ignore\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\n                // Increment position in considerationComponents head.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Get the order index using the fulfillment pointer.\n                orderIndex := mload(mload(fulfillmentHeadPtr))\n\n                // Ensure the order index is in range.\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\n                  throwInvalidFulfillmentComponentData()\n                }\n\n                // Get pointer to AdvancedOrder element.\n                orderPtr := mload(\n                    add(\n                        add(advancedOrders, OneWord),\n                        mul(orderIndex, OneWord)\n                    )\n                )\n\n                // Only continue if numerator is not zero.\n                if iszero(\n                    mload(add(orderPtr, AdvancedOrder_numerator_offset))\n                ) {\n                  continue\n                }\n\n                // Load consideration array pointer from OrderParameters.\n                considerationArrPtr := mload(\n                    add(\n                        // Get pointer to OrderParameters from AdvancedOrder.\n                        mload(orderPtr),\n                        OrderParameters_consideration_head_offset\n                    )\n                )\n\n                // Get the item index using the fulfillment pointer.\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\n\n                // Check if itemIndex is within the range of array.\n                if iszero(lt(itemIndex, mload(considerationArrPtr))) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Retrieve consideration item pointer using index.\n                considerationItemPtr := mload(\n                    add(\n                        // Get pointer to beginning of receivedItem.\n                        add(considerationArrPtr, OneWord),\n                        // Use offset to pointer for desired order.\n                        mul(itemIndex, OneWord)\n                    )\n                )\n\n                // Retrieve amount pointer using consideration item pointer.\n                let amountPtr := add(\n                      considerationItemPtr,\n                      Common_amount_offset\n                )\n\n                // Add offer amount to execution amount.\n                let newAmount := add(amount, mload(amountPtr))\n\n                // Update error buffer (1 = zero amount, 2 = overflow).\n                errorBuffer := or(\n                  errorBuffer,\n                  or(\n                    shl(1, lt(newAmount, amount)),\n                    iszero(mload(amountPtr))\n                  )\n                )\n\n                // Update the amount to the new, summed amount.\n                amount := newAmount\n\n                // Zero out amount on original item to indicate it is credited.\n                mstore(amountPtr, 0)\n\n                // Ensure the indicated item matches original item.\n                if iszero(\n                    and(\n                        // Item recipients must match.\n                        eq(\n                            mload(\n                                add(\n                                    considerationItemPtr,\n                                    ConsiderItem_recipient_offset\n                                )\n                            ),\n                            mload(\n                                add(\n                                    receivedItem,\n                                    ReceivedItem_recipient_offset\n                                )\n                            )\n                        ),\n                        // The itemType, token, identifier must match.\n                        eq(\n                          dataHash,\n                          keccak256(\n                            considerationItemPtr,\n                            ReceivedItem_CommonParams_size\n                          )\n                        )\n                    )\n                ) {\n                    // Throw if any of the requirements are not met.\n                    throwInvalidFulfillmentComponentData()\n                }\n            }\n            // Write final amount to execution.\n            mstore(add(receivedItem, Common_amount_offset), amount)\n\n            // Determine if an error code is contained in the error buffer.\n            switch errorBuffer\n            case 1 {\n                // Store the MissingItemAmount error signature.\n                mstore(0, MissingItemAmount_error_signature)\n\n                // Return, supplying MissingItemAmount signature.\n                revert(0, MissingItemAmount_error_len)\n            }\n            case 2 {\n                // If the sum overflowed, panic.\n                throwOverflow()\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "FulfillmentApplier.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_aggregateValidFulfillmentOfferItems function in FulfillmentApplier.sol",
                "Type": "Unhandled error code",
                "Description": "The _aggregateValidFulfillmentOfferItems() function can be tricked to accept invalid inputs by setting the errorBuffer to an unhandled value of 3, which can lead to fulfilling an order with a consideration lower than expected.",
                "Repair": "Change the check on FulfillmentApplier.sol#L465 to consider case 3. Potential option: Introduce an early abort in case errorBuffer != 0 on FulfillmentApplier.sol#L338"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ItemType, Side } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OfferItem,\n    ConsiderationItem,\n    OrderParameters,\n    AdvancedOrder,\n    CriteriaResolver\n} from \"./ConsiderationStructs.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n// prettier-ignore\nimport {\n    CriteriaResolutionErrors\n} from \"../interfaces/CriteriaResolutionErrors.sol\";\n\n/**\n * @title CriteriaResolution\n * @author 0age\n * @notice CriteriaResolution contains a collection of pure functions related to\n *         resolving criteria-based items.\n */\ncontract CriteriaResolution is CriteriaResolutionErrors {\n    /**\n     * @dev Internal pure function to apply criteria resolvers containing\n     *      specific token identifiers and associated proofs to order items.\n     *\n     * @param advancedOrders     The orders to apply criteria resolvers to.\n     * @param criteriaResolvers  An array where each element contains a\n     *                           reference to a specific order as well as that\n     *                           order's offer or consideration, a token\n     *                           identifier, and a proof that the supplied token\n     *                           identifier is contained in the order's merkle\n     *                           root. Note that a root of zero indicates that\n     *                           any transferrable token identifier is valid and\n     *                           that no proof needs to be supplied.\n     */\n    function _applyCriteriaResolvers(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers\n    ) internal pure {\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Retrieve length of criteria resolvers array and place on stack.\n            uint256 totalCriteriaResolvers = criteriaResolvers.length;\n\n            // Retrieve length of orders array and place on stack.\n            uint256 totalAdvancedOrders = advancedOrders.length;\n\n            // Iterate over each criteria resolver.\n            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {\n                // Retrieve the criteria resolver.\n                CriteriaResolver memory criteriaResolver = (\n                    criteriaResolvers[i]\n                );\n\n                // Read the order index from memory and place it on the stack.\n                uint256 orderIndex = criteriaResolver.orderIndex;\n\n                // Ensure that the order index is in range.\n                if (orderIndex >= totalAdvancedOrders) {\n                    revert OrderCriteriaResolverOutOfRange();\n                }\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrders[orderIndex].numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrders[orderIndex].parameters\n                );\n\n                // Read component index from memory and place it on the stack.\n                uint256 componentIndex = criteriaResolver.index;\n\n                // Declare values for item's type and criteria.\n                ItemType itemType;\n                uint256 identifierOrCriteria;\n\n                // If the criteria resolver refers to an offer item...\n                if (criteriaResolver.side == Side.OFFER) {\n                    // Retrieve the offer.\n                    OfferItem[] memory offer = orderParameters.offer;\n\n                    // Ensure that the component index is in range.\n                    if (componentIndex >= offer.length) {\n                        revert OfferCriteriaResolverOutOfRange();\n                    }\n\n                    // Retrieve relevant item using the component index.\n                    OfferItem memory offerItem = offer[componentIndex];\n\n                    // Read item type and criteria from memory & place on stack.\n                    itemType = offerItem.itemType;\n                    identifierOrCriteria = offerItem.identifierOrCriteria;\n\n                    // Optimistically update item type to remove criteria usage.\n                    ItemType newItemType;\n                    assembly {\n                        newItemType := sub(3, eq(itemType, 4))\n                    }\n                    offerItem.itemType = newItemType;\n\n                    // Optimistically update identifier w/ supplied identifier.\n                    offerItem.identifierOrCriteria = criteriaResolver\n                        .identifier;\n                } else {\n                    // Otherwise, the resolver refers to a consideration item.\n                    ConsiderationItem[] memory consideration = (\n                        orderParameters.consideration\n                    );\n\n                    // Ensure that the component index is in range.\n                    if (componentIndex >= consideration.length) {\n                        revert ConsiderationCriteriaResolverOutOfRange();\n                    }\n\n                    // Retrieve relevant item using order and component index.\n                    ConsiderationItem memory considerationItem = (\n                        consideration[componentIndex]\n                    );\n\n                    // Read item type and criteria from memory & place on stack.\n                    itemType = considerationItem.itemType;\n                    identifierOrCriteria = (\n                        considerationItem.identifierOrCriteria\n                    );\n\n                    // Optimistically update item type to remove criteria usage.\n                    ItemType newItemType;\n                    assembly {\n                        newItemType := sub(3, eq(itemType, 4))\n                    }\n                    considerationItem.itemType = newItemType;\n\n                    // Optimistically update identifier w/ supplied identifier.\n                    considerationItem.identifierOrCriteria = (\n                        criteriaResolver.identifier\n                    );\n                }\n\n                // Ensure the specified item type indicates criteria usage.\n                if (!_isItemWithCriteria(itemType)) {\n                    revert CriteriaNotEnabledForItem();\n                }\n\n                // If criteria is not 0 (i.e. a collection-wide offer)...\n                if (identifierOrCriteria != uint256(0)) {\n                    // Verify identifier inclusion in criteria root using proof.\n                    _verifyProof(\n                        criteriaResolver.identifier,\n                        identifierOrCriteria,\n                        criteriaResolver.criteriaProof\n                    );\n                }\n            }\n\n            // Iterate over each advanced order.\n            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {\n                // Retrieve the advanced order.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrders[i].parameters\n                );\n\n                // Read consideration length from memory and place on stack.\n                uint256 totalItems = orderParameters.consideration.length;\n\n                // Iterate over each consideration item on the order.\n                for (uint256 j = 0; j < totalItems; ++j) {\n                    // Ensure item type no longer indicates criteria usage.\n                    if (\n                        _isItemWithCriteria(\n                            orderParameters.consideration[j].itemType\n                        )\n                    ) {\n                        revert UnresolvedConsiderationCriteria();\n                    }\n                }\n\n                // Read offer length from memory and place on stack.\n                totalItems = orderParameters.offer.length;\n\n                // Iterate over each offer item on the order.\n                for (uint256 j = 0; j < totalItems; ++j) {\n                    // Ensure item type no longer indicates criteria usage.\n                    if (\n                        _isItemWithCriteria(orderParameters.offer[j].itemType)\n                    ) {\n                        revert UnresolvedOfferCriteria();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given item type represents\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\n     *      resolved to one of a number of different identifiers at the time of\n     *      order fulfillment).\n     *\n     * @param itemType The item type in question.\n     *\n     * @return withCriteria A boolean indicating that the item type in question\n     *                      represents a criteria-based item.\n     */\n    function _isItemWithCriteria(ItemType itemType)\n        internal\n        pure\n        returns (bool withCriteria)\n    {\n        // ERC721WithCriteria is ItemType 4. ERC1155WithCriteria is ItemType 5.\n        assembly {\n            withCriteria := gt(itemType, 3)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given element is contained\n     *      in a merkle root via a supplied proof.\n     *\n     * @param leaf  The element for which to prove inclusion.\n     * @param root  The merkle root that inclusion will be proved against.\n     * @param proof The merkle proof.\n     */\n    function _verifyProof(\n        uint256 leaf,\n        uint256 root,\n        bytes32[] memory proof\n    ) internal pure {\n        bool isValid;\n\n        assembly {\n            // Start the hash off as just the starting leaf.\n            let computedHash := leaf\n\n            // Get memory start location of the first element in proof array.\n            let data := add(proof, OneWord)\n\n            // Iterate over proof elements to compute root hash.\n            for {\n                let end := add(data, mul(mload(proof), OneWord))\n            } lt(data, end) {\n                data := add(data, OneWord)\n            } {\n                // Get the proof element.\n                let loadedData := mload(data)\n\n                // Sort and store proof element and hash.\n                switch gt(computedHash, loadedData)\n                case 0 {\n                    mstore(0, computedHash) // Place existing hash first.\n                    mstore(0x20, loadedData) // Place new hash next.\n                }\n                default {\n                    mstore(0, loadedData) // Place new hash first.\n                    mstore(0x20, computedHash) // Place existing hash next.\n                }\n\n                // Derive the updated hash.\n                computedHash := keccak256(0, TwoWords)\n            }\n\n            // Compare the final hash to the supplied root.\n            isValid := eq(computedHash, root)\n        }\n\n        // Revert if computed hash does not equal supplied root.\n        if (!isValid) {\n            revert InvalidProof();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "CriteriaResolution.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CriteriaResolution.sol#L157",
                "Type": "Merkle Tree vulnerability",
                "Description": "The vulnerability allows an attacker to submit an intermediate hash of the merkle tree as the tokenId and trade this NFT instead of one of the requested ones, leading to losses for the offerer as they receive a tokenId that they did not specify in the criteria.",
                "Repair": "Use hashes of the tokenIds as the leaves instead of the tokenIds themselves and compute the leaf hash in the contract from the provided tokenId"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { OrderType } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OrderParameters,\n    Order,\n    AdvancedOrder,\n    OrderComponents,\n    OrderStatus,\n    CriteriaResolver\n} from \"./ConsiderationStructs.sol\";\n\nimport { Executor } from \"./Executor.sol\";\n\nimport { ZoneInteraction } from \"./ZoneInteraction.sol\";\n\n/**\n * @title OrderValidator\n * @author 0age\n * @notice OrderValidator contains functionality related to validating orders\n *         and updating their status.\n */\ncontract OrderValidator is Executor, ZoneInteraction {\n    // Track status of each order (validated, cancelled, and fraction filled).\n    mapping(bytes32 => OrderStatus) private _orderStatus;\n\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Executor(conduitController) {}\n\n    /**\n     * @dev Internal function to verify and update the status of a basic order.\n     *\n     * @param orderHash The hash of the order.\n     * @param offerer   The offerer of the order.\n     * @param signature A signature from the offerer indicating that the order\n     *                  has been approved.\n     */\n    function _validateBasicOrderAndUpdateStatus(\n        bytes32 orderHash,\n        address offerer,\n        bytes memory signature\n    ) internal {\n        // Retrieve the order status for the given order hash.\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        _verifyOrderStatus(\n            orderHash,\n            orderStatus,\n            true, // Only allow unused orders when fulfilling basic orders.\n            true // Signifies to revert if the order is invalid.\n        );\n\n        // If the order is not already validated, verify the supplied signature.\n        if (!orderStatus.isValidated) {\n            _verifySignature(offerer, orderHash, signature);\n        }\n\n        // Update order status as fully filled, packing struct values.\n        _orderStatus[orderHash].isValidated = true;\n        _orderStatus[orderHash].isCancelled = false;\n        _orderStatus[orderHash].numerator = 1;\n        _orderStatus[orderHash].denominator = 1;\n    }\n\n    /**\n     * @dev Internal function to validate an order, determine what portion to\n     *      fill, and update its status. The desired fill amount is supplied as\n     *      a fraction, as is the returned amount to fill.\n     *\n     * @param advancedOrder     The order to fulfill as well as the fraction to\n     *                          fill. Note that all offer and consideration\n     *                          amounts must divide with no remainder in order\n     *                          for a partial fill to be valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific offer or consideration, a token\n     *                          identifier, and a proof that the supplied token\n     *                          identifier is contained in the order's merkle\n     *                          root. Note that a criteria of zero indicates\n     *                          that any (transferrable) token identifier is\n     *                          valid and that no proof needs to be supplied.\n     * @param revertOnInvalid   A boolean indicating whether to revert if the\n     *                          order is invalid due to the time or status.\n     * @param priorOrderHashes  The order hashes of each order supplied prior to\n     *                          the current order as part of a \"match\" variety\n     *                          of order fulfillment (e.g. this array will be\n     *                          empty for single or \"fulfill available\").\n     *\n     * @return orderHash      The order hash.\n     * @return newNumerator   A value indicating the portion of the order that\n     *                        will be filled.\n     * @return newDenominator A value indicating the total size of the order.\n     */\n    function _validateOrderAndUpdateStatus(\n        AdvancedOrder memory advancedOrder,\n        CriteriaResolver[] memory criteriaResolvers,\n        bool revertOnInvalid,\n        bytes32[] memory priorOrderHashes\n    )\n        internal\n        returns (\n            bytes32 orderHash,\n            uint256 newNumerator,\n            uint256 newDenominator\n        )\n    {\n        // Retrieve the parameters for the order.\n        OrderParameters memory orderParameters = advancedOrder.parameters;\n\n        // Ensure current timestamp falls between order start time and end time.\n        if (\n            !_verifyTime(\n                orderParameters.startTime,\n                orderParameters.endTime,\n                revertOnInvalid\n            )\n        ) {\n            // Assuming an invalid time and no revert, return zeroed out values.\n            return (bytes32(0), 0, 0);\n        }\n\n        // Read numerator and denominator from memory and place on the stack.\n        uint256 numerator = uint256(advancedOrder.numerator);\n        uint256 denominator = uint256(advancedOrder.denominator);\n\n        // Ensure that the supplied numerator and denominator are valid.\n        if (numerator > denominator || numerator == 0) {\n            revert BadFraction();\n        }\n\n        // If attempting partial fill (n < d) check order type & ensure support.\n        if (\n            numerator < denominator &&\n            _doesNotSupportPartialFills(orderParameters.orderType)\n        ) {\n            // Revert if partial fill was attempted on an unsupported order.\n            revert PartialFillsNotEnabledForOrder();\n        }\n\n        // Retrieve current nonce and use it w/ parameters to derive order hash.\n        orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\n            orderParameters\n        );\n\n        // Ensure restricted orders have a valid submitter or pass a zone check.\n        _assertRestrictedAdvancedOrderValidity(\n            advancedOrder,\n            criteriaResolvers,\n            priorOrderHashes,\n            orderHash,\n            orderParameters.zoneHash,\n            orderParameters.orderType,\n            orderParameters.offerer,\n            orderParameters.zone\n        );\n\n        // Retrieve the order status using the derived order hash.\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        if (\n            !_verifyOrderStatus(\n                orderHash,\n                orderStatus,\n                false, // Allow partially used orders to be filled.\n                revertOnInvalid\n            )\n        ) {\n            // Assuming an invalid order status and no revert, return zero fill.\n            return (orderHash, 0, 0);\n        }\n\n        // If the order is not already validated, verify the supplied signature.\n        if (!orderStatus.isValidated) {\n            _verifySignature(\n                orderParameters.offerer,\n                orderHash,\n                advancedOrder.signature\n            );\n        }\n\n        // Read filled amount as numerator and denominator and put on the stack.\n        uint256 filledNumerator = orderStatus.numerator;\n        uint256 filledDenominator = orderStatus.denominator;\n\n        // If order currently has a non-zero denominator it is partially filled.\n        if (filledDenominator != 0) {\n            // If denominator of 1 supplied, fill all remaining amount on order.\n            if (denominator == 1) {\n                // Scale numerator & denominator to match current denominator.\n                numerator = filledDenominator;\n                denominator = filledDenominator;\n            }\n            // Otherwise, if supplied denominator differs from current one...\n            else if (filledDenominator != denominator) {\n                // scale current numerator by the supplied denominator, then...\n                filledNumerator *= denominator;\n\n                // the supplied numerator & denominator by current denominator.\n                numerator *= filledDenominator;\n                denominator *= filledDenominator;\n            }\n\n            // Once adjusted, if current+supplied numerator exceeds denominator:\n            if (filledNumerator + numerator > denominator) {\n                // Skip underflow check: denominator >= orderStatus.numerator\n                unchecked {\n                    // Reduce current numerator so it + supplied = denominator.\n                    numerator = denominator - filledNumerator;\n                }\n            }\n\n            // Skip overflow check: checked above unless numerator is reduced.\n            unchecked {\n                // Update order status and fill amount, packing struct values.\n                _orderStatus[orderHash].isValidated = true;\n                _orderStatus[orderHash].isCancelled = false;\n                _orderStatus[orderHash].numerator = uint120(\n                    filledNumerator + numerator\n                );\n                _orderStatus[orderHash].denominator = uint120(denominator);\n            }\n        } else {\n            // Update order status and fill amount, packing struct values.\n            _orderStatus[orderHash].isValidated = true;\n            _orderStatus[orderHash].isCancelled = false;\n            _orderStatus[orderHash].numerator = uint120(numerator);\n            _orderStatus[orderHash].denominator = uint120(denominator);\n        }\n\n        // Return order hash, a modified numerator, and a modified denominator.\n        return (orderHash, numerator, denominator);\n    }\n\n    /**\n     * @dev Internal function to cancel an arbitrary number of orders. Note that\n     *      only the offerer or the zone of a given order may cancel it. Callers\n     *      should ensure that the intended order was cancelled by calling\n     *      `getOrderStatus` and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders were\n     *                   successfully cancelled.\n     */\n    function _cancel(OrderComponents[] calldata orders)\n        internal\n        returns (bool cancelled)\n    {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        address offerer;\n        address zone;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Retrieve the order.\n                OrderComponents calldata order = orders[i];\n\n                offerer = order.offerer;\n                zone = order.zone;\n\n                // Ensure caller is either offerer or zone of the order.\n                if (msg.sender != offerer && msg.sender != zone) {\n                    revert InvalidCanceller();\n                }\n\n                // Derive order hash using the order parameters and the nonce.\n                bytes32 orderHash = _deriveOrderHash(\n                    OrderParameters(\n                        offerer,\n                        zone,\n                        order.offer,\n                        order.consideration,\n                        order.orderType,\n                        order.startTime,\n                        order.endTime,\n                        order.zoneHash,\n                        order.salt,\n                        order.conduitKey,\n                        order.consideration.length\n                    ),\n                    order.nonce\n                );\n\n                // Update the order status as not valid and cancelled.\n                _orderStatus[orderHash].isValidated = false;\n                _orderStatus[orderHash].isCancelled = true;\n\n                // Emit an event signifying that the order has been cancelled.\n                emit OrderCancelled(orderHash, offerer, zone);\n\n                // Increment counter inside body of loop for gas efficiency.\n                ++i;\n            }\n        }\n\n        // Return a boolean indicating that orders were successfully cancelled.\n        cancelled = true;\n    }\n\n    /**\n     * @dev Internal function to validate an arbitrary number of orders, thereby\n     *      registering their signatures as valid and allowing the fulfiller to\n     *      skip signature verification on fulfillment. Note that validated\n     *      orders may still be unfulfillable due to invalid item amounts or\n     *      other factors; callers should determine whether validated orders are\n     *      fulfillable by simulating the fulfillment call prior to execution.\n     *      Also note that anyone can validate a signed order, but only the\n     *      offerer can validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders were\n     *                   successfully validated.\n     */\n    function _validate(Order[] calldata orders)\n        internal\n        returns (bool validated)\n    {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Declare variables outside of the loop.\n        bytes32 orderHash;\n        address offerer;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Retrieve the order.\n                Order calldata order = orders[i];\n\n                // Retrieve the order parameters.\n                OrderParameters calldata orderParameters = order.parameters;\n\n                // Move offerer from memory to the stack.\n                offerer = orderParameters.offerer;\n\n                // Get current nonce and use it w/ params to derive order hash.\n                orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\n                    orderParameters\n                );\n\n                // Retrieve the order status using the derived order hash.\n                OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n                // Ensure order is fillable and retrieve the filled amount.\n                _verifyOrderStatus(\n                    orderHash,\n                    orderStatus,\n                    false, // Signifies that partially filled orders are valid.\n                    true // Signifies to revert if the order is invalid.\n                );\n\n                // If the order has not already been validated...\n                if (!orderStatus.isValidated) {\n                    // Verify the supplied signature.\n                    _verifySignature(offerer, orderHash, order.signature);\n\n                    // Update order status to mark the order as valid.\n                    _orderStatus[orderHash].isValidated = true;\n\n                    // Emit an event signifying the order has been validated.\n                    emit OrderValidated(\n                        orderHash,\n                        offerer,\n                        orderParameters.zone\n                    );\n                }\n\n                // Increment counter inside body of the loop for gas efficiency.\n                ++i;\n            }\n        }\n\n        // Return a boolean indicating that orders were successfully validated.\n        validated = true;\n    }\n\n    /**\n     * @dev Internal view function to retrieve the status of a given order by\n     *      hash, including whether the order has been cancelled or validated\n     *      and the fraction of the order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function _getOrderStatus(bytes32 orderHash)\n        internal\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        )\n    {\n        // Retrieve the order status using the order hash.\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n        // Return the fields on the order status.\n        return (\n            orderStatus.isValidated,\n            orderStatus.isCancelled,\n            orderStatus.numerator,\n            orderStatus.denominator\n        );\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given order type indicates\n     *      that partial fills are not supported (e.g. only \"full fills\" are\n     *      allowed for the order in question).\n     *\n     * @param orderType The order type in question.\n     *\n     * @return isFullOrder A boolean indicating whether the order type only\n     *                     supports full fills.\n     */\n    function _doesNotSupportPartialFills(OrderType orderType)\n        internal\n        pure\n        returns (bool isFullOrder)\n    {\n        // The \"full\" order types are even, while \"partial\" order types are odd.\n        // Bitwise and by 1 is equivalent to modulo by 2, but 2 gas cheaper.\n        assembly {\n            // Equivalent to `uint256(orderType) & 1 == 0`.\n            isFullOrder := iszero(and(orderType, 1))\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "OrderValidator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OrderValidator.sol#L228-L248",
                "Type": "Truncation",
                "Description": "A partial order's fractions (numerator and denominator) can be reset to 0 due to a truncation. This can be used to craft malicious orders.",
                "Repair": "Add checks for overflow/truncation and revert in that case"
            }
        ]
    }
]