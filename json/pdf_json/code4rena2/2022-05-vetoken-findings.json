[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract VeTokenMinter is Ownable {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant maxSupply = 30 * 1000000 * 1e18; //30mil\n    ERC20 public veToken;\n    EnumerableSet.AddressSet internal operators;\n    uint256 public totalCliffs;\n    uint256 public reductionPerCliff;\n    uint256 public totalSupply;\n    mapping(address => uint256) public veAssetWeights;\n    uint256 public totalWeight;\n\n    event Withdraw(address destination, uint256 amount);\n\n    constructor(address veTokenAddress) {\n        veToken = ERC20(veTokenAddress);\n        totalCliffs = 1000;\n        reductionPerCliff = maxSupply.div(totalCliffs);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    ///@dev weight is 10**25 precision\n    function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner {\n        require(operators.contains(veAssetOperator), \"not an veAsset operator\");\n        totalWeight -= veAssetWeights[veAssetOperator];\n        veAssetWeights[veAssetOperator] = newWeight;\n        totalWeight += newWeight;\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        require(operators.contains(_msgSender()), \"not an operator\");\n\n        uint256 supply = totalSupply;\n\n        //use current supply to gauge cliff\n        //this will cause a bit of overflow into the next cliff range\n        //but should be within reasonable levels.\n        //requires a max supply check though\n        uint256 cliff = supply.div(reductionPerCliff);\n        //mint if below total cliffs\n        if (cliff < totalCliffs) {\n            //for reduction% take inverse of current cliff\n            uint256 reduction = totalCliffs.sub(cliff);\n            //reduce\n            _amount = _amount.mul(reduction).div(totalCliffs);\n\n            //supply cap check\n            uint256 amtTillMax = maxSupply.sub(supply);\n            if (_amount > amtTillMax) {\n                _amount = amtTillMax;\n            }\n\n            //mint\n            veToken.safeTransfer(_to, _amount);\n            totalSupply += _amount;\n        }\n    }\n\n    function withdraw(address _destination, uint256 _amount) external onlyOwner {\n        veToken.safeTransfer(_destination, _amount);\n\n        emit Withdraw(_destination, _amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "VeTokenMinter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VeTokenMinter.sol",
                "Type": "Loss of Funds",
                "Description": "Compromised owner can drain funds from VeTokenMinter.sol.",
                "Repair": "Implement a timelock on VeTokenMinter.withdraw() and changing the destination to an address that owner has no control over"
            },
            {
                "Location": "VeTokenMinter.mint function",
                "Type": "Insufficient balance",
                "Description": "Users will not be able to get their rewards from the reward contract at certain point of time if admin withdraws $VE3D token from the VeTokenMinter contract.",
                "Repair": "Update the internal accounting of VeTokenMinter contract during withdrawal so that the actual balance of the $VE3D tokens is taken into consideration within the VeTokenMinter.mint, and the contract will not attempt to transfer more tokens than what it has."
            },
            {
                "Location": "updateveAssetWeight function in VeTokenMinter contract",
                "Type": "Missing sane bounds on asset weights",
                "Description": "The admin may fat-finger a change, or be malicious, and have the weights be extreme ranging from zero to type(uint256).max, which would cause the booster to pay out unexpected amounts.",
                "Repair": "Have sane upper/lower limits on the values."
            },
            {
                "Location": "VeTokenMinter contract",
                "Type": "Not updating totalWeight",
                "Description": "Remaining operators do not receive a fair share of the total rewards and a portion of the rewards are not given out at all.",
                "Repair": "Rewrite removeOperator function to reduce totalWeight and set veAssetWeights to 0"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "25_deploy_angle_pools.js",
                "Type": "Smart Contract Misconfiguration",
                "Description": "Incorrect deployment parameters.",
                "Repair": "Update to the Warden suggested addresses"
            },
            {
                "Location": "Integration with underlying upgradeable contracts",
                "Type": "Contracts not robust to upgrades",
                "Description": "Contracts should be robust to upgrades of underlying gauges and eventually changes of the underlying tokens.",
                "Repair": "Make VoterProxy upgradeable or add upgradeable intermediate contracts between staker and gauge"
            },
            {
                "Location": "BaseRewardPool's stake() function and rewardPerToken() function",
                "Type": "Inflation and reward stealing",
                "Description": "The first user who calls BaseRewardPool's stake() function with 1 wei can inflate the rewardPerTokenStored and rewards can be stolen. The rewardPerToken() function depends on the denominator as totalSupply(), the whole multiplying will be divided by 1 wei which will inflate the rewardPerTokenStored astronomically. There is no obstacle for the user to withdraw it in the withdraw function.",
                "Repair": "Add boundaries to reward the stakers to be consistent inside the limits"
            },
            {
                "Location": "setFeeManager function",
                "Type": "Owner privilege escalation",
                "Description": "Owner should be allowed to change fees manager in case if he feels current fee manager is behaving maliciously.",
                "Repair": "Allow owner to change feeManager after initial setup"
            },
            {
                "Location": "veTokenMinter contract",
                "Type": "Admin privilege escalation",
                "Description": "Admin can dilute tokens by minting an excess amount of tokens.",
                "Repair": "Hardcode the minters or set them as immutable"
            },
            {
                "Location": "Booster's shutdownPool function",
                "Type": "Permanently frozen user funds",
                "Description": "shutdownPool marks shutdown successful even if it's not (i.e. when withdrawAll() call wasn't successful). As withdrawing logic expect that the pool in shutdown has already provided the funds, and makes no additional attempts to retrieve them, user funds will be frozen permanently as there are no mechanics in place to turn shutdown off for a pool.",
                "Repair": "Update shutdownPool logic to mark the pool shutdown only if withdraw was successful"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: vetokenRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VE3DRewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable rewardManager;\n\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    // reward token => reward token info\n    mapping(address => RewardTokenInfo) public rewardTokenInfo;\n    // list of reward tokens\n    EnumerableSet.AddressSet internal rewardTokens;\n    EnumerableSet.AddressSet internal operators;\n\n    address[] public extraRewards;\n\n    struct RewardTokenInfo {\n        address veAssetDeposits;\n        address ve3TokenRewards;\n        address ve3Token;\n        uint256 queuedRewards;\n        uint256 rewardRate;\n        uint256 historicalRewards;\n        uint256 rewardPerTokenStored;\n        uint256 currentRewards;\n        uint256 periodFinish;\n        uint256 lastUpdateTime;\n        mapping(address => uint256) userRewardPerTokenPaid;\n        mapping(address => uint256) rewards;\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(address stakingToken_, address rewardManager_) {\n        stakingToken = IERC20(stakingToken_);\n\n        rewardManager = rewardManager_;\n    }\n\n    function addReward(\n        address _rewardToken,\n        address _veAssetDeposits,\n        address _ve3TokenRewards,\n        address _ve3Token\n    ) external onlyOwner {\n        rewardTokenInfo[_rewardToken].veAssetDeposits = _veAssetDeposits;\n        rewardTokenInfo[_rewardToken].ve3TokenRewards = _ve3TokenRewards;\n        rewardTokenInfo[_rewardToken].ve3Token = _ve3Token;\n        rewardTokens.add(_rewardToken);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored = rewardPerToken(_rewardToken);\n            rewardTokenInfo[_rewardToken].lastUpdateTime = lastTimeRewardApplicable(_rewardToken);\n            if (account != address(0)) {\n                rewardTokenInfo[_rewardToken].rewards[account] = earnedReward(\n                    _rewardToken,\n                    account\n                );\n                rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account] = rewardTokenInfo[\n                    _rewardToken\n                ].rewardPerTokenStored;\n            }\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n        return Math.min(block.timestamp, rewardTokenInfo[_rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardToken) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return rewardTokenInfo[_rewardToken].rewardPerTokenStored;\n        }\n        return\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored.add(\n                lastTimeRewardApplicable(_rewardToken)\n                    .sub(rewardTokenInfo[_rewardToken].lastUpdateTime)\n                    .mul(rewardTokenInfo[_rewardToken].rewardRate)\n                    .mul(1e18)\n                    .div(supply)\n            );\n    }\n\n    function earnedReward(address _rewardToken, address account) internal view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(\n                    rewardPerToken(_rewardToken).sub(\n                        rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account]\n                    )\n                )\n                .div(1e18)\n                .add(rewardTokenInfo[_rewardToken].rewards[account]);\n    }\n\n    function earned(address _rewardToken, address account) external view returns (uint256) {\n        uint256 depositFeeRate = IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits)\n            .lockIncentive();\n\n        uint256 r = earnedReward(_rewardToken, account);\n        uint256 fees = r.mul(depositFeeRate).div(FEE_DENOMINATOR);\n\n        //fees dont apply until whitelist+veVeAsset lock begins so will report\n        //slightly less value than what is actually received.\n        return r.sub(fees);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to _for's balance sheet\n        _balances[_for] = _balances[_for].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, bool claim) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(_amount);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n\n        if (claim) {\n            getReward(msg.sender, true, false);\n        }\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool _stake\n    ) public updateReward(_account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n\n            uint256 reward = earnedReward(_rewardToken, _account);\n            if (reward > 0) {\n                rewardTokenInfo[_rewardToken].rewards[_account] = 0;\n                IERC20(_rewardToken).safeApprove(rewardTokenInfo[_rewardToken].veAssetDeposits, 0);\n                IERC20(_rewardToken).safeApprove(\n                    rewardTokenInfo[_rewardToken].veAssetDeposits,\n                    reward\n                );\n                IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits).deposit(\n                    reward,\n                    false\n                );\n\n                uint256 ve3TokenBalance = IERC20(rewardTokenInfo[_rewardToken].ve3Token).balanceOf(\n                    address(this)\n                );\n                if (_stake) {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        0\n                    );\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        ve3TokenBalance\n                    );\n                    IRewards(rewardTokenInfo[_rewardToken].ve3TokenRewards).stakeFor(\n                        _account,\n                        ve3TokenBalance\n                    );\n                } else {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeTransfer(\n                        _account,\n                        ve3TokenBalance\n                    );\n                }\n                emit RewardPaid(_account, ve3TokenBalance);\n            }\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            uint256 length = extraRewards.length;\n            for (uint256 i = 0; i < length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n    }\n\n    function getReward(bool _stake) external {\n        getReward(msg.sender, true, _stake);\n    }\n\n    function donate(address _rewardToken, uint256 _amount) external {\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        rewardTokenInfo[_rewardToken].queuedRewards += _amount;\n    }\n\n    function queueNewRewards(address _rewardToken, uint256 _rewards) external {\n        require(operators.contains(_msgSender()), \"!authorized\");\n\n        _rewards = _rewards.add(rewardTokenInfo[_rewardToken].queuedRewards);\n\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(\n            rewardTokenInfo[_rewardToken].periodFinish.sub(duration)\n        );\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardTokenInfo[_rewardToken].rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n        } else {\n            rewardTokenInfo[_rewardToken].queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardToken, uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        rewardTokenInfo[_rewardToken].historicalRewards += reward;\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = rewardTokenInfo[_rewardToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardTokenInfo[_rewardToken].rewardRate);\n            reward = reward.add(leftover);\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        }\n        rewardTokenInfo[_rewardToken].currentRewards = reward;\n        rewardTokenInfo[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardTokenInfo[_rewardToken].periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}\n\n\n",
        "CodeNames": [
            "VE3DRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VE3DRewardPool.sol",
                "Type": "Logic Error",
                "Description": "No check for existing extraRewards during push.",
                "Repair": "Add a check for already existing extraRewards before adding them"
            },
            {
                "Location": "VE3DRewardPool.sol",
                "Type": "Loss of Funds",
                "Description": "Deposited staking tokens can be lost if rewards token info added by mistake in addReward() in VE3DRewardPool and there is no checking to ensure this would not happen.",
                "Repair": "Check for values and add validation in addReward()"
            },
            {
                "Location": "VE3DRewardPool.sol",
                "Type": "Incompatibility",
                "Description": "VE3DRewardPool.sol is incompatible with Bal/veBal.",
                "Repair": "Exclude veBal/Bal as a supported asset or create a special wrapper for Bal that adds the Bal as one sided liquidity then stakes the LP."
            },
            {
                "Location": "addExtraReward() function in VE3DRewardPool.sol",
                "Type": "duplicate rewards",
                "Description": "The same reward address can be added multiple times to the extraRewards array, causing rewards to be disbursed twice and breaking protocol invariants.",
                "Repair": "Prevent the same addresses from being added multiple times to the extraRewards array"
            },
            {
                "Location": "VE3DRewardPool claim function",
                "Type": "Loop dependence on pausable token",
                "Description": "If one token has pausable transfer, user cannot claim rewards or withdraw if they have multiple rewards include that pause token.",
                "Repair": "Add a second getReward() function that accepts an array of tokens to interact with instead of withdrawing all token bundles together"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract ExtraRewardStashV2 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant maxRewards = 8;\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public immutable pid;\n    address public immutable veAsset;\n    address public immutable operator;\n    address public immutable staker;\n    address public immutable gauge;\n    address public immutable rewardFactory;\n\n    mapping(address => uint256) public historicalRewards;\n\n    struct TokenInfo {\n        address token;\n        address rewardAddress;\n        uint256 lastActiveTime;\n    }\n    uint256 public tokenCount;\n    TokenInfo[maxRewards] public tokenInfo;\n\n    constructor(\n        uint256 _pid,\n        address _veAsset,\n        address _operator,\n        address _staker,\n        address _gauge,\n        address _rFactory\n    ) {\n        pid = _pid;\n        veAsset = _veAsset;\n        operator = _operator;\n        staker = _staker;\n        gauge = _gauge;\n        rewardFactory = _rFactory;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ExtraRewardStashV2\";\n    }\n\n    //try claiming if there are reward tokens registered\n    function claimRewards() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        //this is updateable in v2 gauges now so must check each time.\n        checkForNewRewardTokens();\n\n        uint256 length = tokenCount;\n        if (length > 0) {\n            //get previous balances of all tokens\n            uint256[] memory balances = new uint256[](length);\n            for (uint256 i = 0; i < length; i++) {\n                balances[i] = IERC20(tokenInfo[i].token).balanceOf(staker);\n            }\n            //claim rewards on gauge for staker\n            //booster will call for future proofing (cant assume anyone will always be able to call)\n            IDeposit(operator).claimRewards(pid, gauge);\n\n            for (uint256 i = 0; i < length; i++) {\n                address token = tokenInfo[i].token;\n                uint256 newbalance = IERC20(token).balanceOf(staker);\n                //stash if balance increased\n                if (newbalance > balances[i]) {\n                    IStaker(staker).withdraw(token);\n                    tokenInfo[i].lastActiveTime = block.timestamp;\n\n                    //make sure this pool is in active list,\n                    IRewardFactory(rewardFactory).addActiveReward(token, pid);\n\n                    //check if other stashes are also active, and if so, send to arbitrator\n                    //do this here because processStash will have tokens from the arbitrator\n                    uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(token);\n                    if (activeCount > 1) {\n                        //send to arbitrator\n                        address arb = IDeposit(operator).rewardArbitrator();\n                        if (arb != address(0)) {\n                            IERC20(token).safeTransfer(arb, newbalance);\n                        }\n                    }\n                } else {\n                    //check if this reward has been inactive too long\n                    if (block.timestamp > tokenInfo[i].lastActiveTime + WEEK) {\n                        //set as inactive\n                        IRewardFactory(rewardFactory).removeActiveReward(token, pid);\n                    } else {\n                        //edge case around reward ending periods\n                        if (newbalance > 0) {\n                            // - recently active pool\n                            // - rewards claimed to staker contract via a deposit/withdraw(or someone manually calling on the gauge)\n                            // - rewards ended before the deposit, thus deposit took the last available tokens\n                            // - thus claimRewards doesnt see any new rewards, but there are rewards on the staker contract\n                            // - i think its safe to assume claim will be called within the timeframe, or else these rewards\n                            //     will be unretrievable until some pool starts rewards again\n\n                            //claim the tokens\n                            IStaker(staker).withdraw(token);\n\n                            uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(\n                                token\n                            );\n                            if (activeCount > 1) {\n                                //send to arbitrator\n                                address arb = IDeposit(operator).rewardArbitrator();\n                                if (arb != address(0)) {\n                                    IERC20(token).safeTransfer(arb, newbalance);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    //check if gauge rewards have changed\n    function checkForNewRewardTokens() internal {\n        for (uint256 i = 0; i < maxRewards; i++) {\n            address token = IGauge(gauge).reward_tokens(i);\n            if (token == address(0)) {\n                for (uint256 x = i; x < tokenCount; x++) {\n                    IRewardFactory(rewardFactory).removeActiveReward(tokenInfo[x].token, pid);\n                }\n                if (i != tokenCount) {\n                    tokenCount = i;\n                }\n                break;\n            }\n            setToken(i, token);\n        }\n    }\n\n    //replace a token on token list\n    function setToken(uint256 _tid, address _token) internal {\n        TokenInfo storage t = tokenInfo[_tid];\n        address currentToken = t.token;\n        if (currentToken != _token) {\n            //set old as inactive\n            IRewardFactory(rewardFactory).removeActiveReward(currentToken, pid);\n\n            //set token address\n            t.token = _token;\n\n            //create new reward contract\n            (, , , address mainRewardContract, , ) = IDeposit(operator).poolInfo(pid);\n            address rewardContract = IRewardFactory(rewardFactory).CreateTokenRewards(\n                _token,\n                mainRewardContract\n            );\n            t.rewardAddress = rewardContract;\n            t.lastActiveTime = 0;\n            //do not set as active yet, wait for first earmark\n        }\n    }\n\n    //pull assigned tokens from staker to stash\n    function stashRewards() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        //after depositing/withdrawing, extra incentive tokens are transfered to the staking contract\n        //need to pull them off and stash here.\n        for (uint256 i = 0; i < tokenCount; i++) {\n            TokenInfo storage t = tokenInfo[i];\n            address token = t.token;\n            if (token == address(0)) continue;\n\n            //only stash if rewards are active\n            if (block.timestamp <= t.lastActiveTime + WEEK) {\n                uint256 before = IERC20(token).balanceOf(address(this));\n                IStaker(staker).withdraw(token);\n\n                //check for multiple pools claiming same token\n                uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(token);\n                if (activeCount > 1) {\n                    //take difference of before/after(only send new tokens)\n                    uint256 amount = IERC20(token).balanceOf(address(this));\n                    amount = amount.sub(before);\n\n                    //send to arbitrator\n                    address arb = IDeposit(operator).rewardArbitrator();\n                    if (arb != address(0)) {\n                        IERC20(token).safeTransfer(arb, amount);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    //send all extra rewards to their reward contracts\n    function processStash() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            TokenInfo storage t = tokenInfo[i];\n            address token = t.token;\n            if (token == address(0)) continue;\n\n            uint256 amount = IERC20(token).balanceOf(address(this));\n            if (amount > 0) {\n                historicalRewards[token] = historicalRewards[token].add(amount);\n                if (token == veAsset) {\n                    //if veAsset, send back to booster to distribute\n                    IERC20(token).safeTransfer(operator, amount);\n                    continue;\n                }\n                //add to reward contract\n                address rewards = t.rewardAddress;\n                if (rewards == address(0)) continue;\n                IERC20(token).safeTransfer(rewards, amount);\n                IRewards(rewards).queueNewRewards(amount);\n            }\n        }\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "ExtraRewardStashV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "stashRewards() function in ExtraRewardStashV2.sol",
                "Type": "lack of check for zero-transfer",
                "Description": "If an arbitrary token doesn't allow for zero amount transfers, the stashRewards() managed extra rewards retrieval can become unavailable.",
                "Repair": "Add a check to run the transfer only when the amount is positive"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/IDeposit.sol\";\n\ncontract BaseRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 constant BLOCKS_PER_DAY = 6450;\n    uint256 constant BLOCKS_PER_YEAR = BLOCKS_PER_DAY * 365;\n    uint256 constant EXTRA_REWARD_POOLS = 3;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event ExtraRewardAdded(address indexed reward);\n    event ExtraRewardCleared();\n    event RewardUpdated(\n        address indexed user,\n        uint256 reward,\n        uint256 rewardPerTokenStored,\n        uint256 lastUpdateTime\n    );\n    event Donated(uint256 queuedRewards);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns (bool) {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n        require(extraRewards.length < EXTRA_REWARD_POOLS, \"!extra reward pools exceed\");\n\n        extraRewards.push(_reward);\n        emit ExtraRewardAdded(_reward);\n        return true;\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n        emit ExtraRewardCleared();\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        emit RewardUpdated(account, rewards[account], rewardPerTokenStored, lastUpdateTime);\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(\n                    totalSupply()\n                )\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(uint256 amount, bool claim) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns (bool)\n    {\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid, amount, msg.sender);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external {\n        withdrawAndUnwrap(_balances[msg.sender], claim);\n    }\n\n    function getReward(address _account, bool _claimExtras)\n        public\n        updateReward(_account)\n        returns (bool)\n    {\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            for (uint256 i = 0; i < extraRewards.length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    function getReward() external returns (bool) {\n        getReward(msg.sender, true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external {\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        queuedRewards = queuedRewards.add(_amount);\n        emit Donated(queuedRewards);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        } else {\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward) internal updateReward(address(0)) {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n\n    function getAPY() external view returns (uint256) {\n        return rewardRate.mul(BLOCKS_PER_YEAR).mul(1e18).div(totalSupply());\n    }\n}\n\n\n",
        "CodeNames": [
            "BaseRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "constructor in BaseRewardPool.sol",
                "Type": "incorrect reward token",
                "Description": "If the rewardToken is set as the stakingToken by mistake, user funds can be lost.",
                "Repair": "Add a check in the constructor to ensure that the stakingToken is not set as the rewardToken"
            },
            {
                "Location": "clearExtraRewards function in BaseRewardPool contract",
                "Type": "User can lose extra rewards",
                "Description": "rewardManager can at any time delete the extra Rewards. This impacts the extra rewards earned by existing staker. The existing staker will have no way to claim these extra rewards.",
                "Repair": "If rewardManager wants to clear extra rewards then all existing stakes on extra rewards must be withdrawn and claimed so that user extra rewards are not lost."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/IDeposit.sol\";\n\ncontract BaseRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 constant BLOCKS_PER_DAY = 6450;\n    uint256 constant BLOCKS_PER_YEAR = BLOCKS_PER_DAY * 365;\n    uint256 constant EXTRA_REWARD_POOLS = 3;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event ExtraRewardAdded(address indexed reward);\n    event ExtraRewardCleared();\n    event RewardUpdated(\n        address indexed user,\n        uint256 reward,\n        uint256 rewardPerTokenStored,\n        uint256 lastUpdateTime\n    );\n    event Donated(uint256 queuedRewards);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns (bool) {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n        require(extraRewards.length < EXTRA_REWARD_POOLS, \"!extra reward pools exceed\");\n\n        extraRewards.push(_reward);\n        emit ExtraRewardAdded(_reward);\n        return true;\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n        emit ExtraRewardCleared();\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        emit RewardUpdated(account, rewards[account], rewardPerTokenStored, lastUpdateTime);\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(\n                    totalSupply()\n                )\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(uint256 amount, bool claim) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns (bool)\n    {\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid, amount, msg.sender);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external {\n        withdrawAndUnwrap(_balances[msg.sender], claim);\n    }\n\n    function getReward(address _account, bool _claimExtras)\n        public\n        updateReward(_account)\n        returns (bool)\n    {\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            for (uint256 i = 0; i < extraRewards.length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    function getReward() external returns (bool) {\n        getReward(msg.sender, true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external {\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        queuedRewards = queuedRewards.add(_amount);\n        emit Donated(queuedRewards);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        } else {\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward) internal updateReward(address(0)) {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n\n    function getAPY() external view returns (uint256) {\n        return rewardRate.mul(BLOCKS_PER_YEAR).mul(1e18).div(totalSupply());\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: vetokenRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VE3DRewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable rewardManager;\n\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    // reward token => reward token info\n    mapping(address => RewardTokenInfo) public rewardTokenInfo;\n    // list of reward tokens\n    EnumerableSet.AddressSet internal rewardTokens;\n    EnumerableSet.AddressSet internal operators;\n\n    address[] public extraRewards;\n\n    struct RewardTokenInfo {\n        address veAssetDeposits;\n        address ve3TokenRewards;\n        address ve3Token;\n        uint256 queuedRewards;\n        uint256 rewardRate;\n        uint256 historicalRewards;\n        uint256 rewardPerTokenStored;\n        uint256 currentRewards;\n        uint256 periodFinish;\n        uint256 lastUpdateTime;\n        mapping(address => uint256) userRewardPerTokenPaid;\n        mapping(address => uint256) rewards;\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(address stakingToken_, address rewardManager_) {\n        stakingToken = IERC20(stakingToken_);\n\n        rewardManager = rewardManager_;\n    }\n\n    function addReward(\n        address _rewardToken,\n        address _veAssetDeposits,\n        address _ve3TokenRewards,\n        address _ve3Token\n    ) external onlyOwner {\n        rewardTokenInfo[_rewardToken].veAssetDeposits = _veAssetDeposits;\n        rewardTokenInfo[_rewardToken].ve3TokenRewards = _ve3TokenRewards;\n        rewardTokenInfo[_rewardToken].ve3Token = _ve3Token;\n        rewardTokens.add(_rewardToken);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored = rewardPerToken(_rewardToken);\n            rewardTokenInfo[_rewardToken].lastUpdateTime = lastTimeRewardApplicable(_rewardToken);\n            if (account != address(0)) {\n                rewardTokenInfo[_rewardToken].rewards[account] = earnedReward(\n                    _rewardToken,\n                    account\n                );\n                rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account] = rewardTokenInfo[\n                    _rewardToken\n                ].rewardPerTokenStored;\n            }\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n        return Math.min(block.timestamp, rewardTokenInfo[_rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardToken) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return rewardTokenInfo[_rewardToken].rewardPerTokenStored;\n        }\n        return\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored.add(\n                lastTimeRewardApplicable(_rewardToken)\n                    .sub(rewardTokenInfo[_rewardToken].lastUpdateTime)\n                    .mul(rewardTokenInfo[_rewardToken].rewardRate)\n                    .mul(1e18)\n                    .div(supply)\n            );\n    }\n\n    function earnedReward(address _rewardToken, address account) internal view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(\n                    rewardPerToken(_rewardToken).sub(\n                        rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account]\n                    )\n                )\n                .div(1e18)\n                .add(rewardTokenInfo[_rewardToken].rewards[account]);\n    }\n\n    function earned(address _rewardToken, address account) external view returns (uint256) {\n        uint256 depositFeeRate = IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits)\n            .lockIncentive();\n\n        uint256 r = earnedReward(_rewardToken, account);\n        uint256 fees = r.mul(depositFeeRate).div(FEE_DENOMINATOR);\n\n        //fees dont apply until whitelist+veVeAsset lock begins so will report\n        //slightly less value than what is actually received.\n        return r.sub(fees);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to _for's balance sheet\n        _balances[_for] = _balances[_for].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, bool claim) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(_amount);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n\n        if (claim) {\n            getReward(msg.sender, true, false);\n        }\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool _stake\n    ) public updateReward(_account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n\n            uint256 reward = earnedReward(_rewardToken, _account);\n            if (reward > 0) {\n                rewardTokenInfo[_rewardToken].rewards[_account] = 0;\n                IERC20(_rewardToken).safeApprove(rewardTokenInfo[_rewardToken].veAssetDeposits, 0);\n                IERC20(_rewardToken).safeApprove(\n                    rewardTokenInfo[_rewardToken].veAssetDeposits,\n                    reward\n                );\n                IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits).deposit(\n                    reward,\n                    false\n                );\n\n                uint256 ve3TokenBalance = IERC20(rewardTokenInfo[_rewardToken].ve3Token).balanceOf(\n                    address(this)\n                );\n                if (_stake) {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        0\n                    );\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        ve3TokenBalance\n                    );\n                    IRewards(rewardTokenInfo[_rewardToken].ve3TokenRewards).stakeFor(\n                        _account,\n                        ve3TokenBalance\n                    );\n                } else {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeTransfer(\n                        _account,\n                        ve3TokenBalance\n                    );\n                }\n                emit RewardPaid(_account, ve3TokenBalance);\n            }\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            uint256 length = extraRewards.length;\n            for (uint256 i = 0; i < length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n    }\n\n    function getReward(bool _stake) external {\n        getReward(msg.sender, true, _stake);\n    }\n\n    function donate(address _rewardToken, uint256 _amount) external {\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        rewardTokenInfo[_rewardToken].queuedRewards += _amount;\n    }\n\n    function queueNewRewards(address _rewardToken, uint256 _rewards) external {\n        require(operators.contains(_msgSender()), \"!authorized\");\n\n        _rewards = _rewards.add(rewardTokenInfo[_rewardToken].queuedRewards);\n\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(\n            rewardTokenInfo[_rewardToken].periodFinish.sub(duration)\n        );\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardTokenInfo[_rewardToken].rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n        } else {\n            rewardTokenInfo[_rewardToken].queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardToken, uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        rewardTokenInfo[_rewardToken].historicalRewards += reward;\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = rewardTokenInfo[_rewardToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardTokenInfo[_rewardToken].rewardRate);\n            reward = reward.add(leftover);\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        }\n        rewardTokenInfo[_rewardToken].currentRewards = reward;\n        rewardTokenInfo[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardTokenInfo[_rewardToken].periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}\n\n\n",
        "CodeNames": [
            "BaseRewardPool.sol",
            "VE3DRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VE3DRewardPool and BaseRewardPool contracts",
                "Type": "Unused rewards locked forever",
                "Description": "If totalSupply() is 0 for some period, rewards will not be added to rewardPerTokenStored and those period rewards would not distribute to any address and those rewards will be stuck in contract forever.",
                "Repair": "Add mechanism to recalculate rewardRate or calculate undistributed rewards based on rewardRate and when totalSupply() is 0"
            },
            {
                "Location": "notifyRewardAmount function in VE3DRewardPool and BaseRewardPool contracts",
                "Type": "Rounding error",
                "Description": "Some tokens will be locked and not distributed due to rounding error in rewardRate calculation.",
                "Repair": "Add extra amount to queuedRewards or add other mechanism to recover it"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IVoteEscrow.sol\";\nimport \"./Interfaces/IDeposit.sol\";\nimport \"./Interfaces/IFeeDistro.sol\";\nimport \"./Interfaces/IVoting.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\n\ncontract VoterProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable veAsset;\n    address public immutable escrow;\n    address public immutable gaugeProxy;\n\n    address public immutable minter;\n\n    address public owner;\n    address public operator;\n    address public depositor;\n    string public name;\n    IVoteEscrow.EscrowModle public escrowModle;\n\n    mapping(address => bool) private protectedTokens;\n    mapping(address => bool) private stashPool;\n    mapping(bytes32 => bool) private votes;\n\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    event VoteSet(bytes32 hash, bool valid);\n\n    constructor(\n        string memory _name,\n        address _veAsset,\n        address _escrow,\n        address _gaugeProxy,\n        address _minter,\n        IVoteEscrow.EscrowModle _escrowModle\n    ) {\n        name = _name;\n        veAsset = _veAsset;\n        escrow = _escrow;\n        gaugeProxy = _gaugeProxy;\n        owner = msg.sender;\n        minter = _minter;\n        escrowModle = _escrowModle;\n    }\n\n    function getName() external view returns (string memory) {\n        return name;\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    function setOperator(address _operator) external {\n        require(msg.sender == owner, \"!auth\");\n        require(\n            operator == address(0) || IDeposit(operator).isShutdown() == true,\n            \"needs shutdown\"\n        );\n\n        operator = _operator;\n    }\n\n    function setDepositor(address _depositor) external {\n        require(msg.sender == owner, \"!auth\");\n\n        depositor = _depositor;\n    }\n\n    function setStashAccess(address _stash, bool _status) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        if (_stash != address(0)) {\n            stashPool[_stash] = _status;\n        }\n        return true;\n    }\n\n    function deposit(address _token, address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        if (protectedTokens[_token] == false) {\n            protectedTokens[_token] = true;\n        }\n        if (protectedTokens[_gauge] == false) {\n            protectedTokens[_gauge] = true;\n        }\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(_token).safeApprove(_gauge, 0);\n            IERC20(_token).safeApprove(_gauge, balance);\n            IGauge(_gauge).deposit(balance);\n        }\n        return true;\n    }\n\n    //stash only function for pulling extra incentive reward tokens out\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(stashPool[msg.sender] == true, \"!auth\");\n\n        //check protection\n        if (protectedTokens[address(_asset)] == true) {\n            return 0;\n        }\n\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(msg.sender, balance);\n        return balance;\n    }\n\n    // Withdraw partial funds\n    function withdraw(\n        address _token,\n        address _gauge,\n        uint256 _amount\n    ) public returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_gauge, _amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        return true;\n    }\n\n    function withdrawAll(address _token, address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));\n        withdraw(_token, _gauge, amount);\n        return true;\n    }\n\n    function _withdrawSome(address _gauge, uint256 _amount) internal returns (uint256) {\n        IGauge(_gauge).withdraw(_amount);\n        return _amount;\n    }\n\n    function createLock(uint256 _value, uint256 _unlockTime) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(veAsset).safeApprove(escrow, 0);\n        IERC20(veAsset).safeApprove(escrow, _value);\n        IVoteEscrow(escrow).create_lock(_value, _unlockTime);\n        return true;\n    }\n\n    function increaseAmount(uint256 _value) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(veAsset).safeApprove(escrow, 0);\n        IERC20(veAsset).safeApprove(escrow, _value);\n        IVoteEscrow(escrow).increase_amount(_value);\n        return true;\n    }\n\n    function increaseTime(uint256 _value) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IVoteEscrow(escrow).increase_unlock_time(_value);\n        return true;\n    }\n\n    function release() external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IVoteEscrow(escrow).withdraw();\n        return true;\n    }\n\n    /**\n     * @notice Save a vote hash so when snapshot.org asks this contract if\n     *          a vote signature is valid we are able to check for a valid hash\n     *          and return the appropriate response inline with EIP 1721\n     * @param _hash  Hash of vote signature that was sent to snapshot.org\n     * @param _valid Is the hash valid\n     */\n    function setVote(bytes32 _hash, bool _valid) external {\n        require(msg.sender == operator, \"!auth\");\n        votes[_hash] = _valid;\n        emit VoteSet(_hash, _valid);\n    }\n\n    /**\n     * @notice  Verifies that the hash is valid\n     * @dev     Snapshot Hub will call this function when a vote is submitted using\n     *          snapshot.js on behalf of this contract. Snapshot Hub will call this\n     *          function with the hash and the signature of the vote that was cast.\n     * @param _hash Hash of the message that was sent to Snapshot Hub to cast a vote\n     * @return EIP1271 magic value if the signature is value\n     */\n    function isValidSignature(bytes32 _hash, bytes memory) public view returns (bytes4) {\n        if (votes[_hash]) {\n            return EIP1271_MAGIC_VALUE;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    function voteGaugeWeight(address[] calldata _tokenVote, uint256[] calldata _weight)\n        external\n        returns (bool)\n    {\n        require(msg.sender == operator, \"!auth\");\n\n        if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n            //vote\n            IVoting(gaugeProxy).vote(_tokenVote, _weight);\n        } else {\n            for (uint256 i = 0; i < _tokenVote.length; i++) {\n                IVoting(gaugeProxy).vote_for_gauge_weights(_tokenVote[i], _weight[i]);\n            }\n        }\n        return true;\n    }\n\n    function claimVeAsset(address _gauge) external returns (uint256) {\n        require(msg.sender == operator, \"!auth\");\n\n        uint256 _balance = 0;\n\n        if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n            try IGauge(_gauge).getReward() {} catch {\n                return _balance;\n            }\n        } else if (\n            escrowModle == IVoteEscrow.EscrowModle.CURVE ||\n            escrowModle == IVoteEscrow.EscrowModle.RIBBON\n        ) {\n            try ITokenMinter(minter).mint(_gauge) {} catch {\n                return _balance;\n            }\n        } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {\n            try ITokenMinter(minter).distribute(_gauge) {} catch {\n                return _balance;\n            }\n        } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {\n            try IGauge(_gauge).claim_rewards() {} catch {\n                return _balance;\n            }\n        }\n\n        _balance = IERC20(veAsset).balanceOf(address(this));\n        IERC20(veAsset).safeTransfer(operator, _balance);\n\n        return _balance;\n    }\n\n    function claimRewards(address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        IGauge(_gauge).claim_rewards();\n        return true;\n    }\n\n    function claimFees(address _distroContract, address _token) external returns (uint256) {\n        require(msg.sender == operator, \"!auth\");\n        IFeeDistro(_distroContract).claim();\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(operator, _balance);\n        return _balance;\n    }\n\n    function balanceOfPool(address _gauge) public view returns (uint256) {\n        return IGauge(_gauge).balanceOf(address(this));\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bool, bytes memory) {\n        require(msg.sender == operator, \"!auth\");\n\n        (bool success, bytes memory result) = _to.call{value: _value}(_data);\n        require(success, \"!success\");\n\n        return (success, result);\n    }\n}\n\n\n",
        "CodeNames": [
            "VoterProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "withdrawAll and execute functions in VoterProxy contract",
                "Type": "Malicious operator can rug pull",
                "Description": "A compromised or malicious operator can withdraw all tokens by calling the function withdrawAll or call an arbitrary address with any value.",
                "Repair": "Use multi-sig wallet as operator"
            },
            {
                "Location": "VoterProxy contract, withdrawAll function",
                "Type": "Incorrect assumption of 1-1 mapping between gauge and LP tokens",
                "Description": "The VoterProxy contract incorrectly assumes a 1-1 mapping between the gauge and the LP tokens, which may lead to a loss of funds when calling withdrawAll.",
                "Repair": "Use the total supply of pool.token to calculate the amount to withdraw when withdrawing all, and poke the gauge for exchange rates and check available tokens after withdrawing"
            },
            {
                "Location": "setOperator, execute, withdraw, and withdrawAll functions in VoterProxy.sol",
                "Type": "Centralization risk",
                "Description": "Owner may set the operator to an address they own and drain all token balances.",
                "Repair": "Remove the ability for the owner to change the operator or put it behind a time lock and multisig/dao"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"./helper/MathUtil.sol\";\nimport \"./helper/BoringMath.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\n/*\nVE3D Locking contract for https://www.convexfinance.com/\nVE3D locked in this contract will be entitled to voting rights for the Vetoken Finance platform\nBased on EPS Staking contract for http://ellipsis.finance/\nBased on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\n\nV2:\n- change locking mechanism to lock to a future epoch instead of current\n- pending lock getter\n- relocking allocates weight to the current epoch instead of future,\n    thus allows keeping voting weight in the same epoch a lock expires by relocking before a vote begins\n- balanceAtEpoch and supplyAtEpoch return proper values for future epochs\n- do not allow relocking directly to a new address\n*/\ncontract VE3DLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* ========== STATE VARIABLES ========== */\n\n    struct Reward {\n        bool isVeAsset;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n        address ve3Token;\n        address ve3TokenStaking;\n        address veAssetDeposits;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n\n    //token\n    IERC20 public stakingToken; //VE3D\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address => Reward) public rewardData;\n\n    EnumerableSet.AddressSet internal operators;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 16;\n\n    // reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n\n    // user -> reward token -> amount\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    uint256 public constant denominator = 10000;\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _stakingToken) Ownable() {\n        _name = \"Vote Locked Vetoken Token\";\n        _symbol = \"xVE3D\";\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function version() public pure returns (uint256) {\n        return 2;\n    }\n\n    /* ========== ADMIN CONFIGURATION ========== */\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _veAssetDeposits,\n        address _ve3Token,\n        address _ve3TokenStaking,\n        address _distributor,\n        bool _isVeAsset\n    ) external {\n        require(_msgSender() == owner() || operators.contains(_msgSender()), \"!Auth\");\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n\n        rewardData[_rewardsToken].isVeAsset = _isVeAsset;\n        // if reward is veAsset\n        if (_isVeAsset) {\n            require(_ve3Token != address(0));\n            require(_ve3TokenStaking != address(0));\n            require(_veAssetDeposits != address(0));\n            rewardData[_rewardsToken].ve3Token = _ve3Token;\n            rewardData[_rewardsToken].ve3TokenStaking = _ve3TokenStaking;\n            rewardData[_rewardsToken].veAssetDeposits = _veAssetDeposits;\n        }\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    //set approvals for locking veAsset and staking VE3Token\n    function setApprovals() external {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            if (rewardData[_rewardsToken].isVeAsset) {\n                // set approve for staking VE3Token\n                IERC20(rewardData[_rewardsToken].ve3Token).safeApprove(\n                    rewardData[_rewardsToken].ve3TokenStaking,\n                    0\n                );\n                IERC20(rewardData[_rewardsToken].ve3Token).safeApprove(\n                    rewardData[_rewardsToken].ve3TokenStaking,\n                    type(uint256).max\n                );\n\n                // set approve for locking veAsset\n                IERC20(_rewardsToken).safeApprove(rewardData[_rewardsToken].veAssetDeposits, 0);\n                IERC20(_rewardsToken).safeApprove(\n                    rewardData[_rewardsToken].veAssetDeposits,\n                    type(uint256).max\n                );\n            }\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {\n        if (lockedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(lockedSupply)\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                    _rewardPerToken(_rewardsToken).sub(\n                        userRewardPerTokenPaid[_user][_rewardsToken]\n                    )\n                )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256) {\n        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256) {\n        return uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData[](rewardTokens.length);\n        Balances storage userBalance = balances[_account];\n        for (uint256 i = 0; i < userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(_account, token, userBalance.locked);\n        }\n        return userRewards;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user) external view returns (uint256 amount) {\n        return balances[_user].locked;\n    }\n\n    //balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        return balanceAtEpochOf(findEpochId(block.timestamp), _user);\n    }\n\n    //balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we're basing from.\n            if (lockEpoch <= epochTime) {\n                if (lockEpoch > cutoffEpoch) {\n                    amount = amount.add(locks[i].amount);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //return currently locked but not active balance\n    function pendingLockOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        uint256 locksLength = locks.length;\n\n        //return amount if latest lock is in the future\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength > 0 &&\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) > currentEpoch\n        ) {\n            return locks[locksLength - 1].amount;\n        }\n\n        return 0;\n    }\n\n    function pendingLockAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get next epoch from the given epoch index\n        uint256 nextEpoch = uint256(epochs[_epoch].date).add(rewardsDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n\n            //return the next epoch balance\n            if (lockEpoch == nextEpoch) {\n                return locks[i].amount;\n            } else if (lockEpoch < nextEpoch) {\n                //no need to check anymore\n                break;\n            }\n        }\n\n        return 0;\n    }\n\n    //supply of all properly locked balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include next epoch's supply\n        if (uint256(epochs[epochindex - 1].date) > currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply) {\n        uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n            rewardsDuration\n        );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) public view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock < _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user's locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        //create new epoch in the future where new non-active locks will lock to\n        uint256 nextEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration).add(\n            rewardsDuration\n        );\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date < nextEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != nextEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(\n                    rewardsDuration\n                );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, false);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        bool _isRelock\n    ) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n\n        //add user lock records or add to current\n        uint256 lockEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        //if a fresh lock, add on an extra duration period\n        if (!_isRelock) {\n            lockEpoch = lockEpoch.add(rewardsDuration);\n        }\n        uint256 unlockTime = lockEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n\n        //if the latest user lock is smaller than this lock, always just add new entry to the end of the list\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({amount: lockAmount, unlockTime: uint32(unlockTime)})\n            );\n        } else {\n            //else add to a current lock\n\n            //if latest lock is further in the future, lower index\n            //this can only happen if relocking an expired lock after creating a new lock\n            if (userLocks[_account][idx - 1].unlockTime > unlockTime) {\n                idx--;\n            }\n\n            //if idx points to the epoch when same unlock time, update\n            //(this is always true with a normal lock but maybe not with relock)\n            if (userLocks[_account][idx - 1].unlockTime == unlockTime) {\n                LockedBalance storage userL = userLocks[_account][idx - 1];\n                userL.amount = userL.amount.add(lockAmount);\n            } else {\n                //can only enter here if a relock is made after a lock and there's no lock entry\n                //for the current epoch.\n                //ex a list of locks such as \"[...][older][current*][next]\" but without a \"current\" lock\n                //length - 1 is the next epoch\n                //length - 2 is a past epoch\n                //thus need to insert an entry for current epoch at the 2nd to last entry\n                //we will copy and insert the tail entry(next) and then overwrite length-2 entry\n\n                //reset idx\n                idx = userLocks[_account].length;\n\n                //get current last item\n                LockedBalance storage userL = userLocks[_account][idx - 1];\n\n                //add a copy to end of list\n                userLocks[_account].push(\n                    LockedBalance({amount: userL.amount, unlockTime: userL.unlockTime})\n                );\n\n                //insert current epoch lock entry by overwriting the entry at length-2\n                userL.amount = lockAmount;\n                userL.unlockTime = uint32(unlockTime);\n            }\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        uint256 eIndex = epochs.length - 1;\n        //if relock, epoch should be current and not next, thus need to decrease index to length-2\n        if (_isRelock) {\n            eIndex--;\n        }\n        Epoch storage e = epochs[eIndex];\n        e.supply = e.supply.add(uint224(lockAmount));\n\n        emit Staked(_account, lockEpoch, _amount, lockAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n\n        if (isShutdown || locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                    rewardsDuration\n                );\n                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                    rewardsDuration\n                );\n                uint256 rRate = MathUtil.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay)) break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch = block\n                        .timestamp\n                        .sub(_checkDelay)\n                        .div(rewardsDuration)\n                        .mul(rewardsDuration);\n                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                        rewardsDuration\n                    );\n                    uint256 rRate = MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        lockedSupply = lockedSupply.sub(locked);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            stakingToken.safeTransfer(_rewardAddress, reward);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, true);\n        } else {\n            stakingToken.safeTransfer(_withdrawTo, locked);\n        }\n    }\n\n    // withdraw expired locks to a different address\n    function withdrawExpiredLocksTo(address _withdrawTo) external nonReentrant {\n        _processExpiredLocks(msg.sender, false, _withdrawTo, msg.sender, 0);\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(\n            _account,\n            false,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward > 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (rewardData[_rewardsToken].isVeAsset) {\n                    IVeAssetDeposit(rewardData[_rewardsToken].veAssetDeposits).deposit(\n                        reward,\n                        false\n                    );\n                    uint256 _ve3TokenBalance = IERC20(rewardData[_rewardsToken].ve3Token)\n                        .balanceOf(address(this));\n\n                    if (_stake) {\n                        IRewards(rewardData[_rewardsToken].ve3TokenStaking).stakeFor(\n                            _account,\n                            _ve3TokenBalance\n                        );\n                    } else {\n                        IERC20(rewardData[_rewardsToken].ve3Token).safeTransfer(\n                            _account,\n                            _ve3TokenBalance\n                        );\n                    }\n                    reward = _ve3TokenBalance;\n                    _rewardsToken = rewardData[_rewardsToken].ve3Token;\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp >= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function queueNewRewards(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender], \"Auth!\");\n        require(_reward > 0, \"No reward\");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        emit RewardAdded(_rewardsToken, _reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token).to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token].periodFinish\n                ).to40();\n                if (_account != address(0)) {\n                    rewards[_account][token] = _earned(_account, token, userBalance.locked);\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 indexed _epoch,\n        uint256 _paidAmount,\n        uint256 _lockedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);\n    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);\n    event Recovered(address _token, uint256 _amount);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: vetokenRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VE3DRewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable rewardManager;\n\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    // reward token => reward token info\n    mapping(address => RewardTokenInfo) public rewardTokenInfo;\n    // list of reward tokens\n    EnumerableSet.AddressSet internal rewardTokens;\n    EnumerableSet.AddressSet internal operators;\n\n    address[] public extraRewards;\n\n    struct RewardTokenInfo {\n        address veAssetDeposits;\n        address ve3TokenRewards;\n        address ve3Token;\n        uint256 queuedRewards;\n        uint256 rewardRate;\n        uint256 historicalRewards;\n        uint256 rewardPerTokenStored;\n        uint256 currentRewards;\n        uint256 periodFinish;\n        uint256 lastUpdateTime;\n        mapping(address => uint256) userRewardPerTokenPaid;\n        mapping(address => uint256) rewards;\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(address stakingToken_, address rewardManager_) {\n        stakingToken = IERC20(stakingToken_);\n\n        rewardManager = rewardManager_;\n    }\n\n    function addReward(\n        address _rewardToken,\n        address _veAssetDeposits,\n        address _ve3TokenRewards,\n        address _ve3Token\n    ) external onlyOwner {\n        rewardTokenInfo[_rewardToken].veAssetDeposits = _veAssetDeposits;\n        rewardTokenInfo[_rewardToken].ve3TokenRewards = _ve3TokenRewards;\n        rewardTokenInfo[_rewardToken].ve3Token = _ve3Token;\n        rewardTokens.add(_rewardToken);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored = rewardPerToken(_rewardToken);\n            rewardTokenInfo[_rewardToken].lastUpdateTime = lastTimeRewardApplicable(_rewardToken);\n            if (account != address(0)) {\n                rewardTokenInfo[_rewardToken].rewards[account] = earnedReward(\n                    _rewardToken,\n                    account\n                );\n                rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account] = rewardTokenInfo[\n                    _rewardToken\n                ].rewardPerTokenStored;\n            }\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n        return Math.min(block.timestamp, rewardTokenInfo[_rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardToken) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return rewardTokenInfo[_rewardToken].rewardPerTokenStored;\n        }\n        return\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored.add(\n                lastTimeRewardApplicable(_rewardToken)\n                    .sub(rewardTokenInfo[_rewardToken].lastUpdateTime)\n                    .mul(rewardTokenInfo[_rewardToken].rewardRate)\n                    .mul(1e18)\n                    .div(supply)\n            );\n    }\n\n    function earnedReward(address _rewardToken, address account) internal view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(\n                    rewardPerToken(_rewardToken).sub(\n                        rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account]\n                    )\n                )\n                .div(1e18)\n                .add(rewardTokenInfo[_rewardToken].rewards[account]);\n    }\n\n    function earned(address _rewardToken, address account) external view returns (uint256) {\n        uint256 depositFeeRate = IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits)\n            .lockIncentive();\n\n        uint256 r = earnedReward(_rewardToken, account);\n        uint256 fees = r.mul(depositFeeRate).div(FEE_DENOMINATOR);\n\n        //fees dont apply until whitelist+veVeAsset lock begins so will report\n        //slightly less value than what is actually received.\n        return r.sub(fees);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to _for's balance sheet\n        _balances[_for] = _balances[_for].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, bool claim) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(_amount);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n\n        if (claim) {\n            getReward(msg.sender, true, false);\n        }\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool _stake\n    ) public updateReward(_account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n\n            uint256 reward = earnedReward(_rewardToken, _account);\n            if (reward > 0) {\n                rewardTokenInfo[_rewardToken].rewards[_account] = 0;\n                IERC20(_rewardToken).safeApprove(rewardTokenInfo[_rewardToken].veAssetDeposits, 0);\n                IERC20(_rewardToken).safeApprove(\n                    rewardTokenInfo[_rewardToken].veAssetDeposits,\n                    reward\n                );\n                IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits).deposit(\n                    reward,\n                    false\n                );\n\n                uint256 ve3TokenBalance = IERC20(rewardTokenInfo[_rewardToken].ve3Token).balanceOf(\n                    address(this)\n                );\n                if (_stake) {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        0\n                    );\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        ve3TokenBalance\n                    );\n                    IRewards(rewardTokenInfo[_rewardToken].ve3TokenRewards).stakeFor(\n                        _account,\n                        ve3TokenBalance\n                    );\n                } else {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeTransfer(\n                        _account,\n                        ve3TokenBalance\n                    );\n                }\n                emit RewardPaid(_account, ve3TokenBalance);\n            }\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            uint256 length = extraRewards.length;\n            for (uint256 i = 0; i < length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n    }\n\n    function getReward(bool _stake) external {\n        getReward(msg.sender, true, _stake);\n    }\n\n    function donate(address _rewardToken, uint256 _amount) external {\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        rewardTokenInfo[_rewardToken].queuedRewards += _amount;\n    }\n\n    function queueNewRewards(address _rewardToken, uint256 _rewards) external {\n        require(operators.contains(_msgSender()), \"!authorized\");\n\n        _rewards = _rewards.add(rewardTokenInfo[_rewardToken].queuedRewards);\n\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(\n            rewardTokenInfo[_rewardToken].periodFinish.sub(duration)\n        );\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardTokenInfo[_rewardToken].rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n        } else {\n            rewardTokenInfo[_rewardToken].queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardToken, uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        rewardTokenInfo[_rewardToken].historicalRewards += reward;\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = rewardTokenInfo[_rewardToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardTokenInfo[_rewardToken].rewardRate);\n            reward = reward.add(leftover);\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        }\n        rewardTokenInfo[_rewardToken].currentRewards = reward;\n        rewardTokenInfo[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardTokenInfo[_rewardToken].periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}\n\n\n",
        "CodeNames": [
            "VE3DLocker.sol",
            "VE3DRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VE3DRewardPool and VE3DLocker contracts",
                "Type": "Unbounded Array",
                "Description": "The addReward() function allows the owner to add a new reward token to the unbounded list rewardTokens, which when appended to cannot be shortened. This can cause a state where all transactions which iterate over this list will revert, making it impossible to withdraw any rewards from the contract.",
                "Repair": "Implement a method for removing old reward tokens which are no longer in use, set a hard limit on the number of reward tokens that can be added, or allow rewards to be iterated and distributed on a per token basis rather than all tokens at once."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IFeeDistro.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/ITokenFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\nimport \"./Interfaces/IStash.sol\";\nimport \"./Interfaces/IStashFactory.sol\";\n\ncontract Booster {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // ve3Token reward pool\n    uint256 public lockIncentive = 1000; //incentive to veAsset stakers\n    // veToken reward pool\n    uint256 public stakerIncentive = 450; //incentive to native token stakers\n    // veToken locking reward pool xVE3D\n    uint256 public stakerLockIncentive;\n    // caller reward\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    // platoform fee\n    uint256 public platformFee; //possible fee to build treasury\n    uint256 public constant MaxFees = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    uint256 public lockFeesIncentive = 10000; //ve3Token veVeAsset fees percentage\n    uint256 public stakerLockFeesIncentive; //xVE3D veVeAsset fees percentage\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public immutable veAsset;\n    address public immutable feeDistro;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //vetoken rewards\n    address public stakerLockRewards; // veToken lock rewards xVE3D\n    address public lockRewards; //ve3Token rewards(veAsset)\n    address public lockFees; //ve3Token veVeAsset fees\n    address public feeToken;\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address veAssetRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n    event OwnerUpdated(address indexed owner);\n    event FeeManagerUpdated(address indexed feeM);\n    event PoolManagerUpdated(address indexed poolM);\n    event FactoriesUpdated(address indexed rfactory, address indexed tfactory);\n    event ArbitratorUpdated(address indexed arb);\n    event VoteDelegateUpdated(address indexed voteDelegate);\n    event RewardContractsUpdated(\n        address indexed rewards,\n        address indexed stakerRewards,\n        address indexed stakerLockRewards\n    );\n    event FeesUpdated(\n        uint256 lockFees,\n        uint256 stakerFees,\n        uint256 stakerLockFee,\n        uint256 callerFees,\n        uint256 platform\n    );\n    event TreasuryUpdated(address indexed treasury);\n    event PoolAdded(\n        address indexed lptoken,\n        address indexed gauge,\n        address indexed token,\n        address rewardPool\n    );\n    event PoolShuttedDown(uint256 indexed pid);\n    event SystemShuttedDown();\n    event Voted(uint256 indexed voteId, address indexed votingAddress, bool support);\n\n    constructor(\n        address _staker,\n        address _minter,\n        address _veAsset,\n        address _feeDistro\n    ) {\n        isShutdown = false;\n        staker = _staker;\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        poolManager = msg.sender;\n        minter = _minter;\n        veAsset = _veAsset;\n        feeDistro = _feeDistro;\n    }\n\n    /// SETTER SECTION ///\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n        emit OwnerUpdated(_owner);\n    }\n\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n        emit FeeManagerUpdated(_feeM);\n    }\n\n    function setPoolManager(address _poolM) external {\n        require(msg.sender == poolManager, \"!auth\");\n        poolManager = _poolM;\n        emit PoolManagerUpdated(_poolM);\n    }\n\n    function setFactories(\n        address _rfactory,\n        address _sfactory,\n        address _tfactory\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward factory only allow this to be called once even if owner\n        //removes ability to inject malicious staking contracts\n        //token factory can also be immutable\n        if (rewardFactory == address(0)) {\n            rewardFactory = _rfactory;\n            tokenFactory = _tfactory;\n            emit FactoriesUpdated(_rfactory, _tfactory);\n        }\n\n        //stash factory should be considered more safe to change\n        //updating may be required to handle new types of gauges\n        stashFactory = _sfactory;\n    }\n\n    function setArbitrator(address _arb) external {\n        require(msg.sender == owner, \"!auth\");\n        rewardArbitrator = _arb;\n        emit ArbitratorUpdated(_arb);\n    }\n\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender == voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n        emit VoteDelegateUpdated(_voteDelegate);\n    }\n\n    function setRewardContracts(\n        address _rewards,\n        address _stakerRewards,\n        address _stakerLockRewards\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward contracts are immutable or else the owner\n        //has a means to redeploy and mint cvx via rewardClaimed()\n        if (lockRewards == address(0)) {\n            lockRewards = _rewards;\n            stakerRewards = _stakerRewards;\n            stakerLockRewards = _stakerLockRewards;\n        }\n\n        emit RewardContractsUpdated(_rewards, _stakerRewards, _stakerLockRewards);\n    }\n\n    // Set reward token and claim contract, get from Curve's registry\n    function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        lockFeesIncentive = _lockFeesIncentive;\n        stakerLockFeesIncentive = _stakerLockFeesIncentive;\n\n        address _feeToken = IFeeDistro(feeDistro).token();\n        if (feeToken != _feeToken) {\n            //create a new reward contract for the new token\n            lockFees = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken, lockRewards);\n\n            if (_feeToken != veAsset) {\n                IRewards(stakerLockRewards).addReward(\n                    _feeToken,\n                    address(0),\n                    address(0),\n                    address(0),\n                    address(this),\n                    false\n                );\n            }\n\n            feeToken = _feeToken;\n        }\n    }\n\n    function setFees(\n        uint256 _lockFees,\n        uint256 _stakerFees,\n        uint256 _stakerLockIncentiveFee,\n        uint256 _callerFees,\n        uint256 _platform\n    ) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform).add(\n            _stakerLockIncentiveFee\n        );\n        require(total <= MaxFees, \">MaxFees\");\n\n        //values must be within certain ranges\n\n        lockIncentive = _lockFees;\n        stakerIncentive = _stakerFees;\n        stakerLockIncentive = _stakerLockIncentiveFee;\n        earmarkIncentive = _callerFees;\n        platformFee = _platform;\n        emit FeesUpdated(_lockFees, _stakerFees, _stakerLockIncentiveFee, _callerFees, _platform);\n    }\n\n    function setTreasury(address _treasury) external {\n        require(msg.sender == feeManager, \"!auth\");\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /// END SETTER SECTION ///\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //create a new pool\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool) {\n        require(msg.sender == poolManager && !isShutdown, \"!add\");\n        require(_gauge != address(0) && _lptoken != address(0), \"!param\");\n\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);\n        //create a reward contract for veAsset rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateVeAssetRewards(pid, token);\n\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(\n            pid,\n            veAsset,\n            _gauge,\n            staker,\n            _stashVersion\n        );\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: token,\n                gauge: _gauge,\n                veAssetRewards: newRewardPool,\n                stash: stash,\n                shutdown: false\n            })\n        );\n        gaugeMap[_gauge] = true;\n\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards\n        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge\n        if (stash != address(0)) {\n            poolInfo[pid].stash = stash;\n            IStaker(staker).setStashAccess(stash, true);\n            IRewardFactory(rewardFactory).setAccess(stash, true);\n        }\n        emit PoolAdded(_lptoken, _gauge, token, newRewardPool);\n\n        return true;\n    }\n\n    //shutdown pool\n    function shutdownPool(uint256 _pid) external returns (bool) {\n        require(msg.sender == poolManager, \"!auth\");\n        PoolInfo storage pool = poolInfo[_pid];\n\n        //withdraw from gauge\n        try IStaker(staker).withdrawAll(pool.lptoken, pool.gauge) {} catch {}\n\n        pool.shutdown = true;\n        gaugeMap[pool.gauge] = false;\n\n        emit PoolShuttedDown(_pid);\n        return true;\n    }\n\n    //shutdown this contract.\n    //  unstake and pull all lp tokens to this address\n    //  only allow withdrawals\n    function shutdownSystem() external {\n        require(msg.sender == owner, \"!auth\");\n        isShutdown = true;\n\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            PoolInfo storage pool = poolInfo[i];\n            if (pool.shutdown) continue;\n\n            address token = pool.lptoken;\n            address gauge = pool.gauge;\n\n            //withdraw from gauge\n            try IStaker(staker).withdrawAll(token, gauge) {\n                pool.shutdown = true;\n            } catch {}\n        }\n        emit SystemShuttedDown();\n    }\n\n    //deposit lp tokens and stake\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) public returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);\n\n        //stake\n        address gauge = pool.gauge;\n        require(gauge != address(0), \"!gauge setting\");\n        IStaker(staker).deposit(lptoken, gauge);\n\n        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            IStash(stash).stashRewards();\n        }\n\n        address token = pool.token;\n        if (_stake) {\n            //mint here and send to rewards on user behalf\n            ITokenMinter(token).mint(address(this), _amount);\n            address rewardContract = pool.veAssetRewards;\n            IERC20(token).safeApprove(rewardContract, _amount);\n            IRewards(rewardContract).stakeFor(msg.sender, _amount);\n        } else {\n            //add user balance directly\n            ITokenMinter(token).mint(msg.sender, _amount);\n        }\n\n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    //deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns (bool) {\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid, balance, _stake);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n        address gauge = pool.gauge;\n\n        //remove lp balance\n        address token = pool.token;\n        ITokenMinter(token).burn(_from, _amount);\n\n        //pull from gauge if not shutdown\n        // if shutdown tokens will be in this contract\n        if (!pool.shutdown) {\n            IStaker(staker).withdraw(lptoken, gauge, _amount);\n        }\n\n        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim\n        //do not call if shutdown since stashes wont have access\n        address stash = pool.stash;\n        if (stash != address(0) && !isShutdown && !pool.shutdown) {\n            IStash(stash).stashRewards();\n        }\n\n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n\n        emit Withdrawn(_to, _pid, _amount);\n    }\n\n    //withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\n        return true;\n    }\n\n    //withdraw all lp tokens\n    function withdrawAll(uint256 _pid) public returns (bool) {\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    //allow reward contracts to send here and withdraw to user\n    function withdrawTo(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract, \"!auth\");\n\n        _withdraw(_pid, _amount, msg.sender, _to);\n        return true;\n    }\n\n    /**\n     * @notice set valid vote hash on VoterProxy\n     */\n    function setVote(bytes32 _hash, bool valid) external returns (bool) {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).setVote(_hash, valid);\n        return true;\n    }\n\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight)\n        external\n        returns (bool)\n    {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).voteGaugeWeight(_gauge, _weight);\n\n        return true;\n    }\n\n    function claimRewards(uint256 _pid, address _gauge) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n\n        IStaker(staker).claimRewards(_gauge);\n        return true;\n    }\n\n    function setGaugeRedirect(uint256 _pid) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n        address gauge = poolInfo[_pid].gauge;\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(keccak256(\"set_rewards_receiver(address)\")),\n            stash\n        );\n        IStaker(staker).execute(gauge, uint256(0), data);\n        return true;\n    }\n\n    //claim veAsset and extra rewards and disperse to reward contracts\n    function _earmarkRewards(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        address gauge = pool.gauge;\n\n        //claim veAsset\n        IStaker(staker).claimVeAsset(gauge);\n\n        //check if there are extra rewards\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            //claim extra rewards\n            IStash(stash).claimRewards();\n            //process extra rewards\n            IStash(stash).processStash();\n        }\n\n        //veAsset balance\n        uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));\n\n        if (veAssetBal > 0) {\n            uint256 _lockIncentive = veAssetBal.mul(lockIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerIncentive = veAssetBal.mul(stakerIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerLockIncentive = veAssetBal.mul(stakerLockIncentive).div(\n                FEE_DENOMINATOR\n            );\n            uint256 _callIncentive = veAssetBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);\n\n            //send treasury\n            if (treasury != address(0) && treasury != address(this) && platformFee > 0) {\n                //only subtract after address condition check\n                uint256 _platform = veAssetBal.mul(platformFee).div(FEE_DENOMINATOR);\n                veAssetBal = veAssetBal.sub(_platform);\n                IERC20(veAsset).safeTransfer(treasury, _platform);\n            }\n\n            //remove incentives from balance\n            veAssetBal = veAssetBal\n                .sub(_lockIncentive)\n                .sub(_callIncentive)\n                .sub(_stakerIncentive)\n                .sub(_stakerLockIncentive);\n\n            //send incentives for calling\n            if (_callIncentive > 0) {\n                IERC20(veAsset).safeTransfer(msg.sender, _callIncentive);\n            }\n\n            //send veAsset to lp provider reward contract\n            address rewardContract = pool.veAssetRewards;\n            IERC20(veAsset).safeTransfer(rewardContract, veAssetBal);\n            IRewards(rewardContract).queueNewRewards(veAssetBal);\n\n            //send lockers' share of veAsset to reward contract\n            if (_lockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(lockRewards, _lockIncentive);\n                IRewards(lockRewards).queueNewRewards(_lockIncentive);\n            }\n            //send stakers's share of veAsset to VE3D reward contract\n            if (_stakerIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerRewards, _stakerIncentive);\n                IRewards(stakerRewards).queueNewRewards(veAsset, _stakerIncentive);\n            }\n\n            //send stakers's lock share of veAsset to VE3D locker reward contract\n            if (_stakerLockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerLockRewards, _stakerLockIncentive);\n                IRewards(stakerLockRewards).queueNewRewards(veAsset, _stakerLockIncentive);\n            }\n        }\n    }\n\n    function earmarkRewards(uint256 _pid) external returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        _earmarkRewards(_pid);\n        return true;\n    }\n\n    //claim fees from fee distro contract, put in lockers' reward contract\n    function earmarkFees() external returns (bool) {\n        //claim fee rewards\n        IStaker(staker).claimFees(feeDistro, feeToken);\n        //send fee rewards to reward contract\n        uint256 _balance = IERC20(feeToken).balanceOf(address(this));\n\n        uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);\n        uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(\n            FEE_DENOMINATOR\n        );\n        if (_lockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);\n            IRewards(lockFees).queueNewRewards(_lockFeesIncentive);\n        }\n        if (_stakerLockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);\n            IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);\n        }\n        return true;\n    }\n\n    //callback from reward contract when veAsset is received.\n    function rewardClaimed(\n        uint256 _pid,\n        address _address,\n        uint256 _amount\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");\n        ITokenMinter veTokenMinter = ITokenMinter(minter);\n        //calc the amount of veAssetEarned\n        uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(\n            veTokenMinter.totalWeight()\n        );\n        //mint reward tokens\n        ITokenMinter(minter).mint(_address, _veAssetEarned);\n\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "Booster.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Booster contract",
                "Type": "Fee Calculation",
                "Description": "The setFeeInfo() function is responsible for setting the allocation of gauge fees between lockers and $VE3D stakers. However, there is no validation check to ensure that _lockFeesIncentive and _stakerLockFeesIncentive add up to 10000. This can cause the remaining gauge fee to be stuck in the Booster contract perpetually, resulting in users losing their gauge fee.",
                "Repair": "Implement a validation check to ensure that lockFeesIncentive and stakerLockFeesIncentive add up to 100% to eliminate any risk of misconfiguration."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IFeeDistro.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/ITokenFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\nimport \"./Interfaces/IStash.sol\";\nimport \"./Interfaces/IStashFactory.sol\";\n\ncontract Booster {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // ve3Token reward pool\n    uint256 public lockIncentive = 1000; //incentive to veAsset stakers\n    // veToken reward pool\n    uint256 public stakerIncentive = 450; //incentive to native token stakers\n    // veToken locking reward pool xVE3D\n    uint256 public stakerLockIncentive;\n    // caller reward\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    // platoform fee\n    uint256 public platformFee; //possible fee to build treasury\n    uint256 public constant MaxFees = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    uint256 public lockFeesIncentive = 10000; //ve3Token veVeAsset fees percentage\n    uint256 public stakerLockFeesIncentive; //xVE3D veVeAsset fees percentage\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public immutable veAsset;\n    address public immutable feeDistro;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //vetoken rewards\n    address public stakerLockRewards; // veToken lock rewards xVE3D\n    address public lockRewards; //ve3Token rewards(veAsset)\n    address public lockFees; //ve3Token veVeAsset fees\n    address public feeToken;\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address veAssetRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n    event OwnerUpdated(address indexed owner);\n    event FeeManagerUpdated(address indexed feeM);\n    event PoolManagerUpdated(address indexed poolM);\n    event FactoriesUpdated(address indexed rfactory, address indexed tfactory);\n    event ArbitratorUpdated(address indexed arb);\n    event VoteDelegateUpdated(address indexed voteDelegate);\n    event RewardContractsUpdated(\n        address indexed rewards,\n        address indexed stakerRewards,\n        address indexed stakerLockRewards\n    );\n    event FeesUpdated(\n        uint256 lockFees,\n        uint256 stakerFees,\n        uint256 stakerLockFee,\n        uint256 callerFees,\n        uint256 platform\n    );\n    event TreasuryUpdated(address indexed treasury);\n    event PoolAdded(\n        address indexed lptoken,\n        address indexed gauge,\n        address indexed token,\n        address rewardPool\n    );\n    event PoolShuttedDown(uint256 indexed pid);\n    event SystemShuttedDown();\n    event Voted(uint256 indexed voteId, address indexed votingAddress, bool support);\n\n    constructor(\n        address _staker,\n        address _minter,\n        address _veAsset,\n        address _feeDistro\n    ) {\n        isShutdown = false;\n        staker = _staker;\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        poolManager = msg.sender;\n        minter = _minter;\n        veAsset = _veAsset;\n        feeDistro = _feeDistro;\n    }\n\n    /// SETTER SECTION ///\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n        emit OwnerUpdated(_owner);\n    }\n\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n        emit FeeManagerUpdated(_feeM);\n    }\n\n    function setPoolManager(address _poolM) external {\n        require(msg.sender == poolManager, \"!auth\");\n        poolManager = _poolM;\n        emit PoolManagerUpdated(_poolM);\n    }\n\n    function setFactories(\n        address _rfactory,\n        address _sfactory,\n        address _tfactory\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward factory only allow this to be called once even if owner\n        //removes ability to inject malicious staking contracts\n        //token factory can also be immutable\n        if (rewardFactory == address(0)) {\n            rewardFactory = _rfactory;\n            tokenFactory = _tfactory;\n            emit FactoriesUpdated(_rfactory, _tfactory);\n        }\n\n        //stash factory should be considered more safe to change\n        //updating may be required to handle new types of gauges\n        stashFactory = _sfactory;\n    }\n\n    function setArbitrator(address _arb) external {\n        require(msg.sender == owner, \"!auth\");\n        rewardArbitrator = _arb;\n        emit ArbitratorUpdated(_arb);\n    }\n\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender == voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n        emit VoteDelegateUpdated(_voteDelegate);\n    }\n\n    function setRewardContracts(\n        address _rewards,\n        address _stakerRewards,\n        address _stakerLockRewards\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward contracts are immutable or else the owner\n        //has a means to redeploy and mint cvx via rewardClaimed()\n        if (lockRewards == address(0)) {\n            lockRewards = _rewards;\n            stakerRewards = _stakerRewards;\n            stakerLockRewards = _stakerLockRewards;\n        }\n\n        emit RewardContractsUpdated(_rewards, _stakerRewards, _stakerLockRewards);\n    }\n\n    // Set reward token and claim contract, get from Curve's registry\n    function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        lockFeesIncentive = _lockFeesIncentive;\n        stakerLockFeesIncentive = _stakerLockFeesIncentive;\n\n        address _feeToken = IFeeDistro(feeDistro).token();\n        if (feeToken != _feeToken) {\n            //create a new reward contract for the new token\n            lockFees = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken, lockRewards);\n\n            if (_feeToken != veAsset) {\n                IRewards(stakerLockRewards).addReward(\n                    _feeToken,\n                    address(0),\n                    address(0),\n                    address(0),\n                    address(this),\n                    false\n                );\n            }\n\n            feeToken = _feeToken;\n        }\n    }\n\n    function setFees(\n        uint256 _lockFees,\n        uint256 _stakerFees,\n        uint256 _stakerLockIncentiveFee,\n        uint256 _callerFees,\n        uint256 _platform\n    ) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform).add(\n            _stakerLockIncentiveFee\n        );\n        require(total <= MaxFees, \">MaxFees\");\n\n        //values must be within certain ranges\n\n        lockIncentive = _lockFees;\n        stakerIncentive = _stakerFees;\n        stakerLockIncentive = _stakerLockIncentiveFee;\n        earmarkIncentive = _callerFees;\n        platformFee = _platform;\n        emit FeesUpdated(_lockFees, _stakerFees, _stakerLockIncentiveFee, _callerFees, _platform);\n    }\n\n    function setTreasury(address _treasury) external {\n        require(msg.sender == feeManager, \"!auth\");\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /// END SETTER SECTION ///\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //create a new pool\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool) {\n        require(msg.sender == poolManager && !isShutdown, \"!add\");\n        require(_gauge != address(0) && _lptoken != address(0), \"!param\");\n\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);\n        //create a reward contract for veAsset rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateVeAssetRewards(pid, token);\n\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(\n            pid,\n            veAsset,\n            _gauge,\n            staker,\n            _stashVersion\n        );\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: token,\n                gauge: _gauge,\n                veAssetRewards: newRewardPool,\n                stash: stash,\n                shutdown: false\n            })\n        );\n        gaugeMap[_gauge] = true;\n\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards\n        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge\n        if (stash != address(0)) {\n            poolInfo[pid].stash = stash;\n            IStaker(staker).setStashAccess(stash, true);\n            IRewardFactory(rewardFactory).setAccess(stash, true);\n        }\n        emit PoolAdded(_lptoken, _gauge, token, newRewardPool);\n\n        return true;\n    }\n\n    //shutdown pool\n    function shutdownPool(uint256 _pid) external returns (bool) {\n        require(msg.sender == poolManager, \"!auth\");\n        PoolInfo storage pool = poolInfo[_pid];\n\n        //withdraw from gauge\n        try IStaker(staker).withdrawAll(pool.lptoken, pool.gauge) {} catch {}\n\n        pool.shutdown = true;\n        gaugeMap[pool.gauge] = false;\n\n        emit PoolShuttedDown(_pid);\n        return true;\n    }\n\n    //shutdown this contract.\n    //  unstake and pull all lp tokens to this address\n    //  only allow withdrawals\n    function shutdownSystem() external {\n        require(msg.sender == owner, \"!auth\");\n        isShutdown = true;\n\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            PoolInfo storage pool = poolInfo[i];\n            if (pool.shutdown) continue;\n\n            address token = pool.lptoken;\n            address gauge = pool.gauge;\n\n            //withdraw from gauge\n            try IStaker(staker).withdrawAll(token, gauge) {\n                pool.shutdown = true;\n            } catch {}\n        }\n        emit SystemShuttedDown();\n    }\n\n    //deposit lp tokens and stake\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) public returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);\n\n        //stake\n        address gauge = pool.gauge;\n        require(gauge != address(0), \"!gauge setting\");\n        IStaker(staker).deposit(lptoken, gauge);\n\n        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            IStash(stash).stashRewards();\n        }\n\n        address token = pool.token;\n        if (_stake) {\n            //mint here and send to rewards on user behalf\n            ITokenMinter(token).mint(address(this), _amount);\n            address rewardContract = pool.veAssetRewards;\n            IERC20(token).safeApprove(rewardContract, _amount);\n            IRewards(rewardContract).stakeFor(msg.sender, _amount);\n        } else {\n            //add user balance directly\n            ITokenMinter(token).mint(msg.sender, _amount);\n        }\n\n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    //deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns (bool) {\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid, balance, _stake);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n        address gauge = pool.gauge;\n\n        //remove lp balance\n        address token = pool.token;\n        ITokenMinter(token).burn(_from, _amount);\n\n        //pull from gauge if not shutdown\n        // if shutdown tokens will be in this contract\n        if (!pool.shutdown) {\n            IStaker(staker).withdraw(lptoken, gauge, _amount);\n        }\n\n        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim\n        //do not call if shutdown since stashes wont have access\n        address stash = pool.stash;\n        if (stash != address(0) && !isShutdown && !pool.shutdown) {\n            IStash(stash).stashRewards();\n        }\n\n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n\n        emit Withdrawn(_to, _pid, _amount);\n    }\n\n    //withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\n        return true;\n    }\n\n    //withdraw all lp tokens\n    function withdrawAll(uint256 _pid) public returns (bool) {\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    //allow reward contracts to send here and withdraw to user\n    function withdrawTo(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract, \"!auth\");\n\n        _withdraw(_pid, _amount, msg.sender, _to);\n        return true;\n    }\n\n    /**\n     * @notice set valid vote hash on VoterProxy\n     */\n    function setVote(bytes32 _hash, bool valid) external returns (bool) {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).setVote(_hash, valid);\n        return true;\n    }\n\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight)\n        external\n        returns (bool)\n    {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).voteGaugeWeight(_gauge, _weight);\n\n        return true;\n    }\n\n    function claimRewards(uint256 _pid, address _gauge) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n\n        IStaker(staker).claimRewards(_gauge);\n        return true;\n    }\n\n    function setGaugeRedirect(uint256 _pid) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n        address gauge = poolInfo[_pid].gauge;\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(keccak256(\"set_rewards_receiver(address)\")),\n            stash\n        );\n        IStaker(staker).execute(gauge, uint256(0), data);\n        return true;\n    }\n\n    //claim veAsset and extra rewards and disperse to reward contracts\n    function _earmarkRewards(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        address gauge = pool.gauge;\n\n        //claim veAsset\n        IStaker(staker).claimVeAsset(gauge);\n\n        //check if there are extra rewards\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            //claim extra rewards\n            IStash(stash).claimRewards();\n            //process extra rewards\n            IStash(stash).processStash();\n        }\n\n        //veAsset balance\n        uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));\n\n        if (veAssetBal > 0) {\n            uint256 _lockIncentive = veAssetBal.mul(lockIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerIncentive = veAssetBal.mul(stakerIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerLockIncentive = veAssetBal.mul(stakerLockIncentive).div(\n                FEE_DENOMINATOR\n            );\n            uint256 _callIncentive = veAssetBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);\n\n            //send treasury\n            if (treasury != address(0) && treasury != address(this) && platformFee > 0) {\n                //only subtract after address condition check\n                uint256 _platform = veAssetBal.mul(platformFee).div(FEE_DENOMINATOR);\n                veAssetBal = veAssetBal.sub(_platform);\n                IERC20(veAsset).safeTransfer(treasury, _platform);\n            }\n\n            //remove incentives from balance\n            veAssetBal = veAssetBal\n                .sub(_lockIncentive)\n                .sub(_callIncentive)\n                .sub(_stakerIncentive)\n                .sub(_stakerLockIncentive);\n\n            //send incentives for calling\n            if (_callIncentive > 0) {\n                IERC20(veAsset).safeTransfer(msg.sender, _callIncentive);\n            }\n\n            //send veAsset to lp provider reward contract\n            address rewardContract = pool.veAssetRewards;\n            IERC20(veAsset).safeTransfer(rewardContract, veAssetBal);\n            IRewards(rewardContract).queueNewRewards(veAssetBal);\n\n            //send lockers' share of veAsset to reward contract\n            if (_lockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(lockRewards, _lockIncentive);\n                IRewards(lockRewards).queueNewRewards(_lockIncentive);\n            }\n            //send stakers's share of veAsset to VE3D reward contract\n            if (_stakerIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerRewards, _stakerIncentive);\n                IRewards(stakerRewards).queueNewRewards(veAsset, _stakerIncentive);\n            }\n\n            //send stakers's lock share of veAsset to VE3D locker reward contract\n            if (_stakerLockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerLockRewards, _stakerLockIncentive);\n                IRewards(stakerLockRewards).queueNewRewards(veAsset, _stakerLockIncentive);\n            }\n        }\n    }\n\n    function earmarkRewards(uint256 _pid) external returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        _earmarkRewards(_pid);\n        return true;\n    }\n\n    //claim fees from fee distro contract, put in lockers' reward contract\n    function earmarkFees() external returns (bool) {\n        //claim fee rewards\n        IStaker(staker).claimFees(feeDistro, feeToken);\n        //send fee rewards to reward contract\n        uint256 _balance = IERC20(feeToken).balanceOf(address(this));\n\n        uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);\n        uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(\n            FEE_DENOMINATOR\n        );\n        if (_lockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);\n            IRewards(lockFees).queueNewRewards(_lockFeesIncentive);\n        }\n        if (_stakerLockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);\n            IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);\n        }\n        return true;\n    }\n\n    //callback from reward contract when veAsset is received.\n    function rewardClaimed(\n        uint256 _pid,\n        address _address,\n        uint256 _amount\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");\n        ITokenMinter veTokenMinter = ITokenMinter(minter);\n        //calc the amount of veAssetEarned\n        uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(\n            veTokenMinter.totalWeight()\n        );\n        //mint reward tokens\n        ITokenMinter(minter).mint(_address, _veAssetEarned);\n\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: vetokenRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VE3DRewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable rewardManager;\n\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    // reward token => reward token info\n    mapping(address => RewardTokenInfo) public rewardTokenInfo;\n    // list of reward tokens\n    EnumerableSet.AddressSet internal rewardTokens;\n    EnumerableSet.AddressSet internal operators;\n\n    address[] public extraRewards;\n\n    struct RewardTokenInfo {\n        address veAssetDeposits;\n        address ve3TokenRewards;\n        address ve3Token;\n        uint256 queuedRewards;\n        uint256 rewardRate;\n        uint256 historicalRewards;\n        uint256 rewardPerTokenStored;\n        uint256 currentRewards;\n        uint256 periodFinish;\n        uint256 lastUpdateTime;\n        mapping(address => uint256) userRewardPerTokenPaid;\n        mapping(address => uint256) rewards;\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(address stakingToken_, address rewardManager_) {\n        stakingToken = IERC20(stakingToken_);\n\n        rewardManager = rewardManager_;\n    }\n\n    function addReward(\n        address _rewardToken,\n        address _veAssetDeposits,\n        address _ve3TokenRewards,\n        address _ve3Token\n    ) external onlyOwner {\n        rewardTokenInfo[_rewardToken].veAssetDeposits = _veAssetDeposits;\n        rewardTokenInfo[_rewardToken].ve3TokenRewards = _ve3TokenRewards;\n        rewardTokenInfo[_rewardToken].ve3Token = _ve3Token;\n        rewardTokens.add(_rewardToken);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored = rewardPerToken(_rewardToken);\n            rewardTokenInfo[_rewardToken].lastUpdateTime = lastTimeRewardApplicable(_rewardToken);\n            if (account != address(0)) {\n                rewardTokenInfo[_rewardToken].rewards[account] = earnedReward(\n                    _rewardToken,\n                    account\n                );\n                rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account] = rewardTokenInfo[\n                    _rewardToken\n                ].rewardPerTokenStored;\n            }\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n        return Math.min(block.timestamp, rewardTokenInfo[_rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardToken) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return rewardTokenInfo[_rewardToken].rewardPerTokenStored;\n        }\n        return\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored.add(\n                lastTimeRewardApplicable(_rewardToken)\n                    .sub(rewardTokenInfo[_rewardToken].lastUpdateTime)\n                    .mul(rewardTokenInfo[_rewardToken].rewardRate)\n                    .mul(1e18)\n                    .div(supply)\n            );\n    }\n\n    function earnedReward(address _rewardToken, address account) internal view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(\n                    rewardPerToken(_rewardToken).sub(\n                        rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account]\n                    )\n                )\n                .div(1e18)\n                .add(rewardTokenInfo[_rewardToken].rewards[account]);\n    }\n\n    function earned(address _rewardToken, address account) external view returns (uint256) {\n        uint256 depositFeeRate = IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits)\n            .lockIncentive();\n\n        uint256 r = earnedReward(_rewardToken, account);\n        uint256 fees = r.mul(depositFeeRate).div(FEE_DENOMINATOR);\n\n        //fees dont apply until whitelist+veVeAsset lock begins so will report\n        //slightly less value than what is actually received.\n        return r.sub(fees);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to _for's balance sheet\n        _balances[_for] = _balances[_for].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, bool claim) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(_amount);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n\n        if (claim) {\n            getReward(msg.sender, true, false);\n        }\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool _stake\n    ) public updateReward(_account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n\n            uint256 reward = earnedReward(_rewardToken, _account);\n            if (reward > 0) {\n                rewardTokenInfo[_rewardToken].rewards[_account] = 0;\n                IERC20(_rewardToken).safeApprove(rewardTokenInfo[_rewardToken].veAssetDeposits, 0);\n                IERC20(_rewardToken).safeApprove(\n                    rewardTokenInfo[_rewardToken].veAssetDeposits,\n                    reward\n                );\n                IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits).deposit(\n                    reward,\n                    false\n                );\n\n                uint256 ve3TokenBalance = IERC20(rewardTokenInfo[_rewardToken].ve3Token).balanceOf(\n                    address(this)\n                );\n                if (_stake) {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        0\n                    );\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        ve3TokenBalance\n                    );\n                    IRewards(rewardTokenInfo[_rewardToken].ve3TokenRewards).stakeFor(\n                        _account,\n                        ve3TokenBalance\n                    );\n                } else {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeTransfer(\n                        _account,\n                        ve3TokenBalance\n                    );\n                }\n                emit RewardPaid(_account, ve3TokenBalance);\n            }\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            uint256 length = extraRewards.length;\n            for (uint256 i = 0; i < length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n    }\n\n    function getReward(bool _stake) external {\n        getReward(msg.sender, true, _stake);\n    }\n\n    function donate(address _rewardToken, uint256 _amount) external {\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        rewardTokenInfo[_rewardToken].queuedRewards += _amount;\n    }\n\n    function queueNewRewards(address _rewardToken, uint256 _rewards) external {\n        require(operators.contains(_msgSender()), \"!authorized\");\n\n        _rewards = _rewards.add(rewardTokenInfo[_rewardToken].queuedRewards);\n\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(\n            rewardTokenInfo[_rewardToken].periodFinish.sub(duration)\n        );\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardTokenInfo[_rewardToken].rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n        } else {\n            rewardTokenInfo[_rewardToken].queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardToken, uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        rewardTokenInfo[_rewardToken].historicalRewards += reward;\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = rewardTokenInfo[_rewardToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardTokenInfo[_rewardToken].rewardRate);\n            reward = reward.add(leftover);\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        }\n        rewardTokenInfo[_rewardToken].currentRewards = reward;\n        rewardTokenInfo[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardTokenInfo[_rewardToken].periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}\n\n\n",
        "CodeNames": [
            "Booster.sol",
            "VE3DRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Booster and VE3DRewardPool contracts",
                "Type": "Balance Discrepancy",
                "Description": "As arbitrary ERC20 tokens can be passed, the amount here should be calculated every time to take into consideration a possible fee-on-transfer or deflation. This can cause a discrepancy between the amount passed as a parameter and the actual amount received, resulting in tokens being stuck in the contract.",
                "Repair": "Use the balance before and after the transfer to calculate the received amount instead of assuming that it would be equal to the amount passed as a parameter."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VeAssetDepositor {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public lockIncentive = 10; //incentive to users who spend gas to lock veAsset\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable veAsset;\n    address public immutable escrow;\n    address public feeManager;\n    address public immutable staker;\n    address public immutable minter;\n    uint256 public incentiveVeAsset = 0;\n    uint256 public unlockTime;\n    uint256 private maxTime;\n\n    event FeeManagerUpdated(address indexed feeManager);\n    event FeesUpdated(uint256 lockIncentive);\n    event InitialLockCreated(uint256 veAssetBalanceStaker, uint256 unlockInWeeks);\n    event LockUpdated(uint256 veAssetBalanceStaker, uint256 unlockInWeeks);\n    event Deposited(address indexed user, uint256 amount, bool lock);\n\n    constructor(\n        address _staker,\n        address _minter,\n        address _veAsset,\n        address _escrow,\n        uint256 _maxTime\n    ) {\n        staker = _staker;\n        minter = _minter;\n        veAsset = _veAsset;\n        escrow = _escrow;\n        feeManager = msg.sender;\n        maxTime = _maxTime;\n    }\n\n    function setFeeManager(address _feeManager) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeManager;\n        emit FeeManagerUpdated(_feeManager);\n    }\n\n    function setFees(uint256 _lockIncentive) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        if (_lockIncentive >= 0 && _lockIncentive <= 30) {\n            lockIncentive = _lockIncentive;\n            emit FeesUpdated(_lockIncentive);\n        }\n    }\n\n    function initialLock() external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        uint256 veVeAsset = IERC20(escrow).balanceOf(staker);\n        if (veVeAsset == 0) {\n            uint256 unlockAt = block.timestamp + maxTime;\n            uint256 unlockInWeeks = (unlockAt / WEEK) * WEEK;\n\n            //release old lock if exists\n            IStaker(staker).release();\n            //create new lock\n            uint256 veAssetBalanceStaker = IERC20(veAsset).balanceOf(staker);\n            IStaker(staker).createLock(veAssetBalanceStaker, unlockAt);\n            unlockTime = unlockInWeeks;\n            emit InitialLockCreated(veAssetBalanceStaker, unlockInWeeks);\n        }\n    }\n\n    //lock veAsset\n    function _lockVeAsset() internal {\n        uint256 veAssetBalance = IERC20(veAsset).balanceOf(address(this));\n        if (veAssetBalance > 0) {\n            IERC20(veAsset).safeTransfer(staker, veAssetBalance);\n        }\n\n        //increase ammount\n        uint256 veAssetBalanceStaker = IERC20(veAsset).balanceOf(staker);\n        if (veAssetBalanceStaker == 0) {\n            return;\n        }\n\n        //increase amount\n        IStaker(staker).increaseAmount(veAssetBalanceStaker);\n\n        uint256 unlockAt = block.timestamp + maxTime;\n        uint256 unlockInWeeks = (unlockAt / WEEK) * WEEK;\n\n        //increase time too if over 2 week buffer\n        if (unlockInWeeks.sub(unlockTime) > 2) {\n            IStaker(staker).increaseTime(unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n        emit LockUpdated(veAssetBalanceStaker, unlockTime);\n    }\n\n    function lockVeAsset() external {\n        _lockVeAsset();\n\n        //mint incentives\n        if (incentiveVeAsset > 0) {\n            ITokenMinter(minter).mint(msg.sender, incentiveVeAsset);\n            incentiveVeAsset = 0;\n        }\n    }\n\n    //deposit veAsset for ve3Token\n    //can locking immediately or defer locking to someone else by paying a fee.\n    //while users can choose to lock or defer, this is mostly in place so that\n    //the vetoken reward contract isnt costly to claim rewards\n    function deposit(\n        uint256 _amount,\n        bool _lock,\n        address _stakeAddress\n    ) public {\n        require(_amount > 0, \"!>0\");\n\n        if (_lock) {\n            //lock immediately, transfer directly to staker to skip an erc20 transfer\n            IERC20(veAsset).safeTransferFrom(msg.sender, staker, _amount);\n            _lockVeAsset();\n            if (incentiveVeAsset > 0) {\n                //add the incentive tokens here so they can be staked together\n                _amount = _amount.add(incentiveVeAsset);\n                incentiveVeAsset = 0;\n            }\n        } else {\n            //move tokens here\n            IERC20(veAsset).safeTransferFrom(msg.sender, address(this), _amount);\n            //defer lock cost to another user\n            uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);\n            _amount = _amount.sub(callIncentive);\n\n            //add to a pool for lock caller\n            incentiveVeAsset = incentiveVeAsset.add(callIncentive);\n        }\n\n        bool depositOnly = _stakeAddress == address(0);\n        if (depositOnly) {\n            //mint for msg.sender\n            ITokenMinter(minter).mint(msg.sender, _amount);\n        } else {\n            //mint here\n            ITokenMinter(minter).mint(address(this), _amount);\n            //stake for msg.sender\n            IERC20(minter).safeApprove(_stakeAddress, _amount);\n            IRewards(_stakeAddress).stakeFor(msg.sender, _amount);\n        }\n\n        emit Deposited(msg.sender, _amount, _lock);\n    }\n\n    function deposit(uint256 _amount, bool _lock) external {\n        deposit(_amount, _lock, address(0));\n    }\n\n    function depositAll(bool _lock, address _stakeAddress) external {\n        uint256 veAssetBal = IERC20(veAsset).balanceOf(msg.sender);\n        deposit(veAssetBal, _lock, _stakeAddress);\n    }\n}\n\n\n",
        "CodeNames": [
            "VeAssetDepositor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Constructor of VeAssetDepositor contract",
                "Type": "Incorrectly set maxTime",
                "Description": "If the owner inputs the _maxTime that is higher than the capacity of each vaults of veTokens, it will cause IVoteEscrow(escrow).increase_unlock_time(_value) to get rejected.",
                "Repair": "Set the value of _maxTime in advance for each veAsset and not relying on manual inputting during the constructoring as the risk of misconfiging it is high. Otherwise, add an emergency measure that can help change _maxTime but this function needs to be protected with the highest security (eg. with timelock and multisig)."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IPools.sol\";\nimport \"./Interfaces/IRegistry.sol\";\n\ncontract PoolManager is Ownable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    //add a new veAsset pool to the system.\n    //gauge must be on veAsset's gaugeProxy, thus anyone can call\n    // use by pickle\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        address _pools,\n        uint256 _stashVersion\n    ) external onlyOwner returns (bool) {\n        require(_lptoken != address(0), \"lptoken is 0\");\n        require(_gauge != address(0), \"gauge is 0\");\n        require(_pools != address(0), \"pools is 0\");\n\n        bool gaugeExists = IPools(_pools).gaugeMap(_gauge);\n        require(!gaugeExists, \"already registered\");\n\n        IPools(_pools).addPool(_lptoken, _gauge, _stashVersion);\n\n        return true;\n    }\n\n    function shutdownPool(address _pools, uint256 _pid) external onlyOwner returns (bool) {\n        IPools(_pools).shutdownPool(_pid);\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "PoolManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "addPool function in PoolManager contract",
                "Type": "Duplicate LP token",
                "Description": "The first pool calling depositAll will take away all lpToken and deposit them under their own pid. This leaves no balance for the 2nd pool.",
                "Repair": "Add a global variable keeping track of all lpToken added for pool. In case of duplicate lpToken addPool function should fail."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IVoteEscrow.sol\";\nimport \"./Interfaces/IDeposit.sol\";\nimport \"./Interfaces/IFeeDistro.sol\";\nimport \"./Interfaces/IVoting.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\n\ncontract VoterProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable veAsset;\n    address public immutable escrow;\n    address public immutable gaugeProxy;\n\n    address public immutable minter;\n\n    address public owner;\n    address public operator;\n    address public depositor;\n    string public name;\n    IVoteEscrow.EscrowModle public escrowModle;\n\n    mapping(address => bool) private protectedTokens;\n    mapping(address => bool) private stashPool;\n    mapping(bytes32 => bool) private votes;\n\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    event VoteSet(bytes32 hash, bool valid);\n\n    constructor(\n        string memory _name,\n        address _veAsset,\n        address _escrow,\n        address _gaugeProxy,\n        address _minter,\n        IVoteEscrow.EscrowModle _escrowModle\n    ) {\n        name = _name;\n        veAsset = _veAsset;\n        escrow = _escrow;\n        gaugeProxy = _gaugeProxy;\n        owner = msg.sender;\n        minter = _minter;\n        escrowModle = _escrowModle;\n    }\n\n    function getName() external view returns (string memory) {\n        return name;\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    function setOperator(address _operator) external {\n        require(msg.sender == owner, \"!auth\");\n        require(\n            operator == address(0) || IDeposit(operator).isShutdown() == true,\n            \"needs shutdown\"\n        );\n\n        operator = _operator;\n    }\n\n    function setDepositor(address _depositor) external {\n        require(msg.sender == owner, \"!auth\");\n\n        depositor = _depositor;\n    }\n\n    function setStashAccess(address _stash, bool _status) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        if (_stash != address(0)) {\n            stashPool[_stash] = _status;\n        }\n        return true;\n    }\n\n    function deposit(address _token, address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        if (protectedTokens[_token] == false) {\n            protectedTokens[_token] = true;\n        }\n        if (protectedTokens[_gauge] == false) {\n            protectedTokens[_gauge] = true;\n        }\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(_token).safeApprove(_gauge, 0);\n            IERC20(_token).safeApprove(_gauge, balance);\n            IGauge(_gauge).deposit(balance);\n        }\n        return true;\n    }\n\n    //stash only function for pulling extra incentive reward tokens out\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(stashPool[msg.sender] == true, \"!auth\");\n\n        //check protection\n        if (protectedTokens[address(_asset)] == true) {\n            return 0;\n        }\n\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(msg.sender, balance);\n        return balance;\n    }\n\n    // Withdraw partial funds\n    function withdraw(\n        address _token,\n        address _gauge,\n        uint256 _amount\n    ) public returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_gauge, _amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        return true;\n    }\n\n    function withdrawAll(address _token, address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));\n        withdraw(_token, _gauge, amount);\n        return true;\n    }\n\n    function _withdrawSome(address _gauge, uint256 _amount) internal returns (uint256) {\n        IGauge(_gauge).withdraw(_amount);\n        return _amount;\n    }\n\n    function createLock(uint256 _value, uint256 _unlockTime) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(veAsset).safeApprove(escrow, 0);\n        IERC20(veAsset).safeApprove(escrow, _value);\n        IVoteEscrow(escrow).create_lock(_value, _unlockTime);\n        return true;\n    }\n\n    function increaseAmount(uint256 _value) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(veAsset).safeApprove(escrow, 0);\n        IERC20(veAsset).safeApprove(escrow, _value);\n        IVoteEscrow(escrow).increase_amount(_value);\n        return true;\n    }\n\n    function increaseTime(uint256 _value) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IVoteEscrow(escrow).increase_unlock_time(_value);\n        return true;\n    }\n\n    function release() external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IVoteEscrow(escrow).withdraw();\n        return true;\n    }\n\n    /**\n     * @notice Save a vote hash so when snapshot.org asks this contract if\n     *          a vote signature is valid we are able to check for a valid hash\n     *          and return the appropriate response inline with EIP 1721\n     * @param _hash  Hash of vote signature that was sent to snapshot.org\n     * @param _valid Is the hash valid\n     */\n    function setVote(bytes32 _hash, bool _valid) external {\n        require(msg.sender == operator, \"!auth\");\n        votes[_hash] = _valid;\n        emit VoteSet(_hash, _valid);\n    }\n\n    /**\n     * @notice  Verifies that the hash is valid\n     * @dev     Snapshot Hub will call this function when a vote is submitted using\n     *          snapshot.js on behalf of this contract. Snapshot Hub will call this\n     *          function with the hash and the signature of the vote that was cast.\n     * @param _hash Hash of the message that was sent to Snapshot Hub to cast a vote\n     * @return EIP1271 magic value if the signature is value\n     */\n    function isValidSignature(bytes32 _hash, bytes memory) public view returns (bytes4) {\n        if (votes[_hash]) {\n            return EIP1271_MAGIC_VALUE;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    function voteGaugeWeight(address[] calldata _tokenVote, uint256[] calldata _weight)\n        external\n        returns (bool)\n    {\n        require(msg.sender == operator, \"!auth\");\n\n        if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n            //vote\n            IVoting(gaugeProxy).vote(_tokenVote, _weight);\n        } else {\n            for (uint256 i = 0; i < _tokenVote.length; i++) {\n                IVoting(gaugeProxy).vote_for_gauge_weights(_tokenVote[i], _weight[i]);\n            }\n        }\n        return true;\n    }\n\n    function claimVeAsset(address _gauge) external returns (uint256) {\n        require(msg.sender == operator, \"!auth\");\n\n        uint256 _balance = 0;\n\n        if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n            try IGauge(_gauge).getReward() {} catch {\n                return _balance;\n            }\n        } else if (\n            escrowModle == IVoteEscrow.EscrowModle.CURVE ||\n            escrowModle == IVoteEscrow.EscrowModle.RIBBON\n        ) {\n            try ITokenMinter(minter).mint(_gauge) {} catch {\n                return _balance;\n            }\n        } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {\n            try ITokenMinter(minter).distribute(_gauge) {} catch {\n                return _balance;\n            }\n        } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {\n            try IGauge(_gauge).claim_rewards() {} catch {\n                return _balance;\n            }\n        }\n\n        _balance = IERC20(veAsset).balanceOf(address(this));\n        IERC20(veAsset).safeTransfer(operator, _balance);\n\n        return _balance;\n    }\n\n    function claimRewards(address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        IGauge(_gauge).claim_rewards();\n        return true;\n    }\n\n    function claimFees(address _distroContract, address _token) external returns (uint256) {\n        require(msg.sender == operator, \"!auth\");\n        IFeeDistro(_distroContract).claim();\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(operator, _balance);\n        return _balance;\n    }\n\n    function balanceOfPool(address _gauge) public view returns (uint256) {\n        return IGauge(_gauge).balanceOf(address(this));\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bool, bytes memory) {\n        require(msg.sender == operator, \"!auth\");\n\n        (bool success, bytes memory result) = _to.call{value: _value}(_data);\n        require(success, \"!success\");\n\n        return (success, result);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IFeeDistro.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/ITokenFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\nimport \"./Interfaces/IStash.sol\";\nimport \"./Interfaces/IStashFactory.sol\";\n\ncontract Booster {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // ve3Token reward pool\n    uint256 public lockIncentive = 1000; //incentive to veAsset stakers\n    // veToken reward pool\n    uint256 public stakerIncentive = 450; //incentive to native token stakers\n    // veToken locking reward pool xVE3D\n    uint256 public stakerLockIncentive;\n    // caller reward\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    // platoform fee\n    uint256 public platformFee; //possible fee to build treasury\n    uint256 public constant MaxFees = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    uint256 public lockFeesIncentive = 10000; //ve3Token veVeAsset fees percentage\n    uint256 public stakerLockFeesIncentive; //xVE3D veVeAsset fees percentage\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public immutable veAsset;\n    address public immutable feeDistro;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //vetoken rewards\n    address public stakerLockRewards; // veToken lock rewards xVE3D\n    address public lockRewards; //ve3Token rewards(veAsset)\n    address public lockFees; //ve3Token veVeAsset fees\n    address public feeToken;\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address veAssetRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n    event OwnerUpdated(address indexed owner);\n    event FeeManagerUpdated(address indexed feeM);\n    event PoolManagerUpdated(address indexed poolM);\n    event FactoriesUpdated(address indexed rfactory, address indexed tfactory);\n    event ArbitratorUpdated(address indexed arb);\n    event VoteDelegateUpdated(address indexed voteDelegate);\n    event RewardContractsUpdated(\n        address indexed rewards,\n        address indexed stakerRewards,\n        address indexed stakerLockRewards\n    );\n    event FeesUpdated(\n        uint256 lockFees,\n        uint256 stakerFees,\n        uint256 stakerLockFee,\n        uint256 callerFees,\n        uint256 platform\n    );\n    event TreasuryUpdated(address indexed treasury);\n    event PoolAdded(\n        address indexed lptoken,\n        address indexed gauge,\n        address indexed token,\n        address rewardPool\n    );\n    event PoolShuttedDown(uint256 indexed pid);\n    event SystemShuttedDown();\n    event Voted(uint256 indexed voteId, address indexed votingAddress, bool support);\n\n    constructor(\n        address _staker,\n        address _minter,\n        address _veAsset,\n        address _feeDistro\n    ) {\n        isShutdown = false;\n        staker = _staker;\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        poolManager = msg.sender;\n        minter = _minter;\n        veAsset = _veAsset;\n        feeDistro = _feeDistro;\n    }\n\n    /// SETTER SECTION ///\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n        emit OwnerUpdated(_owner);\n    }\n\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n        emit FeeManagerUpdated(_feeM);\n    }\n\n    function setPoolManager(address _poolM) external {\n        require(msg.sender == poolManager, \"!auth\");\n        poolManager = _poolM;\n        emit PoolManagerUpdated(_poolM);\n    }\n\n    function setFactories(\n        address _rfactory,\n        address _sfactory,\n        address _tfactory\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward factory only allow this to be called once even if owner\n        //removes ability to inject malicious staking contracts\n        //token factory can also be immutable\n        if (rewardFactory == address(0)) {\n            rewardFactory = _rfactory;\n            tokenFactory = _tfactory;\n            emit FactoriesUpdated(_rfactory, _tfactory);\n        }\n\n        //stash factory should be considered more safe to change\n        //updating may be required to handle new types of gauges\n        stashFactory = _sfactory;\n    }\n\n    function setArbitrator(address _arb) external {\n        require(msg.sender == owner, \"!auth\");\n        rewardArbitrator = _arb;\n        emit ArbitratorUpdated(_arb);\n    }\n\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender == voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n        emit VoteDelegateUpdated(_voteDelegate);\n    }\n\n    function setRewardContracts(\n        address _rewards,\n        address _stakerRewards,\n        address _stakerLockRewards\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward contracts are immutable or else the owner\n        //has a means to redeploy and mint cvx via rewardClaimed()\n        if (lockRewards == address(0)) {\n            lockRewards = _rewards;\n            stakerRewards = _stakerRewards;\n            stakerLockRewards = _stakerLockRewards;\n        }\n\n        emit RewardContractsUpdated(_rewards, _stakerRewards, _stakerLockRewards);\n    }\n\n    // Set reward token and claim contract, get from Curve's registry\n    function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        lockFeesIncentive = _lockFeesIncentive;\n        stakerLockFeesIncentive = _stakerLockFeesIncentive;\n\n        address _feeToken = IFeeDistro(feeDistro).token();\n        if (feeToken != _feeToken) {\n            //create a new reward contract for the new token\n            lockFees = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken, lockRewards);\n\n            if (_feeToken != veAsset) {\n                IRewards(stakerLockRewards).addReward(\n                    _feeToken,\n                    address(0),\n                    address(0),\n                    address(0),\n                    address(this),\n                    false\n                );\n            }\n\n            feeToken = _feeToken;\n        }\n    }\n\n    function setFees(\n        uint256 _lockFees,\n        uint256 _stakerFees,\n        uint256 _stakerLockIncentiveFee,\n        uint256 _callerFees,\n        uint256 _platform\n    ) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform).add(\n            _stakerLockIncentiveFee\n        );\n        require(total <= MaxFees, \">MaxFees\");\n\n        //values must be within certain ranges\n\n        lockIncentive = _lockFees;\n        stakerIncentive = _stakerFees;\n        stakerLockIncentive = _stakerLockIncentiveFee;\n        earmarkIncentive = _callerFees;\n        platformFee = _platform;\n        emit FeesUpdated(_lockFees, _stakerFees, _stakerLockIncentiveFee, _callerFees, _platform);\n    }\n\n    function setTreasury(address _treasury) external {\n        require(msg.sender == feeManager, \"!auth\");\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /// END SETTER SECTION ///\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //create a new pool\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool) {\n        require(msg.sender == poolManager && !isShutdown, \"!add\");\n        require(_gauge != address(0) && _lptoken != address(0), \"!param\");\n\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);\n        //create a reward contract for veAsset rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateVeAssetRewards(pid, token);\n\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(\n            pid,\n            veAsset,\n            _gauge,\n            staker,\n            _stashVersion\n        );\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: token,\n                gauge: _gauge,\n                veAssetRewards: newRewardPool,\n                stash: stash,\n                shutdown: false\n            })\n        );\n        gaugeMap[_gauge] = true;\n\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards\n        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge\n        if (stash != address(0)) {\n            poolInfo[pid].stash = stash;\n            IStaker(staker).setStashAccess(stash, true);\n            IRewardFactory(rewardFactory).setAccess(stash, true);\n        }\n        emit PoolAdded(_lptoken, _gauge, token, newRewardPool);\n\n        return true;\n    }\n\n    //shutdown pool\n    function shutdownPool(uint256 _pid) external returns (bool) {\n        require(msg.sender == poolManager, \"!auth\");\n        PoolInfo storage pool = poolInfo[_pid];\n\n        //withdraw from gauge\n        try IStaker(staker).withdrawAll(pool.lptoken, pool.gauge) {} catch {}\n\n        pool.shutdown = true;\n        gaugeMap[pool.gauge] = false;\n\n        emit PoolShuttedDown(_pid);\n        return true;\n    }\n\n    //shutdown this contract.\n    //  unstake and pull all lp tokens to this address\n    //  only allow withdrawals\n    function shutdownSystem() external {\n        require(msg.sender == owner, \"!auth\");\n        isShutdown = true;\n\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            PoolInfo storage pool = poolInfo[i];\n            if (pool.shutdown) continue;\n\n            address token = pool.lptoken;\n            address gauge = pool.gauge;\n\n            //withdraw from gauge\n            try IStaker(staker).withdrawAll(token, gauge) {\n                pool.shutdown = true;\n            } catch {}\n        }\n        emit SystemShuttedDown();\n    }\n\n    //deposit lp tokens and stake\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) public returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);\n\n        //stake\n        address gauge = pool.gauge;\n        require(gauge != address(0), \"!gauge setting\");\n        IStaker(staker).deposit(lptoken, gauge);\n\n        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            IStash(stash).stashRewards();\n        }\n\n        address token = pool.token;\n        if (_stake) {\n            //mint here and send to rewards on user behalf\n            ITokenMinter(token).mint(address(this), _amount);\n            address rewardContract = pool.veAssetRewards;\n            IERC20(token).safeApprove(rewardContract, _amount);\n            IRewards(rewardContract).stakeFor(msg.sender, _amount);\n        } else {\n            //add user balance directly\n            ITokenMinter(token).mint(msg.sender, _amount);\n        }\n\n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    //deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns (bool) {\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid, balance, _stake);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n        address gauge = pool.gauge;\n\n        //remove lp balance\n        address token = pool.token;\n        ITokenMinter(token).burn(_from, _amount);\n\n        //pull from gauge if not shutdown\n        // if shutdown tokens will be in this contract\n        if (!pool.shutdown) {\n            IStaker(staker).withdraw(lptoken, gauge, _amount);\n        }\n\n        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim\n        //do not call if shutdown since stashes wont have access\n        address stash = pool.stash;\n        if (stash != address(0) && !isShutdown && !pool.shutdown) {\n            IStash(stash).stashRewards();\n        }\n\n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n\n        emit Withdrawn(_to, _pid, _amount);\n    }\n\n    //withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\n        return true;\n    }\n\n    //withdraw all lp tokens\n    function withdrawAll(uint256 _pid) public returns (bool) {\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    //allow reward contracts to send here and withdraw to user\n    function withdrawTo(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract, \"!auth\");\n\n        _withdraw(_pid, _amount, msg.sender, _to);\n        return true;\n    }\n\n    /**\n     * @notice set valid vote hash on VoterProxy\n     */\n    function setVote(bytes32 _hash, bool valid) external returns (bool) {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).setVote(_hash, valid);\n        return true;\n    }\n\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight)\n        external\n        returns (bool)\n    {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).voteGaugeWeight(_gauge, _weight);\n\n        return true;\n    }\n\n    function claimRewards(uint256 _pid, address _gauge) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n\n        IStaker(staker).claimRewards(_gauge);\n        return true;\n    }\n\n    function setGaugeRedirect(uint256 _pid) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n        address gauge = poolInfo[_pid].gauge;\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(keccak256(\"set_rewards_receiver(address)\")),\n            stash\n        );\n        IStaker(staker).execute(gauge, uint256(0), data);\n        return true;\n    }\n\n    //claim veAsset and extra rewards and disperse to reward contracts\n    function _earmarkRewards(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        address gauge = pool.gauge;\n\n        //claim veAsset\n        IStaker(staker).claimVeAsset(gauge);\n\n        //check if there are extra rewards\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            //claim extra rewards\n            IStash(stash).claimRewards();\n            //process extra rewards\n            IStash(stash).processStash();\n        }\n\n        //veAsset balance\n        uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));\n\n        if (veAssetBal > 0) {\n            uint256 _lockIncentive = veAssetBal.mul(lockIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerIncentive = veAssetBal.mul(stakerIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerLockIncentive = veAssetBal.mul(stakerLockIncentive).div(\n                FEE_DENOMINATOR\n            );\n            uint256 _callIncentive = veAssetBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);\n\n            //send treasury\n            if (treasury != address(0) && treasury != address(this) && platformFee > 0) {\n                //only subtract after address condition check\n                uint256 _platform = veAssetBal.mul(platformFee).div(FEE_DENOMINATOR);\n                veAssetBal = veAssetBal.sub(_platform);\n                IERC20(veAsset).safeTransfer(treasury, _platform);\n            }\n\n            //remove incentives from balance\n            veAssetBal = veAssetBal\n                .sub(_lockIncentive)\n                .sub(_callIncentive)\n                .sub(_stakerIncentive)\n                .sub(_stakerLockIncentive);\n\n            //send incentives for calling\n            if (_callIncentive > 0) {\n                IERC20(veAsset).safeTransfer(msg.sender, _callIncentive);\n            }\n\n            //send veAsset to lp provider reward contract\n            address rewardContract = pool.veAssetRewards;\n            IERC20(veAsset).safeTransfer(rewardContract, veAssetBal);\n            IRewards(rewardContract).queueNewRewards(veAssetBal);\n\n            //send lockers' share of veAsset to reward contract\n            if (_lockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(lockRewards, _lockIncentive);\n                IRewards(lockRewards).queueNewRewards(_lockIncentive);\n            }\n            //send stakers's share of veAsset to VE3D reward contract\n            if (_stakerIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerRewards, _stakerIncentive);\n                IRewards(stakerRewards).queueNewRewards(veAsset, _stakerIncentive);\n            }\n\n            //send stakers's lock share of veAsset to VE3D locker reward contract\n            if (_stakerLockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerLockRewards, _stakerLockIncentive);\n                IRewards(stakerLockRewards).queueNewRewards(veAsset, _stakerLockIncentive);\n            }\n        }\n    }\n\n    function earmarkRewards(uint256 _pid) external returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        _earmarkRewards(_pid);\n        return true;\n    }\n\n    //claim fees from fee distro contract, put in lockers' reward contract\n    function earmarkFees() external returns (bool) {\n        //claim fee rewards\n        IStaker(staker).claimFees(feeDistro, feeToken);\n        //send fee rewards to reward contract\n        uint256 _balance = IERC20(feeToken).balanceOf(address(this));\n\n        uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);\n        uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(\n            FEE_DENOMINATOR\n        );\n        if (_lockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);\n            IRewards(lockFees).queueNewRewards(_lockFeesIncentive);\n        }\n        if (_stakerLockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);\n            IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);\n        }\n        return true;\n    }\n\n    //callback from reward contract when veAsset is received.\n    function rewardClaimed(\n        uint256 _pid,\n        address _address,\n        uint256 _amount\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");\n        ITokenMinter veTokenMinter = ITokenMinter(minter);\n        //calc the amount of veAssetEarned\n        uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(\n            veTokenMinter.totalWeight()\n        );\n        //mint reward tokens\n        ITokenMinter(minter).mint(_address, _veAssetEarned);\n\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract ExtraRewardStashV3 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant maxRewards = 8;\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public immutable pid;\n    address public immutable veAsset;\n    address public immutable operator;\n    address public immutable staker;\n    address public immutable gauge;\n    address public immutable rewardFactory;\n\n    mapping(address => uint256) public historicalRewards;\n    bool public hasRedirected;\n\n    struct TokenInfo {\n        address token;\n        address rewardAddress;\n    }\n    uint256 public tokenCount;\n    TokenInfo[maxRewards] public tokenInfo;\n\n    constructor(\n        uint256 _pid,\n        address _veAsset,\n        address _operator,\n        address _staker,\n        address _gauge,\n        address _rFactory\n    ) {\n        pid = _pid;\n        veAsset = _veAsset;\n        operator = _operator;\n        staker = _staker;\n        gauge = _gauge;\n        rewardFactory = _rFactory;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ExtraRewardStashV3\";\n    }\n\n    //try claiming if there are reward tokens registered\n    function claimRewards() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        //this is updateable from v2 gauges now so must check each time.\n        checkForNewRewardTokens();\n\n        //make sure we're redirected\n        if (!hasRedirected) {\n            IDeposit(operator).setGaugeRedirect(pid);\n            hasRedirected = true;\n        }\n\n        uint256 length = tokenCount;\n        if (length > 0) {\n            //claim rewards on gauge for staker\n            //using reward_receiver so all rewards will be moved to this stash\n            IDeposit(operator).claimRewards(pid, gauge);\n        }\n        return true;\n    }\n\n    //check if gauge rewards have changed\n    function checkForNewRewardTokens() internal {\n        for (uint256 i = 0; i < maxRewards; i++) {\n            address token = IGauge(gauge).reward_tokens(i);\n            if (token == address(0)) {\n                if (i != tokenCount) {\n                    tokenCount = i;\n                }\n                break;\n            }\n            setToken(i, token);\n        }\n    }\n\n    //replace a token on token list\n    function setToken(uint256 _tid, address _token) internal {\n        TokenInfo storage t = tokenInfo[_tid];\n        address currentToken = t.token;\n        if (currentToken != _token) {\n            //set token address\n            t.token = _token;\n\n            //create new reward contract\n            (, , , address mainRewardContract, , ) = IDeposit(operator).poolInfo(pid);\n            address rewardContract = IRewardFactory(rewardFactory).CreateTokenRewards(\n                _token,\n                mainRewardContract\n            );\n            t.rewardAddress = rewardContract;\n        }\n    }\n\n    //pull assigned tokens from staker to stash\n    function stashRewards() external pure returns (bool) {\n        //after depositing/withdrawing, extra incentive tokens are claimed\n        //but from v3 this is default to off, and this stash is the reward receiver too.\n\n        return true;\n    }\n\n    //send all extra rewards to their reward contracts\n    function processStash() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            TokenInfo storage t = tokenInfo[i];\n            address token = t.token;\n            if (token == address(0)) continue;\n\n            uint256 amount = IERC20(token).balanceOf(address(this));\n            if (amount > 0) {\n                historicalRewards[token] = historicalRewards[token].add(amount);\n                if (token == veAsset) {\n                    //if veAsset, send back to booster to distribute\n                    IERC20(token).safeTransfer(operator, amount);\n                    continue;\n                }\n                //add to reward contract\n                address rewards = t.rewardAddress;\n                if (rewards == address(0)) continue;\n                IERC20(token).safeTransfer(rewards, amount);\n                IRewards(rewards).queueNewRewards(amount);\n            }\n        }\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "VoterProxy.sol",
            "Booster.sol",
            "ExtraRewardStashV3.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Booster._earmarkRewards function, VoterProxy contract, ExtraRewardStashV3 contract",
                "Type": "Reward token stuck",
                "Description": "When claiming veAsset and extra rewards from the Angle's gauge, the VoterProxy contract is used to claim veAsset and all reward tokens are sent to VoterProxy contract. As a result, extra reward tokens (e.g. DAI, WETH) are stuck in the VoterProxy contract and cannot be collected by users.",
                "Repair": "Trigger Booster.setGaugeRedirect during deployment or update Booster._earmarkRewards function to claim both veAsset and extra rewards from the stash contract instead of VoterProxy contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract VeToken is ERC20 {\n    using SafeMath for uint256;\n\n    address public operator;\n\n    uint256 public constant maxSupply = 100 * 1000000 * 1e18; //100mil\n\n    constructor() ERC20(\"veToken Finance\", \"VE3D\") {\n        operator = msg.sender;\n    }\n\n    function setOperator(address _operator) external {\n        require(msg.sender == operator, \"!auth\");\n        operator = _operator;\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        require(msg.sender == operator, \"!authorized\");\n        require(totalSupply().add(_amount) < maxSupply, \"Exceeed max supply!\");\n\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external {\n        require(msg.sender == operator, \"!authorized\");\n\n        _burn(_from, _amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "VeToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "burn function in VeToken.sol",
                "Type": "Governance privilege escalation",
                "Description": "Governance can arbitrarily burn VeToken from any address.",
                "Repair": "Delete the burn function or modify it to only allow msg.sender to burn the token"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"./helper/MathUtil.sol\";\nimport \"./helper/BoringMath.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\n/*\nVE3D Locking contract for https://www.convexfinance.com/\nVE3D locked in this contract will be entitled to voting rights for the Vetoken Finance platform\nBased on EPS Staking contract for http://ellipsis.finance/\nBased on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\n\nV2:\n- change locking mechanism to lock to a future epoch instead of current\n- pending lock getter\n- relocking allocates weight to the current epoch instead of future,\n    thus allows keeping voting weight in the same epoch a lock expires by relocking before a vote begins\n- balanceAtEpoch and supplyAtEpoch return proper values for future epochs\n- do not allow relocking directly to a new address\n*/\ncontract VE3DLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* ========== STATE VARIABLES ========== */\n\n    struct Reward {\n        bool isVeAsset;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n        address ve3Token;\n        address ve3TokenStaking;\n        address veAssetDeposits;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n\n    //token\n    IERC20 public stakingToken; //VE3D\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address => Reward) public rewardData;\n\n    EnumerableSet.AddressSet internal operators;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 16;\n\n    // reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n\n    // user -> reward token -> amount\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    uint256 public constant denominator = 10000;\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _stakingToken) Ownable() {\n        _name = \"Vote Locked Vetoken Token\";\n        _symbol = \"xVE3D\";\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function version() public pure returns (uint256) {\n        return 2;\n    }\n\n    /* ========== ADMIN CONFIGURATION ========== */\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _veAssetDeposits,\n        address _ve3Token,\n        address _ve3TokenStaking,\n        address _distributor,\n        bool _isVeAsset\n    ) external {\n        require(_msgSender() == owner() || operators.contains(_msgSender()), \"!Auth\");\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n\n        rewardData[_rewardsToken].isVeAsset = _isVeAsset;\n        // if reward is veAsset\n        if (_isVeAsset) {\n            require(_ve3Token != address(0));\n            require(_ve3TokenStaking != address(0));\n            require(_veAssetDeposits != address(0));\n            rewardData[_rewardsToken].ve3Token = _ve3Token;\n            rewardData[_rewardsToken].ve3TokenStaking = _ve3TokenStaking;\n            rewardData[_rewardsToken].veAssetDeposits = _veAssetDeposits;\n        }\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    //set approvals for locking veAsset and staking VE3Token\n    function setApprovals() external {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            if (rewardData[_rewardsToken].isVeAsset) {\n                // set approve for staking VE3Token\n                IERC20(rewardData[_rewardsToken].ve3Token).safeApprove(\n                    rewardData[_rewardsToken].ve3TokenStaking,\n                    0\n                );\n                IERC20(rewardData[_rewardsToken].ve3Token).safeApprove(\n                    rewardData[_rewardsToken].ve3TokenStaking,\n                    type(uint256).max\n                );\n\n                // set approve for locking veAsset\n                IERC20(_rewardsToken).safeApprove(rewardData[_rewardsToken].veAssetDeposits, 0);\n                IERC20(_rewardsToken).safeApprove(\n                    rewardData[_rewardsToken].veAssetDeposits,\n                    type(uint256).max\n                );\n            }\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {\n        if (lockedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(lockedSupply)\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                    _rewardPerToken(_rewardsToken).sub(\n                        userRewardPerTokenPaid[_user][_rewardsToken]\n                    )\n                )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256) {\n        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256) {\n        return uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData[](rewardTokens.length);\n        Balances storage userBalance = balances[_account];\n        for (uint256 i = 0; i < userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(_account, token, userBalance.locked);\n        }\n        return userRewards;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user) external view returns (uint256 amount) {\n        return balances[_user].locked;\n    }\n\n    //balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        return balanceAtEpochOf(findEpochId(block.timestamp), _user);\n    }\n\n    //balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we're basing from.\n            if (lockEpoch <= epochTime) {\n                if (lockEpoch > cutoffEpoch) {\n                    amount = amount.add(locks[i].amount);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //return currently locked but not active balance\n    function pendingLockOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        uint256 locksLength = locks.length;\n\n        //return amount if latest lock is in the future\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength > 0 &&\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) > currentEpoch\n        ) {\n            return locks[locksLength - 1].amount;\n        }\n\n        return 0;\n    }\n\n    function pendingLockAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get next epoch from the given epoch index\n        uint256 nextEpoch = uint256(epochs[_epoch].date).add(rewardsDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n\n            //return the next epoch balance\n            if (lockEpoch == nextEpoch) {\n                return locks[i].amount;\n            } else if (lockEpoch < nextEpoch) {\n                //no need to check anymore\n                break;\n            }\n        }\n\n        return 0;\n    }\n\n    //supply of all properly locked balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include next epoch's supply\n        if (uint256(epochs[epochindex - 1].date) > currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply) {\n        uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n            rewardsDuration\n        );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) public view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock < _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user's locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        //create new epoch in the future where new non-active locks will lock to\n        uint256 nextEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration).add(\n            rewardsDuration\n        );\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date < nextEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != nextEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(\n                    rewardsDuration\n                );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, false);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        bool _isRelock\n    ) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n\n        //add user lock records or add to current\n        uint256 lockEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        //if a fresh lock, add on an extra duration period\n        if (!_isRelock) {\n            lockEpoch = lockEpoch.add(rewardsDuration);\n        }\n        uint256 unlockTime = lockEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n\n        //if the latest user lock is smaller than this lock, always just add new entry to the end of the list\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({amount: lockAmount, unlockTime: uint32(unlockTime)})\n            );\n        } else {\n            //else add to a current lock\n\n            //if latest lock is further in the future, lower index\n            //this can only happen if relocking an expired lock after creating a new lock\n            if (userLocks[_account][idx - 1].unlockTime > unlockTime) {\n                idx--;\n            }\n\n            //if idx points to the epoch when same unlock time, update\n            //(this is always true with a normal lock but maybe not with relock)\n            if (userLocks[_account][idx - 1].unlockTime == unlockTime) {\n                LockedBalance storage userL = userLocks[_account][idx - 1];\n                userL.amount = userL.amount.add(lockAmount);\n            } else {\n                //can only enter here if a relock is made after a lock and there's no lock entry\n                //for the current epoch.\n                //ex a list of locks such as \"[...][older][current*][next]\" but without a \"current\" lock\n                //length - 1 is the next epoch\n                //length - 2 is a past epoch\n                //thus need to insert an entry for current epoch at the 2nd to last entry\n                //we will copy and insert the tail entry(next) and then overwrite length-2 entry\n\n                //reset idx\n                idx = userLocks[_account].length;\n\n                //get current last item\n                LockedBalance storage userL = userLocks[_account][idx - 1];\n\n                //add a copy to end of list\n                userLocks[_account].push(\n                    LockedBalance({amount: userL.amount, unlockTime: userL.unlockTime})\n                );\n\n                //insert current epoch lock entry by overwriting the entry at length-2\n                userL.amount = lockAmount;\n                userL.unlockTime = uint32(unlockTime);\n            }\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        uint256 eIndex = epochs.length - 1;\n        //if relock, epoch should be current and not next, thus need to decrease index to length-2\n        if (_isRelock) {\n            eIndex--;\n        }\n        Epoch storage e = epochs[eIndex];\n        e.supply = e.supply.add(uint224(lockAmount));\n\n        emit Staked(_account, lockEpoch, _amount, lockAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n\n        if (isShutdown || locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                    rewardsDuration\n                );\n                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                    rewardsDuration\n                );\n                uint256 rRate = MathUtil.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay)) break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch = block\n                        .timestamp\n                        .sub(_checkDelay)\n                        .div(rewardsDuration)\n                        .mul(rewardsDuration);\n                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                        rewardsDuration\n                    );\n                    uint256 rRate = MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        lockedSupply = lockedSupply.sub(locked);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            stakingToken.safeTransfer(_rewardAddress, reward);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, true);\n        } else {\n            stakingToken.safeTransfer(_withdrawTo, locked);\n        }\n    }\n\n    // withdraw expired locks to a different address\n    function withdrawExpiredLocksTo(address _withdrawTo) external nonReentrant {\n        _processExpiredLocks(msg.sender, false, _withdrawTo, msg.sender, 0);\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(\n            _account,\n            false,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward > 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (rewardData[_rewardsToken].isVeAsset) {\n                    IVeAssetDeposit(rewardData[_rewardsToken].veAssetDeposits).deposit(\n                        reward,\n                        false\n                    );\n                    uint256 _ve3TokenBalance = IERC20(rewardData[_rewardsToken].ve3Token)\n                        .balanceOf(address(this));\n\n                    if (_stake) {\n                        IRewards(rewardData[_rewardsToken].ve3TokenStaking).stakeFor(\n                            _account,\n                            _ve3TokenBalance\n                        );\n                    } else {\n                        IERC20(rewardData[_rewardsToken].ve3Token).safeTransfer(\n                            _account,\n                            _ve3TokenBalance\n                        );\n                    }\n                    reward = _ve3TokenBalance;\n                    _rewardsToken = rewardData[_rewardsToken].ve3Token;\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp >= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function queueNewRewards(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender], \"Auth!\");\n        require(_reward > 0, \"No reward\");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        emit RewardAdded(_rewardsToken, _reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token).to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token].periodFinish\n                ).to40();\n                if (_account != address(0)) {\n                    rewards[_account][token] = _earned(_account, token, userBalance.locked);\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 indexed _epoch,\n        uint256 _paidAmount,\n        uint256 _lockedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);\n    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);\n    event Recovered(address _token, uint256 _amount);\n}\n\n\n",
        "CodeNames": [
            "VE3DLocker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "totalSupplyAtEpoch, balanceAtEpochOf, pendingLockAtEpochOf, and totalSupply functions in VE3DLocker.sol",
                "Type": "Logic error",
                "Description": "Inversely traverse for loops always reverts due to underflow.",
                "Repair": "Fix the underflow issue in the inversely traverse for loops"
            }
        ]
    }
]