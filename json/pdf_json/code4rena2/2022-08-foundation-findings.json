[
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"forge-std/Test.sol\";\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport \"../../contracts/NFTDropMarket.sol\";\nimport \"../../contracts/FETH.sol\";\nimport \"../../contracts/NFTDropCollection.sol\";\nimport \"../../contracts/NFTCollectionFactory.sol\";\nimport \"../../contracts/mocks/MockTreasury.sol\";\nimport \"../../contracts/mocks/RoyaltyRegistry/MockRoyaltyRegistry.sol\";\n\ncontract TestFixedPriceDrop is Test {\n  address admin = address(99);\n  address creator = address(1);\n  address collector = address(2);\n\n  MockTreasury treasury;\n  NFTDropMarket nftDropMarket;\n  FETH feth;\n  MockRoyaltyRegistry royaltyRegistry;\n  NFTCollectionFactory nftCollectionFactory;\n\n  function setUp() public {\n    /** Pre-reqs **/\n    treasury = new MockTreasury();\n\n    /** Deploy Collection Factory **/\n    nftCollectionFactory = new NFTCollectionFactory(address(treasury));\n    nftCollectionFactory.initialize(2);\n    NFTDropCollection nftDropCollectionTemplate = new NFTDropCollection(address(nftCollectionFactory));\n    nftCollectionFactory.adminUpdateNFTDropCollectionImplementation(address(nftDropCollectionTemplate));\n\n    /** Deploy Market **/\n    // Deploy the proxy with a placeholder implementation.\n    TransparentUpgradeableProxy dropMarketProxy = new TransparentUpgradeableProxy(address(treasury), admin, \"\");\n    feth = new FETH(payable(dropMarketProxy), payable(dropMarketProxy), 24 hours);\n    royaltyRegistry = new MockRoyaltyRegistry();\n\n    NFTDropMarket dropMarketImplementation = new NFTDropMarket(\n      payable(treasury),\n      address(feth),\n      address(royaltyRegistry)\n    );\n    vm.prank(admin);\n    dropMarketProxy.upgradeTo(address(dropMarketImplementation));\n    nftDropMarket = NFTDropMarket(payable(dropMarketProxy));\n    nftDropMarket.initialize();\n  }\n\n  function testHappyCase() public {\n    /** Create drop collection **/\n    uint256 nonce = 42;\n    uint32 maxTokenId = 100;\n    vm.prank(creator);\n    nftCollectionFactory.createNFTDropCollection(\n      \"Name\",\n      \"SYM\",\n      \"ipfs://sample\",\n      0x0,\n      maxTokenId,\n      address(nftDropMarket),\n      nonce\n    );\n    NFTDropCollection nftDropCollection = NFTDropCollection(\n      nftCollectionFactory.predictNFTDropCollectionAddress(creator, nonce)\n    );\n\n    /** List for sale **/\n    uint80 price = 0.5 ether;\n    uint16 limitPerAccount = 10;\n    vm.prank(creator);\n    nftDropMarket.createFixedPriceSale(address(nftDropCollection), price, limitPerAccount);\n\n    /** Mint from sale **/\n    uint16 count = 3;\n    vm.deal(collector, 999 ether);\n    vm.prank(collector);\n    nftDropMarket.mintFromFixedPriceSale{ value: price * count }(address(nftDropCollection), count, payable(0));\n  }\n}\n\n\n",
        "CodeNames": [
            "FixedPriceDrop.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FixedPriceDrop.sol",
                "Type": "Possible to bypass limitPerAccount",
                "Description": "It is possible to bypass the saleConfig.limitPerAccount set by the creator by transferring the NFTs out.",
                "Repair": "Use a mapping to track how many NFTs an address has bought instead of relying on balanceOf"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "royaltyInfo, getRoyalties, or getFeeRecipients functions",
                "Type": "Creator fees may be burned",
                "Description": "royaltyInfo, getRoyalties, or getFeeRecipients may return address(0) as the recipient address. While the value 0 is correctly handled for the royalties itself, it is not for the address. In such a case, the ETH amount will be sent to address(0), i.e. it is burned and lost.",
                "Repair": "Treat address(0) as if no recipient was returned such that the other priorities / methods take over"
            },
            {
                "Location": "mixins/shared/MarketFees.sol#L130",
                "Type": "Gas Stealing",
                "Description": "NFT creator sales revenue recipients can steal gas",
                "Repair": "Consider only providing a higher amount of gas (SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT"
            },
            {
                "Location": "getRoyalties function",
                "Type": "Royalty manipulation",
                "Description": "If one creator specified a share that is larger than BASIS_POINTS, the first creator gets all of the royalties. Depending on how these are set (which is not in the control of the project), this can be exploited by the first creator.",
                "Repair": "Ignore the results if totalShares sums to 10,000 or change royalty logic to use the values returned by collections directly"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/IGetFees.sol\";\nimport \"../../interfaces/IGetRoyalties.sol\";\nimport \"../../interfaces/IOwnable.sol\";\nimport \"../../interfaces/IRoyaltyInfo.sol\";\nimport \"../../interfaces/ITokenCreator.sol\";\n\nimport \"../../libraries/ArrayLibrary.sol\";\n\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./OZERC165Checker.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\nimport \"./MarketSharedCore.sol\";\n\nerror NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n\n/**\n * @title A mixin to distribute funds when an NFT is sold.\n */\nabstract contract MarketFees is FoundationTreasuryNode, MarketSharedCore, SendValueWithFallbackWithdraw {\n  using AddressUpgradeable for address;\n  using ArrayLibrary for address payable[];\n  using ArrayLibrary for uint256[];\n  using ERC165Checker for address;\n  using OZERC165Checker for address;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private _primaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryCreatorFeeBasisPoints;\n   * mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;\n   */\n  uint256[4] private __gap_was_fees;\n\n  /// @notice The royalties sent to creator recipients on secondary sales.\n  uint256 private constant CREATOR_ROYALTY_DENOMINATOR = BASIS_POINTS / 1000; // 10%\n  /// @notice The fee collected by Foundation for sales facilitated by this market contract.\n  uint256 private constant PROTOCOL_FEE_DENOMINATOR = BASIS_POINTS / 500; // 5%\n  /// @notice The fee collected by the buy referrer for sales facilitated by this market contract.\n  ///         This fee is calculated from the total protocol fee.\n  /// @dev 20% of protocol fee == 1% of total sale.\n  uint256 private constant BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR = 5;\n\n  IRoyaltyRegistry private immutable royaltyRegistry;\n\n  /// @notice The address of this contract's implementation.\n  /// @dev This is used when making stateless external calls to this contract,\n  /// saving gas over hopping through the proxy which is only necessary when accessing state.\n  MarketFees private immutable implementationAddress;\n\n  /// @notice True for the Drop market which only performs primary sales. False if primary & secondary are supported.\n  bool private immutable assumePrimarySale;\n\n  /**\n   * @notice Emitted when a NFT sold with a referrer.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyReferrer The account which received the buy referral incentive.\n   * @param buyReferrerFee The portion of the protocol fee collected by the buy referrer.\n   * @param buyReferrerSellerFee The portion of the owner revenue collected by the buy referrer (not implemented).\n   */\n  event BuyReferralPaid(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address buyReferrer,\n    uint256 buyReferrerFee,\n    uint256 buyReferrerSellerFee\n  );\n\n  /**\n   * @notice Configures the registry allowing for royalty overrides to be defined.\n   * @param _royaltyRegistry The registry to use for royalty overrides.\n   */\n  constructor(address _royaltyRegistry, bool _assumePrimarySale) {\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\n      revert NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n    }\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\n\n    assumePrimarySale = _assumePrimarySale;\n\n    // In the constructor, `this` refers to the implementation address. Everywhere else it'll be the proxy.\n    implementationAddress = this;\n  }\n\n  /**\n   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n   */\n  function _distributeFunds(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    internal\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      uint256 sellerRev\n    )\n  {\n    address payable[] memory creatorRecipients;\n    uint256[] memory creatorShares;\n\n    uint256 buyReferrerFee;\n    (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      buyReferrer\n    );\n\n    // Pay the creator(s)\n    unchecked {\n      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n        _sendValueWithFallbackWithdraw(\n          creatorRecipients[i],\n          creatorShares[i],\n          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS\n        );\n        // Sum the total creator rev from shares\n        // creatorShares is in ETH so creatorRev will not overflow here.\n        creatorRev += creatorShares[i];\n      }\n    }\n\n    // Pay the seller\n    _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the protocol fee\n    _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the buy referrer fee\n    if (buyReferrerFee != 0) {\n      _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n      emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n      unchecked {\n        // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n        totalFees += buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns how funds will be distributed for a sale at the given price point.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param price The sale price to calculate the fees for.\n   * @return totalFees How much will be sent to the Foundation treasury and/or referrals.\n   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.\n   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.\n   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.\n   * If there is only one `creatorRecipient`, this may be an empty array.\n   * Otherwise `creatorShares.length` == `creatorRecipients.length`.\n   * @return sellerRev How much will be sent to the owner/seller of the NFT.\n   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.\n   * @return seller The address of the owner of the NFT.\n   * If `sellerRev` is 0, this may be `address(0)`.\n   */\n  function getFeesAndRecipients(\n    address nftContract,\n    uint256 tokenId,\n    uint256 price\n  )\n    external\n    view\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      address payable seller\n    )\n  {\n    seller = _getSellerOrOwnerOf(nftContract, tokenId);\n    (totalFees, creatorRecipients, creatorShares, sellerRev, ) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      // TODO add referral info\n      payable(0)\n    );\n\n    // Sum the total creator rev from shares\n    for (uint256 i = 0; i < creatorShares.length; ++i) {\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  /**\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\n   * @dev See https://royaltyregistry.xyz/\n   * @return registry The address of the royalty registry contract.\n   */\n  function getRoyaltyRegistry() external view returns (address registry) {\n    return address(royaltyRegistry);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks the token creator.\n   */\n  function internalGetTokenCreator(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable creator)\n  {\n    creator = ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * If ERC2981 royalties (or getRoyalties) are defined by the NFT contract, allow this standard to define immutable\n   * royalties that cannot be later changed via the royalty registry.\n   */\n  function internalGetImmutableRoyalties(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints)\n  {\n    // 1st priority: ERC-2981\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n        address receiver,\n        uint256 royaltyAmount\n      ) {\n        // Manifold contracts return (address(this), 0) when royalties are not defined\n        // - so ignore results when the amount is 0\n        if (royaltyAmount > 0) {\n          recipients = new address payable[](1);\n          recipients[0] = payable(receiver);\n          splitPerRecipientInBasisPoints = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n          return (recipients, splitPerRecipientInBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 2nd priority: getRoyalties\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients,\n        uint256[] memory recipientBasisPoints\n      ) {\n        if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n          return (_recipients, recipientBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks for royalties defined in the royalty registry or via a non-standard royalty API.\n   */\n  // solhint-disable-next-line code-complexity\n  function internalGetMutableRoyalties(\n    address nftContract,\n    uint256 tokenId,\n    address payable creator\n  ) external view returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints) {\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\n    // The registry requires overrides are not 0 and contracts when set.\n    // If no override is set, the nftContract address is returned.\n\n    try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\n      address overrideContract\n    ) {\n      if (overrideContract != nftContract) {\n        nftContract = overrideContract;\n\n        // The functions above are repeated here if an override is set.\n\n        // 3rd priority: ERC-2981 override\n        if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n          try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n            address receiver,\n            uint256 /* royaltyAmount */\n          ) {\n            recipients = new address payable[](1);\n            recipients[0] = payable(receiver);\n            splitPerRecipientInBasisPoints = new uint256[](1);\n            // The split amount is assumed to be 100% when only 1 recipient is returned\n            return (recipients, splitPerRecipientInBasisPoints);\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n\n        // 4th priority: getRoyalties override\n        if (recipients.length == 0 && nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n          try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            address payable[] memory _recipients,\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Ignore out of gas errors and continue using the nftContract address\n    }\n\n    // 5th priority: getFee* from contract or override\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetFees).interfaceId)) {\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients\n      ) {\n        if (_recipients.length != 0) {\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\n    if (creator != address(0)) {\n      // Only pay the tokenCreator if there wasn't another royalty defined\n      recipients = new address payable[](1);\n      recipients[0] = creator;\n      splitPerRecipientInBasisPoints = new uint256[](1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n\n    // 7th priority: owner from contract or override\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\n      if (owner != address(0)) {\n        // Only pay the owner if there wasn't another royalty defined\n        recipients = new address payable[](1);\n        recipients[0] = payable(owner);\n        splitPerRecipientInBasisPoints = new uint256[](1);\n        // The split amount is assumed to be 100% when only 1 recipient is returned\n        return (recipients, splitPerRecipientInBasisPoints);\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // If no valid payment address or creator is found, return 0 recipients\n  }\n\n  /**\n   * @notice Calculates how funds should be distributed for the given sale details.\n   * @dev When the NFT is being sold by the `tokenCreator`, all the seller revenue will\n   * be split with the royalty recipients defined for that NFT.\n   */\n  // solhint-disable-next-line code-complexity\n  function _getFees(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    private\n    view\n    returns (\n      uint256 totalFees,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      uint256 buyReferrerFee\n    )\n  {\n    // Calculate the protocol fee\n    unchecked {\n      // SafeMath is not required when dividing by a non-zero constant.\n      totalFees = price / PROTOCOL_FEE_DENOMINATOR;\n    }\n\n    address payable creator;\n    try implementationAddress.internalGetTokenCreator(nftContract, tokenId) returns (address payable _creator) {\n      creator = _creator;\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n      address payable[] memory _recipients,\n      uint256[] memory _splitPerRecipientInBasisPoints\n    ) {\n      (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    if (creatorRecipients.length == 0) {\n      // Check mutable royalties only if we didn't find results from the immutable API\n      try implementationAddress.internalGetMutableRoyalties(nftContract, tokenId, creator) returns (\n        address payable[] memory _recipients,\n        uint256[] memory _splitPerRecipientInBasisPoints\n      ) {\n        (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    if (creatorRecipients.length != 0 || assumePrimarySale) {\n      uint256 creatorRev;\n      if (assumePrimarySale) {\n        // All revenue should go to the creator recipients\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n        if (creatorRecipients.length == 0) {\n          // If no creators were found via the royalty APIs, then set that recipient to the seller's address\n          creatorRecipients = new address payable[](1);\n          creatorRecipients[0] = seller;\n          creatorShares = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n        }\n      } else if (seller == creator || (creatorRecipients.length == 1 && seller == creatorRecipients[0])) {\n        // When sold by the creator, all revenue is split if applicable.\n        // If the seller is unknown, assume it's being sold by the creator.\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        unchecked {\n          // SafeMath is not required when dividing by a non-zero constant.\n          creatorRev = price / CREATOR_ROYALTY_DENOMINATOR;\n        }\n        sellerRev = price - totalFees - creatorRev;\n      }\n\n      // Cap the max number of recipients supported\n      creatorRecipients.capLength(MAX_ROYALTY_RECIPIENTS);\n      creatorShares.capLength(MAX_ROYALTY_RECIPIENTS);\n\n      // Sum the total shares defined\n      uint256 totalShares;\n      if (creatorRecipients.length > 1) {\n        unchecked {\n          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n            if (creatorShares[i] > BASIS_POINTS) {\n              // If the numbers are >100% we ignore the fee recipients and pay just the first instead\n              totalShares = 0;\n              break;\n            }\n            totalShares += creatorShares[i];\n          }\n        }\n\n        if (totalShares == 0) {\n          // If no shares were defined or shares were out of bounds, pay only the first recipient\n          creatorRecipients.capLength(1);\n          creatorShares.capLength(1);\n        }\n      }\n\n      // Send payouts to each additional recipient if more than 1 was defined\n      uint256 totalRoyaltiesDistributed;\n      for (uint256 i = 1; i < creatorRecipients.length; ) {\n        uint256 royalty = (creatorRev * creatorShares[i]) / totalShares;\n        totalRoyaltiesDistributed += royalty;\n        creatorShares[i] = royalty;\n        unchecked {\n          ++i;\n        }\n      }\n\n      // Send the remainder to the 1st creator, rounding in their favor\n      creatorShares[0] = creatorRev - totalRoyaltiesDistributed;\n    } else {\n      // No royalty recipients found.\n      unchecked {\n        // totalFees is always < price.\n        sellerRev = price - totalFees;\n      }\n    }\n\n    if (buyReferrer != address(0) && buyReferrer != msg.sender && buyReferrer != seller && buyReferrer != creator) {\n      unchecked {\n        buyReferrerFee = totalFees / BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR;\n\n        // buyReferrerFee is always <= totalFees\n        totalFees -= buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n",
        "CodeNames": [
            "MarketFees.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MarketFees.sol",
                "Type": "Forget to check zero royalty amount",
                "Description": "Wrong return of cretorShares and creatorRecipients can make real royalties party can't gain the revenue of sale.",
                "Repair": "Add check if royaltyAmount is greater than 0 or not in 3rd priority"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\n/**\n * @notice The required interface for collections to support the NFTDropMarket.\n * @dev This interface must be registered as a ERC165 supported interface to support the NFTDropMarket.\n */\ninterface INFTDropCollectionMint {\n  function mintCountTo(uint16 count, address to) external returns (uint256 firstTokenId);\n\n  function numberOfTokensAvailableToMint() external view returns (uint256 count);\n}\n\n\n",
        "CodeNames": [
            "INFTDropCollectionMint.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "INFTDropCollectionMint.mintCountTo()",
                "Type": "Malicious Creator can steal from collectors upon minting with a custom NFT contract",
                "Description": "In the case of a fixed price sale where nftContract is a custom NFT contract that adheres to INFTDropCollectionMint, a malicious creator can set a malicious implementation of INFTDropCollectionMint.mintCountTo() that would result in collectors calling this function losing funds without receiving the expected amount of NFTs.",
                "Repair": "Add an additional check in NFTDropMarketFixedPriceSale.mintCountTo() using ERC721(nftContract).balanceOf()"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/INFTDropCollectionMint.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/MarketFees.sol\";\n\n/// @param limitPerAccount The limit of tokens an account can purchase.\nerror NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(uint256 limitPerAccount);\nerror NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\nerror NFTDropMarketFixedPriceSale_Mint_Permission_Required();\nerror NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\nerror NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\nerror NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\nerror NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\nerror NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\nerror NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n/// @param mintCost The total cost for this purchase.\nerror NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(uint256 mintCost);\n\n/**\n * @title Allows creators to list a drop collection for sale at a fixed price point.\n * @dev Listing a collection for sale in this market requires the collection to implement\n * the functions in `INFTDropCollectionMint` and to register that interface with ERC165.\n * Additionally the collection must implement access control, or more specifically:\n * `hasRole(bytes32(0), msg.sender)` must return true when called from the creator or admin's account\n * and `hasRole(keccak256(\"MINTER_ROLE\", address(this)))` must return true for this market's address.\n */\nabstract contract NFTDropMarketFixedPriceSale is MarketFees {\n  using AddressUpgradeable for address;\n  using AddressUpgradeable for address payable;\n  using ERC165Checker for address;\n\n  /**\n   * @notice Configuration for the terms of the sale.\n   * @dev This structure is packed in order to consume just a single slot.\n   */\n  struct FixedPriceSaleConfig {\n    /**\n     * @notice The seller for the drop.\n     */\n    address payable seller;\n    /**\n     * @notice The fixed price per NFT in the collection.\n     * @dev The maximum price that can be set on an NFT is ~1.2M (2^80/10^18) ETH.\n     */\n    uint80 price;\n    /**\n     * @notice The max number of NFTs an account may have while minting.\n     */\n    uint16 limitPerAccount;\n  }\n\n  /**\n   * @notice Stores the current sale information for all drop contracts.\n   */\n  mapping(address => FixedPriceSaleConfig) private nftContractToFixedPriceSaleConfig;\n\n  /**\n   * @notice The `role` type used to validate drop collections have granted this market access to mint.\n   * @return `keccak256(\"MINTER_ROLE\")`\n   */\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @notice Emitted when a collection is listed for sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @param seller The address for the seller which listed this for sale.\n   * @param price The price per NFT minted.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   */\n  event CreateFixedPriceSale(\n    address indexed nftContract,\n    address indexed seller,\n    uint256 price,\n    uint256 limitPerAccount\n  );\n\n  /**\n   * @notice Emitted when NFTs are minted from the drop.\n   * @dev The total price paid by the buyer is `totalFees + creatorRev`.\n   * @param nftContract The address of the NFT drop collection.\n   * @param buyer The address of the buyer.\n   * @param firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @param count The number of NFTs minted.\n   * @param totalFees The amount of ETH that was sent to Foundation & referrals for this sale.\n   * @param creatorRev The amount of ETH that was sent to the creator for this sale.\n   */\n  event MintFromFixedPriceDrop(\n    address indexed nftContract,\n    address indexed buyer,\n    uint256 indexed firstTokenId,\n    uint256 count,\n    uint256 totalFees,\n    uint256 creatorRev\n  );\n\n  /**\n   * @notice Create a fixed price sale drop.\n   * @param nftContract The address of the NFT drop collection.\n   * @param price The price per NFT minted.\n   * Set price to 0 for a first come first serve airdrop-like drop.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   * @dev Notes:\n   *   a) The sale is final and can not be updated or canceled.\n   *   b) The sale is immediately kicked off.\n   *   c) Any collection that abides by `INFTDropCollectionMint` and `IAccessControl` is supported.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function createFixedPriceSale(\n    address nftContract,\n    uint80 price,\n    uint16 limitPerAccount\n  ) external {\n    // Confirm the drop collection is supported\n    if (!nftContract.supportsInterface(type(INFTDropCollectionMint).interfaceId)) {\n      revert NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\n    }\n    if (INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\n    }\n\n    // Use the AccessControl interface to confirm the msg.sender has permissions to list.\n    if (!IAccessControl(nftContract).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n      revert NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n    }\n    // And that this contract has permission to mint.\n    if (!IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this))) {\n      revert NFTDropMarketFixedPriceSale_Mint_Permission_Required();\n    }\n\n    // Validate input params.\n    if (limitPerAccount == 0) {\n      revert NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\n    }\n    // Any price is supported, including 0.\n\n    // Confirm this collection has not already been listed.\n    FixedPriceSaleConfig storage saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n    if (saleConfig.seller != payable(0)) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\n    }\n\n    // Save the sale details.\n    saleConfig.seller = payable(msg.sender);\n    saleConfig.price = price;\n    saleConfig.limitPerAccount = limitPerAccount;\n    emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n  }\n\n  /**\n   * @notice Used to mint `count` number of NFTs from the collection.\n   * @param nftContract The address of the NFT drop collection.\n   * @param count The number of NFTs to mint.\n   * @param buyReferrer The address which referred this purchase, or address(0) if n/a.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @dev This call may revert if the collection has sold out, has an insufficient number of tokens available,\n   * or if the market's minter permissions were removed.\n   * If insufficient msg.value is included, the msg.sender's available FETH token balance will be used.\n   */\n  function mintFromFixedPriceSale(\n    address nftContract,\n    uint16 count,\n    address payable buyReferrer\n  ) external payable returns (uint256 firstTokenId) {\n    // Validate input params.\n    if (count == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\n    }\n\n    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n\n    // Confirm that the buyer will not exceed the limit specified after minting.\n    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\n      if (saleConfig.limitPerAccount == 0) {\n        // Provide a more targeted error if the collection has not been listed.\n        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n      }\n      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n    }\n\n    // Calculate the total cost, considering the `count` requested.\n    uint256 mintCost;\n    unchecked {\n      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.\n      mintCost = uint256(saleConfig.price) * count;\n    }\n\n    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.\n    if (msg.value > mintCost) {\n      // Since price is known ahead of time, if too much ETH is sent then something went wrong.\n      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);\n    }\n    // Withdraw from the user's available FETH balance if insufficient msg.value was included.\n    _tryUseFETHBalance(mintCost, false);\n\n    // Mint the NFTs.\n    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n\n    // Distribute revenue from this sale.\n    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(\n      nftContract,\n      firstTokenId,\n      saleConfig.seller,\n      mintCost,\n      buyReferrer\n    );\n\n    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);\n  }\n\n  /**\n   * @notice Returns the max number of NFTs a given account may mint.\n   * @param nftContract The address of the NFT drop collection.\n   * @param user The address of the user which will be minting.\n   * @return numberThatCanBeMinted How many NFTs the user can mint.\n   */\n  function getAvailableCountFromFixedPriceSale(address nftContract, address user)\n    external\n    view\n    returns (uint256 numberThatCanBeMinted)\n  {\n    (, , uint256 limitPerAccount, uint256 numberOfTokensAvailableToMint, bool marketCanMint) = getFixedPriceSale(\n      nftContract\n    );\n    if (!marketCanMint) {\n      // No one can mint in the current state.\n      return 0;\n    }\n    uint256 currentBalance = IERC721(nftContract).balanceOf(user);\n    if (currentBalance >= limitPerAccount) {\n      // User has exhausted their limit.\n      return 0;\n    }\n\n    uint256 availableToMint = limitPerAccount - currentBalance;\n    if (availableToMint > numberOfTokensAvailableToMint) {\n      // User has more tokens available than the collection has available.\n      return numberOfTokensAvailableToMint;\n    }\n\n    return availableToMint;\n  }\n\n  /**\n   * @notice Returns details for a drop collection's fixed price sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @return seller The address of the seller which listed this drop for sale.\n   * This value will be address(0) if the collection is not listed or has sold out.\n   * @return price The price per NFT minted.\n   * @return limitPerAccount The max number of NFTs an account may have while minting.\n   * @return numberOfTokensAvailableToMint The total number of NFTs that may still be minted.\n   * @return marketCanMint True if this contract has permissions to mint from the given collection.\n   */\n  function getFixedPriceSale(address nftContract)\n    public\n    view\n    returns (\n      address payable seller,\n      uint256 price,\n      uint256 limitPerAccount,\n      uint256 numberOfTokensAvailableToMint,\n      bool marketCanMint\n    )\n  {\n    try INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() returns (uint256 count) {\n      if (count != 0) {\n        try IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this)) returns (bool hasRole) {\n          marketCanMint = hasRole;\n        } catch {\n          // The contract is not supported - return default values.\n          return (payable(0), 0, 0, 0, false);\n        }\n\n        FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n        seller = saleConfig.seller;\n        price = saleConfig.price;\n        limitPerAccount = saleConfig.limitPerAccount;\n        numberOfTokensAvailableToMint = count;\n      }\n      // Else minted completed -- return default values.\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Contract not supported or self destructed - return default values\n    }\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns the seller for a collection if listed and not already sold out.\n   */\n  function _getSellerOf(\n    address nftContract,\n    uint256 /* tokenId */\n  ) internal view virtual override returns (address payable seller) {\n    (seller, , , , ) = getFixedPriceSale(nftContract);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n",
        "CodeNames": [
            "NFTDropMarketFixedPriceSale.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTDropMarketFixedPriceSale.createFixedPriceSale",
                "Type": "Loss of Funds",
                "Description": "mintFromFixedPriceSale for a custom contract can lead to users losing funds",
                "Repair": "Add an additional check in NFTDropMarketFixedPriceSale.mintCountTo() using ERC721(nftContract).balanceOf() or specify in INFTDropCollectionMint that mintCountTo must revert if called after all tokens have been minted"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTDropCollectionMint.sol\";\n\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/roles/AdminRole.sol\";\nimport \"./mixins/roles/MinterRole.sol\";\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A contract to batch mint a collection of NFTs.\n * @notice A 10% royalty to the creator is included which may be split with collaborators.\n * @dev A collection can have up to 4,294,967,295 (2^32-1) tokens\n */\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  AdminRole,\n  MinterRole,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using Strings for uint256;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address to pay the proceeds/royalties for the collection.\n   * @dev If this is set to address(0) then the proceeds go to the creator.\n   */\n  address payable private paymentAddress;\n  // 96 bits free space\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `<tokenId>.json` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for `tokenId`: \"1\" with `baseURI`: \"ipfs://foo/\" is \"ipfs://foo/1.json\".\n   * @return The base URI used by this collection.\n   */\n  string public baseURI;\n\n  /****** Slot 2 ******/\n  /**\n   * @notice The hash of the revealed baseURI for the collection.\n   * @dev This can be used to verify that the content was not changed after NFTs were minted.\n   * @return bytes32(0) if the content has been revealed.\n   * In pre-reveal state this is set to bytes32(1) when the final content is unknown\n   * otherwise set to keccak256(finalContentBaseURI).\n   */\n  bytes32 public postRevealBaseURIHash;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the collection is revealed.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  event URIUpdated(string baseURI, bytes32 postRevealBaseURIHash);\n\n  modifier validBaseURI(string calldata _baseURI) {\n    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\n    _;\n  }\n\n  modifier onlyWhileUnrevealed() {\n    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * This account is the default admin for this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   * @param _baseURI The base URI for the collection.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param _maxTokenId The max token id for this collection.\n   * @param _approvedMinter An optional address to grant the MINTER_ROLE.\n   * Set to address(0) if only admins should be granted permission to mint.\n   * @param _paymentAddress The address that will receive royalties and mint payments.\n   */\n  function initialize(\n    address payable _creator,\n    string calldata _name,\n    string calldata _symbol,\n    string calldata _baseURI,\n    bytes32 _postRevealBaseURIHash,\n    uint32 _maxTokenId,\n    address _approvedMinter,\n    address payable _paymentAddress\n  ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n\n    // Initialize the NFT\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, _maxTokenId);\n\n    // Initialize royalties\n    if (_paymentAddress != address(0)) {\n      // If no payment address was defined, use the creator's address.\n      paymentAddress = _paymentAddress;\n    }\n\n    // Initialize URI\n    baseURI = _baseURI;\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n\n    // Initialize access control\n    AdminRole._initializeAdminRole(_creator);\n    if (_approvedMinter != address(0)) {\n      MinterRole._initializeMinterRole(_approvedMinter);\n    }\n  }\n\n  /**\n   * @notice Allows the collection admin to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyAdmin` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyAdmin {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint `count` number of NFTs for the `to` address.\n   * @dev This is only callable by an address with either the MINTER_ROLE or the DEFAULT_ADMIN_ROLE.\n   * @param count The number of NFTs to mint.\n   * @param to The address to mint the NFTs for.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   */\n  function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n    unchecked {\n      // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n      firstTokenId = latestTokenId + 1;\n    }\n    latestTokenId = latestTokenId + count;\n    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n    for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n      _mint(to, i);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a collection admin to reveal the collection's final content.\n   * @dev Once revealed, the collection's content is immutable.\n   * Use `updatePreRevealContent` to update content while unrevealed.\n   * @param _baseURI The base URI of the final content for this collection.\n   */\n  function reveal(string calldata _baseURI) external onlyAdmin validBaseURI(_baseURI) onlyWhileUnrevealed {\n    // `postRevealBaseURIHash` == 0 indicates that the collection has been revealed.\n    delete postRevealBaseURIHash;\n\n    // Set the new base URI.\n    baseURI = _baseURI;\n    emit URIUpdated(_baseURI, \"\");\n  }\n\n  /**\n   * @notice Allows a collection admin to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyAdmin {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyAdmin {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  /**\n   * @notice Allows a collection admin to update the pre-reveal content.\n   * @dev Use `reveal` to reveal the final content for this collection.\n   * @param _baseURI The base URI of the pre-reveal content.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n    external\n    validBaseURI(_baseURI)\n    onlyWhileUnrevealed\n    onlyAdmin\n  {\n    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n    baseURI = _baseURI;\n    emit URIUpdated(baseURI, postRevealBaseURIHash);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(\n    uint256 /* tokenId */\n  ) public view override returns (address payable creatorPaymentAddress) {\n    creatorPaymentAddress = paymentAddress;\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @notice Returns whether the collection has been revealed.\n   * @dev Once revealed, the collection's content is immutable.\n   * @return revealed True if the collection has been revealed.\n   */\n  function isRevealed() external view returns (bool revealed) {\n    revealed = postRevealBaseURIHash == bytes32(0);\n  }\n\n  /**\n   * @notice Get the number of tokens which can still be minted.\n   * @return count The max number of additional NFTs that can be minted by this collection.\n   */\n  function numberOfTokensAvailableToMint() external view returns (uint256 count) {\n    // Mint ensures that latestTokenId is always <= maxTokenId\n    unchecked {\n      count = maxTokenId - latestTokenId;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    if (interfaceId == type(INFTDropCollectionMint).interfaceId) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    _requireMinted(tokenId);\n\n    return string.concat(baseURI, tokenId.toString(), \".json\");\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTDropCollection.sol",
            "NFTCollection.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTCollection.sol:262-274, NFTDropCollection.sol:171-187",
                "Type": "NFT locking",
                "Description": "When calling _mint or mintCountTo function for minting an NFT of a NFT collection or NFT drop collection, the OpenZeppelin's ERC721Upgradeable contract's _mint function is used to mint the NFT to a receiver. If such receiver is a contract that does not support the ERC721 protocol, the NFT will be locked.",
                "Repair": "Change _mint and mintCountTo functions to use _safeMint instead of _mint"
            }
        ]
    }
]