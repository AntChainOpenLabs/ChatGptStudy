[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TridentNFT.permit function",
                "Type": "Medium Severity",
                "Description": "If a user accidentally set the zero address as the operator, tokens can be stolen by anyone as a wrong signature yield recoveredAddress == 0.",
                "Repair": "Change the require logic to recoveredAddress != address(0) && (recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress])"
            },
            {
                "Location": "ConcentratedLiquidityPoolManager.sol#L90-L94",
                "Type": "High Severity",
                "Description": "Possible attacks on Seconds * Liquidity calculation.",
                "Repair": "Lock the positions during a set time while they are staked."
            },
            {
                "Location": "ConcentratedLiquidityPoolManager.reclaimIncentive function",
                "Type": "High Severity",
                "Description": "ConcentratedLiquidityPoolManager's incentives can be stolen.",
                "Repair": "In reclaimIncentive, reduce incentive.rewardsUnclaimed by the withdrawn amount."
            },
            {
                "Location": "Incentive.addIncentive function",
                "Type": "Medium Severity",
                "Description": "Incentive should check that it hasn't started yet.",
                "Repair": "Add a check: require(incentive.secondsClaimed == 0, '!secondsClaimed')"
            },
            {
                "Location": "ConcentratedLiquidityPoolManager.subscribe, getReward, and claimReward functions",
                "Type": "Medium Severity",
                "Description": "Wrong usage of positionId in ConcentratedLiquidityPoolManager.",
                "Repair": "Change positionId to incentiveId in the referenced lines of code."
            },
            {
                "Location": "Incentives for different pools",
                "Type": "Medium Severity",
                "Description": "Incentives for different pools should differ by a large factor.",
                "Repair": "Make sure the developers are at least aware of something like this when choosing incentive amounts for different pools. Carefully choose incentive amounts for each pool."
            },
            {
                "Location": "ConcentratedLiquidityPoolManager.sol, ConcentratedLiquidityPosition.sol, ConcentratedLiquidityPool.sol",
                "Type": "smart contract vulnerability",
                "Description": "Multiple vulnerabilities in the smart contract code of the Concentrated Liquidity Pool of SushiSwap, including integer overflow, incorrect usage of typecasting, and wrong implementation, which could allow attackers to steal yield or funds from the pool.",
                "Repair": "Check whether the result of DyDxMath.getDy or DyDxMath.getDx exceeds type(uint128).max or not. If so, then revert the transaction. Or consider using the SafeCast library from OpenZeppelin instead. Consider removing the unchecked statement to check for integer overflow or casting both amount1Actual and reserve1 to type uint256 before adding them and comparing to the _balance(token). Consider making ConcentratedLiquidityPosition.sol#burn() always use address(this) as recipient and transfer proper amounts to the user. Make adding token0 or token1 as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when collect()."
            },
            {
                "Location": "ConcentratedLiquidityPool.burn function",
                "Type": "unsafe cast",
                "Description": "The burn function performs an unsafe cast of a uint128 type to a *signed* integer.",
                "Repair": "Use SafeCast library everywhere a typecast is done"
            },
            {
                "Location": "ConcentratedLiquidityPoolManager.claimReward function",
                "Type": "uninitialized variable",
                "Description": "The claimReward function requires stake.initialized but it is never set.",
                "Repair": "Set stake.initialized before calling claimReward function"
            },
            {
                "Location": "ConcentratedLiquidityPool.burn function",
                "Type": "incorrect variable update",
                "Description": "The burn function sends out amount0/amount1 tokens but only updates the reserves by decreasing it by the fees of these amounts.",
                "Repair": "Decrease the reserve by what is transferred out"
            },
            {
                "Location": "ConcentratedLiquidityPoolManager.claimReward and getReward functions",
                "Type": "integer underflow",
                "Description": "There could be an integer underflow error when the reward of an incentive is claimed, forcing users to wait for a sufficient period or reduce their liquidity to claim the rewards.",
                "Repair": "Check whether the rewards exceeds the incentive.rewardsUnclaimed"
            },
            {
                "Location": "ConcentratedLiquidityPool.mint/burn functions",
                "Type": "incorrect variable update",
                "Description": "The mint/burn functions add/remove liquidity when (priceLower < currentPrice && currentPrice < priceUpper). Shouldn't it also be changed if priceLower == currentPrice?",
                "Repair": "Change the inequalities to if (priceLower <= currentPrice && currentPrice < priceUpper)"
            },
            {
                "Location": "ConcentratedLiquidityPool.secondsPerLiquidity variable",
                "Type": "incorrect variable update",
                "Description": "secondsPerLiquidity should be modified whenever pool liquidity changes.",
                "Repair": "Update secondsPerLiquidity prior to the change in liquidity"
            },
            {
                "Location": "ConcentratedLiquidityPool.rangeFeeGrowth and rangeSecondsInside functions",
                "Type": "unsafe math",
                "Description": "The fee growth mechanism, and by extension, secondsPerLiquidity mechanism of Uniswap V3 has the ability to underflow. It is therefore a necessity for the math to (ironically) be unsafe / unchecked.",
                "Repair": "Use unchecked math"
            },
            {
                "Location": "RangeFeeGrowth function in ConcentratedLiquidityPool.sol",
                "Type": "range fee growth underflow",
                "Description": "The function RangeFeeGrowth would revert the transaction in some cases when a pool crosses a tick, and feeGrowthBelow + feeGrowthAbove is not necessarily smaller than _feeGrowthGlobal.",
                "Repair": "Modify the tick's algorithm or RangeFeeGrowth function"
            },
            {
                "Location": "ConcentratedLiquidityPool.sol and Ticks.sol",
                "Type": "incorrect feeGrowthGlobal accounting when crossing ticks",
                "Description": "Swap fees are taken from the output, but the logic in Ticks.cross() is reversed, causing wrong fee accounting.",
                "Repair": "Switch the 0 and 1 in Ticks.cross()"
            },
            {
                "Location": "ConcentratedLiquidityPosition.sol",
                "Type": "double yield when calling collect() before burn()",
                "Description": "When a user calls ConcentratedLiquidityPosition.sol#collect() to collect their yield, they may get double the amount of yield when they call burn() to remove liquidity, which dilutes the yield belonging to other users.",
                "Repair": "Make ConcentratedLiquidityPosition.sol#burn() call position.pool.collect() before position.pool.burn(), or change ConcentratedLiquidityPosition.sol#collect() into a public method and call it after position.pool.burn()"
            },
            {
                "Location": "ConcentratedLiquidityPool.sol",
                "Type": "wrong implementation",
                "Description": "The reserves are not updated correctly when LP tokens are burned, causing essential features of the contract to malfunction.",
                "Repair": "Change reserve0 and reserve1 in ConcentratedLiquidityPool.burn() to subtract amount0 and amount1 instead of amount0fees and amount1fees"
            },
            {
                "Location": "ConcentratedLiquidityPool.sol",
                "Type": "initialPrice should be checked to be within allowable range",
                "Description": "No check is performed for the initial price, which can prevent the usability of all other functions.",
                "Repair": "Check that initialPrice is within the acceptable range"
            },
            {
                "Location": "High Severity section",
                "Type": "Understanding vulnerability",
                "Description": "Explanation of the fee growth mechanism and why using nearestTick as the reference point for fee growth calculations instead of the pool tick might not be a wise choice.",
                "Repair": "N/A"
            },
            {
                "Location": "Medium Severity section",
                "Type": "Gas Limit vulnerability",
                "Description": "getTickState() attempts to fetch the state of all inserted ticks (including MIN_TICK and MAX_TICK) of a pool. Depending on the tick spacing, this function may run out of gas.",
                "Repair": "Have a starting index parameter to start the iteration from. Also, tickCount can be made use of more meaningfully to limit the number of iterations performed."
            }
        ]
    }
]