[
    {
        "Code": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO logic version 1\n\n/*********************************\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n *********************************/\n\n// LICENSE\n// NounsDAOLogicV1.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegate.sol\n//\n// GovernorBravoDelegate.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// NounsDAOLogicV1 adds:\n// - Proposal Threshold basis points instead of fixed number\n//   due to the Noun token's increasing supply\n//\n// - Quorum Votes basis points instead of fixed number\n//   due to the Noun token's increasing supply\n//\n// - Per proposal storing of fixed `proposalThreshold`\n//   and `quorumVotes` calculated using the Noun token's total supply\n//   at the block the proposal was created and the basis point parameters\n//\n// - `ProposalCreatedWithRequirements` event that emits `ProposalCreated` parameters with\n//   the addition of `proposalThreshold` and `quorumVotes`\n//\n// - Votes are counted from the block a proposal is created instead of\n//   the proposal's voting start block to align with the parameters\n//   stored with the proposal\n//\n// - Veto ability which allows `veteor` to halt any proposal at any stage unless\n//   the proposal is executed.\n//   The `veto(uint proposalId)` logic is a modified version of `cancel(uint proposalId)`\n//   A `vetoed` flag was added to the `Proposal` struct to support this.\n//\n// NounsDAOLogicV1 removes:\n// - `initialProposalId` and `_initiate()` due to this being the\n//   first instance of the governance contract unlike\n//   GovernorBravo which upgrades GovernorAlpha\n//\n// - Value passed along using `timelock.executeTransaction{value: proposal.value}`\n//   in `execute(uint proposalId)`. This contract should not hold funds and does not\n//   implement `receive()` or `fallback()` functions.\n//\n\npragma solidity ^0.8.6;\n\nimport './NounsDAOInterfaces.sol';\n\ncontract NounsDAOLogicV1 is NounsDAOStorageV1, NounsDAOEvents {\n    /// @notice The name of this contract\n    string public constant name = 'Nouns DAO';\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 40_320; // About 1 week\n\n    /// @notice The minimum setable quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS = 200; // 200 basis points or 2%\n\n    /// @notice The maximum setable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n    /**\n     * @notice Used to initialize the contract during delegator contructor\n     * @param timelock_ The address of the NounsDAOExecutor\n     * @param nouns_ The address of the NOUN tokens\n     * @param vetoer_ The address allowed to unilaterally veto proposals\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThresholdBPS_ The initial proposal threshold in basis points\n     * * @param quorumVotesBPS_ The initial quorum votes threshold in basis points\n     */\n    function initialize(\n        address timelock_,\n        address nouns_,\n        address vetoer_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThresholdBPS_,\n        uint256 quorumVotesBPS_\n    ) public virtual {\n        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n        require(msg.sender == admin, 'NounsDAO::initialize: admin only');\n        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            'NounsDAO::initialize: invalid voting period'\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            'NounsDAO::initialize: invalid voting delay'\n        );\n        require(\n            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::initialize: invalid proposal threshold'\n        );\n        require(\n            quorumVotesBPS_ >= MIN_QUORUM_VOTES_BPS && quorumVotesBPS_ <= MAX_QUORUM_VOTES_BPS,\n            'NounsDAO::initialize: invalid proposal threshold'\n        );\n\n        emit VotingPeriodSet(votingPeriod, votingPeriod_);\n        emit VotingDelaySet(votingDelay, votingDelay_);\n        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);\n        emit QuorumVotesBPSSet(quorumVotesBPS, quorumVotesBPS_);\n\n        timelock = INounsDAOExecutor(timelock_);\n        nouns = NounsTokenLike(nouns_);\n        vetoer = vetoer_;\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThresholdBPS = proposalThresholdBPS_;\n        quorumVotesBPS = quorumVotesBPS_;\n    }\n\n    struct ProposalTemp {\n        uint256 totalSupply;\n        uint256 proposalThreshold;\n        uint256 latestProposalId;\n        uint256 startBlock;\n        uint256 endBlock;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        ProposalTemp memory temp;\n\n        temp.totalSupply = nouns.totalSupply();\n\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'NounsDAO::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n\n        temp.latestProposalId = latestProposalIds[msg.sender];\n        if (temp.latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'NounsDAO::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        temp.startBlock = block.number + votingDelay;\n        temp.endBlock = temp.startBlock + votingPeriod;\n\n        proposalCount++;\n        Proposal storage newProposal = proposals[proposalCount];\n\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.proposalThreshold = temp.proposalThreshold;\n        newProposal.quorumVotes = bps2Uint(quorumVotesBPS, temp.totalSupply);\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = temp.startBlock;\n        newProposal.endBlock = temp.endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n        newProposal.vetoed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        /// @notice Maintains backwards compatibility with GovernorBravo events\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            description\n        );\n\n        /// @notice Updated event with `proposalThreshold` and `quorumVotes`\n        emit ProposalCreatedWithRequirements(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            newProposal.proposalThreshold,\n            newProposal.quorumVotes,\n            description\n        );\n\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'NounsDAO::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');\n\n        Proposal storage proposal = proposals[proposalId];\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the vetoer and the proposal has not been executed.\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        require(vetoer != address(0), 'NounsDAO::veto: veto power burned');\n        require(msg.sender == vetoer, 'NounsDAO::veto: only vetoer');\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::veto: cannot veto executed proposal');\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets\n     * @return values\n     * @return signatures\n     * @return calldatas\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'NounsDAO::castVoteBySig: invalid signature');\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), '');\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, 'NounsDAO::castVoteInternal: voter already voted');\n\n        /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\n        uint96 votes = nouns.getPriorVotes(voter, proposal.startBlock - votingDelay);\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n            'NounsDAO::_setVotingDelay: invalid voting delay'\n        );\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingPeriod: admin only');\n        require(\n            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n            'NounsDAO::_setVotingPeriod: invalid voting period'\n        );\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold basis points\n     * @dev newProposalThresholdBPS must be greater than the hardcoded min\n     * @param newProposalThresholdBPS new proposal threshold\n     */\n    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setProposalThresholdBPS: admin only');\n        require(\n            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::_setProposalThreshold: invalid proposal threshold'\n        );\n        uint256 oldProposalThresholdBPS = proposalThresholdBPS;\n        proposalThresholdBPS = newProposalThresholdBPS;\n\n        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, proposalThresholdBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the quorum votes basis points\n     * @dev newQuorumVotesBPS must be greater than the hardcoded min\n     * @param newQuorumVotesBPS new proposal threshold\n     */\n    function _setQuorumVotesBPS(uint256 newQuorumVotesBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setQuorumVotesBPS: admin only');\n        require(\n            newQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS && newQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS,\n            'NounsDAO::_setProposalThreshold: invalid proposal threshold'\n        );\n        uint256 oldQuorumVotesBPS = quorumVotesBPS;\n        quorumVotesBPS = newQuorumVotesBPS;\n\n        emit QuorumVotesBPSSet(oldQuorumVotesBPS, quorumVotesBPS);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        require(msg.sender == admin, 'NounsDAO::_setPendingAdmin: admin only');\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n        require(msg.sender == pendingAdmin && msg.sender != address(0), 'NounsDAO::_acceptAdmin: pending admin only');\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    /**\n     * @notice Changes vetoer address\n     * @dev Vetoer function for updating vetoer address\n     */\n    function _setVetoer(address newVetoer) public {\n        require(msg.sender == vetoer, 'NounsDAO::_setVetoer: vetoer only');\n\n        emit NewVetoer(vetoer, newVetoer);\n\n        vetoer = newVetoer;\n    }\n\n    /**\n     * @notice Burns veto priviledges\n     * @dev Vetoer function destroying veto power forever\n     */\n    function _burnVetoPower() public {\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n        require(msg.sender == vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n        _setVetoer(address(0));\n    }\n\n    /**\n     * @notice Current proposal threshold using Noun Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function proposalThreshold() public view returns (uint256) {\n        return bps2Uint(proposalThresholdBPS, nouns.totalSupply());\n    }\n\n    /**\n     * @notice Current quorum votes using Noun Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function quorumVotes() public view returns (uint256) {\n        return bps2Uint(quorumVotesBPS, nouns.totalSupply());\n    }\n\n    function bps2Uint(uint256 bps, uint256 number) internal pure returns (uint256) {\n        return (number * bps) / 10000;\n    }\n\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\n\n// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO logic version 2\n\n/*********************************\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n *********************************/\n\n// LICENSE\n// NounsDAOLogicV2.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegate.sol\n//\n// GovernorBravoDelegate.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// See NounsDAOLogicV1 for initial GovernorBravoDelegate modifications.\n\n// NounsDAOLogicV2 adds:\n// - `quorumParamsCheckpoints`, which store dynamic quorum parameters checkpoints\n// to be used when calculating the dynamic quorum.\n// - `_setDynamicQuorumParams(DynamicQuorumParams memory params)`, which allows the\n// DAO to update the dynamic quorum parameters' values.\n// - `getDynamicQuorumParamsAt(uint256 blockNumber_)`\n// - Individual setters of the DynamicQuorumParams members:\n//    - `_setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS)`\n//    - `_setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS)`\n//    - `_setQuorumCoefficient(uint32 newQuorumCoefficient)`\n// - `minQuorumVotes` and `maxQuorumVotes`, which returns the current min and\n// max quorum votes using the current Noun supply.\n// - New `Proposal` struct member:\n//    - `totalSupply` used in dynamic quorum calculation.\n//    - `creationBlock` used for retrieving checkpoints of votes and dynamic quorum params. This now\n// allows changing `votingDelay` without affecting the checkpoints lookup.\n// - `quorumVotes(uint256 proposalId)`, which calculates and returns the dynamic\n// quorum for a specific proposal.\n// - `proposals(uint256 proposalId)` instead of the implicit getter, to avoid stack-too-deep error\n//\n// NounsDAOLogicV2 removes:\n// - `quorumVotes()` has been replaced by `quorumVotes(uint256 proposalId)`.\n\npragma solidity ^0.8.6;\n\nimport './NounsDAOInterfaces.sol';\n\ncontract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n    /// @notice The name of this contract\n    string public constant name = 'Nouns DAO';\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 40_320; // About 1 week\n\n    /// @notice The lower bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_LOWER_BOUND = 200; // 200 basis points or 2%\n\n    /// @notice The upper bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_UPPER_BOUND = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The upper bound of maximum quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS_UPPER_BOUND = 6_000; // 4,000 basis points or 60%\n\n    /// @notice The maximum setable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The maximum priority fee used to cap gas refunds in `castRefundableVote`\n    uint256 public constant MAX_REFUND_PRIORITY_FEE = 2 gwei;\n\n    /// @notice The vote refund gas overhead, including 7K for ETH transfer and 29K for general transaction overhead\n    uint256 public constant REFUND_BASE_GAS = 36000;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n    /// @dev Introduced these errors to reduce contract size, to avoid deployment failure\n    error AdminOnly();\n    error InvalidMinQuorumVotesBPS();\n    error InvalidMaxQuorumVotesBPS();\n    error MinQuorumBPSGreaterThanMaxQuorumBPS();\n    error UnsafeUint16Cast();\n\n    /**\n     * @notice Used to initialize the contract during delegator contructor\n     * @param timelock_ The address of the NounsDAOExecutor\n     * @param nouns_ The address of the NOUN tokens\n     * @param vetoer_ The address allowed to unilaterally veto proposals\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThresholdBPS_ The initial proposal threshold in basis points\n     * @param dynamicQuorumParams_ The initial dynamic quorum parameters\n     */\n    function initialize(\n        address timelock_,\n        address nouns_,\n        address vetoer_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThresholdBPS_,\n        DynamicQuorumParams calldata dynamicQuorumParams_\n    ) public virtual {\n        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n        require(msg.sender == admin, 'NounsDAO::initialize: admin only');\n        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            'NounsDAO::initialize: invalid voting period'\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            'NounsDAO::initialize: invalid voting delay'\n        );\n        require(\n            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::initialize: invalid proposal threshold bps'\n        );\n\n        emit VotingPeriodSet(votingPeriod, votingPeriod_);\n        emit VotingDelaySet(votingDelay, votingDelay_);\n        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);\n\n        timelock = INounsDAOExecutor(timelock_);\n        nouns = NounsTokenLike(nouns_);\n        vetoer = vetoer_;\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThresholdBPS = proposalThresholdBPS_;\n        _setDynamicQuorumParams(\n            dynamicQuorumParams_.minQuorumVotesBPS,\n            dynamicQuorumParams_.maxQuorumVotesBPS,\n            dynamicQuorumParams_.quorumCoefficient\n        );\n    }\n\n    struct ProposalTemp {\n        uint256 totalSupply;\n        uint256 proposalThreshold;\n        uint256 latestProposalId;\n        uint256 startBlock;\n        uint256 endBlock;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        ProposalTemp memory temp;\n\n        temp.totalSupply = nouns.totalSupply();\n\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'NounsDAO::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n\n        temp.latestProposalId = latestProposalIds[msg.sender];\n        if (temp.latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'NounsDAO::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        temp.startBlock = block.number + votingDelay;\n        temp.endBlock = temp.startBlock + votingPeriod;\n\n        proposalCount++;\n        Proposal storage newProposal = _proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.proposalThreshold = temp.proposalThreshold;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = temp.startBlock;\n        newProposal.endBlock = temp.endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n        newProposal.vetoed = false;\n        newProposal.totalSupply = temp.totalSupply;\n        newProposal.creationBlock = block.number;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        /// @notice Maintains backwards compatibility with GovernorBravo events\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            description\n        );\n\n        /// @notice Updated event with `proposalThreshold` and `minQuorumVotes`\n        /// @notice `minQuorumVotes` is always zero since V2 introduces dynamic quorum with checkpoints\n        emit ProposalCreatedWithRequirements(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            newProposal.proposalThreshold,\n            minQuorumVotes(),\n            description\n        );\n\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'NounsDAO::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');\n\n        Proposal storage proposal = _proposals[proposalId];\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the vetoer and the proposal has not been executed.\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        require(vetoer != address(0), 'NounsDAO::veto: veto power burned');\n        require(msg.sender == vetoer, 'NounsDAO::veto: only vetoer');\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::veto: cannot veto executed proposal');\n\n        Proposal storage proposal = _proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets\n     * @return values\n     * @return signatures\n     * @return calldatas\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = _proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return _proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        Proposal storage proposal = _proposals[proposalId];\n        if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes(proposal.id)) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Returns the proposal details given a proposal id.\n     *     The `quorumVotes` member holds the *current* quorum, given the current votes.\n     * @param proposalId the proposal id to get the data for\n     * @return A `ProposalCondensed` struct with the proposal data\n     */\n    function proposals(uint256 proposalId) external view returns (ProposalCondensed memory) {\n        Proposal storage proposal = _proposals[proposalId];\n        return\n            ProposalCondensed({\n                id: proposal.id,\n                proposer: proposal.proposer,\n                proposalThreshold: proposal.proposalThreshold,\n                quorumVotes: quorumVotes(proposal.id),\n                eta: proposal.eta,\n                startBlock: proposal.startBlock,\n                endBlock: proposal.endBlock,\n                forVotes: proposal.forVotes,\n                againstVotes: proposal.againstVotes,\n                abstainVotes: proposal.abstainVotes,\n                canceled: proposal.canceled,\n                vetoed: proposal.vetoed,\n                executed: proposal.executed,\n                totalSupply: proposal.totalSupply,\n                creationBlock: proposal.creationBlock\n            });\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal, asking the DAO to refund gas costs.\n     * Users with > 0 votes receive refunds. Refunds are partial when using a gas priority fee higher than the DAO's cap.\n     * Refunds are partial when the DAO's balance is insufficient.\n     * No refund is sent when the DAO's balance is empty. No refund is sent to users with no votes.\n     * Voting takes place regardless of refund success.\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVote(uint256 proposalId, uint8 support) external {\n        castRefundableVoteInternal(proposalId, support, '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal, asking the DAO to refund gas costs.\n     * Users with > 0 votes receive refunds. Refunds are partial when using a gas priority fee higher than the DAO's cap.\n     * Refunds are partial when the DAO's balance is insufficient.\n     * No refund is sent when the DAO's balance is empty. No refund is sent to users with no votes.\n     * Voting takes place regardless of refund success.\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        castRefundableVoteInternal(proposalId, support, reason);\n    }\n\n    /**\n     * @notice Internal function that carries out refundable voting logic\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVoteInternal(\n        uint256 proposalId,\n        uint8 support,\n        string memory reason\n    ) internal {\n        uint256 startGas = gasleft();\n        uint96 votes = castVoteInternal(msg.sender, proposalId, support);\n        emit VoteCast(msg.sender, proposalId, support, votes, reason);\n        if (votes > 0) {\n            _refundGas(startGas);\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'NounsDAO::castVoteBySig: invalid signature');\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), '');\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n        Proposal storage proposal = _proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, 'NounsDAO::castVoteInternal: voter already voted');\n\n        /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\n        uint96 votes = nouns.getPriorVotes(voter, proposalCreationBlock(proposal));\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n            'NounsDAO::_setVotingDelay: invalid voting delay'\n        );\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingPeriod: admin only');\n        require(\n            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n            'NounsDAO::_setVotingPeriod: invalid voting period'\n        );\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold basis points\n     * @dev newProposalThresholdBPS must be greater than the hardcoded min\n     * @param newProposalThresholdBPS new proposal threshold\n     */\n    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setProposalThresholdBPS: admin only');\n        require(\n            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::_setProposalThreshold: invalid proposal threshold bps'\n        );\n        uint256 oldProposalThresholdBPS = proposalThresholdBPS;\n        proposalThresholdBPS = newProposalThresholdBPS;\n\n        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, proposalThresholdBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the minimum quorum votes bps\n     * @param newMinQuorumVotesBPS minimum quorum votes bps\n     *     Must be between `MIN_QUORUM_VOTES_BPS_LOWER_BOUND` and `MIN_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be lower than or equal to maxQuorumVotesBPS\n     */\n    function _setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setMinQuorumVotesBPS: admin only');\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        require(\n            newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n                newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n            'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n        );\n        require(\n            newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n            'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n        );\n\n        uint16 oldMinQuorumVotesBPS = params.minQuorumVotesBPS;\n        params.minQuorumVotesBPS = newMinQuorumVotesBPS;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MinQuorumVotesBPSSet(oldMinQuorumVotesBPS, newMinQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the maximum quorum votes bps\n     * @param newMaxQuorumVotesBPS maximum quorum votes bps\n     *     Must be lower than `MAX_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be higher than or equal to minQuorumVotesBPS\n     */\n    function _setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setMaxQuorumVotesBPS: admin only');\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        require(\n            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n        );\n        require(\n            params.minQuorumVotesBPS <= newMaxQuorumVotesBPS,\n            'NounsDAO::_setMaxQuorumVotesBPS: min quorum votes bps greater than max'\n        );\n\n        uint16 oldMaxQuorumVotesBPS = params.maxQuorumVotesBPS;\n        params.maxQuorumVotesBPS = newMaxQuorumVotesBPS;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MaxQuorumVotesBPSSet(oldMaxQuorumVotesBPS, newMaxQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the dynamic quorum coefficient\n     * @param newQuorumCoefficient the new coefficient, as a fixed point integer with 6 decimals\n     */\n    function _setQuorumCoefficient(uint32 newQuorumCoefficient) external {\n        require(msg.sender == admin, 'NounsDAO::_setQuorumCoefficient: admin only');\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        uint32 oldQuorumCoefficient = params.quorumCoefficient;\n        params.quorumCoefficient = newQuorumCoefficient;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit QuorumCoefficientSet(oldQuorumCoefficient, newQuorumCoefficient);\n    }\n\n    /**\n     * @notice Admin function for setting all the dynamic quorum parameters\n     * @param newMinQuorumVotesBPS minimum quorum votes bps\n     *     Must be between `MIN_QUORUM_VOTES_BPS_LOWER_BOUND` and `MIN_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be lower than or equal to maxQuorumVotesBPS\n     * @param newMaxQuorumVotesBPS maximum quorum votes bps\n     *     Must be lower than `MAX_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be higher than or equal to minQuorumVotesBPS\n     * @param newQuorumCoefficient the new coefficient, as a fixed point integer with 6 decimals\n     */\n    function _setDynamicQuorumParams(\n        uint16 newMinQuorumVotesBPS,\n        uint16 newMaxQuorumVotesBPS,\n        uint32 newQuorumCoefficient\n    ) public {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        if (\n            newMinQuorumVotesBPS < MIN_QUORUM_VOTES_BPS_LOWER_BOUND ||\n            newMinQuorumVotesBPS > MIN_QUORUM_VOTES_BPS_UPPER_BOUND\n        ) {\n            revert InvalidMinQuorumVotesBPS();\n        }\n        if (newMaxQuorumVotesBPS > MAX_QUORUM_VOTES_BPS_UPPER_BOUND) {\n            revert InvalidMaxQuorumVotesBPS();\n        }\n        if (newMinQuorumVotesBPS > newMaxQuorumVotesBPS) {\n            revert MinQuorumBPSGreaterThanMaxQuorumBPS();\n        }\n\n        DynamicQuorumParams memory oldParams = getDynamicQuorumParamsAt(block.number);\n\n        DynamicQuorumParams memory params = DynamicQuorumParams({\n            minQuorumVotesBPS: newMinQuorumVotesBPS,\n            maxQuorumVotesBPS: newMaxQuorumVotesBPS,\n            quorumCoefficient: newQuorumCoefficient\n        });\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MinQuorumVotesBPSSet(oldParams.minQuorumVotesBPS, params.minQuorumVotesBPS);\n        emit MaxQuorumVotesBPSSet(oldParams.maxQuorumVotesBPS, params.maxQuorumVotesBPS);\n        emit QuorumCoefficientSet(oldParams.quorumCoefficient, params.quorumCoefficient);\n    }\n\n    function _withdraw() external {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n\n        uint256 amount = address(this).balance;\n        (bool sent, ) = msg.sender.call{ value: amount }('');\n\n        emit Withdraw(amount, sent);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        require(msg.sender == admin, 'NounsDAO::_setPendingAdmin: admin only');\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n        require(msg.sender == pendingAdmin && msg.sender != address(0), 'NounsDAO::_acceptAdmin: pending admin only');\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    /**\n     * @notice Changes vetoer address\n     * @dev Vetoer function for updating vetoer address\n     */\n    function _setVetoer(address newVetoer) public {\n        require(msg.sender == vetoer, 'NounsDAO::_setVetoer: vetoer only');\n\n        emit NewVetoer(vetoer, newVetoer);\n\n        vetoer = newVetoer;\n    }\n\n    /**\n     * @notice Burns veto priviledges\n     * @dev Vetoer function destroying veto power forever\n     */\n    function _burnVetoPower() public {\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n        require(msg.sender == vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n        _setVetoer(address(0));\n    }\n\n    /**\n     * @notice Current proposal threshold using Noun Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function proposalThreshold() public view returns (uint256) {\n        return bps2Uint(proposalThresholdBPS, nouns.totalSupply());\n    }\n\n    function proposalCreationBlock(Proposal storage proposal) internal view returns (uint256) {\n        if (proposal.creationBlock == 0) {\n            return proposal.startBlock - votingDelay;\n        }\n        return proposal.creationBlock;\n    }\n\n    /**\n     * @notice Quorum votes required for a specific proposal to succeed\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function quorumVotes(uint256 proposalId) public view returns (uint256) {\n        Proposal storage proposal = _proposals[proposalId];\n        if (proposal.totalSupply == 0) {\n            return proposal.quorumVotes;\n        }\n\n        return\n            dynamicQuorumVotes(\n                proposal.againstVotes,\n                proposal.totalSupply,\n                getDynamicQuorumParamsAt(proposal.creationBlock)\n            );\n    }\n\n    /**\n     * @notice Calculates the required quorum of for-votes based on the amount of against-votes\n     *     The more against-votes there are for a proposal, the higher the required quorum is.\n     *     The quorum BPS is between `params.minQuorumVotesBPS` and params.maxQuorumVotesBPS.\n     *     The additional quorum is calculated as:\n     *       quorumCoefficient * againstVotesBPS\n     * @dev Note the coefficient is a fixed point integer with 6 decimals\n     * @param againstVotes Number of against-votes in the proposal\n     * @param totalSupply The total supply of Nouns at the time of proposal creation\n     * @param params Configurable parameters for calculating the quorum based on againstVotes. See `DynamicQuorumParams` definition for additional details.\n     * @return quorumVotes The required quorum\n     */\n    function dynamicQuorumVotes(\n        uint256 againstVotes,\n        uint256 totalSupply,\n        DynamicQuorumParams memory params\n    ) public pure returns (uint256) {\n        uint256 againstVotesBPS = (10000 * againstVotes) / totalSupply;\n        uint256 quorumAdjustmentBPS = (params.quorumCoefficient * againstVotesBPS) / 1e6;\n        uint256 adjustedQuorumBPS = params.minQuorumVotesBPS + quorumAdjustmentBPS;\n        uint256 quorumBPS = min(params.maxQuorumVotesBPS, adjustedQuorumBPS);\n        return bps2Uint(quorumBPS, totalSupply);\n    }\n\n    /**\n     * @notice returns the dynamic quorum parameters values at a certain block number\n     * @dev The checkpoints array must not be empty, and the block number must be higher than or equal to\n     *     the block of the first checkpoint\n     * @param blockNumber_ the block number to get the params at\n     * @return The dynamic quorum parameters that were set at the given block number\n     */\n    function getDynamicQuorumParamsAt(uint256 blockNumber_) public view returns (DynamicQuorumParams memory) {\n        uint32 blockNumber = safe32(blockNumber_, 'NounsDAO::getDynamicQuorumParamsAt: block number exceeds 32 bits');\n        uint256 len = quorumParamsCheckpoints.length;\n\n        if (len == 0) {\n            return\n                DynamicQuorumParams({\n                    minQuorumVotesBPS: safe16(quorumVotesBPS),\n                    maxQuorumVotesBPS: safe16(quorumVotesBPS),\n                    quorumCoefficient: 0\n                });\n        }\n\n        if (quorumParamsCheckpoints[len - 1].fromBlock <= blockNumber) {\n            return quorumParamsCheckpoints[len - 1].params;\n        }\n\n        if (quorumParamsCheckpoints[0].fromBlock > blockNumber) {\n            return\n                DynamicQuorumParams({\n                    minQuorumVotesBPS: safe16(quorumVotesBPS),\n                    maxQuorumVotesBPS: safe16(quorumVotesBPS),\n                    quorumCoefficient: 0\n                });\n        }\n\n        uint256 lower = 0;\n        uint256 upper = len - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2;\n            DynamicQuorumParamsCheckpoint memory cp = quorumParamsCheckpoints[center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.params;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return quorumParamsCheckpoints[lower].params;\n    }\n\n    function _writeQuorumParamsCheckpoint(DynamicQuorumParams memory params) internal {\n        uint32 blockNumber = safe32(block.number, 'block number exceeds 32 bits');\n        uint256 pos = quorumParamsCheckpoints.length;\n        if (pos > 0 && quorumParamsCheckpoints[pos - 1].fromBlock == blockNumber) {\n            quorumParamsCheckpoints[pos - 1].params = params;\n        } else {\n            quorumParamsCheckpoints.push(DynamicQuorumParamsCheckpoint({ fromBlock: blockNumber, params: params }));\n        }\n    }\n\n    function _refundGas(uint256 startGas) internal {\n        unchecked {\n            uint256 balance = address(this).balance;\n            if (balance == 0) {\n                return;\n            }\n            uint256 gasPrice = min(tx.gasprice, block.basefee + MAX_REFUND_PRIORITY_FEE);\n            uint256 gasUsed = startGas - gasleft() + REFUND_BASE_GAS;\n            uint256 refundAmount = min(gasPrice * gasUsed, balance);\n            (bool refundSent, ) = msg.sender.call{ value: refundAmount }('');\n            emit RefundableVote(msg.sender, refundAmount, refundSent);\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @notice Current min quorum votes using Noun total supply\n     */\n    function minQuorumVotes() public view returns (uint256) {\n        return bps2Uint(getDynamicQuorumParamsAt(block.number).minQuorumVotesBPS, nouns.totalSupply());\n    }\n\n    /**\n     * @notice Current max quorum votes using Noun total supply\n     */\n    function maxQuorumVotes() public view returns (uint256) {\n        return bps2Uint(getDynamicQuorumParamsAt(block.number).maxQuorumVotesBPS, nouns.totalSupply());\n    }\n\n    function bps2Uint(uint256 bps, uint256 number) internal pure returns (uint256) {\n        return (number * bps) / 10000;\n    }\n\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n <= type(uint32).max, errorMessage);\n        return uint32(n);\n    }\n\n    function safe16(uint256 n) internal pure returns (uint16) {\n        if (n > type(uint16).max) {\n            revert UnsafeUint16Cast();\n        }\n        return uint16(n);\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "NounsDAOLogicV1.sol",
            "NounsDAOLogicV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NounsDAOLogicV2.sol and NounsDAOLogicV1.sol",
                "Type": "Loss of Veto Power can Lead to 51% Attack",
                "Description": "Lack of zero address check and lack of 2 step address changing process for vetoer address can lead to Nounders losing their veto power unintentionally and open to 51% attack which can drain their entire treasury.",
                "Repair": "Add zero address check for vetoer address at initialize(). Change _setVetoer() vetoer address changing process to 2-step process."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO logic version 2\n\n/*********************************\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n *********************************/\n\n// LICENSE\n// NounsDAOLogicV2.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegate.sol\n//\n// GovernorBravoDelegate.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// See NounsDAOLogicV1 for initial GovernorBravoDelegate modifications.\n\n// NounsDAOLogicV2 adds:\n// - `quorumParamsCheckpoints`, which store dynamic quorum parameters checkpoints\n// to be used when calculating the dynamic quorum.\n// - `_setDynamicQuorumParams(DynamicQuorumParams memory params)`, which allows the\n// DAO to update the dynamic quorum parameters' values.\n// - `getDynamicQuorumParamsAt(uint256 blockNumber_)`\n// - Individual setters of the DynamicQuorumParams members:\n//    - `_setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS)`\n//    - `_setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS)`\n//    - `_setQuorumCoefficient(uint32 newQuorumCoefficient)`\n// - `minQuorumVotes` and `maxQuorumVotes`, which returns the current min and\n// max quorum votes using the current Noun supply.\n// - New `Proposal` struct member:\n//    - `totalSupply` used in dynamic quorum calculation.\n//    - `creationBlock` used for retrieving checkpoints of votes and dynamic quorum params. This now\n// allows changing `votingDelay` without affecting the checkpoints lookup.\n// - `quorumVotes(uint256 proposalId)`, which calculates and returns the dynamic\n// quorum for a specific proposal.\n// - `proposals(uint256 proposalId)` instead of the implicit getter, to avoid stack-too-deep error\n//\n// NounsDAOLogicV2 removes:\n// - `quorumVotes()` has been replaced by `quorumVotes(uint256 proposalId)`.\n\npragma solidity ^0.8.6;\n\nimport './NounsDAOInterfaces.sol';\n\ncontract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n    /// @notice The name of this contract\n    string public constant name = 'Nouns DAO';\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 40_320; // About 1 week\n\n    /// @notice The lower bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_LOWER_BOUND = 200; // 200 basis points or 2%\n\n    /// @notice The upper bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_UPPER_BOUND = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The upper bound of maximum quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS_UPPER_BOUND = 6_000; // 4,000 basis points or 60%\n\n    /// @notice The maximum setable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The maximum priority fee used to cap gas refunds in `castRefundableVote`\n    uint256 public constant MAX_REFUND_PRIORITY_FEE = 2 gwei;\n\n    /// @notice The vote refund gas overhead, including 7K for ETH transfer and 29K for general transaction overhead\n    uint256 public constant REFUND_BASE_GAS = 36000;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n    /// @dev Introduced these errors to reduce contract size, to avoid deployment failure\n    error AdminOnly();\n    error InvalidMinQuorumVotesBPS();\n    error InvalidMaxQuorumVotesBPS();\n    error MinQuorumBPSGreaterThanMaxQuorumBPS();\n    error UnsafeUint16Cast();\n\n    /**\n     * @notice Used to initialize the contract during delegator contructor\n     * @param timelock_ The address of the NounsDAOExecutor\n     * @param nouns_ The address of the NOUN tokens\n     * @param vetoer_ The address allowed to unilaterally veto proposals\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThresholdBPS_ The initial proposal threshold in basis points\n     * @param dynamicQuorumParams_ The initial dynamic quorum parameters\n     */\n    function initialize(\n        address timelock_,\n        address nouns_,\n        address vetoer_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThresholdBPS_,\n        DynamicQuorumParams calldata dynamicQuorumParams_\n    ) public virtual {\n        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n        require(msg.sender == admin, 'NounsDAO::initialize: admin only');\n        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            'NounsDAO::initialize: invalid voting period'\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            'NounsDAO::initialize: invalid voting delay'\n        );\n        require(\n            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::initialize: invalid proposal threshold bps'\n        );\n\n        emit VotingPeriodSet(votingPeriod, votingPeriod_);\n        emit VotingDelaySet(votingDelay, votingDelay_);\n        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);\n\n        timelock = INounsDAOExecutor(timelock_);\n        nouns = NounsTokenLike(nouns_);\n        vetoer = vetoer_;\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThresholdBPS = proposalThresholdBPS_;\n        _setDynamicQuorumParams(\n            dynamicQuorumParams_.minQuorumVotesBPS,\n            dynamicQuorumParams_.maxQuorumVotesBPS,\n            dynamicQuorumParams_.quorumCoefficient\n        );\n    }\n\n    struct ProposalTemp {\n        uint256 totalSupply;\n        uint256 proposalThreshold;\n        uint256 latestProposalId;\n        uint256 startBlock;\n        uint256 endBlock;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        ProposalTemp memory temp;\n\n        temp.totalSupply = nouns.totalSupply();\n\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'NounsDAO::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n\n        temp.latestProposalId = latestProposalIds[msg.sender];\n        if (temp.latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'NounsDAO::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        temp.startBlock = block.number + votingDelay;\n        temp.endBlock = temp.startBlock + votingPeriod;\n\n        proposalCount++;\n        Proposal storage newProposal = _proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.proposalThreshold = temp.proposalThreshold;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = temp.startBlock;\n        newProposal.endBlock = temp.endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n        newProposal.vetoed = false;\n        newProposal.totalSupply = temp.totalSupply;\n        newProposal.creationBlock = block.number;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        /// @notice Maintains backwards compatibility with GovernorBravo events\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            description\n        );\n\n        /// @notice Updated event with `proposalThreshold` and `minQuorumVotes`\n        /// @notice `minQuorumVotes` is always zero since V2 introduces dynamic quorum with checkpoints\n        emit ProposalCreatedWithRequirements(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            newProposal.proposalThreshold,\n            minQuorumVotes(),\n            description\n        );\n\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'NounsDAO::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');\n\n        Proposal storage proposal = _proposals[proposalId];\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the vetoer and the proposal has not been executed.\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        require(vetoer != address(0), 'NounsDAO::veto: veto power burned');\n        require(msg.sender == vetoer, 'NounsDAO::veto: only vetoer');\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::veto: cannot veto executed proposal');\n\n        Proposal storage proposal = _proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets\n     * @return values\n     * @return signatures\n     * @return calldatas\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = _proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return _proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        Proposal storage proposal = _proposals[proposalId];\n        if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes(proposal.id)) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Returns the proposal details given a proposal id.\n     *     The `quorumVotes` member holds the *current* quorum, given the current votes.\n     * @param proposalId the proposal id to get the data for\n     * @return A `ProposalCondensed` struct with the proposal data\n     */\n    function proposals(uint256 proposalId) external view returns (ProposalCondensed memory) {\n        Proposal storage proposal = _proposals[proposalId];\n        return\n            ProposalCondensed({\n                id: proposal.id,\n                proposer: proposal.proposer,\n                proposalThreshold: proposal.proposalThreshold,\n                quorumVotes: quorumVotes(proposal.id),\n                eta: proposal.eta,\n                startBlock: proposal.startBlock,\n                endBlock: proposal.endBlock,\n                forVotes: proposal.forVotes,\n                againstVotes: proposal.againstVotes,\n                abstainVotes: proposal.abstainVotes,\n                canceled: proposal.canceled,\n                vetoed: proposal.vetoed,\n                executed: proposal.executed,\n                totalSupply: proposal.totalSupply,\n                creationBlock: proposal.creationBlock\n            });\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal, asking the DAO to refund gas costs.\n     * Users with > 0 votes receive refunds. Refunds are partial when using a gas priority fee higher than the DAO's cap.\n     * Refunds are partial when the DAO's balance is insufficient.\n     * No refund is sent when the DAO's balance is empty. No refund is sent to users with no votes.\n     * Voting takes place regardless of refund success.\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVote(uint256 proposalId, uint8 support) external {\n        castRefundableVoteInternal(proposalId, support, '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal, asking the DAO to refund gas costs.\n     * Users with > 0 votes receive refunds. Refunds are partial when using a gas priority fee higher than the DAO's cap.\n     * Refunds are partial when the DAO's balance is insufficient.\n     * No refund is sent when the DAO's balance is empty. No refund is sent to users with no votes.\n     * Voting takes place regardless of refund success.\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        castRefundableVoteInternal(proposalId, support, reason);\n    }\n\n    /**\n     * @notice Internal function that carries out refundable voting logic\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVoteInternal(\n        uint256 proposalId,\n        uint8 support,\n        string memory reason\n    ) internal {\n        uint256 startGas = gasleft();\n        uint96 votes = castVoteInternal(msg.sender, proposalId, support);\n        emit VoteCast(msg.sender, proposalId, support, votes, reason);\n        if (votes > 0) {\n            _refundGas(startGas);\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'NounsDAO::castVoteBySig: invalid signature');\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), '');\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n        Proposal storage proposal = _proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, 'NounsDAO::castVoteInternal: voter already voted');\n\n        /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\n        uint96 votes = nouns.getPriorVotes(voter, proposalCreationBlock(proposal));\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n            'NounsDAO::_setVotingDelay: invalid voting delay'\n        );\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingPeriod: admin only');\n        require(\n            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n            'NounsDAO::_setVotingPeriod: invalid voting period'\n        );\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold basis points\n     * @dev newProposalThresholdBPS must be greater than the hardcoded min\n     * @param newProposalThresholdBPS new proposal threshold\n     */\n    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setProposalThresholdBPS: admin only');\n        require(\n            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::_setProposalThreshold: invalid proposal threshold bps'\n        );\n        uint256 oldProposalThresholdBPS = proposalThresholdBPS;\n        proposalThresholdBPS = newProposalThresholdBPS;\n\n        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, proposalThresholdBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the minimum quorum votes bps\n     * @param newMinQuorumVotesBPS minimum quorum votes bps\n     *     Must be between `MIN_QUORUM_VOTES_BPS_LOWER_BOUND` and `MIN_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be lower than or equal to maxQuorumVotesBPS\n     */\n    function _setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setMinQuorumVotesBPS: admin only');\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        require(\n            newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n                newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n            'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n        );\n        require(\n            newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n            'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n        );\n\n        uint16 oldMinQuorumVotesBPS = params.minQuorumVotesBPS;\n        params.minQuorumVotesBPS = newMinQuorumVotesBPS;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MinQuorumVotesBPSSet(oldMinQuorumVotesBPS, newMinQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the maximum quorum votes bps\n     * @param newMaxQuorumVotesBPS maximum quorum votes bps\n     *     Must be lower than `MAX_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be higher than or equal to minQuorumVotesBPS\n     */\n    function _setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setMaxQuorumVotesBPS: admin only');\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        require(\n            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n        );\n        require(\n            params.minQuorumVotesBPS <= newMaxQuorumVotesBPS,\n            'NounsDAO::_setMaxQuorumVotesBPS: min quorum votes bps greater than max'\n        );\n\n        uint16 oldMaxQuorumVotesBPS = params.maxQuorumVotesBPS;\n        params.maxQuorumVotesBPS = newMaxQuorumVotesBPS;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MaxQuorumVotesBPSSet(oldMaxQuorumVotesBPS, newMaxQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the dynamic quorum coefficient\n     * @param newQuorumCoefficient the new coefficient, as a fixed point integer with 6 decimals\n     */\n    function _setQuorumCoefficient(uint32 newQuorumCoefficient) external {\n        require(msg.sender == admin, 'NounsDAO::_setQuorumCoefficient: admin only');\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        uint32 oldQuorumCoefficient = params.quorumCoefficient;\n        params.quorumCoefficient = newQuorumCoefficient;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit QuorumCoefficientSet(oldQuorumCoefficient, newQuorumCoefficient);\n    }\n\n    /**\n     * @notice Admin function for setting all the dynamic quorum parameters\n     * @param newMinQuorumVotesBPS minimum quorum votes bps\n     *     Must be between `MIN_QUORUM_VOTES_BPS_LOWER_BOUND` and `MIN_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be lower than or equal to maxQuorumVotesBPS\n     * @param newMaxQuorumVotesBPS maximum quorum votes bps\n     *     Must be lower than `MAX_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be higher than or equal to minQuorumVotesBPS\n     * @param newQuorumCoefficient the new coefficient, as a fixed point integer with 6 decimals\n     */\n    function _setDynamicQuorumParams(\n        uint16 newMinQuorumVotesBPS,\n        uint16 newMaxQuorumVotesBPS,\n        uint32 newQuorumCoefficient\n    ) public {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        if (\n            newMinQuorumVotesBPS < MIN_QUORUM_VOTES_BPS_LOWER_BOUND ||\n            newMinQuorumVotesBPS > MIN_QUORUM_VOTES_BPS_UPPER_BOUND\n        ) {\n            revert InvalidMinQuorumVotesBPS();\n        }\n        if (newMaxQuorumVotesBPS > MAX_QUORUM_VOTES_BPS_UPPER_BOUND) {\n            revert InvalidMaxQuorumVotesBPS();\n        }\n        if (newMinQuorumVotesBPS > newMaxQuorumVotesBPS) {\n            revert MinQuorumBPSGreaterThanMaxQuorumBPS();\n        }\n\n        DynamicQuorumParams memory oldParams = getDynamicQuorumParamsAt(block.number);\n\n        DynamicQuorumParams memory params = DynamicQuorumParams({\n            minQuorumVotesBPS: newMinQuorumVotesBPS,\n            maxQuorumVotesBPS: newMaxQuorumVotesBPS,\n            quorumCoefficient: newQuorumCoefficient\n        });\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MinQuorumVotesBPSSet(oldParams.minQuorumVotesBPS, params.minQuorumVotesBPS);\n        emit MaxQuorumVotesBPSSet(oldParams.maxQuorumVotesBPS, params.maxQuorumVotesBPS);\n        emit QuorumCoefficientSet(oldParams.quorumCoefficient, params.quorumCoefficient);\n    }\n\n    function _withdraw() external {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n\n        uint256 amount = address(this).balance;\n        (bool sent, ) = msg.sender.call{ value: amount }('');\n\n        emit Withdraw(amount, sent);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        require(msg.sender == admin, 'NounsDAO::_setPendingAdmin: admin only');\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n        require(msg.sender == pendingAdmin && msg.sender != address(0), 'NounsDAO::_acceptAdmin: pending admin only');\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    /**\n     * @notice Changes vetoer address\n     * @dev Vetoer function for updating vetoer address\n     */\n    function _setVetoer(address newVetoer) public {\n        require(msg.sender == vetoer, 'NounsDAO::_setVetoer: vetoer only');\n\n        emit NewVetoer(vetoer, newVetoer);\n\n        vetoer = newVetoer;\n    }\n\n    /**\n     * @notice Burns veto priviledges\n     * @dev Vetoer function destroying veto power forever\n     */\n    function _burnVetoPower() public {\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n        require(msg.sender == vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n        _setVetoer(address(0));\n    }\n\n    /**\n     * @notice Current proposal threshold using Noun Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function proposalThreshold() public view returns (uint256) {\n        return bps2Uint(proposalThresholdBPS, nouns.totalSupply());\n    }\n\n    function proposalCreationBlock(Proposal storage proposal) internal view returns (uint256) {\n        if (proposal.creationBlock == 0) {\n            return proposal.startBlock - votingDelay;\n        }\n        return proposal.creationBlock;\n    }\n\n    /**\n     * @notice Quorum votes required for a specific proposal to succeed\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function quorumVotes(uint256 proposalId) public view returns (uint256) {\n        Proposal storage proposal = _proposals[proposalId];\n        if (proposal.totalSupply == 0) {\n            return proposal.quorumVotes;\n        }\n\n        return\n            dynamicQuorumVotes(\n                proposal.againstVotes,\n                proposal.totalSupply,\n                getDynamicQuorumParamsAt(proposal.creationBlock)\n            );\n    }\n\n    /**\n     * @notice Calculates the required quorum of for-votes based on the amount of against-votes\n     *     The more against-votes there are for a proposal, the higher the required quorum is.\n     *     The quorum BPS is between `params.minQuorumVotesBPS` and params.maxQuorumVotesBPS.\n     *     The additional quorum is calculated as:\n     *       quorumCoefficient * againstVotesBPS\n     * @dev Note the coefficient is a fixed point integer with 6 decimals\n     * @param againstVotes Number of against-votes in the proposal\n     * @param totalSupply The total supply of Nouns at the time of proposal creation\n     * @param params Configurable parameters for calculating the quorum based on againstVotes. See `DynamicQuorumParams` definition for additional details.\n     * @return quorumVotes The required quorum\n     */\n    function dynamicQuorumVotes(\n        uint256 againstVotes,\n        uint256 totalSupply,\n        DynamicQuorumParams memory params\n    ) public pure returns (uint256) {\n        uint256 againstVotesBPS = (10000 * againstVotes) / totalSupply;\n        uint256 quorumAdjustmentBPS = (params.quorumCoefficient * againstVotesBPS) / 1e6;\n        uint256 adjustedQuorumBPS = params.minQuorumVotesBPS + quorumAdjustmentBPS;\n        uint256 quorumBPS = min(params.maxQuorumVotesBPS, adjustedQuorumBPS);\n        return bps2Uint(quorumBPS, totalSupply);\n    }\n\n    /**\n     * @notice returns the dynamic quorum parameters values at a certain block number\n     * @dev The checkpoints array must not be empty, and the block number must be higher than or equal to\n     *     the block of the first checkpoint\n     * @param blockNumber_ the block number to get the params at\n     * @return The dynamic quorum parameters that were set at the given block number\n     */\n    function getDynamicQuorumParamsAt(uint256 blockNumber_) public view returns (DynamicQuorumParams memory) {\n        uint32 blockNumber = safe32(blockNumber_, 'NounsDAO::getDynamicQuorumParamsAt: block number exceeds 32 bits');\n        uint256 len = quorumParamsCheckpoints.length;\n\n        if (len == 0) {\n            return\n                DynamicQuorumParams({\n                    minQuorumVotesBPS: safe16(quorumVotesBPS),\n                    maxQuorumVotesBPS: safe16(quorumVotesBPS),\n                    quorumCoefficient: 0\n                });\n        }\n\n        if (quorumParamsCheckpoints[len - 1].fromBlock <= blockNumber) {\n            return quorumParamsCheckpoints[len - 1].params;\n        }\n\n        if (quorumParamsCheckpoints[0].fromBlock > blockNumber) {\n            return\n                DynamicQuorumParams({\n                    minQuorumVotesBPS: safe16(quorumVotesBPS),\n                    maxQuorumVotesBPS: safe16(quorumVotesBPS),\n                    quorumCoefficient: 0\n                });\n        }\n\n        uint256 lower = 0;\n        uint256 upper = len - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2;\n            DynamicQuorumParamsCheckpoint memory cp = quorumParamsCheckpoints[center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.params;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return quorumParamsCheckpoints[lower].params;\n    }\n\n    function _writeQuorumParamsCheckpoint(DynamicQuorumParams memory params) internal {\n        uint32 blockNumber = safe32(block.number, 'block number exceeds 32 bits');\n        uint256 pos = quorumParamsCheckpoints.length;\n        if (pos > 0 && quorumParamsCheckpoints[pos - 1].fromBlock == blockNumber) {\n            quorumParamsCheckpoints[pos - 1].params = params;\n        } else {\n            quorumParamsCheckpoints.push(DynamicQuorumParamsCheckpoint({ fromBlock: blockNumber, params: params }));\n        }\n    }\n\n    function _refundGas(uint256 startGas) internal {\n        unchecked {\n            uint256 balance = address(this).balance;\n            if (balance == 0) {\n                return;\n            }\n            uint256 gasPrice = min(tx.gasprice, block.basefee + MAX_REFUND_PRIORITY_FEE);\n            uint256 gasUsed = startGas - gasleft() + REFUND_BASE_GAS;\n            uint256 refundAmount = min(gasPrice * gasUsed, balance);\n            (bool refundSent, ) = msg.sender.call{ value: refundAmount }('');\n            emit RefundableVote(msg.sender, refundAmount, refundSent);\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @notice Current min quorum votes using Noun total supply\n     */\n    function minQuorumVotes() public view returns (uint256) {\n        return bps2Uint(getDynamicQuorumParamsAt(block.number).minQuorumVotesBPS, nouns.totalSupply());\n    }\n\n    /**\n     * @notice Current max quorum votes using Noun total supply\n     */\n    function maxQuorumVotes() public view returns (uint256) {\n        return bps2Uint(getDynamicQuorumParamsAt(block.number).maxQuorumVotesBPS, nouns.totalSupply());\n    }\n\n    function bps2Uint(uint256 bps, uint256 number) internal pure returns (uint256) {\n        return (number * bps) / 10000;\n    }\n\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n <= type(uint32).max, errorMessage);\n        return uint32(n);\n    }\n\n    function safe16(uint256 n) internal pure returns (uint16) {\n        if (n > type(uint16).max) {\n            revert UnsafeUint16Cast();\n        }\n        return uint16(n);\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "NounsDAOLogicV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NounsDAOLogicV2.sol",
                "Type": "Voters can burn large amounts of Ether by submitting votes with long reason strings",
                "Description": "Voters can burn large amounts of Ether by submitting votes with long reason strings. The gas refunds will include the gas price of emitting this event, which could potentially be very large.",
                "Repair": "Add a check to the length of reason in castRefundableVoteWithReason(), reverting if it is too long."
            },
            {
                "Location": "NounsDAOLogicV2.sol: cancel() function",
                "Type": "Inconsistent State Access Control",
                "Description": "User A cannot cancel User B's proposal when User B's prior number of votes at relevant block is same as proposal threshold, which contradicts the fact that User B actually cannot create the proposal when the prior number of votes is same as proposal threshold.",
                "Repair": "Update the cancel() function to allow cancellation of proposals when the prior number of votes at relevant block is same as proposal threshold"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "delegateBySig function and _moveDelegates function",
                "Type": "Loss of user's vote and NFT transfer due to overflow",
                "Description": "The delegateBySig function allows the user to vote to address 0, which causes the user to permanently lose his vote and cannot transfer his NFT due to overflow in the _moveDelegates function.",
                "Repair": "Add a requirement in the delegateBySig function that delegatee cannot be address 0"
            }
        ]
    }
]