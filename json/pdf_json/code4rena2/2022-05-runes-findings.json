[
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the tokens of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsGuild is\n    IForgottenRunesWarriorsGuild,\n    Ownable,\n    ReentrancyGuard,\n    ERC721\n{\n    using Strings for uint256;\n\n    /// @notice The maximum number of Warriors\n    uint256 public constant MAX_WARRIORS = 16000;\n\n    /// @notice Counter to track the number minted so far\n    uint256 public numMinted = 0;\n\n    /// @notice Address of the minter\n    address public minter;\n\n    /// @notice The base URI for the metadata of the tokens\n    string public baseTokenURI;\n\n    string public constant R =\n        \"Old men forget: yet all shall be forgot, But he'll remember with advantages What feats he did that day: then shall our names Familiar in his mouth as household words. This story shall the good man teach his son From this day to the ending of the world\";\n\n    /// @notice The provenance hash\n    string public METADATA_PROVENANCE_HASH = '';\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param baseURI string the initial base URI for the token metadata URL\n     */\n    constructor(string memory baseURI)\n        ERC721('ForgottenRunesWarriorsGuild', 'WARRIORS')\n    {\n        setBaseURI(baseURI);\n    }\n\n    /**\n     * @dev Convenient way to initialize the contract\n     * @param newMinter address of the minter contract\n     */\n    function initialize(address newMinter) public onlyOwner {\n        setMinter(newMinter);\n    }\n\n    /**\n     * @dev Returns the URL of a given tokenId\n     * @param tokenId uint256 ID of the token to be minted\n     * @return string the URL of a given tokenId\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            'ERC721Metadata: URI query for nonexistent token'\n        );\n\n        return string(abi.encodePacked(baseTokenURI, tokenId.toString()));\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    /**\n     * @dev Returns if the token exists\n     * @param tokenId uint256 the id of the token\n     * @return exists bool if it exists\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /**\n     * @dev Mint the next token\n     * @param recipient address representing the owner of the new tokenId\n     * @return tokenId uint256 the new tokenId\n     */\n    function mint(address recipient)\n        public\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');\n        require(_msgSender() == minter, 'Not a minter');\n        uint256 tokenId = numMinted;\n        _safeMint(recipient, tokenId);\n        numMinted += 1;\n        return tokenId;\n    }\n\n    /**\n     * @notice I wouldn't if I were you\n     * @dev Burns the token\n     * @param tokenId uint256 representing the tokenId\n     */\n    function burn(uint256 tokenId) public virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            'ERC721Burnable: caller is not owner nor approved'\n        );\n        _burn(tokenId);\n    }\n\n    /**\n     * Only the owner can do these things\n     */\n\n    /**\n     * @dev Sets a new base URI\n     * @param newBaseURI string the new token base URI\n     */\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseTokenURI = newBaseURI;\n    }\n\n    /**\n     * @dev Sets a new primary minter address\n     * @param newMinter address of the new minter\n     */\n    function setMinter(address newMinter) public onlyOwner {\n        minter = newMinter;\n    }\n\n    /**\n     * @dev Sets provenance hash\n     * @param newHash string of the new minter\n     */\n    function setProvenanceHash(string memory newHash) public onlyOwner {\n        METADATA_PROVENANCE_HASH = newHash;\n    }\n\n    /**\n     * @dev Adds calldata on chain for the images. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadImage(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev Adds calldata on chain for the attributes. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadAttributes(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev ETH should not be sent to this contract, but in the case that it is\n     * sent by accident, this function allows the owner to withdraw it.\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(payable(msg.sender).send(address(this).balance));\n    }\n\n    /**\n     * @dev Again, ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\nimport './interfaces/IWETH.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the minter of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsMinter is Ownable, Pausable, ReentrancyGuard {\n    /// @notice The start timestamp for the Dutch Auction (DA) sale and price\n    uint256 public daStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for mintlisters\n    /// @dev This is the end of DA phase. No more DA bids when this is hit\n    uint256 public mintlistStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the public sale\n    uint256 public publicStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the claims\n    uint256 public claimsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for self refunds\n    uint256 public selfRefundsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The main Merkle root\n    bytes32 public mintlist1MerkleRoot;\n\n    /// @notice The secondary Merkle root\n    /// @dev Having a backup merkle root lets us atomically update the merkletree without downtime on the frontend\n    bytes32 public mintlist2MerkleRoot;\n\n    /// @notice The claimslist Merkle root\n    bytes32 public claimlistMerkleRoot;\n\n    /// @notice The address of the Warriors contract\n    IForgottenRunesWarriorsGuild public warriors;\n\n    /// @notice The address of the vault\n    address public vault;\n\n    /// @notice The address of the WETH contract\n    address public weth;\n\n    /// @notice The start price of the DA\n    uint256 public startPrice = 2.5 ether;\n\n    /// @notice The lowest price of the DA\n    uint256 public lowestPrice = 0.6 ether;\n\n    /// @notice The length of time for the price curve in the DA\n    uint256 public daPriceCurveLength = 380 minutes;\n\n    /// @notice The interval of time in which the price steps down\n    uint256 public daDropInterval = 10 minutes;\n\n    /// @notice The final price of the DA. Will be updated when DA is over and then used for subsequent phases\n    uint256 public finalPrice = 2.5 ether;\n\n    /// @notice An array of the addresses of the DA minters\n    /// @dev An entry is created for every da minting tx, so the same minter address is quite likely to appear more than once\n    address[] public daMinters;\n\n    /// @notice Tracks the total amount paid by a given address in the DA\n    mapping(address => uint256) public daAmountPaid;\n\n    /// @notice Tracks the total amount refunded to a given address for the DA\n    mapping(address => uint256) public daAmountRefunded;\n\n    /// @notice Tracks the total count of NFTs minted by a given address in the DA\n    mapping(address => uint256) public daNumMinted;\n\n    /// @notice Tracks if a given address minted in the mintlist\n    mapping(address => bool) public mintlistMinted;\n\n    /// @notice Tracks the total count of NFTs claimed by a given address\n    mapping(address => bool) public claimlistMinted;\n\n    /// @notice The total number of tokens reserved for the DA phase\n    uint256 public maxDaSupply = 8000;\n\n    /// @notice Tracks the total count of NFTs sold (vs. freebies)\n    uint256 public numSold;\n\n    /// @notice Tracks the total count of NFTs for sale\n    uint256 public maxForSale = 14190;\n\n    /// @notice Tracks the total count of NFTs claimed for free\n    uint256 public numClaimed;\n\n    /// @notice Tracks the total count of NFTs that can be claimed\n    /// @dev While we will have a merkle root set for this group, putting a hard cap helps limit the damage of any problems with an overly-generous merkle tree\n    uint256 public maxForClaim = 1100;\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param _warriors address the initial warriors contract address\n     */\n    constructor(IForgottenRunesWarriorsGuild _warriors, address _weth) {\n        setWarriorsAddress(_warriors);\n        setWethAddress(_weth);\n        setVaultAddress(msg.sender);\n    }\n\n    /*\n     * Timeline:\n     *\n     * bidSummon       : |------------|\n     * mintlistSummon  :              |------------|-------------------------------------|\n     * publicSummon    :                           |------------|------------------------|\n     * claimSummon     :                                        |------------|-----------|\n     * teamSummon      : |---------------------------------------------------------------|\n     */\n\n    /**\n     * @notice Mint a Warrior in the Dutch Auction phase\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function bidSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxDaSupply, 'Auction sold out');\n        require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\n        require(daStarted(), 'Auction not started');\n        require(!mintlistStarted(), 'Auction phase over');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n\n        uint256 currentPrice = currentDaPrice();\n        require(\n            msg.value >= (currentPrice * numWarriors),\n            'Ether value sent is not sufficient'\n        );\n\n        daMinters.push(msg.sender);\n        daAmountPaid[msg.sender] += msg.value;\n        daNumMinted[msg.sender] += numWarriors;\n        numSold += numWarriors;\n\n        if (numSold == maxDaSupply) {\n            // optimistic: save gas by not setting on every mint, but will\n            // require manual `setFinalPrice` before refunds if da falls short\n            finalPrice = currentPrice;\n        }\n\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @notice Mint a Warrior in the mintlist phase (paid)\n     * @param _merkleProof bytes32[] your proof of being able to mint\n     */\n    function mintlistSummon(bytes32[] calldata _merkleProof)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(mintlistStarted(), 'Mintlist phase not started');\n        require(msg.value == finalPrice, 'Ether value incorrect');\n\n        // verify didn't already mint\n        require(mintlistMinted[msg.sender] == false, 'Already minted');\n        mintlistMinted[msg.sender] = true;\n\n        // verify mintlist merkle\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, mintlist1MerkleRoot, node) ||\n                MerkleProof.verify(_merkleProof, mintlist2MerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numSold += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior in the Public phase (paid)\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function publicSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\n        require(publicStarted(), 'Public sale not started');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n        require(\n            msg.value == (finalPrice * numWarriors),\n            'Ether value sent is incorrect'\n        );\n\n        numSold += numWarriors;\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @dev claim a warrior for free if you're in the claimlist\n     * @param _merkleProof bytes32[] the proof that you're eligible to mint here\n     */\n    function claimSummon(bytes32[] calldata _merkleProof)\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        require(numClaimed < maxForClaim, 'No more claims');\n        require(claimsStarted(), 'Claim phase not started');\n\n        // verify didn't already claim\n        require(claimlistMinted[msg.sender] == false, 'Already claimed');\n        claimlistMinted[msg.sender] = true;\n\n        // verify claimlist\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, claimlistMerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numClaimed += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior (owner only)\n     * @param recipient address the address of the recipient\n     * @param count uint256 of the number of warriors you're trying to mint\n     */\n    function teamSummon(address recipient, uint256 count) external onlyOwner {\n        require(address(recipient) != address(0), 'address req');\n        for (uint256 i = 0; i < count; i++) {\n            _mint(recipient);\n        }\n    }\n\n    function _mint(address recipient) private {\n        warriors.mint(recipient);\n    }\n\n    /*\n     * View utilities\n     */\n\n    /**\n     * @notice returns the current dutch auction price\n     */\n    function currentDaPrice() public view returns (uint256) {\n        if (!daStarted()) {\n            return startPrice;\n        }\n        if (block.timestamp >= daStartTime + daPriceCurveLength) {\n            // end of the curve\n            return lowestPrice;\n        }\n\n        uint256 dropPerStep = (startPrice - lowestPrice) /\n            (daPriceCurveLength / daDropInterval);\n\n        uint256 elapsed = block.timestamp - daStartTime;\n        uint256 steps = elapsed / daDropInterval;\n        uint256 stepDeduction = steps * dropPerStep;\n\n        // don't go negative in the next step\n        if (stepDeduction > startPrice) {\n            return lowestPrice;\n        }\n        uint256 currentPrice = startPrice - stepDeduction;\n        return currentPrice > lowestPrice ? currentPrice : lowestPrice;\n    }\n\n    /**\n     * @notice returns whether the dutch auction has started\n     */\n    function daStarted() public view returns (bool) {\n        return block.timestamp > daStartTime;\n    }\n\n    /**\n     * @notice returns whether the mintlist has started\n     */\n    function mintlistStarted() public view returns (bool) {\n        return block.timestamp > mintlistStartTime;\n    }\n\n    /**\n     * @notice returns whether the public mint has started\n     */\n    function publicStarted() public view returns (bool) {\n        return block.timestamp > publicStartTime;\n    }\n\n    /**\n     * @notice returns whether the claims phase has started\n     */\n    function claimsStarted() public view returns (bool) {\n        return block.timestamp > claimsStartTime;\n    }\n\n    /**\n     * @notice returns whether self refunds phase has started\n     */\n    function selfRefundsStarted() public view returns (bool) {\n        return block.timestamp > selfRefundsStartTime;\n    }\n\n    /**\n     * @notice returns the number of minter addresses in the DA phase (includes duplicates)\n     */\n    function numDaMinters() public view returns (uint256) {\n        return daMinters.length;\n    }\n\n    /*\n     * Refund logic\n     */\n\n    /**\n     * @notice issues refunds for the accounts in minters between startIdx and endIdx inclusive\n     * @param startIdx uint256 the starting index of daMinters\n     * @param endIdx uint256 the ending index of daMinters, inclusive\n     */\n    function issueRefunds(uint256 startIdx, uint256 endIdx)\n        public\n        onlyOwner\n        nonReentrant\n    {\n        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n            _refundAddress(daMinters[i]);\n        }\n    }\n\n    /**\n     * @notice issues a refund for the address\n     * @param minter address the address to refund\n     */\n    function refundAddress(address minter) public onlyOwner nonReentrant {\n        _refundAddress(minter);\n    }\n\n    /**\n     * @notice refunds msg.sender what they're owed\n     */\n    function selfRefund() public nonReentrant {\n        require(selfRefundsStarted(), 'Self refund period not started');\n        _refundAddress(msg.sender);\n    }\n\n    function _refundAddress(address minter) private {\n        uint256 owed = refundOwed(minter);\n        if (owed > 0) {\n            daAmountRefunded[minter] += owed;\n            _safeTransferETHWithFallback(minter, owed);\n        }\n    }\n\n    /**\n     * @notice returns the amount owed the address\n     * @param minter address the address of the account that wants a refund\n     */\n    function refundOwed(address minter) public view returns (uint256) {\n        uint256 totalCostOfMints = finalPrice * daNumMinted[minter];\n        uint256 refundsPaidAlready = daAmountRefunded[minter];\n        return daAmountPaid[minter] - totalCostOfMints - refundsPaidAlready;\n    }\n\n    /**\n     * @notice Transfer ETH. If the ETH transfer fails, wrap the ETH and try send it as WETH.\n     * @param to account who to send the ETH or WETH to\n     * @param amount uint256 how much ETH or WETH to send\n     */\n    function _safeTransferETHWithFallback(address to, uint256 amount) internal {\n        if (!_safeTransferETH(to, amount)) {\n            IWETH(weth).deposit{value: amount}();\n            IERC20(weth).transfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer ETH and return the success status.\n     * @dev This function only forwards 30,000 gas to the callee.\n     * @param to account who to send the ETH to\n     * @param value uint256 how much ETH to send\n     */\n    function _safeTransferETH(address to, uint256 value)\n        internal\n        returns (bool)\n    {\n        (bool success, ) = to.call{value: value, gas: 30_000}(new bytes(0));\n        return success;\n    }\n\n    /*\n     * Only the owner can do these things\n     */\n\n    /**\n     * @notice pause the contract\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice unpause the contract\n     */\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice set the dutch auction start timestamp\n     */\n    function setDaStartTime(uint256 _newTime) public onlyOwner {\n        daStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the mintlist start timestamp\n     */\n    function setMintlistStartTime(uint256 _newTime) public onlyOwner {\n        mintlistStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the public sale start timestamp\n     */\n    function setPublicStartTime(uint256 _newTime) public onlyOwner {\n        publicStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the claims phase start timestamp\n     */\n    function setClaimsStartTime(uint256 _newTime) public onlyOwner {\n        claimsStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the self refund phase start timestamp\n     */\n    function setSelfRefundsStartTime(uint256 _newTime) public onlyOwner {\n        selfRefundsStartTime = _newTime;\n    }\n\n    /**\n     * @notice A convenient way to set all phase times at once\n     * @param newDaStartTime uint256 the dutch auction start time\n     * @param newMintlistStartTime uint256 the mintlst phase start time\n     * @param newPublicStartTime uint256 the public phase start time\n     * @param newClaimsStartTime uint256 the claims phase start time\n     */\n    function setPhaseTimes(\n        uint256 newDaStartTime,\n        uint256 newMintlistStartTime,\n        uint256 newPublicStartTime,\n        uint256 newClaimsStartTime\n    ) public onlyOwner {\n        // we put these checks here instead of in the setters themselves\n        // because they're just guardrails of the typical case\n        require(\n            newPublicStartTime >= newMintlistStartTime,\n            'Set public after mintlist'\n        );\n        require(\n            newClaimsStartTime >= newPublicStartTime,\n            'Set claims after public'\n        );\n        setDaStartTime(newDaStartTime);\n        setMintlistStartTime(newMintlistStartTime);\n        setPublicStartTime(newPublicStartTime);\n        setClaimsStartTime(newClaimsStartTime);\n    }\n\n    /**\n     * @notice set the merkle root for the mintlist phase\n     */\n    function setMintlist1MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist1MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the alternate merkle root for the mintlist phase\n     * @dev we have two because it lets us idempotently update the website without downtime\n     */\n    function setMintlist2MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist2MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the merkle root for the claimslist phase\n     */\n    function setClaimlistMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        claimlistMerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the vault address where the funds are withdrawn\n     */\n    function setVaultAddress(address _newVaultAddress) public onlyOwner {\n        vault = _newVaultAddress;\n    }\n\n    /**\n     * @notice set the warriors token address\n     */\n    function setWarriorsAddress(\n        IForgottenRunesWarriorsGuild _newWarriorsAddress\n    ) public onlyOwner {\n        warriors = _newWarriorsAddress;\n    }\n\n    /**\n     * @notice set the weth token address\n     */\n    function setWethAddress(address _newWethAddress) public onlyOwner {\n        weth = _newWethAddress;\n    }\n\n    /**\n     * @notice set the dutch auction start price\n     */\n    function setStartPrice(uint256 _newPrice) public onlyOwner {\n        startPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the dutch auction lowest price\n     */\n    function setLowestPrice(uint256 _newPrice) public onlyOwner {\n        lowestPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the length of time the dutch auction price should change\n     */\n    function setDaPriceCurveLength(uint256 _newTime) public onlyOwner {\n        daPriceCurveLength = _newTime;\n    }\n\n    /**\n     * @notice set how long it takes for the dutch auction to step down in price\n     */\n    function setDaDropInterval(uint256 _newTime) public onlyOwner {\n        daDropInterval = _newTime;\n    }\n\n    /**\n     * @notice set \"final\" price of the dutch auction\n     * @dev this is set automatically if the dutch-auction sells out, but needs to be set manually if the DA fails to sell out\n     */\n    function setFinalPrice(uint256 _newPrice) public onlyOwner {\n        finalPrice = _newPrice;\n    }\n\n    /**\n     * @notice the max supply available in the dutch auction\n     */\n    function setMaxDaSupply(uint256 _newSupply) public onlyOwner {\n        maxDaSupply = _newSupply;\n    }\n\n    /**\n     * @notice the total max supply available for sale in any phase\n     */\n    function setMaxForSale(uint256 _newSupply) public onlyOwner {\n        maxForSale = _newSupply;\n    }\n\n    /**\n     * @notice the max supply available in the claimlist\n     */\n    function setMaxForClaim(uint256 _newSupply) public onlyOwner {\n        maxForClaim = _newSupply;\n    }\n\n    /**\n     * @notice Withdraw funds to the vault\n     * @param _amount uint256 the amount to withdraw\n     */\n    function withdraw(uint256 _amount) public onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(_amount));\n    }\n\n    /**\n     * @notice Withdraw all funds to the vault\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(address(this).balance));\n    }\n\n    /**\n     * @dev ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ForgottenRunesWarriorsGuild.sol",
            "ForgottenRunesWarriorsMinter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ForgottenRunesWarriorsGuild.sol#L173-L176, ForgottenRunesWarriorsMinter.sol#L627-L630",
                "Type": "ERC20 token transfer vulnerability",
                "Description": "ERC20 tokens like USDT known for using non-standard ERC20 and the contract function forwardERC20 will always revert when trying to transfer this kind of tokens. Cannot withdraw some special ERC20 token through contract call.",
                "Repair": "Use SafeTransferLib.safeTransfer instead of IERC20 transfer"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\nimport './interfaces/IWETH.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the minter of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsMinter is Ownable, Pausable, ReentrancyGuard {\n    /// @notice The start timestamp for the Dutch Auction (DA) sale and price\n    uint256 public daStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for mintlisters\n    /// @dev This is the end of DA phase. No more DA bids when this is hit\n    uint256 public mintlistStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the public sale\n    uint256 public publicStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the claims\n    uint256 public claimsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for self refunds\n    uint256 public selfRefundsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The main Merkle root\n    bytes32 public mintlist1MerkleRoot;\n\n    /// @notice The secondary Merkle root\n    /// @dev Having a backup merkle root lets us atomically update the merkletree without downtime on the frontend\n    bytes32 public mintlist2MerkleRoot;\n\n    /// @notice The claimslist Merkle root\n    bytes32 public claimlistMerkleRoot;\n\n    /// @notice The address of the Warriors contract\n    IForgottenRunesWarriorsGuild public warriors;\n\n    /// @notice The address of the vault\n    address public vault;\n\n    /// @notice The address of the WETH contract\n    address public weth;\n\n    /// @notice The start price of the DA\n    uint256 public startPrice = 2.5 ether;\n\n    /// @notice The lowest price of the DA\n    uint256 public lowestPrice = 0.6 ether;\n\n    /// @notice The length of time for the price curve in the DA\n    uint256 public daPriceCurveLength = 380 minutes;\n\n    /// @notice The interval of time in which the price steps down\n    uint256 public daDropInterval = 10 minutes;\n\n    /// @notice The final price of the DA. Will be updated when DA is over and then used for subsequent phases\n    uint256 public finalPrice = 2.5 ether;\n\n    /// @notice An array of the addresses of the DA minters\n    /// @dev An entry is created for every da minting tx, so the same minter address is quite likely to appear more than once\n    address[] public daMinters;\n\n    /// @notice Tracks the total amount paid by a given address in the DA\n    mapping(address => uint256) public daAmountPaid;\n\n    /// @notice Tracks the total amount refunded to a given address for the DA\n    mapping(address => uint256) public daAmountRefunded;\n\n    /// @notice Tracks the total count of NFTs minted by a given address in the DA\n    mapping(address => uint256) public daNumMinted;\n\n    /// @notice Tracks if a given address minted in the mintlist\n    mapping(address => bool) public mintlistMinted;\n\n    /// @notice Tracks the total count of NFTs claimed by a given address\n    mapping(address => bool) public claimlistMinted;\n\n    /// @notice The total number of tokens reserved for the DA phase\n    uint256 public maxDaSupply = 8000;\n\n    /// @notice Tracks the total count of NFTs sold (vs. freebies)\n    uint256 public numSold;\n\n    /// @notice Tracks the total count of NFTs for sale\n    uint256 public maxForSale = 14190;\n\n    /// @notice Tracks the total count of NFTs claimed for free\n    uint256 public numClaimed;\n\n    /// @notice Tracks the total count of NFTs that can be claimed\n    /// @dev While we will have a merkle root set for this group, putting a hard cap helps limit the damage of any problems with an overly-generous merkle tree\n    uint256 public maxForClaim = 1100;\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param _warriors address the initial warriors contract address\n     */\n    constructor(IForgottenRunesWarriorsGuild _warriors, address _weth) {\n        setWarriorsAddress(_warriors);\n        setWethAddress(_weth);\n        setVaultAddress(msg.sender);\n    }\n\n    /*\n     * Timeline:\n     *\n     * bidSummon       : |------------|\n     * mintlistSummon  :              |------------|-------------------------------------|\n     * publicSummon    :                           |------------|------------------------|\n     * claimSummon     :                                        |------------|-----------|\n     * teamSummon      : |---------------------------------------------------------------|\n     */\n\n    /**\n     * @notice Mint a Warrior in the Dutch Auction phase\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function bidSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxDaSupply, 'Auction sold out');\n        require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\n        require(daStarted(), 'Auction not started');\n        require(!mintlistStarted(), 'Auction phase over');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n\n        uint256 currentPrice = currentDaPrice();\n        require(\n            msg.value >= (currentPrice * numWarriors),\n            'Ether value sent is not sufficient'\n        );\n\n        daMinters.push(msg.sender);\n        daAmountPaid[msg.sender] += msg.value;\n        daNumMinted[msg.sender] += numWarriors;\n        numSold += numWarriors;\n\n        if (numSold == maxDaSupply) {\n            // optimistic: save gas by not setting on every mint, but will\n            // require manual `setFinalPrice` before refunds if da falls short\n            finalPrice = currentPrice;\n        }\n\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @notice Mint a Warrior in the mintlist phase (paid)\n     * @param _merkleProof bytes32[] your proof of being able to mint\n     */\n    function mintlistSummon(bytes32[] calldata _merkleProof)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(mintlistStarted(), 'Mintlist phase not started');\n        require(msg.value == finalPrice, 'Ether value incorrect');\n\n        // verify didn't already mint\n        require(mintlistMinted[msg.sender] == false, 'Already minted');\n        mintlistMinted[msg.sender] = true;\n\n        // verify mintlist merkle\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, mintlist1MerkleRoot, node) ||\n                MerkleProof.verify(_merkleProof, mintlist2MerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numSold += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior in the Public phase (paid)\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function publicSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\n        require(publicStarted(), 'Public sale not started');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n        require(\n            msg.value == (finalPrice * numWarriors),\n            'Ether value sent is incorrect'\n        );\n\n        numSold += numWarriors;\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @dev claim a warrior for free if you're in the claimlist\n     * @param _merkleProof bytes32[] the proof that you're eligible to mint here\n     */\n    function claimSummon(bytes32[] calldata _merkleProof)\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        require(numClaimed < maxForClaim, 'No more claims');\n        require(claimsStarted(), 'Claim phase not started');\n\n        // verify didn't already claim\n        require(claimlistMinted[msg.sender] == false, 'Already claimed');\n        claimlistMinted[msg.sender] = true;\n\n        // verify claimlist\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, claimlistMerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numClaimed += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior (owner only)\n     * @param recipient address the address of the recipient\n     * @param count uint256 of the number of warriors you're trying to mint\n     */\n    function teamSummon(address recipient, uint256 count) external onlyOwner {\n        require(address(recipient) != address(0), 'address req');\n        for (uint256 i = 0; i < count; i++) {\n            _mint(recipient);\n        }\n    }\n\n    function _mint(address recipient) private {\n        warriors.mint(recipient);\n    }\n\n    /*\n     * View utilities\n     */\n\n    /**\n     * @notice returns the current dutch auction price\n     */\n    function currentDaPrice() public view returns (uint256) {\n        if (!daStarted()) {\n            return startPrice;\n        }\n        if (block.timestamp >= daStartTime + daPriceCurveLength) {\n            // end of the curve\n            return lowestPrice;\n        }\n\n        uint256 dropPerStep = (startPrice - lowestPrice) /\n            (daPriceCurveLength / daDropInterval);\n\n        uint256 elapsed = block.timestamp - daStartTime;\n        uint256 steps = elapsed / daDropInterval;\n        uint256 stepDeduction = steps * dropPerStep;\n\n        // don't go negative in the next step\n        if (stepDeduction > startPrice) {\n            return lowestPrice;\n        }\n        uint256 currentPrice = startPrice - stepDeduction;\n        return currentPrice > lowestPrice ? currentPrice : lowestPrice;\n    }\n\n    /**\n     * @notice returns whether the dutch auction has started\n     */\n    function daStarted() public view returns (bool) {\n        return block.timestamp > daStartTime;\n    }\n\n    /**\n     * @notice returns whether the mintlist has started\n     */\n    function mintlistStarted() public view returns (bool) {\n        return block.timestamp > mintlistStartTime;\n    }\n\n    /**\n     * @notice returns whether the public mint has started\n     */\n    function publicStarted() public view returns (bool) {\n        return block.timestamp > publicStartTime;\n    }\n\n    /**\n     * @notice returns whether the claims phase has started\n     */\n    function claimsStarted() public view returns (bool) {\n        return block.timestamp > claimsStartTime;\n    }\n\n    /**\n     * @notice returns whether self refunds phase has started\n     */\n    function selfRefundsStarted() public view returns (bool) {\n        return block.timestamp > selfRefundsStartTime;\n    }\n\n    /**\n     * @notice returns the number of minter addresses in the DA phase (includes duplicates)\n     */\n    function numDaMinters() public view returns (uint256) {\n        return daMinters.length;\n    }\n\n    /*\n     * Refund logic\n     */\n\n    /**\n     * @notice issues refunds for the accounts in minters between startIdx and endIdx inclusive\n     * @param startIdx uint256 the starting index of daMinters\n     * @param endIdx uint256 the ending index of daMinters, inclusive\n     */\n    function issueRefunds(uint256 startIdx, uint256 endIdx)\n        public\n        onlyOwner\n        nonReentrant\n    {\n        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n            _refundAddress(daMinters[i]);\n        }\n    }\n\n    /**\n     * @notice issues a refund for the address\n     * @param minter address the address to refund\n     */\n    function refundAddress(address minter) public onlyOwner nonReentrant {\n        _refundAddress(minter);\n    }\n\n    /**\n     * @notice refunds msg.sender what they're owed\n     */\n    function selfRefund() public nonReentrant {\n        require(selfRefundsStarted(), 'Self refund period not started');\n        _refundAddress(msg.sender);\n    }\n\n    function _refundAddress(address minter) private {\n        uint256 owed = refundOwed(minter);\n        if (owed > 0) {\n            daAmountRefunded[minter] += owed;\n            _safeTransferETHWithFallback(minter, owed);\n        }\n    }\n\n    /**\n     * @notice returns the amount owed the address\n     * @param minter address the address of the account that wants a refund\n     */\n    function refundOwed(address minter) public view returns (uint256) {\n        uint256 totalCostOfMints = finalPrice * daNumMinted[minter];\n        uint256 refundsPaidAlready = daAmountRefunded[minter];\n        return daAmountPaid[minter] - totalCostOfMints - refundsPaidAlready;\n    }\n\n    /**\n     * @notice Transfer ETH. If the ETH transfer fails, wrap the ETH and try send it as WETH.\n     * @param to account who to send the ETH or WETH to\n     * @param amount uint256 how much ETH or WETH to send\n     */\n    function _safeTransferETHWithFallback(address to, uint256 amount) internal {\n        if (!_safeTransferETH(to, amount)) {\n            IWETH(weth).deposit{value: amount}();\n            IERC20(weth).transfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer ETH and return the success status.\n     * @dev This function only forwards 30,000 gas to the callee.\n     * @param to account who to send the ETH to\n     * @param value uint256 how much ETH to send\n     */\n    function _safeTransferETH(address to, uint256 value)\n        internal\n        returns (bool)\n    {\n        (bool success, ) = to.call{value: value, gas: 30_000}(new bytes(0));\n        return success;\n    }\n\n    /*\n     * Only the owner can do these things\n     */\n\n    /**\n     * @notice pause the contract\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice unpause the contract\n     */\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice set the dutch auction start timestamp\n     */\n    function setDaStartTime(uint256 _newTime) public onlyOwner {\n        daStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the mintlist start timestamp\n     */\n    function setMintlistStartTime(uint256 _newTime) public onlyOwner {\n        mintlistStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the public sale start timestamp\n     */\n    function setPublicStartTime(uint256 _newTime) public onlyOwner {\n        publicStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the claims phase start timestamp\n     */\n    function setClaimsStartTime(uint256 _newTime) public onlyOwner {\n        claimsStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the self refund phase start timestamp\n     */\n    function setSelfRefundsStartTime(uint256 _newTime) public onlyOwner {\n        selfRefundsStartTime = _newTime;\n    }\n\n    /**\n     * @notice A convenient way to set all phase times at once\n     * @param newDaStartTime uint256 the dutch auction start time\n     * @param newMintlistStartTime uint256 the mintlst phase start time\n     * @param newPublicStartTime uint256 the public phase start time\n     * @param newClaimsStartTime uint256 the claims phase start time\n     */\n    function setPhaseTimes(\n        uint256 newDaStartTime,\n        uint256 newMintlistStartTime,\n        uint256 newPublicStartTime,\n        uint256 newClaimsStartTime\n    ) public onlyOwner {\n        // we put these checks here instead of in the setters themselves\n        // because they're just guardrails of the typical case\n        require(\n            newPublicStartTime >= newMintlistStartTime,\n            'Set public after mintlist'\n        );\n        require(\n            newClaimsStartTime >= newPublicStartTime,\n            'Set claims after public'\n        );\n        setDaStartTime(newDaStartTime);\n        setMintlistStartTime(newMintlistStartTime);\n        setPublicStartTime(newPublicStartTime);\n        setClaimsStartTime(newClaimsStartTime);\n    }\n\n    /**\n     * @notice set the merkle root for the mintlist phase\n     */\n    function setMintlist1MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist1MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the alternate merkle root for the mintlist phase\n     * @dev we have two because it lets us idempotently update the website without downtime\n     */\n    function setMintlist2MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist2MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the merkle root for the claimslist phase\n     */\n    function setClaimlistMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        claimlistMerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the vault address where the funds are withdrawn\n     */\n    function setVaultAddress(address _newVaultAddress) public onlyOwner {\n        vault = _newVaultAddress;\n    }\n\n    /**\n     * @notice set the warriors token address\n     */\n    function setWarriorsAddress(\n        IForgottenRunesWarriorsGuild _newWarriorsAddress\n    ) public onlyOwner {\n        warriors = _newWarriorsAddress;\n    }\n\n    /**\n     * @notice set the weth token address\n     */\n    function setWethAddress(address _newWethAddress) public onlyOwner {\n        weth = _newWethAddress;\n    }\n\n    /**\n     * @notice set the dutch auction start price\n     */\n    function setStartPrice(uint256 _newPrice) public onlyOwner {\n        startPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the dutch auction lowest price\n     */\n    function setLowestPrice(uint256 _newPrice) public onlyOwner {\n        lowestPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the length of time the dutch auction price should change\n     */\n    function setDaPriceCurveLength(uint256 _newTime) public onlyOwner {\n        daPriceCurveLength = _newTime;\n    }\n\n    /**\n     * @notice set how long it takes for the dutch auction to step down in price\n     */\n    function setDaDropInterval(uint256 _newTime) public onlyOwner {\n        daDropInterval = _newTime;\n    }\n\n    /**\n     * @notice set \"final\" price of the dutch auction\n     * @dev this is set automatically if the dutch-auction sells out, but needs to be set manually if the DA fails to sell out\n     */\n    function setFinalPrice(uint256 _newPrice) public onlyOwner {\n        finalPrice = _newPrice;\n    }\n\n    /**\n     * @notice the max supply available in the dutch auction\n     */\n    function setMaxDaSupply(uint256 _newSupply) public onlyOwner {\n        maxDaSupply = _newSupply;\n    }\n\n    /**\n     * @notice the total max supply available for sale in any phase\n     */\n    function setMaxForSale(uint256 _newSupply) public onlyOwner {\n        maxForSale = _newSupply;\n    }\n\n    /**\n     * @notice the max supply available in the claimlist\n     */\n    function setMaxForClaim(uint256 _newSupply) public onlyOwner {\n        maxForClaim = _newSupply;\n    }\n\n    /**\n     * @notice Withdraw funds to the vault\n     * @param _amount uint256 the amount to withdraw\n     */\n    function withdraw(uint256 _amount) public onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(_amount));\n    }\n\n    /**\n     * @notice Withdraw all funds to the vault\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(address(this).balance));\n    }\n\n    /**\n     * @dev ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ForgottenRunesWarriorsMinter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ForgottenRunesWarriorsMinter.sol#L275-L297",
                "Type": "Unbounded and under-constrained variables",
                "Description": "Many unbounded and under-constrained variables in the system can lead to unfair price or DoS. The team can change the variables during sale, which can result in the wrong sale phases order.",
                "Repair": "Bound and constrain variables"
            },
            {
                "Location": "ForgottenRunesWarriorsMinter.sol#L564, ForgottenRunesWarriorsMinter.sol#L571, ForgottenRunesWarriorsMinter.sol#L557, ForgottenRunesWarriorsMinter.sol#L571",
                "Type": "Critical variables change vulnerability",
                "Description": "The price for the dutch auction could be altered. Changing the Start Price or the Lowest price in the middle of the auction could allow the owner to manipulate the price.",
                "Repair": "Add require (variable == 0) to ensure they are set once in a permanent way"
            },
            {
                "Location": "ForgottenRunesWarriorsMinter.sol#L616-L619",
                "Type": "Insufficient fund vulnerability",
                "Description": "Owner of the contract can call withdrawAll before the refund process is done to send all ETH to the vault. Since there are no payable receive function in ForgottenRunesWarriorsMinter, the owner won't be able to replenish the contract for the refund process.",
                "Repair": "Only allow owner to call withdrawAll after refund period"
            },
            {
                "Location": "ForgottenRunesWarriorsMinter.teamSummon()",
                "Type": "Unrestricted minting of NFTs",
                "Description": "The owner can mint an unrestricted amount of NFTs, which poses a risk in case of private key compromise. The suggested fix is to limit the number of NFTs that the owner can mint.",
                "Repair": "Limit the number of NFTs that the owner can mint to prevent potential damage in case of private key compromise"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\nimport './interfaces/IWETH.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the minter of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsMinter is Ownable, Pausable, ReentrancyGuard {\n    /// @notice The start timestamp for the Dutch Auction (DA) sale and price\n    uint256 public daStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for mintlisters\n    /// @dev This is the end of DA phase. No more DA bids when this is hit\n    uint256 public mintlistStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the public sale\n    uint256 public publicStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for the claims\n    uint256 public claimsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The start timestamp for self refunds\n    uint256 public selfRefundsStartTime =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice The main Merkle root\n    bytes32 public mintlist1MerkleRoot;\n\n    /// @notice The secondary Merkle root\n    /// @dev Having a backup merkle root lets us atomically update the merkletree without downtime on the frontend\n    bytes32 public mintlist2MerkleRoot;\n\n    /// @notice The claimslist Merkle root\n    bytes32 public claimlistMerkleRoot;\n\n    /// @notice The address of the Warriors contract\n    IForgottenRunesWarriorsGuild public warriors;\n\n    /// @notice The address of the vault\n    address public vault;\n\n    /// @notice The address of the WETH contract\n    address public weth;\n\n    /// @notice The start price of the DA\n    uint256 public startPrice = 2.5 ether;\n\n    /// @notice The lowest price of the DA\n    uint256 public lowestPrice = 0.6 ether;\n\n    /// @notice The length of time for the price curve in the DA\n    uint256 public daPriceCurveLength = 380 minutes;\n\n    /// @notice The interval of time in which the price steps down\n    uint256 public daDropInterval = 10 minutes;\n\n    /// @notice The final price of the DA. Will be updated when DA is over and then used for subsequent phases\n    uint256 public finalPrice = 2.5 ether;\n\n    /// @notice An array of the addresses of the DA minters\n    /// @dev An entry is created for every da minting tx, so the same minter address is quite likely to appear more than once\n    address[] public daMinters;\n\n    /// @notice Tracks the total amount paid by a given address in the DA\n    mapping(address => uint256) public daAmountPaid;\n\n    /// @notice Tracks the total amount refunded to a given address for the DA\n    mapping(address => uint256) public daAmountRefunded;\n\n    /// @notice Tracks the total count of NFTs minted by a given address in the DA\n    mapping(address => uint256) public daNumMinted;\n\n    /// @notice Tracks if a given address minted in the mintlist\n    mapping(address => bool) public mintlistMinted;\n\n    /// @notice Tracks the total count of NFTs claimed by a given address\n    mapping(address => bool) public claimlistMinted;\n\n    /// @notice The total number of tokens reserved for the DA phase\n    uint256 public maxDaSupply = 8000;\n\n    /// @notice Tracks the total count of NFTs sold (vs. freebies)\n    uint256 public numSold;\n\n    /// @notice Tracks the total count of NFTs for sale\n    uint256 public maxForSale = 14190;\n\n    /// @notice Tracks the total count of NFTs claimed for free\n    uint256 public numClaimed;\n\n    /// @notice Tracks the total count of NFTs that can be claimed\n    /// @dev While we will have a merkle root set for this group, putting a hard cap helps limit the damage of any problems with an overly-generous merkle tree\n    uint256 public maxForClaim = 1100;\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param _warriors address the initial warriors contract address\n     */\n    constructor(IForgottenRunesWarriorsGuild _warriors, address _weth) {\n        setWarriorsAddress(_warriors);\n        setWethAddress(_weth);\n        setVaultAddress(msg.sender);\n    }\n\n    /*\n     * Timeline:\n     *\n     * bidSummon       : |------------|\n     * mintlistSummon  :              |------------|-------------------------------------|\n     * publicSummon    :                           |------------|------------------------|\n     * claimSummon     :                                        |------------|-----------|\n     * teamSummon      : |---------------------------------------------------------------|\n     */\n\n    /**\n     * @notice Mint a Warrior in the Dutch Auction phase\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function bidSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxDaSupply, 'Auction sold out');\n        require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\n        require(daStarted(), 'Auction not started');\n        require(!mintlistStarted(), 'Auction phase over');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n\n        uint256 currentPrice = currentDaPrice();\n        require(\n            msg.value >= (currentPrice * numWarriors),\n            'Ether value sent is not sufficient'\n        );\n\n        daMinters.push(msg.sender);\n        daAmountPaid[msg.sender] += msg.value;\n        daNumMinted[msg.sender] += numWarriors;\n        numSold += numWarriors;\n\n        if (numSold == maxDaSupply) {\n            // optimistic: save gas by not setting on every mint, but will\n            // require manual `setFinalPrice` before refunds if da falls short\n            finalPrice = currentPrice;\n        }\n\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @notice Mint a Warrior in the mintlist phase (paid)\n     * @param _merkleProof bytes32[] your proof of being able to mint\n     */\n    function mintlistSummon(bytes32[] calldata _merkleProof)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(mintlistStarted(), 'Mintlist phase not started');\n        require(msg.value == finalPrice, 'Ether value incorrect');\n\n        // verify didn't already mint\n        require(mintlistMinted[msg.sender] == false, 'Already minted');\n        mintlistMinted[msg.sender] = true;\n\n        // verify mintlist merkle\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, mintlist1MerkleRoot, node) ||\n                MerkleProof.verify(_merkleProof, mintlist2MerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numSold += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior in the Public phase (paid)\n     * @param numWarriors uint256 of the number of warriors you're trying to mint\n     */\n    function publicSummon(uint256 numWarriors)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        require(numSold < maxForSale, 'Sold out');\n        require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\n        require(publicStarted(), 'Public sale not started');\n        require(\n            numWarriors > 0 && numWarriors <= 20,\n            'You can summon no more than 20 Warriors at a time'\n        );\n        require(\n            msg.value == (finalPrice * numWarriors),\n            'Ether value sent is incorrect'\n        );\n\n        numSold += numWarriors;\n        for (uint256 i = 0; i < numWarriors; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    /**\n     * @dev claim a warrior for free if you're in the claimlist\n     * @param _merkleProof bytes32[] the proof that you're eligible to mint here\n     */\n    function claimSummon(bytes32[] calldata _merkleProof)\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        require(numClaimed < maxForClaim, 'No more claims');\n        require(claimsStarted(), 'Claim phase not started');\n\n        // verify didn't already claim\n        require(claimlistMinted[msg.sender] == false, 'Already claimed');\n        claimlistMinted[msg.sender] = true;\n\n        // verify claimlist\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, claimlistMerkleRoot, node),\n            'Invalid proof'\n        );\n\n        numClaimed += 1;\n        _mint(msg.sender);\n    }\n\n    /**\n     * @notice Mint a Warrior (owner only)\n     * @param recipient address the address of the recipient\n     * @param count uint256 of the number of warriors you're trying to mint\n     */\n    function teamSummon(address recipient, uint256 count) external onlyOwner {\n        require(address(recipient) != address(0), 'address req');\n        for (uint256 i = 0; i < count; i++) {\n            _mint(recipient);\n        }\n    }\n\n    function _mint(address recipient) private {\n        warriors.mint(recipient);\n    }\n\n    /*\n     * View utilities\n     */\n\n    /**\n     * @notice returns the current dutch auction price\n     */\n    function currentDaPrice() public view returns (uint256) {\n        if (!daStarted()) {\n            return startPrice;\n        }\n        if (block.timestamp >= daStartTime + daPriceCurveLength) {\n            // end of the curve\n            return lowestPrice;\n        }\n\n        uint256 dropPerStep = (startPrice - lowestPrice) /\n            (daPriceCurveLength / daDropInterval);\n\n        uint256 elapsed = block.timestamp - daStartTime;\n        uint256 steps = elapsed / daDropInterval;\n        uint256 stepDeduction = steps * dropPerStep;\n\n        // don't go negative in the next step\n        if (stepDeduction > startPrice) {\n            return lowestPrice;\n        }\n        uint256 currentPrice = startPrice - stepDeduction;\n        return currentPrice > lowestPrice ? currentPrice : lowestPrice;\n    }\n\n    /**\n     * @notice returns whether the dutch auction has started\n     */\n    function daStarted() public view returns (bool) {\n        return block.timestamp > daStartTime;\n    }\n\n    /**\n     * @notice returns whether the mintlist has started\n     */\n    function mintlistStarted() public view returns (bool) {\n        return block.timestamp > mintlistStartTime;\n    }\n\n    /**\n     * @notice returns whether the public mint has started\n     */\n    function publicStarted() public view returns (bool) {\n        return block.timestamp > publicStartTime;\n    }\n\n    /**\n     * @notice returns whether the claims phase has started\n     */\n    function claimsStarted() public view returns (bool) {\n        return block.timestamp > claimsStartTime;\n    }\n\n    /**\n     * @notice returns whether self refunds phase has started\n     */\n    function selfRefundsStarted() public view returns (bool) {\n        return block.timestamp > selfRefundsStartTime;\n    }\n\n    /**\n     * @notice returns the number of minter addresses in the DA phase (includes duplicates)\n     */\n    function numDaMinters() public view returns (uint256) {\n        return daMinters.length;\n    }\n\n    /*\n     * Refund logic\n     */\n\n    /**\n     * @notice issues refunds for the accounts in minters between startIdx and endIdx inclusive\n     * @param startIdx uint256 the starting index of daMinters\n     * @param endIdx uint256 the ending index of daMinters, inclusive\n     */\n    function issueRefunds(uint256 startIdx, uint256 endIdx)\n        public\n        onlyOwner\n        nonReentrant\n    {\n        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n            _refundAddress(daMinters[i]);\n        }\n    }\n\n    /**\n     * @notice issues a refund for the address\n     * @param minter address the address to refund\n     */\n    function refundAddress(address minter) public onlyOwner nonReentrant {\n        _refundAddress(minter);\n    }\n\n    /**\n     * @notice refunds msg.sender what they're owed\n     */\n    function selfRefund() public nonReentrant {\n        require(selfRefundsStarted(), 'Self refund period not started');\n        _refundAddress(msg.sender);\n    }\n\n    function _refundAddress(address minter) private {\n        uint256 owed = refundOwed(minter);\n        if (owed > 0) {\n            daAmountRefunded[minter] += owed;\n            _safeTransferETHWithFallback(minter, owed);\n        }\n    }\n\n    /**\n     * @notice returns the amount owed the address\n     * @param minter address the address of the account that wants a refund\n     */\n    function refundOwed(address minter) public view returns (uint256) {\n        uint256 totalCostOfMints = finalPrice * daNumMinted[minter];\n        uint256 refundsPaidAlready = daAmountRefunded[minter];\n        return daAmountPaid[minter] - totalCostOfMints - refundsPaidAlready;\n    }\n\n    /**\n     * @notice Transfer ETH. If the ETH transfer fails, wrap the ETH and try send it as WETH.\n     * @param to account who to send the ETH or WETH to\n     * @param amount uint256 how much ETH or WETH to send\n     */\n    function _safeTransferETHWithFallback(address to, uint256 amount) internal {\n        if (!_safeTransferETH(to, amount)) {\n            IWETH(weth).deposit{value: amount}();\n            IERC20(weth).transfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer ETH and return the success status.\n     * @dev This function only forwards 30,000 gas to the callee.\n     * @param to account who to send the ETH to\n     * @param value uint256 how much ETH to send\n     */\n    function _safeTransferETH(address to, uint256 value)\n        internal\n        returns (bool)\n    {\n        (bool success, ) = to.call{value: value, gas: 30_000}(new bytes(0));\n        return success;\n    }\n\n    /*\n     * Only the owner can do these things\n     */\n\n    /**\n     * @notice pause the contract\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice unpause the contract\n     */\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice set the dutch auction start timestamp\n     */\n    function setDaStartTime(uint256 _newTime) public onlyOwner {\n        daStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the mintlist start timestamp\n     */\n    function setMintlistStartTime(uint256 _newTime) public onlyOwner {\n        mintlistStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the public sale start timestamp\n     */\n    function setPublicStartTime(uint256 _newTime) public onlyOwner {\n        publicStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the claims phase start timestamp\n     */\n    function setClaimsStartTime(uint256 _newTime) public onlyOwner {\n        claimsStartTime = _newTime;\n    }\n\n    /**\n     * @notice set the self refund phase start timestamp\n     */\n    function setSelfRefundsStartTime(uint256 _newTime) public onlyOwner {\n        selfRefundsStartTime = _newTime;\n    }\n\n    /**\n     * @notice A convenient way to set all phase times at once\n     * @param newDaStartTime uint256 the dutch auction start time\n     * @param newMintlistStartTime uint256 the mintlst phase start time\n     * @param newPublicStartTime uint256 the public phase start time\n     * @param newClaimsStartTime uint256 the claims phase start time\n     */\n    function setPhaseTimes(\n        uint256 newDaStartTime,\n        uint256 newMintlistStartTime,\n        uint256 newPublicStartTime,\n        uint256 newClaimsStartTime\n    ) public onlyOwner {\n        // we put these checks here instead of in the setters themselves\n        // because they're just guardrails of the typical case\n        require(\n            newPublicStartTime >= newMintlistStartTime,\n            'Set public after mintlist'\n        );\n        require(\n            newClaimsStartTime >= newPublicStartTime,\n            'Set claims after public'\n        );\n        setDaStartTime(newDaStartTime);\n        setMintlistStartTime(newMintlistStartTime);\n        setPublicStartTime(newPublicStartTime);\n        setClaimsStartTime(newClaimsStartTime);\n    }\n\n    /**\n     * @notice set the merkle root for the mintlist phase\n     */\n    function setMintlist1MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist1MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the alternate merkle root for the mintlist phase\n     * @dev we have two because it lets us idempotently update the website without downtime\n     */\n    function setMintlist2MerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        mintlist2MerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the merkle root for the claimslist phase\n     */\n    function setClaimlistMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        claimlistMerkleRoot = newMerkleRoot;\n    }\n\n    /**\n     * @notice set the vault address where the funds are withdrawn\n     */\n    function setVaultAddress(address _newVaultAddress) public onlyOwner {\n        vault = _newVaultAddress;\n    }\n\n    /**\n     * @notice set the warriors token address\n     */\n    function setWarriorsAddress(\n        IForgottenRunesWarriorsGuild _newWarriorsAddress\n    ) public onlyOwner {\n        warriors = _newWarriorsAddress;\n    }\n\n    /**\n     * @notice set the weth token address\n     */\n    function setWethAddress(address _newWethAddress) public onlyOwner {\n        weth = _newWethAddress;\n    }\n\n    /**\n     * @notice set the dutch auction start price\n     */\n    function setStartPrice(uint256 _newPrice) public onlyOwner {\n        startPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the dutch auction lowest price\n     */\n    function setLowestPrice(uint256 _newPrice) public onlyOwner {\n        lowestPrice = _newPrice;\n    }\n\n    /**\n     * @notice set the length of time the dutch auction price should change\n     */\n    function setDaPriceCurveLength(uint256 _newTime) public onlyOwner {\n        daPriceCurveLength = _newTime;\n    }\n\n    /**\n     * @notice set how long it takes for the dutch auction to step down in price\n     */\n    function setDaDropInterval(uint256 _newTime) public onlyOwner {\n        daDropInterval = _newTime;\n    }\n\n    /**\n     * @notice set \"final\" price of the dutch auction\n     * @dev this is set automatically if the dutch-auction sells out, but needs to be set manually if the DA fails to sell out\n     */\n    function setFinalPrice(uint256 _newPrice) public onlyOwner {\n        finalPrice = _newPrice;\n    }\n\n    /**\n     * @notice the max supply available in the dutch auction\n     */\n    function setMaxDaSupply(uint256 _newSupply) public onlyOwner {\n        maxDaSupply = _newSupply;\n    }\n\n    /**\n     * @notice the total max supply available for sale in any phase\n     */\n    function setMaxForSale(uint256 _newSupply) public onlyOwner {\n        maxForSale = _newSupply;\n    }\n\n    /**\n     * @notice the max supply available in the claimlist\n     */\n    function setMaxForClaim(uint256 _newSupply) public onlyOwner {\n        maxForClaim = _newSupply;\n    }\n\n    /**\n     * @notice Withdraw funds to the vault\n     * @param _amount uint256 the amount to withdraw\n     */\n    function withdraw(uint256 _amount) public onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(_amount));\n    }\n\n    /**\n     * @notice Withdraw all funds to the vault\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(address(this).balance));\n    }\n\n    /**\n     * @dev ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the tokens of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsGuild is\n    IForgottenRunesWarriorsGuild,\n    Ownable,\n    ReentrancyGuard,\n    ERC721\n{\n    using Strings for uint256;\n\n    /// @notice The maximum number of Warriors\n    uint256 public constant MAX_WARRIORS = 16000;\n\n    /// @notice Counter to track the number minted so far\n    uint256 public numMinted = 0;\n\n    /// @notice Address of the minter\n    address public minter;\n\n    /// @notice The base URI for the metadata of the tokens\n    string public baseTokenURI;\n\n    string public constant R =\n        \"Old men forget: yet all shall be forgot, But he'll remember with advantages What feats he did that day: then shall our names Familiar in his mouth as household words. This story shall the good man teach his son From this day to the ending of the world\";\n\n    /// @notice The provenance hash\n    string public METADATA_PROVENANCE_HASH = '';\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param baseURI string the initial base URI for the token metadata URL\n     */\n    constructor(string memory baseURI)\n        ERC721('ForgottenRunesWarriorsGuild', 'WARRIORS')\n    {\n        setBaseURI(baseURI);\n    }\n\n    /**\n     * @dev Convenient way to initialize the contract\n     * @param newMinter address of the minter contract\n     */\n    function initialize(address newMinter) public onlyOwner {\n        setMinter(newMinter);\n    }\n\n    /**\n     * @dev Returns the URL of a given tokenId\n     * @param tokenId uint256 ID of the token to be minted\n     * @return string the URL of a given tokenId\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            'ERC721Metadata: URI query for nonexistent token'\n        );\n\n        return string(abi.encodePacked(baseTokenURI, tokenId.toString()));\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    /**\n     * @dev Returns if the token exists\n     * @param tokenId uint256 the id of the token\n     * @return exists bool if it exists\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /**\n     * @dev Mint the next token\n     * @param recipient address representing the owner of the new tokenId\n     * @return tokenId uint256 the new tokenId\n     */\n    function mint(address recipient)\n        public\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');\n        require(_msgSender() == minter, 'Not a minter');\n        uint256 tokenId = numMinted;\n        _safeMint(recipient, tokenId);\n        numMinted += 1;\n        return tokenId;\n    }\n\n    /**\n     * @notice I wouldn't if I were you\n     * @dev Burns the token\n     * @param tokenId uint256 representing the tokenId\n     */\n    function burn(uint256 tokenId) public virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            'ERC721Burnable: caller is not owner nor approved'\n        );\n        _burn(tokenId);\n    }\n\n    /**\n     * Only the owner can do these things\n     */\n\n    /**\n     * @dev Sets a new base URI\n     * @param newBaseURI string the new token base URI\n     */\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseTokenURI = newBaseURI;\n    }\n\n    /**\n     * @dev Sets a new primary minter address\n     * @param newMinter address of the new minter\n     */\n    function setMinter(address newMinter) public onlyOwner {\n        minter = newMinter;\n    }\n\n    /**\n     * @dev Sets provenance hash\n     * @param newHash string of the new minter\n     */\n    function setProvenanceHash(string memory newHash) public onlyOwner {\n        METADATA_PROVENANCE_HASH = newHash;\n    }\n\n    /**\n     * @dev Adds calldata on chain for the images. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadImage(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev Adds calldata on chain for the attributes. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadAttributes(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev ETH should not be sent to this contract, but in the case that it is\n     * sent by accident, this function allows the owner to withdraw it.\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(payable(msg.sender).send(address(this).balance));\n    }\n\n    /**\n     * @dev Again, ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ForgottenRunesWarriorsMinter.sol",
            "ForgottenRunesWarriorsGuild.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ForgottenRunesWarriorsMinter.sol#L610, ForgottenRunesWarriorsMinter.sol#L618, ForgottenRunesWarriorsGuild.sol#L164",
                "Type": "Use of .send() vulnerability",
                "Description": "The .send() function intends to transfer an ETH amount with a fixed amount of 2300 gas. This function is not equipped to handle changes in the underlying .send() and .transfer() functions which may supply different amounts of gas in the future.",
                "Repair": "Consider using .call() instead with the checks-effects-interactions pattern implemented correctly"
            }
        ]
    }
]