[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function _createComment(DataTypes.CommentData memory vars) internal",
                "Type": "Reentrancy",
                "Description": "An attacker is able to emit a comment containing some information that does not match the actual information of a post, allowing him/her to trick light clients into responding to a post that they otherwise would have avoided. The attacker can use this to propagate scams, serve malware, or otherwise poison other user's profiles with unwanted content.",
                "Repair": "Store the new pubCount in a variable before the comment is created and use it during the creation rather than choosing it afterwards."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {Helpers} from './Helpers.sol';\nimport {DataTypes} from './DataTypes.sol';\nimport {Errors} from './Errors.sol';\nimport {Events} from './Events.sol';\nimport {Constants} from './Constants.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ICollectModule} from '../interfaces/ICollectModule.sol';\nimport {IReferenceModule} from '../interfaces/IReferenceModule.sol';\n\n/**\n * @title PublishingLogic\n * @author Lens Protocol\n *\n * @notice This is the library that contains the logic for profile creation & publication.\n *\n * @dev The functions are external, so they are called from the hub via `delegateCall` under the hood. Furthermore,\n * expected events are emitted from this library instead of from the hub to alleviate code size concerns.\n */\nlibrary PublishingLogic {\n    /**\n     * @notice Executes the logic to create a profile with the given parameters to the given address.\n     *\n     * @param vars The CreateProfileData struct containing the following parameters:\n     *      to: The address receiving the profile.\n     *      handle: The handle to set for the profile, must be unique and non-empty.\n     *      imageURI: The URI to set for the profile image.\n     *      followModule: The follow module to use, can be the zero address.\n     *      followModuleData: The follow module initialization data, if any\n     *      followNFTURI: The URI to set for the follow NFT.\n     * @param profileId The profile ID to associate with this profile NFT (token ID).\n     * @param _profileIdByHandleHash The storage reference to the mapping of profile IDs by handle hash.\n     * @param _profileById The storage reference to the mapping of profile structs by IDs.\n     * @param _followModuleWhitelisted The storage reference to the mapping of whitelist status by follow module address.\n     */\n    function createProfile(\n        DataTypes.CreateProfileData calldata vars,\n        uint256 profileId,\n        mapping(bytes32 => uint256) storage _profileIdByHandleHash,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,\n        mapping(address => bool) storage _followModuleWhitelisted\n    ) external {\n        _validateHandle(vars.handle);\n\n        bytes32 handleHash = keccak256(bytes(vars.handle));\n\n        if (_profileIdByHandleHash[handleHash] != 0) revert Errors.HandleTaken();\n        _profileIdByHandleHash[handleHash] = profileId;\n\n        _profileById[profileId].handle = vars.handle;\n        _profileById[profileId].imageURI = vars.imageURI;\n        _profileById[profileId].followNFTURI = vars.followNFTURI;\n\n        if (vars.followModule != address(0)) {\n            _profileById[profileId].followModule = vars.followModule;\n        }\n\n        bytes memory followModuleReturnData = _initFollowModule(\n            profileId,\n            vars.followModule,\n            vars.followModuleData,\n            _followModuleWhitelisted\n        );\n\n        _emitProfileCreated(profileId, vars, followModuleReturnData);\n    }\n\n    /**\n     * @notice Sets the follow module for a given profile.\n     *\n     * @param profileId The profile ID to set the follow module for.\n     * @param followModule The follow module to set for the given profile, if any.\n     * @param followModuleData The data to pass to the follow module for profile initialization.\n     * @param _profile The storage reference to the profile struct associated with the given profile ID.\n     * @param _followModuleWhitelisted The storage reference to the mapping of whitelist status by follow module address.\n     */\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleData,\n        DataTypes.ProfileStruct storage _profile,\n        mapping(address => bool) storage _followModuleWhitelisted\n    ) external {\n        address prevFollowModule = _profile.followModule;\n        if (followModule != prevFollowModule) {\n            _profile.followModule = followModule;\n        }\n\n        bytes memory followModuleReturnData = _initFollowModule(\n            profileId,\n            followModule,\n            followModuleData,\n            _followModuleWhitelisted\n        );\n        emit Events.FollowModuleSet(\n            profileId,\n            followModule,\n            followModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Creates a post publication mapped to the given profile.\n     *\n     * @dev To avoid a stack too deep error, reference parameters are passed in memory rather than calldata.\n     *\n     * @param profileId The profile ID to associate this publication to.\n     * @param contentURI The URI to set for this publication.\n     * @param collectModule The collect module to set for this publication.\n     * @param collectModuleData The data to pass to the collect module for publication initialization.\n     * @param referenceModule The reference module to set for this publication, if any.\n     * @param referenceModuleData The data to pass to the reference module for publication initialization.\n     * @param pubId The publication ID to associate with this publication.\n     * @param _pubByIdByProfile The storage reference to the mapping of publications by publication ID by profile ID.\n     * @param _collectModuleWhitelisted The storage reference to the mapping of whitelist status by collect module address.\n     * @param _referenceModuleWhitelisted The storage reference to the mapping of whitelist status by reference module address.\n     */\n    function createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData,\n        uint256 pubId,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _collectModuleWhitelisted,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) external {\n        _pubByIdByProfile[profileId][pubId].contentURI = contentURI;\n\n        // Collect module initialization\n        bytes memory collectModuleReturnData = _initPubCollectModule(\n            profileId,\n            pubId,\n            collectModule,\n            collectModuleData,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted\n        );\n\n        // Reference module initialization\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            profileId,\n            pubId,\n            referenceModule,\n            referenceModuleData,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n\n        emit Events.PostCreated(\n            profileId,\n            pubId,\n            contentURI,\n            collectModule,\n            collectModuleReturnData,\n            referenceModule,\n            referenceModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Creates a comment publication mapped to the given profile.\n     *\n     * @dev This function is unique in that it requires many variables, so, unlike the other publishing functions,\n     * we need to pass the full CommentData struct in memory to avoid a stack too deep error.\n     *\n     * @param vars The CommentData struct to use to create the comment.\n     * @param pubId The publication ID to associate with this publication.\n     * @param _profileById The storage reference to the mapping of profile structs by IDs.\n     * @param _pubByIdByProfile The storage reference to the mapping of publications by publication ID by profile ID.\n     * @param _collectModuleWhitelisted The storage reference to the mapping of whitelist status by collect module address.\n     * @param _referenceModuleWhitelisted The storage reference to the mapping of whitelist status by reference module address.\n     */\n    function createComment(\n        DataTypes.CommentData memory vars,\n        uint256 pubId,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _collectModuleWhitelisted,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) external {\n        // Validate existence of the pointed publication\n        uint256 pubCount = _profileById[vars.profileIdPointed].pubCount;\n        if (pubCount < vars.pubIdPointed || vars.pubIdPointed == 0)\n            revert Errors.PublicationDoesNotExist();\n\n        _pubByIdByProfile[vars.profileId][pubId].contentURI = vars.contentURI;\n        _pubByIdByProfile[vars.profileId][pubId].profileIdPointed = vars.profileIdPointed;\n        _pubByIdByProfile[vars.profileId][pubId].pubIdPointed = vars.pubIdPointed;\n\n        // Collect Module Initialization\n        bytes memory collectModuleReturnData = _initPubCollectModule(\n            vars.profileId,\n            pubId,\n            vars.collectModule,\n            vars.collectModuleData,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted\n        );\n\n        // Reference module initialization\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            vars.profileId,\n            pubId,\n            vars.referenceModule,\n            vars.referenceModuleData,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n\n        // Reference module validation\n        address refModule = _pubByIdByProfile[vars.profileIdPointed][vars.pubIdPointed]\n            .referenceModule;\n        if (refModule != address(0)) {\n            IReferenceModule(refModule).processComment(\n                vars.profileId,\n                vars.profileIdPointed,\n                vars.pubIdPointed\n            );\n        }\n\n        // Prevents a stack too deep error\n        _emitCommentCreated(vars, pubId, collectModuleReturnData, referenceModuleReturnData);\n    }\n\n    /**\n     * @notice Creates a mirror publication mapped to the given profile.\n     *\n     * @param profileId The profile ID to associate this publication to.\n     * @param profileIdPointed The profile ID of the pointed publication's publisher.\n     * @param pubIdPointed The pointed publication's publication ID.\n     * @param referenceModule The reference module to set for this publication, if any.\n     * @param referenceModuleData The data to pass to the reference module for publication initialization.\n     * @param pubId The publication ID to associate with this publication.\n     * @param _pubByIdByProfile The storage reference to the mapping of publications by publication ID by profile ID.\n     * @param _referenceModuleWhitelisted The storage reference to the mapping of whitelist status by reference module address.\n     */\n    function createMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        address referenceModule,\n        bytes calldata referenceModuleData,\n        uint256 pubId,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) external {\n        (uint256 rootProfileIdPointed, uint256 rootPubIdPointed, ) = Helpers.getPointedIfMirror(\n            profileIdPointed,\n            pubIdPointed,\n            _pubByIdByProfile\n        );\n\n        _pubByIdByProfile[profileId][pubId].profileIdPointed = rootProfileIdPointed;\n        _pubByIdByProfile[profileId][pubId].pubIdPointed = rootPubIdPointed;\n\n        // Reference module initialization\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            profileId,\n            pubId,\n            referenceModule,\n            referenceModuleData,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n\n        // Reference module validation\n        address refModule = _pubByIdByProfile[rootProfileIdPointed][rootPubIdPointed]\n            .referenceModule;\n        if (refModule != address(0)) {\n            IReferenceModule(refModule).processMirror(\n                profileId,\n                rootProfileIdPointed,\n                rootPubIdPointed\n            );\n        }\n\n        emit Events.MirrorCreated(\n            profileId,\n            pubId,\n            rootProfileIdPointed,\n            rootPubIdPointed,\n            referenceModule,\n            referenceModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    function _initPubCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        address collectModule,\n        bytes memory collectModuleData,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _collectModuleWhitelisted\n    ) private returns (bytes memory) {\n        if (!_collectModuleWhitelisted[collectModule]) revert Errors.CollectModuleNotWhitelisted();\n        _pubByIdByProfile[profileId][pubId].collectModule = collectModule;\n        return\n            ICollectModule(collectModule).initializePublicationCollectModule(\n                profileId,\n                pubId,\n                collectModuleData\n            );\n    }\n\n    function _initPubReferenceModule(\n        uint256 profileId,\n        uint256 pubId,\n        address referenceModule,\n        bytes memory referenceModuleData,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) private returns (bytes memory) {\n        if (referenceModule != address(0)) {\n            if (!_referenceModuleWhitelisted[referenceModule])\n                revert Errors.ReferenceModuleNotWhitelisted();\n            _pubByIdByProfile[profileId][pubId].referenceModule = referenceModule;\n            return\n                IReferenceModule(referenceModule).initializeReferenceModule(\n                    profileId,\n                    pubId,\n                    referenceModuleData\n                );\n        } else {\n            return new bytes(0);\n        }\n    }\n\n    function _initFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes memory followModuleData,\n        mapping(address => bool) storage _followModuleWhitelisted\n    ) private returns (bytes memory) {\n        if (followModule != address(0)) {\n            if (!_followModuleWhitelisted[followModule]) revert Errors.FollowModuleNotWhitelisted();\n            bytes memory returnData = IFollowModule(followModule).initializeFollowModule(\n                profileId,\n                followModuleData\n            );\n            return returnData;\n        } else {\n            return new bytes(0);\n        }\n    }\n\n    function _emitCommentCreated(\n        DataTypes.CommentData memory vars,\n        uint256 pubId,\n        bytes memory collectModuleReturnData,\n        bytes memory referenceModuleReturnData\n    ) private {\n        emit Events.CommentCreated(\n            vars.profileId,\n            pubId,\n            vars.contentURI,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.collectModule,\n            collectModuleReturnData,\n            vars.referenceModule,\n            referenceModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    function _emitProfileCreated(\n        uint256 profileId,\n        DataTypes.CreateProfileData calldata vars,\n        bytes memory followModuleReturnData\n    ) internal {\n        emit Events.ProfileCreated(\n            profileId,\n            msg.sender, // Creator is always the msg sender\n            vars.to,\n            vars.handle,\n            vars.imageURI,\n            vars.followModule,\n            followModuleReturnData,\n            vars.followNFTURI,\n            block.timestamp\n        );\n    }\n\n    function _validateHandle(string calldata handle) private pure {\n        bytes memory byteHandle = bytes(handle);\n        if (byteHandle.length == 0 || byteHandle.length > Constants.MAX_HANDLE_LENGTH)\n            revert Errors.HandleLengthInvalid();\n\n        for (uint256 i = 0; i < byteHandle.length; ++i) {\n            if (\n                (byteHandle[i] < '0' ||\n                    byteHandle[i] > 'z' ||\n                    (byteHandle[i] > '9' && byteHandle[i] < 'a')) && byteHandle[i] != '.'\n            ) revert Errors.HandleContainsInvalidCharacters();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PublishingLogic.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PublishingLogic.sol#L50",
                "Type": "Frontrunning",
                "Description": "The LensHub/PublishingLogic.createProfile function can be frontrun by other whitelisted profile creators. An attacker can observe pending createProfile transactions and frontrun them, own that handle, and demand ransom from the original transaction creator.",
                "Repair": "Implement a commit/reveal scheme for the handle and the entire profile creation"
            },
            {
                "Location": "PublishingLogic.sol#L308-309",
                "Type": "Functionality",
                "Description": "In case when zero collection module be white listed and then zero collection module set to a post (done by different actors), its functionality will be partially broken: every collecting and mirroring of it will be reverted with Errors.PublicationDoesNotExist.",
                "Repair": "Prohibit zero collection module to be whitelisted"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address recipient;\n    address currency;\n    uint16 referralFee;\n}\n\n/**\n * @title FeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing unlimited collects for a publication at a given price.\n */\ncontract FeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The token ID of the profile of the publisher, passed by the hub.\n     * @param pubId The publication ID of the newly created publication, passed by the hub.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (uint256 amount, address currency, address recipient, uint16 referralFee) = abi.decode(\n            data,\n            (uint256, address, address, uint16)\n        );\n        if (\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external virtual override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "FeeCollectModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FeeCollectModule.sol#L99",
                "Type": "Value Leakage",
                "Description": "In the fee collect modules like FeeCollectModule there is no prevention of someone submitting a second profile they own as the referrerProfileId in processCollect to receive back part of the fees paid. The referral system is essentially broken as all rational agents will submit a second profile they control to get back part of the fees.",
                "Repair": "Whitelist certain important infrastructure providers, like different frontends, as referrers and only allow these to be used instead of users submitting their alt profiles"
            },
            {
                "Location": "FeeCollectModule.sol#L163-L172",
                "Type": "Inappropriate handling of referralFee",
                "Description": "If the publication is a Mirror and there is a referralFee set by the original publication, the user won't be able to collect from a Mirror that was published by a burned profile.",
                "Repair": "Change to: try IERC721(HUB).ownerOf(referrerProfileId) returns (address referralRecipient) { uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX; adjustedAmount = adjustedAmount referralAmount; address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId); IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);} catch { emit LogNonExistingReferrer(referrerProfileId);}"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute follow actions on a given profile.\n *\n * @param currency The currency associated with this profile.\n * @param amount The following cost associated with this profile.\n * @param recipient The recipient address associated with this profile.\n */\nstruct ProfileData {\n    address currency;\n    uint256 amount;\n    address recipient;\n}\n\n/**\n * @title FeeFollowModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens FollowModule implementation, inheriting from the IFollowModule interface, but with additional\n * variables that can be controlled by governance, such as the governance & treasury addresses as well as the treasury fee.\n */\ncontract FeeFollowModule is IFollowModule, FeeModuleBase, FollowValidatorFollowModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => ProfileData) internal _dataByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This follow module levies a fee on follows.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      address currency: The currency address, must be internally whitelisted.\n     *      uint256 amount: The currency total amount to levy.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        (uint256 amount, address currency, address recipient) = abi.decode(\n            data,\n            (uint256, address, address)\n        );\n        if (!_currencyWhitelisted(currency) || recipient == address(0) || amount < BPS_MAX)\n            revert Errors.InitParamsInvalid();\n\n        _dataByProfile[profileId].amount = amount;\n        _dataByProfile[profileId].currency = currency;\n        _dataByProfile[profileId].recipient = recipient;\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Charging a fee\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        uint256 amount = _dataByProfile[profileId].amount;\n        address currency = _dataByProfile[profileId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByProfile[profileId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(follower, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns the profile data for a given profile, or an empty struct if that profile was not initialized\n     * with this module.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return The ProfileData struct mapped to that profile.\n     */\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory) {\n        return _dataByProfile[profileId];\n    }\n}\n\n\n",
        "CodeNames": [
            "FeeFollowModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FeeFollowModule.sol#L75-L91",
                "Type": "Imprecise management of users' allowance",
                "Description": "Improper management of users' allowance is the root cause of some of the biggest attacks in the history of DeFi security.",
                "Repair": "Add a non-upgradeable contract for processing user payments"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {LensMultiState} from './base/LensMultiState.sol';\nimport {LensHubStorage} from './storage/LensHubStorage.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entrypoint of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke an LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is ILensHub, LensNFTBase, VersionedInitializable, LensMultiState, LensHubStorage {\n    uint256 internal constant REVISION = 1;\n\n    address internal immutable FOLLOW_NFT_IMPL;\n    address internal immutable COLLECT_NFT_IMPL;\n\n    /**\n     * @dev This modifier reverts if the caller is not the configured governance address.\n     */\n    modifier onlyGov() {\n        _validateCallerIsGovernance();\n        _;\n    }\n\n    /**\n     * @dev This modifier reverts if the caller is not a whitelisted profile creator address.\n     */\n    modifier onlyWhitelistedProfileCreator() {\n        _validateCallerIsWhitelistedProfileCreator();\n        _;\n    }\n\n    /**\n     * @dev The constructor sets the immutable follow & collect NFT implementations.\n     *\n     * @param followNFTImpl The follow NFT implementation address.\n     * @param collectNFTImpl The collect NFT implementation address.\n     */\n    constructor(address followNFTImpl, address collectNFTImpl) {\n        FOLLOW_NFT_IMPL = followNFTImpl;\n        COLLECT_NFT_IMPL = collectNFTImpl;\n    }\n\n    /// @inheritdoc ILensHub\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external override initializer {\n        super._initialize(name, symbol);\n        _setState(DataTypes.ProtocolState.Paused);\n        _setGovernance(newGovernance);\n    }\n\n    /// ***********************\n    /// *****GOV FUNCTIONS*****\n    /// ***********************\n\n    /// @inheritdoc ILensHub\n    function setGovernance(address newGovernance) external override onlyGov {\n        _setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc ILensHub\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyGov {\n        address prevEmergencyAdmin = _emergencyAdmin;\n        _emergencyAdmin = newEmergencyAdmin;\n        emit Events.EmergencyAdminSet(\n            msg.sender,\n            prevEmergencyAdmin,\n            newEmergencyAdmin,\n            block.timestamp\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setState(DataTypes.ProtocolState newState) external override {\n        if (msg.sender != _governance && msg.sender != _emergencyAdmin)\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        _setState(newState);\n    }\n\n    ///@inheritdoc ILensHub\n    function whitelistProfileCreator(address profileCreator, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _profileCreatorWhitelisted[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistFollowModule(address followModule, bool whitelist) external override onlyGov {\n        _followModuleWhitelisted[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistReferenceModule(address referenceModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _referenceModuleWhitelisted[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistCollectModule(address collectModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _collectModuleWhitelisted[collectModule] = whitelist;\n        emit Events.CollectModuleWhitelisted(collectModule, whitelist, block.timestamp);\n    }\n\n    /// *********************************\n    /// *****PROFILE OWNER FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function createProfile(DataTypes.CreateProfileData calldata vars)\n        external\n        override\n        whenNotPaused\n        onlyWhitelistedProfileCreator\n    {\n        uint256 profileId = ++_profileCounter;\n        _mint(vars.to, profileId);\n        PublishingLogic.createProfile(\n            vars,\n            profileId,\n            _profileIdByHandleHash,\n            _profileById,\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleData\n    ) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        PublishingLogic.setFollowModule(\n            profileId,\n            followModule,\n            followModuleData,\n            _profileById[profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.followModule,\n                            keccak256(vars.followModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        PublishingLogic.setFollowModule(\n            vars.profileId,\n            vars.followModule,\n            vars.followModuleData,\n            _profileById[vars.profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcher(uint256 profileId, address dispatcher) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        _setDispatcher(profileId, dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_DISPATCHER_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.dispatcher,\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setDispatcher(vars.profileId, vars.dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.imageURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setProfileImageURI(vars.profileId, vars.imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setFollowNFTURI(profileId, followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_NFT_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.followNFTURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setFollowNFTURI(vars.profileId, vars.followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function post(DataTypes.PostData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function postWithSig(DataTypes.PostWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            POST_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function comment(DataTypes.CommentData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createComment(vars);\n    }\n\n    /// @inheritdoc ILensHub\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COMMENT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createComment(\n            DataTypes.CommentData(\n                vars.profileId,\n                vars.contentURI,\n                vars.profileIdPointed,\n                vars.pubIdPointed,\n                vars.collectModule,\n                vars.collectModuleData,\n                vars.referenceModule,\n                vars.referenceModuleData\n            )\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirror(DataTypes.MirrorData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            MIRROR_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burn()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burn(uint256 tokenId) public override whenNotPaused {\n        super.burn(tokenId);\n        _clearHandleHash(tokenId);\n    }\n\n    /**\n     * @notice Burns a profile with a signature, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burnWithSig()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\n        public\n        override\n        whenNotPaused\n    {\n        super.burnWithSig(tokenId, sig);\n        _clearHandleHash(tokenId);\n    }\n\n    /// ***************************************\n    /// *****PROFILE INTERACTION FUNCTIONS*****\n    /// ***************************************\n\n    /// @inheritdoc ILensHub\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\n        external\n        override\n        whenNotPaused\n    {\n        InteractionLogic.follow(\n            msg.sender,\n            profileIds,\n            datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32[] memory dataHashes = new bytes32[](vars.datas.length);\n        for (uint256 i = 0; i < vars.datas.length; ++i) {\n            dataHashes[i] = keccak256(vars.datas[i]);\n        }\n\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            FOLLOW_WITH_SIG_TYPEHASH,\n                            keccak256(abi.encodePacked(vars.profileIds)),\n                            keccak256(abi.encodePacked(dataHashes)),\n                            sigNonces[vars.follower]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.follower, vars.sig);\n        InteractionLogic.follow(\n            vars.follower,\n            vars.profileIds,\n            vars.datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collect(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override whenNotPaused {\n        InteractionLogic.collect(\n            msg.sender,\n            profileId,\n            pubId,\n            data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COLLECT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.pubId,\n                            keccak256(vars.data),\n                            sigNonces[vars.collector]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.collector, vars.sig);\n        InteractionLogic.collect(\n            vars.collector,\n            vars.profileId,\n            vars.pubId,\n            vars.data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function emitFollowNFTTransferEvent(\n        uint256 profileId,\n        uint256 followNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedFollowNFT = _profileById[profileId].followNFT;\n        if (msg.sender != expectedFollowNFT) revert Errors.CallerNotFollowNFT();\n        emit Events.FollowNFTTransferred(profileId, followNFTId, from, to, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedCollectNFT = _pubByIdByProfile[profileId][pubId].collectNFT;\n        if (msg.sender != expectedCollectNFT) revert Errors.CallerNotCollectNFT();\n        emit Events.CollectNFTTransferred(\n            profileId,\n            pubId,\n            collectNFTId,\n            from,\n            to,\n            block.timestamp\n        );\n    }\n\n    /// *********************************\n    /// *****EXTERNAL VIEW FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function isProfileCreatorWhitelisted(address profileCreator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _profileCreatorWhitelisted[profileCreator];\n    }\n\n    /// @inheritdoc ILensHub\n    function isFollowModuleWhitelisted(address followModule) external view override returns (bool) {\n        return _followModuleWhitelisted[followModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isReferenceModuleWhitelisted(address referenceModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _referenceModuleWhitelisted[referenceModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isCollectModuleWhitelisted(address collectModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _collectModuleWhitelisted[collectModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function getGovernance() external view override returns (address) {\n        return _governance;\n    }\n\n    /// @inheritdoc ILensHub\n    function getDispatcher(uint256 profileId) external view override returns (address) {\n        return _dispatcherByProfile[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubCount(uint256 profileId) external view override returns (uint256) {\n        return _profileById[profileId].pubCount;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFT(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFTURI(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].followNFTURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectNFT(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowModule(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getReferenceModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].referenceModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getHandle(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].handle;\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubPointer(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 profileIdPointed = _pubByIdByProfile[profileId][pubId].profileIdPointed;\n        uint256 pubIdPointed = _pubByIdByProfile[profileId][pubId].pubIdPointed;\n        return (profileIdPointed, pubIdPointed);\n    }\n\n    /// @inheritdoc ILensHub\n    function getContentURI(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 rootProfileId, uint256 rootPubId, ) = Helpers.getPointedIfMirror(\n            profileId,\n            pubId,\n            _pubByIdByProfile\n        );\n        return _pubByIdByProfile[rootProfileId][rootPubId].contentURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfileIdByHandle(string calldata handle) external view override returns (uint256) {\n        bytes32 handleHash = keccak256(bytes(handle));\n        return _profileIdByHandleHash[handleHash];\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfile(uint256 profileId)\n        external\n        view\n        override\n        returns (DataTypes.ProfileStruct memory)\n    {\n        return _profileById[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPub(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PublicationStruct memory)\n    {\n        return _pubByIdByProfile[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PubType)\n    {\n        if (pubId == 0 || _profileById[profileId].pubCount < pubId) {\n            return DataTypes.PubType.Nonexistent;\n        } else if (_pubByIdByProfile[profileId][pubId].collectModule == address(0)) {\n            return DataTypes.PubType.Mirror;\n        } else {\n            if (_pubByIdByProfile[profileId][pubId].profileIdPointed == 0) {\n                return DataTypes.PubType.Post;\n            } else {\n                return DataTypes.PubType.Comment;\n            }\n        }\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return _profileById[tokenId].imageURI; // temp\n    }\n\n    /// ****************************\n    /// *****INTERNAL FUNCTIONS*****\n    /// ****************************\n\n    function _setGovernance(address newGovernance) internal {\n        address prevGovernance = _governance;\n        _governance = newGovernance;\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    function _createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData\n    ) internal {\n        PublishingLogic.createPost(\n            profileId,\n            contentURI,\n            collectModule,\n            collectModuleData,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n\n    function _createMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        address referenceModule,\n        bytes calldata referenceModuleData\n    ) internal {\n        PublishingLogic.createMirror(\n            profileId,\n            profileIdPointed,\n            pubIdPointed,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _setDispatcher(uint256 profileId, address dispatcher) internal {\n        _dispatcherByProfile[profileId] = dispatcher;\n        emit Events.DispatcherSet(profileId, dispatcher, block.timestamp);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string memory imageURI) internal {\n        _profileById[profileId].imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function _setFollowNFTURI(uint256 profileId, string memory followNFTURI) internal {\n        _profileById[profileId].followNFTURI = followNFTURI;\n        emit Events.FollowNFTURISet(profileId, followNFTURI, block.timestamp);\n    }\n\n    function _clearHandleHash(uint256 profileId) internal {\n        bytes32 handleHash = keccak256(bytes(_profileById[profileId].handle));\n        _profileIdByHandleHash[handleHash] = 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        if (_dispatcherByProfile[tokenId] != address(0)) {\n            _setDispatcher(tokenId, address(0));\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId) && msg.sender != _dispatcherByProfile[profileId])\n            revert Errors.NotProfileOwnerOrDispatcher();\n    }\n\n    function _validateCallerIsProfileOwner(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId)) revert Errors.NotProfileOwner();\n    }\n\n    function _validateCallerIsGovernance() internal view {\n        if (msg.sender != _governance) revert Errors.NotGovernance();\n    }\n\n    function _validateCallerIsWhitelistedProfileCreator() internal view {\n        if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}\n\n\n",
        "CodeNames": [
            "LensHub.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LensHub.sol#L142",
                "Type": "Name squatting",
                "Description": "Creating profiles through LensHub/PublishingLogic.createProfile does not cost anything and will therefore result in 'name squatting'.",
                "Repair": "Consider auctioning off handles to the highest bidder or at least taking a fee such that the cost of name squatting is not zero"
            },
            {
                "Location": "LensHub.sol#L146",
                "Type": "Ineffective Whitelist",
                "Description": "A single whitelisted account can create as many profiles as they want and send the profile NFT to other users.",
                "Repair": "Consider limiting the number of profile creations per whitelisted user or severely limiting who is allowed to create profiles, basically making profile creation a centralized system."
            },
            {
                "Location": "LensHub.sol#L929",
                "Type": "Missing whenNotPaused",
                "Description": "In case where the governance wants to stop all activity, they still can't stop transferring profiles nfts.",
                "Repair": "Add whenNotPasued to _beforeTokenTransfer"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param currency The currency associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param endTimestamp The end timestamp after which collecting is impossible.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address currency;\n    address recipient;\n    uint16 referralFee;\n    uint40 endTimestamp;\n}\n\n/**\n * @title TimedFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract. To optimize on gas, this module uses a constant 24 hour maximum\n * collection time.\n *\n * This module works by allowing unlimited collects for a publication within the allotted time with a given fee.\n *\n * NOTE: If data passed on initialization is empty, this module will only check for the time limit.\n */\ncontract TimedFeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    uint24 internal constant ONE_DAY = 24 hours;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, containing (in order): amount, currency, recipient, referral fee & end timestamp.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        uint40 endTimestamp = uint40(block.timestamp) + ONE_DAY;\n\n        (uint256 amount, address currency, address recipient, uint16 referralFee) = abi.decode(\n            data,\n            (uint256, address, address, uint16)\n        );\n        if (\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].endTimestamp = endTimestamp;\n\n        return abi.encode(amount, currency, recipient, referralFee, endTimestamp);\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Ensuring the current timestamp is less than or equal to the collect end timestamp\n     *  3. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        uint256 endTimestamp = _dataByPublicationByProfile[profileId][pubId].endTimestamp;\n        if (block.timestamp > endTimestamp) revert Errors.CollectExpired();\n\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param collectLimit The maximum number of collects for this publication.\n * @param currentCollects The current number of collects for this publication.\n * @param amount The collecting cost associated with this publication.\n * @param currency The currency associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param endTimestamp The end timestamp after which collecting is impossible.\n */\nstruct ProfilePublicationData {\n    uint256 collectLimit;\n    uint256 currentCollects;\n    uint256 amount;\n    address currency;\n    address recipient;\n    uint16 referralFee;\n    uint40 endTimestamp;\n}\n\n/**\n * @title LimitedTimedFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract. To optimize on gas, this module uses a constant 24 hour maximum\n * collection time.\n *\n * This module works by allowing limited collects for a publication within the allotted time with a given fee.\n */\ncontract LimitedTimedFeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    uint24 internal constant ONE_DAY = 24 hours;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 collectLimit: The maximum amount of collects.\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, containing (in order): collectLimit, amount, currency, recipient, referral fee & end timestamp.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        uint40 endTimestamp = uint40(block.timestamp) + ONE_DAY;\n\n        (\n            uint256 collectLimit,\n            uint256 amount,\n            address currency,\n            address recipient,\n            uint16 referralFee\n        ) = abi.decode(data, (uint256, uint256, address, address, uint16));\n        if (\n            collectLimit == 0 ||\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].collectLimit = collectLimit;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].endTimestamp = endTimestamp;\n\n        return abi.encode(collectLimit, amount, currency, recipient, referralFee, endTimestamp);\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Ensuring the current timestamp is less than or equal to the collect end timestamp\n     *  3. Ensuring the collect does not pass the collect limit\n     *  4. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        uint256 endTimestamp = _dataByPublicationByProfile[profileId][pubId].endTimestamp;\n        if (block.timestamp > endTimestamp) revert Errors.CollectExpired();\n\n        if (\n            _dataByPublicationByProfile[profileId][pubId].currentCollects >=\n            _dataByPublicationByProfile[profileId][pubId].collectLimit\n        ) {\n            revert Errors.MintLimitExceeded();\n        } else {\n            _dataByPublicationByProfile[profileId][pubId].currentCollects++;\n            if (referrerProfileId == profileId) {\n                _processCollect(collector, profileId, pubId, data);\n            } else {\n                _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute follow actions on a given profile.\n *\n * @param currency The currency associated with this profile.\n * @param amount The following cost associated with this profile.\n * @param recipient The recipient address associated with this profile.\n */\nstruct ProfileData {\n    address currency;\n    uint256 amount;\n    address recipient;\n}\n\n/**\n * @title FeeFollowModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens FollowModule implementation, inheriting from the IFollowModule interface, but with additional\n * variables that can be controlled by governance, such as the governance & treasury addresses as well as the treasury fee.\n */\ncontract FeeFollowModule is IFollowModule, FeeModuleBase, FollowValidatorFollowModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => ProfileData) internal _dataByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This follow module levies a fee on follows.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      address currency: The currency address, must be internally whitelisted.\n     *      uint256 amount: The currency total amount to levy.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        (uint256 amount, address currency, address recipient) = abi.decode(\n            data,\n            (uint256, address, address)\n        );\n        if (!_currencyWhitelisted(currency) || recipient == address(0) || amount < BPS_MAX)\n            revert Errors.InitParamsInvalid();\n\n        _dataByProfile[profileId].amount = amount;\n        _dataByProfile[profileId].currency = currency;\n        _dataByProfile[profileId].recipient = recipient;\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Charging a fee\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        uint256 amount = _dataByProfile[profileId].amount;\n        address currency = _dataByProfile[profileId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByProfile[profileId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(follower, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns the profile data for a given profile, or an empty struct if that profile was not initialized\n     * with this module.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return The ProfileData struct mapped to that profile.\n     */\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory) {\n        return _dataByProfile[profileId];\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param collectLimit The maximum number of collects for this publication.\n * @param currentCollects The current number of collects for this publication.\n * @param amount The collecting cost associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n */\nstruct ProfilePublicationData {\n    uint256 collectLimit;\n    uint256 currentCollects;\n    uint256 amount;\n    address recipient;\n    address currency;\n    uint16 referralFee;\n}\n\n/**\n * @title LimitedFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing limited collects for a publication indefinitely.\n */\ncontract LimitedFeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 collectLimit: The maximum amount of collects.\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (\n            uint256 collectLimit,\n            uint256 amount,\n            address currency,\n            address recipient,\n            uint16 referralFee\n        ) = abi.decode(data, (uint256, uint256, address, address, uint16));\n        if (\n            collectLimit == 0 ||\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].collectLimit = collectLimit;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Ensuring the collect does not pass the collect limit\n     *  3. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub {\n        _checkFollowValidity(profileId, collector);\n\n        if (\n            _dataByPublicationByProfile[profileId][pubId].currentCollects >=\n            _dataByPublicationByProfile[profileId][pubId].collectLimit\n        ) {\n            revert Errors.MintLimitExceeded();\n        } else {\n            _dataByPublicationByProfile[profileId][pubId].currentCollects++;\n            if (referrerProfileId == profileId) {\n                _processCollect(collector, profileId, pubId, data);\n            } else {\n                _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address recipient;\n    address currency;\n    uint16 referralFee;\n}\n\n/**\n * @title FeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing unlimited collects for a publication at a given price.\n */\ncontract FeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The token ID of the profile of the publisher, passed by the hub.\n     * @param pubId The publication ID of the newly created publication, passed by the hub.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (uint256 amount, address currency, address recipient, uint16 referralFee) = abi.decode(\n            data,\n            (uint256, address, address, uint16)\n        );\n        if (\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external virtual override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "TimedFeeCollectModule.sol",
            "LimitedTimedFeeCollectModule.sol",
            "FeeFollowModule.sol",
            "LimitedFeeCollectModule.sol",
            "FeeCollectModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FeeCollectModule.sol#L176, LimitedFeeCollectModule.sol#L194, TimedFeeCollectModule.sol#L190, LimitedTimedFeeCollectModule.sol#L205, FeeFollowModule.sol#L90",
                "Type": "Collect modules can fail on zero amount transfers",
                "Description": "Treasury fee can be zero, while collect modules do attempt to send it in such a case anyway as there is no check in place.",
                "Repair": "Consider checking the treasury fee amount and do transfer only when it is positive"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {Events} from '../../../libraries/Events.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title ApprovalFollowModule\n * @author Lens Protocol\n *\n * @notice This follow module only allows addresses that are approved for a profile by the profile owner to follow.\n */\ncontract ApprovalFollowModule is IFollowModule, FollowValidatorFollowModuleBase {\n    // We use a triple nested mapping so that, on profile transfer, the previous approved address list is invalid;\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        internal _approvedByProfileByOwner;\n\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @notice A custom function that allows profile owners to customize approved addresses.\n     *\n     * @param profileId The profile ID to approve/disapprove follower addresses for.\n     * @param addresses The addresses to approve/disapprove for following the profile.\n     * @param toApprove Whether to approve or disapprove the addresses for following the profile.\n     */\n    function approve(\n        uint256 profileId,\n        address[] calldata addresses,\n        bool[] calldata toApprove\n    ) external {\n        if (addresses.length != toApprove.length) revert Errors.InitParamsInvalid();\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (msg.sender != owner) revert Errors.NotProfileOwner();\n\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            _approvedByProfileByOwner[owner][profileId][addresses[i]] = toApprove[i];\n        }\n\n        emit Events.FollowsApproved(owner, profileId, addresses, toApprove, block.timestamp);\n    }\n\n    /**\n     * @notice This follow module works on custom profile owner approvals.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      address[] addresses: The array of addresses to approve initially.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        address owner = IERC721(HUB).ownerOf(profileId);\n\n        if (data.length > 0) {\n            address[] memory addresses = abi.decode(data, (address[]));\n            for (uint256 i = 0; i < addresses.length; ++i) {\n                _approvedByProfileByOwner[owner][profileId][addresses[i]] = true;\n            }\n        }\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Validating that the follower has been approved for that profile by the profile owner\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (!_approvedByProfileByOwner[owner][profileId][follower])\n            revert Errors.FollowNotApproved();\n        _approvedByProfileByOwner[owner][profileId][follower] = false; // prevents repeat follows\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns whether the given address is approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approval with.\n     * @param profileId The token ID of the profile to query approval with.\n     * @param toCheck The address to query approval for.\n     *\n     * @return\n     */\n    function isApproved(\n        address profileOwner,\n        uint256 profileId,\n        address toCheck\n    ) external view returns (bool) {\n        return _approvedByProfileByOwner[profileOwner][profileId][toCheck];\n    }\n\n    /**\n     * @notice Returns whether the given addresses are approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approvals with.\n     * @param profileId The token ID of the profile to query approvals with.\n     * @param toCheck The address array to query approvals for.\n     */\n    function isApprovedArray(\n        address profileOwner,\n        uint256 profileId,\n        address[] calldata toCheck\n    ) external view returns (bool[] memory) {\n        bool[] memory approved = new bool[](toCheck.length);\n        for (uint256 i = 0; i < toCheck.length; ++i) {\n            approved[i] = _approvedByProfileByOwner[profileOwner][profileId][toCheck[i]];\n        }\n        return approved;\n    }\n}\n\n\n",
        "CodeNames": [
            "ApprovalFollowModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ApprovalFollowModule.sol#L32",
                "Type": "Approvals not cleared",
                "Description": "Upon transfer, the old approvals are not cleared. This can lead to similar issues as OpenSea not cancelling their sale offers upon NFT transfer.",
                "Repair": "Consider resetting all approvals upon transfer"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {Helpers} from './Helpers.sol';\nimport {DataTypes} from './DataTypes.sol';\nimport {Errors} from './Errors.sol';\nimport {Events} from './Events.sol';\nimport {Constants} from './Constants.sol';\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\nimport {ICollectNFT} from '../interfaces/ICollectNFT.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ICollectModule} from '../interfaces/ICollectModule.sol';\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\n\n/**\n * @title InteractionLogic\n * @author Lens Protocol\n *\n * @notice This is the library that contains the logic for follows & collects. \n \n * @dev The functions are external, so they are called from the hub via `delegateCall` under the hood.\n */\nlibrary InteractionLogic {\n    using Strings for uint256;\n\n    /**\n     * @notice Follows the given profiles, executing the necessary logic and module calls before minting the follow\n     * NFT(s) to the follower.\n     *\n     * @param follower The address executing the follow.\n     * @param profileIds The array of profile token IDs to follow.\n     * @param followModuleDatas The array of follow module data parameters to pass to each profile's follow module.\n     * @param followNFTImpl The address of the follow NFT implementation, which has to be passed because it's an immutable in the hub.\n     * @param _profileById A pointer to the storage mapping of profile structs by profile ID.\n     */\n    function follow(\n        address follower,\n        uint256[] calldata profileIds,\n        bytes[] calldata followModuleDatas,\n        address followNFTImpl,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,\n        mapping(bytes32 => uint256) storage _profileIdByHandleHash\n    ) external {\n        if (profileIds.length != followModuleDatas.length) revert Errors.ArrayMismatch();\n        for (uint256 i = 0; i < profileIds.length; ++i) {\n            string memory handle = _profileById[profileIds[i]].handle;\n            if (_profileIdByHandleHash[keccak256(bytes(handle))] == 0)\n                revert Errors.TokenDoesNotExist();\n\n            address followModule = _profileById[profileIds[i]].followModule;\n\n            address followNFT = _profileById[profileIds[i]].followNFT;\n\n            if (followNFT == address(0)) {\n                followNFT = Clones.clone(followNFTImpl);\n                _profileById[profileIds[i]].followNFT = followNFT;\n\n                bytes4 firstBytes = bytes4(bytes(handle));\n\n                string memory followNFTName = string(\n                    abi.encodePacked(handle, Constants.FOLLOW_NFT_NAME_SUFFIX)\n                );\n                string memory followNFTSymbol = string(\n                    abi.encodePacked(firstBytes, Constants.FOLLOW_NFT_SYMBOL_SUFFIX)\n                );\n\n                IFollowNFT(followNFT).initialize(profileIds[i], followNFTName, followNFTSymbol);\n                emit Events.FollowNFTDeployed(profileIds[i], followNFT, block.timestamp);\n            }\n\n            IFollowNFT(followNFT).mint(follower);\n\n            if (followModule != address(0)) {\n                IFollowModule(followModule).processFollow(\n                    follower,\n                    profileIds[i],\n                    followModuleDatas[i]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Collects the given publication, executing the necessary logic and module call before minting the\n     * collect NFT to the collector.\n     *\n     * @param collector The address executing the collect.\n     * @param profileId The token ID of the publication being collected's parent profile.\n     * @param pubId The publication ID of the publication being collected.\n     * @param collectModuleData The data to pass to the publication's collect module.\n     * @param collectNFTImpl The address of the collect NFT implementation, which has to be passed because it's an immutable in the hub.\n     * @param _pubByIdByProfile A pointer to the storage mapping of publications by pubId by profile ID.\n     * @param _profileById A pointer to the storage mapping of profile structs by profile ID.\n     */\n    function collect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata collectModuleData,\n        address collectNFTImpl,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById\n    ) external {\n        (uint256 rootProfileId, uint256 rootPubId, address rootCollectModule) = Helpers\n            .getPointedIfMirror(profileId, pubId, _pubByIdByProfile);\n\n        address collectNFT = _pubByIdByProfile[rootProfileId][rootPubId].collectNFT;\n\n        if (collectNFT == address(0)) {\n            collectNFT = Clones.clone(collectNFTImpl);\n            _pubByIdByProfile[rootProfileId][rootPubId].collectNFT = collectNFT;\n\n            string memory handle = _profileById[rootProfileId].handle;\n            bytes4 firstBytes = bytes4(bytes(handle));\n\n            string memory collectNFTName = string(\n                abi.encodePacked(handle, Constants.COLLECT_NFT_NAME_INFIX, rootPubId.toString())\n            );\n            string memory collectNFTSymbol = string(\n                abi.encodePacked(\n                    firstBytes,\n                    Constants.COLLECT_NFT_SYMBOL_INFIX,\n                    rootPubId.toString()\n                )\n            );\n\n            ICollectNFT(collectNFT).initialize(\n                rootProfileId,\n                rootPubId,\n                collectNFTName,\n                collectNFTSymbol\n            );\n            emit Events.CollectNFTDeployed(rootProfileId, rootPubId, collectNFT, block.timestamp);\n        }\n\n        ICollectNFT(collectNFT).mint(collector);\n\n        ICollectModule(rootCollectModule).processCollect(\n            profileId,\n            collector,\n            rootProfileId,\n            rootPubId,\n            collectModuleData\n        );\n        emit Events.Collected(\n            collector,\n            profileId,\n            pubId,\n            rootProfileId,\n            rootPubId,\n            block.timestamp\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "InteractionLogic.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "InteractionLogic.sol#L49",
                "Type": "Following deleted profiles",
                "Description": "The problem is that there might be a new profile with the same handle as the deleted one, allowing following deleted profiles.",
                "Repair": "Change to: if (_profileIdByHandleHash[keccak256(bytes(handle))] != profileIds[i]) revert Errors.TokenDoesNotExist();"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param currency The currency associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param endTimestamp The end timestamp after which collecting is impossible.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address currency;\n    address recipient;\n    uint16 referralFee;\n    uint40 endTimestamp;\n}\n\n/**\n * @title TimedFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract. To optimize on gas, this module uses a constant 24 hour maximum\n * collection time.\n *\n * This module works by allowing unlimited collects for a publication within the allotted time with a given fee.\n *\n * NOTE: If data passed on initialization is empty, this module will only check for the time limit.\n */\ncontract TimedFeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    uint24 internal constant ONE_DAY = 24 hours;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, containing (in order): amount, currency, recipient, referral fee & end timestamp.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        uint40 endTimestamp = uint40(block.timestamp) + ONE_DAY;\n\n        (uint256 amount, address currency, address recipient, uint16 referralFee) = abi.decode(\n            data,\n            (uint256, address, address, uint16)\n        );\n        if (\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].endTimestamp = endTimestamp;\n\n        return abi.encode(amount, currency, recipient, referralFee, endTimestamp);\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Ensuring the current timestamp is less than or equal to the collect end timestamp\n     *  3. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        uint256 endTimestamp = _dataByPublicationByProfile[profileId][pubId].endTimestamp;\n        if (block.timestamp > endTimestamp) revert Errors.CollectExpired();\n\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param collectLimit The maximum number of collects for this publication.\n * @param currentCollects The current number of collects for this publication.\n * @param amount The collecting cost associated with this publication.\n * @param currency The currency associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param endTimestamp The end timestamp after which collecting is impossible.\n */\nstruct ProfilePublicationData {\n    uint256 collectLimit;\n    uint256 currentCollects;\n    uint256 amount;\n    address currency;\n    address recipient;\n    uint16 referralFee;\n    uint40 endTimestamp;\n}\n\n/**\n * @title LimitedTimedFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract. To optimize on gas, this module uses a constant 24 hour maximum\n * collection time.\n *\n * This module works by allowing limited collects for a publication within the allotted time with a given fee.\n */\ncontract LimitedTimedFeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    uint24 internal constant ONE_DAY = 24 hours;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 collectLimit: The maximum amount of collects.\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, containing (in order): collectLimit, amount, currency, recipient, referral fee & end timestamp.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        uint40 endTimestamp = uint40(block.timestamp) + ONE_DAY;\n\n        (\n            uint256 collectLimit,\n            uint256 amount,\n            address currency,\n            address recipient,\n            uint16 referralFee\n        ) = abi.decode(data, (uint256, uint256, address, address, uint16));\n        if (\n            collectLimit == 0 ||\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].collectLimit = collectLimit;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].endTimestamp = endTimestamp;\n\n        return abi.encode(collectLimit, amount, currency, recipient, referralFee, endTimestamp);\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Ensuring the current timestamp is less than or equal to the collect end timestamp\n     *  3. Ensuring the collect does not pass the collect limit\n     *  4. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        uint256 endTimestamp = _dataByPublicationByProfile[profileId][pubId].endTimestamp;\n        if (block.timestamp > endTimestamp) revert Errors.CollectExpired();\n\n        if (\n            _dataByPublicationByProfile[profileId][pubId].currentCollects >=\n            _dataByPublicationByProfile[profileId][pubId].collectLimit\n        ) {\n            revert Errors.MintLimitExceeded();\n        } else {\n            _dataByPublicationByProfile[profileId][pubId].currentCollects++;\n            if (referrerProfileId == profileId) {\n                _processCollect(collector, profileId, pubId, data);\n            } else {\n                _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {Errors} from '../../libraries/Errors.sol';\nimport {Events} from '../../libraries/Events.sol';\nimport {IModuleGlobals} from '../../interfaces/IModuleGlobals.sol';\n\n/**\n * @title FeeModuleBase\n * @author Lens Protocol\n *\n * @notice This is an abstract contract to be inherited from by modules that require basic fee functionality. It\n * contains getters for module globals parameters as well as a validation function to check expected data.\n */\nabstract contract FeeModuleBase {\n    uint16 internal constant BPS_MAX = 10000;\n\n    address public immutable MODULE_GLOBALS;\n\n    constructor(address moduleGlobals) {\n        if (moduleGlobals == address(0)) revert Errors.InitParamsInvalid();\n        MODULE_GLOBALS = moduleGlobals;\n        emit Events.FeeModuleBaseConstructed(moduleGlobals, block.timestamp);\n    }\n\n    function _currencyWhitelisted(address currency) internal view returns (bool) {\n        return IModuleGlobals(MODULE_GLOBALS).isCurrencyWhitelisted(currency);\n    }\n\n    function _treasuryData() internal view returns (address, uint16) {\n        return IModuleGlobals(MODULE_GLOBALS).getTreasuryData();\n    }\n\n    function _validateDataIsExpected(\n        bytes calldata data,\n        address currency,\n        uint256 amount\n    ) internal pure {\n        (address decodedCurrency, uint256 decodedAmount) = abi.decode(data, (address, uint256));\n        if (decodedAmount != amount || decodedCurrency != currency)\n            revert Errors.ModuleDataMismatch();\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute follow actions on a given profile.\n *\n * @param currency The currency associated with this profile.\n * @param amount The following cost associated with this profile.\n * @param recipient The recipient address associated with this profile.\n */\nstruct ProfileData {\n    address currency;\n    uint256 amount;\n    address recipient;\n}\n\n/**\n * @title FeeFollowModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens FollowModule implementation, inheriting from the IFollowModule interface, but with additional\n * variables that can be controlled by governance, such as the governance & treasury addresses as well as the treasury fee.\n */\ncontract FeeFollowModule is IFollowModule, FeeModuleBase, FollowValidatorFollowModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => ProfileData) internal _dataByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This follow module levies a fee on follows.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      address currency: The currency address, must be internally whitelisted.\n     *      uint256 amount: The currency total amount to levy.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        (uint256 amount, address currency, address recipient) = abi.decode(\n            data,\n            (uint256, address, address)\n        );\n        if (!_currencyWhitelisted(currency) || recipient == address(0) || amount < BPS_MAX)\n            revert Errors.InitParamsInvalid();\n\n        _dataByProfile[profileId].amount = amount;\n        _dataByProfile[profileId].currency = currency;\n        _dataByProfile[profileId].recipient = recipient;\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Charging a fee\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        uint256 amount = _dataByProfile[profileId].amount;\n        address currency = _dataByProfile[profileId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByProfile[profileId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(follower, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns the profile data for a given profile, or an empty struct if that profile was not initialized\n     * with this module.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return The ProfileData struct mapped to that profile.\n     */\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory) {\n        return _dataByProfile[profileId];\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param collectLimit The maximum number of collects for this publication.\n * @param currentCollects The current number of collects for this publication.\n * @param amount The collecting cost associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n */\nstruct ProfilePublicationData {\n    uint256 collectLimit;\n    uint256 currentCollects;\n    uint256 amount;\n    address recipient;\n    address currency;\n    uint16 referralFee;\n}\n\n/**\n * @title LimitedFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing limited collects for a publication indefinitely.\n */\ncontract LimitedFeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 collectLimit: The maximum amount of collects.\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (\n            uint256 collectLimit,\n            uint256 amount,\n            address currency,\n            address recipient,\n            uint16 referralFee\n        ) = abi.decode(data, (uint256, uint256, address, address, uint16));\n        if (\n            collectLimit == 0 ||\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].collectLimit = collectLimit;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Ensuring the collect does not pass the collect limit\n     *  3. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub {\n        _checkFollowValidity(profileId, collector);\n\n        if (\n            _dataByPublicationByProfile[profileId][pubId].currentCollects >=\n            _dataByPublicationByProfile[profileId][pubId].collectLimit\n        ) {\n            revert Errors.MintLimitExceeded();\n        } else {\n            _dataByPublicationByProfile[profileId][pubId].currentCollects++;\n            if (referrerProfileId == profileId) {\n                _processCollect(collector, profileId, pubId, data);\n            } else {\n                _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "TimedFeeCollectModule.sol",
            "LimitedTimedFeeCollectModule.sol",
            "FeeModuleBase.sol",
            "FeeFollowModule.sol",
            "LimitedFeeCollectModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Base fee modules in FeeModuleBase.sol, LimitedFeeCollectModule.sol, TimedFeeCollectModule.sol, LimitedTimedFeeCollectModule.sol, and FeeFollowModule.sol",
                "Type": "Restrictive functionality",
                "Description": "BPS_MAX constant is used as minimal fee amount requirement, which restricts functionality for some currencies with small decimals and market rates.",
                "Repair": "Add a separate constant for minimum fee amount in nominal terms"
            }
        ]
    }
]