[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./MasterChef.sol\";\n\ncontract StakingRewards is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    MasterChef public immutable masterChef;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 7 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    address public rewardsDistribution;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        MasterChef _masterChef\n    ) {\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        masterChef = _masterChef;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / _totalSupply);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            (_balances[account] *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) /\n            1e18 +\n            rewards[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate * rewardsDuration;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.deposit(msg.sender, pid, amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.withdraw(msg.sender, pid, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        updateReward(address(0))\n    {\n        require(\n            msg.sender == rewardsDistribution,\n            \"Caller is not RewardsDistribution contract\"\n        );\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance / rewardsDuration,\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    function setRewardsDistribution(address _rewardsDistribution)\n        external\n        onlyOwner\n    {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDistribution = _rewardsDistribution;\n        emit RewardsDistributionUpdated(rewardsDistribution);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event RewardsDistributionUpdated(address indexed newDistribution);\n    event Recovered(address token, uint256 amount);\n}\n\n\n",
        "CodeNames": [
            "StakingRewards.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StakingRewards.sol recoverERC20()",
                "Type": "backdoor",
                "Description": "The owner can use recoverERC20() to retrieve rewardsToken, which can result in users losing their rewards to a malicious/compromised owner.",
                "Repair": "Change the function to transfer tokens to a specified address instead of the owner address"
            },
            {
                "Location": "StakingRewards.sol notifyRewardAmount()",
                "Type": "reward balance check",
                "Description": "The contract only checks if balanceOf rewardsToken is greater than or equal to the future rewards, which can result in the contract ending up in a wrong state that makes some users unable to claim their rewards.",
                "Repair": "Change the function to addReward() and use transferFrom() to transfer rewardsToken into the contract"
            },
            {
                "Location": "StakingRewards.sol#L166",
                "Type": "Rug Pull",
                "Description": "StakingRewards.recoverERC20 allows the owner to sweep the rewards tokens, perhaps as a way to rug depositors.",
                "Repair": "Add an additional check to require that the token being withdrawn is not the rewards token."
            },
            {
                "Location": "StakingRewards.setRewardsDuration",
                "Type": "Admin Privilege",
                "Description": "Setting near zero or enormous rewardsDuration breaks reward logic.",
                "Repair": "Check for min and max range in the rewardsDuration setter"
            },
            {
                "Location": "ConvexStakingWrapper, StakingRewards",
                "Type": "smart contract vulnerability",
                "Description": "ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver",
                "Repair": "Add two new functions to MasterChef: depositFor() and withdrawFor()"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ICurveMetaPool } from \"./external/CurveInterfaces.sol\";\n\ncontract USDMPegRecovery is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    IERC20 public immutable usdm;\n\n    IERC20 public immutable pool3;\n\n    ICurveMetaPool public immutable usdm3crv;\n\n    address public immutable kpiOracle;\n\n    uint256 public step;\n\n    uint256 public startLiquidity;\n\n    struct Liquidity {\n        uint128 usdm;\n        uint128 pool3;\n    }\n\n    event Deposit(address indexed depositor, Liquidity deposits);\n\n    event Withdraw(address indexed withdrawer, Liquidity withdrawals);\n\n    Liquidity public totalLiquidity;\n\n    mapping(address => Liquidity) public userLiquidity;\n\n    mapping(address => bool) public isGuardian;\n\n    bool public unlockable;\n\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"!guardian\");\n        _;\n    }\n\n    constructor(\n        uint256 _startLiquidity,\n        address _kpiOracle\n    ) Ownable() {\n        startLiquidity = _startLiquidity;\n        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);\n        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);\n        step = 250000e18;\n        kpiOracle = _kpiOracle;\n    }\n\n    function addGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = true;\n    }\n\n    function removeGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = false;\n    }\n\n    function enableUnlock() external {\n        require(msg.sender == kpiOracle, \"!oracle\");\n        unlockable = true;\n    }\n\n    function provide(uint256 _minimumLP) external onlyGuardian {\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n        // truncate amounts under step\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n        // match usdm : pool3 = 1 : 1\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n        usdm.approve(address(usdm3crv), addingLiquidity);\n        pool3.approve(address(usdm3crv), addingLiquidity);\n        usdm3crv.add_liquidity(amounts, _minimumLP);\n    }\n\n    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {\n        uint256 removingLiquidity = _steps * step;\n        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];\n        usdm3crv.remove_liquidity(_burningLPs, amounts);\n    }\n\n    function deposit(Liquidity calldata _deposits) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_deposits.usdm > 0) {\n            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));\n            total.usdm += _deposits.usdm;\n            user.usdm += _deposits.usdm;\n        }\n\n        if(_deposits.pool3 > 0) {\n            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");\n            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));\n            total.pool3 += _deposits.pool3;\n            user.pool3 += _deposits.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Deposit(msg.sender, _deposits);\n    }\n\n    function withdraw(Liquidity calldata _withdrawal) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_withdrawal.usdm > 0) {\n            require(unlockable, \"!unlock usdm\");\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\n            total.usdm -= _withdrawal.usdm;\n            user.usdm -= _withdrawal.usdm;\n        }\n\n        if(_withdrawal.pool3 > 0) {\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\n            total.pool3 -= _withdrawal.pool3;\n            user.pool3 -= _withdrawal.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Withdraw(msg.sender, _withdrawal);\n    }\n}\n\n\n",
        "CodeNames": [
            "USDMPegRecovery.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "USDMPegRecovery",
                "Type": "fund lock",
                "Description": "The internal balances in the contract can become imbalanced due to the way curve works, causing users to be unable to withdraw the exact amounts they deposited and resulting in funds being stuck.",
                "Repair": "Price user contribution based on LP tokens or have users deposit the LP token directly"
            },
            {
                "Location": "USDMPegRecovery.sol#withdraw()",
                "Type": "Insufficient Balance",
                "Description": "The withdraw() may often fail due to insufficient funds in the balance.",
                "Repair": "Call usdm3crv.remove_liquidity_one_coin() when the balance is insufficient for the user's withdrawal"
            },
            {
                "Location": "USDMPegRecovery.sol#L90",
                "Type": "Locked USDM deposits",
                "Description": "USDM deposits are locked based on the KPI\u2019s from carrot.eth. However, USDM deposits are also locked until guardian remove liquidity because there are no mechanism to remove deposited USDM in withdraw.",
                "Repair": "Refactor the contract to transform it into a Yield Bearing Vault and denominate the deposit token in the CRV_LP token to avoid issues with Single Sided Exposure"
            },
            {
                "Location": "USDMPegRecovery.sol#provide()",
                "Type": "Unable to add liquidity to the usdm3crv pool",
                "Description": "USDMPegRecovery.sol#provide() Improper design/implementation make it often unable to add liquidity to the usdm3crv pool.",
                "Repair": "Change the implementation of USDMPegRecovery.sol#provide() to calculate addingLiquidity based on the minimum balance of usdm and pool3 tokens"
            },
            {
                "Location": "USDMPegRecovery.sol provide() function",
                "Type": "Insufficient Liquidity",
                "Description": "The provide() function does not take a _steps argument and will instead calculate addingLiquidity by truncating amounts under step. As a result, if there is an excess of usdm such that the truncated amount exceeds the contract's pool3 truncated balance, then the function will revert due to insufficient pool3 collateral, preventing guardians from effectively providing liquidity whenever tokens are available.",
                "Repair": "Modify the provide() function such that a _steps argument can be supplied or use the balance of the pool3 token to calculate the LP amounts"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./external/ConvexInterfaces.sol\";\nimport \"./interfaces/IConcurRewardClaim.sol\";\nimport \"./MasterChef.sol\";\n\ncontract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    struct RewardType {\n        address token;\n        address pool;\n        uint128 integral;\n        uint128 remaining;\n    }\n\n    struct Reward {\n        uint128 integral;\n    }\n\n    //constants/immutables\n    address public constant convexBooster =\n        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv =\n        address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx =\n        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n\n    uint256 public constant CRV_INDEX = 0;\n    uint256 public constant CVX_INDEX = 1;\n    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000\n    MasterChef public immutable masterChef;\n\n    //convex rewards\n    mapping(uint256 => address) public convexPool;\n    mapping(uint256 => RewardType[]) public rewards;\n    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))\n        public userReward;\n    mapping(uint256 => mapping(address => uint256)) public registeredRewards;\n\n    //management\n    address public treasury;\n    IConcurRewardClaim public claimContract;\n\n    struct Deposit {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    struct WithdrawRequest {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    mapping(address => uint256) public pids;\n    mapping(uint256 => mapping(address => Deposit)) public deposits;\n    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;\n\n    event Deposited(address indexed _user, uint256 _amount);\n    event Withdrawn(address indexed _user, uint256 _amount);\n\n    constructor(address _treasury, MasterChef _masterChef) {\n        treasury = _treasury;\n        masterChef = _masterChef;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n    }\n\n    function setRewardPool(address _claimContract) external onlyOwner {\n        claimContract = IConcurRewardClaim(_claimContract);\n    }\n\n    /// @notice function to bootstrap the reward pool and extra rewards of convex booster\n    /// @dev should be able to be called more than once\n    /// @param _pid pid of the curve lp. same as convex booster pid\n    function addRewards(uint256 _pid) public {\n        address mainPool = IRewardStaking(convexBooster)\n            .poolInfo(_pid)\n            .crvRewards;\n        if (rewards[_pid].length == 0) {\n            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;\n            convexPool[_pid] = mainPool;\n            rewards[_pid].push(\n                RewardType({\n                    token: crv,\n                    pool: mainPool,\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            rewards[_pid].push(\n                RewardType({\n                    token: cvx,\n                    pool: address(0),\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1\n            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        for (uint256 i = 0; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            address extraToken = IRewardStaking(extraPool).rewardToken();\n            if (extraToken == cvx) {\n                //no-op for cvx, crv rewards\n                rewards[_pid][CVX_INDEX].pool = extraPool;\n            } else if (registeredRewards[_pid][extraToken] == 0) {\n                //add new token to list\n                rewards[_pid].push(\n                    RewardType({\n                        token: IRewardStaking(extraPool).rewardToken(),\n                        pool: extraPool,\n                        integral: 0,\n                        remaining: 0\n                    })\n                );\n                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1\n            }\n        }\n    }\n\n    function rewardLength(uint256 _pid) external view returns (uint256) {\n        return rewards[_pid].length;\n    }\n\n    function _getDepositedBalance(uint256 _pid, address _account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return deposits[_pid][_account].amount;\n    }\n\n    function _getTotalSupply(uint256 _pid)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));\n    }\n\n    function _calcRewardIntegral(\n        uint256 _pid,\n        uint256 _index,\n        address _account,\n        uint256 _balance,\n        uint256 _supply\n    ) internal {\n        RewardType memory reward = rewards[_pid][_index];\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.token).balanceOf(address(this));\n        uint256 d_reward = bal - reward.remaining;\n        // send 20 % of cvx / crv reward to treasury\n        if (reward.token == cvx || reward.token == crv) {\n            IERC20(reward.token).transfer(treasury, d_reward / 5);\n            d_reward = (d_reward * 4) / 5;\n        }\n        IERC20(reward.token).transfer(address(claimContract), d_reward);\n\n        if (_supply > 0 && d_reward > 0) {\n            reward.integral =\n                reward.integral +\n                uint128((d_reward * 1e20) / _supply);\n        }\n\n        //update user integrals\n        uint256 userI = userReward[_pid][_index][_account].integral;\n        if (userI < reward.integral) {\n            userReward[_pid][_index][_account].integral = reward.integral;\n            claimContract.pushReward(\n                _account,\n                reward.token,\n                (_balance * (reward.integral - userI)) / 1e20\n            );\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != reward.remaining) {\n            reward.remaining = uint128(bal);\n        }\n\n        rewards[_pid][_index] = reward;\n    }\n\n    function _checkpoint(uint256 _pid, address _account) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (paused()) return;\n\n        uint256 supply = _getTotalSupply(_pid);\n        uint256 depositedBalance = _getDepositedBalance(_pid, _account);\n\n        IRewardStaking(convexPool[_pid]).getReward(address(this), true);\n\n        uint256 rewardCount = rewards[_pid].length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);\n        }\n    }\n\n    /// @notice deposit curve lp token\n    /// @dev should approve curve lp token to this address before calling this function\n    /// @param _pid pid to deposit, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        whenNotPaused\n        nonReentrant\n    {\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].epoch = currentEpoch();\n        deposits[_pid][msg.sender].amount += uint192(_amount);\n        if (_amount > 0) {\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n\n            lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n            lpToken.safeApprove(convexBooster, _amount);\n            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);\n            lpToken.safeApprove(convexBooster, 0);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.deposit(msg.sender, pid, _amount);\n        }\n\n        emit Deposited(msg.sender, _amount);\n    }\n\n    /// @notice withdraw curve lp token\n    /// @dev should request withdraw before calling this function\n    /// @param _pid pid to withdraw, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {\n        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];\n        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");\n        require(request.amount >= _amount, \"too much\");\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].amount -= uint192(_amount);\n        if (_amount > 0) {\n            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n            lpToken.safeTransfer(msg.sender, _amount);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.withdraw(msg.sender, pid, _amount);\n        }\n        delete withdrawRequest[_pid][msg.sender];\n        //events\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    /// @notice epoch for voting cycle\n    /// @return returns the epoch in uint64 type\n    function currentEpoch() public view returns(uint64) {\n        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;\n    }\n\n    /// @notice request withdraw to be eligible for withdrawal after currentEpoch\n    /// @dev prior withdrawal request will be overwritten\n    /// @param _pid pid to withdraw\n    /// @param _amount amount to request withdrawal\n    function requestWithdraw(uint256 _pid, uint256 _amount) external {\n        require(_amount <= uint256(deposits[_pid][msg.sender].amount), \"too much\");\n        withdrawRequest[_pid][msg.sender] = WithdrawRequest({\n            epoch : currentEpoch(),\n            amount : uint192(_amount)\n        });\n    }\n}\n\n\n",
        "CodeNames": [
            "ConvexStakingWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ConvexStakingWrapper",
                "Type": "deposit/withdraw disablement",
                "Description": "If a reward token doesn't allow for zero value transfers, the reward update function will fail on an empty incremental reward transfer, which is now done unconditionally, reverting the caller deposit/withdrawal functionality.",
                "Repair": "Check the reward before doing transfer and related computations"
            },
            {
                "Location": "ConvexStakingWrapper.sol",
                "Type": "Loss of Rewards",
                "Description": "Users will lose rewards if the shelter mechanism is enacted before a recent checkpoint, as they will only receive their rewards upon depositing/withdrawing their funds due to how the checkpointing mechanism works.",
                "Repair": "Consider allowing users to call a public facing _checkpoint function once their funds have been drained to the Shelter.sol contract. This should ensure they receive their fair share of rewards."
            },
            {
                "Location": "ConvexStakingWrapper.sol#_calcRewardIntegral",
                "Type": "Wrong implementation",
                "Description": "Wrong implementation can disrupt rewards calculation and distribution.",
                "Repair": "Compare the balanceOf reward token before and after getReward() to get the actual rewarded amount, and reward.remaining should be removed."
            },
            {
                "Location": "ConvexStakingWrapper.enterShelter()",
                "Type": "May Erroneously Overwrite",
                "Description": "May Erroneously Overwrite amountInShelter Leading To Locked Tokens.",
                "Repair": "Add to the amountInShelter[lpToken] mapping instead of overwriting it altogether."
            },
            {
                "Location": "ConvexStakingWrapper.sol deposit() function",
                "Type": "Unsafe Type Casting",
                "Description": "When the value of the amount parameter is larger than type(uint192).max, due to unsafe type casting, the recorded deposited amount can be much smaller than their invested amount, causing the depositor to lose all their invested funds.",
                "Repair": "Add an upper limit for the amount parameter"
            },
            {
                "Location": "ConvexStakingWrapper",
                "Type": "smart contract vulnerability",
                "Description": "deposit in ConvexStakingWrapper will most certainly revert",
                "Repair": "Change the code to call the correct function or implement the missing function"
            },
            {
                "Location": "ConvexStakingWrapper.exitShelter()",
                "Type": "smart contract vulnerability",
                "Description": "ConvexStakingWrapper.exitShelter() Will Lock LP Tokens, Preventing Users From Withdrawing",
                "Repair": "Re-deposit LP tokens upon calling exitShelter()"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IShelter } from \"./interfaces/IShelter.sol\";\nimport { IShelterClient } from \"./interfaces/IShelterClient.sol\";\n\ncontract Shelter is IShelter {\n    using SafeERC20 for IERC20;\n\n    IShelterClient public immutable client;\n\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    mapping(IERC20 => mapping(address => bool)) public override claimed;\n\n    mapping(IERC20 => uint256) public activated;\n\n    mapping(IERC20 => uint256) public savedTokens;\n\n    modifier onlyClient {\n        require(msg.sender == address(client), \"!client\");\n        _;\n    }\n\n    constructor(IShelterClient _client){\n        client = _client;\n    }\n\n    function donate(IERC20 _token, uint256 _amount) external {\n        require(activated[_token] != 0, \"!activated\");\n        savedTokens[_token] += _amount;\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function activate(IERC20 _token) external override onlyClient {\n        activated[_token] = block.timestamp;\n        savedTokens[_token] = _token.balanceOf(address(this));\n        emit ShelterActivated(_token);\n    }\n\n    function deactivate(IERC20 _token) external override onlyClient {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\");\n        activated[_token] = 0;\n        savedTokens[_token] = 0;\n        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));\n        emit ShelterDeactivated(_token);\n    }\n\n    function withdraw(IERC20 _token, address _to) external override {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, \"shelter not activated\");\n        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);\n        claimed[_token][_to] = true;\n        emit ExitShelter(_token, msg.sender, _to, amount);\n        _token.safeTransfer(_to, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "Shelter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Shelter",
                "Type": "funds drain",
                "Description": "The claimed mapping is set with the _to address, not the msg.sender address, allowing any user to withdraw all the funds from the shelter.",
                "Repair": "Change the _to address to msg.sender"
            },
            {
                "Location": "Shelter.sol#L38-L42",
                "Type": "Malicious Admin",
                "Description": "The Shelter contract can steal user tokens.",
                "Repair": "Avoid activate twice for the same token, donate only after the GRACE_PERIOD"
            },
            {
                "Location": "Shelter.sol",
                "Type": "Bypassing deactivate function",
                "Description": "onlyClient can deactivate a token even after deadline is passed and transfer all token balance to itself.",
                "Repair": "Add a condition to the activate function to check if the token is already activated before activating it"
            },
            {
                "Location": "Shelter.sol#L32-L36",
                "Type": "Donated tokens cannot be recovered",
                "Description": "Donated Tokens Cannot Be Recovered If A Shelter Is Deactivated.",
                "Repair": "Allocate donated LP tokens to the contract owner when a shelter is deactivated by checking for an excess of LP tokens"
            },
            {
                "Location": "Shelter.sol withdraw() function",
                "Type": "Reentrancy Attack",
                "Description": "Repeated calls to Shelter.withdraw can drain all funds in Shelter, allowing an attacker that can successfully call withdraw() once on a shelter, to call it repeatedly to steal the funds of others.",
                "Repair": "Check claims against msg.sender and record who is withdrawing"
            },
            {
                "Location": "Shelter",
                "Type": "smart contract vulnerability",
                "Description": "Fee-on-transfer token donations in Shelter break withdrawals",
                "Repair": "Add only the actual transferred amounts to savedTokens[_token]"
            },
            {
                "Location": "Shelter",
                "Type": "smart contract vulnerability",
                "Description": "Deposits after the grace period should not be allowed",
                "Repair": "Add a check to donate function to disallow new deposits after the grace period ends"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IConcurRewardClaim} from \"./interfaces/IConcurRewardClaim.sol\";\n\ncontract ConcurRewardPool is IConcurRewardClaim {\n    using SafeERC20 for IERC20;\n    address public immutable rewardNotifier;\n\n    mapping(address => mapping(address => uint256)) public reward;\n\n    constructor(address _notifier) {\n        rewardNotifier = _notifier;\n    }\n\n    /// @notice push reward to `_recipient`\n    /// @param _recipient reward recipient address\n    /// @param _token token to reward\n    /// @param _amount amount of tokens to allocate to `_recipient`\n    function pushReward(\n        address _recipient,\n        address _token,\n        uint256 _amount\n    ) external override {\n        require(msg.sender == rewardNotifier, \"!notifier\");\n        reward[_recipient][_token] += _amount;\n    }\n\n    /// @notice claim rewards of `msg.sender`\n    /// @param _tokens array of tokens to claim\n    function claimRewards(address[] calldata _tokens) external override {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 getting = reward[msg.sender][_tokens[i]];\n            IERC20(_tokens[i]).safeTransfer(msg.sender, getting);\n            reward[msg.sender][_tokens[i]] = 0;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "ConcurRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ConcurRewardPool.sol#L34",
                "Type": "Reentrancy Attack",
                "Description": "The reward tokens are transferred before the balances are set to 0, making it possible to perform a reentrancy attack if the reward token has some kind of call back functionality.",
                "Repair": "Use a nonReentrant modifier, set balances to 0 first before disbursing the rewards"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./MasterChef.sol\";\n\ncontract StakingRewards is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    MasterChef public immutable masterChef;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 7 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    address public rewardsDistribution;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        MasterChef _masterChef\n    ) {\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        masterChef = _masterChef;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / _totalSupply);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            (_balances[account] *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) /\n            1e18 +\n            rewards[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate * rewardsDuration;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.deposit(msg.sender, pid, amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.withdraw(msg.sender, pid, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        updateReward(address(0))\n    {\n        require(\n            msg.sender == rewardsDistribution,\n            \"Caller is not RewardsDistribution contract\"\n        );\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance / rewardsDuration,\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    function setRewardsDistribution(address _rewardsDistribution)\n        external\n        onlyOwner\n    {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDistribution = _rewardsDistribution;\n        emit RewardsDistributionUpdated(rewardsDistribution);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event RewardsDistributionUpdated(address indexed newDistribution);\n    event Recovered(address token, uint256 amount);\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./external/ConvexInterfaces.sol\";\nimport \"./interfaces/IConcurRewardClaim.sol\";\nimport \"./MasterChef.sol\";\n\ncontract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    struct RewardType {\n        address token;\n        address pool;\n        uint128 integral;\n        uint128 remaining;\n    }\n\n    struct Reward {\n        uint128 integral;\n    }\n\n    //constants/immutables\n    address public constant convexBooster =\n        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv =\n        address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx =\n        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n\n    uint256 public constant CRV_INDEX = 0;\n    uint256 public constant CVX_INDEX = 1;\n    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000\n    MasterChef public immutable masterChef;\n\n    //convex rewards\n    mapping(uint256 => address) public convexPool;\n    mapping(uint256 => RewardType[]) public rewards;\n    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))\n        public userReward;\n    mapping(uint256 => mapping(address => uint256)) public registeredRewards;\n\n    //management\n    address public treasury;\n    IConcurRewardClaim public claimContract;\n\n    struct Deposit {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    struct WithdrawRequest {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    mapping(address => uint256) public pids;\n    mapping(uint256 => mapping(address => Deposit)) public deposits;\n    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;\n\n    event Deposited(address indexed _user, uint256 _amount);\n    event Withdrawn(address indexed _user, uint256 _amount);\n\n    constructor(address _treasury, MasterChef _masterChef) {\n        treasury = _treasury;\n        masterChef = _masterChef;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n    }\n\n    function setRewardPool(address _claimContract) external onlyOwner {\n        claimContract = IConcurRewardClaim(_claimContract);\n    }\n\n    /// @notice function to bootstrap the reward pool and extra rewards of convex booster\n    /// @dev should be able to be called more than once\n    /// @param _pid pid of the curve lp. same as convex booster pid\n    function addRewards(uint256 _pid) public {\n        address mainPool = IRewardStaking(convexBooster)\n            .poolInfo(_pid)\n            .crvRewards;\n        if (rewards[_pid].length == 0) {\n            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;\n            convexPool[_pid] = mainPool;\n            rewards[_pid].push(\n                RewardType({\n                    token: crv,\n                    pool: mainPool,\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            rewards[_pid].push(\n                RewardType({\n                    token: cvx,\n                    pool: address(0),\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1\n            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        for (uint256 i = 0; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            address extraToken = IRewardStaking(extraPool).rewardToken();\n            if (extraToken == cvx) {\n                //no-op for cvx, crv rewards\n                rewards[_pid][CVX_INDEX].pool = extraPool;\n            } else if (registeredRewards[_pid][extraToken] == 0) {\n                //add new token to list\n                rewards[_pid].push(\n                    RewardType({\n                        token: IRewardStaking(extraPool).rewardToken(),\n                        pool: extraPool,\n                        integral: 0,\n                        remaining: 0\n                    })\n                );\n                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1\n            }\n        }\n    }\n\n    function rewardLength(uint256 _pid) external view returns (uint256) {\n        return rewards[_pid].length;\n    }\n\n    function _getDepositedBalance(uint256 _pid, address _account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return deposits[_pid][_account].amount;\n    }\n\n    function _getTotalSupply(uint256 _pid)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));\n    }\n\n    function _calcRewardIntegral(\n        uint256 _pid,\n        uint256 _index,\n        address _account,\n        uint256 _balance,\n        uint256 _supply\n    ) internal {\n        RewardType memory reward = rewards[_pid][_index];\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.token).balanceOf(address(this));\n        uint256 d_reward = bal - reward.remaining;\n        // send 20 % of cvx / crv reward to treasury\n        if (reward.token == cvx || reward.token == crv) {\n            IERC20(reward.token).transfer(treasury, d_reward / 5);\n            d_reward = (d_reward * 4) / 5;\n        }\n        IERC20(reward.token).transfer(address(claimContract), d_reward);\n\n        if (_supply > 0 && d_reward > 0) {\n            reward.integral =\n                reward.integral +\n                uint128((d_reward * 1e20) / _supply);\n        }\n\n        //update user integrals\n        uint256 userI = userReward[_pid][_index][_account].integral;\n        if (userI < reward.integral) {\n            userReward[_pid][_index][_account].integral = reward.integral;\n            claimContract.pushReward(\n                _account,\n                reward.token,\n                (_balance * (reward.integral - userI)) / 1e20\n            );\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != reward.remaining) {\n            reward.remaining = uint128(bal);\n        }\n\n        rewards[_pid][_index] = reward;\n    }\n\n    function _checkpoint(uint256 _pid, address _account) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (paused()) return;\n\n        uint256 supply = _getTotalSupply(_pid);\n        uint256 depositedBalance = _getDepositedBalance(_pid, _account);\n\n        IRewardStaking(convexPool[_pid]).getReward(address(this), true);\n\n        uint256 rewardCount = rewards[_pid].length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);\n        }\n    }\n\n    /// @notice deposit curve lp token\n    /// @dev should approve curve lp token to this address before calling this function\n    /// @param _pid pid to deposit, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        whenNotPaused\n        nonReentrant\n    {\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].epoch = currentEpoch();\n        deposits[_pid][msg.sender].amount += uint192(_amount);\n        if (_amount > 0) {\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n\n            lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n            lpToken.safeApprove(convexBooster, _amount);\n            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);\n            lpToken.safeApprove(convexBooster, 0);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.deposit(msg.sender, pid, _amount);\n        }\n\n        emit Deposited(msg.sender, _amount);\n    }\n\n    /// @notice withdraw curve lp token\n    /// @dev should request withdraw before calling this function\n    /// @param _pid pid to withdraw, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {\n        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];\n        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");\n        require(request.amount >= _amount, \"too much\");\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].amount -= uint192(_amount);\n        if (_amount > 0) {\n            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n            lpToken.safeTransfer(msg.sender, _amount);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.withdraw(msg.sender, pid, _amount);\n        }\n        delete withdrawRequest[_pid][msg.sender];\n        //events\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    /// @notice epoch for voting cycle\n    /// @return returns the epoch in uint64 type\n    function currentEpoch() public view returns(uint64) {\n        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;\n    }\n\n    /// @notice request withdraw to be eligible for withdrawal after currentEpoch\n    /// @dev prior withdrawal request will be overwritten\n    /// @param _pid pid to withdraw\n    /// @param _amount amount to request withdrawal\n    function requestWithdraw(uint256 _pid, uint256 _amount) external {\n        require(_amount <= uint256(deposits[_pid][msg.sender].amount), \"too much\");\n        withdrawRequest[_pid][msg.sender] = WithdrawRequest({\n            epoch : currentEpoch(),\n            amount : uint192(_amount)\n        });\n    }\n}\n\n\n",
        "CodeNames": [
            "StakingRewards.sol",
            "ConvexStakingWrapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StakingRewards.sol and ConvexStakingWrapper.sol",
                "Type": "Double Rewards",
                "Description": "Users can continue claiming Concur rewards after the shelter has been activated, resulting in double the amount of rewards they should be receiving.",
                "Repair": "Ensure that staking tokens cannot be deposited in both the StakingRewards.sol and ConvexStakingWrapper.sol contracts. If this is intended behaviour, it may be worthwhile to ensure that the sheltered users have their deposited balance wiped from the MasterChef.sol contract upon being sheltered."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed _user, uint indexed _pid, uint _amount);\n    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);\n    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);\n\n    struct UserInfo {\n        uint128 amount; // How many tokens the user has provided.\n        uint128 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of RADSs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.\n        uint lastRewardBlock; // Last block number that distribution occurs.\n        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.\n        uint16 depositFeeBP; // Deposit fee in basis points\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.\n    mapping(address => bool) public isDepositor;\n    mapping(address => uint256) public pid; // pid mapped to token\n    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block\n    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint public startBlock;\n    uint public endBlock; // The block number when mining starts.\n    IERC20 public concur;\n\n    uint private _concurShareMultiplier = 1e18;\n    uint private _perMille = 1000; // 100%\n\n    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        concur = _concur;\n        poolInfo.push(\n            PoolInfo({\n            depositToken: IERC20(address(0)),\n            allocPoint : 0,\n            lastRewardBlock : _startBlock,\n            accConcurPerShare : 0,\n            depositFeeBP : 0\n        }));\n    }\n\n    modifier onlyDepositor() {\n        require(isDepositor[msg.sender], \"!depositor\");\n        _;\n    }\n\n    function addDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = true;\n    }\n\n    function removeDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = false;\n    }\n\n    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {\n        require(_token != address(0), \"zero address\");\n        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocationPoints);\n        require(pid[_token] == 0, \"already registered\"); // pid starts from 0\n        poolInfo.push(\n            PoolInfo({\n                depositToken: IERC20(_token),\n                allocPoint: _allocationPoints,\n                lastRewardBlock: lastRewardBlock,\n                accConcurPerShare: 0,\n                depositFeeBP: _depositFee\n            })\n        );\n        pid[_token] = poolInfo.length - 1;\n    }\n\n    function poolLength() external view returns (uint) {\n        return poolInfo.length;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint _from, uint _to) public pure returns (uint) {\n        return _to.sub(_from);\n    }\n\n    // View function to see pending [concur] on frontend.\n    function pendingConcur(uint _pid, address _user) external view returns (uint) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint accConcurPerShare = pool.accConcurPerShare;\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        }\n        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint length = poolInfo.length;\n        for (uint _pid = 0; _pid < length; ++_pid) {\n            updatePool(_pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        if(block.number >= endBlock) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }        \n\n        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit tokens for [concur] allocation.  \n    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        updatePool(_pid);\n       \n        if(user.amount > 0) {  \n            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n            if (pending > 0) {\n                safeConcurTransfer(_recipient, pending);\n            }\n        }\n\n        if (_amount > 0) {\n            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n            } else {\n                user.amount = SafeCast.toUint128(user.amount + _amount);\n            }\n        }     \n\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Deposit(_recipient, _pid, _amount);\n    }\n\n    // Withdraw tokens\n    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        require(user.amount > 0, \"MasterChef: nothing to withdraw\");\n        require(user.amount >= _amount, \"MasterChef: withdraw not allowed\");\n        updatePool(_pid);\n\n        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n        if(pending > 0) {\n            safeConcurTransfer(_recipient, pending);\n        }\n        if (_amount > 0) {\n            user.amount = SafeCast.toUint128(user.amount - _amount);\n        }\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Withdraw(_recipient, _pid, _amount);\n    }\n\n    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        bool transferSuccess = false;\n        if (_amount > concurBalance) {\n            transferSuccess = concur.transfer(_to, concurBalance);\n        } else {\n            transferSuccess = concur.transfer(_to, _amount);\n        }\n        require(transferSuccess, \"safeConcurTransfer: transfer failed\");\n    }\n}\n\n\n",
        "CodeNames": [
            "MasterChef.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MasterChef.sol#L86",
                "Type": "Incorrect Reward Token Calculation",
                "Description": "When adding a new token pool for staking in MasterChef contract, all other already added pools should be updated but currently they are not, resulting in user rewards not being computed correctly.",
                "Repair": "Update all existing pools before adding new pool. Use the massUdpate() function which is already present ... but unused."
            },
            {
                "Location": "MasterChef.sol#L78-L80, MasterChef.sol#L157-L180",
                "Type": "Admin Privilege",
                "Description": "Owner can steal Concur rewards by adding a depositor and inflating other depositors' assigned balance of the token within the contract.",
                "Repair": "Set an immutable depositor instead of allowing any contract to become a depositor, ask the depositor contract for the total supply instead of expecting lpTokens to be in the Masterchef"
            },
            {
                "Location": "MasterChef.sol",
                "Type": "Logical Flaw",
                "Description": "Users won't be able to receive the Concur rewards.",
                "Repair": "Create a receipt token to represent the invested token and use the receipt tokens in MasterChef"
            },
            {
                "Location": "MasterChef.sol#L82-L84",
                "Type": "Malicious Owner",
                "Description": "Owner can lock tokens in MasterChef.",
                "Repair": "Have an immutable depositor that can't be changed"
            },
            {
                "Location": "MasterChef.sol#L205-L206",
                "Type": "Incorrect reward distribution",
                "Description": "During stake or deposit, users would not be rewarded the correct Concur token, when MasterChef has under-supply of it.",
                "Repair": "Add a require statement to the MasterChef.safeConcurTransfer function to check if the balance is zero before transferring Concur tokens"
            },
            {
                "Location": "MasterChef.sol#L170-L172",
                "Type": "Improper handling of deposit fee",
                "Description": "Improper handling of deposit fee can lead to permanent lockups of deposit fees in the relevant depositor contracts.",
                "Repair": "Transfer the fee to a feeReceiver or add a way to pull those fees."
            },
            {
                "Location": "MasterChef.sol deposit() function",
                "Type": "Arbitrary Deposit Amount",
                "Description": "A depositor can deposit an arbitrary amount without any cost, allowing a malicious/compromised depositor to take the majority share of all pools simply by calling deposit() with extremely large amounts, and take all the rewards.",
                "Repair": "Remove the depositor role or add a limit to the deposit amount parameter"
            },
            {
                "Location": "MasterChef.sol#L86-L101",
                "Type": "Unconstrained fee",
                "Description": "Token fee in MasterChef can be set to more than 100%, (for example, by accident) causing all deposit calls to fail due to underflow on subtraction when reward is lowered by the fee, thus breaking essential mechanics.",
                "Repair": "Ensure that the fee is below a set maximum, which is set to no more than 100%"
            },
            {
                "Location": "MasterChef.sol#L135-L154",
                "Type": "Failure to update reward variables",
                "Description": "The updatePool function intends to calculate the accumulated Concur rewards by tracking the number of blocks passed since the last update to correctly determine how many Concur tokens to distribute to each share. The reward distribution has a start and end block which dictates the timeframe by which rewards will be distributed to the underlying pool.",
                "Repair": "Ensure that once the block.number = endBlock statement has been reached, the pool.accConcurPerShare is updated to reflect the number of blocks that have passed up until endBlock"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./MasterChef.sol\";\n\ncontract StakingRewards is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    MasterChef public immutable masterChef;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 7 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    address public rewardsDistribution;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        MasterChef _masterChef\n    ) {\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        masterChef = _masterChef;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / _totalSupply);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            (_balances[account] *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) /\n            1e18 +\n            rewards[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate * rewardsDuration;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.deposit(msg.sender, pid, amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.withdraw(msg.sender, pid, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        updateReward(address(0))\n    {\n        require(\n            msg.sender == rewardsDistribution,\n            \"Caller is not RewardsDistribution contract\"\n        );\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance / rewardsDuration,\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    function setRewardsDistribution(address _rewardsDistribution)\n        external\n        onlyOwner\n    {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDistribution = _rewardsDistribution;\n        emit RewardsDistributionUpdated(rewardsDistribution);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event RewardsDistributionUpdated(address indexed newDistribution);\n    event Recovered(address token, uint256 amount);\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./external/ConvexInterfaces.sol\";\nimport \"./interfaces/IConcurRewardClaim.sol\";\nimport \"./MasterChef.sol\";\n\ncontract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    struct RewardType {\n        address token;\n        address pool;\n        uint128 integral;\n        uint128 remaining;\n    }\n\n    struct Reward {\n        uint128 integral;\n    }\n\n    //constants/immutables\n    address public constant convexBooster =\n        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv =\n        address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx =\n        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n\n    uint256 public constant CRV_INDEX = 0;\n    uint256 public constant CVX_INDEX = 1;\n    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000\n    MasterChef public immutable masterChef;\n\n    //convex rewards\n    mapping(uint256 => address) public convexPool;\n    mapping(uint256 => RewardType[]) public rewards;\n    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))\n        public userReward;\n    mapping(uint256 => mapping(address => uint256)) public registeredRewards;\n\n    //management\n    address public treasury;\n    IConcurRewardClaim public claimContract;\n\n    struct Deposit {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    struct WithdrawRequest {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    mapping(address => uint256) public pids;\n    mapping(uint256 => mapping(address => Deposit)) public deposits;\n    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;\n\n    event Deposited(address indexed _user, uint256 _amount);\n    event Withdrawn(address indexed _user, uint256 _amount);\n\n    constructor(address _treasury, MasterChef _masterChef) {\n        treasury = _treasury;\n        masterChef = _masterChef;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n    }\n\n    function setRewardPool(address _claimContract) external onlyOwner {\n        claimContract = IConcurRewardClaim(_claimContract);\n    }\n\n    /// @notice function to bootstrap the reward pool and extra rewards of convex booster\n    /// @dev should be able to be called more than once\n    /// @param _pid pid of the curve lp. same as convex booster pid\n    function addRewards(uint256 _pid) public {\n        address mainPool = IRewardStaking(convexBooster)\n            .poolInfo(_pid)\n            .crvRewards;\n        if (rewards[_pid].length == 0) {\n            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;\n            convexPool[_pid] = mainPool;\n            rewards[_pid].push(\n                RewardType({\n                    token: crv,\n                    pool: mainPool,\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            rewards[_pid].push(\n                RewardType({\n                    token: cvx,\n                    pool: address(0),\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1\n            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        for (uint256 i = 0; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            address extraToken = IRewardStaking(extraPool).rewardToken();\n            if (extraToken == cvx) {\n                //no-op for cvx, crv rewards\n                rewards[_pid][CVX_INDEX].pool = extraPool;\n            } else if (registeredRewards[_pid][extraToken] == 0) {\n                //add new token to list\n                rewards[_pid].push(\n                    RewardType({\n                        token: IRewardStaking(extraPool).rewardToken(),\n                        pool: extraPool,\n                        integral: 0,\n                        remaining: 0\n                    })\n                );\n                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1\n            }\n        }\n    }\n\n    function rewardLength(uint256 _pid) external view returns (uint256) {\n        return rewards[_pid].length;\n    }\n\n    function _getDepositedBalance(uint256 _pid, address _account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return deposits[_pid][_account].amount;\n    }\n\n    function _getTotalSupply(uint256 _pid)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));\n    }\n\n    function _calcRewardIntegral(\n        uint256 _pid,\n        uint256 _index,\n        address _account,\n        uint256 _balance,\n        uint256 _supply\n    ) internal {\n        RewardType memory reward = rewards[_pid][_index];\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.token).balanceOf(address(this));\n        uint256 d_reward = bal - reward.remaining;\n        // send 20 % of cvx / crv reward to treasury\n        if (reward.token == cvx || reward.token == crv) {\n            IERC20(reward.token).transfer(treasury, d_reward / 5);\n            d_reward = (d_reward * 4) / 5;\n        }\n        IERC20(reward.token).transfer(address(claimContract), d_reward);\n\n        if (_supply > 0 && d_reward > 0) {\n            reward.integral =\n                reward.integral +\n                uint128((d_reward * 1e20) / _supply);\n        }\n\n        //update user integrals\n        uint256 userI = userReward[_pid][_index][_account].integral;\n        if (userI < reward.integral) {\n            userReward[_pid][_index][_account].integral = reward.integral;\n            claimContract.pushReward(\n                _account,\n                reward.token,\n                (_balance * (reward.integral - userI)) / 1e20\n            );\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != reward.remaining) {\n            reward.remaining = uint128(bal);\n        }\n\n        rewards[_pid][_index] = reward;\n    }\n\n    function _checkpoint(uint256 _pid, address _account) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (paused()) return;\n\n        uint256 supply = _getTotalSupply(_pid);\n        uint256 depositedBalance = _getDepositedBalance(_pid, _account);\n\n        IRewardStaking(convexPool[_pid]).getReward(address(this), true);\n\n        uint256 rewardCount = rewards[_pid].length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);\n        }\n    }\n\n    /// @notice deposit curve lp token\n    /// @dev should approve curve lp token to this address before calling this function\n    /// @param _pid pid to deposit, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        whenNotPaused\n        nonReentrant\n    {\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].epoch = currentEpoch();\n        deposits[_pid][msg.sender].amount += uint192(_amount);\n        if (_amount > 0) {\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n\n            lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n            lpToken.safeApprove(convexBooster, _amount);\n            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);\n            lpToken.safeApprove(convexBooster, 0);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.deposit(msg.sender, pid, _amount);\n        }\n\n        emit Deposited(msg.sender, _amount);\n    }\n\n    /// @notice withdraw curve lp token\n    /// @dev should request withdraw before calling this function\n    /// @param _pid pid to withdraw, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {\n        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];\n        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");\n        require(request.amount >= _amount, \"too much\");\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].amount -= uint192(_amount);\n        if (_amount > 0) {\n            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n            lpToken.safeTransfer(msg.sender, _amount);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.withdraw(msg.sender, pid, _amount);\n        }\n        delete withdrawRequest[_pid][msg.sender];\n        //events\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    /// @notice epoch for voting cycle\n    /// @return returns the epoch in uint64 type\n    function currentEpoch() public view returns(uint64) {\n        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;\n    }\n\n    /// @notice request withdraw to be eligible for withdrawal after currentEpoch\n    /// @dev prior withdrawal request will be overwritten\n    /// @param _pid pid to withdraw\n    /// @param _amount amount to request withdrawal\n    function requestWithdraw(uint256 _pid, uint256 _amount) external {\n        require(_amount <= uint256(deposits[_pid][msg.sender].amount), \"too much\");\n        withdrawRequest[_pid][msg.sender] = WithdrawRequest({\n            epoch : currentEpoch(),\n            amount : uint192(_amount)\n        });\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed _user, uint indexed _pid, uint _amount);\n    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);\n    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);\n\n    struct UserInfo {\n        uint128 amount; // How many tokens the user has provided.\n        uint128 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of RADSs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.\n        uint lastRewardBlock; // Last block number that distribution occurs.\n        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.\n        uint16 depositFeeBP; // Deposit fee in basis points\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.\n    mapping(address => bool) public isDepositor;\n    mapping(address => uint256) public pid; // pid mapped to token\n    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block\n    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint public startBlock;\n    uint public endBlock; // The block number when mining starts.\n    IERC20 public concur;\n\n    uint private _concurShareMultiplier = 1e18;\n    uint private _perMille = 1000; // 100%\n\n    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        concur = _concur;\n        poolInfo.push(\n            PoolInfo({\n            depositToken: IERC20(address(0)),\n            allocPoint : 0,\n            lastRewardBlock : _startBlock,\n            accConcurPerShare : 0,\n            depositFeeBP : 0\n        }));\n    }\n\n    modifier onlyDepositor() {\n        require(isDepositor[msg.sender], \"!depositor\");\n        _;\n    }\n\n    function addDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = true;\n    }\n\n    function removeDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = false;\n    }\n\n    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {\n        require(_token != address(0), \"zero address\");\n        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocationPoints);\n        require(pid[_token] == 0, \"already registered\"); // pid starts from 0\n        poolInfo.push(\n            PoolInfo({\n                depositToken: IERC20(_token),\n                allocPoint: _allocationPoints,\n                lastRewardBlock: lastRewardBlock,\n                accConcurPerShare: 0,\n                depositFeeBP: _depositFee\n            })\n        );\n        pid[_token] = poolInfo.length - 1;\n    }\n\n    function poolLength() external view returns (uint) {\n        return poolInfo.length;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint _from, uint _to) public pure returns (uint) {\n        return _to.sub(_from);\n    }\n\n    // View function to see pending [concur] on frontend.\n    function pendingConcur(uint _pid, address _user) external view returns (uint) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint accConcurPerShare = pool.accConcurPerShare;\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        }\n        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint length = poolInfo.length;\n        for (uint _pid = 0; _pid < length; ++_pid) {\n            updatePool(_pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        if(block.number >= endBlock) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }        \n\n        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit tokens for [concur] allocation.  \n    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        updatePool(_pid);\n       \n        if(user.amount > 0) {  \n            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n            if (pending > 0) {\n                safeConcurTransfer(_recipient, pending);\n            }\n        }\n\n        if (_amount > 0) {\n            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n            } else {\n                user.amount = SafeCast.toUint128(user.amount + _amount);\n            }\n        }     \n\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Deposit(_recipient, _pid, _amount);\n    }\n\n    // Withdraw tokens\n    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        require(user.amount > 0, \"MasterChef: nothing to withdraw\");\n        require(user.amount >= _amount, \"MasterChef: withdraw not allowed\");\n        updatePool(_pid);\n\n        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n        if(pending > 0) {\n            safeConcurTransfer(_recipient, pending);\n        }\n        if (_amount > 0) {\n            user.amount = SafeCast.toUint128(user.amount - _amount);\n        }\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Withdraw(_recipient, _pid, _amount);\n    }\n\n    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        bool transferSuccess = false;\n        if (_amount > concurBalance) {\n            transferSuccess = concur.transfer(_to, concurBalance);\n        } else {\n            transferSuccess = concur.transfer(_to, _amount);\n        }\n        require(transferSuccess, \"safeConcurTransfer: transfer failed\");\n    }\n}\n\n\n",
        "CodeNames": [
            "StakingRewards.sol",
            "ConvexStakingWrapper.sol",
            "MasterChef.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Multiple locations in StakingRewards.sol, ConvexStakingWrapper.sol, and MasterChef.sol",
                "Type": "Smart Contract",
                "Description": "Various vulnerabilities in the smart contracts that can lead to dilution of reward rate, siphoning rewards from other pools, disruption of rewards distribution, and dilution of rewards due to totalAllocPoint only increasing.",
                "Repair": "Add functionality for removing pool or setting pool's totalAllocPoint param, redesign mechanism to ensure each pool is allocated only a fraction of the total rewards instead of the change in contract balance, consider keeping the rewardRate constant but extend periodFinish time by += reward / rewardRate, wrap a certain amount of initial totalSupply at deployment and never burn it, use uint256 instead of uint128 for reward.integral, lower 1e20 down to 1e12, check transfer to treasury has succeeded before updating accounting"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./external/ConvexInterfaces.sol\";\nimport \"./interfaces/IConcurRewardClaim.sol\";\nimport \"./MasterChef.sol\";\n\ncontract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    struct RewardType {\n        address token;\n        address pool;\n        uint128 integral;\n        uint128 remaining;\n    }\n\n    struct Reward {\n        uint128 integral;\n    }\n\n    //constants/immutables\n    address public constant convexBooster =\n        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv =\n        address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx =\n        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n\n    uint256 public constant CRV_INDEX = 0;\n    uint256 public constant CVX_INDEX = 1;\n    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000\n    MasterChef public immutable masterChef;\n\n    //convex rewards\n    mapping(uint256 => address) public convexPool;\n    mapping(uint256 => RewardType[]) public rewards;\n    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))\n        public userReward;\n    mapping(uint256 => mapping(address => uint256)) public registeredRewards;\n\n    //management\n    address public treasury;\n    IConcurRewardClaim public claimContract;\n\n    struct Deposit {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    struct WithdrawRequest {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    mapping(address => uint256) public pids;\n    mapping(uint256 => mapping(address => Deposit)) public deposits;\n    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;\n\n    event Deposited(address indexed _user, uint256 _amount);\n    event Withdrawn(address indexed _user, uint256 _amount);\n\n    constructor(address _treasury, MasterChef _masterChef) {\n        treasury = _treasury;\n        masterChef = _masterChef;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n    }\n\n    function setRewardPool(address _claimContract) external onlyOwner {\n        claimContract = IConcurRewardClaim(_claimContract);\n    }\n\n    /// @notice function to bootstrap the reward pool and extra rewards of convex booster\n    /// @dev should be able to be called more than once\n    /// @param _pid pid of the curve lp. same as convex booster pid\n    function addRewards(uint256 _pid) public {\n        address mainPool = IRewardStaking(convexBooster)\n            .poolInfo(_pid)\n            .crvRewards;\n        if (rewards[_pid].length == 0) {\n            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;\n            convexPool[_pid] = mainPool;\n            rewards[_pid].push(\n                RewardType({\n                    token: crv,\n                    pool: mainPool,\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            rewards[_pid].push(\n                RewardType({\n                    token: cvx,\n                    pool: address(0),\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1\n            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        for (uint256 i = 0; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            address extraToken = IRewardStaking(extraPool).rewardToken();\n            if (extraToken == cvx) {\n                //no-op for cvx, crv rewards\n                rewards[_pid][CVX_INDEX].pool = extraPool;\n            } else if (registeredRewards[_pid][extraToken] == 0) {\n                //add new token to list\n                rewards[_pid].push(\n                    RewardType({\n                        token: IRewardStaking(extraPool).rewardToken(),\n                        pool: extraPool,\n                        integral: 0,\n                        remaining: 0\n                    })\n                );\n                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1\n            }\n        }\n    }\n\n    function rewardLength(uint256 _pid) external view returns (uint256) {\n        return rewards[_pid].length;\n    }\n\n    function _getDepositedBalance(uint256 _pid, address _account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return deposits[_pid][_account].amount;\n    }\n\n    function _getTotalSupply(uint256 _pid)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));\n    }\n\n    function _calcRewardIntegral(\n        uint256 _pid,\n        uint256 _index,\n        address _account,\n        uint256 _balance,\n        uint256 _supply\n    ) internal {\n        RewardType memory reward = rewards[_pid][_index];\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.token).balanceOf(address(this));\n        uint256 d_reward = bal - reward.remaining;\n        // send 20 % of cvx / crv reward to treasury\n        if (reward.token == cvx || reward.token == crv) {\n            IERC20(reward.token).transfer(treasury, d_reward / 5);\n            d_reward = (d_reward * 4) / 5;\n        }\n        IERC20(reward.token).transfer(address(claimContract), d_reward);\n\n        if (_supply > 0 && d_reward > 0) {\n            reward.integral =\n                reward.integral +\n                uint128((d_reward * 1e20) / _supply);\n        }\n\n        //update user integrals\n        uint256 userI = userReward[_pid][_index][_account].integral;\n        if (userI < reward.integral) {\n            userReward[_pid][_index][_account].integral = reward.integral;\n            claimContract.pushReward(\n                _account,\n                reward.token,\n                (_balance * (reward.integral - userI)) / 1e20\n            );\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != reward.remaining) {\n            reward.remaining = uint128(bal);\n        }\n\n        rewards[_pid][_index] = reward;\n    }\n\n    function _checkpoint(uint256 _pid, address _account) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (paused()) return;\n\n        uint256 supply = _getTotalSupply(_pid);\n        uint256 depositedBalance = _getDepositedBalance(_pid, _account);\n\n        IRewardStaking(convexPool[_pid]).getReward(address(this), true);\n\n        uint256 rewardCount = rewards[_pid].length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);\n        }\n    }\n\n    /// @notice deposit curve lp token\n    /// @dev should approve curve lp token to this address before calling this function\n    /// @param _pid pid to deposit, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        whenNotPaused\n        nonReentrant\n    {\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].epoch = currentEpoch();\n        deposits[_pid][msg.sender].amount += uint192(_amount);\n        if (_amount > 0) {\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n\n            lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n            lpToken.safeApprove(convexBooster, _amount);\n            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);\n            lpToken.safeApprove(convexBooster, 0);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.deposit(msg.sender, pid, _amount);\n        }\n\n        emit Deposited(msg.sender, _amount);\n    }\n\n    /// @notice withdraw curve lp token\n    /// @dev should request withdraw before calling this function\n    /// @param _pid pid to withdraw, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {\n        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];\n        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");\n        require(request.amount >= _amount, \"too much\");\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].amount -= uint192(_amount);\n        if (_amount > 0) {\n            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n            lpToken.safeTransfer(msg.sender, _amount);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.withdraw(msg.sender, pid, _amount);\n        }\n        delete withdrawRequest[_pid][msg.sender];\n        //events\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    /// @notice epoch for voting cycle\n    /// @return returns the epoch in uint64 type\n    function currentEpoch() public view returns(uint64) {\n        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;\n    }\n\n    /// @notice request withdraw to be eligible for withdrawal after currentEpoch\n    /// @dev prior withdrawal request will be overwritten\n    /// @param _pid pid to withdraw\n    /// @param _amount amount to request withdrawal\n    function requestWithdraw(uint256 _pid, uint256 _amount) external {\n        require(_amount <= uint256(deposits[_pid][msg.sender].amount), \"too much\");\n        withdrawRequest[_pid][msg.sender] = WithdrawRequest({\n            epoch : currentEpoch(),\n            amount : uint192(_amount)\n        });\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed _user, uint indexed _pid, uint _amount);\n    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);\n    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);\n\n    struct UserInfo {\n        uint128 amount; // How many tokens the user has provided.\n        uint128 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of RADSs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.\n        uint lastRewardBlock; // Last block number that distribution occurs.\n        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.\n        uint16 depositFeeBP; // Deposit fee in basis points\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.\n    mapping(address => bool) public isDepositor;\n    mapping(address => uint256) public pid; // pid mapped to token\n    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block\n    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint public startBlock;\n    uint public endBlock; // The block number when mining starts.\n    IERC20 public concur;\n\n    uint private _concurShareMultiplier = 1e18;\n    uint private _perMille = 1000; // 100%\n\n    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        concur = _concur;\n        poolInfo.push(\n            PoolInfo({\n            depositToken: IERC20(address(0)),\n            allocPoint : 0,\n            lastRewardBlock : _startBlock,\n            accConcurPerShare : 0,\n            depositFeeBP : 0\n        }));\n    }\n\n    modifier onlyDepositor() {\n        require(isDepositor[msg.sender], \"!depositor\");\n        _;\n    }\n\n    function addDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = true;\n    }\n\n    function removeDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = false;\n    }\n\n    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {\n        require(_token != address(0), \"zero address\");\n        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocationPoints);\n        require(pid[_token] == 0, \"already registered\"); // pid starts from 0\n        poolInfo.push(\n            PoolInfo({\n                depositToken: IERC20(_token),\n                allocPoint: _allocationPoints,\n                lastRewardBlock: lastRewardBlock,\n                accConcurPerShare: 0,\n                depositFeeBP: _depositFee\n            })\n        );\n        pid[_token] = poolInfo.length - 1;\n    }\n\n    function poolLength() external view returns (uint) {\n        return poolInfo.length;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint _from, uint _to) public pure returns (uint) {\n        return _to.sub(_from);\n    }\n\n    // View function to see pending [concur] on frontend.\n    function pendingConcur(uint _pid, address _user) external view returns (uint) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint accConcurPerShare = pool.accConcurPerShare;\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        }\n        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint length = poolInfo.length;\n        for (uint _pid = 0; _pid < length; ++_pid) {\n            updatePool(_pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        if(block.number >= endBlock) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }        \n\n        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit tokens for [concur] allocation.  \n    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        updatePool(_pid);\n       \n        if(user.amount > 0) {  \n            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n            if (pending > 0) {\n                safeConcurTransfer(_recipient, pending);\n            }\n        }\n\n        if (_amount > 0) {\n            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n            } else {\n                user.amount = SafeCast.toUint128(user.amount + _amount);\n            }\n        }     \n\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Deposit(_recipient, _pid, _amount);\n    }\n\n    // Withdraw tokens\n    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        require(user.amount > 0, \"MasterChef: nothing to withdraw\");\n        require(user.amount >= _amount, \"MasterChef: withdraw not allowed\");\n        updatePool(_pid);\n\n        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n        if(pending > 0) {\n            safeConcurTransfer(_recipient, pending);\n        }\n        if (_amount > 0) {\n            user.amount = SafeCast.toUint128(user.amount - _amount);\n        }\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Withdraw(_recipient, _pid, _amount);\n    }\n\n    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        bool transferSuccess = false;\n        if (_amount > concurBalance) {\n            transferSuccess = concur.transfer(_to, concurBalance);\n        } else {\n            transferSuccess = concur.transfer(_to, _amount);\n        }\n        require(transferSuccess, \"safeConcurTransfer: transfer failed\");\n    }\n}\n\n\n",
        "CodeNames": [
            "ConvexStakingWrapper.sol",
            "MasterChef.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ConvexStakingWrapper.sol, MasterChef.sol",
                "Type": "Loss of Yield",
                "Description": "Users Will Lose Concur Rewards If The Shelter Mechanism Is Enacted On A Pool.",
                "Repair": "Remove sheltered pools from the MasterChef.sol Concur token distribution, create a sweep mechanism which can be called by the contract owner"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/Iauction.sol\";\n\ncontract VoteProxy is Ownable {\n    Iauction public auctioneer;\n\n    function updateAuctioneer(address _auctioneer) external onlyOwner {\n        auctioneer = Iauction(_auctioneer);\n    }\n\n    function isValidSignature(bytes32 _hash, bytes calldata _signature)\n        external\n        view\n        returns (bytes4)\n    {\n        // Validate signatures\n        if (auctioneer.isWinningSignature(_hash, _signature) == true) {\n            return 0x1626ba7e;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external onlyOwner returns (bool, bytes memory) {\n        (bool success, bytes memory result) = _to.call{value: _value}(_data);\n        return (success, result);\n    }\n}\n\n\n",
        "CodeNames": [
            "VoteProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VoteProxy.sol#L28-L35",
                "Type": "Non-payable function",
                "Description": "execute will revert when msg.value < 0. Lacking payable mutability specifier.",
                "Repair": "Add payable mutability specifier"
            }
        ]
    }
]