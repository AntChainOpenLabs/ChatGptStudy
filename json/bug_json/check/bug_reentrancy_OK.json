[
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24;\n    uint256 private constant BLOCK_DECREMENT = 10000;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    bool public override initialized;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(!initialized);\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basketAsERC20.transfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty memory bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-09-defiProtocol-findings.json",
                "Location": "settleAuction() function in Auction.sol",
                "Type": "Reentrancy",
                "Description": "The function calls withdrawBounty() before setting auctionOngoing = false, allowing reentrancy and enabling a malicious publisher to bypass the index timelock mechanism and rug the basket.",
                "Repair": "Move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IDue} from './interfaces/IDue.sol';\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport {IConvenience} from './interfaces/IConvenience.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC721Permit} from './base/ERC721Permit.sol';\nimport {SafeMetadata} from './libraries/SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {NFTTokenURIScaffold} from './libraries/NFTTokenURIScaffold.sol';\n\ncontract CollateralizedDebt is IDue, ERC721Permit {\n    using Strings for uint256;\n    using SafeMetadata for IERC20;\n\n    IConvenience public immutable override convenience;\n    IPair public immutable override pair;\n    uint256 public immutable override maturity;\n\n    function name() external view override returns (string memory) {\n        string memory assetName = pair.asset().safeName();\n        string memory collateralName = pair.collateral().safeName();\n        return\n            string(\n                abi.encodePacked(\n                    'Timeswap Collateralized Debt - ',\n                    assetName,\n                    ' - ',\n                    collateralName,\n                    ' - ',\n                    maturity.toString()\n                )\n            );\n    }\n\n    function symbol() external view override returns (string memory) {\n        string memory assetSymbol = pair.asset().safeSymbol();\n        string memory collateralSymbol = pair.collateral().safeSymbol();\n        return string(abi.encodePacked('TS-CDT-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));\n    }\n\n    function tokenURI(uint256 id) external view override returns (string memory) {\n        require(ownerOf[id] != address(0), 'E404');\n        return NFTTokenURIScaffold.tokenURI(id, pair, dueOf(id), maturity);\n    }\n\n    function assetDecimals() external view override returns (uint8) {\n        return pair.asset().safeDecimals();\n    }\n\n    function collateralDecimals() external view override returns (uint8) {\n        return pair.collateral().safeDecimals();\n    }\n\n    function dueOf(uint256 id) public view override returns (IPair.Due memory) {\n        return pair.dueOf(maturity, address(this), id);\n    }\n\n    constructor(\n        IConvenience _convenience,\n        IPair _pair,\n        uint256 _maturity\n    ) ERC721Permit('Timeswap Collateralized Debt') {\n        convenience = _convenience;\n        pair = _pair;\n        maturity = _maturity;\n    }\n\n    modifier onlyConvenience() {\n        require(msg.sender == address(convenience), 'E403');\n        _;\n    }\n\n    function mint(address to, uint256 id) external override onlyConvenience {\n        _safeMint(to, id);\n    }\n\n    function burn(\n        address to,\n        uint256[] memory ids,\n        uint112[] memory assetsIn,\n        uint112[] memory collateralsOut,\n        bytes calldata data\n    ) external override onlyConvenience returns (uint128 assetIn, uint128 collateralOut) {\n        (assetIn, collateralOut) = pair.pay(maturity, to, address(this), ids, assetsIn, collateralsOut, data);\n    }\n\n    function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {\n        require(msg.sender == address(pair), 'E401');\n\n        convenience.collateralizedDebtCallback(pair, maturity, assetIn, data);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-timeswap-findings.json",
                "Location": "CollateralizedDebt.sol#mint()",
                "Type": "Reentrancy",
                "Description": "Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.",
                "Repair": "Add a reentrancy guard modifier on the mint() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IShelter } from \"./interfaces/IShelter.sol\";\nimport { IShelterClient } from \"./interfaces/IShelterClient.sol\";\n\ncontract Shelter is IShelter {\n    using SafeERC20 for IERC20;\n\n    IShelterClient public immutable client;\n\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    mapping(IERC20 => mapping(address => bool)) public override claimed;\n\n    mapping(IERC20 => uint256) public activated;\n\n    mapping(IERC20 => uint256) public savedTokens;\n\n    modifier onlyClient {\n        require(msg.sender == address(client), \"!client\");\n        _;\n    }\n\n    constructor(IShelterClient _client){\n        client = _client;\n    }\n\n    function donate(IERC20 _token, uint256 _amount) external {\n        require(activated[_token] != 0, \"!activated\");\n        savedTokens[_token] += _amount;\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function activate(IERC20 _token) external override onlyClient {\n        activated[_token] = block.timestamp;\n        savedTokens[_token] = _token.balanceOf(address(this));\n        emit ShelterActivated(_token);\n    }\n\n    function deactivate(IERC20 _token) external override onlyClient {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\");\n        activated[_token] = 0;\n        savedTokens[_token] = 0;\n        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));\n        emit ShelterDeactivated(_token);\n    }\n\n    function withdraw(IERC20 _token, address _to) external override {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, \"shelter not activated\");\n        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);\n        claimed[_token][_to] = true;\n        emit ExitShelter(_token, msg.sender, _to, amount);\n        _token.safeTransfer(_to, amount);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-02-concur-findings.json",
                "Location": "Shelter.sol withdraw() function",
                "Type": "Reentrancy",
                "Description": "Repeated calls to Shelter.withdraw can drain all funds in Shelter, allowing an attacker that can successfully call withdraw() once on a shelter, to call it repeatedly to steal the funds of others.",
                "Repair": "Check claims against msg.sender and record who is withdrawing"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IConcurRewardClaim} from \"./interfaces/IConcurRewardClaim.sol\";\n\ncontract ConcurRewardPool is IConcurRewardClaim {\n    using SafeERC20 for IERC20;\n    address public immutable rewardNotifier;\n\n    mapping(address => mapping(address => uint256)) public reward;\n\n    constructor(address _notifier) {\n        rewardNotifier = _notifier;\n    }\n\n    /// @notice push reward to `_recipient`\n    /// @param _recipient reward recipient address\n    /// @param _token token to reward\n    /// @param _amount amount of tokens to allocate to `_recipient`\n    function pushReward(\n        address _recipient,\n        address _token,\n        uint256 _amount\n    ) external override {\n        require(msg.sender == rewardNotifier, \"!notifier\");\n        reward[_recipient][_token] += _amount;\n    }\n\n    /// @notice claim rewards of `msg.sender`\n    /// @param _tokens array of tokens to claim\n    function claimRewards(address[] calldata _tokens) external override {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 getting = reward[msg.sender][_tokens[i]];\n            IERC20(_tokens[i]).safeTransfer(msg.sender, getting);\n            reward[msg.sender][_tokens[i]] = 0;\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-02-concur-findings.json",
                "Location": "ConcurRewardPool.sol#L34",
                "Type": "Reentrancy",
                "Description": "The reward tokens are transferred before the balances are set to 0, making it possible to perform a reentrancy attack if the reward token has some kind of call back functionality.",
                "Repair": "Use a nonReentrant modifier, set balances to 0 first before disbursing the rewards"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./VestingWallet.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title BathBuddy\n * @dev *** This contract is a lightly modified version of Vesting Wallet by OpenZeppelin\n * @dev PLEASE FIND OZ DOCUMENTATION FOR THIS CONTRACT HERE: https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet\n *\n * @dev The only entrypoint used in the system is the release function called by the Bath Token. Extra care should be taken to make sure only the beneficiary can ever access the funds and send them to the withdrawer (and fee to self)\n *\n * @dev This contract handles the vesting ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract BathBuddy is IBathBuddy {\n    using SafeMath for uint256;\n\n    // Public versions of the base VestingWallet storage\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n\n    // Beneficiary must be the Bath Token vault recipient that will call release() for its withdrawer\n    address public beneficiary;\n    uint64 public start;\n    uint64 public duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint64 durationSeconds\n    ) {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        beneficiary = beneficiaryAddress;\n        start = startTimestamp;\n        duration = durationSeconds;\n    }\n\n    // OZ\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    /// @notice Log bonus token reward event\n    event LogClaimBonusToken(\n        address indexed receiver,\n        address indexed callingPool,\n        uint256 amountReceived,\n        uint256 shares,\n        IERC20 bonusToken,\n        uint256 releasableAmountToWholePool\n    );\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /// @inheritdoc IBathBuddy\n    /// @dev Added and modified release function. Should be the only callable release function\n    function release(\n        IERC20 token,\n        address recipient,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply,\n        uint256 poolFee\n    ) external override {\n        require(\n            msg.sender == beneficiary,\n            \"Caller is not the Bath Token beneficiary of these rewards\"\n        );\n        uint256 releasable = vestedAmount(\n            address(token),\n            uint64(block.timestamp)\n        ) - released(address(token));\n        if (releasable > 0) {\n            uint256 amount = releasable.mul(sharesWithdrawn).div(\n                initialTotalSupply\n            );\n            uint256 _fee = amount.mul(poolFee).div(10000);\n\n            // If FeeTo == address(this) then the fee is effectively accrued by the pool\n            // Assume the caller is the liquidity pool and they receive the fee\n            // Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy\n            // token.transfer(address(this), _fee);\n\n            uint256 amountWithdrawn = amount.sub(_fee);\n            token.transfer(recipient, amountWithdrawn);\n\n            _erc20Released[address(token)] += amount;\n            emit ERC20Released(address(token), amount);\n\n            emit LogClaimBonusToken(\n                recipient,\n                msg.sender,\n                amountWithdrawn,\n                sharesWithdrawn,\n                token,\n                releasable\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp > start + duration) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "release() function in BathBuddy.sol",
                "Type": "Reentrancy",
                "Description": "If a token with callback capabilities is used as a token to vested, then a malicious beneficiary may get the vested amount back without waiting for the vesting period. In the function release, there\u2019s no modifier to stop reentrancy, in the other contracts it would be the synchronized modifier. If a token could reenter with a hook in a malicious contract (an ERC777 token, for example, which is backwards compatible with ERC20), released token counter array wouldn\u2019t be updated, enabling the withdrawal of the vested amount before the vesting period ends.",
                "Repair": "Add a mutex such as nonReentrant, or the synchronized modifier used in the other contracts. Implement checks-effects-interactions pattern."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\ncontract BoringBatchable {\n  error BatchError(bytes innerError);\n\n  /// @dev Helper function to extract a useful revert message from a failed call.\n  /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n  function _getRevertMsg(bytes memory _returnData) internal pure {\n    // If the _res length is less than 68, then\n    // the transaction failed with custom error or silently (without a revert message)\n    if (_returnData.length < 68) revert BatchError(_returnData);\n\n    assembly {\n      // Slice the sighash.\n      _returnData := add(_returnData, 0x04)\n    }\n    revert(abi.decode(_returnData, (string))); // All that remains is the revert string\n  }\n\n  /// @notice Allows batched call to self (this contract).\n  /// @param calls An array of inputs for each call.\n  /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n  // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n  // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n  // C3: The length of the loop is fully under user control, so can't be exploited\n  // C7: Delegatecall is only used on the same contract, so it's safe\n  function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n      if (!success && revertOnFail) {\n        _getRevertMsg(result);\n      }\n    }\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-mimo-findings.json",
                "Location": "BoringBatchable contract",
                "Type": "Reentrancy",
                "Description": "Persisted msg.value in a loop of delegate calls can be used to drain ETH from your proxy",
                "Repair": "Remove payable from batch() function in BoringBatchable contract"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RealEstatePlatform {\n\n    mapping(address => uint) public propertyPrices;\n    mapping(address => uint) public ownerBalances;\n\n    function listProperty(uint price) public {\n        propertyPrices[msg.sender] = price;\n    }\n\n    function buyProperty(address payable propertyOwner) public payable {\n        require(msg.value >= propertyPrices[propertyOwner], 'Insufficient funds to buy this property.');\n\n        ownerBalances[propertyOwner] += msg.value;\n\n        (bool success,) = propertyOwner.call{value: ownerBalances[propertyOwner]}('');\n        require(success, 'Transfer failed.');\n\n        ownerBalances[propertyOwner] = 0;\n        propertyPrices[propertyOwner] = 0;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "1",
            "Location": "(bool success,) = propertyOwner.call{value: ownerBalances[propertyOwner]}('');\nrequire(success, 'Transfer failed.');",
            "Type": "Reentrancy",
            "Description": "The function buyProperty has a reentrancy vulnerability because it uses a low-level call to transfer ether to propertyOwner, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into buyProperty, it could potentially withdraw more ether than intended.",
            "Repair": "The best practice is to apply the Checks-Effects-Interactions pattern. This can be done by moving the ether transfer to the end of the function, after all the internal state has been updated. Additionally, use the transfer() function instead of call.value() to prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CryptoExchange {\n\n    mapping(address => uint) public tokenBalances;\n    mapping(address => mapping(address => uint)) public tokenAllowances;\n\n    event Deposit(address indexed user, uint amount);\n    event Withdraw(address indexed user, uint amount);\n\n    function depositTokens(address token, uint amount) public {\n        require(tokenBalances[msg.sender] >= amount, 'Insufficient token balance.');\n        tokenBalances[msg.sender] -= amount;\n        tokenAllowances[token][msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdrawTokens(address token, uint amount) public {\n        require(tokenAllowances[token][msg.sender] >= amount, 'Insufficient allowance.');\n\n        tokenAllowances[token][msg.sender] -= amount;\n        tokenBalances[msg.sender] += amount;\n\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed.');\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "2",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\nrequire(success, 'Transfer failed.');",
            "Type": "Reentrancy",
            "Description": "In the function withdrawTokens, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to msg.sender, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into withdrawTokens, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarketplace {\n\n    struct Product {\n        string name;\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Product) public products;\n\n    event ProductPurchased(uint productId, address buyer, uint price);\n\n    function addProduct(string memory name, uint price) public {\n        uint newProductId = uint(keccak256(abi.encodePacked(name, msg.sender)));\n        products[newProductId] = Product(name, price, payable(msg.sender));\n    }\n\n    function buyProduct(uint productId) public payable {\n        Product storage product = products[productId];\n\n        require(msg.value >= product.price, 'Insufficient funds to buy this product.');\n\n        (bool transferSucceeded,) = product.owner.call{value: msg.value}('');\n        require(transferSucceeded, 'Failed to transfer funds to the product owner.');\n\n        emit ProductPurchased(productId, msg.sender, msg.value);\n\n        delete products[productId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "3",
            "Location": "(bool transferSucceeded,) = product.owner.call{value: msg.value}('');\nrequire(transferSucceeded, 'Failed to transfer funds to the product owner.');",
            "Type": "Reentrancy",
            "Description": "In the function buyProduct, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the product owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into buyProduct, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DigitalBank {\n    mapping(address => uint) public accountBalances;\n    event Withdrawal(address indexed accountHolder, uint amount);\n\n    function deposit() public payable {\n        accountBalances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(accountBalances[msg.sender] >= amount, 'Insufficient funds.');\n\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Failed to transfer Ether.');\n\n        accountBalances[msg.sender] -= amount;\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function balance() public view returns (uint) {\n        return accountBalances[msg.sender];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "4",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the function withdraw, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to msg.sender, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into withdraw, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CrowdfundingCampaign {\n\n    struct Contribution {\n        uint amount;\n        address payable contributor;\n    }\n\n    mapping(uint => Contribution) public contributions;\n    uint public contributionsCount = 0;\n    uint public totalFunds = 0;\n\n    function contribute() public payable {\n        uint newContributionId = contributionsCount++;\n        contributions[newContributionId] = Contribution(msg.value, payable(msg.sender));\n        totalFunds += msg.value;\n    }\n\n    function refund(uint contributionId) public {\n        Contribution storage contrib = contributions[contributionId];\n\n        require(contrib.contributor == msg.sender, 'Not the contributor.');\n\n        (bool success,) = contrib.contributor.call{value: contrib.amount}('');\n        require(success, 'Failed to refund.');\n\n        totalFunds -= contrib.amount;\n        delete contributions[contributionId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "5",
            "Location": "(bool success,) = contrib.contributor.call{value: contrib.amount}('');\nrequire(success, 'Failed to refund.');",
            "Type": "Reentrancy",
            "Description": "In the function refund, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the contributor, which can potentially trigger the fallback function in the contributor's contract. If the contributor's contract's fallback function in turn calls back into refund, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarket {\n\n    struct Item {\n        uint price;\n        address payable seller;\n    }\n\n    mapping(uint => Item) public items;\n    uint public itemCount = 0;\n\n    function addItem(uint price) public {\n        uint newItemId = itemCount++;\n        items[newItemId] = Item(price, payable(msg.sender));\n    }\n\n    function buyItem(uint itemId) public payable {\n        Item storage item = items[itemId];\n\n        require(msg.value >= item.price, 'Not enough Ether sent.');\n\n        (bool success,) = item.seller.call{value: item.price}('');\n        require(success, 'Failed to transfer Ether to seller.');\n\n        delete items[itemId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "6",
            "Location": "(bool success,) = item.seller.call{value: item.price}('');\nrequire(success, 'Failed to transfer Ether to seller.');",
            "Type": "Reentrancy",
            "Description": "In the function buyItem, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the seller, which can potentially trigger the fallback function in the seller's contract. If the seller's contract's fallback function in turn calls back into buyItem, it could potentially purchase more items than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RealEstateAgency {\n\n    struct Property {\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Property) public properties;\n    uint public propertyCount = 0;\n\n    function listProperty(uint price) public {\n        uint newPropertyId = propertyCount++;\n        properties[newPropertyId] = Property(price, payable(msg.sender));\n    }\n\n    function purchaseProperty(uint propertyId) public payable {\n        Property storage property = properties[propertyId];\n\n        require(msg.value >= property.price, 'Not enough Ether sent.');\n\n        (bool success,) = property.owner.call{value: property.price}('');\n        require(success, 'Failed to transfer Ether to owner.');\n\n        delete properties[propertyId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "7",
            "Location": "(bool success,) = property.owner.call{value: property.price}('');\nrequire(success, 'Failed to transfer Ether to owner.');",
            "Type": "Reentrancy",
            "Description": "In the function purchaseProperty, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the property owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into purchaseProperty, it could potentially purchase more properties than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineAuction {\n\n    struct Bid {\n        uint amount;\n        address payable bidder;\n    }\n\n    mapping(uint => Bid) public bids;\n    uint public bidCount = 0;\n\n    function makeBid(uint amount) public payable {\n        uint newBidId = bidCount++;\n        bids[newBidId] = Bid(amount, payable(msg.sender));\n    }\n\n    function acceptBid(uint bidId) public {\n        Bid storage bid = bids[bidId];\n\n        (bool success,) = bid.bidder.call{value: bid.amount}('');\n        require(success, 'Failed to transfer Ether to bidder.');\n\n        delete bids[bidId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "8",
            "Location": "(bool success,) = bid.bidder.call{value: bid.amount}('');\nrequire(success, 'Failed to transfer Ether to bidder.');",
            "Type": "Reentrancy",
            "Description": "In the function acceptBid, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the bidder, which can potentially trigger the fallback function in the bidder's contract. If the bidder's contract's fallback function in turn calls back into acceptBid, it could potentially cause unexpected behavior.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarketplace {\n\n    struct Product {\n        uint price;\n        address payable seller;\n    }\n\n    mapping(uint => Product) public products;\n    uint public productCount = 0;\n\n    function listProduct(uint price) public {\n        uint newProductId = productCount++;\n        products[newProductId] = Product(price, payable(msg.sender));\n    }\n\n    function purchaseProduct(uint productId) public payable {\n        Product storage product = products[productId];\n\n        require(msg.value >= product.price, 'Not enough Ether sent.');\n\n        (bool success,) = product.seller.call{value: product.price}('');\n        require(success, 'Failed to transfer Ether to seller.');\n\n        delete products[productId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "9",
            "Location": "(bool success,) = product.seller.call{value: product.price}('');\nrequire(success, 'Failed to transfer Ether to seller.');",
            "Type": "Reentrancy",
            "Description": "In the function purchaseProduct, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the product seller, which can potentially trigger the fallback function in the seller's contract. If the seller's contract's fallback function in turn calls back into purchaseProduct, it could potentially purchase more products than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DigitalExchange {\n\n    struct Share {\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Share) public shares;\n    uint public shareCount = 0;\n\n    function listShare(uint price) public {\n        uint newShareId = shareCount++;\n        shares[newShareId] = Share(price, payable(msg.sender));\n    }\n\n    function buyShare(uint shareId) public payable {\n        Share storage share = shares[shareId];\n\n        require(msg.value >= share.price, 'Not enough Ether sent.');\n\n        (bool success,) = share.owner.call{value: share.price}('');\n        require(success, 'Failed to transfer Ether to owner.');\n\n        delete shares[shareId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "10",
            "Location": "(bool success,) = share.owner.call{value: share.price}('');\nrequire(success, 'Failed to transfer Ether to owner.');",
            "Type": "Reentrancy",
            "Description": "In the function buyShare, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the share owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into buyShare, it could potentially buy more shares than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FineArtAuction {\n\n    struct Artwork {\n        uint bid;\n        address payable artist;\n    }\n\n    mapping(uint => Artwork) public artworks;\n    uint public artworkCount = 0;\n\n    function listArtwork() public {\n        uint newArtworkId = artworkCount++;\n        artworks[newArtworkId] = Artwork(0, payable(msg.sender));\n    }\n\n    function placeBid(uint artworkId) public payable {\n        Artwork storage artwork = artworks[artworkId];\n\n        require(msg.value > artwork.bid, 'Bid is not high enough.');\n\n        (bool success,) = artwork.artist.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether to artist.');\n\n        artwork.bid = msg.value;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "11",
            "Location": "(bool success,) = artwork.artist.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether to artist.');",
            "Type": "Reentrancy",
            "Description": "In the function placeBid, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the artist, which can potentially trigger the fallback function in the artist's contract. If the artist's contract's fallback function in turn calls back into placeBid, it could potentially place more bids than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CrowdfundingCampaign {\n\n    struct Project {\n        uint fundingGoal;\n        uint amountRaised;\n        address payable creator;\n    }\n\n    mapping(uint => Project) public projects;\n    uint public projectCount = 0;\n\n    function createProject(uint fundingGoal) public {\n        uint newProjectId = projectCount++;\n        projects[newProjectId] = Project(fundingGoal, 0, payable(msg.sender));\n    }\n\n    function contribute(uint projectId) public payable {\n        Project storage project = projects[projectId];\n\n        require(msg.value + project.amountRaised <= project.fundingGoal, 'Funding goal exceeded.');\n\n        (bool success,) = project.creator.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether to project creator.');\n\n        project.amountRaised += msg.value;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "12",
            "Location": "(bool success,) = project.creator.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether to project creator.');",
            "Type": "Reentrancy",
            "Description": "In the function contribute, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the project creator, which can potentially trigger the fallback function in the creator's contract. If the creator's contract's fallback function in turn calls back into contribute, it could potentially contribute more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CapitalVenture {\n\n    struct Investor {\n        uint invested;\n        uint lastInvest;\n        address payable addr;\n    }\n\n    mapping(address => Investor) public investors;\n\n    function invest() public payable {\n        Investor storage investor = investors[msg.sender];\n        investor.addr = payable(msg.sender);\n        investor.invested += msg.value;\n        investor.lastInvest = block.timestamp;\n\n        (bool success,) = investor.addr.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether.');\n    }\n\n    function getInvestedAmount(address addr) public view returns (uint) {\n        return investors[addr].invested;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "13",
            "Location": "(bool success,) = investor.addr.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the invest function, there is a reentrancy vulnerability because it uses a low-level call to transfer ether back to the investor, potentially triggering the fallback function of the investor's contract. If the investor's contract's fallback function in turn calls back into invest, it could potentially invest more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FundRaiser {\n\n    struct Donor {\n        uint amount;\n        address payable addr;\n    }\n\n    mapping(address => Donor) public donors;\n\n    function donate() public payable {\n        Donor storage donor = donors[msg.sender];\n        donor.addr = payable(msg.sender);\n        donor.amount += msg.value;\n\n        (bool success,) = donor.addr.call{value: msg.value / 10}('');\n        require(success, 'Failed to transfer Ether.');\n    }\n\n    function getDonationAmount(address addr) public view returns (uint) {\n        return donors[addr].amount;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "14",
            "Location": "(bool success,) = donor.addr.call{value: msg.value / 10}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the donate function, there is a reentrancy vulnerability because it uses a low-level call to transfer a portion of the donated ether back to the donor, potentially triggering the fallback function of the donor's contract. If the donor's contract's fallback function in turn calls back into donate, it could potentially donate more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract MembershipClub {\n    mapping(address => uint) public memberFees;\n\n    function joinClub() public payable {\n        memberFees[msg.sender] += msg.value;\n        require(memberFees[msg.sender] >= 1 ether, 'Membership fee is at least 1 Ether');\n\n        (bool sent,) = msg.sender.call{value: msg.value / 10}('');\n        require(sent, 'Failed to send Ether');\n    }\n\n    function getFee(address member) public view returns (uint) {\n        return memberFees[member];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "15",
            "Location": "(bool sent,) = msg.sender.call{value: msg.value / 10}('');\n        require(sent, 'Failed to send Ether');",
            "Type": "Reentrancy",
            "Description": "In the joinClub function, there is a reentrancy vulnerability because it uses a low-level call to refund part of the membership fee to the caller, potentially triggering the fallback function of the caller's contract. If the caller's contract's fallback function in turn calls back into joinClub, it could potentially join the club with less fee than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AssetPortfolio {\n    mapping(address => uint) public investments;\n\n    function invest() public payable {\n        investments[msg.sender] += msg.value;\n    }\n\n    function divest(uint amount) public {\n        require(investments[msg.sender] >= amount, 'Insufficient investment');\n        investments[msg.sender] -= amount;\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed');\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "16",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed');",
            "Type": "Reentrancy",
            "Description": "In the divest function, there is a reentrancy vulnerability. Before updating the internal state (i.e., the investor's investment amount), transferring money to the investor may trigger the fallback function of his contract, which may cause the investor to withdraw more than his original investment amount if the function calls divest again.",
            "Repair": "Adopt the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract WealthManager {\n    mapping(address => uint) public deposits;\n\n    function makeDeposit() public payable {\n        deposits[msg.sender] += msg.value;\n    }\n\n    function makeWithdrawal(uint _amount) public {\n        require(deposits[msg.sender] >= _amount, 'Insufficient deposit');\n        deposits[msg.sender] -= _amount;\n        (bool success,) = msg.sender.call{value: _amount}('');\n        require(success, 'Transfer failed');\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "17",
            "Location": "(bool success,) = msg.sender.call{value: _amount}('');\n        require(success, 'Transfer failed');",
            "Type": "Reentrancy",
            "Description": "In the makeWithdrawal function, there is a reentrancy vulnerability. Before updating the internal state (i.e. the user's deposit), transferring funds to the user may trigger the fallback function of their contract, which may cause the user to withdraw more than their original deposit if the function calls makeWithdrawal again.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AssetLocker {\n    mapping(address => uint256) public assetBalance;\n\n    event AssetDeposited(address indexed depositor, uint256 amount);\n    event AssetWithdrawn(address indexed withdrawer, uint256 amount);\n\n    function depositAsset() public payable {\n        assetBalance[msg.sender] += msg.value;\n        emit AssetDeposited(msg.sender, msg.value);\n    }\n\n    function withdrawAsset(uint256 amount) public {\n        require(assetBalance[msg.sender] >= amount, 'Not enough asset to withdraw');\n        (bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Asset transfer failed');\n        assetBalance[msg.sender] -= amount;\n        emit AssetWithdrawn(msg.sender, amount);\n    }\n\n    function getBalance() public view returns(uint256) {\n        return assetBalance[msg.sender];\n    }\n\n    function totalAssets() public view returns(uint256) {\n        return address(this).balance;\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "18",
            "Location": "(bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Asset transfer failed');\n        assetBalance[msg.sender] -= amount;",
            "Type": "Reentrancy",
            "Description": "In the withdrawAsset function, there is a reentrancy vulnerability. Before updating the internal state (i.e. the user's asset balance), transferring money to the user may trigger the fallback function of their contract, which may allow the user to withdraw more than their original deposit if the function calls withdrawAsset again.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract PropertyRegistry {\n    mapping(address => uint256) public propertyBalance;\n    address payable public registryOwner;\n\n    constructor() {\n        registryOwner = payable(msg.sender);\n    }\n\n    function deposit() public payable {\n        propertyBalance[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(propertyBalance[msg.sender] >= amount, 'Insufficient balance');\n        (bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Failed to send ether');\n        propertyBalance[msg.sender] -= amount;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return propertyBalance[msg.sender];\n    }\n\n    function contractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function closeRegistry() public {\n        require(msg.sender == registryOwner, 'Only owner can close the registry');\n        selfdestruct(registryOwner);\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "19",
            "Location": "(bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Failed to send ether');\n        propertyBalance[msg.sender] -= amount;",
            "Type": "Reentrancy",
            "Description": "In the withdraw function, there is a reentrancy vulnerability. Before updating the internal state (i.e., the user's property balance), sending ether to the user could trigger their contract's fallback function. If that function calls withdraw again, it could allow the user to withdraw more than their original deposit.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, moving the ether transfer to the end of the function when all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the amount of gas available to the recipient, preventing the recipient's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CashbackLoyaltyProgram {\n    mapping(address => uint256) public loyaltyPoints;\n    mapping(address => uint256) public etherBalance;\n    address payable public companyWallet;\n\n    constructor() {\n        companyWallet = payable(msg.sender);\n    }\n\n    function purchaseItem() public payable {\n        companyWallet.transfer(msg.value);\n        loyaltyPoints[msg.sender] += msg.value / 100;\n    }\n\n    function redeemPoints(uint256 points) public {\n        require(loyaltyPoints[msg.sender] >= points, 'Not enough loyalty points');\n        uint256 etherToRedeem = points / 100;\n        require(etherBalance[companyWallet] >= etherToRedeem, 'Not enough funds in the company wallet');\n        (bool sent, ) = msg.sender.call{value: etherToRedeem}('');\n        require(sent, 'Failed to send Ether');\n        loyaltyPoints[msg.sender] -= points;\n        etherBalance[companyWallet] -= etherToRedeem;\n    }\n\n    function getPoints() public view returns (uint256) {\n        return loyaltyPoints[msg.sender];\n    }\n\n    function getCompanyBalance() public view returns (uint256) {\n        return etherBalance[companyWallet];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "20",
            "Location": "(bool sent, ) = msg.sender.call{value: etherToRedeem}('');\n        require(sent, 'Failed to send Ether');\n        loyaltyPoints[msg.sender] -= points;\n        etherBalance[companyWallet] -= etherToRedeem;",
            "Type": "Reentrancy",
            "Description": "In the redeemPoints function, a reentrancy vulnerability is present. Before the internal state (i.e., the user's loyalty points and the company's ether balance) is updated, ether is sent to the user. If the user's contract's fallback function is triggered and calls redeemPoints again, it could allow the user to redeem more than their original loyalty points for ether.",
            "Repair": "To fix it, the Checks-Effects-Interactions pattern should be used, moving the ether transfer to the end of the function after all internal states have been updated. It would be safer to use the transfer() function instead of call.value() to limit the amount of gas available to the recipient, thus preventing the recipient's contract from executing a large amount of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract VentureCapital {\n    mapping(address => uint) public investments;\n    address payable public entrepreneur;\n\n    constructor() {\n        entrepreneur = payable(msg.sender);\n    }\n\n    function invest() public payable {\n        investments[msg.sender] += msg.value;\n    }\n\n    function profitDistribution() public {\n        require(msg.sender == entrepreneur, 'Only the entrepreneur can distribute profits');\n        for (address investor: getInvestors()) {\n            uint profitShare = investments[investor] / 10;\n            (bool sent, ) = investor.call{value: profitShare}('');\n            require(sent, 'Failed to send Ether');\n        }\n    }\n\n    function getInvestors() public view returns (address[] memory) {\n        address[] memory investors = new address[](address(this).balance);\n        uint count = 0;\n        for (uint i = 0; i < investors.length; i++) {\n            if (investments[investors[i]] > 0) {\n                investors[count] = investors[i];\n                count++;\n            }\n        }\n        return investors;\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "21",
            "Location": "(bool sent, ) = investor.call{value: profitShare}('');\n        require(sent, 'Failed to send Ether');",
            "Type": "Reentrancy",
            "Description": "In the profitDistribution function, there is a reentrancy vulnerability. Ether is being sent to investors before the state (i.e., the balance of this contract) is updated. This allows the investor's fallback function to be triggered and call profitDistribution again, possibly leading to a withdrawal of more profits than intended.",
            "Repair": "To mitigate this, one should apply the Checks-Effects-Interactions pattern, ensuring state changes happen prior to calling external contracts. In addition, Solidity's transfer function could be used instead of call.value() to limit the gas provided to the external call, which could limit the potential for reentrancy by preventing the called contract from performing other operations."
        }
    }
]