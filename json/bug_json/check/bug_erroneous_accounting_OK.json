[
    {
        "Code": "function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-04-vader#h-15-wrong-slippage-protection-on-token---token-trades",
                "Location": "require(iUTILS(UTILS()).calcSwapSlip(\n    inputAmount, // should use outToken here from prev trade\n    iPOOLS(POOLS).getBaseAmount(outputToken)\n  ) <= slipLimit\n);",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The Router.swapWithSynthsWithLimit allows trading token to token and specifying slippage protection. A token to token trade consists of two trades: token to base base to token The slippage protection of the second trade (base to token) is computed wrong. It compares the token input amount (of the first trade) to the base reserve of the second pair. Slippage protection fails and either the trade is cancelled when it shouldn\ufffd\ufffdt be or it is accepted even though the user suffered more losses than expected. Recommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../Interfaces/IOracle.sol\";\nimport \"../Interfaces/IChainlinkOracle.sol\";\nimport \"../lib/LibMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\n/**\n * @dev The following is a sample Gas Price Oracle Implementation for a Tracer Oracle.\n *      It references the Chainlink fast gas price and ETH/USD price to get a gas cost\n *      estimate in USD.\n */\ncontract GasOracle is IOracle, Ownable {\n    using LibMath for uint256;\n    IChainlinkOracle public gasOracle;\n    IChainlinkOracle public priceOracle;\n    uint8 public override decimals = 18;\n    uint256 private constant MAX_DECIMALS = 18;\n\n    constructor(address _priceOracle, address _gasOracle) {\n        gasOracle = IChainlinkOracle(_gasOracle); /* Gas cost oracle */\n        priceOracle = IChainlinkOracle(_priceOracle); /* Quote/ETH oracle */\n    }\n\n    /**\n     * @notice Calculates the latest USD/Gas price\n     * @dev Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\n     */\n    function latestAnswer() external view override returns (uint256) {\n        uint256 gasPrice = uint256(gasOracle.latestAnswer());\n        uint256 ethPrice = uint256(priceOracle.latestAnswer());\n\n        uint256 result = PRBMathUD60x18.mul(gasPrice, ethPrice);\n        return result;\n    }\n\n    /**\n     * @notice converts a raw value to a WAD value.\n     * @dev this allows consistency for oracles used throughout the protocol\n     *      and allows oracles to have their decimals changed withou affecting\n     *      the market itself\n     */\n    function toWad(uint256 raw, IChainlinkOracle _oracle) internal view returns (uint256) {\n        IChainlinkOracle oracle = IChainlinkOracle(_oracle);\n        // reset the scaler for consistency\n        uint8 _decimals = oracle.decimals(); // 9\n        require(_decimals <= MAX_DECIMALS, \"GAS: too many decimals\");\n        uint256 scaler = uint256(10**(MAX_DECIMALS - _decimals));\n        return raw * scaler;\n    }\n\n    function setGasOracle(address _gasOracle) public onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasOracle = IChainlinkOracle(_gasOracle);\n    }\n\n    function setPriceOracle(address _priceOracle) public onlyOwner {\n        require(_priceOracle != address(0), \"address(0) given\");\n        priceOracle = IChainlinkOracle(_priceOracle);\n    }\n\n    function setDecimals(uint8 _decimals) external {\n        decimals = _decimals;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-06-tracer#h-06-wrong-price-scale-for-gasoracle",
                "Location": "    constructor(address _priceOracle, address _gasOracle) {\n        gasOracle = IChainlinkOracle(_gasOracle); /* Gas cost oracle */\n        priceOracle = IChainlinkOracle(_priceOracle); /* Quote/ETH oracle */\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The GasOracle uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD. However, the scaling depends on the underlying decimals of the two oracles and could be anything. But the code assumes it\ufffd\ufffds in 18 decimals. \ufffd\ufffdReturned value is USD/Gas * 10^18 for compatibility with rest of calculations\ufffd\ufffd There is a toWad function that seems to involve scaling but it is never used. The impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported. Recommend checking chainlink.decimals() to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the latestAnswer function always returns the answer in 18 decimals.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "   function setCap(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        address _convert\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n            updateBalance(_vault, _strategy);\n            _balance = IStrategy(_strategy).balanceOf();\n            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n            address _want = IStrategy(_strategy).want();\n            _balance = IERC20(_want).balanceOf(address(this));\n            if (_convert != address(0)) {\n                IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n                IERC20(_want).safeTransfer(address(_converter), _balance);\n                _balance = _converter.convert(_want, _convert, _balance, 1);\n                IERC20(_convert).safeTransfer(_vault, _balance);\n            } else {\n                IERC20(_want).safeTransfer(_vault, _balance);\n            }\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-yaxis#h-01-controllersetcap-sets-wrong-vault-balance",
                "Location": "_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The Controller.setCap function sets a cap for a strategy and withdraws any excess amounts (_diff). The vault balance is decreased by the entire strategy balance instead of by this _diff",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-yaxis#h-07-vaultbalance-mixes-normalized-and-standard-amounts",
                "Location": "for (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The Vault.balance function uses the balanceOfThis function which scales (\ufffd\ufffdnormalizes\ufffd\ufffd) all balances to 18 decimals. Note that balance()\ufffd\ufffds second term IController(manager.controllers(address(this))).balanceOf() is not normalized. The code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-yaxis#h-08-vaultwithdraw-mixes-normalized-and-standard-amounts",
                "Location": "// @audit compares unnormalzied output to normalized output\nif (_balance < _amount) {\n    IController _controller = IController(manager.controllers(address(this)));\n    // @audit cannot directly subtract unnormalized\n    uint256 _toWithdraw = _amount.sub(_balance);\n    if (_controller.strategies() > 0) {\n        _controller.withdraw(_output, _toWithdraw);\n    }\n    uint256 _after = IERC20(_output).balanceOf(address(this));\n    uint256 _diff = _after.sub(_balance);\n    if (_diff < _toWithdraw) {\n        _amount = _balance.add(_diff);\n    }\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Note that balance()\ufffd\ufffds second term IController(manager.controllers(address(this))).balanceOf() is not normalized, but it must be. This leads to many issues through the contracts that use balance but don\ufffd\ufffdt treat these values as normalized values. For example, in Vault.withdraw, the computed _amount value is normalized (in 18 decimals). But the uint256 _balance = IERC20(_output).balanceOf(address(this)); value is not normalized but compared to the normalized _amount and even subtracted",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "   function manualRebalance(uint256 toLock) external whenNotPaused {\n        _onlyGovernance();\n        require(toLock <= MAX_BPS, \"Max is 100%\");\n\n        if (processLocksOnRebalance) {\n            // manualRebalance will revert if you have no expired locks\n            LOCKER.processExpiredLocks(false);\n        }\n\n        if (harvestOnRebalance) {\n            harvest();\n        }\n\n        // Token that is highly liquid\n        uint256 balanceOfWant =\n            IERC20Upgradeable(want).balanceOf(address(this));\n        // CVX uninvested we got from harvest and unlocks\n        uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));\n        // Locked CVX in the locker\n        uint256 balanceInLock = LOCKER.balanceOf(address(this));\n        uint256 totalCVXBalance =\n            balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));\n\n        //Ratios\n        uint256 currentLockRatio =\n            balanceInLock.mul(10**18).div(totalCVXBalance);\n        // Amount we want to have in lock\n        uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);\n        // Amount we want to have in bCVX\n        uint256 toWantRatio =\n            totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);\n\n        // We can't unlock enough, just deposit rest into bCVX\n        if (newLockRatio <= currentLockRatio) {\n            // Deposit into vault\n            uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));\n            if (toDeposit > 0) {\n                CVX_VAULT.deposit(toDeposit);\n            }\n\n            return;\n        }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-bvecvx#h-01-vecvxstrategymanualrebalance-has-wrong-logic",
                "Location": "if (newLockRatio <= currentLockRatio) {// ...}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The veCVXStrategy.manualRebalance function computes two ratios currentLockRatio and newLockRatio and compares them.\n\nHowever, these ratios compute different things and are not comparable:\n\ncurrentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance) is a percentage value with 18 decimals (i.e. 1e18 = 100%). Its max value can at most be 1e18.\nnewLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS) is a CVX token amount. It\ufffd\ufffds unbounded and just depends on the totalCVXBalance amount.\nThe comparison that follows does not make sense",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(\n            data,\n            (int24, int24, uint128, address, bool)\n        );\n\n        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n        uint160 currentPrice = price;\n\n        unchecked {\n            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n        }\n\n        (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(\n            uint256(priceLower),\n            uint256(priceUpper),\n            uint256(currentPrice),\n            uint256(amount)\n        );\n\n        (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n\n        unchecked {\n            amount0 += amount0fees;\n            amount1 += amount1fees;\n        }\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n\n        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }\n\n        _transferBothTokens(recipient, amount0, amount1, unwrapBento);\n\n        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident-2#h-08-wrong-inequality-when-addingremoving-liquidity-in-current-price-range",
                "Location": "unchecked { if (priceLower < currentPrice && currentPrice < priceUpper) liquidity += uint128(_liquidity);}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The ConcentratedLiquidityPool.mint/burn functions add/remove liquidity when (priceLower < currentPrice && currentPrice < priceUpper). it should  also be changed if priceLower == currentPrice",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(\n            data,\n            (int24, int24, uint128, address, bool)\n        );\n\n        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n        uint160 currentPrice = price;\n\n        unchecked {\n            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n        }\n\n        (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(\n            uint256(priceLower),\n            uint256(priceUpper),\n            uint256(currentPrice),\n            uint256(amount)\n        );\n\n        (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n\n        unchecked {\n            amount0 += amount0fees;\n            amount1 += amount1fees;\n        }\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n\n        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }\n\n        _transferBothTokens(recipient, amount0, amount1, unwrapBento);\n\n        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident-2#h-10-concentratedliquiditypoolburn-wrong-implementation",
                "Location": "        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers.The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool. However, the current implementation only updated reserves with the fees subtracted. Makes the reserve0 and reserve1 smaller than the current balance0 and balance1.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function cross(\n        mapping(int24 => Tick) storage ticks,\n        int24 nextTickToCross,\n        uint160 secondsPerLiquidity,\n        uint256 currentLiquidity,\n        uint256 feeGrowthGlobal,\n        bool zeroForOne\n    ) internal returns (uint256, int24) {\n        ticks[nextTickToCross].secondsPerLiquidityOutside = secondsPerLiquidity - ticks[nextTickToCross].secondsPerLiquidityOutside;\n        if (zeroForOne) {\n            // Moving forward through the linked list\n            if (nextTickToCross % 2 == 0) {\n                currentLiquidity -= ticks[nextTickToCross].liquidity;\n            } else {\n                currentLiquidity += ticks[nextTickToCross].liquidity;\n            }\n            nextTickToCross = ticks[nextTickToCross].previousTick;\n            ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0;\n        } else {\n            // Moving backwards through the linked list\n            if (nextTickToCross % 2 == 0) {\n                currentLiquidity += ticks[nextTickToCross].liquidity;\n            } else {\n                currentLiquidity -= ticks[nextTickToCross].liquidity;\n            }\n            nextTickToCross = ticks[nextTickToCross].nextTick;\n            ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1;\n        }\n\n        return (currentLiquidity, nextTickToCross);\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident-2#h-11-concentratedliquiditypool-incorrect-feegrowthglobal-accounting-when-crossing-ticks",
                "Location": "if (zeroForOne) {\n...\nticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0;\n} else {\n...\nticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1;\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Swap fees are taken from the output. Hence, if swapping token0 for token1 (zeroForOne is true), then fees are taken in token1. We see this to be the case in the initialization of feeGrowthGlobal in the swap cache feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0; and in _updateFees(). However, looking at Ticks.cross(), the logic is the reverse, which causes wrong fee accounting.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/ICreditLimitModel.sol\";\n\ncontract CreditLimitByMedian is Ownable, ICreditLimitModel {\n    using Math for uint256;\n\n    bool public constant override isCreditLimitModel = true;\n    uint256 public override effectiveNumber;\n\n    constructor(uint256 effectiveNumber_) {\n        effectiveNumber = effectiveNumber_;\n    }\n\n    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {\n        if (vouchs.length >= effectiveNumber) {\n            return _findMedian(vouchs);\n        } else {\n            return 0;\n        }\n    }\n\n    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount - 1;\n                } else {\n                    newLockedAmount = 0;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    function setEffectNumber(uint256 number) external onlyOwner {\n        effectiveNumber = number;\n    }\n\n    /**\n     *  @dev Find median from uint array\n     *  @param array array\n     *  @return uint256\n     */\n    function _findMedian(uint256[] memory array) private pure returns (uint256) {\n        uint256[] memory arr = _sortArray(array);\n        if (arr.length == 0) return 0;\n\n        if (arr.length % 2 == 0) {\n            uint256 num1 = arr[arr.length >> 1];\n            uint256 num2 = arr[(arr.length >> 1) - 1];\n            return num1.average(num2);\n        } else {\n            return arr[arr.length >> 1];\n        }\n    }\n\n    /**\n     *  @dev Sort uint array\n     *  @param arr array\n     *  @return uint256 array\n     */\n    function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {\n        uint256 length = arr.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            for (uint256 j = i + 1; j < length; j++) {\n                if (arr[i] < arr[j]) {\n                    uint256 temp = arr[j];\n                    arr[j] = arr[i];\n                    arr[i] = temp;\n                }\n            }\n        }\n\n        return arr;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-10-union#h-02-wrong-implementation-of-creditlimitbymediansolgetlockedamount-makes-it-unable-to-unlock-lockedamount-in-creditlimitbymedian-model",
                "Location": "    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount - 1;\n                } else {\n                    newLockedAmount = 0;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. getLockedAmount() is used by UserManager.sol#updateLockedData() to update locked amounts. Based on the context, at L66, newLockedAmount = array[i].lockedAmount - 1; should be newLockedAmount = array[i].lockedAmount - amount;. The current implementation is wrong and makes it impossible to unlock lockedAmount in CreditLimitByMedian model.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function rampTargetPrice(\n        TargetPrice storage self,\n        uint256 futureTargetPrice_,\n        uint256 futureTime_\n    ) external returns (uint256) {\n        require(\n            block.timestamp >= self.initialTargetPriceTime.add(1 days),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureTargetPrice_ >= 0,\n            \"futureTargetPrice_ must be >= 0\"\n        );\n\n        uint256 initialTargetPricePrecise = _getTargetPricePrecise(self);\n        uint256 futureTargetPricePrecise = futureTargetPrice_.mul(TARGET_PRICE_PRECISION);\n\n        if (futureTargetPricePrecise < initialTargetPricePrecise) {\n            require(\n                futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,\n                \"futureTargetPrice_ is too small\"\n            );\n        } else {\n            require(\n                futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),\n                \"futureTargetPrice_ is too large\"\n            );\n        }\n\n        self.initialTargetPrice = initialTargetPricePrecise;\n        self.futureTargetPrice = futureTargetPricePrecise;\n        self.initialTargetPriceTime = block.timestamp;\n        self.futureTargetPriceTime = futureTime_;\n        \n        // console.log(\"executing rampTargetPrice() initalTargetPrice: %s\", self.initialTargetPrice);\n        // console.log(\"futureTargetPrice: %s\", self.futureTargetPrice);\n\n        emit RampTargetPrice(\n            initialTargetPricePrecise,\n            futureTargetPricePrecise,\n            block.timestamp,\n            futureTime_\n        );\n\n        // change token multiplier to reflect new target price\n        return self.originalPrecisionMultipliers[0].mul(initialTargetPricePrecise).div(WEI_UNIT);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-bootfinance#h-02-can-not-update-target-price",
                "Location": "        if (futureTargetPricePrecise < initialTargetPricePrecise) {\n            require(\n                futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,\n                \"futureTargetPrice_ is too small\"\n            );\n        } else {\n            require(\n                futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),\n                \"futureTargetPrice_ is too large\"\n            );\n        }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The sanity checks in rampTargetPrice are broken. If futureTargetPricePrecise is smaller than initialTargetPricePrecise 0.01 of futureTargetPricePrecise would never larger than initialTargetPricePrecise.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function determineA(\n        Swap storage self, \n        uint256[] memory xp)\n        internal\n        view\n        returns(uint256)\n    {\n        // Determine the correct A by comparing xp[0] and xp[1].\n        // determine if currently in the A region or in the A2 region.\n        if( xp[0] < xp[1] ) {\n            return _getAPrecise(self);\n        } else {\n            return _getA2Precise(self);        \n        }\n    }     function getYC(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp\n    ) internal view returns (uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        require(\n            tokenIndexFrom != tokenIndexTo,\n            \"Can't compare token to itself\"\n        );\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        // 1. Determine the correct A by comparing xp[0] and xp[1].\n        uint256 a = determineA(self, xp);\n\n        // 2. Calculate D of the initial position\n        uint256 d = getD(xp, a);\n\n        // 3. calculate y\n        uint256 y = getY(self, tokenIndexFrom, tokenIndexTo, x, xp, a, d);\n\n        // 4. Calculate A at the resulting position\n        uint256 aNew = _xpCalc(self, tokenIndexFrom, tokenIndexTo, x, y);\n\n        // 5. Check if we switched A's during the swap\n        if (aNew == a){     // We have used the correct A\n            return y;\n        } else {    // We have switched A's, do it again with the new A\n            return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d);\n        }\n\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-bootfinance#h-04-swaps-are-not-split-when-trade-crosses-target-price",
                "Location": "// 5. Check if we switched A's during the swap\nif (aNew == a){     // We have used the correct A\n    return y;\n} else {    // We have switched A's, do it again with the new A\n    return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d);\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, see SwapUtils.determineA. The swap curve is therefore a join of two different curves at the target price. When doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2. However, the SwapUtils.swap / _calculateSwap function does not do this, it only uses the \ufffd\ufffdnew A\ufffd\ufffd, see getYC step 5.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function consult(address token) public view returns (uint256 result) {\n        uint256 pairCount = _pairs.length;\n        uint256 sumNative = 0;\n        uint256 sumUSD = 0;\n\n        for (uint256 i = 0; i < pairCount; i++) {\n            PairData memory pairData = _pairs[i];\n\n            if (token == pairData.token0) {\n                //\n                // TODO - Review:\n                //   Verify price1Average is amount of USDV against 1 unit of token1\n                //\n\n                sumNative += pairData.price1Average.mul(1).decode144(); // native asset amount\n                if (pairData.price1Average._x != 0) {\n                    require(sumNative != 0);\n                }\n\n                (\n                    uint80 roundID,\n                    int256 price,\n                    ,\n                    ,\n                    uint80 answeredInRound\n                ) = AggregatorV3Interface(_aggregators[pairData.token1])\n                        .latestRoundData();\n\n                require(\n                    answeredInRound >= roundID,\n                    \"TwapOracle::consult: stale chainlink price\"\n                );\n                require(\n                    price != 0,\n                    \"TwapOracle::consult: chainlink malfunction\"\n                );\n\n                sumUSD += uint256(price) * (10**10);\n            }\n        }\n        require(sumNative != 0, \"TwapOracle::consult: Sum of native is zero\");\n        result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-vader#h-04-twaporacle-doesnt-calculate-vaderusdv-exchange-rate-correctly",
                "Location": "result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative); result = ((sumUSD * 18) / sumNative);",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {FixedPointMath} from \"../FixedPointMath.sol\";\nimport {IDetailedERC20} from \"../../interfaces/IDetailedERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title CDP\n///\n/// @dev A library which provides the CDP data struct and associated functions.\nlibrary CDP {\n  using CDP for Data;\n  using FixedPointMath for FixedPointMath.FixedDecimal;\n  using SafeERC20 for IDetailedERC20;\n  using SafeMath for uint256;\n\n  struct Context {\n    FixedPointMath.FixedDecimal collateralizationLimit;\n    FixedPointMath.FixedDecimal accumulatedYieldWeight;\n  }\n\n  struct Data {\n    uint256 totalDeposited;\n    uint256 totalDebt;\n    uint256 totalCredit;\n    uint256 lastDeposit;\n    FixedPointMath.FixedDecimal lastAccumulatedYieldWeight;\n  }\n\n  function update(Data storage _self, Context storage _ctx) internal {\n    uint256 _earnedYield = _self.getEarnedYield(_ctx);\n    if (_earnedYield > _self.totalDebt) {\n      uint256 _currentTotalDebt = _self.totalDebt;\n      _self.totalDebt = 0;\n      _self.totalCredit = _earnedYield.sub(_currentTotalDebt);\n    } else {\n      _self.totalDebt = _self.totalDebt.sub(_earnedYield);\n    }\n    _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n  }\n\n  /// @dev Assures that the CDP is healthy.\n  ///\n  /// This function will revert if the CDP is unhealthy.\n  function checkHealth(Data storage _self, Context storage _ctx, string memory _msg) internal view {\n    require(_self.isHealthy(_ctx), _msg);\n  }\n\n  /// @dev Gets if the CDP is considered healthy.\n  ///\n  /// A CDP is healthy if its collateralization ratio is greater than the global collateralization limit.\n  ///\n  /// @return if the CDP is healthy.\n  function isHealthy(Data storage _self, Context storage _ctx) internal view returns (bool) {\n    return _ctx.collateralizationLimit.cmp(_self.getCollateralizationRatio(_ctx)) <= 0;\n  }\n\n  function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {\n    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\n    if (_unclaimedYield == 0) {\n      return _self.totalDebt;\n    }\n\n    uint256 _currentTotalDebt = _self.totalDebt;\n    if (_unclaimedYield >= _currentTotalDebt) {\n      return 0;\n    }\n\n    return _currentTotalDebt - _unclaimedYield;\n  }\n\n  function getUpdatedTotalCredit(Data storage _self, Context storage _ctx) internal view returns (uint256) {\n    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\n    if (_unclaimedYield == 0) {\n      return _self.totalCredit;\n    }\n\n    uint256 _currentTotalDebt = _self.totalDebt;\n    if (_unclaimedYield <= _currentTotalDebt) {\n      return 0;\n    }\n\n    return _self.totalCredit + (_unclaimedYield - _currentTotalDebt);\n  }\n\n  /// @dev Gets the amount of yield that a CDP has earned since the last time it was updated.\n  ///\n  /// @param _self the CDP to query.\n  /// @param _ctx  the CDP context.\n  ///\n  /// @return the amount of earned yield.\n  function getEarnedYield(Data storage _self, Context storage _ctx) internal view returns (uint256) {\n    FixedPointMath.FixedDecimal memory _currentAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n    FixedPointMath.FixedDecimal memory _lastAccumulatedYieldWeight = _self.lastAccumulatedYieldWeight;\n\n    if (_currentAccumulatedYieldWeight.cmp(_lastAccumulatedYieldWeight) == 0) {\n      return 0;\n    }\n\n    return _currentAccumulatedYieldWeight\n      .sub(_lastAccumulatedYieldWeight)\n      .mul(_self.totalDeposited)\n      .decode();\n  }\n\n  /// @dev Gets a CDPs collateralization ratio.\n  ///\n  /// The collateralization ratio is defined as the ratio of collateral to debt. If the CDP has zero debt then this\n  /// will return the maximum value of a fixed point integer.\n  ///\n  /// This function will use the updated total debt so an update before calling this function is not required.\n  ///\n  /// @param _self the CDP to query.\n  ///\n  /// @return a fixed point integer representing the collateralization ratio.\n  function getCollateralizationRatio(Data storage _self, Context storage _ctx)\n    internal view\n    returns (FixedPointMath.FixedDecimal memory)\n  {\n    uint256 _totalDebt = _self.getUpdatedTotalDebt(_ctx);\n    if (_totalDebt == 0) {\n      return FixedPointMath.maximumValue();\n    }\n    return FixedPointMath.fromU256(_self.totalDeposited).div(_totalDebt);\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-yaxis#h-02-cdpsol-update-overwrites-users-credit-on-every-positive-increment",
                "Location": "  function update(Data storage _self, Context storage _ctx) internal {\n    uint256 _earnedYield = _self.getEarnedYield(_ctx);\n    if (_earnedYield > _self.totalDebt) {\n      uint256 _currentTotalDebt = _self.totalDebt;\n      _self.totalDebt = 0;\n      _self.totalCredit = _earnedYield.sub(_currentTotalDebt);\n    } else {\n      _self.totalDebt = _self.totalDebt.sub(_earnedYield);\n    }\n    _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n  }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. there is a function called update. This function slowly decreases the debt of a position as yield is earned, until the debt is fully paid off, and the idea is then that the credit should begin incrementing as more yield is accumulated. However, the current logic to increment the totalCredit is this line of code",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../utils/types/UFixed18.sol\";\n\n/// @dev OptimisticLedger type\nstruct OptimisticLedger {\n    /// @dev Individual account collateral balances\n    mapping(address => UFixed18) balances;\n\n    /// @dev Total ledger collateral balance\n    UFixed18 total;\n\n    /// @dev Total ledger collateral shortfall\n    UFixed18 shortfall;\n}\n\n/**\n * @title OptimisticLedgerLib\n * @notice Library that manages a global vs account ledger where the global ledger is settled separately,\n *         and ahead of, the user-level accounts.\n * @dev    Ensures that no more collateral leaves the ledger than goes it, while allowing user-level accounts\n *         to settle as a follow up step. Overdrafts on the user-level are accounted as \"shortall\". Shortfall\n *         in the system is the quantity of insolvency that can be optionally resolved by the ledger owner.\n *         Until the shortfall is resolved, collateral may be withdrawn from the ledger on a FCFS basis. However\n *         once the ledger total has been depleted, users will not be able to withdraw even if they have non-zero\n *         user level balances until the shortfall is resolved, recapitalizing the ledger.\n */\nlibrary OptimisticLedgerLib {\n    using UFixed18Lib for UFixed18;\n    using Fixed18Lib for Fixed18;\n\n    /**\n     * @notice Credits `account` with `amount` collateral\n     * @param self The struct to operate on\n     * @param account Account to credit collateral to\n     * @param amount Amount of collateral to credit\n     */\n    function creditAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {\n        self.balances[account] = self.balances[account].add(amount);\n        self.total = self.total.add(amount);\n    }\n\n    /**\n     * @notice Debits `account` `amount` collateral\n     * @param self The struct to operate on\n     * @param account Account to debit collateral from\n     * @param amount Amount of collateral to debit\n     */\n    function debitAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {\n        self.balances[account] = self.balances[account].sub(amount);\n        self.total = self.total.sub(amount);\n    }\n\n    /**\n     * @notice Credits `account` with `amount` collateral\n     * @dev Funds come from inside the product, not totals are updated\n     *      Shortfall is created if more funds are debited from an account than exist\n     * @param self The struct to operate on\n     * @param account Account to credit collateral to\n     * @param amount Amount of collateral to credit\n     */\n    function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\n    internal returns (UFixed18 shortfall) {\n        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n        if (newBalance.sign() == -1) {\n            shortfall = self.shortfall.add(newBalance.abs());\n            newBalance = Fixed18Lib.ZERO;\n        }\n\n        self.balances[account] = newBalance.abs();\n        self.shortfall = self.shortfall.add(shortfall);\n    }\n\n    /**\n     * @notice Debits ledger globally `amount` collateral\n     * @dev Removes balance from total that is accounted for elsewhere (e.g. product-level accumulators)\n     * @param self The struct to operate on\n     * @param amount Amount of collateral to debit\n     */\n    function debit(OptimisticLedger storage self, UFixed18 amount) internal {\n        self.total = self.total.sub(amount);\n    }\n\n    /**\n     * @notice Reduces the amount of collateral shortfall in the ledger\n     * @param self The struct to operate on\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolve(OptimisticLedger storage self, UFixed18 amount) internal {\n        self.shortfall = self.shortfall.sub(amount);\n        self.total = self.total.add(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-perennial#h-01-wrong-shortfall-calculation",
                "Location": "    function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\n    internal returns (UFixed18 shortfall) {\n        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n        if (newBalance.sign() == -1) {\n            shortfall = self.shortfall.add(newBalance.abs());\n            newBalance = Fixed18Lib.ZERO;\n        }\n\n        self.balances[account] = newBalance.abs();\n        self.shortfall = self.shortfall.add(shortfall);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-sublime#h-02-wrong-returns-of-savingsaccountutildepositfromsavingsaccount-can-cause-fund-loss",
                "Location": "_sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),",
                "Type": "Erroneous state updates",
                "Description": "Returning an unexpected value that deviates from the expected semantics specified for the contract. The function SavingsAccountUtil.depositFromSavingsAccount() is expected to return the number of equivalent shares for given _asset.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-streaming#h-03-reward-token-not-correctly-recovered",
                "Location": "    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The Streaming contract allows recovering the reward token by calling recoverTokens(rewardToken, recipient). However, the excess amount is computed incorrectly as ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount). Note that rewardTokenAmount only ever increases (when calling fundStream) but it never decreases when claiming the rewards through claimReward. However, claimReward transfers out the reward token. Therefore, the rewardTokenAmount never tracks the contract\ufffd\ufffds reward balance and the excess cannot be computed that way.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-streaming#h-10-recovertokens-doesnt-work-when-issale-is-true",
                "Location": "uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. This breaks in the case where isSale is true and the deposit tokens have already been claimed through the use of creatorClaimSoldTokens. In this case, redemeedDepositTokens will be zero, and depositTokenAmount will still be at its original value when the streaming ended. As a result, any attempts to recover deposit tokens from the contract would either revert or send less tokens than should be sent, since the logic above would still think that there are the full amount of deposit tokens in the contract. This breaks the functionality of the function completely in this case.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "   function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-vader#h-05-oracle-returns-an-improperly-scaled-usdvvader-price",
                "Location": "        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The LBT oracle does not properly scale values when calculating prices for VADER or USDV. ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\ncontract VaderReserve is IVaderReserve, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe VADER transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The Vader token the reserve is handling\n    IERC20 public immutable vader;\n\n    // Router address for IL awards\n    address public router;\n\n    // Tracks last grant time for throttling\n    uint256 public lastGrant;\n\n    // LBT used for loss reimbursement\n    ILiquidityBasedTWAP public lbt;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20 _vader) {\n        require(\n            _vader != IERC20(_ZERO_ADDRESS),\n            \"VaderReserve::constructor: Incorrect Arguments\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function reserve() public view override returns (uint256) {\n        return vader.balanceOf(address(this));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function grant(address recipient, uint256 amount)\n        external\n        override\n        onlyOwner\n        throttle\n    {\n        amount = _min(\n            (reserve() * _MAX_GRANT_BASIS_POINTS) / _MAX_BASIS_POINTS,\n            amount\n        );\n        vader.safeTransfer(recipient, amount);\n\n        emit GrantDistributed(recipient, amount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function initialize(\n        ILiquidityBasedTWAP _lbt,\n        address _router,\n        address _dao\n    ) external onlyOwner {\n        require(\n            _router != _ZERO_ADDRESS &&\n                _dao != _ZERO_ADDRESS &&\n                _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"VaderReserve::initialize: Incorrect Arguments\"\n        );\n        router = _router;\n        lbt = _lbt;\n        transferOwnership(_dao);\n    }\n\n    function reimburseImpermanentLoss(address recipient, uint256 amount)\n        external\n        override\n    {\n        require(\n            msg.sender == router,\n            \"VaderReserve::reimburseImpermanentLoss: Insufficient Priviledges\"\n        );\n\n        // NOTE: Loss is in USDV, reimbursed in VADER\n        // NOTE: If USDV LBT is working, prefer it otherwise use VADER price\n        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {\n            uint256 usdvPrice = lbt.getUSDVPrice();\n\n            amount = amount / usdvPrice;\n        } else {\n            uint256 vaderPrice = lbt.getVaderPrice();\n\n            amount = amount * vaderPrice;\n        }\n\n        uint256 actualAmount = _min(reserve(), amount);\n\n        vader.safeTransfer(recipient, actualAmount);\n\n        emit LossCovered(recipient, amount, actualAmount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier throttle() {\n        require(\n            lastGrant + _GRANT_DELAY <= block.timestamp,\n            \"VaderReserve::throttle: Grant Too Fast\"\n        );\n        lastGrant = block.timestamp;\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-vader#h-08-reserve-does-not-properly-apply-prices-of-vader-and-usdv-tokens",
                "Location": "        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {\n            uint256 usdvPrice = lbt.getUSDVPrice();\n\n            amount = amount / usdvPrice;\n        } else {\n            uint256 vaderPrice = lbt.getVaderPrice();\n\n            amount = amount * vaderPrice;\n        }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Here we multiply the IL experienced by the LP by a price for USDV or VADER as returned by the LBT. However the price from the oracle is a fixed point number (scaled up by 1e8 or 1e18 depending on the resolution of finding \ufffd\ufffdOracle returns an improperly scaled USDV/VADER price\ufffd\ufffd) and so a fixed scaling factor should be applied to convert back from a fixed point number to a standard integer. As it stands depending on the branch which is executed, the amount to be reimbursed will be 1e18 times too large or too small. Should the \ufffd\ufffdelse\ufffd\ufffd branch be executed the reserve will pay out much in terms of IL protection resulting in severe loss of funds. High severity.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../facades/TokenProxyLike.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n///@title Rebase Proxy\n///@author Justin Goro\n/**@notice expresses the balance changes of a rebase token as a fluctuating redeem rate, allowing for balanceOf stability. Useful for dapps which maintain their own balance values\n* Very large rebase down movement tokens are still discouraged as this could cause threshold instability.\n*/\n///@dev TokenProxyRegistry contract maps this token to a base token.\ncontract RebaseProxy is ERC20, TokenProxyLike {\n    constructor(\n        address _baseToken,\n        string memory name_,\n        string memory symbol_\n    ) TokenProxyLike(_baseToken) ERC20(name_, symbol_) {}\n\n    function redeemRate() public view returns (uint256) {\n        uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));\n        if (totalSupply() == 0 || balanceOfBase == 0) return ONE;\n\n        return (balanceOfBase * ONE) / totalSupply();\n    }\n\n    function mint(address to, uint256 amount)\n        public\n        override\n        returns (uint256)\n    {\n        uint256 _redeemRate = redeemRate();\n        require(\n            IERC20(baseToken).transferFrom(msg.sender, address(this), amount)\n        );\n        uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));\n        uint256 proxy = (baseBalance * ONE) / _redeemRate;\n        _mint(to, proxy);\n    }\n\n    function redeem(address to, uint256 amount)\n        public\n        override\n        returns (uint256)\n    {\n        uint256 _redeemRate = redeemRate();\n        uint256 baseTokens = (_redeemRate * amount) / ONE;\n        _burn(msg.sender, amount);\n        IERC20(baseToken).transfer(to, baseTokens);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-01-behodler#h-02-wrong-minting-amount",
                "Location": "    function mint(address to, uint256 amount)\n        public\n        override\n        returns (uint256)\n    {\n        uint256 _redeemRate = redeemRate();\n        require(\n            IERC20(baseToken).transferFrom(msg.sender, address(this), amount)\n        );\n        uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));\n        uint256 proxy = (baseBalance * ONE) / _redeemRate;\n        _mint(to, proxy);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. wrong minting amount",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        require(\n            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||\n                IJoePair(\n                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)\n                ).totalSupply() ==\n                0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(wavaxReserve > 0, \"LaunchEvent: no wavax balance\");\n\n        uint256 tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (\n            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated\n        ) {\n            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        WAVAX.approve(address(router), wavaxReserve);\n        token.approve(address(router), tokenAllocated);\n\n        /// We can't trust the output cause of reflect tokens\n        (, , lpSupply) = router.addLiquidity(\n            wavaxAddress, // tokenA\n            tokenAddress, // tokenB\n            wavaxReserve, // amountADesired\n            tokenAllocated, // amountBDesired\n            wavaxReserve, // amountAMin\n            tokenAllocated, // amountBMin\n            address(this), // to\n            block.timestamp // deadline\n        );\n\n        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));\n        wavaxAllocated = wavaxReserve;\n        wavaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            wavaxAllocated\n        );\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-01-trader-joe#h-02-wrong-token-allocation-computation-for-token-decimals--18-if-floor-price-not-reached",
                "Location": "tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. In LaunchEvent.createPair, when the floor price is not reached (floorPrice > wavaxReserve * 1e18 / tokenAllocated), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price. Note that the floorPrice is supposed to have a precision of 18: /// @param _floorPrice Price of each token in AVAX, scaled to 1e18 The floorPrice > (wavaxReserve * 1e18) / tokenAllocated check is correct but the tokenAllocated computation involves the token decimals",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function getAmountToTransfer(\n        uint256 initialGas,\n        address tokenAddress,\n        uint256 amount,\n        uint256 tokenGasPrice\n    ) internal returns (uint256 amountToTransfer) {\n        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);\n        uint256 lpFee;\n        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {\n            // Here add some fee to incentive pool also\n            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;\n            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;\n        } else {\n            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n        }\n        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n\n        liquidityProviders.addLPFee(tokenAddress, lpFee);\n\n        uint256 totalGasUsed = initialGas - gasleft();\n        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;\n        totalGasUsed = totalGasUsed + baseGas;\n\n        uint256 gasFee = totalGasUsed * tokenGasPrice;\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;\n        amountToTransfer = amount - (transferFeeAmount + gasFee);\n\n        emit FeeDetails(lpFee, transferFeeAmount, gasFee);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-03-biconomy#h-03-wrong-formula-when-add-fee-incentivepool-can-lead-to-loss-of-funds",
                "Location": "            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The getAmountToTransfer function of LiquidityPool updates incentivePool[tokenAddress] by adding some fee to it but the formula is wrong and the value of incentivePool[tokenAddress] will be divided by BASE_DIVISOR (10000000000) each time. After just a few time, the value of incentivePool[tokenAddress] will become zero and that amount of tokenAddress token will be locked in contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n  return _principalWithdrawable;\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-03-sublime#h-01-lenderpool-principal-withdrawable-is-incorrectly-calculated-if-start-is-invoked-with-non-zero-start-fee",
                "Location": "function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n  return _principalWithdrawable;\n}",
                "Type": "Erroneous state updates",
                "Description": "Returning an unexpected value that deviates from the expected semantics specified for the contract. The _principalWithdrawable calculated will be more than expected if _start() is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in totalSupply[id] not being 1:1 with the borrow limit.",
                "Repair": ""
            }
        ]
    }
]