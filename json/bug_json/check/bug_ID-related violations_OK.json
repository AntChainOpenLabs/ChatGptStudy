[
    {
        "Code": "pragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/compound/CTokenInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CompoundToNotionalV2 {\n    NotionalProxy public immutable NotionalV2;\n    address public owner;\n\n    constructor(NotionalProxy notionalV2_) {\n        NotionalV2 = notionalV2_;\n        owner = msg.sender;\n    }\n\n    function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n\n    function migrateBorrowFromCompound(\n        address cTokenBorrow,\n        uint256 cTokenRepayAmount,\n        uint16[] memory notionalV2CollateralIds,\n        uint256[] memory notionalV2CollateralAmounts,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);\n        if (cTokenRepayAmount == 0) {\n            // Set the entire borrow balance if it is not set\n            cTokenRepayAmount = borrowBalance;\n        } else {\n            // Check that the cToken repayment amount is not more than required\n            require(cTokenRepayAmount <= borrowBalance, \"Invalid repayment amount\");\n        }\n\n        bytes memory encodedData = abi.encode(\n            cTokenBorrow,\n            cTokenRepayAmount,\n            notionalV2CollateralIds,\n            notionalV2CollateralAmounts\n        );\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n    }\n\n    receive() external payable {\n        revert(\"Cannot transfer ETH\");\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-08-notional#h-04-access-restrictions-on-compoundtonotionalv2notionalcallback-can-be-bypassed",
                "Location": "function notionalCallback(    address sender,address account,   bytes calldata callbackData) external returns (uint256) {require(sender == address(this), \"Unauthorized callback\"); in notionalCallback function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed,The CompoundToNotionalV2.notionalCallback is supposed to only be called from the verified contract that calls this callback. But, the access restrictions can be circumvented by simply providing sender = this, as sender is a parameter of the function that can be chosen by the attacker.An attacker can call the function passing in an arbitrary account whose tokens are then transferred to the contract. The account first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker front-runs the actual transaction.It\u2019s at least a griefing attack: I can pass in a malicious cTokenBorrow that returns any token of my choice (through the .underlying() call) but whose repayBorrowBehalf is a no-op.This will lead to any of the victim\u2019s approved tokens becoming stuck in the contract, essentially burning them",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity =0.7.6;\npragma abicoder v2;\nimport \"@openzeppelin-0.7/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin-0.7/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./ActionGuards.sol\";\nimport \"./math/SafeInt256.sol\";\nimport \"./stubs/BalanceHandler.sol\";\nimport \"./stubs/TokenHandler.sol\";\nimport \"./global/StorageLayoutV2.sol\";\nimport \"./global/Constants.sol\";\nimport \"interfaces/notional/NotionalTreasury.sol\";\nimport \"interfaces/compound/ComptrollerInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport {WETH9_07 as WETH9} from \"interfaces/WETH9_07.sol\";\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    IERC20 public immutable COMP;\n    Comptroller public immutable COMPTROLLER;\n    WETH9 public immutable WETH;\n    event TreasuryManagerChanged(address indexed previousManager, address indexed newManager);\n    event ReserveBufferUpdated(uint16 currencyId, uint256 bufferAmount);\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Caller is not the treasury manager\");\n        _;\n    }\n    function _checkValidCurrency(uint16 currencyId) internal view {\n        require(0 < currencyId && currencyId <= maxCurrencyId, \"Invalid currency id\");\n    }\n\n    constructor(Comptroller _comptroller, WETH9 _weth) {\n        COMPTROLLER = _comptroller;\n        COMP = IERC20(_comptroller.getCompAddress());\n        WETH = _weth;\n    }\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        (int256 reserveBalance) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n        require(newBalance < reserveBalance, \"cannot increase reserve balance\");\n\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n    function claimCOMPAndTransfer(address[] calldata cTokens)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 balanceBefore = COMP.balanceOf(address(this));\n        COMPTROLLER.claimComp(address(this), cTokens);\n        uint256 balanceAfter = COMP.balanceOf(address(this));\n        uint256 amountClaimed = balanceAfter.sub(balanceBefore);\n        COMP.safeTransfer(treasuryManagerContract, amountClaimed);\n        return amountClaimed;\n    }\n    function _redeemAndTransfer(\n        uint16 currencyId,\n        Token memory asset,\n        int256 assetInternalRedeemAmount\n    ) private returns (uint256) {\n        Token memory underlying = TokenHandler.getUnderlyingToken(currencyId);\n        int256 assetExternalRedeemAmount = asset.convertToExternal(assetInternalRedeemAmount);\n        uint256 redeemedExternalUnderlying = asset\n            .redeem(underlying, assetExternalRedeemAmount.toUint())\n            .toUint();\n        if (underlying.tokenAddress == address(0)) {\n            WETH9(WETH).deposit{value: address(this).balance}();\n        }\n\n        address underlyingAddress = underlying.tokenAddress == address(0)\n            ? address(WETH)\n            : underlying.tokenAddress;\n        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);\n\n        return redeemedExternalUnderlying;\n    }\n    function transferReserveToTreasury(uint16[] calldata currencies)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; i++) {\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n            if (bufferInternal == 0) continue;\n            (int256 reserveInternal, , , ) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n\n            if (reserveInternal <= bufferInternal) continue;\n\n            Token memory asset = TokenHandler.getAssetToken(currencyId);\n\n            int256 assetInternalRedeemAmount = reserveInternal.subNoNeg(bufferInternal);\n\n            amountsTransferred[i] = _redeemAndTransfer(\n                currencyId,\n                asset,\n                assetInternalRedeemAmount\n            );\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                assetInternalRedeemAmount\n            );\n        }\n        return amountsTransferred;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-01-notional#h-01-treasury-cannot-claim-comp-tokens--comp-tokens-are-stuck",
                "Location": "claimCOMPAndTransfer function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Treasury cannot claim COMP tokens & COMP tokens are stuck,The TreasuryAction.claimCOMPAndTransfer function uses pre- and post-balances of the COMP token to check which ones to transfer.Note that anyone can claim COMP tokens on behalf of any address (see Comptroller.claimComp). An attacker can claim COMP tokens on behalf of the contract and it\u2019ll never be able to claim any compound itself. The COMP claimed by the attacker are stuck in the contract and cannot be retrieved. (One can eventually get back the stuck COMP by creating a cCOMP market and then transferring it through transferReserveToTreasury.)",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.7;\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"./Swapper.sol\";\n\ncontract GenericSwapFacet is ILiFi, Swapper {\n    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-03-lifinance#h-01-reliance-on-lifidatareceivingassetid-can-cause-loss-of-funds",
                "Location": "uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n _executeSwaps(_lifiData, _swapData);\n uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance); in swapTokensGeneric function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Reliance on lifiData.receivingAssetId can cause loss of funds,In the swapTokensGeneric() function, an arbitrary number of swaps can be performed from and to various tokens. However, the final balance that is sent to the user relies on _lifiData.receivingAssetId which has no use in the swapping functionality. LifiData is claimed to be used purely for analytical reasons per the comments to this function. If this value is input incorrectly, the swapped tokens will simply sit in the contract and be lost to the user.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract JPEGLock is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    event Lock(address indexed user, uint256 indexed nftIndex, uint256 amount);\n    event Unlock(address indexed user, uint256 indexed nftIndex, uint256 amount);\n\n    struct LockPosition {\n        address owner;\n        uint256 unlockAt;\n        uint256 lockAmount;\n    }\n\n    IERC20 public immutable jpeg;\n\n    uint256 public lockTime;\n\n    mapping(uint256 => LockPosition) public positions;\n\n    constructor(IERC20 _jpeg) Ownable() ReentrancyGuard() {\n        jpeg = _jpeg;\n        lockTime = 365 days;\n    }\n    function setLockTime(uint256 _newTime) external onlyOwner {\n        require(_newTime > 0, \"Invalid lock time\");\n        lockTime = _newTime;\n    }\n    function lockFor(\n        address _account,\n        uint256 _nftIndex,\n        uint256 _lockAmount\n    ) external onlyOwner nonReentrant {\n        jpeg.safeTransferFrom(_account, address(this), _lockAmount);\n\n        positions[_nftIndex] = LockPosition({\n            owner: _account,\n            unlockAt: block.timestamp + lockTime,\n            lockAmount: _lockAmount\n        });\n\n        emit Lock(_account, _nftIndex, _lockAmount);\n    }\n    function unlock(uint256 _nftIndex) external nonReentrant {\n        LockPosition memory position = positions[_nftIndex];\n        require(position.owner == msg.sender, \"unauthorized\");\n        require(position.unlockAt <= block.timestamp, \"locked\");\n\n        delete positions[_nftIndex];\n\n        jpeg.safeTransfer(msg.sender, position.lockAmount);\n\n        emit Unlock(msg.sender, _nftIndex, position.lockAmount);\n    }\n\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-04-jpegd#h-02-existing-users-locked-jpeg-could-be-overwritten-by-new-user-causing-permanent-loss-of-jpeg-funds",
                "Location": "jpeg.safeTransferFrom(_account, address(this), _lockAmount);positions[_nftIndex] = LockPosition({owner: _account,unlockAt: block.timestamp + lockTime,lockAmount: _lockAmount});emit Lock(_account, _nftIndex, _lockAmount); in lockFor function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Existing user\u2019s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds,A user\u2019s JPEG lock schedule can be overwritten by another user\u2019s if he (the other user) submits and finalizes a proposal to change the same NFT index\u2019s value.The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function borrowAllowed ( address xToken , uint256 orderId , address borrower , uint256 borrowAmount) external whenNotPaused(xToken , 3){\n require ( poolStates [ xToken ] . isListed , \"xToken not listed\") ;\n address _collection = orderAllowed ( orderId , borrower ) ;\n CollateralState storage _collateralState = collateralStates[ _collection ] ;\n require ( _collateralState . isListed , \"collection not exist\") ;\n require ( _collateralState . supportPools [ xToken ] _collateralState .iupportAllPools , \"collection don\u2019t support this pool\") ;\n address _lastXToken = orderDebtStates [ orderId ] ;\n require ( _lastXToken == address (0) _lastXToken == xToken , \"only supportborrowing of one xToken\") ;\n ( uint256 _price , bool valid ) = oracle . getPrice ( _collection , IXToken(xToken) .\n underlying () ) ;\n  require ( _price > 0 && valid , \"price is not valid\") ;\n \n  // Borrow cap of 0 corresponds to unlimited borrowing\n  if ( poolStates [ xToken ] . borrowCap != 0) {\n  require (IXToken(xToken) . totalBorrows () . add(borrowAmount) < poolStates [ xToken\n ] . borrowCap , \"pool borrow cap reached\") ;\n  }\n \n  uint256 _maxBorrow = mulScalarTruncate ( _price , _collateralState . collateralFactor) ;\n  uint256 _mayBorrowed = borrowAmount ;\n  if(_lastXToken != address (0) ){\n  _mayBorrowed = IXToken( _lastXToken ) . borrowBalanceStored ( orderId ) . add(borrowAmount) ;\n  }\n  require (_mayBorrowed <= _maxBorrow , \"borrow amount exceed\") ;\n if( _lastXToken == address (0) ){\n  orderDebtStates [ orderId ] = xToken ;\n  }\n  }",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-XCarnival-v1.0/3.4 Tightened Access Control In borrowAllowed()",
                "Location": "borrowAllowed",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.It validates the input parameters with current pool states, and return if the borrow is allowed or revert if it is not allowed. Specially, there is a state variable orderDebtStates[orderId] that records the allowed borrow pool for the given order. If the input xToken doesn\u2019t equal to the orderDebtStates[orderId] , the borrow operation is refused, meaning the pledger can borrow from no more than one pool for the given order. The orderDebtStates[orderId] is updated (line 90-92) at the end of the borrowAllowed() during the first time the pledger borrows for the order. However, it comes to our attention that the borrowAllowed() is public accessible, which may lead to the orderDebtStates[orderId] being faked by malicious user and the pledger can not borrow from other pool for its order any more.",
                "Repair": "Tighten the access control policy on the above-mentioned borrowAllowed()routine"
            }
        ]
    },
    {
        "Code": "function afterLP() external{\n isExchange[uniswapV2Pair] = true;\n isExchange[secondV2Pair] = true;\n onlySB = preLiqSB;\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-FEG-SmartDeFi-v1.1/4.1 Suggested Access Control to Set onlySB",
                "Location": "afterLP function. onlySB = preLiqSB;",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.In the SMARTDeFi contract, there is a state variable, i.e., onlySB , which controls how the transaction is taxed. Per design, when the onlySB is true, it only taxes on buy/sell transactions. When the onlySB is false, it taxes on all transactions. While examining the update of the onlySB logic, we notice there is no access control for the afterLP() routine, which allows anyone to reset the onlySB back to the initial value. To elaborate, we show below the code snippet of the afterLP() routine. As the name indicates, it is used to be called after the liquidity has been added to enable the exchange taxes. It resets the onlySB to preLiqSB which is the default value initialized in the constructor. However, there is a lack of proper access control in this routine and anyone can call it at any time. As a result, the transactions may be taxed unexpectedly.",
                "Repair": "Add necessary access control in the afterLP() routine"
            }
        ]
    },
    {
        "Code": "function updateCapsuleCollectionOwner(address _previousOwner, address _newOwner) external {\n    address _capsule = _msgSender();\n    require(isCapsule[_capsule], Errors.NOT_CAPSULE);\n    require(capsulesOf[_previousOwner].remove(_capsule), Errors.ADDRESS_DOES_NOT_EXIST);\n    require(capsulesOf[_newOwner].add(_capsule), Errors.ADDRESS_ALREADY_EXIST);\n    emit CapsuleOwnerUpdated(_capsule, _previousOwner, _newOwner);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "/Quantstamp/capsule-nft.pdf/QSP-1 Access control vulnerability in CapsuleFactory.updateCapsuleCollectionOwner(...)",
                "Location": "updateCapsuleCollectionOwner function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.Although the inline comment states that the function updateCapsuleCollectionOwner() can be called only by the Capsule Collection as part of the transferOwnership(), we notice that this function has external visibility and, apparently, no access control. This function transfers the ownership  from _previousOwner to the _newOwner without any consentiment from any of the parties. The function is reproduced below.",
                "Repair": "Double-check the function and consider to: Recommendation: 1.Implement an access control strategy in order to guarantee that the (and the ) acknowledge the transfer; _previousOwner _newOwner 2.Guarantee that only the of Capsule can call this function to change the owner of Capsule , and any other Capsule; owner A A 3.Check if the input parameters are different from ; address(0x0) 4.Clear specify this use case. Is it necessary to validate if the is a whitelisted or blacklisted address before transfering the ownership?"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBasePool.sol\";\nimport \"./base/TokenSaver.sol\";\n\ncontract LiquidityMiningManager is TokenSaver {\n\n    bytes32 public constant GOV_ROLE = keccak256(\"GOV_ROLE\");\n    bytes32 public constant REWARD_DISTRIBUTOR_ROLE = keccak256(\"REWARD_DISTRIBUTOR_ROLE\");\n\n    IERC20 immutable public reward;\n    address immutable public rewardSource;\n    uint256 public rewardPerSecond; //total reward amount per second\n    uint256 public lastDistribution; //when rewards were last pushed\n    uint256 public totalWeight;\n\n    mapping(address => bool) public poolAdded;\n    Pool[] public pools;\n\n    struct Pool {\n        IBasePool poolContract;\n        uint256 weight;\n    }\n\n    modifier onlyGov {\n        require(hasRole(GOV_ROLE, _msgSender()), \"LiquidityMiningManager.onlyGov: permission denied\");\n        _;\n    }\n\n    modifier onlyRewardDistributor {\n        require(hasRole(REWARD_DISTRIBUTOR_ROLE, _msgSender()), \"LiquidityMiningManager.onlyRewardDistributor: permission denied\");\n        _;\n    }\n\n    event PoolAdded(address indexed pool, uint256 weight);\n    event PoolRemoved(uint256 indexed poolId, address indexed pool);\n    event WeightAdjusted(uint256 indexed poolId, address indexed pool, uint256 newWeight);\n    event RewardsPerSecondSet(uint256 rewardsPerSecond);\n    event RewardsDistributed(address _from, uint256 indexed _amount);\n\n    constructor(address _reward, address _rewardSource) {\n        reward = IERC20(_reward);\n        rewardSource = _rewardSource;\n    }\n\n    function addPool(address _poolContract, uint256 _weight) external onlyGov {\n        distributeRewards();\n        require(!poolAdded[_poolContract], \"LiquidityMiningManager.addPool: Pool already added\");\n        // add pool\n        pools.push(Pool({\n            poolContract: IBasePool(_poolContract),\n            weight: _weight\n        }));\n        poolAdded[_poolContract] = true;\n        \n        // increase totalWeight\n        totalWeight += _weight;\n\n        // Approve max token amount\n        reward.approve(_poolContract, type(uint256).max);\n\n        emit PoolAdded(_poolContract, _weight);\n    }\n\n    function removePool(uint256 _poolId) external onlyGov {\n        distributeRewards();\n        address poolAddress = address(pools[_poolId].poolContract);\n\n        // decrease totalWeight\n        totalWeight -= pools[_poolId].weight;\n        \n        // remove pool\n        pools[_poolId] = pools[pools.length - 1];\n        pools.pop();\n        poolAdded[poolAddress] = false;\n\n        emit PoolRemoved(_poolId, poolAddress);\n    }\n\n    function adjustWeight(uint256 _poolId, uint256 _newWeight) external onlyGov {\n        distributeRewards();\n        Pool storage pool = pools[_poolId];\n\n        totalWeight -= pool.weight;\n        totalWeight += _newWeight;\n\n        pool.weight = _newWeight;\n\n        emit WeightAdjusted(_poolId, address(pool.poolContract), _newWeight);\n    }\n\n    function setRewardPerSecond(uint256 _rewardPerSecond) external onlyGov {\n        distributeRewards();\n        rewardPerSecond = _rewardPerSecond;\n\n        emit RewardsPerSecondSet(_rewardPerSecond);\n    }\n\n    function distributeRewards() public onlyRewardDistributor {\n        uint256 timePassed = block.timestamp - lastDistribution;\n        uint256 totalRewardAmount = rewardPerSecond * timePassed;\n        lastDistribution = block.timestamp;\n\n        // return if pool length == 0\n        if(pools.length == 0) {\n            return;\n        }\n\n        // return if accrued rewards == 0\n        if(totalRewardAmount == 0) {\n            return;\n        }\n\n        reward.transferFrom(rewardSource, address(this), totalRewardAmount);\n\n        for(uint256 i = 0; i < pools.length; i ++) {\n            Pool memory pool = pools[i];\n            uint256 poolRewardAmount = totalRewardAmount * pool.weight / totalWeight;\n            // ignore tx failing\n            address(pool.poolContract).call(abi.encodeWithSelector(pool.poolContract.distributeRewards.selector, poolRewardAmount));\n        }\n\n        uint256 leftOverReward = reward.balanceOf(address(this));\n\n        // send back excess but ignore dust\n        if(leftOverReward > 1) {\n            reward.transfer(rewardSource, leftOverReward);\n        }\n\n        emit RewardsDistributed(_msgSender(), totalRewardAmount);\n    }\n\n    function getPools() external view returns(Pool[] memory result) {\n        return pools;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/Quantstamp/merit-circle.pdf/QSP-1 Write to Arbitrary Storage Location",
                "Location": "removePool function",
                "Type": "ID-related violations",
                "Description": " ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.In LiquidityMiningManager. removePoolC) parameter _poolId is not checked to be within the bounds of pools. length, ollowing the coller to write the contents of pools[pools. length-1] to on orbitrory storoge locotion, by corefully crofting _pool Id, when executing L75 of LiquidityMiningManager. sol. Similorly, but in this case performable by anyone and not just an address having the GOV_ROLE role, in TimeLockPool .withdrawC)_depositId is not checked to be within the bounds of depositsOf[_msgSender()]. Length, allowing the caller to write the contents of depositsOf[_msgSender()][depositsOf[_msgSender()].length - 1 ] to an arbitrary\nlocation, by carefully crafting _depositId, when executing L71 of TimeLockPool sol. See https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte for refer\n",
                "Repair": "Add a check for to be smaller than and smaller than in\nand respectively.\nRecommendation: _poolId pools.length _depositId depositsOf[_msgSender()].length in LiquidityMiningManager.removePool() TimeLockPool.withdraw("
            }
        ]
    },
    {
        "Code": "function runLMS() public {\n\nif(viewifTrue() == true) {\nlastTimeProcessedLMS lastTimeProcessedLMS = block.timestamp;\nlmsDist lmsDist = true;\ndividendTracker dividendTracker.populateLastManStanding(gasForProcessing);\n}\n\n}\n \n function distLMS() public {\n \n if(lmsDist == true) {\n lmsDist lmsDist = false;\n dividendTracker dividendTracker.processLastManStanding(gasForProcessing);\n }\n \n }",
        "VulnerabilityDesc": [
            {
                "Name": " certik/CertiK-Audit-for-Zada-v13.pdf/Missing Access Restrictio runLMS",
                "Location": "runLMS functione",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.Function runLMS() can be called by any external users. Since these two functions affect some critical parameters in the contract, missing access restriction here may cause potential denial of service attack.",
                "Repair": ""
            },
            {
                "Name": " certik/CertiK-Audit-for-Zada-v13.pdf/Missing Access Restrictio distLMS",
                "Location": "distLMS functione",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.Function distLMS() can be called by any external users. Since these two functions affect some critical parameters in the contract, missing access restriction here may cause potential denial of service attack.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function withdraw(uint16 tokenId, address to, uint256 amount, uint256 maxAmount, uint256 lossBip) onlyZkSync external returns\n(uint256) {\n    _validateToken(tokenId);\n    if (amount == 0) {\n        return 0;\n    }\n\n    require(strategy != address(0), 'Vault: zero strategy address');\n\n    uint16 tokenId = IStrategy(strategy).want();\n    _validateToken(tokenId);\n    TokenVault storage tv = tokenVaults[tokenId];\n    require(tv.strategy != address(0), 'Vault: no strategy');\n    require(tv.strategy != strategy, 'Vault: upgrade to self');\n\n\nfunction migrateStrategy(uint16 tokenId) external {\nfunction migrateStrategy(uint16 tokenId) onlyNetworkGovernor external {\n    TokenVault storage tv = tokenVaults[tokenId];\n    require(tv.strategy != address(0), 'Vault: no strategy');\n    require(tv.status == StrategyStatus.PREPARE_UPGRADE, 'Vault: require prepare upgrade');",
        "VulnerabilityDesc": [
            {
                "Name": "certik/CertiK-Audit-for-zklink.pdf/Lack Of Access Restrictio",
                "Location": "migrateStrategy function",
                "Type": "ID-related violations",
                "Description": "Shared resource (e.g., token) without proper locks.migrateStrategy() function is designed to migrate a specific token's current strategy to its prepared strategy. Currently, any external caller can call this function to execute the strategy migration once the take-effect time reached.",
                "Repair": "We advise the client to add the onlyNetworkGovernor modifier to the function migrateStrategy() to only allow the governor to execute the strategy migration."
            }
        ]
    },
    {
        "Code": "function setSwapTime(uint _startingSwapTime) external {\n /* require(msg.sender == factory, 'Pancake: FORBIDDEN'); // sufficient check*/\n startingSwapTime = _startingSwapTime;\n \n }",
        "VulnerabilityDesc": [
            {
                "Name": "certik/REP-Alita-2021-10-01.pdf/Lack of access control",
                "Location": "setSwapTime function ",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.The require statement in the setSwapTime() gets commented out, hence anyone can call this function to set startingSwapTime",
                "Repair": "We recommend keeping this require statement, ensuring the access is granted to the factory only"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\ncontract TokenAddresses {\n    string public constant GLOBAL = \"GLOBAL\";\n    string public constant CAKE = \"CAKE\";\n    string public constant BNB = \"BNB\";   // ERC20 on eth\n    string public constant WBNB = \"WBNB\"; // BEP20 on bsc\n    string public constant BUSD = \"BUSD\";\n    string public constant BUNNY = \"BUNNY\";\n    string public constant CAKE_WBNB_LP = \"CAKE-WBNB-LP\";\n\n    mapping (string => address) private tokens;\n\n    function findByName(string memory _tokenName) external view returns (address) {\n        require(tokens[_tokenName] != address(0), \"Token does not exists.\");\n        return tokens[_tokenName];\n    }\n\n    function addToken(string memory _tokenName, address _tokenAddress) external {\n        require(tokens[_tokenName] == address(0), \"Token already exists.\");\n        tokens[_tokenName] = _tokenAddress;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "certik/REP-BeGlobal-2021-11-12.pdf/Missing access restrictio addToken",
                "Location": "addToken function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.After this contract is deployed, hackers can be the first to call this function to register malicious contracts to potentially steal funds afterward.",
                "Repair": "We advise the client to restrict the access to this function to governance account only."
            }
        ]
    },
    {
        "Code": "function setMinter(address _minter) external {\n    require(IMinter(_minter).isMinter(address(this)) == true, \"This vault must be a minter in minter's contract\");\n    minter = IMinter(_minter);\n    _allowance(cake, _minter);\n}",
        "VulnerabilityDesc": [
            {
                "Name": "certik/REP-BeGlobal-2021-11-12.pdf/Missing access restrictio setMinter",
                "Location": "setMinter function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.A hacker can call the setMinter() function to set a malicious minter contract which will be invoked by the VaultCake contract.",
                "Repair": "We advise the client to restrict the access to this function to governance account only."
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.6;\n contract CurveFactory is Ownable {\n     uint256 private totalRateLimit = 50;\n \n     address payable public platform; // % of total minting cost as platform commission\n \n     event CurveCreated(\n         address indexed owner,\n         address indexed curveAddr,\n         uint256 initMintPrice,\n         uint256 m,\n         uint256 n,\n         uint256 d\n     );\n \n     constructor() {}\n    function setPlatformParms(address payable _platform, uint256 _platformRate)\n         public\n         onlyOwner\n     {\n         platform = _platform;\n         platformRate = _platformRate;\n     }\n \n     // set the limit of total commission rate, only operable by contract owner, _totalRateLimit is in pph\n     function setTotalRateLimit(uint256 _totalRateLimit) public onlyOwner {\n         totalRateLimit = _totalRateLimit;\n     }\n \n \n     function createCurve(\n         string memory _name,\n         string memory _symbol,\n         address payable _creator,\n         uint256 _creatorRate,\n         uint256 _initMintPrice,\n         address _erc20,\n         uint256 _m,\n         uint256 _n,\n         uint256 _d,\n         string memory _baseUri\n     ) public {\n         require(\n             _creatorRate <= totalRateLimit - platformRate,\n             \"Curve: creator's commission rate is too high.\"\n         );\n         Curve curve = new Curve(\n             _name,\n             _symbol,\n             _baseUri,\n             _erc20,\n             _initMintPrice,\n             _m,\n             _n,\n             _d\n         );\n         curve.setFeeParameters(platform, platformRate, _creator, _creatorRate);\n         address curveAddr = address(curve); \n         emit CurveCreated(msg.sender, curveAddr, _initMintPrice, _m, _n, _d);\n     }\n }",
        "VulnerabilityDesc": [
            {
                "Name": "certik/REP-The-PASS-2021-12-17(2)(1).pdf/Lack of Access Control on `createCurve()",
                "Location": "createCurve function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.The function createCurve() is design to create new curve. Currently, there is no access control to this function and therefore any external caller can call this function.",
                "Repair": "We would like to confirm with the client that if the specific implementation matches the design."
            }
        ]
    },
    {
        "Code": "function setMaxTxPercent(uint256 maxTxPercent) public {\n    require(maxTxPercent > 0, \"Cannot set transaction amount less than 1 percent!\");\n    _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n    10**2\n    );\n}\n     \n function setMaxWalletPercent(uint256 maxWalletPercent) public {\n     require(maxWalletPercent > 0, \"Cannot set transaction amount less than 1 percent!\");\n    _maxWalletToken = _tTotal.mul(maxWalletPercent).div(\n     10**2\n     );\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-Squid-Net-Game-v7.pdf/Missing Access Restriction",
                "Location": "function setMaxTxPercent(uint256 maxTxPercent) ; function setMaxWalletPercent(uint256 maxWalletPercent)",
                "Type": "ID-related violations",
                "Description": "Shared resource (e.g., token) without proper locks.In the buyTokenByEthWithRate function of the PChannel_APT contract, arbitrary value could be passed to the _ethUsdRate by users, as a result, the usdAmount could be any value if users want, and the programSize can also be Manipulated.\n",
                "Repair": "We advise the client to add onlyOwner() modifier to guarantee the function caller must be the contract owner."
            }
        ]
    },
    {
        "Code": "function fundERC20(address tokenAddress, address owner, uint256 amount) public {\n IERC20 erc20 = IERC20(tokenAddress);\n _safeTransferFrom(erc20, owner, address(this), amount);\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-stafi-v4.pdf/Arbitrary owner address in unrestricted fundERC20",
                "Location": "function fundERC20",
                "Type": "ID-related violations",
                "Description": "Shared resource (e.g., token) without proper locks.The fundERC20 function in the ERC20Safe contract did not implement access restriction and took an arbitrary owner address parameter instead of referencing msg.sender :",
                "Repair": "We recommended determining if the fundERC20 function should be unrestricted:\nIf not, implement proper access restriction for the funcERC20 function \nIf so, consider replacing the usage of the arbitrary owner address parameter with msg.sender"
            }
        ]
    },
    {
        "Code": "function initialize(   \n        address svLaunch,\n        address campOwner, \n        address deed,\n        address currencyToken\n    ) onlyFactory external\n    {\n        svLaunchAddress = svLaunch;\n        campaignOwner = campOwner; \n        deedNftAddress = deed;\n        currencyAddress = currencyToken;\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-Superlauncher.pdf/Lack of Access Control for Initialization",
                "Location": "svLaunchAddress = svLaunch;\n        campaignOwner = campOwner; \n        deedNftAddress = deed;\n        currencyAddress = currencyToken;",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The current initialize function is not restricted. The initialization can be invoked multiple time, this is might be dangerous operation if the there any incident happened which the attacker take the controlled, they might able to replace all the contracts with the malicious one.",
                "Repair": "We advise that the function should be more restricted in term of invocation and sanity check for inputs"
            }
        ]
    },
    {
        "Code": "interface IPancakeswapFarm {\n    function poolLength() external view returns (uint256);\n\n    function userInfo() external view returns (uint256);\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint256 _from, uint256 _to)\n        external\n        view\n        returns (uint256);\n\n    // View function to see pending CAKEs on frontend.\n    function pendingCake(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256);\n\n    // Deposit LP tokens to MasterChef for CAKE allocation.\n    function deposit(uint256 _pid, uint256 _amount) external;\n\n    // Withdraw LP tokens from MasterChef.\n    function withdraw(uint256 _pid, uint256 _amount) external;\n\n    // Stake CAKE tokens to MasterChef\n    function enterStaking(uint256 _amount) external;\n\n    // Withdraw CAKE tokens from STAKING.\n    function leaveStaking(uint256 _amount) external;\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) external;\n}  \nfunction withdraw(address _userAddress, uint256 _wantAmt)\n        public\n        onlyOwner\n        nonReentrant\n        returns (uint256)\n    {\n        require(_wantAmt > 0, \"_wantAmt <= 0\");\n\n        if (isNativeVault) {\n            IPancakeswapFarm(farmContractAddress).withdraw(pid, _wantAmt);\n        }\n\n        uint256 wantAmt = IERC20(wantAddress).balanceOf(address(this));\n        if (_wantAmt > wantAmt) {\n            _wantAmt = wantAmt;\n        }\n\n        if (wantLockedTotal < _wantAmt) {\n            _wantAmt = wantLockedTotal;\n        }\n\n        uint256 sharesRemoved = _wantAmt.mul(sharesTotal).div(wantLockedTotal);\n        if (sharesRemoved > sharesTotal) {\n            sharesRemoved = sharesTotal;\n        }\n        sharesTotal = sharesTotal.sub(sharesRemoved);\n        wantLockedTotal = wantLockedTotal.sub(_wantAmt);\n\n        IERC20(wantAddress).safeTransfer(nativeFarmAddress, _wantAmt);\n\n        return sharesRemoved;\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-SwampFinance-v10.pdf/Missing Access Control",
                "Location": " if (isNativeVault) {\n            IPancakeswapFarm(farmContractAddress).withdraw(pid, _wantAmt);\n        }",
                "Type": "ID-related violations",
                "Description": "Shared resource (e.g., token) without proper locks.Function farm is public and thus can be called by anyone. When !isNativeVault and farm is called, wantAddress token will be sent to farmContractAddress. Because function withdraw withdraws token from farmContractAddress only when isNativeVault, users will not be able to withdraw token sent to farmContractAddress when !isNativeVault.",
                "Repair": "We recommend checking if isNativeVault is true in function farm."
            }
        ]
    },
    {
        "Code": "    /**\n     * @notice Used to finalise the pool with the required attributes and operations\n     *\n     * @dev Checks, pool is finalised, caller is controller, supplied token balance\n     * should be equal\n     * @dev Binds the token, and its leverage and balance\n     * @dev Calculates the iniyial pool supply, mints and transfer to the controller\n     *\n     * @param _primaryBalance Balance amount of primary token\n     * @param _primaryLeverage Leverage value of primary token\n     * @param _complementBalance  Balance amount of complement token\n     * @param _complementLeverage  Leverage value of complement token\n     * @param _exposureLimitPrimary TODO: Need to check this\n     * @param _exposureLimitComplement TODO: Need to check this\n     * @param _pMin TODO: Need to check this\n     * @param _qMin TODO: Need to check this\n     */\n    function finalize(\n        uint256 _primaryBalance,\n        uint256 _primaryLeverage,\n        uint256 _complementBalance,\n        uint256 _complementLeverage,\n        uint256 _exposureLimitPrimary,\n        uint256 _exposureLimitComplement,\n        uint256 _pMin,\n        uint256 _qMin\n    ) external _logs_ _lock_ onlyNotSettled {\n        require(!_finalized, 'VolmexAMM: AMM is finalized');\n\n        require(_primaryBalance == _complementBalance, 'VolmexAMM: Assets balance should be same');\n\n        require(baseFee > 0, 'VolmexAMM: baseFee should be larger than 0');\n\n        pMin = _pMin;\n        qMin = _qMin;\n        exposureLimitPrimary = _exposureLimitPrimary;\n        exposureLimitComplement = _exposureLimitComplement;\n\n        _finalized = true;\n\n        _bind(0, address(protocol.volatilityToken()), _primaryBalance, _primaryLeverage);\n        _bind(\n            1,\n            address(protocol.inverseVolatilityToken()),\n            _complementBalance,\n            _complementLeverage\n        );\n\n        uint256 initPoolSupply = getDerivativeDenomination() * _primaryBalance;\n\n        uint256 collateralDecimals = uint256(protocol.collateral().decimals());\n        if (collateralDecimals >= 0 && collateralDecimals < 18) {\n            initPoolSupply = initPoolSupply * (10**(18 - collateralDecimals));\n        }\n\n        _mintPoolShare(initPoolSupply);\n        _pushPoolShare(msg.sender, initPoolSupply);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-Volmex---AMM-v2.pdf/VAM-01 Missing Access Control",
                "Location": " _finalized = true;",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The function finalize() finalizes the volatility tokens and updates the state variable _finalized . The comments of the aforementioned function indicate that this function should only be called by the role controller . However, this function does not have proper access controls.",
                "Repair": "We recommend enforcing modifier onlyController() to the aforementioned function."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\n// Builds new Pools, logging their addresses and providing `isPool(address) -> (bool)`\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport './interfaces/IVolmexAMM.sol';\nimport './interfaces/IPausablePool.sol';\n\ncontract VolmexAMMRegistry is OwnableUpgradeable {\n    event LOG_NEW_POOL(\n        address indexed caller,\n        address indexed pool,\n        uint256 indexed poolIndex\n    );\n\n    uint256 public index;\n    address[] internal _pools;\n    mapping(address => bool) private _isPool;\n\n    function initialize() external initializer {\n        __Ownable_init();\n    }\n\n    function isPool(address _pool) external view returns (bool) {\n        return _isPool[_pool];\n    }\n\n    function registerNewPool(address _newPool) external {\n        require(!_isPool[_newPool], 'VolmexAMMRegistry: AMM already exist');\n\n        _pools.push(_newPool);\n        _isPool[_newPool] = true;\n        index++;\n        emit LOG_NEW_POOL(msg.sender, _newPool, index);\n    }\n\n    function pausePool(IPausablePool _pool) public onlyOwner {\n        _pool.pause();\n    }\n\n    function unpausePool(IPausablePool _pool) public onlyOwner {\n        _pool.unpause();\n    }\n\n    function collect(IVolmexAMM pool) external onlyOwner {\n        uint256 collected = IERC20(pool).balanceOf(address(this));\n        bool xfer = pool.transfer(owner(), collected);\n        require(xfer, 'ERC20_FAILED');\n    }\n\n    function getPool(uint256 _index) external view returns (address) {\n        return _pools[_index];\n    }\n\n    function getLastPoolIndex() external view returns (uint256) {\n        return _pools.length - 1;\n    }\n\n    function getAllPools() external view returns (address[] memory) {\n        return _pools;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-Volmex---AMM-v2.pdf/VAR-02 Missing Access Control",
                "Location": "_pools.push(_newPool);\n        _isPool[_newPool] = true;\n        index++;",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The function registerNewPool() registers new pools. Calling this function updates state variables index ,_isPool and _pools . Anyone can call this function to register new pools. We would like to check with the Volmex team whether this is an intended design.\n",
                "Repair": "We recommend setting a proper access control for the function registerNewPool() if it is not an intended\ndesign."
            }
        ]
    },
    {
        "Code": "/**\n     * @notice Deposits ETH.\n     *\n     * @param _amount The amount;\n     * @param _weth The address for WETH.\n     */\n    function depositETH(address _weth, uint256 _amount) external payable whenNotPaused {\n        require(msg.value == _amount, ErrMsg.REQ_BAD_AMOUNT);\n        _deposit(_weth, _amount, msg.sender);\n        IWETH(_weth).deposit{value: _amount}();\n    } \n/**\n     * @notice Executes pending withdraw of ETH to an account.\n     *\n     * @param _account The destination account.\n     * @param _weth The address for WETH.\n     */\n    function withdrawETH(address _account, address _weth) external whenNotPaused {\n        uint256 amount = _withdraw(_account, _weth);\n        IWETH(_weth).withdraw(amount);\n        (bool sent, ) = _account.call{value: amount}(\"\");\n        require(sent, ErrMsg.REQ_NO_WITHDRAW);\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-Brewlabs-v11.pdf/Lack Of Access Restriction",
                "Location": "address _weth",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The linked lines contain arbitrary address parameters which are intended to represent the wETH address.",
                "Repair": "Since the wETH address is well-known, consider removing the wETH parameters at the linked lines and utilizing a constant to represent the well-known wETH address instead."
            }
        ]
    },
    {
        "Code": "/**\n     * @notice Executes pending withdraw of an asset to an account.\n     *\n     * @param _account The destination account.\n     * @param _asset The asset address;\n     */\n    function withdraw(address _account, address _asset) external whenNotPaused {\n        uint256 amount = _withdraw(_account, _asset);\n        IERC20(_asset).safeTransfer(_account, amount);\n    }\n\n    /**\n     * @notice Executes pending withdraw of ETH to an account.\n     *\n     * @param _account The destination account.\n     * @param _weth The address for WETH.\n     */\n    function withdrawETH(address _account, address _weth) external whenNotPaused {\n        uint256 amount = _withdraw(_account, _weth);\n        IWETH(_weth).withdraw(amount);\n        (bool sent, ) = _account.call{value: amount}(\"\");\n        require(sent, ErrMsg.REQ_NO_WITHDRAW);\n    }\n /**\n     * @notice internal withdrawal processing without actual token transfer.\n     *\n     * @param _account The destination account.\n     * @param _asset The asset token address.\n     * @return amount to withdraw\n     */\n    function _withdraw(address _account, address _asset) private returns (uint256) {\n        uint32 assetId = registry.assetAddressToIndex(_asset);\n        require(assetId > 0, ErrMsg.REQ_BAD_ASSET);\n\n        uint256 amount = pendingWithdraws[_account][assetId];\n        require(amount > 0, ErrMsg.REQ_BAD_AMOUNT);\n\n        if (netDeposits[_asset] < amount) {\n            netDeposits[_asset] = 0;\n        } else {\n            netDeposits[_asset] -= amount;\n        }\n        pendingWithdraws[_account][assetId] = 0;\n\n        emit AssetWithdrawn(_account, assetId, amount);\n        return amount;\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-Celer-Layer2-Finance-v2-v12.pdf/Anyone can induce a withdraw for an arbitrary account",
                "Location": "_withdraw(_account, _asset); _withdraw(_account, _weth);",
                "Type": "ID-related violations",
                "Description": "The external withdraw and withdrawETH functions in the RollupChain contract both take an arbitrary\n_account address parameter instead of utilizing msg.sender , which allows anyone to request a withdraw\nfor a particular account without permission for msg.sender to do so, which may be undesired by the\naccount owning the funds.",
                "Repair": "Consider removing the _account address parameter and supplying msg.sender in its place in the call to\nthe _withdraw function."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.10;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\ncontract CoolGas is Initializable,ERC20Upgradeable,AccessControlUpgradeable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    function initialize (string memory name_, string memory symbol_, address  initialHolder_, uint256  initialSupply_) initializer public {\n        __ERC20_init_unchained (name_, symbol_);\n        __AccessControl_init_unchained();\n        __CoolGas_init_unchained(initialHolder_, initialSupply_);\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\n    }\n    function __CoolGas_init_unchained(address  initialHolder_, uint256  initialSupply_) initializer public {\n        _mint(initialHolder_, initialSupply_);\n    }\n    function mint(address account, uint256 amount) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _mint(account, amount);\n    }\n    function burn(address account, uint256 amount) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _burn(account, amount);\n    }\n    function mintGas(address account, uint256 amount) external onlyRole(MINTER_ROLE) {\n        _mint(account, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-Coolmining.pdf/Lack of Access Control",
                "Location": "initialize function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The following functions can be called by anyone to update the sensitive stats of the contract or mint\ntokens:\ninitialize() in contract CoolGas",
                "Repair": "We recommend adding proper access control to this function or checking the status of initialization in the\ndeployment process."
            }
        ]
    }
]