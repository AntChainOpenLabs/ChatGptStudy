[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport \"../interfaces/IMochiEngine.sol\";\r\nimport \"../interfaces/ICurveVotingEscrow.sol\";\r\n\r\ncontract MochiTreasuryV0 {\r\n    IMochiEngine public immutable engine;\r\n\r\n    IUniswapV2Router02 public immutable uniswapRouter;\r\n\r\n    IERC20 public immutable crv;\r\n    ICurveVotingEscrow public immutable veCrv;\r\n    bool public lockCrv;\r\n    uint256 public operationShare;\r\n    uint256 public veCRVShare;\r\n\r\n    constructor(\r\n        address _engine,\r\n        address _uniswap,\r\n        address _crv,\r\n        address _veCrv\r\n    ) {\r\n        engine = IMochiEngine(_engine);\r\n        uniswapRouter = IUniswapV2Router02(_uniswap);\r\n        crv = IERC20(_crv);\r\n        veCrv = ICurveVotingEscrow(_veCrv);\r\n        lockCrv = false;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function withdrawCRV() external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        crv.transfer(msg.sender, crv.balanceOf(address(this)));\r\n    }\r\n\r\n    function withdrawLock() external {\r\n        veCrv.withdraw();\r\n    }\r\n\r\n    function veCRVInitialize() external {\r\n        require(lockCrv, \"!lock\");\r\n        updateFee();\r\n        _buyCRV();\r\n        veCrv.create_lock(\r\n            crv.balanceOf(address(this)),\r\n            block.timestamp + 90 days\r\n        );\r\n    }\r\n\r\n    function toggleLocking() external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        lockCrv = !lockCrv;\r\n    }\r\n\r\n    function updateFee() public {\r\n        uint256 updatedFee = engine.usdm().balanceOf(address(this)) -\r\n            operationShare -\r\n            veCRVShare;\r\n        operationShare += updatedFee / 2;\r\n        veCRVShare += updatedFee / 2;\r\n    }\r\n\r\n    function claimOperationCost() external {\r\n        updateFee();\r\n        engine.usdm().transfer(engine.operationWallet(), operationShare);\r\n        operationShare = 0;\r\n    }\r\n\r\n    function veCRVlock() external {\r\n        require(lockCrv, \"!lock\");\r\n        updateFee();\r\n        _buyCRV();\r\n        _lockCRV();\r\n        veCRVShare = 0;\r\n    }\r\n\r\n    function _buyCRV() internal {\r\n        IUSDM usdm = engine.usdm();\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(usdm);\r\n        path[1] = address(crv);\r\n        usdm.approve(address(uniswapRouter), veCRVShare);\r\n        uniswapRouter.swapExactTokensForTokens(\r\n            veCRVShare,\r\n            1,\r\n            path,\r\n            address(this),\r\n            type(uint256).max\r\n        );\r\n    }\r\n\r\n    function _lockCRV() internal {\r\n        crv.approve(address(veCrv), crv.balanceOf(address(this)));\r\n        veCrv.increase_amount(crv.balanceOf(address(this)));\r\n        veCrv.increase_unlock_time(block.timestamp + 90 days);\r\n    }\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-10-mochi#h-09-treasury-is-vulnerable-to-sandwich-attack",
                "Location": "veCRVlock fuction",
                "Type": "Price oracle manipulation",
                "Description": "Sandwich attack.There\u2019s a permissionless function veCRVlock in MochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds.",
                "Repair": "Recommend to add onlyOwner modifier."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport \"../interfaces/IFeePool.sol\";\r\nimport \"../interfaces/IUSDM.sol\";\r\nimport \"../interfaces/IMochiEngine.sol\";\r\n\r\ncontract FeePoolV0 is IFeePool {\r\n    IMochiEngine public immutable engine;\r\n\r\n    IUniswapV2Router02 public immutable uniswapRouter;\r\n\r\n    address public crvVoterRewardPool;\r\n\r\n    uint256 public treasuryRatio;\r\n\r\n    uint256 public vMochiRatio;\r\n\r\n    uint256 public mochiShare;\r\n\r\n    uint256 public treasuryShare;\r\n\r\n    constructor(address _engine, address _uniswap) {\r\n        engine = IMochiEngine(_engine);\r\n        uniswapRouter = IUniswapV2Router02(_uniswap);\r\n        treasuryRatio = 20e16;\r\n        vMochiRatio = 80e16;\r\n    }\r\n\r\n    function updateReserve() external override {\r\n        uint256 newReserve = engine.usdm().balanceOf(address(this)) -\r\n            mochiShare -\r\n            treasuryShare;\r\n        treasuryShare += (newReserve * treasuryRatio) / 1e18;\r\n        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;\r\n    }\r\n\r\n    function changecrvVoterRewardPool(address _pool) external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        crvVoterRewardPool = _pool;\r\n    }\r\n\r\n    function changeTreasuryRatio(uint256 _ratio) external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        treasuryRatio = _ratio;\r\n    }\r\n\r\n    function changevMochiRatio(uint256 _ratio) external {\r\n        require(msg.sender == engine.governance(), \"!gov\");\r\n        vMochiRatio = _ratio;\r\n    }\r\n\r\n    // this will open up arb oppertunity for Mochi\r\n    // so we will not reward the caller, caller can benefit from flashbot\r\n    // should decide which market we should use UniV2?V3? BalancerV2?\r\n    function distributeMochi() external {\r\n        // buy Mochi with mochiShare\r\n        _buyMochi();\r\n        _shareMochi();\r\n    }\r\n\r\n    function _buyMochi() internal {\r\n        IUSDM usdm = engine.usdm();\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(usdm);\r\n        path[1] = address(engine.mochi());\r\n        usdm.approve(address(uniswapRouter), mochiShare);\r\n        uniswapRouter.swapExactTokensForTokens(\r\n            mochiShare,\r\n            1,\r\n            path,\r\n            address(this),\r\n            type(uint256).max\r\n        );\r\n    }\r\n\r\n    function _shareMochi() internal {\r\n        IMochi mochi = engine.mochi();\r\n        uint256 mochiBalance = mochi.balanceOf(address(this));\r\n        // send Mochi to vMochi Vault\r\n        mochi.transfer(\r\n            address(engine.vMochi()),\r\n            (mochiBalance * vMochiRatio) / 1e18\r\n        );\r\n        // send Mochi to veCRV Holders\r\n        mochi.transfer(\r\n            crvVoterRewardPool,\r\n            (mochiBalance * (1e18 - vMochiRatio)) / 1e18\r\n        );\r\n        // flush mochiShare\r\n        mochiShare = 0;\r\n        treasuryShare = 0;\r\n    }\r\n\r\n    function sendToTreasury() external {\r\n        engine.usdm().transfer(engine.treasury(), treasuryShare);\r\n        treasuryShare = 0;\r\n    }\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-10-mochi#h-12-feepool-is-vulnerable-to-sandwich-attack",
                "Location": "distributeMochi function",
                "Type": "Price oracle manipulation",
                "Description": "Sandwich attack.There\u2019s a permissionless function distributeMochi in FeePoolV0.sol L55-L62. Since everyone can trigger this function, an attacker can launch a sandwich attack with flashloan to steal the funds. The devs have mentioned this concern in the comment. An attacker can steal the funds with a flash loan attack.",
                "Repair": "If the dev wants to make this a permissionless control, the contract should calculate a min return based on TWAP and check the slippage."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./curve/ICurve.sol\";\r\nimport \"./BaseStrategy.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * Strategy that handles non-UST tokens, by first converting them to UST via\r\n * Curve (https://curve.fi/), and only then depositing into EthAnchor\r\n */\r\ncontract NonUSTStrategy is BaseStrategy {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // address of the Curve pool to use\r\n    ICurve public curvePool;\r\n\r\n    // index of the underlying token in the pool\r\n    int128 public underlyingI;\r\n\r\n    // index of the UST token in the pool\r\n    int128 public ustI;\r\n\r\n    constructor(\r\n        address _vault,\r\n        address _treasury,\r\n        address _ethAnchorRouter,\r\n        address _exchangeRateFeeder,\r\n        IERC20 _ustToken,\r\n        IERC20 _aUstToken,\r\n        uint16 _perfFeePct,\r\n        address _owner,\r\n        address _curvePool,\r\n        int128 _underlyingI,\r\n        int128 _ustI\r\n    )\r\n        BaseStrategy(\r\n            _vault,\r\n            _treasury,\r\n            _ethAnchorRouter,\r\n            _exchangeRateFeeder,\r\n            _ustToken,\r\n            _aUstToken,\r\n            _perfFeePct,\r\n            _owner\r\n        )\r\n    {\r\n        require(underlying != _ustToken, \"invalid underlying\");\r\n        require(_curvePool != address(0), \"0x addr\");\r\n        curvePool = ICurve(_curvePool);\r\n        underlyingI = _underlyingI;\r\n        ustI = _ustI;\r\n\r\n        ustToken.safeApprove(_curvePool, type(uint256).max);\r\n        underlying.safeApprove(_curvePool, type(uint256).max);\r\n    }\r\n\r\n    /**\r\n     * Swaps the underlying currency for UST, and initiates a deposit of all\r\n     * the converted UST into EthAnchor\r\n     *\r\n     * @notice since EthAnchor uses an asynchronous model, this function\r\n     * only starts the deposit process, but does not finish it.\r\n     */\r\n    function doHardWork() external override(BaseStrategy) restricted {\r\n        _swapUnderlyingToUst();\r\n        _initDepositStable();\r\n    }\r\n\r\n    /**\r\n     * Calls Curve to convert the existing underlying balance into UST\r\n     */\r\n    function _swapUnderlyingToUst() internal {\r\n        uint256 underlyingBalance = _getUnderlyingBalance();\r\n        if (underlyingBalance > 0) {\r\n            // slither-disable-next-line unused-return\r\n            curvePool.exchange_underlying(\r\n                underlyingI,\r\n                ustI,\r\n                underlyingBalance,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calls Curve to convert the existing UST back into the underlying token\r\n     */\r\n    function _swapUstToUnderlying() internal {\r\n        uint256 ustBalance = _getUstBalance();\r\n        if (ustBalance > 0) {\r\n            // slither-disable-next-line unused-return\r\n            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\r\n     * Once UST is retrieved, convert it back to underlying via Curve\r\n     *\r\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\r\n     * the EthAnchor bridge has finished processing the deposit.\r\n     *\r\n     * @param idx Id of the pending redeem operation\r\n     */\r\n    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {\r\n        super.finishRedeemStable(idx);\r\n        _swapUstToUnderlying();\r\n    }\r\n\r\n    /**\r\n     * Amount, expressed in the underlying currency, currently in the strategy\r\n     *\r\n     * @notice both held and invested amounts are included here, using the\r\n     * latest known exchange rates to the underlying currency\r\n     *\r\n     * @return The total amount of underlying\r\n     */\r\n    function investedAssets()\r\n        external\r\n        view\r\n        override(BaseStrategy)\r\n        returns (uint256)\r\n    {\r\n        uint256 underlyingBalance = _getUnderlyingBalance();\r\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\r\n\r\n        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\r\n            address(aUstToken),\r\n            true\r\n        ) * aUstBalance) / 1e18) + pendingDeposits;\r\n        return\r\n            underlyingBalance +\r\n            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\r\n    }\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-01-sandclock#h-03-vaults-with-non-ust-underlying-asset-vulnerable-to-flash-loan-attack-on-curve-pool",
                "Location": "curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.In short, the NonUSTStrategy is vulnerable to attacks by flash loans on curve pools. Here\u2019s an outline of the attack: Assume there is a vault with DAI underlying and a NonUSTStrategy with a DAI / UST curve pool Take out a flash loan of DAI Exchange a ton of DAI for UST The exchange rate from DAI to UST has gone up (!!) Withdraw or deposit from vault with more favorable terms than market Transfer back UST to DAI Repay flash loan",
                "Repair": "Use an oracle"
            }
        ]
    },
    {
        "Code": "function burn(uint256 id, address to)\r\n        external\r\n        override\r\n        onlyRouter\r\n        returns (\r\n            uint256 amountNative,\r\n            uint256 amountForeign,\r\n            uint256 coveredLoss\r\n        )\r\n    {\r\n        (amountNative, amountForeign) = _burn(id, to);\r\n\r\n        Position storage position = positions[id];\r\n\r\n        uint256 creation = position.creation;\r\n        uint256 originalNative = position.originalNative;\r\n        uint256 originalForeign = position.originalForeign;\r\n\r\n        delete positions[id];\r\n\r\n        uint256 loss = VaderMath.calculateLoss(\r\n            originalNative,\r\n            originalForeign,\r\n            amountNative,\r\n            amountForeign\r\n        );\r\n\r\n        // TODO: Original Implementation Applied 100 Days\r\n        coveredLoss =\r\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\r\n            _ONE_YEAR;\r\n    }\r\n\r\n    function calculateLoss(\r\n        uint256 originalVader,\r\n        uint256 originalAsset,\r\n        uint256 releasedVader,\r\n        uint256 releasedAsset\r\n    ) internal pure returns (uint256 loss) {\r\n        //\r\n        // TODO: Vader Formula Differs https://github.com/vetherasset/vaderprotocol-contracts/blob/main/contracts/Utils.sol#L347-L356\r\n        //\r\n\r\n        // [(A0 * P1) + V0]\r\n        uint256 originalValue = ((originalAsset * releasedVader) /\r\n            releasedAsset) + originalVader;\r\n\r\n        // [(A1 * P1) + V1]\r\n        uint256 releasedValue = ((releasedAsset * releasedVader) /\r\n            releasedAsset) + releasedVader;\r\n\r\n        // [(A0 * P1) + V0] - [(A1 * P1) + V1]\r\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;\r\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-12-vader#h-06-lps-of-vaderpoolv2-can-manipulate-pool-reserves-to-extract-funds-from-the-reserve",
                "Location": "uint256 originalValue = ((originalAsset * releasedVader) /\r\n            releasedAsset) + originalVader;\r\n\r\n        // [(A1 * P1) + V1]\r\n        uint256 releasedValue = ((releasedAsset * releasedVader) /\r\n            releasedAsset) + releasedVader;\r\n\r\n        // [(A0 * P1) + V0] - [(A1 * P1) + V1]\r\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.In VaderPoolV2.burn we calculate the current losses that the LP has made to impermanent loss.These losses are then refunded to the LP in VADER tokens from the reserve.This loss is calculated by the current reserves of the pool so if an LP can manipulate the pool\u2019s reserves they can artificially engineer a huge amount of IL in order to qualify for a payout up to the size of their LP position.",
                "Repair": "Use a manipulation resistant oracle for the relative prices of the pool\u2019s assets (TWAP, etc.)"
            }
        ]
    },
    {
        "Code": "///@notice handles staking logic for EYE and EYE based assets so that correct rate of fate is earned.\r\n  ///@param finalAssetBalance after staking, what is the final user balance on LimboDAO of the asset in question\r\n  ///@param finalEYEBalance if EYE is being staked, this value is the same as finalAssetBalance but for LPs it's about half\r\n  ///@param rootEYE offload high gas arithmetic to the client. Cheap to verify. Square root in fixed point requires Babylonian algorithm\r\n  ///@param asset the asset being staked\r\n  function setEYEBasedAssetStake(\r\n    uint256 finalAssetBalance,\r\n    uint256 finalEYEBalance,\r\n    uint256 rootEYE,\r\n    address asset\r\n  ) public isLive incrementFate {\r\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\r\n    address sender = _msgSender();\r\n    FateGrowthStrategy strategy = fateGrowthStrategy[asset];\r\n\r\n    //verifying that rootEYE value is accurate within precision.\r\n    uint256 rootEYESquared = rootEYE * rootEYE;\r\n    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);\r\n    require(\r\n      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,\r\n      \"LimboDAO: Stake EYE invariant.\"\r\n    );\r\n    AssetClout storage clout = stakedUserAssetWeight[sender][asset];\r\n    fateState[sender].fatePerDay -= clout.fateWeight;\r\n    uint256 initialBalance = clout.balance;\r\n    //EYE\r\n    if (strategy == FateGrowthStrategy.directRoot) {\r\n      require(finalAssetBalance == finalEYEBalance, \"LimboDAO: staking eye invariant.\");\r\n      require(asset == domainConfig.eye);\r\n\r\n      clout.fateWeight = rootEYE;\r\n      clout.balance = finalAssetBalance;\r\n      fateState[sender].fatePerDay += rootEYE;\r\n    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {\r\n      //LP\r\n      clout.fateWeight = 2 * rootEYE;\r\n      fateState[sender].fatePerDay += clout.fateWeight;\r\n\r\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\r\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\r\n      uint256 totalSupply = IERC20(asset).totalSupply();\r\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\r\n      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);\r\n      finalEYEBalance /= precision;\r\n      require(\r\n        finalEYEBalance == impliedEye, //precision cap\r\n        \"LimboDAO: stake invariant check 2.\"\r\n      );\r\n      clout.balance = finalAssetBalance;\r\n    } else {\r\n      revert(\"LimboDAO: asset growth strategy not accounted for\");\r\n    }\r\n    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);\r\n    asset.ERC20NetTransfer(sender, address(this), netBalance);\r\n  }\r\n \r\n\r\n/**\r\n   *@notice Acquiring enough fate to either influence a decision or to lodge a proposal can take very long.\r\n   * If a very important decision has to be acted on via a proposal, the option exists to buy large quantities for fate instantly by burning an EYE based asset\r\n   * This may be necessary if a vote is nearly complete by the looming outcome is considered unacceptable.\r\n   * While Fate accumulation is quadratic for staking, burning is linear and subject to a factor of 10. This gives whales effective veto power but at the cost of a permanent\r\n   * loss of EYE.\r\n   *@param asset the asset to burn and can be EYE or EYE based assets\r\n   *@param amount the amount of asset to burn\r\n   */\r\n  function burnAsset(address asset, uint256 amount) public isLive incrementFate {\r\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\r\n    address sender = _msgSender();\r\n    require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\");\r\n    uint256 fateCreated = fateState[_msgSender()].fateBalance;\r\n    if (asset == domainConfig.eye) {\r\n      fateCreated = amount * 10;\r\n      ERC677(domainConfig.eye).burn(amount);\r\n    } else {\r\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\r\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\r\n      uint256 totalSupply = IERC20(asset).totalSupply();\r\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\r\n      uint256 impliedEye = (eyePerUnit * amount) / ONE;\r\n      fateCreated = impliedEye * 20;\r\n    }\r\n    fateState[_msgSender()].fateBalance += fateCreated;\r\n    emit assetBurnt(_msgSender(), asset, fateCreated);\r\n  }",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-01-behodler#h-07-lp-pricing-formula-is-vulnerable-to-flashloan-manipulation",
                "Location": "uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The LP pricing formula used in the burnAsset function of LimboDAO is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more fate than he is supposed to with a relatively low cost. With the large portion of fate he gets, he has more voting power to influence the system\u2019s decisions, or even he can convert his fate to Flan tokens for a direct profit.",
                "Repair": "Use a fair pricing formula for the LP tokens, for example, the one proposed by Alpha Finance."
            }
        ]
    },
    {
        "Code": "function buy(uint256 _id) external payable isValidPair(_id){\r\n    requlre(pairs[_id].owner 1-msg.sender,\"ouner can not buy\"); \r\n    Pair memory pair -pairs[_id];\r\n    uint256 totalAmount-pair.price; i\r\n    if(pair.currency --address(exe)){\r\n\t\trequire(msg.value>-totalAmount,\"insufficient eth amount\"): \r\n\t\t// refund extra eth\r\n\t\tpayable(msg.sender).transfer(msg.value.sub(totalAmount)); \r\n\t\t// transfer service fee\r\n\t\tpayable(feewallet).transfer(totalAmount,mul(serviceFee).div(PERCENT_DIVIDER));\r\n\t\t// transfer creator fee\r\n\t\tpayable(palr.creator).transfer(totalAmount,mul(pair,creatorFee).dlv(PERCENT_DIVIDER)); \r\n\t\t// transfer remain amount to owner\r\n\t\tuint256 ownerPercent-PERCENT_DIVIDER.sub(serviceFee).sub(pair,creatorFee); \r\n\t\tpayable(pair.owner).transfer(totalAnount.mul(ownerPercent).div(PERCENT_DIVIDER));\r\n\t}else {\r\n        IERC20 currency - IERC20(pair,currency):\r\n        uint256 tokenBalane= currency.balanceof(msg.sender);\r\n        require(tokenBalane>-totalAmount, \"insufficient token balance\"); \r\n        // transfer service fee\r\n        require(currency.transferFrom(msg,sender,feewallet,totalAmount.nul(serviceFee).div(PERCENT_DIVIDER)),\"failed to transfer Admin fee\"); \r\n        // transfer creator fee\r\n        require(currency.transferFrom(msg,sender,pair,creator,totalAmount.nul(pair,creatorFee).div(PERCENT_DIVIDER)),\"failed to transfer creator fee\");\r\n        // transfer remain amount to owner\r\n        uint256 ownerPercent-PERCENT_DIVIDER.sub(serviceFee).sub(pair,creatorFee);\r\n        require(currency.transferFrom(msg.sender,pair.owner,totalAmount,mul(ownerPercent).div(PERCENT_DIVIDER)),\"failed to transfer to owner\"); \r\n    }\r\n    // transfer NFT token to buyer\r\n    IERC721(pairs[_id].collection),safeTransferFrom(address(this),msg.sender,pair.tokenId);\r\n    pairs[_id].bvalid- false;\r\n    emit Suapped(msg.sender,pair); \r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "Beosin/BOG_202204071430.pdf/[BOG-2]Transaction-Ordering Attacks",
                "Location": "buy function",
                "Type": "Price oracle manipulation",
                "Description": "Sandwich attack.The buy function in the BattleOfGuardiansMarket contract has a transaction-ordering dependency attack. During the transaction process, if the buyer decides to buy the NFT and initiates a transaction, the seller can preempt the transaction and change the currency address or price before the buyer's transaction is confirmed. This can lead to unexpected transactions.",
                "Repair": "It is recommended to specify currency and price by user input in the buy function. "
            }
        ]
    },
    {
        "Code": "function VSpecia12(uint256 amount) public returns (uint256 result){\r\n\tPRBMath.UD60x18 memory_a-PRBMathUD60x18.fromUint(a());\r\n    _a=PRBMathUD060x18.mul(_a,PRBMathUD60x18.fromUint(scaleFactor)); \r\n    PRBMath.UD60x18 memory _amount=PRBMathUD60x18.fromUint(amount); \r\n    PRBMath.UD60x18 memory _S1= PRBMathUD60x18.fromUint(starSupply);\r\n    PRBMath.UD60x18 memory_S0 =PRBMathUD60x18.sub(_amount,PRBMathUD60x18.fromUint(supplySold)); \r\n    _S0=PRBMathUD60x18.sub(_S1,_S0);\r\n    curve350 = PRBMathUD60x18.toUint(_S0);\r\n    _S0 = PRBMathUD60x18.mul(_SO,PRBMathUD60x18.fromUint(scaleFactor)); \r\n    _S1=PRBMathUD60x18.mul(_S1, PRBMathUD60x18.fromUint(scaleFactor)); \r\n    PRBMath.UD60x18 memory InNumerator =PRBMathU060x18.e();\r\n    PRBMath.UD60x18 memory powerNum-PRBMathUD60x18.mul(PRBMathUD60x18.fromUint(33),_S1); \r\n    powerNum = PRBMathUD60x18.div(powerNum,PRBMathUD60x18.fromUint(10));\r\n    powerNum=PRBMathUD60x18.div(powerNum,_a); \r\n    if (PRBMathUD60x18\uff0etoUint\uff08powerNum\uff09>14\uff09\uff5b}else{}\r\n}\r\n",
        "VulnerabilityDesc": [
            {
                "Name": "/Beosin/promfans_202109061825.pdf/The system variable curve3S0 can be modified by anyone",
                "Location": "curve350 = PRBMathUD60x18.toUint(_S0);",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The visibility of the SSpecial and VSpecial2 functions in the contract is \"public\", which means \r\nthat they can be called by any user. But the function will internally modify curve3S0 according to the \r\nincoming value, which may cause the price of the contract's token transaction to be manipulated",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function harvest() public override whenNotPaused {\r\n    if (balanceOfPool() > 0) {\r\n    \\/\\/ claim diff\r\n    miniChef.harvest(pid, address(this));\r\n \r\n    uint256 diffBal = diff.balanceOf(address(this));\r\n    if (diffBal > 0) {\r\n    \\/\\/ charge fees\r\n    uint256 harvestFee = diffBal.mul(harvestFeeRate).div(\r\n    FEE_PRECISION\r\n    );\r\n   diff.safeTransfer(feeRecipient, harvestFee);\r\n\r\n   \\/\\/ swap diff\r\n    uint256 diffBalHalf = diffBal.sub(harvestFee).div(2);\r\n    if (lpToken0 != diff) {\r\n    uniRouter.swapExactTokensForTokens(\r\n    diffBalHalf,\r\n    0,\r\n    diffToLpToken0,\r\n    address(this),\r\n    now\r\n    );\r\n \r\n    }\r\n    if (lpToken1 != diff) {\r\n    uniRouter.swapExactTokensForTokens(\r\n    diffBalHalf,\r\n    0,\r\n    diffToLpToken1,\r\n    address(this),\r\n    now\r\n    );\r\n    }\r\n \r\n    \\/\\/ Adds liquidity and gets more want tokens.\r\n    uniRouter.addLiquidity(\r\n    address(lpToken0),\r\n    address(lpToken1),\r\n    lpToken0.balanceOf(address(this)),\r\n    lpToken1.balanceOf(address(this)),\r\n    1,\r\n    1,\r\n    address(this),\r\n    now\r\n    );\r\n\r\n   \\/\\/ reinvest\r\n   deposit();\r\n\r\n   emit Harvested(diffBal, harvestFee);\r\n   }\r\n  }\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/blocksec/1660885789323-2.pdf/Possible price manipulation attack",
                "Location": "if (lpToken0 != diff) ; if (lpToken1 != diff)",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The function harvest of StratDiffusion swaps the DIFF token for the underlying tokens\n(line 155 and 164). It\u2019s susceptible to the price manipulation attack.Specifically, the DIFF token will be transferred into the strategy contract, and then swapped to the\nunderlying tokens in the DEX pools. However, the price of the DIFF could be manipulated in the DEX pool\nso that it\u2019s price is very low and the underlying token exchanged will be less than expected. Besides, there\nis no slippage protection when swapping the DIFF for the underlying token.",
                "Repair": "Ensure that only the EOA account can invoke the deposit function in the vault contract and\nthe harvest function in the strategy. A slippage protection could be leveraged in the function. Besides, the\nproject can monitor the accumulated DIFF token in the Chef contract and invoke the harvest function when\nthe accumulated DIFF token exceeds a threshold."
            }
        ]
    },
    {
        "Code": "function tradeCollaterals() public {\r\n    \\/\\/ for all lp tokens in the collateral array\r\n    uint256 len = allCollaterals.length;\r\n    for (uint256 i = 0; i < len; ++i) {\r\n        tradeCollateral(allCollaterals[i]);\r\n    }\r\n}\r\n   \r\nfunction getPathToStnd(address input) private view returns (address[] memory) {\r\n    address[] memory path = new address[](3);\r\n    path[0] = input;\r\n    path[1] = stablecoin;\r\n    path[2] = stnd;\r\n   \r\n    return path;\r\n}\r\n   \r\nfunction tradeCollateral (\r\n    address collateral\r\n    ) internal {\r\n    IUniswapV2Router01(router).swapExactTokensForTokens(\r\n    IERC20(collateral).balanceOf(address(this)),\r\n    0,\r\n    getPathToStnd(collateral),\r\n    dstnd,\r\n    block.timestamp + 20000000\r\n    );\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/blocksec/1660886228484-2.pdf/Price manipulation attacks against FeeRoll contract",
                "Location": "tradeCollaterals function",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The function tradeCollaterals in the following code snippets is used to trade fees distributed from vaults for\r\nSTND tokens, which can support the value of STND in DeFi market.\r\nThere are two price manipulation methods that can cause the FeeRoll contract to lose collaterals.\r\nFor example, the collateral token to be sold is WETH. The function tradeCollateralls will sell WETH for\r\nMTR and then for STND. The attack consists of three steps. The first step, an attacker borrows a huge amount\r\nof WETH via flashloan to swap for the MTR, then the WETH\u2019s price in the pool is manipulated to be very low.\r\nSecond, the attacker invokes tradeCollaterals of the FeeRoll contract that cheaply sells WETH reserves\r\nfor little MTR and then for little STND. Third, the attacker swaps his MTR for WETH back, which can profit from\r\nthe trade that FeeRoll contract makes",
                "Repair": "Add a check require(msg.sender == tx.origin) in the function tradeCollateralls to ensure the caller\r\nis EOA.\r\nAdd a check to make sure the existence of the swap pool between input and stablecoin in the function\r\ngetPathToStnd\r\nLeverage the price oracle to implement a slippage check for swapExactTokensForTokens rather than filling\r\n0 (in line 843)"
            }
        ]
    },
    {
        "Code": "@internal\r\ndef _checkpoint(addr: address):\r\n    \"\"\"\r\n    @notice Checkpoint for a user\r\n    @param addr User address\r\n    \"\"\"\r\n    _point_period: int128 = self.point_period\r\n    _point_period_timestamp: uint256 = self.point_period_timestamp[_point_period]\r\n    _point_integrate_inv_supply: uint256 = self.point_integrate_inv_supply[_point_period]\r\n   \r\n    rate: uint256 = self.point_rate\r\n    prev_epoch: uint256 = self.point_current_epoch_time\r\n    new_rate: uint256 = rate\r\n    next_epoch: uint256 = prev_epoch + WEEK\r\n\r\n    if block.timestamp > next_epoch:\r\n        new_totalSupply: uint256 = ERC20(self.lp_token).totalSupply()\r\n        if new_totalSupply > 0:\r\n            new_rate = self.point_proportion * new_totalSupply \\/ WEEK\r\n        self.point_current_epoch_time = next_epoch\r\n        self.point_rate = new_rate\r\n   \r\n    # Update integral of 1\\/supply\r\n    if block.timestamp > _point_period_timestamp and not self.is_killed:\r\n        prev_week_time: uint256 = _point_period_timestamp\r\n        week_time: uint256 = min((_point_period_timestamp + WEEK) \\/ WEEK * WEEK, block.timestamp)\r\n        _totalSupply: uint256 = self.lpTotalSupply\r\n   \r\n        for i in range(500):\r\n            dt: uint256 = week_time - prev_week_time\r\n            if _totalSupply > 0:\r\n                if next_epoch >= prev_week_time and next_epoch < week_time:\r\n                    # If we went across epoch, apply the rate\r\n                    # of the first epoch until it ends, and then the rate of\r\n                    # the last epoch.\r\n                    _point_integrate_inv_supply += rate * (next_epoch - prev_week_time) \\/ _totalSupply\r\n                    rate = new_rate\r\n                    _point_integrate_inv_supply += rate * (week_time - next_epoch) \\/ _totalSupply\r\n\r\n\r\n@external\r\ndef user_checkpoint(addr: address) -> bool:\r\n    \"\"\"\r\n    @notice Record a checkpoint for \u2018addr\u2018\r\n    @param addr User address\r\n    @return bool success\r\n    \"\"\"\r\n    assert (msg.sender == addr) or (msg.sender == self.minter) # dev: unauthorized\r\n    self._checkpoint(addr)\r\n    self._checkpoint_dao(addr)\r\n    self._checkpoint_rewards(addr, False, ZERO_ADDRESS)\r\n    self._update_liquidity_limit(addr, self._balance_of(addr), self.totalSupply)\r\n    return True",
        "VulnerabilityDesc": [
            {
                "Name": "/blocksec_filda_dao_v1.0_signed.pdf/Potential price manipulation on the reward allocation speed",
                "Location": "_checkpoint function",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.There exists a price manipulation problem in the _checkpoint function of the LiquidityGaugeV3 contract. The project provides incentives to the holders of fTokens (a series of Compound-CToken-like to\u0002kens) by adopting a mechanism similar to the Curve DAO project. Every time the function is invoked, a\r\ncheckpoint is recorded for allocating the rewards. Specifically, every balance change of fTokens would trigger a hook calling to the corresponding\r\nLiquidityGaugeV3 contract and accumulate the reward in FILDA tokens. This hook updates the reward\r\nallocation points (points for short) based on the following two-step calculation:\r\n1. The reward allocation speed for a certain time t is calculated as r(t) = p \u2217 s(t)\\/W EEK, where p is a system parameter, s(t) is the total supply of fToken recorded in the first checkpoint of a week, W EEK is the total seconds in a week (604800).\r\n2. The points of a certain user is calculated as Iu =R r(t)bu(t)s(t), where bu(t) is the balance of the user at time t, and s(t) is the current total supply of fToken.\r\n",
                "Repair": "Check the rate updating mechanism"
            }
        ]
    },
    {
        "Code": "function getTokenPrice ( address token_address , address token1_address )\r\n    external\r\n    view\r\n    override\r\n    returns ( uint256 price )\r\n{\r\n    uint256 token_decimals = IERC20Metadata ( token_address ). decimals () ;\r\n\r\n    uint256 min_amountIn = 1 * 10** token_decimals ;\r\n    if ( token_address == token1_address ) {\r\n        price = min_amountIn ;\r\n    } else {\r\n        ( uint256 reserve0 , uint256 reserve1 ) = getReserves (\r\n            token_address ,\r\n            token1_address\r\n         );\r\n         price = uniswapV2Router . getAmountOut (\r\n             min_amountIn ,\r\n             reserve0 ,\r\n             reserve1\r\n         );\r\n    }\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "PeckShield/PeckShield-Audit-Report-Velvet-v1.0.pdf/3.3 Flashloan-Based Oracle Price Manipulation\n",
                "Location": "price = uniswapV2Router . getAmountOut (\r\n             min_amountIn ,\r\n             reserve0 ,\r\n             reserve1\r\n         );",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The Velvet Capital protocol has a PriceOracle contract to facilitate the token price discovery. Our\nanalysis shows the current approach to compute the on-chain token price can be manipulated\u3002To elaborate, we show above the related getTokenPrice() function. It comes to our attention that\nthe conversion is routed to UniswapV2-based DEXs and the related spot reserves are used to compute\nthe price! Therefore, they are vulnerable to possible front-running attacks, resulting in possible loss\nfor the token conversion.\n",
                "Repair": "Develop an effective mitigation (e.g., slippage control) to the above front-running attack to better protect the interests of protocol users"
            }
        ]
    },
    {
        "Code": "function _kalmPrice () internal view returns ( uint256 ) {\r\n    IPancakeswapV2Pair pair = IPancakeswapV2Pair (lp) ;\r\n    address other = pair . token0 () == kalm ? pair . token1 () : pair . token0 () ;\r\n    ( uint256 Res0 , uint256 Res1 , ) = pair . getReserves () ;\r\n    ( uint256 kalmReserve , uint256 otherReserve ) = pair . token0 () == kalm ? (Res0 ,\r\n        ) : (Res1 , Res0 );\r\n    uint256 decimalsOther = IERC20Detailed ( other ) . decimals () ;\r\n    \\/\\/ amount\r\n    uint256 otherPERkalm = (1 e18* otherReserve )\\/ kalmReserve ;\r\n\r\n    uint256 kalmPrice = ( otherPERkalm * _usdTokenPrice () ) \\/(10** decimalsOther );\r\n    return kalmPrice ;\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-Kalmar-Bond-v1.0.pdf/3.1 Possible Price manipulation For _kalmPrice()/_getLpPrice()",
                "Location": "uint256 kalmPrice = ( otherPERkalm * _usdTokenPrice () ) /(10** decimalsOther );",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The KalmarBondingStrategy contract defines two functions (i.e., _kalmPrice() and _getLpPrice()) to\r\nobtain the prices of kalm Token and lp Token. During the analysis of these two functions, we notice\r\nthe prices of kalm Token\\/lp Token are possible to be manipulated. In the following, we use the\r\n_kalmPrice() routine as an example.\r\nTo elaborate, we show below the related code snippet of the KalmarBondingStrategy contract.\r\nSpecifically, if we examine the implementation of the _kalmPrice(), the final price of the kalm Token\r\nis derived from (otherPERkalm*_usdTokenPrice())\\/(10**decimalsOther) (line 236), where the value of\r\notherPERkalm is calculated by (1e18*otherReserve)\\/kalmReserve. Although the price of BUSD is obtained\r\nfrom the chainlink and cannot be manipulated, kalmReserve or otherReserve is the token amount in\r\nthe pool thus can be manipulated by flash loans, which causes the final values of the kalm Token not\r\ntrustworthy.",
                "Repair": "Revise current execution logic of _kalmPrice()/_getLpPrice() to defensively\ndetect any manipulation attempts in the kalm Token/lp Token prices."
            }
        ]
    },
    {
        "Code": "function prePurchase ( uint256 _expectedPrice , uint256 _startTime , uint256\r\n_expiredTime ) public payable {\r\n    require ( _expiredTime > _startTime , \" Incorrect time period !\" );\r\n    uint256 accountQuota = getAccountPurchaseQuota ( msg . sender );\r\n    require ( accountQuota > 0 , \" Exceed account quota !\" );\r\n    uint256 currAmount = 0;\r\n    PrePurchaseInfo [] storage purchases = prePurchaseList [ msg. sender ];\r\n    PrePurchaseInfo memory pcInfo ;\r\n    uint256 ethPrice = 0;\r\n    uint256 usdtPrice = 0;\r\n    ( ethPrice , usdtPrice ) = getANBPrice () ;\r\n    if( msg . value > 0) {\r\n        require ( ethPrice > 0, \" Invalid ethPrice !\");\r\n        uint256 highestEthPrice = ethPrice * maxPriceMultiple * (100 + expectedPriceFloatVal ) / 100;\r\n        require ( _expectedPrice <= highestEthPrice , \" expectedPrice too high !\" ) ;\r\n        currAmount = msg . value * 10 ** angryTokenDecimals / ethPrice ;\r\n        pcInfo . price = ethPrice ;\r\n        pcInfo . paymentAmount = msg . value ;\r\n        pcInfo . paymentType = 1;\r\n    } else {\r\n        require ( usdtPrice > 0 , \" Invalid usdtPrice !\") ;\r\n        uint256 highestUSDTPrice = usdtPrice * maxPriceMultiple * (100 + expectedPriceFloatVal ) / 100;\r\n        require ( _expectedPrice <= highestUSDTPrice , \" expectedPrice too high !\" );\r\n        uint256 allowance = usdtToken . allowance ( msg . sender , address ( this ) );\r\n        require ( allowance > 0, \"Not any payments !\" );\r\n        currAmount = allowance * 10 ** angryTokenDecimals / usdtPrice ;\r\n        pcInfo . price = usdtPrice ;\r\n        usdtToken . safeTransferFrom (\r\n            msg . sender ,\r\n            address ( this ) ,\r\n            allowance\r\n        );\r\n        pcInfo . paymentAmount = allowance ;\r\n        pcInfo . paymentType = 2;\r\n    }\r\n    uint256 totalQuota = queryCurrPrePurchaseQuota () ;\r\n    require ( ( currAmount + totalPrePurcaseAmount ) <= totalQuota , \" Exceed daily quota!\" );\r\n    require ( currAmount <= accountQuota , \" Exceed account quota !\" );\r\n    if( purchases . length == 0) {\r\n        prePurchaseAccounts . push ( msg . sender );\r\n    }\r\n    pcInfo . amount = currAmount ;\r\n    pcInfo . expectedPrice = _expectedPrice ;\r\n    pcInfo . startTime = _startTime ;\r\n    pcInfo . expiredTime = _expiredTime ;\r\n    pcInfo . status = 0;\r\n    purchases . push ( pcInfo );\r\n    totalPrePurcaseAmount = totalPrePurcaseAmount + currAmount ;\r\n    emit PrePurchase ( msg . sender , purchases . length -1 , currAmount , pcInfo .\r\n        paymentAmount , pcInfo .price , _expectedPrice , _startTime , _expiredTime ,\r\n        pcInfo . paymentType , pcInfo . status ) ;\r\n}\r\n\r\n\r\nfunction getANBPrice () public view returns ( uint256 _ethPrice , uint256 _usdtPrice ){\r\n    address [] memory path = new address [](3) ;\r\n    path [0] = angryTokenAddr ;\r\n    path [1] = uniswapRouterV2 . WETH () ;\r\n    path [2] = usdtTokenAddr ;\r\n    uint256 [] memory amounts = uniswapRouterV2 . getAmountsOut (10 **\r\nangryTokenDecimals , path );\r\n    _ethPrice = amounts [1];\r\n    _usdtPrice = amounts [2];\r\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-AngryToken-v1.0.pdf/4.2 Possible Sandwich/MEV For Reduced Purchase Price",
                "Location": "uint256 [] memory amounts = uniswapRouterV2 . getAmountsOut (10 **\nangryTokenDecimals , path );\n    _ethPrice = amounts [1];\n    _usdtPrice = amounts [2];\n }",
                "Type": "Price oracle manipulation",
                "Description": "Sandwich attack.As mentioned earlier, the AngryToken contract supports pre-sale that allows early adopters to purchase\r\nthe token. While examining the pre-sale support, we notice the purchase price can be arbitrarily\r\nmanipulated.\r\nTo elaborate, we show below the prePurchase() function. As the name indicates, it is designed to\r\nimplement the pre-sale functionality. It comes to our attention that the purchase price is computed\r\non-chain via an internal helper getANBPrice().Specifically, the purchase price is directly returned by querying the trading price of UniswapV2\non the trading path ANB -> WETH -> USDT without imposing any restriction. As a result, the current\npricing approach is vulnerable to possible sandwich attacks, resulting in a manipulated purchase price.",
                "Repair": "Develop an effective mitigation to the above sandwich attack to better\nprotect the interests of purchasing users."
            }
        ]
    },
    {
        "Code": "function _updatePriceWithSignature(\n    uint256 timestamp,uint256 price,uint8 v,bytes32 r,bytes32 s\n    )internal\n{\n    if(block.number!=_lastPriceBlockNumber){\n        require(timestamp>=_lastPriceTimestamp,\"Perpetual Pool:price is not the newest\");\n        require(block.timestamp\u2212timestamp<=_priceDelayAllowance,\"Perpetual Pool: price is older than allowance\");\n        _checkPriceSignature(timestamp,price,v,r,s);\n        _price=price;\n        _lastPriceTimestamp=timestamp;\n        _lastPriceBlockNumber=block.number;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-Deri-v1.0.pdf/3.3 Potential Replay Of Signed Prices",
                "Location": "timestamp",
                "Type": "Price oracle manipulation",
                "Description": "Non-AMM price oracle manipulation.In the current implementation of the Deri protocol, the _price is provided by a trusted oracle. If the\noracle is an on-chain contract, PerpetualPool can get a price by the oracle\u2019s interface. Conversely,\nif the oracle is an EOA account, PerpetualPool should check the price signature first to verify if the\nprice is authorized. We notice that the price signature is signed with a timestamp. However, if the\nsignature is not signed in the currently active chain, e.g., a testnet. It could lead to a replay attack.\nIn particular, we show the related code snippet below.\n",
                "Repair": "Add new fields into signature calculation, i.e., chainID and the address of\nPerpetualPool."
            }
        ]
    },
    {
        "Code": "functiongetPrice()publicoverridereturns(uint256){\n   IUniswapV2Pair p = IUniswapV2Pair(pair);\n   uint256 reserveQ;\n   uint256 reserveB;\n   uint256 timestamp;\n   if(isQuoteToken0){(reserveQ,reserveB,timestamp)=p.getReserves();\n   }else{(reserveB,reserveQ,timestamp)=p.getReserves();}\n   if(timestamp!=timestampLast2){\n      priceCumulativeLast1=priceCumulativeLast2;\n      timestampLast1=timestampLast2;\n      priceCumulativeLast2=isQuoteToken0?p.price0CumulativeLast():p.price1CumulativeLast();\n      timestampLast2=timestamp;\n   }\n   uint256 price;\n   if(timestampLast1!=0){\n   //TWAP\n   price=(priceCumulativeLast2\u2212priceCumulativeLast1)\\ (timestampLast2\u2212 timestampLast1)\u221710\u2217\u2217(18+qDecimals\u2212bDecimals)\\ Q112;\n   }else{\n   //Spot\n   //this price will only be used when BToken is newly added to pool\n   //since the liquidity for newly added BToken is always zero,\n   //there will be no manipulation consequences for this price\n   price=reserveB\u221710\u2217\u2217(18+qDecimals\u2212bDecimals)\\ reserveQ;\n}\n67returnprice;\n68}",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-DeriV2-v1.0.pdf/3.8 Potential Manipulation of BToken Prices",
                "Location": "price=(priceCumulativeLast2\u2212priceCumulativeLast1)\\ (timestampLast2\u2212 timestampLast1)\u221710\u2217\u2217(18+qDecimals\u2212bDecimals)\\ Q112;",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.In the Deri-V2 protocol, each base token has a price oracle that is based on the widely used UniswapV2\ntime-weighted average price (TWAP). The TWAP is constructed by reading the cumulative price from\na UniswapV2 pair at the beginning and at the end of the desired interval. The difference in this\ncumulative price can then be divided by the length of the interval to create a TWAP for that period.\nTo elaborate, we show below the getPrice() implementation. It comes to our attention that\nthe interval used to compute the TWAP is not restricted (line 58). As a result, it leaves the room or\npossibility for undesired price manipulation. To mitigate, it is helpful to ensure a minimum interval\nfor the TWAP-based price calculation.",
                "Repair": "Develop an effective mitigation to avoid the price oracle from being manipulated"
            }
        ]
    },
    {
        "Code": "function getPriceByWBTCDAI() public view returns(uint256){\n address[] memory WbtcToDaiSwapPath;\n WbtcToDaiSwapPath = new address[](2);\n WbtcToDaiSwapPath[0] = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n WbtcToDaiSwapPath[1] = address(0x113587939c8967e61Aa2360613951B23AB2Af49a);\n uint256 amount = 1e8*1e18;\n n return uniswapRouter.getAmountsIn(amount, WbtcToDaiSwapPath)[0];\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/SlowMist/SlowMist Audit Report - Shield_en-us.pdf/4.3.1.1 Risk of Oracle Manipulation",
                "Location": "return uniswapRouter.getAmountsIn(amount, WbtcToDaiSwapPath)[0];",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.the price is obtained from Uniswap's getAmountsIn through the getPriceByWBTCDAI function, but this interface obtains the real-time price of the WBTC/DAI pool, and there is a risk of malicious manipulation",
                "Repair": " It is recommended to use Uniswap's delayed price feed oracle for acquisition."
            }
        ]
    },
    {
        "Code": "function IOUPrice() public view returns (uint256) {\n uint256 IOUSupply = totalSupply();\n return IOUSupply == 0\n ? 1e18\n : (totalFarmingTokenBalance() * 1e18) / IOUSupply;\n }\n function totalFarmingTokenBalance() public view returns (uint256) {\n return farmingToken().balanceOf(address(this)) + strategy.balanceOf();\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/SlowMist/SlowMist Audit Report - Shield_en-us.pdf/[N4] [Medium] Price manipulation issue",
                "Location": "totalFarmingTokenBalance function",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice.",
                "Repair": "It is recommended not to use IOUPrice for other contracts as the calculation of the asset price on-chain."
            }
        ]
    },
    {
        "Code": "function IOUPrice() public view returns (uint256) {\n uint256 IOUSupply = totalSupply();\n return IOUSupply == 0\n ? 1e18\n : (totalFarmingTokenBalance() * 1e18) / IOUSupply;\n }\n function totalFarmingTokenBalance() public view returns (uint256) {\n return farmingToken().balanceOf(address(this)) + strategy.balanceOf();\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/SlowMist/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf/[N4] [Medium] Price manipulation issue",
                "Location": "totalFarmingTokenBalance function",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice.",
                "Repair": "It is recommended not to use IOUPrice for other contracts as the calculation of the asset price on-chain"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.6.12;\n import 'OpenZeppelin/openzeppelin-contracts@3.4.0/contracts/proxy/Initializable.sol';\n \n import '../../interfaces/IKeep3rV1Oracle.sol';\n import '../../interfaces/IUniswapV2Pair.sol';\n \n contract BaseKP3ROracle is Initializable {\n   uint public constant MIN_TWAP_TIME = 15 minutes;\n   uint public constant MAX_TWAP_TIME = 60 minutes;\n \n   IKeep3rV1Oracle public immutable kp3r;\n   address public immutable factory;\n   address public immutable weth;\n \n   constructor(IKeep3rV1Oracle _kp3r) public {\n     kp3r = _kp3r;\n     factory = _kp3r.factory();\n     weth = _kp3r.WETH();\n   }\n \n   function price0TWAP(address pair) public view returns (uint) {\n     uint length = kp3r.observationLength(pair);\n     require(length > 0, 'no length-1 observation');\n     (uint lastTime, uint lastPx0Cumu, ) = kp3r.observations(pair, length - 1);\n     if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n       require(length > 1, 'no length-2 observation');\n       (lastTime, lastPx0Cumu, ) = kp3r.observations(pair, length - 2);\n     }\n     uint elapsedTime = block.timestamp - lastTime;\n     require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, 'bad TWAP time');\n     uint currPx0Cumu = currentPx0Cumu(pair);\n     return (currPx0Cumu - lastPx0Cumu) / (block.timestamp - lastTime); \n   }\n \n   function price1TWAP(address pair) public view returns (uint) {\n     uint length = kp3r.observationLength(pair);\n     require(length > 0, 'no length-1 observation');\n     (uint lastTime, , uint lastPx1Cumu) = kp3r.observations(pair, length - 1);\n     if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n       require(length > 1, 'no length-2 observation');\n       (lastTime, , lastPx1Cumu) = kp3r.observations(pair, length - 2);\n     }\n     uint elapsedTime = block.timestamp - lastTime;\n     require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, 'bad TWAP time');\n     uint currPx1Cumu = currentPx1Cumu(pair);\n     return (currPx1Cumu - lastPx1Cumu) / (block.timestamp - lastTime); \n   }\n \n \n   function currentPx0Cumu(address pair) public view returns (uint px0Cumu) {\n     uint32 currTime = uint32(block.timestamp);\n     px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n     (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n     if (lastTime != block.timestamp) {\n       uint32 timeElapsed = currTime - lastTime; \n       px0Cumu += uint((reserve1 << 112) / reserve0) * timeElapsed; \n     }\n   }\n \n \n   function currentPx1Cumu(address pair) public view returns (uint px1Cumu) {\n     uint32 currTime = uint32(block.timestamp);\n     px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n     (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n     if (lastTime != currTime) {\n       uint32 timeElapsed = currTime - lastTime;\n       px1Cumu += uint((reserve0 << 112) / reserve1) * timeElapsed; \n     }\n   }\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/Quantstamp/alpha-homora-v-2.pdf/QSP-4 Oracle attack is possible by manipulating a Uniswap pool High Fixed",
                "Location": "price0TWAP and price1TWAP functions, IUniswapV2Pair(pair).getReserves()",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.Uniswap oracle (https://uniswap.org/docs/v2/core-concepts/oracles/) aggregates prices from all the blocks weighted by block time into cumulative prices whereas Keep3r oracle takes 30-minute samples of Uniswap cumulative prices. The price calculations (i.e., function and ) in calculates the sample provided by Keep3r with a last-minute ( ) spot price from Uniswap. This is fine as long as the accumulation weight is okay, but under heavy congestion and delays the weight (i.e., in function and ) can be too big. And together with the ( ) in , this platform could be attacked by flash loans.",
                "Repair": "Use only observations on the Keep3r oracle, use more data points, and do not fine-tune the oracle with current prices"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.2;\n interface UniswapV2Library {\n     function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n }\n \n contract Oracle {\n     function read() external view returns (bytes32) {\n         address _router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n \n         uint256 _amountIn = 1e18;\n \n         address[] memory _path = new address[](2);\n         _path[0] = 0x431ad2ff6a9C365805eBaD47Ee021148d6f7DBe0;\n         _path[1] = 0xeb269732ab75A6fD61Ea60b06fE994cD32a83549; \n         \n \n         uint[] memory amounts = UniswapV2Library(_router).getAmountsOut(_amountIn, _path);\n         if (amounts[1] != uint256(0)) {\n             return bytes32(amounts[1]);\n         }\n         return bytes32(uint256(0.1e15));\n     }\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/Quantstamp/illuvium-part-4-staking-v-2.pdf/QSP-1 Missing Validation of the Oracle\u2019s Output High Acknowledged",
                "Location": "read function",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The implemented contract in calls the uniswap router to get the swap output value to be used as price estimation. However, depending on its usage, the router output can be manipulated by trading X amount back and forth on that specific Uniswap pair and the oracle call can be placed in between.",
                "Repair": "Uniswap implemented a special oracle that provide time weighted cumulative price that can be averaged later depending on the project needs"
            }
        ]
    },
    {
        "Code": "function getLpTokenValue ( address _lpToken , uint256 _amount) public view returns (\n uint256 value ) {\n uint256 totalSupply = IERC20(_lpToken) . totalSupply () ;\n address token0 = ISwapPair (_lpToken) . token0 () ;\n address token1 = ISwapPair (_lpToken) . token1 () ;\n uint256 token0Decimal = IERC20p( token0 ) . decimals () ;\n uint256 token1Decimal = IERC20p( token1 ) . decimals () ;\n ( uint256 reserve0 , uint256 reserve1 ) = SwapLibrary . getReserves ( factory , token0 ,token1 ) ;\n  uint256 token0Value = ( getAveragePrice ( token0 ) ) . mul( reserve0 ) . div (10\u2217\u2217token0Decimal ) ;\n  uint256 token1Value = ( getAveragePrice ( token1 ) ) . mul( reserve1 ) . div (10\u2217\u2217token1Decimal ) ;\n  value = ( token0Value . add( token1Value ) ) . mul(_amount) . div ( totalSupply ) ;\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-DSG-v1.0.pdf/3.11 Possible Price manipulation For Oracle::getLpTokenValue()",
                "Location": "value = ( token0Value . add( token1Value ) ) . mul(_amount) . div ( totalSupply ) ;",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.if we examine the implementation of the getLpTokenValue() , the final price of the LP Token is derived from (token0Value.add(token1Value)).mul(_amount).div(totalSupply) (line 174), where each of the tokenValue is calculated by (getAveragePrice(token0)).mul(reserve0) . Although the price of token0 or token1 is the average price from history prices and cannot be manipulated, reserve0 or reserve1 is the token amount in the pool thus can be manipulated by flash loans, which cause the final values of the LP Token not trustworthy.",
                "Repair": "Revise current execution logic of getLpTokenValue() to defensively detect any manipulation attempts in the LP Token price."
            }
        ]
    },
    {
        "Code": "    function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused {\n        require(amount > 0, 'amount cant be zero');\n        require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first');\n        require(amount <= maxStakeAmount, 'amount too high');\n        \n        usdt.safeTransferFrom(msg.sender, address(this), amount);\n        if(feePermille > 0) {\n            uint256 feeAmount = amount * feePermille / 1000;\n            usdt.safeTransfer(treasury, feeAmount);\n            amount = amount - feeAmount;\n        }\n        wusd.mint(address(this), amount);\n        uint256 wexAmount = amount * wexPermille / 1000;\n        usdt.approve(address(wswapRouter), wexAmount);\n        wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            wexAmount,\n            amountOutMin,\n            swapPath,\n            address(this),\n            block.timestamp\n        );\n        \n        wusdClaimAmount[msg.sender] = amount;\n        wusdClaimBlock[msg.sender] = block.number;\n        \n        emit Stake(msg.sender, amount);\n    }     function claimUsdt(uint256 amountOutMin) external nonReentrant whenNotPaused {\n        require(usdtClaimAmount[msg.sender] > 0, 'there is nothing to claim');\n        require(usdtClaimBlock[msg.sender] < block.number, 'you cant claim yet');\n        \n        uint256 amount = usdtClaimAmount[msg.sender];\n        usdtClaimAmount[msg.sender] = 0;\n        \n        uint256 usdtTransferAmount = amount * (1000 - wexPermille - treasuryPermille) / 1000;\n        uint256 usdtTreasuryAmount = amount * treasuryPermille / 1000;\n        uint256 wexTransferAmount = wex.balanceOf(address(this)) * amount / wusd.totalSupply();\n        wusd.burn(dead, amount);\n        usdt.safeTransfer(treasury, usdtTreasuryAmount);\n        usdt.safeTransfer(msg.sender, usdtTransferAmount);\n        wex.approve(address(wswapRouter), wexTransferAmount);\n        wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            wexTransferAmount,\n            amountOutMin,\n            swapPathReverse,\n            msg.sender,\n            block.timestamp\n        );\n        \n        emit UsdtClaim(msg.sender, amount);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-WUSD-&-WUSDMaster-v13.pdf  :   Potential WEX-USDT Exchange Rate Manipulatio",
                "Location": "",
                "Type": "Price oracle manipulation",
                "Description": "In the function WUSDMaster.stake() , a portion of staked USDT will be used to swap for WEX; in the function WUSDMaster.claimUsdt() , a portion of WEX will be used to swap for USDT. The WEX-USDT exchange rate might be manipulated by these processes. For example, if WUSD is used for lending, people can make profits through the following strategy: 1. Borrow WUSD from the lending pool. 2. Call WUSDMaster.redeem() to get prepared for triggering WUSDMaster.claimUsdt() in the next block. Borrowed WUSD is sent to the contract in this step. 3. Call WUSDMaster.claimUsdt() and receive USDT. A portion of WEX in this contract is swapped for USDT so the price of WEX decreases in this step. Although the amount of claimed USDT is restricted in the previous step, people can create multiple accounts and trigger WUSDMaster.claimUsdt() for multiple accounts in one transaction so the change of WEX-USDT exchange rate should not be ignored. 4. Swap USDT for WEX at a low WEX price. 5. Call WUSDMaster.stake() to get prepared for claiming WUSD in the next block. USDT is sent to the contract, with a portion of it is used to swap for WEX, which leads to an increase in WEX's price. 6. Swap WEX for USDT. Considering the price of WEX has been increased by the previous step, people make profits by steps 4 and 6. Steps 3 to 6 should happen in one transaction. 7. Call WUSDMaster.claimWusd() and receive WUSD. 8. Return borrowed WUSD to the lending pool.",
                "Repair": "We advise the Wault Finance team to restrict the change of WEX-USDT exchange rate made by WUSDMaster.stake() and WUSDMaster.claimUsdt() ."
            }
        ]
    },
    {
        "Code": "    function _convertPrice(\n        address _fromAsset,\n        address _toAsset,\n        uint256 _fromAmount\n    ) internal view returns(uint256) {\n        require(_fromAsset != _toAsset, \"!SAME_ASSET\");\n        require(assets[_fromAsset].priceFeed != address(0), \"!INVALID(fromAsset)\");\n        require(assets[_toAsset].priceFeed != address(0), \"!NOT_ALLOWED(toAsset)\");\n\n        if (_fromAmount == 0) {\n            return 0;\n        }\n\n        int256 oraclePrice;\n        uint256 updatedAt;\n\n        ( , oraclePrice, , updatedAt, ) = AggregatorV3Interface(assets[_fromAsset].priceFeed).latestRoundData();\n        uint256 fromOraclePrice = uint256(oraclePrice);\n        require(maxPriceFeedAge == 0 || block.timestamp - updatedAt <= maxPriceFeedAge, \"!PRICE_OUTDATED\");\n        ( , oraclePrice, , updatedAt, ) = AggregatorV3Interface(assets[_toAsset].priceFeed).latestRoundData();\n        uint256 toOraclePrice = uint256(oraclePrice);\n        require(maxPriceFeedAge == 0 || block.timestamp - updatedAt <= maxPriceFeedAge, \"!PRICE_OUTDATED\");\n\n        if (assets[_fromAsset].priceFeedDecimals != assets[_toAsset].priceFeedDecimals) {\n            // since oracle precision is different, scale everything\n            // to _toAsset precision and do conversion\n            return _scalePrice(_fromAmount, assets[_fromAsset].assetDecimals, assets[_toAsset].assetDecimals) *\n                    _scalePrice(fromOraclePrice, assets[_fromAsset].priceFeedDecimals, assets[_toAsset].assetDecimals) /\n                    _scalePrice(toOraclePrice, assets[_toAsset].priceFeedDecimals, assets[_toAsset].assetDecimals);\n        } else {\n            // oracles are already in same precision, so just scale _amount to asset precision,\n            // and multiply by the price feed ratio\n            return _scalePrice(_fromAmount, assets[_fromAsset].assetDecimals, assets[_toAsset].assetDecimals) *\n                fromOraclePrice / toOraclePrice;\n        }\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-Cask-v4.pdf  :   How to Guarantee The AggregatorV3Interface Price Pairs Is Correct",
                "Location": "",
                "Type": "Price oracle manipulation",
                "Description": "As the design of Chainlink Data Feeds we could calculate the currency price across two price pairs.For example, if you needed a BTC / EUR price, you could take the BTC / USD feed and the EUR / USD feed and derive BTC / EUR using the division. So here comes a question: Is there any protection in CaskVault contracts to make sure the fromOraclePrice and toOraclePrice are based on the same currency denomination? If assets[_fromAsset].priceFeed provide a TokenA / ETH price\uff0c but assets[_toAsset].priceFeed provides a TokenB / BTC price. The calculation result for will be TokenA * BTC / TokenB * ETH , and it's not expected.",
                "Repair": "Recommend to conform the data feed setup logic is well restricted"
            }
        ]
    },
    {
        "Code": "    function deposit(\n        uint256 deposit0,\n        uint256 deposit1,\n        address to\n    ) external nonReentrant override returns (uint256 shares) {\n        require(deposit0 > 0 || deposit1 > 0, \"deposits must be nonzero\");\n        require(deposit0 < deposit0Max && deposit1 < deposit1Max, \"deposits must be less than maximum amounts\");\n        require(to != address(0) && to != address(this), \"to\");\n\n        // update fees for inclusion in total pool amounts\n        (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);\n        if (baseLiquidity > 0) {\n            pool.burn(baseLower, baseUpper, 0);\n        }\n        (uint128 limitLiquidity,,)  = _position(limitLower, limitUpper);\n        if (limitLiquidity > 0) {\n            pool.burn(limitLower, limitUpper, 0);\n        }\n\n        uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());\n        uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));\n\n        (uint256 pool0, uint256 pool1) = getTotalAmounts();\n\n        uint256 deposit0PricedInToken1 = deposit0.mul(price).div(PRECISION);\n        shares = deposit1.add(deposit0PricedInToken1);\n\n        if (deposit0 > 0) {\n          token0.safeTransferFrom(msg.sender, address(this), deposit0);\n        }\n        if (deposit1 > 0) {\n          token1.safeTransferFrom(msg.sender, address(this), deposit1);\n        }\n\n        if (totalSupply() != 0) {\n          uint256 pool0PricedInToken1 = pool0.mul(price).div(PRECISION);\n          shares = shares.mul(totalSupply()).div(pool0PricedInToken1.add(pool1));\n        }\n        _mint(to, shares);\n        emit Deposit(msg.sender, to, shares, deposit0, deposit1);\n        // Check total supply cap not exceeded. A value of 0 means no limit.\n        require(maxTotalSupply == 0 || totalSupply() <= maxTotalSupply, \"maxTotalSupply\");\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "REP-Liquidrium-Limited-2021-12-04.pdf  :   Potential Price Manipulation In Shares Calculatio",
                "Location": "        uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());\n        uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));\n\n        (uint256 pool0, uint256 pool1) = getTotalAmounts();\n\n        uint256 deposit0PricedInToken1 = deposit0.mul(price).div(PRECISION);\n        shares = deposit1.add(deposit0PricedInToken1);\n     function currentTick() public view returns (int24 tick) {\n        int24 _tick = getTwap();\n        return _tick;\n    }",
                "Type": "Price oracle manipulation",
                "Description": "In the function HyperLiquidrium.deposit,the number of shares deposited is calculated using the price from the UniswapV3 pool. The function HyperLiquidrium.currentTick() returns the current price in the UniswapV3 pool instead of a TWAP (time-weighted average price)Attackers would be able to manipulate the current price in UniswapV3 pool by a flashloan and attack the project. Attackers would be able to manipulate the current price in UniswapV3 pool by a flashloan and attack the project",
                "Repair": "it is recommended to use a TWAP oracle to provide the price for shares calculation in the function HyperLiquidrium.deposit() "
            }
        ]
    },
    {
        "Code": "    /// @notice This method is defined in the BaseStrategy contract and is meant\n    ///         to provide an accurate conversion from amtInWei (denominated in wei)\n    ///         to want token (using the native decimal characteristics of want token).\n    /// @param amtInWei The amount (in wei/1e-18 ETH) to convert to want tokens.\n    /// @return The amount in want tokens.\n    function ethToWant(uint256 amtInWei)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        address[] memory path = new address[](2);\n        path[0] = wethToken;\n        path[1] = wbtcToken;\n\n        // As of writing this contract, there's no pool available that trades\n        // an underlying token with ETH. To overcome this, the ETH amount\n        // denominated in WEI should be converted into an amount denominated\n        // in one of the tokens accepted by the tBTC v2 Curve pool using Uniswap.\n        // The wBTC token was chosen arbitrarily since it is already used in this\n        // contract for other operations on Uniswap.\n        // amounts[0] -> ETH in wei\n        // amounts[1] -> wBTC\n        uint256[] memory amounts = IUniswapV2Router(uniswap).getAmountsOut(\n            amtInWei,\n            path\n        );\n\n        // Use the amount denominated in wBTC to calculate the amount of LP token\n        // (vault's underlying token) that could be obtained if that wBTC amount\n        // was deposited in the Curve pool that has tBTC v2 in it. This way we\n        // obtain an estimated value of the original WEI amount represented in\n        // the vault's underlying token.\n        //\n        // TODO: When the new curve pool with tBTC v2 is deployed, verify that\n        // the index of wBTC (amounts[1]) in the array is correct.\n        return\n            ICurvePool(tbtcCurvePoolDepositor).calc_token_amount(\n                [0, 0, amounts[1], 0],\n                true\n            );\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-KEEP.pdf  :   Potential manipulation on token pric",
                "Location": "    uint256[] memory amounts = IUniswapV2Router(uniswap).getAmountsOut(\n            amtInWei,\n            path\n        );\n        return\n            ICurvePool(tbtcCurvePoolDepositor).calc_token_amount(\n                [0, 0, amounts[1], 0],\n                true\n            );",
                "Type": "Price oracle manipulation",
                "Description": "ethToWant uses DEX API to determine the amount of token to be swapped. However, this price can be significantly manipulated by trading with DEX. It seems like Sandwich Attacks.",
                "Repair": "If a project requires price references, it needs to be caution of flash loans that might manipulate token prices. To minimize the chance of happening, we recommend the client to consider following according to the project's business model 1. Use multiple reliable on-chain price oracle sources, such as Chainlink and Uniswap. 2. Use Time-Weighted Average Price (TWAP). The TWAP represents the average price of a token over a specified time frame. If an attacker manipulates the price in one block, it will not affect too much on the average price. 3. Flash loans only allow users to borrow money within a single transaction. If the contract use cases allowed, force critical transactions to span at least two blocks."
            }
        ]
    },
    {
        "Code": "contract UniswapUtils is IUniswapUtils {\n\n    using SafeMath for uint256;\n\n    uint24 public constant POOL_FEE = 3000;\n\n    uint32 public constant TWAP_PERIOD = 60;\n\n    function calculateLimitTicks(\n        IUniswapV3Pool _pool,\n        uint160 _sqrtPriceX96,\n        uint256 _amount0,\n        uint256 _amount1\n    ) external override view\n    returns (\n        int24 _lowerTick,\n        int24 _upperTick,\n        uint128 _liquidity,\n        uint128 _orderType\n    ) {\n\n        int24 tickSpacing = _pool.tickSpacing();\n        (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0();\n\n        int24 _targetTick = TickMath.getTickAtSqrtRatio(_sqrtPriceX96);\n\n        int24 tickFloor = _floor(_targetTick, tickSpacing);\n\n        return _checkLiquidityRange(\n            tickFloor - tickSpacing,\n            tickFloor,\n            tickFloor,\n            tickFloor + tickSpacing,\n            _amount0,\n            _amount1,\n            sqrtRatioX96,\n            tickSpacing\n        );\n\n    }\n\n    function quoteKROM(IUniswapV3Factory factory, address WETH, address KROM, uint256 _weiAmount)\n    external override view returns (uint256 quote) {\n\n        address _poolAddress = factory.getPool(WETH, KROM, POOL_FEE);\n        require(_poolAddress != address(0), \"UUC_PA\");\n\n        if (_weiAmount > 0) {\n            (int24 arithmeticMeanTick,) = OracleLibrary.consult(_poolAddress, TWAP_PERIOD);\n            quote = OracleLibrary.getQuoteAtTick(\n                arithmeticMeanTick,\n                _toUint128(_weiAmount),\n                WETH,\n                KROM\n            );\n        }\n    }\n\n    function _checkLiquidityRange(int24 _bidLower, int24 _bidUpper,\n        int24 _askLower, int24 _askUpper,\n        uint256 _amount0, uint256 _amount1,\n        uint160 sqrtRatioX96, int24 _tickSpacing) internal pure\n    returns (int24 _lowerTick, int24 _upperTick, uint128 _liquidity, uint128 _orderType) {\n\n        _checkRange(_bidLower, _bidUpper, _tickSpacing);\n        _checkRange(_askLower, _askUpper, _tickSpacing);\n\n        uint128 bidLiquidity = _liquidityForAmounts(sqrtRatioX96, _bidLower, _bidUpper, _amount0, _amount1);\n        uint128 askLiquidity = _liquidityForAmounts(sqrtRatioX96, _askLower, _askUpper, _amount0, _amount1);\n\n        require(bidLiquidity > 0 || askLiquidity > 0, \"UUC_BAL\");\n\n        if (bidLiquidity > askLiquidity) {\n            (_lowerTick, _upperTick, _liquidity, _orderType) = (_bidLower, _bidUpper, bidLiquidity, uint128(1));\n        } else {\n            (_lowerTick, _upperTick, _liquidity, _orderType) = (_askLower, _askUpper, askLiquidity, uint128(2));\n        }\n    }\n\n    /// @dev Casts uint256 to uint128 with overflow check.\n    function _toUint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max, \"UUC_IC\");\n        return uint128(x);\n    }\n\n    /// @dev Wrapper around `LiquidityAmounts.getLiquidityForAmounts()`.\n    function _liquidityForAmounts(\n        uint160 sqrtRatioX96,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128) {\n        return\n        LiquidityAmounts.getLiquidityForAmounts(\n            sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            amount0,\n            amount1\n        );\n    }\n\n    /// @dev Wrapper around `LiquidityAmounts.getAmountsForLiquidity()`.\n    function _amountsForLiquidity(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) external override view returns (uint256, uint256) {\n        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();\n        return\n        LiquidityAmounts.getAmountsForLiquidity(\n            sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            liquidity\n        );\n    }\n\n    function _checkRange(int24 _tickLower, int24 _tickUpper, int24 _tickSpacing) internal pure {\n\n        require(_tickLower < _tickUpper, \"UUC_TLU\");\n        require(_tickLower >= TickMath.MIN_TICK, \"UUC_TLMIN\");\n        require(_tickUpper <= TickMath.MAX_TICK, \"UUC_TAMAX\");\n        require(_tickLower % _tickSpacing == 0, \"UUC_TLS\");\n        require(_tickUpper % _tickSpacing == 0, \"UUC_TUS\");\n    }\n\n    /// @dev Rounds tick down towards negative infinity so that it's a multiple\n    /// of `tickSpacing`.\n    function _floor(int24 tick, int24 _tickSpacing) internal pure returns (int24) {\n        int24 compressed = tick / _tickSpacing;\n        if (tick < 0 && tick % _tickSpacing != 0) compressed--;\n        return compressed * _tickSpacing;\n    }\n\n    receive() external payable {}\n}",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-Kromatika.Finance-v13.pdf  :   Potential Oracle Manipulatio",
                "Location": "    uint32 public constant TWAP_PERIOD = 60;     function quoteKROM(IUniswapV3Factory factory, address WETH, address KROM, uint256 _weiAmount)\n    external override view returns (uint256 quote) {\n\n        address _poolAddress = factory.getPool(WETH, KROM, POOL_FEE);\n        require(_poolAddress != address(0), \"UUC_PA\");\n\n        if (_weiAmount > 0) {\n            (int24 arithmeticMeanTick,) = OracleLibrary.consult(_poolAddress, TWAP_PERIOD);\n            quote = OracleLibrary.getQuoteAtTick(\n                arithmeticMeanTick,\n                _toUint128(_weiAmount),\n                WETH,\n                KROM\n            );\n        }\n    }",
                "Type": "Price oracle manipulation",
                "Description": "In the function quoteKROM() , timeWeightedAverageTick is used to calculate the amount of KROM token received in exchange given a tick and a token amount. However, the timeWeightedAverageTick is fetched using Uniswap V3 oracle given the pool address and the TWAP_PERIOD that is used to calculate the time weighted average. To be noticed, the TWAP_PERIOD is in units of seconds. By the current setting, the TWAP_PERIOD is a constant and it's only 20 seconds, which means the timeWeightedAverageTick is vulnerable to oracle manipulation. The attacker could manipulate the pool for a few seconds to further manipulate the timeWeightedAverageTick since the time weight is relatively focused in a short period of time which makes it be easily manipulated.",
                "Repair": "consider increasing the value of TWAP_PERIOD to increase the quote resilience from potential oracle manipulation"
            }
        ]
    },
    {
        "Code": "contract UniswapUtils is IUniswapUtils {\n\n    using SafeMath for uint256;\n\n    uint24 public constant POOL_FEE = 3000;\n\n    uint32 public constant TWAP_PERIOD = 60;\n\n    function calculateLimitTicks(\n        IUniswapV3Pool _pool,\n        uint160 _sqrtPriceX96,\n        uint256 _amount0,\n        uint256 _amount1\n    ) external override view\n    returns (\n        int24 _lowerTick,\n        int24 _upperTick,\n        uint128 _liquidity,\n        uint128 _orderType\n    ) {\n\n        int24 tickSpacing = _pool.tickSpacing();\n        (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0();\n\n        int24 _targetTick = TickMath.getTickAtSqrtRatio(_sqrtPriceX96);\n\n        int24 tickFloor = _floor(_targetTick, tickSpacing);\n\n        return _checkLiquidityRange(\n            tickFloor - tickSpacing,\n            tickFloor,\n            tickFloor,\n            tickFloor + tickSpacing,\n            _amount0,\n            _amount1,\n            sqrtRatioX96,\n            tickSpacing\n        );\n\n    }\n\n    function quoteKROM(IUniswapV3Factory factory, address WETH, address KROM, uint256 _weiAmount)\n    external override view returns (uint256 quote) {\n\n        address _poolAddress = factory.getPool(WETH, KROM, POOL_FEE);\n        require(_poolAddress != address(0), \"UUC_PA\");\n\n        if (_weiAmount > 0) {\n            (int24 arithmeticMeanTick,) = OracleLibrary.consult(_poolAddress, TWAP_PERIOD);\n            quote = OracleLibrary.getQuoteAtTick(\n                arithmeticMeanTick,\n                _toUint128(_weiAmount),\n                WETH,\n                KROM\n            );\n        }\n    }\n\n    function _checkLiquidityRange(int24 _bidLower, int24 _bidUpper,\n        int24 _askLower, int24 _askUpper,\n        uint256 _amount0, uint256 _amount1,\n        uint160 sqrtRatioX96, int24 _tickSpacing) internal pure\n    returns (int24 _lowerTick, int24 _upperTick, uint128 _liquidity, uint128 _orderType) {\n\n        _checkRange(_bidLower, _bidUpper, _tickSpacing);\n        _checkRange(_askLower, _askUpper, _tickSpacing);\n\n        uint128 bidLiquidity = _liquidityForAmounts(sqrtRatioX96, _bidLower, _bidUpper, _amount0, _amount1);\n        uint128 askLiquidity = _liquidityForAmounts(sqrtRatioX96, _askLower, _askUpper, _amount0, _amount1);\n\n        require(bidLiquidity > 0 || askLiquidity > 0, \"UUC_BAL\");\n\n        if (bidLiquidity > askLiquidity) {\n            (_lowerTick, _upperTick, _liquidity, _orderType) = (_bidLower, _bidUpper, bidLiquidity, uint128(1));\n        } else {\n            (_lowerTick, _upperTick, _liquidity, _orderType) = (_askLower, _askUpper, askLiquidity, uint128(2));\n        }\n    }\n\n    /// @dev Casts uint256 to uint128 with overflow check.\n    function _toUint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max, \"UUC_IC\");\n        return uint128(x);\n    }\n\n    /// @dev Wrapper around `LiquidityAmounts.getLiquidityForAmounts()`.\n    function _liquidityForAmounts(\n        uint160 sqrtRatioX96,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128) {\n        return\n        LiquidityAmounts.getLiquidityForAmounts(\n            sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            amount0,\n            amount1\n        );\n    }\n\n    /// @dev Wrapper around `LiquidityAmounts.getAmountsForLiquidity()`.\n    function _amountsForLiquidity(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) external override view returns (uint256, uint256) {\n        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();\n        return\n        LiquidityAmounts.getAmountsForLiquidity(\n            sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            liquidity\n        );\n    }\n\n    function _checkRange(int24 _tickLower, int24 _tickUpper, int24 _tickSpacing) internal pure {\n\n        require(_tickLower < _tickUpper, \"UUC_TLU\");\n        require(_tickLower >= TickMath.MIN_TICK, \"UUC_TLMIN\");\n        require(_tickUpper <= TickMath.MAX_TICK, \"UUC_TAMAX\");\n        require(_tickLower % _tickSpacing == 0, \"UUC_TLS\");\n        require(_tickUpper % _tickSpacing == 0, \"UUC_TUS\");\n    }\n\n    /// @dev Rounds tick down towards negative infinity so that it's a multiple\n    /// of `tickSpacing`.\n    function _floor(int24 tick, int24 _tickSpacing) internal pure returns (int24) {\n        int24 compressed = tick / _tickSpacing;\n        if (tick < 0 && tick % _tickSpacing != 0) compressed--;\n        return compressed * _tickSpacing;\n    }\n\n    receive() external payable {}\n}",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-Kromatika.Finance-v13.pdf  :   Potential Price Manipulatio",
                "Location": "    function calculateLimitTicks(\n        IUniswapV3Pool _pool,\n        uint160 _sqrtPriceX96,\n        uint256 _amount0,\n        uint256 _amount1\n    ) external override view\n    returns (\n        int24 _lowerTick,\n        int24 _upperTick,\n        uint128 _liquidity,\n        uint128 _orderType\n    ) {\n\n        int24 tickSpacing = _pool.tickSpacing();\n        (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0();\n\n        int24 _targetTick = TickMath.getTickAtSqrtRatio(_sqrtPriceX96);\n\n        int24 tickFloor = _floor(_targetTick, tickSpacing);\n\n        return _checkLiquidityRange(\n            tickFloor - tickSpacing,\n            tickFloor,\n            tickFloor,\n            tickFloor + tickSpacing,\n            _amount0,\n            _amount1,\n            sqrtRatioX96,\n            tickSpacing\n        );\n\n    }     function calculateLimitTicks(\n        IUniswapV3Pool _pool,\n        uint160 _sqrtPriceX96,\n        uint256 _amount0,\n        uint256 _amount1\n    ) external override view\n    returns (\n        int24 _lowerTick,\n        int24 _upperTick,\n        uint128 _liquidity,\n        uint128 _orderType\n    ) {\n\n        int24 tickSpacing = _pool.tickSpacing();\n        (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0();\n\n        int24 _targetTick = TickMath.getTickAtSqrtRatio(_sqrtPriceX96);\n\n        int24 tickFloor = _floor(_targetTick, tickSpacing);\n\n        return _checkLiquidityRange(\n            tickFloor - tickSpacing,\n            tickFloor,\n            tickFloor,\n            tickFloor + tickSpacing,\n            _amount0,\n            _amount1,\n            sqrtRatioX96,\n            tickSpacing\n        );\n\n    }",
                "Type": "Price oracle manipulation",
                "Description": "n the function calculateLimitTicks() , Uniswap V3 pool's spot price is used to calculate the liquidity range. (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0(); The spot price of Uniswap V3 pools can be manipulated by flash loan attacks to generate a liquidity range that favors the attacker. In the function _amountsForLiquidity() , Uniswap V3 pool's spot price is also used to compute the token0 and token1 value for a given amount of liquidity. (uint160 sqrtRatioX96, , , , , , ) = pool.slot0(); The spot price of Uniswap V3 pools can be manipulated by flash loan attacks to generate token values that favor the attacker.",
                "Repair": "Considering using time weighted average price to reduce the effects from the pool price manipulation."
            }
        ]
    },
    {
        "Code": "    function getExchangeCountOfOneUsdt(address lptoken)\n        public\n        view\n        returns (uint256)\n    {\n        require(_lpPools[lptoken].tradeContract != address(0));\n\n        if (lptoken == address(2)) //BNB\n        {\n            (uint112 _reserve0, uint112 _reserve1, ) =\n                IPancakePair(_bnbtradeaddress).getReserves();\n            uint256 a = _reserve0;\n            uint256 b = _reserve1;\n            return b.mul(1e18).div(a);\n        }\n\n        if (lptoken == _Lizaddr) {\n            (uint112 _reserve0, uint112 _reserve1, ) =\n                IPancakePair(_Liztrade).getReserves();\n            uint256 a = _reserve0;\n            uint256 b = _reserve1;\n            return b.mul(1e18).div(a);\n        } else {\n            (uint112 _reserve0, uint112 _reserve1, ) =\n                IPancakePair(_bnbtradeaddress).getReserves();\n            (uint112 _reserve3, uint112 _reserve4, ) =\n                IPancakePair(_lpPools[lptoken].tradeContract).getReserves();\n\n            uint256 balancea = _reserve0;\n            uint256 balanceb = _reserve1;\n            uint256 balancec =\n                IPancakePair(_lpPools[lptoken].tradeContract).token0() ==\n                    lptoken\n                    ? _reserve3\n                    : _reserve4;\n            uint256 balanced =\n                IPancakePair(_lpPools[lptoken].tradeContract).token0() ==\n                    lptoken\n                    ? _reserve4\n                    : _reserve3;\n            if (balancea == 0 || balanceb == 0 || balanced == 0) return 0;\n            return balancec.mul(1e18).div(balancea.mul(balanced).div(balanceb));\n        }\n    } ",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-Lizard.pdf  :   Potential flash loans manipulate the token pric",
                "Location": "uint256 balancec = IPancakePair(_lpPools[lptoken].tradeContract).token0() == lptoken ? _reserve3 : _reserve4;",
                "Type": "Price oracle manipulation",
                "Description": "Function getExchangeCountOfOneUsdt is used to calculate the token price by the number of tokens in the pair of Pancake Swap. And the pair pool may be affected by a huge number of token transactions. Flash loans are a way to borrow large amounts of tokens for a certain fee. An attacker can use the borrowed token as the initial funds for an exploit to enlarge the profit and/or manipulate the token price in the decentralized exchanges. We find that the buyVip , TakeBack , deposit , and some other functions rely on price calculations that are based on-chain, meaning that they would be susceptible to flash-loan attacks by manipulating the price of given pairs to the attacker's benefit.",
                "Repair": "If a project requires price references, it needs to be careful of flash loans that might manipulate token prices. To prevent this from happening, we recommend the following: 1. Use a reliable on-chain price oracle, such as Chainlink. 2. Use Time-Weighted Average Price (TWAP). The TWAP represents the average price of a token over a specified time frame. If an attacker manipulates the price in one block, it will not affect too much on the average price. 3. If the business model allows, restrict the function caller to be a non-contract/EOA address. 4. Flash loans only allow users to borrow money within a single transaction. If the contract use cases allowed, force critical transactions to span at least two blocks."
            }
        ]
    },
    {
        "Code": "    function getUpdatedPriceInPeg(address token, uint256 inAmount)\n        internal\n        virtual\n        returns (uint256)\n    {\n        if (token == peg) {\n            return inAmount;\n        } else {\n            TokenPrice storage tokenPrice = tokenPrices[token];\n            uint256[] memory pathAmounts =\n                MarginRouter(router()).getAmountsOut(\n                    UNI,\n                    inAmount,\n                    tokenPrice.liquidationPath\n                );\n            uint256 outAmount = pathAmounts[pathAmounts.length - 1];\n\n            if (\n                outAmount > UPDATE_MIN_PEG_AMOUNT &&\n                outAmount < UPDATE_MAX_PEG_AMOUNT\n            ) {\n                confidentUpdatePriceInPeg(tokenPrice, inAmount, outAmount);\n            }\n\n            return outAmount;\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-MarginSwap---Core-Implementation-Contracts-v2.pdf  :   Susceptible to Oracle Price Manipulation  ",
                "Location": "uint256[] memory pathAmounts = MarginRouter(router()).getAmountsOut( UNI, inAmount, tokenPrice.liquidationPath );",
                "Type": "Price oracle manipulation",
                "Description": "The getUpdatedPriceInPeg relies on a price update based on UniSwap using the getAmountsOut function which can yield unreliable results in case a flash loan has been deposited temporarily to the pair",
                "Repair": "Although ranges do exist within L91-L94 that are meant to guarantee the fluctuation of price is within a minimum and maximum range, the function can still be exploited whereby the price is kept \"still\" or even slightly moved within the bounds as this can be pre-calculated. We advise the calculation of price based on TWAPs (Time-Weighted Average Prices) rather than spot prices to ensure security in the protocol. A confidence rating is utilized in L130-L143, however, sharp changes in price can still overpower the \"weighted\" average imposed here as it is not sufficiently parameterized to prevent such an attack."
            }
        ]
    },
    {
        "Code": "function _transfer(\naddress from,\naddress to,\nuint256 amount\n) private {\nrequire(from != address(0), \"ERC20: transfer from the zero address\");\nrequire(to != address(0), \"ERC20: transfer to the zero address\");\nrequire(amount > 0, \"Transfer amount must be greater than zero\");\nrequire(tradingOpen || _tradingOpenExempt[from] , \"Trading not open yet\");\nrequire(launchedBlock + deadBlocks <= block.number || _tradingOpenExempt[from], \"BOT not allowed\");\n\nif (!_isMaxWalletExempt[from] && to != address(this)  && to != address(DEAD_ADDRESS) && to != uniswapV2Pair && to != marketingFeeReceiver && to != autoLiquidityReceiver){\nuint256 heldTokens = balanceOf(to);\nrequire((heldTokens + amount) <= _maxWalletAmount,\"Total Holding is currently limited, you can not buy that much.\");}\n\nrequire(amount <= _maxTxAmount || _isMaxTaxExempt[to] || _isMaxTaxExempt[from] , \"Transfer amount exceeds the maxTxAmount.\");\n\nif (from == uniswapV2Pair &&\n!_isTimelockExempt[to]) {\nrequire(cooldownTimer[to] < block.timestamp,\"Please wait for cooldown between two buys\");\ncooldownTimer[to] = block.timestamp + cooldownTimerInterval;\n}\n\n// is the token balance of this contract address over the min number of\n// tokens that we need to initiate a swap + liquidity lock?\n// also, don't get caught in a circular liquidity event.\n// also, don't swap & liquify if sender is uniswap pair.\nuint256 contractTokenBalance = balanceOf(address(this));\n\nbool isSell = setIsSell(to);\n\nif (isSell && from != owner()){\n_amountTokensLastSold += _getSellBnBAmount(amount);\n}\n\n\nif(contractTokenBalance >= _maxTxAmount)\n{\ncontractTokenBalance = _maxTxAmount;\n}\n\nbool overMinTokenBalance = contractTokenBalance >= minTokensBeforeSwap;\nif (\noverMinTokenBalance &&\n!inSwapAndLiquify &&\nfrom != uniswapV2Pair &&\nswapAndLiquifyEnabled\n) {\ncontractTokenBalance = minTokensBeforeSwap;\n//add liquidity\nswapAndLiquify(contractTokenBalance);\n\nuint256 balance = address(this).balance;\nif (buyBackEnabled) {\nif(balance > buyBackUpperLimit){\nuint256 buyBackAmount = _amountTokensLastSold.div(1000).mul(_percentLastSoldToBuyBackTimesTen);\nif(buyBackAmount < balance){\nbuyBackTokens(buyBackAmount);\n_amountTokensLastSold = 0;\n}else{\namountTokensLastSold = 0;\n}\n}\n}\n}\n\n//indicates if fee should be deducted from transfer\nbool takeFee = true;\n\n//if any account belongs to _isExcludedFromFee account then remove the fee\nif(_isExcludedFromFee[from] || _isExcludedFromFee[to] || inSwapAndLiquify ){\ntakeFee = false;\n}\n//transfer amount, it will take tax, burn, liquidity fee\n_tokenTransfer(from,to,amount,takeFee, isSell);\n\n}     function _getSellBnBAmount(uint256 tokenAmount) private view returns(uint256) {\n        address[] memory path = new address[](2);\n\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        uint[] memory amounts = uniswapV2Router.getAmountsOut(tokenAmount, path);\n\n        return amounts[1];\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-Party-dog-v8.pdf  :   Arbitrage through Pair Price Manipulatio",
                "Location": "    function _getSellBnBAmount(uint256 tokenAmount) private view returns(uint256) {\n        address[] memory path = new address[](2);\n\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        uint[] memory amounts = uniswapV2Router.getAmountsOut(tokenAmount, path);\n\n        return amounts[1];\n    }",
                "Type": "Price oracle manipulation",
                "Description": "_amountTokensLastSold is determined by the token versus bnb ratio on the uniswap pair which is the same pair used for buyBack. Maybe it is possible to manipulate the price on that pair using a large amount of token or bnb and take advantage of it through the buyBack feature during transfer",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function trade(address trader, uint256 symbolId, int256 tradeVolume) external override _lock_ {\n        _checkRouter();\n        Data memory data = _getBTokensAndSymbols(type(uint256).max, symbolId);\n        _getMarginsAndPositions(data, trader);\n        SymbolData memory s = data.symbols[symbolId];\n        IPToken.Position memory p = data.positions[symbolId];\n\n        tradeVolume = tradeVolume.reformat(0);\n        require(tradeVolume != 0, '0 tradeVolume');\n\n        int256 curCost = DpmmPricerFutures._calculateDpmmCost(\n            s.indexPrice,\n            s.K,\n            s.tradersNetPosition,\n            tradeVolume * s.multiplier / ONE\n        );\n        int256 fee = curCost.abs() * s.feeRatio / ONE;\n\n        int256 realizedCost;\n        if (!(p.volume >= 0 && tradeVolume >= 0) && !(p.volume <= 0 && tradeVolume <= 0)) {\n            int256 absVolume = p.volume.abs();\n            int256 absTradeVolume = tradeVolume.abs();\n            if (absVolume <= absTradeVolume) {\n                realizedCost = curCost * absVolume / absTradeVolume + p.cost;\n            } else {\n                realizedCost = p.cost * absTradeVolume / absVolume + curCost;\n            }\n        }\n\n        int256 preVolume = p.volume;\n        p.volume += tradeVolume;\n        p.cost += curCost - realizedCost;\n        p.lastCumulativeFundingRate = s.cumulativeFundingRate;\n        s.positionUpdated = true;\n\n        data.margins[0] -= fee + realizedCost;\n\n        int256 protocolFee = fee * _protocolFeeCollectRatio / ONE;\n        _protocolFeeAccrued += protocolFee;\n        data.undistributedPnl += fee - protocolFee;\n\n        s.distributedUnrealizedPnl += realizedCost;\n        _distributePnlToBTokens(data);\n\n        s.tradersNetVolume += tradeVolume;\n        s.tradersNetCost += curCost - realizedCost;\n\n        data.totalTraderNontional += (p.volume.abs() - preVolume.abs()) * s.indexPrice / ONE * s.multiplier / ONE;\n        data.totalNotional += s.tradersNetVolume.abs() * s.indexPrice / ONE * s.multiplier / ONE - s.notional;\n\n        IPToken(_pTokenAddress).updatePosition(trader, symbolId, p);\n        _updateBTokensAndSymbols(data);\n        _updateMarginsAndPositions(data);\n\n        require(data.totalEquity * ONE >= data.totalNotional * _minPoolMarginRatio, \"insuf't liq\");\n        require(data.totalTraderEquity * ONE >= data.totalTraderNontional * _initialMarginRatio, \"insuf't margin\");\n\n        emit Trade(trader, symbolId, s.indexPrice, tradeVolume, curCost, fee);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "REP-deriprotocol-v2-2021-06-02.pdf  :   Traders May Manipulate Pric",
                "Location": "function trade",
                "Type": "Price oracle manipulation",
                "Description": "Flash loans are a way to borrow large amounts of money for a certain fee. The requirement is that the loans need to be returned within the same transaction in a block. If not, the transaction will be reverted. An attacker can use the borrowed money as the initial funds for an exploit to enlarge the profit and/or manipulate the token price in the decentralized exchanges. We find that the [PerpetualPool.sol/trade()] rely on price calculations that are based on-chain, meaning that they would be susceptible to flash-loan attacks by manipulating the price of given pairs to the attacker's benefit.",
                "Repair": "If a project requires price references, it needs to be careful of flash loans that might manipulate token prices"
            }
        ]
    },
    {
        "Code": "    function deposit(\n        uint256 deposit0,\n        uint256 deposit1,\n        address to\n    ) external nonReentrant override returns (uint256 shares) {\n        require(deposit0 > 0 || deposit1 > 0, \"deposits must be nonzero\");\n        require(deposit0 < deposit0Max && deposit1 < deposit1Max, \"deposits must be less than maximum amounts\");\n        require(to != address(0) && to != address(this), \"to\");\n\n        // update fees for inclusion in total pool amounts\n        (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);\n        if (baseLiquidity > 0) {\n            pool.burn(baseLower, baseUpper, 0);\n        }\n        (uint128 limitLiquidity,,)  = _position(limitLower, limitUpper);\n        if (limitLiquidity > 0) {\n            pool.burn(limitLower, limitUpper, 0);\n        }\n\n        uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());\n        uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));\n\n        (uint256 pool0, uint256 pool1) = getTotalAmounts();\n\n        uint256 deposit0PricedInToken1 = deposit0.mul(price).div(PRECISION);\n        shares = deposit1.add(deposit0PricedInToken1);\n\n        if (deposit0 > 0) {\n          token0.safeTransferFrom(msg.sender, address(this), deposit0);\n        }\n        if (deposit1 > 0) {\n          token1.safeTransferFrom(msg.sender, address(this), deposit1);\n        }\n\n        if (totalSupply() != 0) {\n          uint256 pool0PricedInToken1 = pool0.mul(price).div(PRECISION);\n          shares = shares.mul(totalSupply()).div(pool0PricedInToken1.add(pool1));\n        }\n        _mint(to, shares);\n        emit Deposit(msg.sender, to, shares, deposit0, deposit1);\n        // Check total supply cap not exceeded. A value of 0 means no limit.\n        require(maxTotalSupply == 0 || totalSupply() <= maxTotalSupply, \"maxTotalSupply\");\n    } function currentTick() public view returns (int24 tick) { int24 _tick = getTwap(); return tick;}",
        "VulnerabilityDesc": [
            {
                "Name": "REP-Liquidrium-Limited-2021-12-04.pdf  :   Potential Price Manipulation In Shares Calculatio",
                "Location": "uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());\n        uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));\n\n        (uint256 pool0, uint256 pool1) = getTotalAmounts();\n\n uint256 deposit0PricedInToken1 = deposit0.mul(price).div(PRECISION);\n        shares = deposit1.add(deposit0PricedInToken1);\n\n",
                "Type": "Price oracle manipulation",
                "Description": "In the function HyperLiquidrium.deposit() , the number of shares deposited is calculated using the price from the UniswapV3 pool. The function HyperLiquidrium.currentTick() returns the current price in the UniswapV3 pool instead of a TWAP (time-weighted average price).  Attackers would be able to manipulate the current price in UniswapV3 pool by a flashloan and attack the project.",
                "Repair": "It is recommended to use a TWAP oracle to provide the price for shares calculation in the function HyperLiquidrium.deposit() ."
            }
        ]
    },
    {
        "Code": "function buy ( uint256 maxPrice_ ) external virtual whenNotPaused\nnonReentrant {\nif( endTime [ FEATURE_ENDTIME_BUY ] != 0) {\nrequire ( now256 () < endTime [ FEATURE_ENDTIME_BUY ] , \" sale is\nexpire \") ;\n}\nrequire ( maxPrice_ > 0 , \" invalid max price \") ;\n\ntransferFromHighToken ( _msgSender () , address ( this ) , maxPrice_ );\n\n( uint256 change ) = _buy ( maxPrice_ ) ;\nif( change > 0) {\ntransferHighToken ( _msgSender () , change ) ;\n}\nfunction sell ( uint32 amount_ ) external virtual whenNotPaused\nnonReentrant {\nif( endTime [ FEATURE_ENDTIME_SELL ] != 0) {\nrequire ( now256 () < endTime [ FEATURE_ENDTIME_SELL ], \" sale is\nexpire \") ;\n}\nrequire ( amount_ > 0 , \" Amount must be non - zero .\");\nrequire ( balanceOf ( _msgSender () ) >= amount_ , \" Insufficient tokens\n.\");\n\nuint256 price = _sell ( amount_ );\ntransferHighToken ( _msgSender () , price ) ;\n}\nfunction initialize (\nstring memory _name ,\nstring memory _symbol ,\naddress _high ,\naddress _bondingCurve ,\naddress _productNft ,\nuint32 _reserveRatio ,\nuint32 _maxTokenCount ,\nuint32 _supplyOffset ,\nuint256 _baseReserve ,\nuint256 _endTime\n) public virtual initializer {\nHIGH = _high ;\nProductTokenCore . initialize (\n_name ,\n_symbol ,\n_bondingCurve ,\n_productNft ,\n_reserveRatio ,\n_maxTokenCount ,\n_supplyOffset ,\n_baseReserve\n) ;\nif( _endTime > 0) {\nupdateEndTime ( FEATURE_ENDTIME_MAX , _endTime ) ;\n}\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf  :   PRODUCTTOKENHIGHBASE CONTRACT IS VULNERABLE TO SANDWIC",
                "Location": "function buy ( uint256 maxPrice_ ) external virtual whenNotPaused\nnonReentrant {\nif( endTime [ FEATURE_ENDTIME_BUY ] != 0) {\nrequire ( now256 () < endTime [ FEATURE_ENDTIME_BUY ] , \" sale is\nexpire \") ;\n}\nrequire ( maxPrice_ > 0 , \" invalid max price \") ;\n\ntransferFromHighToken ( _msgSender () , address ( this ) , maxPrice_ );\n\n( uint256 change ) = _buy ( maxPrice_ ) ;\nif( change > 0) {\ntransferHighToken ( _msgSender () , change ) ;\n}\nfunction sell ( uint32 amount_ ) external virtual whenNotPaused\nnonReentrant {\nif( endTime [ FEATURE_ENDTIME_SELL ] != 0) {\nrequire ( now256 () < endTime [ FEATURE_ENDTIME_SELL ], \" sale is\nexpire \") ;\n}\nrequire ( amount_ > 0 , \" Amount must be non - zero .\");\nrequire ( balanceOf ( _msgSender () ) >= amount_ , \" Insufficient tokens\n.\");\n\nuint256 price = _sell ( amount_ );\ntransferHighToken ( _msgSender () , price ) ;\n}\n",
                "Type": "Price oracle manipulation",
                "Description": "ProductTokenHighBase is an ERC20 contract that allows users to buy and sell a product token. The buying and selling price of the token is based on a pricing algorithm called Bonding Curve. This algorithm causes the price of the token to increase with every purchase, meaning that early buyers are rewarded as they can, then, sell the tokens back for a profit. The function sell(uint32 amount_) allows users to sell a product token, returning the equivalent HIGH tokens. The growth of the price with each purchase is determined by the different bonding curve parameters, which are set in the initialize() function of the ProductTokenHighBase contract. As there are no restriction or cooldown period to sell the product token after its purchase, the buy() function calls are vulnerable to a sandwich attack.",
                "Repair": "It is recommended to redesign the application logic to use only one pair contract for each token pair."
            }
        ]
    },
    {
        "Code": "contract Uniswapv2Oracle is IUsdcOracle, AccessControl {\n    /* ==========  Libraries  ========== */\n\n    using Prices for address;\n    using Prices for Prices.PriceObservation;\n    using Prices for Prices.TwoWayAveragePrice;\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n    /* ==========  Constants  ========== */\n\n    // Period over which prices are observed, each period should have 1 price observation.\n    // Minimum time elapsed between price observations\n    uint32 public immutable MINIMUM_OBSERVATION_DELAY;\n\n    address public immutable USDC; // 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public immutable WETH; // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public immutable uniswapFactory; // 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n\n    uint32 public immutable maxObservationAge;\n\n    /* ==========  Storage  ========== */\n\n    uint32 public observationPeriod;\n    // Price observations for tokens indexed by time period.\n    mapping(address => mapping(uint256 => Prices.PriceObservation)) internal priceObservations;\n\n    /* ==========  Events  ========== */\n\n    event PriceUpdated(\n        address indexed token,\n        uint224 tokenPriceCumulativeLast,\n        uint224 ethPriceCumulativeLast\n    );\n\n    /* ==========  Constructor  ========== */\n\n    constructor(address _uniswapFactory, uint32 _initialObservationPeriod, address _usdc, address _weth) {\n        require(_uniswapFactory != address(0), \"ERR_UNISWAPV2_FACTORY_INIT\");\n        require(_weth!= address(0), \"ERR_WETH_INIT\");\n        uniswapFactory = _uniswapFactory;\n        USDC = _usdc;\n        WETH = _weth;\n        observationPeriod = _initialObservationPeriod;\n        MINIMUM_OBSERVATION_DELAY = _initialObservationPeriod / 2;\n        maxObservationAge = _initialObservationPeriod * 2;\n    }\n\n    /* ==========  External Functions  ========== */\n\n    function getLastPriceObservation(address token)\n        external\n        view\n        returns (Prices.PriceObservation memory)\n    {\n        Prices.PriceObservation memory current = Prices.observeTwoWayPrice(\n            uniswapFactory,\n            token,\n            WETH\n        );\n        Prices.PriceObservation memory previous = _getLatestUsableObservation(\n            token,\n            current.timestamp\n        );\n        return previous;\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-Delta-Finance--v5.pdf  :   Funds Can Be Stolen via Multi-Strategy Value Manipulatio https://github.com/Singularity-DAO/dynaset-contracts/blob/master/contracts/oracles/Uniswapv2Oracle.sol#L361",
                "Location": "    // Price observations for tokens indexed by time period.\n    mapping(address => mapping(uint256 => Prices.PriceObservation)) internal priceObservations;\n\n    /* ==========  Events  ========== */\n\n    event PriceUpdated(\n        address indexed token,\n        uint224 tokenPriceCumulativeLast,\n        uint224 ethPriceCumulativeLast\n    );\n\n    function getLastPriceObservation(address token)\n        external\n        view\n        returns (Prices.PriceObservation memory)\n    {\n        Prices.PriceObservation memory current = Prices.observeTwoWayPrice(\n            uniswapFactory,\n            token,\n            WETH\n        );\n        Prices.PriceObservation memory previous = _getLatestUsableObservation(\n            token,\n            current.timestamp\n        );\n        return previous;\n    }",
                "Type": "Price oracle manipulation",
                "Description": "Uniswapv3Oracle and Uniswapv2Oracle contracts use Uniswap router for the prices obtaining. The prices in the Uniswap may be disbalanced using the flashloan, and the price may be manipulated.",
                "Repair": "do not the current price for the price calculation, replace the arithmetic mean with the geometric mean in the Uniswapv2Oracle."
            }
        ]
    },
    {
        "Code": "function getPirce() public view returns (uint256) {\n        (uint256 reserve0, uint256 reserve1, ) = addr.pair.getReserves();\n        if (addr.pair.token0() == address(addr.usdt)) {\n            return (reserve0 * 1e18) / reserve1;\n        } else {\n            return (reserve1 * 1e18) / reserve0;\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "/Secure3/Lymex_final_Secure3_Audit_Report.pdf/Price manipulation risk in\nLymSignPool::getPirce() function",
                "Location": " (reserve0 * 1e18) / reserve1",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation. the getPirce() function only gets the single tick price of that moment, which is very vulnerable to the price\nmanipulation especially for the low liquidity tokens. this can lead to mis-compute power in the registerSignMining() function as registerSignMining -> coutingPower -> getPirce.",
                "Repair": " use more robust algorithms such as time weighted average price (TWAP) to calculate the price."
            }
        ]
    },
    {
        "Code": "no code",
        "VulnerabilityDesc": [
            {
                "Name": "REP-Moma-2021-05-19.pdf  :   Risk of Flash Loan Attack on Price Oracl",
                "Location": "",
                "Type": "Price oracle manipulation",
                "Description": "",
                "Repair": ""
            }
        ]
    }
]