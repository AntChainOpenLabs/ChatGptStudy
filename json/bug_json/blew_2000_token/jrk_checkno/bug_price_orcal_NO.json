[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./curve/ICurve.sol\";\r\nimport \"./BaseStrategy.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * Strategy that handles non-UST tokens, by first converting them to UST via\r\n * Curve (https://curve.fi/), and only then depositing into EthAnchor\r\n */\r\ncontract NonUSTStrategy is BaseStrategy {\r\n using SafeERC20 for IERC20;\r\n\r\n // address of the Curve pool to use\r\n ICurve public curvePool;\r\n\r\n // index of the underlying token in the pool\r\n int128 public underlyingI;\r\n\r\n // index of the UST token in the pool\r\n int128 public ustI;\r\n\r\n constructor(\r\n  address _vault,\r\n  address _treasury,\r\n  address _ethAnchorRouter,\r\n  address _exchangeRateFeeder,\r\n  IERC20 _ustToken,\r\n  IERC20 _aUstToken,\r\n  uint16 _perfFeePct,\r\n  address _owner,\r\n  address _curvePool,\r\n  int128 _underlyingI,\r\n  int128 _ustI\r\n )\r\n  BaseStrategy(\r\n_vault,\r\n_treasury,\r\n_ethAnchorRouter,\r\n_exchangeRateFeeder,\r\n_ustToken,\r\n_aUstToken,\r\n_perfFeePct,\r\n_owner\r\n  )\r\n {\r\n  require(underlying != _ustToken, \"invalid underlying\");\r\n  require(_curvePool != address(0), \"0x addr\");\r\n  curvePool = ICurve(_curvePool);\r\n  underlyingI = _underlyingI;\r\n  ustI = _ustI;\r\n\r\n  ustToken.safeApprove(_curvePool, type(uint256).max);\r\n  underlying.safeApprove(_curvePool, type(uint256).max);\r\n }\r\n\r\n /**\r\n  * Swaps the underlying currency for UST, and initiates a deposit of all\r\n  * the converted UST into EthAnchor\r\n  *\r\n  * @notice since EthAnchor uses an asynchronous model, this function\r\n  * only starts the deposit process, but does not finish it.\r\n  */\r\n function doHardWork() external override(BaseStrategy) restricted {\r\n  _swapUnderlyingToUst();\r\n  _initDepositStable();\r\n }\r\n\r\n /**\r\n  * Calls Curve to convert the existing underlying balance into UST\r\n  */\r\n function _swapUnderlyingToUst() internal {\r\n  uint256 underlyingBalance = _getUnderlyingBalance();\r\n  if (underlyingBalance > 0) {\r\n// slither-disable-next-line unused-return\r\ncurvePool.exchange_underlying(\r\n underlyingI,\r\n ustI,\r\n underlyingBalance,\r\n 0\r\n);\r\n  }\r\n }\r\n\r\n /**\r\n  * Calls Curve to convert the existing UST back into the underlying token\r\n  */\r\n function _swapUstToUnderlying() internal {\r\n  uint256 ustBalance = _getUstBalance();\r\n  if (ustBalance > 0) {\r\n// slither-disable-next-line unused-return\r\ncurvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);\r\n  }\r\n }\r\n\r\n /**\r\n  * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\r\n  * Once UST is retrieved, convert it back to underlying via Curve\r\n  *\r\n  * @notice Must be called some time after `initRedeemStable()`. Will only work if\r\n  * the EthAnchor bridge has finished processing the deposit.\r\n  *\r\n  * @param idx Id of the pending redeem operation\r\n  */\r\n function finishRedeemStable(uint256 idx) public override(BaseStrategy) {\r\n  super.finishRedeemStable(idx);\r\n  _swapUstToUnderlying();\r\n }\r\n\r\n /**\r\n  * Amount, expressed in the underlying currency, currently in the strategy\r\n  *\r\n  * @notice both held and invested amounts are included here, using the\r\n  * latest known exchange rates to the underlying currency\r\n  *\r\n  * @return The total amount of underlying\r\n  */\r\n function investedAssets()\r\n  external\r\n  view\r\n  override(BaseStrategy)\r\n  returns (uint256)\r\n {\r\n  uint256 underlyingBalance = _getUnderlyingBalance();\r\n  uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\r\n\r\n  uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\r\naddress(aUstToken),\r\ntrue\r\n  ) * aUstBalance) / 1e18) + pendingDeposits;\r\n  return\r\nunderlyingBalance +\r\ncurvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\r\n }\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-01-sandclock#h-03-vaults-with-non-ust-underlying-asset-vulnerable-to-flash-loan-attack-on-curve-pool",
                "Location": "curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.In short, the NonUSTStrategy is vulnerable to attacks by flash loans on curve pools. Here\u2019s an outline of the attack: Assume there is a vault with DAI underlying and a NonUSTStrategy with a DAI / UST curve pool Take out a flash loan of DAI Exchange a ton of DAI for UST The exchange rate from DAI to UST has gone up (!!) Withdraw or deposit from vault with more favorable terms than market Transfer back UST to DAI Repay flash loan",
                "Repair": "Use an oracle"
            }
        ]
    },
    {
        "Code": "contract UniswapUtils is IUniswapUtils {\n\n using SafeMath for uint256;\n\n uint24 public constant POOL_FEE = 3000;\n\n uint32 public constant TWAP_PERIOD = 60;\n\n function calculateLimitTicks(\n  IUniswapV3Pool _pool,\n  uint160 _sqrtPriceX96,\n  uint256 _amount0,\n  uint256 _amount1\n ) external override view\n returns (\n  int24 _lowerTick,\n  int24 _upperTick,\n  uint128 _liquidity,\n  uint128 _orderType\n ) {\n\n  int24 tickSpacing = _pool.tickSpacing();\n  (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0();\n\n  int24 _targetTick = TickMath.getTickAtSqrtRatio(_sqrtPriceX96);\n\n  int24 tickFloor = _floor(_targetTick, tickSpacing);\n\n  return _checkLiquidityRange(\ntickFloor - tickSpacing,\ntickFloor,\ntickFloor,\ntickFloor + tickSpacing,\n_amount0,\n_amount1,\nsqrtRatioX96,\ntickSpacing\n  );\n\n }\n\n function quoteKROM(IUniswapV3Factory factory, address WETH, address KROM, uint256 _weiAmount)\n external override view returns (uint256 quote) {\n\n  address _poolAddress = factory.getPool(WETH, KROM, POOL_FEE);\n  require(_poolAddress != address(0), \"UUC_PA\");\n\n  if (_weiAmount > 0) {\n(int24 arithmeticMeanTick,) = OracleLibrary.consult(_poolAddress, TWAP_PERIOD);\nquote = OracleLibrary.getQuoteAtTick(\n arithmeticMeanTick,\n _toUint128(_weiAmount),\n WETH,\n KROM\n);\n  }\n }\n\n function _checkLiquidityRange(int24 _bidLower, int24 _bidUpper,\n  int24 _askLower, int24 _askUpper,\n  uint256 _amount0, uint256 _amount1,\n  uint160 sqrtRatioX96, int24 _tickSpacing) internal pure\n returns (int24 _lowerTick, int24 _upperTick, uint128 _liquidity, uint128 _orderType) {\n\n  _checkRange(_bidLower, _bidUpper, _tickSpacing);\n  _checkRange(_askLower, _askUpper, _tickSpacing);\n\n  uint128 bidLiquidity = _liquidityForAmounts(sqrtRatioX96, _bidLower, _bidUpper, _amount0, _amount1);\n  uint128 askLiquidity = _liquidityForAmounts(sqrtRatioX96, _askLower, _askUpper, _amount0, _amount1);\n\n  require(bidLiquidity > 0 || askLiquidity > 0, \"UUC_BAL\");\n\n  if (bidLiquidity > askLiquidity) {\n(_lowerTick, _upperTick, _liquidity, _orderType) = (_bidLower, _bidUpper, bidLiquidity, uint128(1));\n  } else {\n(_lowerTick, _upperTick, _liquidity, _orderType) = (_askLower, _askUpper, askLiquidity, uint128(2));\n  }\n }\n\n /// @dev Casts uint256 to uint128 with overflow check.\n function _toUint128(uint256 x) internal pure returns (uint128) {\n  require(x <= type(uint128).max, \"UUC_IC\");\n  return uint128(x);\n }\n\n /// @dev Wrapper around `LiquidityAmounts.getLiquidityForAmounts()`.\n function _liquidityForAmounts(\n  uint160 sqrtRatioX96,\n  int24 tickLower,\n  int24 tickUpper,\n  uint256 amount0,\n  uint256 amount1\n ) internal pure returns (uint128) {\n  return\n  LiquidityAmounts.getLiquidityForAmounts(\nsqrtRatioX96,\nTickMath.getSqrtRatioAtTick(tickLower),\nTickMath.getSqrtRatioAtTick(tickUpper),\namount0,\namount1\n  );\n }\n\n /// @dev Wrapper around `LiquidityAmounts.getAmountsForLiquidity()`.\n function _amountsForLiquidity(\n  IUniswapV3Pool pool,\n  int24 tickLower,\n  int24 tickUpper,\n  uint128 liquidity\n ) external override view returns (uint256, uint256) {\n  (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();\n  return\n  LiquidityAmounts.getAmountsForLiquidity(\nsqrtRatioX96,\nTickMath.getSqrtRatioAtTick(tickLower),\nTickMath.getSqrtRatioAtTick(tickUpper),\nliquidity\n  );\n }\n\n function _checkRange(int24 _tickLower, int24 _tickUpper, int24 _tickSpacing) internal pure {\n\n  require(_tickLower < _tickUpper, \"UUC_TLU\");\n  require(_tickLower >= TickMath.MIN_TICK, \"UUC_TLMIN\");\n  require(_tickUpper <= TickMath.MAX_TICK, \"UUC_TAMAX\");\n  require(_tickLower % _tickSpacing == 0, \"UUC_TLS\");\n  require(_tickUpper % _tickSpacing == 0, \"UUC_TUS\");\n }\n\n /// @dev Rounds tick down towards negative infinity so that it's a multiple\n /// of `tickSpacing`.\n function _floor(int24 tick, int24 _tickSpacing) internal pure returns (int24) {\n  int24 compressed = tick / _tickSpacing;\n  if (tick < 0 && tick % _tickSpacing != 0) compressed--;\n  return compressed * _tickSpacing;\n }\n\n receive() external payable {}\n}",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-Kromatika.Finance-v13.pdf  :   Potential Oracle Manipulatio",
                "Location": "    uint32 public constant TWAP_PERIOD = 60;     function quoteKROM(IUniswapV3Factory factory, address WETH, address KROM, uint256 _weiAmount)\n    external override view returns (uint256 quote) {\n\n        address _poolAddress = factory.getPool(WETH, KROM, POOL_FEE);\n        require(_poolAddress != address(0), \"UUC_PA\");\n\n        if (_weiAmount > 0) {\n            (int24 arithmeticMeanTick,) = OracleLibrary.consult(_poolAddress, TWAP_PERIOD);\n            quote = OracleLibrary.getQuoteAtTick(\n                arithmeticMeanTick,\n                _toUint128(_weiAmount),\n                WETH,\n                KROM\n            );\n        }\n    }",
                "Type": "Price oracle manipulation",
                "Description": "In the function quoteKROM() , timeWeightedAverageTick is used to calculate the amount of KROM token received in exchange given a tick and a token amount. However, the timeWeightedAverageTick is fetched using Uniswap V3 oracle given the pool address and the TWAP_PERIOD that is used to calculate the time weighted average. To be noticed, the TWAP_PERIOD is in units of seconds. By the current setting, the TWAP_PERIOD is a constant and it's only 20 seconds, which means the timeWeightedAverageTick is vulnerable to oracle manipulation. The attacker could manipulate the pool for a few seconds to further manipulate the timeWeightedAverageTick since the time weight is relatively focused in a short period of time which makes it be easily manipulated.",
                "Repair": "consider increasing the value of TWAP_PERIOD to increase the quote resilience from potential oracle manipulation"
            }
        ]
    },
    {
        "Code": "contract UniswapUtils is IUniswapUtils {\n\n using SafeMath for uint256;\n\n uint24 public constant POOL_FEE = 3000;\n\n uint32 public constant TWAP_PERIOD = 60;\n\n function calculateLimitTicks(\n  IUniswapV3Pool _pool,\n  uint160 _sqrtPriceX96,\n  uint256 _amount0,\n  uint256 _amount1\n ) external override view\n returns (\n  int24 _lowerTick,\n  int24 _upperTick,\n  uint128 _liquidity,\n  uint128 _orderType\n ) {\n\n  int24 tickSpacing = _pool.tickSpacing();\n  (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0();\n\n  int24 _targetTick = TickMath.getTickAtSqrtRatio(_sqrtPriceX96);\n\n  int24 tickFloor = _floor(_targetTick, tickSpacing);\n\n  return _checkLiquidityRange(\ntickFloor - tickSpacing,\ntickFloor,\ntickFloor,\ntickFloor + tickSpacing,\n_amount0,\n_amount1,\nsqrtRatioX96,\ntickSpacing\n  );\n\n }\n\n function quoteKROM(IUniswapV3Factory factory, address WETH, address KROM, uint256 _weiAmount)\n external override view returns (uint256 quote) {\n\n  address _poolAddress = factory.getPool(WETH, KROM, POOL_FEE);\n  require(_poolAddress != address(0), \"UUC_PA\");\n\n  if (_weiAmount > 0) {\n(int24 arithmeticMeanTick,) = OracleLibrary.consult(_poolAddress, TWAP_PERIOD);\nquote = OracleLibrary.getQuoteAtTick(\n arithmeticMeanTick,\n _toUint128(_weiAmount),\n WETH,\n KROM\n);\n  }\n }\n\n function _checkLiquidityRange(int24 _bidLower, int24 _bidUpper,\n  int24 _askLower, int24 _askUpper,\n  uint256 _amount0, uint256 _amount1,\n  uint160 sqrtRatioX96, int24 _tickSpacing) internal pure\n returns (int24 _lowerTick, int24 _upperTick, uint128 _liquidity, uint128 _orderType) {\n\n  _checkRange(_bidLower, _bidUpper, _tickSpacing);\n  _checkRange(_askLower, _askUpper, _tickSpacing);\n\n  uint128 bidLiquidity = _liquidityForAmounts(sqrtRatioX96, _bidLower, _bidUpper, _amount0, _amount1);\n  uint128 askLiquidity = _liquidityForAmounts(sqrtRatioX96, _askLower, _askUpper, _amount0, _amount1);\n\n  require(bidLiquidity > 0 || askLiquidity > 0, \"UUC_BAL\");\n\n  if (bidLiquidity > askLiquidity) {\n(_lowerTick, _upperTick, _liquidity, _orderType) = (_bidLower, _bidUpper, bidLiquidity, uint128(1));\n  } else {\n(_lowerTick, _upperTick, _liquidity, _orderType) = (_askLower, _askUpper, askLiquidity, uint128(2));\n  }\n }\n\n /// @dev Casts uint256 to uint128 with overflow check.\n function _toUint128(uint256 x) internal pure returns (uint128) {\n  require(x <= type(uint128).max, \"UUC_IC\");\n  return uint128(x);\n }\n\n /// @dev Wrapper around `LiquidityAmounts.getLiquidityForAmounts()`.\n function _liquidityForAmounts(\n  uint160 sqrtRatioX96,\n  int24 tickLower,\n  int24 tickUpper,\n  uint256 amount0,\n  uint256 amount1\n ) internal pure returns (uint128) {\n  return\n  LiquidityAmounts.getLiquidityForAmounts(\nsqrtRatioX96,\nTickMath.getSqrtRatioAtTick(tickLower),\nTickMath.getSqrtRatioAtTick(tickUpper),\namount0,\namount1\n  );\n }\n\n /// @dev Wrapper around `LiquidityAmounts.getAmountsForLiquidity()`.\n function _amountsForLiquidity(\n  IUniswapV3Pool pool,\n  int24 tickLower,\n  int24 tickUpper,\n  uint128 liquidity\n ) external override view returns (uint256, uint256) {\n  (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();\n  return\n  LiquidityAmounts.getAmountsForLiquidity(\nsqrtRatioX96,\nTickMath.getSqrtRatioAtTick(tickLower),\nTickMath.getSqrtRatioAtTick(tickUpper),\nliquidity\n  );\n }\n\n function _checkRange(int24 _tickLower, int24 _tickUpper, int24 _tickSpacing) internal pure {\n\n  require(_tickLower < _tickUpper, \"UUC_TLU\");\n  require(_tickLower >= TickMath.MIN_TICK, \"UUC_TLMIN\");\n  require(_tickUpper <= TickMath.MAX_TICK, \"UUC_TAMAX\");\n  require(_tickLower % _tickSpacing == 0, \"UUC_TLS\");\n  require(_tickUpper % _tickSpacing == 0, \"UUC_TUS\");\n }\n\n /// @dev Rounds tick down towards negative infinity so that it's a multiple\n /// of `tickSpacing`.\n function _floor(int24 tick, int24 _tickSpacing) internal pure returns (int24) {\n  int24 compressed = tick / _tickSpacing;\n  if (tick < 0 && tick % _tickSpacing != 0) compressed--;\n  return compressed * _tickSpacing;\n }\n\n receive() external payable {}\n}",
        "VulnerabilityDesc": [
            {
                "Name": "CertiK-Audit-for-Kromatika.Finance-v13.pdf  :   Potential Price Manipulatio",
                "Location": "    function calculateLimitTicks(\n        IUniswapV3Pool _pool,\n        uint160 _sqrtPriceX96,\n        uint256 _amount0,\n        uint256 _amount1\n    ) external override view\n    returns (\n        int24 _lowerTick,\n        int24 _upperTick,\n        uint128 _liquidity,\n        uint128 _orderType\n    ) {\n\n        int24 tickSpacing = _pool.tickSpacing();\n        (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0();\n\n        int24 _targetTick = TickMath.getTickAtSqrtRatio(_sqrtPriceX96);\n\n        int24 tickFloor = _floor(_targetTick, tickSpacing);\n\n        return _checkLiquidityRange(\n            tickFloor - tickSpacing,\n            tickFloor,\n            tickFloor,\n            tickFloor + tickSpacing,\n            _amount0,\n            _amount1,\n            sqrtRatioX96,\n            tickSpacing\n        );\n\n    }     function calculateLimitTicks(\n        IUniswapV3Pool _pool,\n        uint160 _sqrtPriceX96,\n        uint256 _amount0,\n        uint256 _amount1\n    ) external override view\n    returns (\n        int24 _lowerTick,\n        int24 _upperTick,\n        uint128 _liquidity,\n        uint128 _orderType\n    ) {\n\n        int24 tickSpacing = _pool.tickSpacing();\n        (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0();\n\n        int24 _targetTick = TickMath.getTickAtSqrtRatio(_sqrtPriceX96);\n\n        int24 tickFloor = _floor(_targetTick, tickSpacing);\n\n        return _checkLiquidityRange(\n            tickFloor - tickSpacing,\n            tickFloor,\n            tickFloor,\n            tickFloor + tickSpacing,\n            _amount0,\n            _amount1,\n            sqrtRatioX96,\n            tickSpacing\n        );\n\n    }",
                "Type": "Price oracle manipulation",
                "Description": "n the function calculateLimitTicks() , Uniswap V3 pool's spot price is used to calculate the liquidity range. (uint160 sqrtRatioX96,, , , , , ) = _pool.slot0(); The spot price of Uniswap V3 pools can be manipulated by flash loan attacks to generate a liquidity range that favors the attacker. In the function _amountsForLiquidity() , Uniswap V3 pool's spot price is also used to compute the token0 and token1 value for a given amount of liquidity. (uint160 sqrtRatioX96, , , , , , ) = pool.slot0(); The spot price of Uniswap V3 pools can be manipulated by flash loan attacks to generate token values that favor the attacker.",
                "Repair": "Considering using time weighted average price to reduce the effects from the pool price manipulation."
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iPOOL.sol\";\nimport \"./interfaces/iSYNTH.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iRESERVE.sol\";\nimport \"./interfaces/iSYNTHFACTORY.sol\";\nimport \"./interfaces/iPOOLFACTORY.sol\";\ncontract SynthVault {\n address public BASE;\n address public DEPLOYER;\n uint256 public minimumDepositTime; \n uint256 public totalWeight;  \n uint256 public erasToEarn;\n uint256 public vaultClaim;\n address [] public stakedSynthAssets; \n uint private lastMonth; \n uint public genesis; \n uint256 public map30DVaultRevenue;\n uint256 public mapPast30DVaultRevenue; \n uint256 [] public revenueArray; \n modifier onlyDAO() {\n  require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\n  _;\n }\n constructor(address _base) {\n  BASE = _base;\n  DEPLOYER = msg.sender;\n  erasToEarn = 30;\n  minimumDepositTime = 3600; \n  vaultClaim = 1000;\n  genesis = block.timestamp;\n  lastMonth = 0;\n }\n function _DAO() internal view returns(iDAO) {\n  return iBASE(BASE).DAO();\n }\n mapping(address => mapping(address => uint256)) private mapMemberSynth_weight;\n mapping(address => uint256) private mapMemberTotal_weight;\n mapping(address => mapping(address => uint256)) private mapMemberSynth_deposit;\n mapping(address => mapping(address => uint256)) private mapMemberSynth_lastTime;\n mapping(address => uint256) private mapMember_depositTime;\n mapping(address => uint256) public lastBlock;\n mapping(address => bool) private isStakedSynth;\n mapping(address => mapping(address => bool)) private isSynthMember;\n event MemberDeposits(\n  address indexed synth,\n  address indexed member,\n  uint256 newDeposit,\n  uint256 weight,\n  uint256 totalWeight\n );\n event MemberWithdraws(\n  address indexed synth,\n  address indexed member,\n  uint256 amount,\n  uint256 weight,\n  uint256 totalWeight\n );\n event MemberHarvests(\n  address indexed synth,\n  address indexed member,\n  uint256 amount,\n  uint256 weight,\n  uint256 totalWeight\n );\n function deposit(address synth, uint256 amount) external {\n  depositForMember(synth, msg.sender, amount);\n }\n function depositForMember(address synth, address member, uint256 amount) public {\n  require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), \"!synth\"); // Must be a valid synth\n  require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in\n  _deposit(synth, member, amount); // Assess and record the deposit\n }\n\n function _deposit(address _synth, address _member, uint256 _amount) internal {\n  if(!isStakedSynth[_synth]){\nisStakedSynth[_synth] = true; // Record as a staked synth\nstakedSynthAssets.push(_synth); // Add to staked synth array\n  }\n  mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth)\n  mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member)\n  mapMemberSynth_deposit[_member][_synth] += _amount; // Record balance for member\n  uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); // Get the SPARTA weight of the deposit\n  mapMemberSynth_weight[_member][_synth] += _weight; // Add the weight to the user (scope: member -> synth)\n  mapMemberTotal_weight[_member] += _weight; // Add to the user's total weight (scope: member)\n  totalWeight += _weight; // Add to the total weight (scope: vault)\n  isSynthMember[_member][_synth] = true; // Record user as a member\n  emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);\n }\n function harvestAll() external returns (bool) {\n  for(uint i = 0; i < stakedSynthAssets.length; i++){\nif((block.timestamp > mapMemberSynth_lastTime[msg.sender][stakedSynthAssets[i]])){\n uint256 reward = calcCurrentReward(stakedSynthAssets[i], msg.sender);\n if(reward > 0){\n  harvestSingle(stakedSynthAssets[i]);\n }\n}\n\n  }\n  return true;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-07-spartan#h-06-synthvault-rewards-can-be-gamed",
                "Location": "SynthVault._deposit",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The SynthVault._deposit function adds weight for the user that depends on the spot value of the deposit synth amount in BASE. This spot price can be manipulated and the cost of manipulation is relative to the pool\u2019s liquidity. However, the reward (see calcReward) is measured in BASE tokens unrelated to the pool. Therefore, if the pool\u2019s liquidity is low and the reward reserve is high, the attack can be profitable: Manipulate the pool spot price of the iSYNTH(_synth).LayerONE() pool by dripping a lot of BASE into it repeatedly (sending lots of smaller trades is less costly due to the path-independence of the continuous liquidity model). This increases the BASE per token price. Call SynthVault.depositForMember and deposit a small amount of synth token. The iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount) will return an inflated weight due to the price. Optionally drip more BASE into the pool and repeat the deposits Drip back token to the pool to rebalance it The user\u2019s weight is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool\u2019s liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.",
                "Repair": "Recommend tracking a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit."
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.3;\ncontract Pool is iBEP20 {  \n address public BASE;\n address public TOKEN;\n address public DEPLOYER;\n string _name; string _symbol;\n uint8 public override decimals; uint256 public override totalSupply;\n mapping(address => uint) private _balances;\n mapping(address => mapping(address => uint)) private _allowances;\n uint256 public baseAmount; \n uint256 public tokenAmount; \n uint private lastMonth; \n uint public genesis; \n uint256 public map30DPoolRevenue;\n uint256 public mapPast30DPoolRevenue;\n uint256 [] public revenueArray; \n function _DAO() internal view returns(iDAO) {\n  return iBASE(BASE).DAO();\n }\n\n constructor (address _base, address _token) {\n  BASE = _base;\n  TOKEN = _token;\n  string memory poolName = \"-SpartanProtocolPool\";\n  string memory poolSymbol = \"-SPP\";\n  _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n  _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n  decimals = 18;\n  genesis = block.timestamp;\n  DEPLOYER = msg.sender;\n  lastMonth = 0;\n function addForMember(address member) public returns(uint liquidityUnits){\n  uint256 _actualInputBase = _getAddedBaseAmount();\n  uint256 _actualInputToken = _getAddedTokenAmount(); \n  if(baseAmount == 0 || tokenAmount == 0){\n  require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n  }\n  liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\n  _incrementPoolBalances(_actualInputBase, _actualInputToken); \n  _mint(member, liquidityUnits); // Mint the LP tokens directly to the user\n  emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n  return liquidityUnits;\n }\n function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n  require((token == BASE || token == TOKEN), \"!BASE||TOKEN\")\n  address _fromToken; uint _amount;\n  if(token == BASE){\n_fromToken = TOKEN; \n_amount = _getAddedTokenAmount(); \n(outputAmount, fee) = _swapTokenToBase(_amount);\n  } else {\n_fromToken = BASE; \n_amount = _getAddedBaseAmount(); \n(outputAmount, fee) = _swapBaseToToken(_amount); \n  }\n  emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n  iBEP20(token).transfer(member, outputAmount); \n  return (outputAmount, fee);\n }\n\n\n function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n  require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); \n  uint256 _actualInputBase = _getAddedBaseAmount(); \n  uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount);\n  uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); \n  _incrementPoolBalances(_actualInputBase, 0);\n  uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); \n  fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee);\n  _mint(synthOut, _liquidityUnits); \n  iSYNTH(synthOut).mintSynth(member, output); \n  _addPoolMetrics(fee); \n  emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\nreturn (output, fee);\n }\n \n function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n  require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); \n  uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); \n  uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); \n  fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount);\n  iBEP20(synthIN).transfer(synthIN, _actualInputSynth); \n  iSYNTH(synthIN).burnSynth(); \n  _decrementPoolBalances(outputBase, 0); \n  iBEP20(BASE).transfer(member, outputBase); \n  _addPoolMetrics(fee);\n  emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\nreturn (outputBase, fee);\n }\n function _getAddedBaseAmount() internal view returns(uint256 _actual){\n  uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n  if(_baseBalance > baseAmount){\n_actual = _baseBalance-(baseAmount);\n  } else {\n_actual = 0;\n  }\n  return _actual;\n }\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-07-spartan#h-07-missing-slippage-checks",
                "Location": "Missing slippage checks",
                "Type": "Price oracle manipulation",
                "Description": "Sandwich attack.There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.",
                "Repair": "Recommend adding a minimum amount out parameter. The function reverts if the minimum amount isn\u2019t obtained."
            }
        ]
    },
    {
        "Code": "pragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\nlibrary AssetHandler {\n using SafeMath for uint256;\n using SafeInt256 for int256;\n using CashGroup for CashGroupParameters;\n using AssetRate for AssetRateParameters;\n\n function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\n  return\nassetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\nassetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\n }\n function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\n  require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX);\n\n  if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\n\n  uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\n\n  return asset.maturity.sub(marketLength).add(Constants.QUARTER);\n }\n function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\n  internal\n  pure\n  returns (int256 assetCash, int256 fCash)\n {\n  require(isLiquidityToken(token.assetType) && token.notional >= 0); \n\n  assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\n  fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\n }\n function getHaircutCashClaims(\n  PortfolioAsset memory token,\n  MarketParameters memory market,\n  CashGroupParameters memory cashGroup\n ) internal pure returns (int256, int256) {\n  require(isLiquidityToken(token.assetType) && token.notional >= 0);\n\n  require(token.currencyId == cashGroup.currencyId); \n\n  int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));\n\n  int256 assetCash =\n_calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);\n\n  int256 fCash =\n_calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);\n\n  return (assetCash, fCash);\n }\n function getLiquidityTokenValue(\n  uint256 index,\n  CashGroupParameters memory cashGroup,\n  MarketParameters memory market,\n  PortfolioAsset[] memory assets,\n  uint256 blockTime,\n  bool riskAdjusted\n ) internal view returns (int256, int256) {\n  PortfolioAsset memory liquidityToken = assets[index];\n  require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); \n\n  {\n(uint256 marketIndex, bool idiosyncratic) =\n DateTime.getMarketIndex(\n  cashGroup.maxMarketIndex,\n  liquidityToken.maturity,\n  blockTime\n );\nrequire(!idiosyncratic);\n\n  \ncashGroup.loadMarket(market, marketIndex, true, blockTime);\n  }\n\n  int256 assetCashClaim;\n  int256 fCashClaim;\n  if (riskAdjusted) {\n(assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);\n  } else {\n(assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);\n  }\n  if (\nindex > 0 &&\nassets[index - 1].currencyId == liquidityToken.currencyId &&\nassets[index - 1].maturity == liquidityToken.maturity &&\nassets[index - 1].assetType == Constants.FCASH_ASSET_TYPE\n  ) {\nassets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);\nreturn (assetCashClaim, 0);\n  }\n\n\n  if (riskAdjusted) {\nint256 pv =\n getRiskAdjustedPresentValue(\n  cashGroup,\n  fCashClaim,\n  liquidityToken.maturity,\n  blockTime,\n  market.oracleRate\n );\n\nreturn (assetCashClaim, pv);\n  } else {\nint256 pv =\n getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);\n\nreturn (assetCashClaim, pv);\n  }\n }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-08-notional#h-10-liquidity-token-value-can-be-manipulated",
                "Location": "// @audit token.notional are the LP tokens to redeem\r\nassetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\r\nfCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);",
                "Type": "Price oracle manipulation",
                "Description": "AMM price oracle manipulation.The liquidity token value (AssetHandler.getLiquidityTokenValue) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see AssetHandler.getCashClaims / AssetHandler.getHaircutCashClaims.This means the value depends on the current market reserves which can be manipulated. You\u2019re essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.",
                "Repair": "Recommend not using the current market reserves to determine the value of LP tokens. Also, think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables."
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.9;\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n using SafeERC20 for IERC20;\n ILPWrapper public wrapper;\n ISynthFactory public synthFactory;\n bool public queueActive;\n constructor(bool _queueActive, IERC20 _nativeAsset)\n  BasePoolV2(_nativeAsset)\n {\n  queueActive = _queueActive;\n }\n function cumulativePrices(IERC20 foreignAsset)\n  public\n  view\n  returns (\nuint256 price0CumulativeLast,\nuint256 price1CumulativeLast,\nuint32 blockTimestampLast\n  )\n {\n  PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n.priceCumulative;\n  price0CumulativeLast = priceCumulative.nativeLast;\n  price1CumulativeLast = priceCumulative.foreignLast;\n  blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n }\n function initialize(\n  ILPWrapper _wrapper,\n  ISynthFactory _synthFactory,\n  address _router\n ) external onlyOwner {\n  require(\nwrapper == ILPWrapper(_ZERO_ADDRESS),\n\"VaderPoolV2::initialize: Already initialized\"\n  );\n  require(\n_wrapper != ILPWrapper(_ZERO_ADDRESS),\n\"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n  );\n  require(\n_synthFactory != ISynthFactory(_ZERO_ADDRESS),\n\"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n  );\n  require(\n_router != _ZERO_ADDRESS,\n\"VaderPoolV2::initialize: Incorrect Router Specified\"\n  );\n  wrapper = _wrapper;\n  synthFactory = _synthFactory;\n  router = _router;\n }\n function mintSynth(\n  IERC20 foreignAsset,\n  uint256 nativeDeposit,\n  address from,\n  address to\n )\n  external\n  override\n  nonReentrant\n  supportedToken(foreignAsset)\n  returns (uint256 amountSynth)\n {\n  nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n  ISynth synth = synthFactory.synths(foreignAsset);\n\n  if (synth == ISynth(_ZERO_ADDRESS))\nsynth = synthFactory.createSynth(\n IERC20Extended(address(foreignAsset))\n);\n\n  (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\nforeignAsset\n  ); \n  amountSynth = VaderMath.calculateSwap(\nnativeDeposit,\nreserveNative,\nreserveForeign\n  );\n  _update(\nforeignAsset,\nreserveNative + nativeDeposit,\nreserveForeign,\nreserveNative,\nreserveForeign\n  );\n  synth.mint(to, amountSynth);\n }\n function burnSynth(\n  IERC20 foreignAsset,\n  uint256 synthAmount,\n  address to\n ) external override nonReentrant returns (uint256 amountNative) {\n  ISynth synth = synthFactory.synths(foreignAsset);\n\n  require(\nsynth != ISynth(_ZERO_ADDRESS),\n\"VaderPoolV2::burnSynth: Inexistent Synth\"\n  );\n\n  require(\nsynthAmount > 0,\n\"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n  );\n\n  IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n  synth.burn(synthAmount);\n\n  (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\nforeignAsset\n  ); \n\n  amountNative = VaderMath.calculateSwap(\nsynthAmount,\nreserveForeign,\nreserveNative\n  );\n\n \n  _update(\nforeignAsset,\nreserveNative - amountNative,\nreserveForeign,\nreserveNative,\nreserveForeign\n  );\n\n  nativeAsset.safeTransfer(to, amountNative);\n }\n\n function _min(uint256 a, uint256 b) private pure returns (uint256) {\n  return a < b ? a : b;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-11-vader#h-22-mintsynth-and-burnsynth-can-be-front-run",
                "Location": "mintSynth function , burnSynth function",
                "Type": "Price oracle manipulation",
                "Description": "Sandwich attack.Given that mintSynth() and burnSynth() will issue and redeem assets based on the price of the pool (reserves), and they will create price impact based on the volume being minted and burnt. However, the current implementation provides no parameter for slippage control, making them vulnerable to front-run attacks. Especially for transactions with rather large volumes.",
                "Repair": "Consider adding a minAmountOut parameter."
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.9;\ncontract VaderRouterV2 is IVaderRouterV2, ProtocolConstants, Ownable {\n using SafeERC20 for IERC20;\n IVaderPoolV2 public immutable pool;\n IERC20 public immutable nativeAsset;\n IVaderReserve public reserve;\n constructor(IVaderPoolV2 _pool) {\n  require(\n_pool != IVaderPoolV2(_ZERO_ADDRESS),\n\"VaderRouterV2::constructor: Incorrect Arguments\"\n  );\n\n  pool = _pool;\n  nativeAsset = pool.nativeAsset();\n }\n function addLiquidity(\n  IERC20 tokenA,\n  IERC20 tokenB,\n  uint256 amountADesired,\n  uint256 amountBDesired,\n  uint256, // amountAMin = unused\n  uint256, // amountBMin = unused\n  address to,\n  uint256 deadline\n ) external override returns (uint256 liquidity) {\n  return\naddLiquidity(\n tokenA,\n tokenB,\n amountADesired,\n amountBDesired,\n to,\n deadline\n);\n }\n function addLiquidity(\n  IERC20 tokenA,\n  IERC20 tokenB,\n  uint256 amountADesired,\n  uint256 amountBDesired,\n  address to,\n  uint256 deadline\n ) public override ensure(deadline) returns (uint256 liquidity) {\n  IERC20 foreignAsset;\n  uint256 nativeDeposit;\n  uint256 foreignDeposit;\n\n  if (tokenA == nativeAsset) {\nrequire(\n pool.supported(tokenB),\n \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\n);\nforeignAsset = tokenB;\nforeignDeposit = amountBDesired;\nnativeDeposit = amountADesired;\n  } else {\nrequire(\n tokenB == nativeAsset && pool.supported(tokenA),\n \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\n);\nforeignAsset = tokenA;\nforeignDeposit = amountADesired;\nnativeDeposit = amountBDesired;\n  }\n\n  liquidity = pool.mint(\nforeignAsset,\nnativeDeposit,\nforeignDeposit,\nmsg.sender,\nto\n  );\n }\n function _swap(\n  uint256 amountIn,\n  IERC20[] calldata path,\n  address to\n ) private returns (uint256 amountOut) {\n  if (path.length == 3) {\nrequire(\n path[0] != path[1] &&\n  path[1] == pool.nativeAsset() &&\n  path[2] != path[1],\n \"VaderRouterV2::_swap: Incorrect Path\"\n);\n\npath[0].safeTransferFrom(msg.sender, address(pool), amountIn);\n\nreturn pool.doubleSwap(path[0], path[2], amountIn, to);\n  } else {\nrequire(\n path.length == 2,\n \"VaderRouterV2::_swap: Incorrect Path Length\"\n);\nIERC20 _nativeAsset = nativeAsset;\nrequire(path[0] != path[1], \"VaderRouterV2::_swap: Incorrect Path\");\n\npath[0].safeTransferFrom(msg.sender, address(pool), amountIn);\nif (path[0] == _nativeAsset) {\n return pool.swap(path[1], amountIn, 0, to);\n} else {\n require(\n  path[1] == _nativeAsset,\n  \"VaderRouterV2::_swap: Incorrect Path\"\n );\n return pool.swap(path[0], 0, amountIn, to);\n}\n  }\n }\n modifier ensure(uint256 deadline) {\n  require(deadline >= block.timestamp, \"VaderRouterV2::ensure: Expired\");\n  _;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-11-vader#h-31-unused-slippage-params",
                "Location": "function addLiquidity(\r\n        IERC20 tokenA,\r\n        IERC20 tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256, // amountAMin = unused\r\n        uint256, // amountBMin = unused\r\n        address to,\r\n        uint256 deadline\r\n    )",
                "Type": "Price oracle manipulation",
                "Description": "Sandwich attack.Unused slippage params. function addLiquidity in VaderRouter (both V1 and V2) do not use slippage parameters: uint256, // amountAMin = unused uint256, // amountBMin = unused,making it susceptible to sandwich attacks / MEV.",
                "Repair": "Consider paying some attention to the slippage to reduce possible manipulation attacks from mempool snipers."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.17;\ncontract Pair is ERC20, ERC721TokenReceiver {\n using SafeTransferLib for address;\n using SafeTransferLib for ERC20;\n\n uint256 public constant ONE = 1e18;\n uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n address public immutable nft;\n address public immutable baseToken; // address(0) for ETH\n bytes32 public immutable merkleRoot;\n LpToken public immutable lpToken;\n Caviar public immutable caviar;\n uint256 public closeTimestamp;\n\n event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n event Buy(uint256 inputAmount, uint256 outputAmount);\n event Sell(uint256 inputAmount, uint256 outputAmount);\n event Wrap(uint256[] tokenIds);\n event Unwrap(uint256[] tokenIds);\n event Close(uint256 closeTimestamp);\n event Withdraw(uint256 tokenId);\n\n constructor(\n  address _nft,\n  address _baseToken,\n  bytes32 _merkleRoot,\n  string memory pairSymbol,\n  string memory nftName,\n  string memory nftSymbol\n ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n  nft = _nft;\n  baseToken = _baseToken;\n  merkleRoot = _merkleRoot;\n  lpToken = new LpToken(pairSymbol);\n  caviar = Caviar(msg.sender);\n }\n function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n  public\n  payable\n  returns (uint256 lpTokenAmount)\n {\n  require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n  require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n  lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n  require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n  _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n  lpToken.mint(msg.sender, lpTokenAmount);\n  if (baseToken != address(0)) {\nERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n  }\n  emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n }\n function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n  require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n  inputAmount = buyQuote(outputAmount);\n  require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n  _transferFrom(address(this), msg.sender, outputAmount);\n  if (baseToken == address(0)) {\nuint256 refundAmount = maxInputAmount - inputAmount;\nif (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n  } else {\nERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n  }\n  emit Buy(inputAmount, outputAmount);\n }\n function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)\n  public\n  returns (uint256 outputAmount)\n {\n  uint256 inputAmount = wrap(tokenIds, proofs);\n  outputAmount = sell(inputAmount, minOutputAmount);\n }\n function baseTokenReserves() public view returns (uint256) {\n  return _baseTokenReserves();\n }\n\n function fractionalTokenReserves() public view returns (uint256) {\n  return balanceOf[address(this)];\n }\n\n function buyQuote(uint256 outputAmount) public view returns (uint256) {\n  return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);\n }\n\n\n function sellQuote(uint256 inputAmount) public view returns (uint256) {\n  uint256 inputAmountWithFee = inputAmount * 997;\n  return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n }\n\n function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n  uint256 lpTokenSupply = lpToken.totalSupply();\n  if (lpTokenSupply > 0) {\nuint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\nuint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\nreturn Math.min(baseTokenShare, fractionalTokenShare);\n  } else {\nreturn Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n  }\n }\n function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {\n  uint256 lpTokenSupply = lpToken.totalSupply();\n  uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply;\n  uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;\n\n  return (baseTokenOutputAmount, fractionalTokenOutputAmount);\n }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-12-caviar#h-02-liquidity-providers-may-lose-funds-when-adding-liquidity",
                "Location": "// calculate amount of lp tokens as a fraction of existing reserves\r\nuint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\r\nuint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\r\nreturn Math.min(baseTokenShare, fractionalTokenShare);",
                "Type": "Price oracle manipulation",
                "Description": "Sandwich attack.Liquidity providers may lose a portion of provided liquidity in either of the pair tokens. While the minLpTokenAmount protects from slippage when adding liquidity, it doesn\u2019t protect from providing liquidity at different K.",
                "Repair": "In the add function, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router"
            }
        ]
    }
]