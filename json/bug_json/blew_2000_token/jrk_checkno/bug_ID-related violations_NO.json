[
    {
        "Code": "contract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n  IERC20 public immutable COMP;\n    Comptroller public immutable COMPTROLLER;\n    WETH9 public immutable WETH;\n     function _checkValidCurrency(uint16 currencyId) internal view {\n        require(0 < currencyId && currencyId <= maxCurrencyId, \"Invalid currency id\");\n    }\n\n    constructor(Comptroller _comptroller, WETH9 _weth) {\n        COMPTROLLER = _comptroller;\n        COMP = IERC20(_comptroller.getCompAddress());\n        WETH = _weth;\n    }\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        (int256 reserveBalance) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n        require(newBalance < reserveBalance, \"cannot increase reserve balance\");\n\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n    function claimCOMPAndTransfer(address[] calldata cTokens)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 balanceBefore = COMP.balanceOf(address(this));\n        COMPTROLLER.claimComp(address(this), cTokens);\n        uint256 balanceAfter = COMP.balanceOf(address(this));\n        uint256 amountClaimed = balanceAfter.sub(balanceBefore);\n        COMP.safeTransfer(treasuryManagerContract, amountClaimed);\n        return amountClaimed;\n    }\n    function _redeemAndTransfer(\n        uint16 currencyId,\n        Token memory asset,\n        int256 assetInternalRedeemAmount\n    ) private returns (uint256) {\n        Token memory underlying = TokenHandler.getUnderlyingToken(currencyId);\n        int256 assetExternalRedeemAmount = asset.convertToExternal(assetInternalRedeemAmount);\n        uint256 redeemedExternalUnderlying = asset\n            .redeem(underlying, assetExternalRedeemAmount.toUint())\n            .toUint();\n        if (underlying.tokenAddress == address(0)) {\n            WETH9(WETH).deposit{value: address(this).balance}();\n        }\n\n        address underlyingAddress = underlying.tokenAddress == address(0)\n            ? address(WETH)\n            : underlying.tokenAddress;\n        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);\n\n        return redeemedExternalUnderlying;\n    }\n    function transferReserveToTreasury(uint16[] calldata currencies)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; i++) {\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n            if (bufferInternal == 0) continue;\n            (int256 reserveInternal, , , ) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n\n            if (reserveInternal <= bufferInternal) continue;\n\n            Token memory asset = TokenHandler.getAssetToken(currencyId);\n\n            int256 assetInternalRedeemAmount = reserveInternal.subNoNeg(bufferInternal);\n\n            amountsTransferred[i] = _redeemAndTransfer(\n                currencyId,\n                asset,\n                assetInternalRedeemAmount\n            );\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                assetInternalRedeemAmount\n            );\n        }\n        return amountsTransferred;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-01-notional#h-01-treasury-cannot-claim-comp-tokens--comp-tokens-are-stuck",
                "Location": "claimCOMPAndTransfer function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Treasury cannot claim COMP tokens & COMP tokens are stuck,The TreasuryAction.claimCOMPAndTransfer function uses pre- and post-balances of the COMP token to check which ones to transfer.Note that anyone can claim COMP tokens on behalf of any address (see Comptroller.claimComp). An attacker can claim COMP tokens on behalf of the contract and it\u2019ll never be able to claim any compound itself. The COMP claimed by the attacker are stuck in the contract and cannot be retrieved. (One can eventually get back the stuck COMP by creating a cCOMP market and then transferring it through transferReserveToTreasury.)",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n\n    EnumerableSetUpgradeable.UintSet private positionIndexes;\n\n    mapping(uint256 => Position) private positions;\n    mapping(uint256 => address) public positionOwner;\n    mapping(bytes32 => uint256) public nftTypeValueETH;\n    mapping(uint256 => uint256) public nftValueETH;\n\n    mapping(uint256 => bytes32) public nftTypes;\n    mapping(uint256 => uint256) public pendingNFTValueETH;\n\n\n    modifier validNFTIndex(uint256 nftIndex) {\n\n        require(nftContract.ownerOf(nftIndex) != address(0), \"invalid_nft\");\n        _;\n    }\n\n    struct NFTCategoryInitializer {\n        bytes32 hash;\n        uint256 valueETH;\n        uint256[] nfts;\n    }\n    function initialize(\n        IStableCoin _stablecoin,\n        IERC721Upgradeable _nftContract,\n        IAggregatorV3Interface _ethAggregator,\n        IAggregatorV3Interface _jpegAggregator,\n        IAggregatorV3Interface _floorOracle,\n        IAggregatorV3Interface _fallbackOracle,\n        NFTCategoryInitializer[] memory _typeInitializers,\n        IJPEGLock _jpegLocker,\n        VaultSettings memory _settings\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DAO_ROLE, msg.sender);\n        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        _validateRate(_settings.debtInterestApr);\n        _validateRate(_settings.creditLimitRate);\n        _validateRate(_settings.liquidationLimitRate);\n        _validateRate(_settings.valueIncreaseLockRate);\n        _validateRate(_settings.organizationFeeRate);\n        _validateRate(_settings.insurancePurchaseRate);\n        _validateRate(_settings.insuranceLiquidationPenaltyRate);\n\n        _validateCreditLimitAndLiquidationRate(\n            _settings.creditLimitRate,\n            _settings.liquidationLimitRate\n        );\n\n        stablecoin = _stablecoin;\n        jpegLocker = _jpegLocker;\n        ethAggregator = _ethAggregator;\n        jpegAggregator = _jpegAggregator;\n        floorOracle = _floorOracle;\n        fallbackOracle = _fallbackOracle;\n        nftContract = _nftContract;\n\n        settings = _settings;\n\n        //initializing the categories\n        for (uint256 i = 0; i < _typeInitializers.length; i++) {\n            NFTCategoryInitializer memory initializer = _typeInitializers[i];\n            nftTypeValueETH[initializer.hash] = initializer.valueETH;\n            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n                nftTypes[initializer.nfts[j]] = initializer.hash;\n            }\n        }\n    }\n\n    function toggleFallbackOracle(bool _useFallback)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        useFallbackOracle = _useFallback;\n    }\n\n    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {\n        jpegLocker.setLockTime(_newLockTime);\n    }\n\n\n    function finalizePendingNFTValueETH(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        uint256 pendingValue = pendingNFTValueETH[_nftIndex];\n        require(pendingValue > 0, \"no_pending_value\");\n        uint256 toLockJpeg = (((pendingValue *\n            _ethPriceUSD() *\n            settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator) *\n            settings.valueIncreaseLockRate.numerator) /\n            settings.valueIncreaseLockRate.denominator /\n            _jpegPriceUSD();\n\n        //lock JPEG using JPEGLock\n        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);\n\n        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;\n        nftValueETH[_nftIndex] = pendingValue;\n        //clear pending value\n        pendingNFTValueETH[_nftIndex] = 0;\n    }\n\n\n    uint256[50] private __gap;\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-04-jpegd#h-02-existing-users-locked-jpeg-could-be-overwritten-by-new-user-causing-permanent-loss-of-jpeg-funds",
                "Location": "jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg); in finalizePendingNFTValueETH function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Existing user\u2019s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds,A user\u2019s JPEG lock schedule can be overwritten by another user\u2019s if he (the other user) submits and finalizes a proposal to change the same NFT index\u2019s value.The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n\n  mapping(uint256 => int256) internal _processedTokenTrackerOf;\n\n\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\ninternal _packedDistributionLimitDataOf;\n\n\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\ninternal _packedOverflowAllowanceDataOf;\n\n \n  IJBProjects public immutable override projects;\n\n \n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n\n  IJBTokenStore public immutable override tokenStore;\n\n \n  IJBSplitsStore public immutable override splitsStore;\n\n  IJBDirectory public immutable override directory;\n\n\n  function launchProjectFor(\naddress _owner,\nJBProjectMetadata calldata _projectMetadata,\nJBFundingCycleData calldata _data,\nJBFundingCycleMetadata calldata _metadata,\nuint256 _mustStartAtOrAfter,\nJBGroupedSplits[] calldata _groupedSplits,\nJBFundAccessConstraints[] calldata _fundAccessConstraints,\nIJBPaymentTerminal[] memory _terminals,\nstring memory _memo\n  ) external virtual override returns (uint256 projectId) {\n// Mint the project into the wallet of the message sender.\nprojectId = projects.createFor(_owner, _projectMetadata);\n\n// Set this contract as the project\"s controller in the directory.\ndirectory.setControllerOf(projectId, address(this));\n\n// Configure the first funding cycle.\nuint256 _configuration = _configure(\n  projectId,\n  _data,\n  _metadata,\n  _mustStartAtOrAfter,\n  _groupedSplits,\n  _fundAccessConstraints\n);\n\n// Add the provided terminals to the list of terminals.\nif (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);\n\nemit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  function launchFundingCyclesFor(\nuint256 _projectId,\nJBFundingCycleData calldata _data,\nJBFundingCycleMetadata calldata _metadata,\nuint256 _mustStartAtOrAfter,\nJBGroupedSplits[] calldata _groupedSplits,\nJBFundAccessConstraints[] memory _fundAccessConstraints,\nIJBPaymentTerminal[] memory _terminals,\nstring memory _memo\n  )\nexternal\nvirtual\noverride\nrequirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\nreturns (uint256 configuration)\n  {\n// If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\nif (fundingCycleStore.latestConfigurationOf(_projectId) > 0)\n  revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n// Set this contract as the project\"s controller in the directory.\ndirectory.setControllerOf(_projectId, address(this));\n\n// Configure the first funding cycle.\nconfiguration = _configure(\n  _projectId,\n  _data,\n  _metadata,\n  _mustStartAtOrAfter,\n  _groupedSplits,\n  _fundAccessConstraints\n);\n\n// Add the provided terminals to the list of terminals.\nif (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);\n\nemit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n\n  function reconfigureFundingCyclesOf(\nuint256 _projectId,\nJBFundingCycleData calldata _data,\nJBFundingCycleMetadata calldata _metadata,\nuint256 _mustStartAtOrAfter,\nJBGroupedSplits[] calldata _groupedSplits,\nJBFundAccessConstraints[] calldata _fundAccessConstraints,\nstring calldata _memo\n  )\nexternal\nvirtual\noverride\nrequirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\nreturns (uint256 configuration)\n  {\n// Configure the next funding cycle.\nconfiguration = _configure(\n  _projectId,\n  _data,\n  _metadata,\n  _mustStartAtOrAfter,\n  _groupedSplits,\n  _fundAccessConstraints\n);\n\nemit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  function issueTokenFor(\nuint256 _projectId,\nstring calldata _name,\nstring calldata _symbol\n  )\nexternal\nvirtual\noverride\nrequirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\nreturns (IJBToken token)\n  {\n// Issue the token in the store.\nreturn tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n\n\n  function changeTokenOf(\nuint256 _projectId,\nIJBToken _token,\naddress _newOwner\n  )\nexternal\nvirtual\noverride\nrequirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n// Get a reference to the project\"s current funding cycle.\nJBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n// The current funding cycle must not be paused.\nif (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n\n// Change the token in the store.\ntokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-07-juicebox#h-02-token-change-can-be-frontrun-blocking-token",
                "Location": "tokenStore.changeFor(_projectId, _token, _newOwner); in changeTokenOf function",
                "Type": "ID-related violations",
                "Description": "Shared resource (e.g., token) without proper locks.Token Change Can Be Frontrun, Blocking Token,This vulnerability allows malicious actors to block other users from changing tokens of their projects. Furthermore if ownership over the token contract is transferred to the JBTokenStore contract prior to the change, as suggested in the recourse section of Juicebox\u2019s 24.05.2022 post-mortem update, this vulnerability would allow an attacker to become the owner of tokens being transferred. For JBToken based tokens this would allow an attacker to begin issuing arbitrary amounts the token that was meant to be transferred.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "     function split(\n  SplitStruct memory _splitStruct\n     )\n  public\n  nonReentrant\n  returns (uint256 amountOutToken1, uint256 amountOutToken2)\n     {\n  address _token = _splitStruct.token;\n  uint256 _amount = _splitStruct.amount;\n  address _firstToken = _splitStruct.firstToken;\n  address _secondToken = _splitStruct.secondToken;\n  uint256 _amountOutMinFirst = _splitStruct.amountOutMinFirst;\n  uint256 _amountOutMinSecond = _splitStruct.amountOutMinSecond;\n \n  IUniswapV2Router02 routerIn = getRouterOneToken(_token);\n  IUniswapV2Router02 routerOutFirstToken = getRouterOneToken(_firstToken);\n  IUniswapV2Router02 routerOutSecondToken = getRouterOneToken(_secondToken);\n \n  uint256[] memory amountsOut;\n  if(_token != FTM && (routerIn != routerOutFirstToken || routerIn != routerOutSecondToken)) {\n      IERC20(_token).safeApprove(address(routerIn), _amount);\n \n      address[] memory path = new address[](2);\n      path[0] = _token;\n      path[1] = FTM;\n \n      amountsOut = routerIn.swapExactTokensForTokens(\n   _amount,\n   0,\n   path,\n   address(this),\n   block.timestamp\n      );\n \n      _amount = amountsOut[amountsOut.length - 1];\n      _token = FTM;\n  }\n \n  uint256 _firstTokenAmount = mulScale(\n      _amount,\n      _splitStruct.percentageFirstToken,\n      10000\n  ); // Amount of first token.\n  uint256 _secondTokenAmount = _amount - _firstTokenAmount; // Amount of second token.\n \n  if(routerOutFirstToken == routerOutSecondToken && address(routerOutFirstToken) != address(0) && address(routerOutSecondToken) != address(0)) {\n      IERC20(_token).safeApprove(address(routerOutFirstToken), _amount);\n  } else {\n      if(address(routerOutFirstToken) != address(0)) {\n   IERC20(_token).safeApprove(address(routerOutFirstToken), _firstTokenAmount);\n      }\n      if(address(routerOutSecondToken) != address(0)) {\n   IERC20(_token).safeApprove(address(routerOutSecondToken), _secondTokenAmount);\n      }\n  }\n  \n  uint256 _amountOutToken1;\n  uint256 _amountOutToken2;\n  if (_token == FTM) {\n      (_amountOutToken1, _amountOutToken2) = _splitFromFTM(\n   _firstToken,\n   _secondToken,\n   _firstTokenAmount,\n   _secondTokenAmount,\n   _amountOutMinFirst,\n   _amountOutMinSecond\n      );\n  } else if (_firstToken == FTM || _secondToken == FTM) {\n      (_amountOutToken1, _amountOutToken2) = _splitToFTM(\n   _token,\n   _firstToken,\n   _secondToken,\n   _firstTokenAmount,\n   _secondTokenAmount,\n   _amountOutMinFirst,\n   _amountOutMinSecond\n      );\n  } else {\n      if (_firstToken != _token) {\n   address[] memory pathFirstToken = new address[](3);\n   pathFirstToken[0] = _token;\n   pathFirstToken[1] = FTM;\n   pathFirstToken[2] = _firstToken;\n \n   amountsOut = routerOutFirstToken.swapExactTokensForTokens(\n_firstTokenAmount,\n_amountOutMinFirst,\npathFirstToken,\naddress(msg.sender),\nblock.timestamp\n   );\n \n   _amountOutToken1 = amountsOut[amountsOut.length - 1];\n      } else {\n   _amountOutToken1 = _firstTokenAmount;\n   IERC20(_firstToken).safeTransfer(msg.sender, _firstTokenAmount);\n      }\n \n      if (_secondToken != _token) {\n   address[] memory pathSecondToken = new address[](3);\n   pathSecondToken[0] = _token;\n   pathSecondToken[1] = FTM;\n   pathSecondToken[2] = _secondToken;\n \n   amountsOut = routerOutSecondToken.swapExactTokensForTokens(\n_secondTokenAmount,\n_amountOutMinSecond,\npathSecondToken,\naddress(msg.sender),\nblock.timestamp\n   );\n \n   _amountOutToken2 = amountsOut[amountsOut.length - 1];\n      } else {\n   _amountOutToken2 = _secondTokenAmount;\n   IERC20(_secondToken).safeTransfer(msg.sender, _secondTokenAmount);\n      }\n  }\n \n  return (_amountOutToken1, _amountOutToken2);\n     }\n ",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-TortleNinja-v1.0/3.2 Missed Access Control in Nodes_::split()",
                "Location": "split function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.The Nodes_ contract provides a routine (i.e. split() ) to divide one token into two tokens according to the selected percentage. Before calling this routine, the user has to send the token to this contract. However there\u2019s a lack of proper access control validation at the beginning of this routine, which results in potential assets loss in this contract if user doesn\u2019t transfer in enough tokens first. Although currently this contract is not designed to store user assets, which greatly alleviates this concern, it\u2019s still suggested to add proper access control to the split() routine. Per our further study in the protocol, we can only allow the Nodes contract to call this routine.",
                "Repair": "Add proper access control to the above routines"
            }
        ]
    },
    {
        "Code": "contract Nodes_ is ReentrancyGuard {\n using SafeERC20 for IERC20;\n \n address public immutable owner;\n address private immutable FTM;\n address[] public routers;\n uint256 public constant minimumAmount = 1000;\n \n struct SplitStruct {\n address token;\n uint256 amount;\n address firstToken;\n address secondToken;\n uint256 percentageFirstToken;\n uint256 amountOutMinFirst;\n uint256 amountOutMinSecond;\n }\n \n constructor(address _owner, address[] memory _routers) {\n owner = _owner;\n routers = _routers;\n FTM = IUniswapV2Router02(_routers[0]).WETH();\n }\n \n \n function mulScale(\n uint256 x,\n uint256 y,\n uint128 scale\n ) internal pure returns (uint256) {\n uint256 a = x / scale;\n uint256 b = x % scale;\n uint256 c = y / scale;\n uint256 d = y % scale;\n \n return a * c * scale + a * d + b * c + (b * d) / scale;\n }\n\n function swapTokens(\n address _tokenIn,\n uint256 _amount,\n address _tokenOut,\n uint256 _amountOutMin\n ) public nonReentrant returns (uint256 amountOut) {\n IUniswapV2Router02 routerIn = getRouterOneToken(_tokenIn);\n IUniswapV2Router02 routerOut = getRouterOneToken(_tokenOut);\n \n uint256[] memory amountsOut;\n if(_tokenIn != FTM && routerIn != routerOut) {\n IERC20(_tokenIn).safeApprove(address(routerIn), _amount);\n \n address[] memory path = new address[](2);\n path[0] = _tokenIn;\n path[1] = FTM;\n \n amountsOut = routerIn.swapExactTokensForTokens(\n _amount,\n _amountOutMin,\n path,\n address(this),\n block.timestamp\n );\n \n _amount = amountsOut[amountsOut.length - 1];\n _tokenIn = FTM;\n }\n \n IERC20(_tokenIn).safeApprove(address(routerOut), _amount);\n \n uint256 _amountOut;\n if(_tokenIn != _tokenOut) {\n if (_tokenIn == FTM || _tokenOut == FTM) {\n address[] memory path = new address[](2);\n path[0] = _tokenIn;\n path[1] = _tokenOut;\n \n amountsOut = routerOut.swapExactTokensForTokens(\n _amount,\n _amountOutMin,\n path,\n address(msg.sender),\n block.timestamp\n );\n \n _amountOut = amountsOut[amountsOut.length - 1];\n } else {\n address[] memory path = new address[](3);\n path[0] = _tokenIn;\n path[1] = FTM;\n path[2] = _tokenOut;\n \n amountsOut = routerOut.swapExactTokensForTokens(\n _amount,\n _amountOutMin,\n path,\n address(msg.sender),\n block.timestamp\n );\n \n _amountOut = amountsOut[amountsOut.length - 1];\n }\n } else {\n _amountOut = _amount;\n }\n \n return _amountOut;\n }\n \n function getRouter(address _token0, address _token1) public view returns(IUniswapV2Router02 router) {\n address pairToken0;\n address pairToken1;\n for(uint8 i = 0; i < routers.length; i++) {\n if(_token0 == FTM || _token1 == FTM){\n router = IUniswapV2Router02(routers[i]);\n break;\n } else {\n pairToken0 = IUniswapV2Factory(IUniswapV2Router02(routers[i]).factory()).getPair(_token0, FTM);\n if(pairToken0 != address(0)) {\n pairToken1 = IUniswapV2Factory(IUniswapV2Router02(routers[i]).factory()).getPair(_token1, FTM);\n }\n }\n if(pairToken1 != address(0)) {\n router = IUniswapV2Router02(routers[i]);\n }\n }\n \n require(address(router) != address(0), \"Pair doesn't exists.\");\n }\n \n function getRouterOneToken(address _token) public view returns(IUniswapV2Router02 router) {\n address pair;\n for(uint8 i = 0; i < routers.length; i++) {\n if(_token == FTM){\n router = IUniswapV2Router02(routers[i]);\n break;\n } else {\n pair = IUniswapV2Factory(IUniswapV2Router02(routers[i]).factory()).getPair(_token, FTM);\n }\n if(pair != address(0)) {\n router = IUniswapV2Router02(routers[i]);\n }\n }\n \n require(address(router) != address(0), \"Pair doesn't exists.\");\n }\n \n receive() external payable {}\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-TortleNinja-v1.0/3.2 Missed Access Control in Nodes_::swapTokens()",
                "Location": "swapTokens function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.The Nodes_ contract provides a routine (i.e. split() ) to divide one token into two tokens according to the selected percentage. Before calling this routine, the user has to send the token to this contract. However there\u2019s a lack of proper access control validation at the beginning of this routine, which results in potential assets loss in this contract if user doesn\u2019t transfer in enough tokens first. Although currently this contract is not designed to store user assets, which greatly alleviates this concern, it\u2019s still suggested to add proper access control to the split() routine. Per our further study in the protocol, we can only allow the Nodes contract to call this routine.",
                "Repair": "Add proper access control to the above routines"
            }
        ]
    },
    {
        "Code": "contract Zap is AccessControlDefended {\n\nstruct Pool {\nIERC20 lpToken;\nICurveFi deposit;\nISett sett;\n}\nPool[4] public pools;\n\nfunction mint(IERC20 token, uint amount, uint poolId, uint idx, uint minOut)\nexternal\ndefend\nblockLocked\nreturns(uint _ibbtc)\n{\nPool memory pool = pools[poolId];\n\ntoken.safeTransferFrom(msg.sender, address(this), amount);\n\nif (poolId < 3) { // setts\n_addLiquidity(pool.deposit, amount, poolId + 2, idx); // pools are such that the #tokens they support is +2 from their poolId.\npool.sett.deposit(pool.lpToken.balanceOf(address(this)));\n_ibbtc = settPeak.mint(poolId, pool.sett.balanceOf(address(this)), new bytes32[](0));\n} else if (poolId == 3) { // byvwbtc\nIbyvWbtc(address(pool.sett)).deposit(new bytes32[](0)); // pulls all available\n_ibbtc = byvWbtcPeak.mint(pool.sett.balanceOf(address(this)), new bytes32[](0));\n} else {\nrevert(\"INVALID_POOL_ID\");\n}\n\nrequire(_ibbtc >= minOut, \"INSUFFICIENT_IBBTC\"); // used for capping slippage in curve pools\nIERC20(address(ibbtc)).safeTransfer(msg.sender, _ibbtc);\n}\n\nfunction _addLiquidity(ICurveFi pool, uint amount, uint numTokens, uint idx) internal {\nif (numTokens == 2) {\nuint[2] memory amounts;\namounts[idx] = amount;\npool.add_liquidity(amounts, 0);\n}\n\nif (numTokens == 3) {\nuint[3] memory amounts;\namounts[idx] = amount;\npool.add_liquidity(amounts, 0);\n}\n\nif (numTokens == 4) {\nuint[4] memory amounts;\namounts[idx] = amount;\npool.add_liquidity(amounts, 0);\n}\n}\n\nfunction calcMint(address token, uint amount) external view returns(uint poolId, uint idx, uint bBTC, uint fee) {\nif (token == address(ren)) {\nreturn calcMintWithRen(amount);\n}\nif (token == address(wbtc)) {\nreturn calcMintWithWbtc(amount);\n}\nrevert(\"INVALID_TOKEN\");\n}\n\nfunction calcMintWithRen(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {\nuint _ibbtc;\nuint _fee;\n\n// poolId=0, idx=0\n(bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([amount,0], true));\n\n(_ibbtc, _fee) = curveLPToIbbtc(1, pools[1].deposit.calc_token_amount([amount,0,0], true));\nif (_ibbtc > bBTC) {\nbBTC = _ibbtc;\nfee = _fee;\npoolId = 1;\n// idx=0\n}\n\n(_ibbtc, _fee) = curveLPToIbbtc(2, pools[2].deposit.calc_token_amount([0,amount,0,0], true));\nif (_ibbtc > bBTC) {\nbBTC = _ibbtc;\nfee = _fee;\npoolId = 2;\nidx = 1;\n}\n}\n\nfunction calcMintWithWbtc(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {\nuint _ibbtc;\nuint _fee;\n\n// poolId=0\n(bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([0,amount], true));\nidx = 1;\n\n(_ibbtc, _fee) = curveLPToIbbtc(1, pools[1].deposit.calc_token_amount([0,amount,0], true));\nif (_ibbtc > bBTC) {\nbBTC = _ibbtc;\nfee = _fee;\npoolId = 1;\n// idx=1\n}\n\n(_ibbtc, _fee) = curveLPToIbbtc(2, pools[2].deposit.calc_token_amount([0,0,amount,0], true));\nif (_ibbtc > bBTC) {\nbBTC = _ibbtc;\nfee = _fee;\npoolId = 2;\nidx = 2;\n}\n\n// for byvwbtc, sett.pricePerShare returns a wbtc value, as opposed to lpToken amount in setts\n(_ibbtc, _fee) = byvWbtcPeak.calcMint(amount.mul(1e8).div(IbyvWbtc(address(pools[3].sett)).pricePerShare()));\nif (_ibbtc > bBTC) {\nbBTC = _ibbtc;\nfee = _fee;\npoolId = 3;\n// idx value will be ignored anyway\n}\n}\nfunction curveLPToIbbtc(uint poolId, uint _lp) public view returns(uint bBTC, uint fee) {\nPool memory pool = pools[poolId];\nuint _sett = _lp.mul(1e18).div(pool.sett.getPricePerFullShare());\nreturn settPeak.calcMint(poolId, _sett);\n}\n}\n\ninterface ICurveFi {\nfunction add_liquidity(uint[2] calldata amounts, uint min_mint_amount) external;\nfunction calc_token_amount(uint[2] calldata amounts, bool isDeposit) external view returns(uint);\n\nfunction add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;\nfunction calc_token_amount(uint[3] calldata amounts, bool isDeposit) external view returns(uint);\n\nfunction add_liquidity(uint[4] calldata amounts, uint min_mint_amount) external;\nfunction calc_token_amount(uint[4] calldata amounts, bool isDeposit) external view returns(uint);\n}\n\ninterface IyvWbtc {\nfunction deposit(uint) external;\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/Quantstamp/badger-ib-btc.pdf/QSP-6 Lack of validation for arbitrary input token may lead to stolen token credit",
                "Location": "safeTransferFrom function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Currently in Zap, the method does not check for whether the input token are the desired wBTC or renBTC addresses. Therefore, given that the only check for token is in the form of safeTransferFrom a specified amount, it is possible to set token to some arbitrary worthless token address to steal any underlying wBTC or renBTC on the Zap contract",
                "Repair": "Validate that the input token is either in the expected renBTC or wBTC address"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.10;\n\n\ncontract WorldFootball is Context, IERC20 { \n using SafeMath for uint256;\n using Address for address;\n\n address private _owner;\n\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n function owner() public view virtual returns (address) {\n  return _owner;\n }\n\n modifier onlyOwner() {\n  require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n  _;\n }\n\n function renounceOwnership() public virtual {\n  emit OwnershipTransferred(_owner, address(0));\n  _owner = address(0);\n }\n\n mapping (address => uint256) private _tOwned;\n mapping (address => mapping (address => uint256)) private _allowances;\n mapping (address => bool) public _isExcludedFromFee; \n\n address payable public Wallet_Game = payable(0x8a4fA360a46B9467f6b0decE101bBf9a99405C9C); \n address payable public Wallet_Dev = payable(0x15805a0F423c87Cc2293b4c5a3129a1A2F2E6118);\n address payable public constant Wallet_Burn = payable(0x000000000000000000000000000000000000dEaD); \n\n\n uint256 private constant MAX = ~uint256(0);\n uint8 private constant _decimals = 9;\n uint256 private _tTotal = 10**11 * 10**_decimals;\n string private constant _name = \"World Football\"; \n string private constant _symbol = unicode\"WOFO\"; \n\n uint8 private txCount = 0;\n uint8 private swapTrigger = 10; \n\n uint256 public _Tax_On_Buy = 12;\n uint256 public _Tax_On_Sell = 12;\n\n uint256 public Percent_Game = 50;\n uint256 public Percent_Dev = 30;\n uint256 public Percent_Burn = 0;\n uint256 public Percent_AutoLP = 20; \n  \n IUniswapV2Router02 public uniswapV2Router;\n address public uniswapV2Pair;\n bool public inSwapAndLiquify;\n bool public swapAndLiquifyEnabled = true;\n \n event SwapAndLiquifyEnabledUpdated(bool true_or_false);\n event SwapAndLiquify(\n  uint256 tokensSwapped,\n  uint256 ethReceived,\n  uint256 tokensIntoLiqudity\n  \n );\n \n modifier lockTheSwap {\n  inSwapAndLiquify = true;\n  _;\n  inSwapAndLiquify = false;\n }\n \n constructor () {\n\n  _owner = _msgSender();\n  emit OwnershipTransferred(address(0), _owner);\n\n  _tOwned[owner()] = _tTotal;\n  \n  IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); \n  //IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); // Testnet\n  \n  uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n.createPair(address(this), _uniswapV2Router.WETH());\n  uniswapV2Router = _uniswapV2Router;\n\n  _isExcludedFromFee[owner()] = true;\n  _isExcludedFromFee[address(this)] = true;\n  _isExcludedFromFee[Wallet_Game] = true; \n  _isExcludedFromFee[Wallet_Burn] = true;\n\n  emit Transfer(address(0), owner(), _tTotal);\n\n }\n\n function name() public pure returns (string memory) {\n  return _name;\n }\n\n  function swapTokensForBNB(uint256 tokenAmount) private {\n\n  address[] memory path = new address[](2);\n  path[0] = address(this);\n  path[1] = uniswapV2Router.WETH();\n  _approve(address(this), address(uniswapV2Router), tokenAmount);\n  uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\ntokenAmount,\n0, \npath,\naddress(this),\nblock.timestamp\n  );\n }\n\n\n function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\n\n  _approve(address(this), address(uniswapV2Router), tokenAmount);\n  uniswapV2Router.addLiquidityETH{value: BNBAmount}(\naddress(this),\ntokenAmount,\n0, \n0,\nWallet_Burn, \nblock.timestamp\n  );\n } \n\n\n function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee, bool isBuy) private {\n  \n  \n  if(!takeFee){\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tAmount;\nemit Transfer(sender, recipient, tAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tAmount;\n\n} else if (isBuy){\n\nuint256 buyFEE = tAmount*_Tax_On_Buy/100;\nuint256 tTransferAmount = tAmount-buyFEE;\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n_tOwned[address(this)] = _tOwned[address(this)]+buyFEE;\nemit Transfer(sender, recipient, tTransferAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tTransferAmount;\n\n} else {\n\nuint256 sellFEE = tAmount*_Tax_On_Sell/100;\nuint256 tTransferAmount = tAmount-sellFEE;\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n_tOwned[address(this)] = _tOwned[address(this)]+sellFEE;\nemit Transfer(sender, recipient, tTransferAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tTransferAmount;\n\n\n}\n\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "certik/CertiK-Audit-for-World-Football-v2.pdf/Lack of Access Control",
                "Location": "renounceOwnership function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.The function renounceOwnership() is public and can be called by anyone to renounce ownership",
                "Repair": "We advise the client to set up access controls over the functions so only authorized users can call the function"
            }
        ]
    },
    {
        "Code": "constructor(address _WaToken, address _Token, address _governance) public {\n  require(_governance != ZERO_ADDRESS, \"TransmuterD8: 0 gov\");\n  governance = _governance;\n  WaToken = _WaToken;\n  Token = _Token;\n  TRANSMUTATION_PERIOD = 50;\n }\n\n\n function dividendsOwing(address account) public view returns (uint256) {\n  uint256 newDividendPoints = totalDividendPoints.sub(lastDividendPoints[account]);\n  return depositedWaTokens[account].mul(newDividendPoints).div(pointMultiplier);\n }\n\n modifier updateAccount(address account) {\n  uint256 owing = dividendsOwing(account);\n  if (owing > 0) {\nunclaimedDividends = unclaimedDividends.sub(owing);\ntokensInBucket[account] = tokensInBucket[account].add(owing);\n  }\n  lastDividendPoints[account] = totalDividendPoints;\n  _;\n }\n modifier checkIfNewUser() {\n  if (!userIsKnown[msg.sender]) {\nuserList[nextUser] = msg.sender;\nuserIsKnown[msg.sender] = true;\nnextUser++;\n  }\n  _;\n }\n\n modifier runPhasedDistribution() {\n  uint256 _lastDepositBlock = lastDepositBlock;\n  uint256 _currentBlock = block.number;\n  uint256 _toDistribute = 0;\n  uint256 _buffer = buffer;\n\n  if (_buffer > 0) {\n \nuint256 deltaTime = _currentBlock.sub(_lastDepositBlock);\n\nif(deltaTime >= TRANSMUTATION_PERIOD) {\n _toDistribute = _buffer;\n} else {\n\n if(_buffer.mul(deltaTime) > TRANSMUTATION_PERIOD)\n {\n  _toDistribute = _buffer.mul(deltaTime).div(TRANSMUTATION_PERIOD);\n }\n}\n\nif(_toDistribute > 0){\n\n buffer = _buffer.sub(_toDistribute);\n\n increaseAllocations(_toDistribute);\n}\n  }\n\n  lastDepositBlock = _currentBlock;\n  _;\n }\n modifier onlyWhitelisted() {\n  require(whiteList[msg.sender], \"TransmuterD8: !whitelisted\");\n  _;\n }\n modifier onlyGov() {\n  require(msg.sender == governance, \"TransmuterD8: !governance\");\n  _;\n }\n\n function distribute(address origin, uint256 amount) public onlyWhitelisted() runPhasedDistribution() {\n  IERC20Burnable(Token).safeTransferFrom(origin, address(this), amount);\n  buffer = buffer.add(amount);\n }\n function increaseAllocations(uint256 amount) internal {\n  if(totalSupplyWaTokens > 0 && amount > 0) {\ntotalDividendPoints = totalDividendPoints.add(\n amount.mul(pointMultiplier).div(totalSupplyWaTokens)\n);\nunclaimedDividends = unclaimedDividends.add(amount);\n  } else {\nbuffer = buffer.add(amount);\n  }\n }\n function userInfo(address user)\n  public\n  view\n  returns (\nuint256 depositedAl,\nuint256 pendingdivs,\nuint256 inbucket,\nuint256 realised\n  )\n {\n  uint256 _depositedAl = depositedWaTokens[user];\n  uint256 _toDistribute = buffer.mul(block.number.sub(lastDepositBlock)).div(TRANSMUTATION_PERIOD);\n  if(block.number.sub(lastDepositBlock) > TRANSMUTATION_PERIOD){\n_toDistribute = buffer;\n  }\n  uint256 _pendingdivs = _toDistribute.mul(depositedWaTokens[user]).div(totalSupplyWaTokens);\n  uint256 _inbucket = tokensInBucket[user].add(dividendsOwing(user));\n  uint256 _realised = realisedTokens[user];\n  return (_depositedAl, _pendingdivs, _inbucket, _realised);\n }\n function getMultipleUserInfo(uint256 from, uint256 to)\n  public\n  view\n  returns (address[] memory theUserList, uint256[] memory theUserData)\n {\n  uint256 i = from;\n  uint256 delta = to - from;\n  address[] memory _theUserList = new address[](delta); //user\n  uint256[] memory _theUserData = new uint256[](delta * 2); //deposited-bucket\n  uint256 y = 0;\n  uint256 _toDistribute = buffer.mul(block.number.sub(lastDepositBlock)).div(TRANSMUTATION_PERIOD);\n  if(block.number.sub(lastDepositBlock) > TRANSMUTATION_PERIOD){\n_toDistribute = buffer;\n  }\n  for (uint256 x = 0; x < delta; x += 1) {\n_theUserList[x] = userList[i];\n_theUserData[y] = depositedWaTokens[userList[i]];\n_theUserData[y + 1] = dividendsOwing(userList[i]).add(tokensInBucket[userList[i]]).add(_toDistribute.mul(depositedWaTokens[userList[i]]).div(totalSupplyWaTokens));\ny += 2;\ni += 1;\n  }\n  return (_theUserList, _theUserData);\n }\n function bufferInfo() public view returns (uint256 _toDistribute, uint256 _deltaBlocks, uint256 _buffer){\n  _deltaBlocks = block.number.sub(lastDepositBlock);\n  _buffer = buffer; \n  _toDistribute = _buffer.mul(_deltaBlocks).div(TRANSMUTATION_PERIOD);\n ",
        "VulnerabilityDesc": [
            {
                "Name": "certik/REP-Wasabix-yum-2021-07-05.pdf/Minimize The Scope of Access To The Function",
                "Location": "distribute function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.As the comment indicates in LXX This function is meant to be called by the Alchemist contract for when it is sending the yield to the transmuter. , the function distribute() should only be called by Alchemist contract. However, currently a whitelist is adopted to restrict the accesses to the distribute() function, which may have the potential to add non-Alchemist address into it.",
                "Repair": "We advise the client to stored the Alchemist contract addresses in immutable variables and initialized them in the constructor of e.g the TransmuterD8 contract."
            }
        ]
    },
    {
        "Code": "function setAUTO(IERC777 AUTO) external {\n  require(!_AUTOSet, \"SM: AUTO already set\");\n  _AUTOSet = true;\n  _AUTO = AUTO;\n }\n\n\n function getOracle() external view override returns (IOracle) {\n  return _oracle;\n }\n\n function getAUTOAddr() external view override returns (address) {\n  return address(_AUTO);\n }\n\n function getTotalStaked() external view override returns (uint) {\n  return _totalStaked;\n }\n\n function getStake(address staker) external view override returns (uint) {\n  return _stakerToStakedAmount[staker];\n }\n\n function getStakes() external view override returns (address[] memory) {\n  return _stakes;\n }\n\n function getStakesLength() external view override returns (uint) {\n  return _stakes.length;\n }\n\n function getStakesSlice(uint startIdx, uint endIdx) external view override returns (address[] memory) {\n  address[] memory slice = new address[](endIdx - startIdx);\n  uint sliceIdx = 0;\n  for (uint stakeIdx = startIdx; stakeIdx < endIdx; stakeIdx++) {\nslice[sliceIdx] = _stakes[stakeIdx];\nsliceIdx++;\n  }\n\n  return slice;\n }\n\n function getCurEpoch() public view override returns (uint96) {\n  return uint96((block.number / BLOCKS_IN_EPOCH) * BLOCKS_IN_EPOCH);\n }\n\n function getExecutor() external view override returns (Executor memory) {\n  return _executor;\n }\n\n function isCurExec(address addr) external view override returns (bool) {\n  Executor memory ex = _executor;\n  if (ex.forEpoch == getCurEpoch()) {\nif (ex.addr == addr) {\n return true;\n} else {\n return false;\n}\n  }\n  if (_stakes.length == 0) { return true; }\n\n  return false;\n }\n\n function getUpdatedExecRes() public view override returns (uint96 epoch, uint randNum, uint idxOfExecutor, address exec) {\n  epoch = getCurEpoch();\n  address[] memory stakes = _stakes;\n  if (_executor.forEpoch != epoch && stakes.length > 0) {\nrandNum = _oracle.getRandNum(epoch - 1);\nidxOfExecutor = randNum % stakes.length;\nexec = stakes[idxOfExecutor];\n  }\n }\n\n function updateExecutor() external override nonReentrant noFish returns (uint, uint, uint, address) {\n  return _updateExecutor();\n }\n\n function isUpdatedExec(address addr) external override nonReentrant noFish returns (bool) {\n  Executor memory ex = _executor;\n  if (ex.forEpoch == getCurEpoch()) {\nif (ex.addr == addr) {\n return true;\n} else {\n return false;\n}\n  } else {\n(, , , address exec) = _updateExecutor();\nif (exec == addr) { return true; }\n  }\n  if (_stakes.length == 0) { return true; }\n\n  return false;\n }\n\n function stake(uint numStakes) external nzUint(numStakes) nonReentrant updateExec noFish override {\n  uint amount = numStakes * STAN_STAKE;\n  _stakerToStakedAmount[msg.sender] += amount;\n  IERC777 AUTO = _AUTO;\n\n  uint balBefore = AUTO.balanceOf(address(this));\n  AUTO.operatorSend(msg.sender, address(this), amount, \"\", _stakingIndicator);\n  require(AUTO.balanceOf(address(this)) - balBefore == amount, \"SM: transfer bal check failed\");\n\n  for (uint i; i < numStakes; i++) {\n_stakes.push(msg.sender);\n  }\n\n  _totalStaked += amount;\n  emit Staked(msg.sender, amount);\n }\n\n function unstake(uint[] calldata idxs) external nzUintArr(idxs) nonReentrant updateExec noFish override {\n  uint amount = idxs.length * STAN_STAKE;\n  require(amount <= _stakerToStakedAmount[msg.sender], \"SM: not enough stake, peasant\");\n\n  for (uint i = 0; i < idxs.length; i++) {\nrequire(_stakes[idxs[i]] == msg.sender, \"SM: idx is not you\");\nrequire(idxs[i] < _stakes.length, \"SM: idx out of bounds\");\n_stakes[idxs[i]] = _stakes[_stakes.length-1];\n_stakes.pop();\n  }\n  \n  _stakerToStakedAmount[msg.sender] -= amount;\n  _AUTO.send(msg.sender, amount, _stakingIndicator);\n  _totalStaked -= amount;\n  emit Unstaked(msg.sender, amount);\n }\n\n function _updateExecutor() private returns (uint96 epoch, uint randNum, uint idxOfExecutor, address exec) {\n  (epoch, randNum, idxOfExecutor, exec) = getUpdatedExecRes();\n  if (exec != _ADDR_0) {\n_executor = Executor(exec, epoch);\n  }\n }\n\n modifier updateExec() {\n  _updateExecutor();\n  _;\n }\n\n modifier noFish() {\n  _;\n  require(_AUTO.balanceOf(address(this)) >= _totalStaked, \"SM: something fishy here\");\n }\n\n function tokensReceived(\n  address _operator,\n  address _from,\n  address _to,\n  uint256 _amount,\n  bytes calldata _data,\n  bytes calldata _operatorData\n ) external override {\n  require(msg.sender == address(_AUTO), \"SM: non-AUTO token\");\n  require(keccak256(_operatorData) == keccak256(_stakingIndicator), \"SM: sending by mistake\");\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-Autonomy-Network.pdf/Lack Of Access Control",
                "Location": "function setAUTO(IERC777 AUTO) external {\n        require(!_AUTOSet, \"SM: AUTO already set\");\n        _AUTOSet = true;\n        _AUTO = AUTO;\n    }",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The external facing function setAUTO() allows anyone to update the significant state _AUTO as long as\nnobody has executed setAUTO() . This is potentially risky because an attacker is possible to execute setAUTO() before anyone by front-running.",
                "Repair": "We advise the client to add neccessary access control for setAUTO() function and ensure the AUTO token\nis correctly set.\n"
            }
        ]
    },
    {
        "Code": " function owner() public view virtual returns (address) {\n  return _owner;\n }\n\n modifier onlyOwner() {\n  require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n  _;\n }\n\n function renounceOwnership() public virtual {\n  emit OwnershipTransferred(_owner, address(0));\n  _owner = address(0);\n }\n\n\n function _transfer(\n  address from,\n  address to,\n  uint256 amount\n ) private {\n  require(from != address(0) && to != address(0), \"ERR: Using 0 address!\");\n  require(amount > 0, \"Token value must be higher than zero.\");\n\n  if(\ntxCount >= swapTrigger && \n!inSwapAndLiquify &&\nfrom != uniswapV2Pair &&\nswapAndLiquifyEnabled \n)\n  {  \n\nuint256 contractTokenBalance = balanceOf(address(this));\ntxCount = 0;\nswapAndLiquify(contractTokenBalance);\n  }\n  \n  bool takeFee = true;\n  bool isBuy;\n  if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\ntakeFee = false;\n  } else {\n\nif(from == uniswapV2Pair){\n isBuy = true;\n}\n\ntxCount++;\n\n  }\n\n  _tokenTransfer(from, to, amount, takeFee, isBuy);\n\n }\n \n function sendToWallet(address payable wallet, uint256 amount) private {\nwallet.transfer(amount);\n\n  }\n\n\n function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n\nuint256 tokens_to_Burn = contractTokenBalance * Percent_Burn / 100;\n_tTotal = _tTotal - tokens_to_Burn;\n_tOwned[Wallet_Burn] = _tOwned[Wallet_Burn] + tokens_to_Burn;\n_tOwned[address(this)] = _tOwned[address(this)] - tokens_to_Burn; \n\nuint256 tokens_to_M = contractTokenBalance * Percent_Game / 100;\nuint256 tokens_to_D = contractTokenBalance * Percent_Dev / 100;\nuint256 tokens_to_LP_Half = contractTokenBalance * Percent_AutoLP / 200;\n\nuint256 balanceBeforeSwap = address(this).balance;\nswapTokensForBNB(tokens_to_LP_Half + tokens_to_M + tokens_to_D);\nuint256 BNB_Total = address(this).balance - balanceBeforeSwap;\n\nuint256 split_M = Percent_Game * 100 / (Percent_AutoLP + Percent_Game + Percent_Dev);\nuint256 BNB_M = BNB_Total * split_M / 100;\n\nuint256 split_D = Percent_Dev * 100 / (Percent_AutoLP + Percent_Game + Percent_Dev);\nuint256 BNB_D = BNB_Total * split_D / 100;\n\n\naddLiquidity(tokens_to_LP_Half, (BNB_Total - BNB_M - BNB_D));\nemit SwapAndLiquify(tokens_to_LP_Half, (BNB_Total - BNB_M - BNB_D), tokens_to_LP_Half);\n\nsendToWallet(Wallet_Game, BNB_M);\n\nBNB_Total = address(this).balance;\nsendToWallet(Wallet_Dev, BNB_Total);\n\n}\n\n function swapTokensForBNB(uint256 tokenAmount) private {\n\n  address[] memory path = new address[](2);\n  path[0] = address(this);\n  path[1] = uniswapV2Router.WETH();\n  _approve(address(this), address(uniswapV2Router), tokenAmount);\n  uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\ntokenAmount,\n0, \npath,\naddress(this),\nblock.timestamp\n  );\n }\n\n\n function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\n\n  _approve(address(this), address(uniswapV2Router), tokenAmount);\n  uniswapV2Router.addLiquidityETH{value: BNBAmount}(\naddress(this),\ntokenAmount,\n0, \n0,\nWallet_Burn, \nblock.timestamp\n  );\n } \n\n\n function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee, bool isBuy) private {\n  \n  \n  if(!takeFee){\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tAmount;\nemit Transfer(sender, recipient, tAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tAmount;\n\n} else if (isBuy){\n\nuint256 buyFEE = tAmount*_Tax_On_Buy/100;\nuint256 tTransferAmount = tAmount-buyFEE;\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n_tOwned[address(this)] = _tOwned[address(this)]+buyFEE;\nemit Transfer(sender, recipient, tTransferAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tTransferAmount;\n\n} else {\n\nuint256 sellFEE = tAmount*_Tax_On_Sell/100;\nuint256 tTransferAmount = tAmount-sellFEE;\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n_tOwned[address(this)] = _tOwned[address(this)]+sellFEE;\nemit Transfer(sender, recipient, tTransferAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tTransferAmount;\n\n\n}\n\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-World-Football-v2.pdf/Lack Of Access Control",
                "Location": "function renounceOwnership() public virtual {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The function renounceOwnership() is public and can be called by anyone to renounce ownership.\n",
                "Repair": "We advise the client to set up access controls over the functions so only authorized users can call the function."
            }
        ]
    }
]