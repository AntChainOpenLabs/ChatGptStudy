[
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction {\n using SafeERC20 for IERC20;\n\n uint256 private constant BASE = 1e18;\n uint256 private constant ONE_DAY = 4 * 60 * 24;\n uint256 private constant BLOCK_DECREMENT = 10000;\n \n bool public override auctionOngoing;\n uint256 public override auctionStart;\n bool public override hasBonded;\n uint256 public override bondAmount;\n uint256 public override bondTimestamp;\n bool public override initialized;\n\n IBasket public override basket;\n IFactory public override factory;\n address public override auctionBonder;\n\n Bounty[] private _bounties;\n\n modifier onlyBasket() {\n  require(msg.sender == address(basket), 'not basket');\n  _;\n }\n\n function startAuction() onlyBasket public override {\n  require(auctionOngoing == false, 'ongoing auction');\n\n  auctionOngoing = true;\n  auctionStart = block.number;\n\n  emit AuctionStarted();\n }\n\n function killAuction() onlyBasket public override {\n  auctionOngoing = false;\n }\n\n function initialize(address basket_, address factory_) public override {\n  require(!initialized);\n  basket = IBasket(basket_);\n  factory = IFactory(factory_);\n  initialized = true;\n }\n\n function bondForRebalance() public override {\n  require(auctionOngoing);\n  require(!hasBonded);\n\n  bondTimestamp = block.number;\n\n  IERC20 basketToken = IERC20(address(basket));\n  bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n  basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n  hasBonded = true;\n  auctionBonder = msg.sender;\n\n  emit Bonded(msg.sender, bondAmount);\n }\n\n function settleAuction(\n  uint256[] memory bountyIDs,\n  address[] memory inputTokens,\n  uint256[] memory inputWeights,\n  address[] memory outputTokens,\n  uint256[] memory outputWeights\n ) public override {\n  require(auctionOngoing);\n  require(hasBonded);\n  require(bondTimestamp + ONE_DAY > block.number);\n  require(msg.sender == auctionBonder);\n\n  for (uint256 i = 0; i < inputTokens.length; i++) {\nIERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n  }\n\n  for (uint256 i = 0; i < outputTokens.length; i++) {\nIERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n  }\n\n  uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n  uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n  uint256 newRatio = a - b;\n\n  (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n  IERC20 basketAsERC20 = IERC20(address(basket));\n\n  for (uint256 i = 0; i < pendingWeights.length; i++) {\nuint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\nrequire(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n  }\n\n  basketAsERC20.transfer(msg.sender, bondAmount);\n  withdrawBounty(bountyIDs);\n  basket.setNewWeights();\n  basket.updateIBRatio(newRatio);\n  auctionOngoing = false;\n  hasBonded = false;\n\n  emit AuctionSettled(msg.sender);\n }\n\n function bondBurn() external override {\n  require(auctionOngoing);\n  require(hasBonded);\n  require(bondTimestamp + ONE_DAY <= block.number);\n\n  basket.auctionBurn(bondAmount);\n  hasBonded = false;\n  auctionOngoing = false;\n  basket.deleteNewIndex();\n\n  emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n  auctionBonder = address(0);\n }\n\n function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n  // add bounty to basket\n  token.safeTransferFrom(msg.sender, address(this), amount);\n  _bounties.push(Bounty({\ntoken: address(token),\namount: amount,\nactive: true\n  }));\n\n  uint256 id = _bounties.length - 1;\n  emit BountyAdded(token, amount, id);\n  return id;\n }\n\n function withdrawBounty(uint256[] memory bountyIds) internal {\n  // withdraw bounties\n  for (uint256 i = 0; i < bountyIds.length; i++) {\nBounty memory bounty = _bounties[bountyIds[i]];\nrequire(bounty.active);\n\nIERC20(bounty.token).transfer(msg.sender, bounty.amount);\nbounty.active = false;\n\nemit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n  }\n }\n }\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-09-defiProtocol-findings.json",
                "Location": "settleAuction() function in Auction.sol",
                "Type": "Reentrancy",
                "Description": "The function calls withdrawBounty() before setting auctionOngoing = false, allowing reentrancy and enabling a malicious publisher to bypass the index timelock mechanism and rug the basket.",
                "Repair": "Move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./VestingWallet.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title BathBuddy\n * @dev *** This contract is a lightly modified version of Vesting Wallet by OpenZeppelin\n * @dev PLEASE FIND OZ DOCUMENTATION FOR THIS CONTRACT HERE: https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet\n *\n * @dev The only entrypoint used in the system is the release function called by the Bath Token. Extra care should be taken to make sure only the beneficiary can ever access the funds and send them to the withdrawer (and fee to self)\n *\n * @dev This contract handles the vesting ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract BathBuddy is IBathBuddy {\n using SafeMath for uint256;\n\n // Public versions of the base VestingWallet storage\n uint256 private _released;\n mapping(address => uint256) private _erc20Released;\n\n // Beneficiary must be the Bath Token vault recipient that will call release() for its withdrawer\n address public beneficiary;\n uint64 public start;\n uint64 public duration;\n\n /**\n  * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n  */\n constructor(\n  address beneficiaryAddress,\n  uint64 startTimestamp,\n  uint64 durationSeconds\n ) {\n  require(\nbeneficiaryAddress != address(0),\n\"VestingWallet: beneficiary is zero address\"\n  );\n  beneficiary = beneficiaryAddress;\n  start = startTimestamp;\n  duration = durationSeconds;\n }\n\n // OZ\n event EtherReleased(uint256 amount);\n event ERC20Released(address indexed token, uint256 amount);\n\n /// @notice Log bonus token reward event\n event LogClaimBonusToken(\n  address indexed receiver,\n  address indexed callingPool,\n  uint256 amountReceived,\n  uint256 shares,\n  IERC20 bonusToken,\n  uint256 releasableAmountToWholePool\n );\n\n /**\n  * @dev The contract should be able to receive Eth.\n  */\n receive() external payable {}\n\n /**\n  * @dev Amount of eth already released\n  */\n function released() public view returns (uint256) {\n  return _released;\n }\n\n /**\n  * @dev Amount of token already released\n  */\n function released(address token) public view returns (uint256) {\n  return _erc20Released[token];\n }\n\n /// @inheritdoc IBathBuddy\n /// @dev Added and modified release function. Should be the only callable release function\n function release(\n  IERC20 token,\n  address recipient,\n  uint256 sharesWithdrawn,\n  uint256 initialTotalSupply,\n  uint256 poolFee\n ) external override {\n  require(\nmsg.sender == beneficiary,\n\"Caller is not the Bath Token beneficiary of these rewards\"\n  );\n  uint256 releasable = vestedAmount(\naddress(token),\nuint64(block.timestamp)\n  ) - released(address(token));\n  if (releasable > 0) {\nuint256 amount = releasable.mul(sharesWithdrawn).div(\n initialTotalSupply\n);\nuint256 _fee = amount.mul(poolFee).div(10000);\n\n// If FeeTo == address(this) then the fee is effectively accrued by the pool\n// Assume the caller is the liquidity pool and they receive the fee\n// Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy\n// token.transfer(address(this), _fee);\n\nuint256 amountWithdrawn = amount.sub(_fee);\ntoken.transfer(recipient, amountWithdrawn);\n\n_erc20Released[address(token)] += amount;\nemit ERC20Released(address(token), amount);\n\nemit LogClaimBonusToken(\n recipient,\n msg.sender,\n amountWithdrawn,\n sharesWithdrawn,\n token,\n releasable\n);\n  }\n }\n\n /**\n  * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n  */\n function vestedAmount(address token, uint64 timestamp)\n  public\n  view\n  returns (uint256)\n {\n  return\n_vestingSchedule(\n IERC20(token).balanceOf(address(this)) + released(token),\n timestamp\n);\n }\n\n /**\n  * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n  * an asset given its total historical allocation.\n  */\n function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n  internal\n  view\n  returns (uint256)\n {\n  if (timestamp < start) {\nreturn 0;\n  } else if (timestamp > start + duration) {\nreturn totalAllocation;\n  } else {\nreturn (totalAllocation * (timestamp - start)) / duration;\n  }\n }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "release() function in BathBuddy.sol",
                "Type": "Reentrancy",
                "Description": "If a token with callback capabilities is used as a token to vested, then a malicious beneficiary may get the vested amount back without waiting for the vesting period. In the function release, there\u2019s no modifier to stop reentrancy, in the other contracts it would be the synchronized modifier. If a token could reenter with a hook in a malicious contract (an ERC777 token, for example, which is backwards compatible with ERC20), released token counter array wouldn\u2019t be updated, enabling the withdrawal of the vested amount before the vesting period ends.",
                "Repair": "Add a mutex such as nonReentrant, or the synchronized modifier used in the other contracts. Implement checks-effects-interactions pattern."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.10;\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n using Counters for Counters.Counter;\n using SafeERC20 for IERC20;\n using PercentMath for uint256;\n using Address for address;\n using ERC165Query for address;\n uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n uint256 public constant SHARES_MULTIPLIER = 10**18;\n IERC20 public override(IVault) underlying;\n IStrategy public strategy;\n uint256 public investPerc;\n uint256 public immutable override(IVault) minLockPeriod;\n uint256 public override(IVaultSponsoring) totalSponsored;\n Depositors public depositors;\n Claimers public claimers;\n Counters.Counter private _depositGroupIds;\n constructor(\n  IERC20 _underlying,\n  uint256 _minLockPeriod,\n  uint256 _investPerc,\n  address _owner\n ) Trust(_owner) {\n  require(\nPercentMath.validPerc(_investPerc),\n\"Vault: invalid investPerc\"\n  );\n  require(\naddress(_underlying) != address(0x0),\n\"VaultContext: underlying cannot be 0x0\"\n  );\n  investPerc = _investPerc;\n  underlying = _underlying;\n  minLockPeriod = _minLockPeriod;\n\n  depositors = new Depositors(address(this), \"depositors\", \"p\");\n  claimers = new Claimers(address(this));\n }\n function deposit(DepositParams calldata _params) external {\n  _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n  _transferAndCheckUnderlying(_msgSender(), _params.amount);\n }\n\n function sponsor(uint256 _amount, uint256 _lockedUntil)\n  external\n  override(IVaultSponsoring)\n {\n  if (_lockedUntil == 0)\n_lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n  else\nrequire(\n _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n \"Vault: lock time is too small\"\n);\n  uint256 tokenId = depositors.mint(\n_msgSender(),\n_amount,\n0,\n_lockedUntil\n  );\n\n  emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n  totalSponsored += _amount;\n  _transferAndCheckUnderlying(_msgSender(), _amount);\n }  \nfunction _withdrawDeposit(\n  uint256 _tokenId,\n  uint256 _totalShares,\n  uint256 _totalUnderlyingMinusSponsored,\n  address _to,\n  bool _force\n ) internal returns (uint256) {\n  require(\ndepositors.ownerOf(_tokenId) == _msgSender(),\n\"Vault: you are not the owner of a deposit\"\n  );\n\n  (\nuint256 depositAmount,\nuint256 claimerId,\nuint256 lockedUntil\n  ) = depositors.deposits(_tokenId);\n  require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n  require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n  uint256 claimerShares = claimers.sharesOf(claimerId);\n\n  uint256 depositShares = _computeShares(\ndepositAmount,\n_totalShares,\n_totalUnderlyingMinusSponsored\n  );\n\n  if (_force && depositShares > claimerShares) {\ndepositShares = claimerShares;\n  } else if (!_force) {\nrequire(\n claimerShares >= depositShares,\n \"Vault: cannot withdraw more than the available amount\"\n);\n  }\n\n  claimers.onWithdraw(claimerId, depositAmount, depositShares);\n  depositors.burn(_tokenId);\n  address claimer = claimers.ownerOf(claimerId);\n  if (_isIntegration(claimer)) {\nbytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\nrequire(ret == IIntegration(claimer).onDepositBurned.selector);\n  }\n\n  emit DepositBurned(_tokenId, depositShares, _to);\n\n  return\n_computeAmount(\n depositShares,\n _totalShares,\n _totalUnderlyingMinusSponsored\n);\n }\n  function _isIntegration(address addr) internal view returns (bool) {\n  return\naddr.doesContractImplementInterface(type(IIntegration).interfaceId);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-sandclock-findings.json",
                "Location": "onDepositBurned function in Vault.sol",
                "Type": "Reentrancy",
                "Description": "The impact of this is that users can get significantly more UST withdrawn than they would be allotted if they had done non-reentrant withdraw calls.",
                "Repair": "Add reentrancy guards. Simplify some of the shares logic."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.10;\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n using Counters for Counters.Counter;\n using SafeERC20 for IERC20;\n using PercentMath for uint256;\n using Address for address;\n using ERC165Query for address;\n uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n uint256 public constant SHARES_MULTIPLIER = 10**18;\n IERC20 public override(IVault) underlying;\n IStrategy public strategy;\n uint256 public investPerc;\n uint256 public immutable override(IVault) minLockPeriod;\n uint256 public override(IVaultSponsoring) totalSponsored;\n Depositors public depositors;\n Claimers public claimers;\n Counters.Counter private _depositGroupIds;\n constructor(\n  IERC20 _underlying,\n  uint256 _minLockPeriod,\n  uint256 _investPerc,\n  address _owner\n ) Trust(_owner) {\n  require(\nPercentMath.validPerc(_investPerc),\n\"Vault: invalid investPerc\"\n  );\n  require(\naddress(_underlying) != address(0x0),\n\"VaultContext: underlying cannot be 0x0\"\n  );\n  investPerc = _investPerc;\n  underlying = _underlying;\n  minLockPeriod = _minLockPeriod;\n\n  depositors = new Depositors(address(this), \"depositors\", \"p\");\n  claimers = new Claimers(address(this));\n }\n\n function sponsor(uint256 _amount, uint256 _lockedUntil)\n  external\n  override(IVaultSponsoring)\n {\n  if (_lockedUntil == 0)\n_lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n  else\nrequire(\n _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n \"Vault: lock time is too small\"\n);\n\n  uint256 tokenId = depositors.mint(\n_msgSender(),\n_amount,\n0,\n_lockedUntil\n  );\n\n  emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n  totalSponsored += _amount;\n  _transferAndCheckUnderlying(_msgSender(), _amount);\n }  \n function _createClaim(\n  uint256 _depositGroupId,\n  uint256 _amount,\n  uint256 _lockedUntil,\n  ClaimParams memory _claim,\n  uint256 _localTotalShares,\n  uint256 _localTotalPrincipal\n ) internal {\n  uint256 amount = _amount.percOf(_claim.pct);\n\n  uint256 newShares = _computeShares(\namount,\n_localTotalShares,\n_localTotalPrincipal\n  );\n\n  uint256 claimerId = claimers.mint(\n_claim.beneficiary,\namount,\nnewShares\n  );\n\n  uint256 tokenId = depositors.mint(\n_msgSender(),\namount,\nclaimerId,\n_lockedUntil\n  );\n\n  if (_isIntegration(_claim.beneficiary)) {\nbytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n tokenId,\n newShares,\n _claim.data\n);\n\nrequire(\n ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n);\n  }\n\n  emit DepositMinted(\ntokenId,\n_depositGroupId,\namount,\nnewShares,\n_msgSender(),\n_claim.beneficiary,\nclaimerId,\n_lockedUntil\n  );\n }\n function _transferAndCheckUnderlying(address _from, uint256 _amount)\n  internal\n {\n  uint256 balanceBefore = totalUnderlying();\n  underlying.safeTransferFrom(_from, address(this), _amount);\n  uint256 balanceAfter = totalUnderlying();\n\n  require(\nbalanceAfter == balanceBefore + _amount,\n\"Vault: amount received does not match params\"\n  );\n }\n function _isIntegration(address addr) internal view returns (bool) {\n  return\naddr.doesContractImplementInterface(type(IIntegration).interfaceId);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-sandclock-findings.json",
                "Location": "sponsor() function in Vault.sol",
                "Type": "Reentrancy",
                "Description": "In Vault.sol the sponsor() function does not have a reentrancy guard allowing an attacker to reenter the function because the depositors.mint() function has as callback to the msg.sender.",
                "Repair": "Add a reentrancy guard modifier to the sponsor() function in Vault.sol"
            }
        ]
    },
    {
        "Code": "apragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IERC721.sol\";\nstruct TokenLoanParams {\n uint128 valuation; // How much will you get? OK to owe until expiration.\n uint64 duration; // Length of loan in seconds\n uint16 annualInterestBPS; // Variable cost of taking out the loan\n}\ninterface ILendingClub {\n function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\ninterface INFTPair {\n function collateral() external view returns (IERC721);\n function asset() external view returns (IERC20);\n function masterContract() external view returns (address);\n function bentoBox() external view returns (IBentoBoxV1);\n function removeCollateral(uint256 tokenId, address to) external;}\ncontract NFTPair is BoringOwnable, Domain, IMasterContract {\n using BoringMath for uint256;using BoringMath128 for uint128;using RebaseLibrary for Rebase;using BoringERC20 for IERC20;\n event LogRequestLoan(address indexed borrower, uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n event LogLend(address indexed lender, uint256 indexed tokenId);\n event LogRepay(address indexed from, uint256 indexed tokenId);\n event LogFeeTo(address indexed newFeeTo);\n event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n IBentoBoxV1 public immutable bentoBox;\n NFTPair public immutable masterContract;address public feeTo;IERC721 public collateral;IERC20 public asset;uint256 public feesEarnedShare;\n mapping(uint256 => TokenLoanParams) public tokenLoanParams;\n uint8 private constant LOAN_INITIAL = 0;\n uint8 private constant LOAN_REQUESTED = 1;\n uint8 private constant LOAN_OUTSTANDING = 2;\n struct TokenLoan {address borrower;address lender;uint64 startTime;uint8 status;}\n mapping(uint256 => TokenLoan) public tokenLoan;\n uint256 private constant PROTOCOL_FEE_BPS = 1000;\n uint256 private constant OPEN_FEE_BPS = 100;\n uint256 private constant BPS = 10_000;\n uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n mapping(address => uint256) public nonces;\n constructor(IBentoBoxV1 bentoBox_) public {bentoBox = bentoBox_;masterContract = this;}\n function init(bytes calldata data) public payable override {\n  require(address(collateral) == address(0), \"NFTPair: already initialized\");\n  (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n  require(address(collateral) != address(0), \"NFTPair: bad pair\");}\n function _requestLoan(address collateralProvider,uint256 tokenId,TokenLoanParams memory params,address to,bool skim) private {equire(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");\n  if (skim) {require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");\n  } else {collateral.transferFrom(collateralProvider, address(this), tokenId);}\n  TokenLoan memory loan;loan.borrower = to;loan.status = LOAN_REQUESTED;tokenLoan[tokenId] = loan;tokenLoanParams[tokenId] = params;\n  emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);}\n function requestLoan(uint256 tokenId,TokenLoanParams memory params,address to,bool skim) public {_requestLoan(msg.sender, tokenId, params, to, skim);}\n function requestAndBorrow(uint256 tokenId,address lender,address recipient,TokenLoanParams memory params,bool skimCollateral,bool anyTokenId,uint256 deadline,uint8 v,bytes32 r,bytes32 s\n ) public {if (v == 0 && r == bytes32(0) && s == bytes32(0)) {\nrequire(ILendingClub(lender).willLend(tokenId, params), \"NFTPair: LendingClub does not like you\");} else {\nrequire(block.timestamp <= deadline, \"NFTPair: signature expired\");\nuint256 nonce = nonces[lender]++;bytes32 dataHash = keccak256(abi.encode(LEND_SIGNATURE_HASH,address(this),anyTokenId ? 0 : tokenId,anyTokenId,params.valuation,params.duration,params.annualInterestBPS,nonce,deadline));\nrequire(ecrecover(_getDigest(dataHash), v, r, s) == lender, \"NFTPair: signature invalid\");}\n  _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);_lend(lender, tokenId, params, false);}\n function takeCollateralAndLend(uint256 tokenId,address borrower,TokenLoanParams memory params,bool skimFunds,uint256 deadline,uint8 v,bytes32 r,bytes32 s\n ) public {require(block.timestamp <= deadline, \"NFTPair: signature expired\");uint256 nonce = nonces[borrower]++;\n  bytes32 dataHash = keccak256(abi.encode(BORROW_SIGNATURE_HASH,address(this),tokenId,params.valuation,params.duration,params.annualInterestBPS,nonce,deadline));\n  require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, \"NFTPair: signature invalid\");\n  _requestLoan(borrower, tokenId, params, borrower, false);_lend(msg.sender, tokenId, params, skimFunds); }  }",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-abranft-findings.json",
                "Location": "collateral.transferFrom(collateralProvider, address(this), tokenId); in _requestLoan function",
                "Type": "Reentrancy",
                "Description": "The NFTPair contract can be reentered, and a loan can be requested without the borrower supplying the collateral.",
                "Repair": "Move the external call to the end of the function to conform with checks-effects-interaction pattern"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.9;\nimport { IAxelarGatewayMultisig } from './interfaces/IAxelarGatewayMultisig.sol';\nimport { ECDSA } from './ECDSA.sol';\nimport { AxelarGateway } from './AxelarGateway.sol';\ncontract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {\n error InvalidAddress();error InvalidOwners();error InvalidOwnerThreshold();error DuplicateOwner(address owner);error InvalidOperators();error InvalidOperatorThreshold();\n error DuplicateOperator(address operator);error NotProxy();error InvalidChainId();error MalformedSigners();error InvalidCommands();\n bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');\n bytes32 internal constant PREFIX_OWNER = keccak256('owner');\n bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');\n bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');\n bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');\n bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');\n bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');\n bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');\n bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');\n bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');\n constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}\n function execute(bytes calldata input) external override { (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[])); _execute(data, signatures);}\n function _execute(bytes memory data, bytes[] memory signatures) internal {\n  uint256 signatureCount = signatures.length;\n  address[] memory signers = new address[](signatureCount);\n  for (uint256 i; i < signatureCount; i++) {\nsigners[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);}\n  ( uint256 chainId,\nRole signersRole,\nbytes32[] memory commandIds,\nstring[] memory commands,\nbytes[] memory params) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));\n  if (chainId != block.chainid) revert InvalidChainId();\n  if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();\n  uint256 commandsLength = commandIds.length;\n  if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n  bool areValidCurrentOwners;bool areValidRecentOwners;bool areValidRecentOperators;\n  if (signersRole == Role.Owner) {\nareValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);\nareValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);} else if (signersRole == Role.Operator) {\nareValidRecentOperators = _areValidRecentOperators(signers);}\n  for (uint256 i; i < commandsLength; i++) {\nbytes32 commandId = commandIds[i];\nif (isCommandExecuted(commandId)) continue; \nbytes4 commandSelector;\nbytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\nif (commandHash == SELECTOR_DEPLOY_TOKEN) {\n if (!areValidRecentOwners) continue;commandSelector = AxelarGatewayMultisig.deployToken.selector;\n} else if (commandHash == SELECTOR_MINT_TOKEN) {\n if (!areValidRecentOperators && !areValidRecentOwners) continue;\n commandSelector = AxelarGatewayMultisig.mintToken.selector;\n} else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n if (!areValidRecentOperators && !areValidRecentOwners) continue;\n commandSelector = AxelarGatewayMultisig.approveContractCall.selector;\n} else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n if (!areValidRecentOperators && !areValidRecentOwners) continue;\n commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;\n} else if (commandHash == SELECTOR_BURN_TOKEN) {\n if (!areValidRecentOperators && !areValidRecentOwners) continue;\n commandSelector = AxelarGatewayMultisig.burnToken.selector;\n} else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {\n if (!areValidCurrentOwners) continue;\n commandSelector = AxelarGatewayMultisig.transferOwnership.selector;\n} else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n if (!areValidCurrentOwners) continue;\n commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;\n} else {continue; }\n_setCommandExecuted(commandId, true);\n(bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n_setCommandExecuted(commandId, success);\nif (success) {emit Executed(commandId);}}}}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-axelar-findings.json",
                "Location": "execute function and  if (isCommandExecuted(commandId)) continue; in _executef function",
                "Type": "Reentrancy",
                "Description": "The _execute function and its wrapper execute are both reentrant. If an attacker manages to reenter the _execute function with the same batch of commands and signatures, previously successfully executed and ongoing commands will be skipped due to premature marking of the success flag. This allows later commands to be executed before the current ongoing command is finished. The reentrant attack can be nested to perform further reordering of commands.",
                "Repair": "Make execute nonReentrant, Add an ever increasing nonce to signatures to prevent replay"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.12;\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n using SafeTransferLib for ERC20;\n uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n address public override lendTicketContract;\n address public override borrowTicketContract;\n mapping(uint256 => Loan) public loanInfo;\n uint256 private _nonce = 1;\n modifier notClosed(uint256 loanId) { \n  require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n }\n constructor(address _manager) {\n  transferOwnership(_manager);\n }\n function lend(\n  uint256 loanId,\n  uint16 interestRate,\n  uint128 amount,\n  uint32 durationSeconds,\n  address sendLendTicketTo\n ) external override notClosed(loanId)\n {\n  Loan storage loan = loanInfo[loanId];\n  if (loan.lastAccumulatedTimestamp == 0) {\n ...\n);IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n  } else {\nuint256 previousLoanAmount = loan.loanAmount;\nuint256 amountIncrease = amount - previousLoanAmount;\n\n{\n uint256 previousInterestRate = loan.perAnumInterestRate;\n uint256 previousDurationSeconds = loan.durationSeconds;\n require(interestRate <= previousInterestRate, \"NFTLoanFacilitator: rate too high\");\n require(durationSeconds >= previousDurationSeconds, \"NFTLoanFacilitator: duration too low\");\n require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n  && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n}\nuint256 accumulatedInterest = _interestOwed(\n previousLoanAmount,\n loan.lastAccumulatedTimestamp,\n loan.perAnumInterestRate,\n loan.accumulatedInterest\n);\nrequire(accumulatedInterest <= type(uint128).max,\n\"NFTLoanFacilitator: accumulated interest exceeds uint128\");\nloan.perAnumInterestRate = interestRate;\nloan.lastAccumulatedTimestamp = uint40(block.timestamp);\nloan.durationSeconds = durationSeconds;\nloan.loanAmount = amount;\nloan.accumulatedInterest = uint128(accumulatedInterest);\naddress currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\nif (amountIncrease > 0) { address loanAssetContractAddress = loan.loanAssetContractAddress;ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender,address(this),amount + accumulatedInterest);\n ERC20(loanAssetContractAddress).safeTransfer(\n  currentLoanOwner,\n  accumulatedInterest + previousLoanAmount\n );\n uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n ERC20(loanAssetContractAddress).safeTransfer(\n  IERC721(borrowTicketContract).ownerOf(loanId),\n  amountIncrease - facilitatorTake\n );\n} else {\n ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n  msg.sender,\n  currentLoanOwner,\n  accumulatedInterest + previousLoanAmount\n );\n}\nILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n\nemit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n  }\n\n  emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-backed-findings.json",
                "Location": "ERC20(loanAssetContractAddress).safeTransfer( currentLoanOwner,accumulatedInterest + previousLoanAmount); and  ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender,currentLoanOwner,accumulatedInterest + previousLoanAmount);  in lend function",
                "Type": "Reentrancy",
                "Description": "An attacker can manipulate loanInfo by reentrancy attack when any lenders try to buyout. The attacker can set bad values of lendInfo (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.",
                "Repair": "Use nonReentrant modifier on lend() to prevent reentrancy attack or block ERC777 tokens"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.12;\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n using SafeTransferLib for ERC20;\n uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n mapping(uint256 => Loan) public loanInfo;\n uint256 private _nonce = 1;\n constructor(address _manager) {\n  transferOwnership(_manager);\n }\n function (\n  uint256 loanId,\n  uint16 interestRate,\n  uint128 amount,\n  uint32 durationSeconds,\n  address sendLendTicketTo\n )\n  external\n  override\n  notClosed(loanId)\n {\n  Loan storage loan = loanInfo[loanId];\n  \n  if (loan.lastAccumulatedTimestamp == 0) {\n...\n  } else {\nuint256 previousLoanAmount = loan.loanAmount;\nuint256 amountIncrease = amount - previousLoanAmount;\n\n{\n...\n}\n\nuint256 accumulatedInterest = _interestOwed(\n previousLoanAmount,\n loan.lastAccumulatedTimestamp,\n loan.perAnumInterestRate,\n loan.accumulatedInterest\n);\n  ...\nloan.perAnumInterestRate = interestRate;\nloan.lastAccumulatedTimestamp = uint40(block.timestamp);\nloan.durationSeconds = durationSeconds;\nloan.loanAmount = amount;\nloan.accumulatedInterest = uint128(accumulatedInterest);\n\naddress currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\nif (amountIncrease > 0) {\n address loanAssetContractAddress = loan.loanAssetContractAddress;\n ERC20(loanAssetContractAddress).safeTransferFrom(\n  msg.sender,\n  address(this),\n  amount + accumulatedInterest\n );\n ERC20(loanAssetContractAddress).safeTransfer(\n  currentLoanOwner,\n  accumulatedInterest + previousLoanAmount\n );\n uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n ERC20(loanAssetContractAddress).safeTransfer(\n  IERC721(borrowTicketContract).ownerOf(loanId),\n  amountIncrease - facilitatorTake\n );\n} else {\n ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n  msg.sender,\n  currentLoanOwner,\n  accumulatedInterest + previousLoanAmount\n );\n}\nILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n\nemit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n  }\n\n  emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n }\n function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n  Loan storage loan = loanInfo[loanId];\n\n  uint256 interest = _interestOwed(\nloan.loanAmount,\nloan.lastAccumulatedTimestamp,\nloan.perAnumInterestRate,\nloan.accumulatedInterest\n  );\n  address lender = IERC721(lendTicketContract).ownerOf(loanId);\n  loan.closed = true;\n  ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n  IERC721(loan.collateralContractAddress).safeTransferFrom(\naddress(this),\nIERC721(borrowTicketContract).ownerOf(loanId),\nloan.collateralTokenId\n  );\n\n  emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n  emit Close(loanId);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-backed-findings.json",
                "Location": "NFTLoanFacilitator.sol#repayAndCloseLoan",
                "Type": "Reentrancy",
                "Description": "If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.",
                "Repair": "Move the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely. If desired, also require that the lender cannot be the same account as the borrower of a loan."
            }
        ]
    },
    {
        "Code": "pragma solidity =0.7.6;\ncontract BathToken {\n using SafeMath for uint256;\n bool public initialized;\n string public symbol;\n string public name;\n uint8 public decimals;\n address public RubiconMarketAddress;\n address public bathHouse;\n address public feeTo;\n IERC20 public underlyingToken;\n uint256 public feeBPS;\n uint256 public totalSupply;\n uint256 public outstandingAmount;\n uint256[] deprecatedStorageArray; \n mapping(uint256 => uint256) deprecatedMapping; \n mapping(address => uint256) public balanceOf;\n mapping(address => mapping(address => uint256)) public allowance;\n bytes32 public DOMAIN_SEPARATOR;\n bytes32 public constant PERMIT_TYPEHASH =\n  0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n mapping(address => uint256) public nonces;\n address[] public bonusTokens;\n IBathBuddy public rewardsVestingWallet;\n function initialize(\n  ERC20 token,\n  address market,\n  address _feeTo\n ) external {\n  require(!initialized);\n  string memory _symbol = string(\nabi.encodePacked((\"bath\"), token.symbol())\n  );\n  symbol = _symbol;\n  underlyingToken = token;\n  RubiconMarketAddress = market;\n  bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n  uint256 chainId;\n  assembly {\nchainId := chainid()\n  }\n  DOMAIN_SEPARATOR = keccak256(\nabi.encode(\n keccak256(\n  \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n ),\n keccak256(bytes(name)),\n keccak256(bytes(\"1\")),\n chainId,\n address(this)\n)\n  );\n  name = string(abi.encodePacked(_symbol, (\" v1\")));\n  decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n  // Add infinite approval of Rubicon Market for this asset\n  IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n  emit LogInit(block.timestamp);\n\n  feeTo = address(this); /\n  feeBPS = 3; \n  initialized = true;\n }\n modifier onlyPair() {\n  require(\nIBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n\"not an approved pair - bathToken\"\n  );\n  _;\n }\n modifier onlyBathHouse() {\n  require(\nmsg.sender == bathHouse,\n\"caller is not bathHouse - BathToken.sol\"\n  );\n  _;\n }\n function permit(\n  address owner,\n  address spender,\n  uint256 value,\n  uint256 deadline,\n  uint8 v,\n  bytes32 r,\n  bytes32 s\n ) external {\n  require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n  bytes32 digest = keccak256(\nabi.encodePacked(\n \"\\x19\\x01\",\n DOMAIN_SEPARATOR,\n keccak256(\n  abi.encode(\nPERMIT_TYPEHASH,\nowner,\nspender,\nvalue,\nnonces[owner]++,\ndeadline\n  )\n )\n)\n  );\n  address recoveredAddress = ecrecover(digest, v, r, s);\n  require(\nrecoveredAddress != address(0) && recoveredAddress == owner,\n\"bathToken: INVALID_SIGNATURE\"\n  );\n  _approve(owner, spender, value);\n }\n\n function underlyingERC20() external view returns (address) {\n  return address(underlyingToken);\n }\n\n function underlyingBalance() public view returns (uint256) {\n  uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n  return _pool.add(outstandingAmount);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "BathToken.initialize()",
                "Type": "Reentrancy",
                "Description": "Malicious pools can be deployed through BathHouse. Reentrancy in BathToken.initialize() can be exploited and this allows to create a pool which has a legitimate underlying token (even one for which a pool already exists), and has given full approval of underlying Token to an attacker.",
                "Repair": "Add onlyBathHouse modifier to initialize function in BathToken to avoid reentrancy from malicious tokens."
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.10;\ncontract MIMOAutoRebalance is MIMOAutoAction, MIMOFlashloan, IMIMOAutoRebalance {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  address public immutable mimoRebalance;\n  constructor(\n IAddressProvider _a,\n IPool _lendingPool,\n IMIMOProxyRegistry _proxyRegistry,\n address _mimoRebalance\n  ) MIMOAutoAction(_a, _proxyRegistry) MIMOFlashloan(_lendingPool) {\n if (_mimoRebalance == address(0)) {\nrevert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n }\n mimoRebalance = _mimoRebalance;\n  }\n\n  function rebalance(uint256 vaultId, IMIMOSwap.SwapData calldata swapData) external override {\n AutomatedVault memory autoVault = _automatedVaults[vaultId];\n\n (uint256 vaultARatioBefore, VaultState memory vaultAState) = _getVaultStats(vaultId);\n\n _preRebalanceChecks(autoVault, vaultId, vaultARatioBefore);\n\n IVaultsDataProvider vaultsData = a.vaultsData();\n address vaultOwner = vaultsData.vaultOwner(vaultId);\n uint256 vaultBId = vaultsData.vaultId(address(autoVault.toCollateral), vaultOwner);\n uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n (IMIMORebalance.RebalanceData memory rbData, FlashLoanData memory flData, uint256 autoFee) = _getRebalanceParams(\nautoVault,\nvaultAState,\nIERC20(autoVault.toCollateral),\nvaultId\n );\n\n _takeFlashLoan(flData, abi.encode(vaultOwner, autoFee, rbData, swapData));\n _postRebalanceChecks(autoVault, flData.amount, vaultBBalanceBefore, vaultId, vaultOwner, vaultsData);\n\n _operationTracker[vaultId] = block.timestamp;\n\n IERC20(a.stablex()).safeTransfer(msg.sender, autoFee);\n  }\n\n  function executeOperation(\n address[] calldata assets,\n uint256[] calldata amounts,\n uint256[] calldata premiums,\n address initiator,\n bytes calldata params\n  ) external override returns (bool) {\n (\naddress mimoProxy,\nuint256 managerFee,\nIMIMORebalance.RebalanceData memory rbData,\nIMIMOSwap.SwapData memory swapData\n ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n if (initiator != address(this)) {\nrevert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n }\n if (msg.sender != address(lendingPool)) {\nrevert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n }\n\n IERC20 fromCollateral = IERC20(assets[0]);\n uint256 amount = amounts[0];\n fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n IMIMOProxy(mimoProxy).execute(\nmimoRebalance,\nabi.encodeWithSignature(\n  \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n  fromCollateral,\n  amount,\n  flashloanRepayAmount,\n  managerFee,\n  rbData,\n  swapData\n)\n );\n\n fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n return true;\n  }\n\n  function _getAmounts(\n AutomatedVault memory autoVault,\n VaultState memory vaultState,\n address toCollateral\n  )\n internal\n view\n returns (\nuint256 rebalanceAmount,\nuint256 mintAmount,\nuint256 autoFee\n )\n  {\n IAddressProvider _a = a;\n\n uint256 targetRatio = autoVault.targetRatio + 1e15; // add 0.1% to account for rounding\n uint256 toVaultMcr = _a.config().collateralMinCollateralRatio(address(toCollateral));\n uint256 rebalanceValue = (targetRatio.wadMul(vaultState.vaultDebt + autoVault.fixedFee) -\nvaultState.collateralValue).wadDiv(\n  (targetRatio.wadDiv(toVaultMcr + autoVault.mcrBuffer) - targetRatio.wadMul(autoVault.varFee) - WadRayMath.WAD)\n);\n autoFee = autoVault.fixedFee + rebalanceValue.wadMul(autoVault.varFee);\n rebalanceAmount = _a.priceFeed().convertTo(vaultState.collateralType, rebalanceValue);\n mintAmount = rebalanceValue.wadDiv(toVaultMcr + autoVault.mcrBuffer) - autoFee;\n  }\n  function _preRebalanceChecks(\n AutomatedVault memory autoVault,\n uint256 vaultId,\n uint256 vaultARatio\n  ) internal view {\n if (!autoVault.isAutomated) {\nrevert CustomErrors.VAULT_NOT_AUTOMATED();\n }\n if (_operationTracker[vaultId] > block.timestamp - 1 days) {\nrevert CustomErrors.MAX_OPERATIONS_REACHED();\n }\n if (vaultARatio > autoVault.triggerRatio) {\nrevert CustomErrors.VAULT_TRIGGER_RATIO_NOT_REACHED(vaultARatio, autoVault.triggerRatio);\n }\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-mimo-findings.json",
                "Location": "MIMOAutoRebalance.sol#rebalance",
                "Type": "Reentrancy",
                "Description": "An attacker can exploit the vulnerability to steal funds by swapping through a malicious token that transfers control to the caller.",
                "Repair": "Add nonReentrant modifier to the function"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract Market {\n\n address public gov;\n address public lender;\n address public pauseGuardian;\n address public immutable escrowImplementation;\n IDolaBorrowingRights public immutable dbr;\n IBorrowController public borrowController;\n IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n IERC20 public immutable collateral;\n IOracle public oracle;\n uint public collateralFactorBps;\n uint public replenishmentIncentiveBps;\n uint public liquidationIncentiveBps;\n uint public liquidationFeeBps;\n uint public liquidationFactorBps = 5000; // 50% by default\n bool immutable callOnDepositCallback;\n bool public borrowPaused;\n uint public totalDebt;\n uint256 internal immutable INITIAL_CHAIN_ID;\n bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n mapping (address => IEscrow) public escrows; // user => escrow\n mapping (address => uint) public debts; // user => debt\n mapping(address => uint256) public nonces; // user => nonce\n constructor (\n  address _gov,\n  address _lender,\n  address _pauseGuardian,\n  address _escrowImplementation,\n  IDolaBorrowingRights _dbr,\n  IERC20 _collateral,\n  IOracle _oracle,\n  uint _collateralFactorBps,\n  uint _replenishmentIncentiveBps,\n  uint _liquidationIncentiveBps,\n  bool _callOnDepositCallback\n ) {\n  require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n  require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n  require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n  gov = _gov;\n  lender = _lender;\n  pauseGuardian = _pauseGuardian;\n  escrowImplementation = _escrowImplementation;\n  dbr = _dbr;\n  collateral = _collateral;\n  oracle = _oracle;\n  collateralFactorBps = _collateralFactorBps;\n  replenishmentIncentiveBps = _replenishmentIncentiveBps;\n  liquidationIncentiveBps = _liquidationIncentiveBps;\n  callOnDepositCallback = _callOnDepositCallback;\n  INITIAL_CHAIN_ID = block.chainid;\n  INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n }\n modifier onlyGov {\n  require(msg.sender == gov, \"Only gov can call this function\");\n  _;\n }\n function withdrawInternal(address from, address to, uint amount) internal {\n  uint limit = getWithdrawalLimitInternal(from);\n  require(limit >= amount, \"Insufficient withdrawal limit\");\n  IEscrow escrow = getEscrow(from);\n  escrow.pay(to, amount);\n  emit Withdraw(from, to, amount);\n }\n function withdraw(uint amount) public {\n  withdrawInternal(msg.sender, msg.sender, amount);\n }\n function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n  require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n  unchecked {\naddress recoveredAddress = ecrecover(\n keccak256(\n  abi.encodePacked(\n\"\\x19\\x01\",\nDOMAIN_SEPARATOR(),\nkeccak256(\n abi.encode(\n  keccak256(\n\"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n  ),\n  msg.sender,\n  from,\n  amount,\n  nonces[from]++,\n  deadline\n )\n)\n  )\n ),\n v,\n r,\n s\n);\nrequire(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\nwithdrawInternal(from, msg.sender, amount);\n  }\n }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-10-inverse-findings.json",
                "Location": "withdrawInternal function in Market.sol",
                "Type": "Reentrancy",
                "Description": "ERC777 reentrancy when withdrawing can be used to withdraw all collateral",
                "Repair": "Mark the affected functions as nonReentrant"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n event WalletCredited(address indexed smartWallet, uint256 amount);\n event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n event StakehouseJoined(bytes blsPubKey);\n event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n event NetworkTickerUpdated(string newTicker);\n event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n event NodeRunnerBanned(address indexed nodeRunner);\n event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n address public brand;\n address public override stakehouse;\n address public syndicate;\n address public dao;\n OptionalHouseGatekeeper public gatekeeper;\n ISyndicateFactory public syndicateFactory;\n IOwnableSmartWalletFactory public smartWalletFactory;\n string public stakehouseTicker;\n StakingFundsVault public stakingFundsVault;\n SavETHVault public savETHVault;\n bool public enableWhitelisting;\n mapping(address => bool) public isNodeRunnerWhitelisted;\n mapping(address => address) public smartWalletRepresentative;\n mapping(bytes => address) public smartWalletOfKnot;\n mapping(address => address) public smartWalletOfNodeRunner;\n mapping(address => address) public nodeRunnerOfSmartWallet;\n mapping(address => uint256) public stakedKnotsOfSmartWallet;\n mapping(address => address) public smartWalletDormantRepresentative;\n mapping(bytes => address) public bannedBLSPublicKeys;\n mapping(address => bool) public bannedNodeRunners;\n uint256 public numberOfKnots;\n uint256 public daoCommissionPercentage;\n uint256 public MODULO = 100_00000;\n modifier onlyDAO() {\n  require(msg.sender == dao, \"Must be DAO\");\n  _;\n }\n\n /// @custom:oz-upgrades-unsafe-allow constructor\n constructor() initializer {}\n\n /// @inheritdoc ILiquidStakingManager\n function init(\n  address _dao,\n  address _syndicateFactory,\n  address _smartWalletFactory,\n  address _lpTokenFactory,\n  address _brand,\n  address _savETHVaultDeployer,\n  address _stakingFundsVaultDeployer,\n  address _optionalGatekeeperDeployer,\n  uint256 _optionalCommission,\n  bool _deployOptionalGatekeeper,\n  string calldata _stakehouseTicker\n ) external virtual override initializer {\n  _init(\n_dao,\n_syndicateFactory,\n_smartWalletFactory,\n_lpTokenFactory,\n_brand,\n_savETHVaultDeployer,\n_stakingFundsVaultDeployer,\n_optionalGatekeeperDeployer,\n_optionalCommission,\n_deployOptionalGatekeeper,\n_stakehouseTicker\n  );\n }\n\n\n function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n  require(_recipient != address(0), \"Zero address\");\n  require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n  address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n  require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n  require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n  require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n  require(\ngetAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n\"Initials not registered\"\n  );\n\n  // refund 4 ether from smart wallet to node runner's EOA\n  IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n_recipient,\n\"\",\n4 ether\n  );\n\n  // update the mapping\n  bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n  emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n }\n\n \n function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n  // Use an external deployer to reduce the size of the liquid staking manager\n  savETHVault = SavETHVault(\nSavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n  );\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "LiquidStakingManager.sol#withdrawETHForKnot",
                "Type": "Reentrancy",
                "Description": "The _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.",
                "Repair": "Ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; \ncontract BondNFT is ERC721Enumerable, Ownable {  \n uint constant private DAY = 24 * 60 * 60; \n struct Bond { \n  uint id; \n  address owner; \n  address asset; \n  uint amount; \n  uint mintEpoch; \n  uint mintTime; \n  uint expireEpoch; \n  uint pending; \n  uint shares; \n  uint period; \n  bool expired; \n } \n mapping(address => uint256) public epoch; \n uint private totalBonds; \n string public baseURI; \n address public manager; \n address[] public assets; \n mapping(address => bool) public allowedAsset; \n mapping(address => uint) private assetsIndex; \n mapping(uint256 => mapping(address => uint256)) private bondPaid; \n mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare \n mapping(uint => Bond) private _idToBond; \n mapping(address => uint) public totalShares; \n mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount \n constructor( \n  string memory _setBaseURI, \n  string memory _name, \n  string memory _symbol \n ) ERC721(_name, _symbol) { \n  baseURI = _setBaseURI; \n } \n function claim( \n  uint _id, \n  address _claimer \n ) public onlyManager() returns(uint amount, address tigAsset) { \n  Bond memory bond = idToBond(_id); \n  require(_claimer == bond.owner, \"!owner\"); \n  amount = bond.pending; \n  tigAsset = bond.asset; \n  unchecked { \nif (bond.expired) { \n uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]); \n if (totalShares[bond.asset] > 0) { \n  accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset]; \n } \n} \nbondPaid[_id][bond.asset] += amount; \n  } \n  IERC20(tigAsset).transfer(manager, amount); \n  emit ClaimFees(tigAsset, amount, _claimer, _id); \n } \n \n\n function claimDebt( \n  address _user, \n  address _tigAsset \n ) public onlyManager() returns(uint amount) { \n  amount = userDebt[_user][_tigAsset]; \n  userDebt[_user][_tigAsset] = 0; \n  IERC20(_tigAsset).transfer(manager, amount); \n  emit ClaimDebt(_tigAsset, amount, _user); \n } \n function _mint( \n  address to, \n  Bond memory bond \n ) internal { \n  unchecked { \nbondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18; \n  } \n  _mint(to, bond.id); \n } \n \n function _burn( \n  uint256 _id \n ) internal override { \n  delete _idToBond[_id]; \n  super._burn(_id); \n } \n function _transfer( \n  address from, \n  address to, \n  uint256 _id \n ) internal override { \n  Bond memory bond = idToBond(_id); \n  require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\"); \n  require(!bond.expired, \"Expired!\"); \n  unchecked { \nrequire(block.timestamp > bond.mintTime + 300, \"Recent update\"); \nuserDebt[from][bond.asset] += bond.pending; \nbondPaid[_id][bond.asset] += bond.pending; \n  } \n  super._transfer(from, to, _id); \n } \n function setBaseURI(string calldata _newBaseURI) external onlyOwner { \n  baseURI = _newBaseURI; \n } \n modifier onlyManager() { \n  require(msg.sender == manager, \"!manager\"); \n  _; \n } \n event Distribution(address _tigAsset, uint256 _amount); \n event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id); \n event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id); \n event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id); \n event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id); \n event ClaimDebt(address _tigAsset, uint256 _amount, address _owner); \n} ",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-12-tigris-findings.json",
                "Location": "BondNFT.claim() function",
                "Type": "Reentrancy",
                "Description": "A malicious user can exploit this vulnerability to steal all assets in BondNFT contract by repeatedly calling claim() function of an expired bond, which updates accRewardsPerShare and increases pending rewards of all other users.",
                "Repair": "Forcing an expired bond to release() and adding a check to claim() function to revert if an expired bond is claimed"
            }
        ]
    }
]