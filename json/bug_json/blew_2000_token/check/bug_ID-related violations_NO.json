[
    {
        "Code": "pragma solidity =0.7.6;\npragma abicoder v2;\nimport \"@openzeppelin-0.7/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin-0.7/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./ActionGuards.sol\";\nimport \"./math/SafeInt256.sol\";\nimport \"./stubs/BalanceHandler.sol\";\nimport \"./stubs/TokenHandler.sol\";\nimport \"./global/StorageLayoutV2.sol\";\nimport \"./global/Constants.sol\";\nimport \"interfaces/notional/NotionalTreasury.sol\";\nimport \"interfaces/compound/ComptrollerInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport {WETH9_07 as WETH9} from \"interfaces/WETH9_07.sol\";\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    IERC20 public immutable COMP;\n    Comptroller public immutable COMPTROLLER;\n    WETH9 public immutable WETH;\n    event TreasuryManagerChanged(address indexed previousManager, address indexed newManager);\n    event ReserveBufferUpdated(uint16 currencyId, uint256 bufferAmount);\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Caller is not the treasury manager\");\n        _;\n    }\n    function _checkValidCurrency(uint16 currencyId) internal view {\n        require(0 < currencyId && currencyId <= maxCurrencyId, \"Invalid currency id\");\n    }\n\n    constructor(Comptroller _comptroller, WETH9 _weth) {\n        COMPTROLLER = _comptroller;\n        COMP = IERC20(_comptroller.getCompAddress());\n        WETH = _weth;\n    }\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        (int256 reserveBalance) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n        require(newBalance < reserveBalance, \"cannot increase reserve balance\");\n\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n    function claimCOMPAndTransfer(address[] calldata cTokens)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 balanceBefore = COMP.balanceOf(address(this));\n        COMPTROLLER.claimComp(address(this), cTokens);\n        uint256 balanceAfter = COMP.balanceOf(address(this));\n        uint256 amountClaimed = balanceAfter.sub(balanceBefore);\n        COMP.safeTransfer(treasuryManagerContract, amountClaimed);\n        return amountClaimed;\n    }\n    function _redeemAndTransfer(\n        uint16 currencyId,\n        Token memory asset,\n        int256 assetInternalRedeemAmount\n    ) private returns (uint256) {\n        Token memory underlying = TokenHandler.getUnderlyingToken(currencyId);\n        int256 assetExternalRedeemAmount = asset.convertToExternal(assetInternalRedeemAmount);\n        uint256 redeemedExternalUnderlying = asset\n            .redeem(underlying, assetExternalRedeemAmount.toUint())\n            .toUint();\n        if (underlying.tokenAddress == address(0)) {\n            WETH9(WETH).deposit{value: address(this).balance}();\n        }\n\n        address underlyingAddress = underlying.tokenAddress == address(0)\n            ? address(WETH)\n            : underlying.tokenAddress;\n        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);\n\n        return redeemedExternalUnderlying;\n    }\n    function transferReserveToTreasury(uint16[] calldata currencies)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; i++) {\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n            if (bufferInternal == 0) continue;\n            (int256 reserveInternal, , , ) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n\n            if (reserveInternal <= bufferInternal) continue;\n\n            Token memory asset = TokenHandler.getAssetToken(currencyId);\n\n            int256 assetInternalRedeemAmount = reserveInternal.subNoNeg(bufferInternal);\n\n            amountsTransferred[i] = _redeemAndTransfer(\n                currencyId,\n                asset,\n                assetInternalRedeemAmount\n            );\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                assetInternalRedeemAmount\n            );\n        }\n        return amountsTransferred;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-01-notional#h-01-treasury-cannot-claim-comp-tokens--comp-tokens-are-stuck",
                "Location": "claimCOMPAndTransfer function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Treasury cannot claim COMP tokens & COMP tokens are stuck,The TreasuryAction.claimCOMPAndTransfer function uses pre- and post-balances of the COMP token to check which ones to transfer.Note that anyone can claim COMP tokens on behalf of any address (see Comptroller.claimComp). An attacker can claim COMP tokens on behalf of the contract and it\u2019ll never be able to claim any compound itself. The COMP claimed by the attacker are stuck in the contract and cannot be retrieved. (One can eventually get back the stuck COMP by creating a cCOMP market and then transferring it through transferReserveToTreasury.)",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n\n    enum BorrowType {\n        NOT_CONFIRMED,\n        NON_INSURANCE,\n        USE_INSURANCE\n    }\n\n    struct Position {\n        BorrowType borrowType;\n        uint256 debtPrincipal;\n        uint256 debtPortion;\n        uint256 debtAmountForRepurchase;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    struct VaultSettings {\n        Rate debtInterestApr;\n        Rate creditLimitRate;\n        Rate liquidationLimitRate;\n        Rate valueIncreaseLockRate;\n        Rate organizationFeeRate;\n        Rate insurancePurchaseRate;\n        Rate insuranceLiquidationPenaltyRate;\n        uint256 insuraceRepurchaseTimeLimit;\n        uint256 borrowAmountCap;\n    }\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n\n    IStableCoin public stablecoin;\n    IAggregatorV3Interface public ethAggregator;\n    IAggregatorV3Interface public jpegAggregator;\n    IAggregatorV3Interface public floorOracle;\n    IAggregatorV3Interface public fallbackOracle;\n    IJPEGLock public jpegLocker;\n    IERC721Upgradeable public nftContract;\n    bool public daoFloorOverride;\n\n    bool public useFallbackOracle;\n\n    uint256 public totalDebtAmount;\n\n    uint256 public totalDebtAccruedAt;\n    uint256 public totalFeeCollected;\n    uint256 internal totalDebtPortion;\n\n    VaultSettings public settings;\n\n    EnumerableSetUpgradeable.UintSet private positionIndexes;\n\n    mapping(uint256 => Position) private positions;\n    mapping(uint256 => address) public positionOwner;\n    mapping(bytes32 => uint256) public nftTypeValueETH;\n    mapping(uint256 => uint256) public nftValueETH;\n\n    mapping(uint256 => bytes32) public nftTypes;\n    mapping(uint256 => uint256) public pendingNFTValueETH;\n\n\n    modifier validNFTIndex(uint256 nftIndex) {\n\n        require(nftContract.ownerOf(nftIndex) != address(0), \"invalid_nft\");\n        _;\n    }\n\n    struct NFTCategoryInitializer {\n        bytes32 hash;\n        uint256 valueETH;\n        uint256[] nfts;\n    }\n    function initialize(\n        IStableCoin _stablecoin,\n        IERC721Upgradeable _nftContract,\n        IAggregatorV3Interface _ethAggregator,\n        IAggregatorV3Interface _jpegAggregator,\n        IAggregatorV3Interface _floorOracle,\n        IAggregatorV3Interface _fallbackOracle,\n        NFTCategoryInitializer[] memory _typeInitializers,\n        IJPEGLock _jpegLocker,\n        VaultSettings memory _settings\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DAO_ROLE, msg.sender);\n        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        _validateRate(_settings.debtInterestApr);\n        _validateRate(_settings.creditLimitRate);\n        _validateRate(_settings.liquidationLimitRate);\n        _validateRate(_settings.valueIncreaseLockRate);\n        _validateRate(_settings.organizationFeeRate);\n        _validateRate(_settings.insurancePurchaseRate);\n        _validateRate(_settings.insuranceLiquidationPenaltyRate);\n\n        _validateCreditLimitAndLiquidationRate(\n            _settings.creditLimitRate,\n            _settings.liquidationLimitRate\n        );\n\n        stablecoin = _stablecoin;\n        jpegLocker = _jpegLocker;\n        ethAggregator = _ethAggregator;\n        jpegAggregator = _jpegAggregator;\n        floorOracle = _floorOracle;\n        fallbackOracle = _fallbackOracle;\n        nftContract = _nftContract;\n\n        settings = _settings;\n\n        //initializing the categories\n        for (uint256 i = 0; i < _typeInitializers.length; i++) {\n            NFTCategoryInitializer memory initializer = _typeInitializers[i];\n            nftTypeValueETH[initializer.hash] = initializer.valueETH;\n            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n                nftTypes[initializer.nfts[j]] = initializer.hash;\n            }\n        }\n    }\n\n    function toggleFallbackOracle(bool _useFallback)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        useFallbackOracle = _useFallback;\n    }\n\n    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {\n        jpegLocker.setLockTime(_newLockTime);\n    }\n\n\n    function finalizePendingNFTValueETH(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        uint256 pendingValue = pendingNFTValueETH[_nftIndex];\n        require(pendingValue > 0, \"no_pending_value\");\n        uint256 toLockJpeg = (((pendingValue *\n            _ethPriceUSD() *\n            settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator) *\n            settings.valueIncreaseLockRate.numerator) /\n            settings.valueIncreaseLockRate.denominator /\n            _jpegPriceUSD();\n\n        //lock JPEG using JPEGLock\n        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);\n\n        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;\n        nftValueETH[_nftIndex] = pendingValue;\n        //clear pending value\n        pendingNFTValueETH[_nftIndex] = 0;\n    }\n\n\n    uint256[50] private __gap;\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-04-jpegd#h-02-existing-users-locked-jpeg-could-be-overwritten-by-new-user-causing-permanent-loss-of-jpeg-funds",
                "Location": "jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg); in finalizePendingNFTValueETH function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Existing user\u2019s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds,A user\u2019s JPEG lock schedule can be overwritten by another user\u2019s if he (the other user) submits and finalizes a proposal to change the same NFT index\u2019s value.The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n\n  mapping(uint256 => int256) internal _processedTokenTrackerOf;\n\n\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\n    internal _packedDistributionLimitDataOf;\n\n\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\n    internal _packedOverflowAllowanceDataOf;\n\n \n  IJBProjects public immutable override projects;\n\n \n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n\n  IJBTokenStore public immutable override tokenStore;\n\n \n  IJBSplitsStore public immutable override splitsStore;\n\n  IJBDirectory public immutable override directory;\n\n\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data >> 232);\n  }\n\n\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data >> 232);\n  }\n\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n\n\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n \n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n\n    // Set this contract as the project\"s controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);\n\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n    // Set this contract as the project\"s controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);\n\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n\n\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project\"s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-07-juicebox#h-02-token-change-can-be-frontrun-blocking-token",
                "Location": "tokenStore.changeFor(_projectId, _token, _newOwner); in changeTokenOf function",
                "Type": "ID-related violations",
                "Description": "Shared resource (e.g., token) without proper locks.Token Change Can Be Frontrun, Blocking Token,This vulnerability allows malicious actors to block other users from changing tokens of their projects. Furthermore if ownership over the token contract is transferred to the JBTokenStore contract prior to the change, as suggested in the recourse section of Juicebox\u2019s 24.05.2022 post-mortem update, this vulnerability would allow an attacker to become the owner of tokens being transferred. For JBToken based tokens this would allow an attacker to begin issuing arbitrary amounts the token that was meant to be transferred.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract Nodes_ is ReentrancyGuard {\n     using SafeERC20 for IERC20;\n \n     address public immutable owner;\n     address private immutable FTM;\n     address[] public routers;\n     uint256 public constant minimumAmount = 1000;\n \n     struct SplitStruct {\n         address token;\n         uint256 amount;\n         address firstToken;\n         address secondToken;\n         uint256 percentageFirstToken;\n         uint256 amountOutMinFirst;\n         uint256 amountOutMinSecond;\n     }\n \n     constructor(address _owner, address[] memory _routers) {\n         owner = _owner;\n         routers = _routers;\n         FTM = IUniswapV2Router02(_routers[0]).WETH();\n     }\n \n \n     function mulScale(\n         uint256 x,\n         uint256 y,\n         uint128 scale\n     ) internal pure returns (uint256) {\n         uint256 a = x / scale;\n         uint256 b = x % scale;\n         uint256 c = y / scale;\n         uint256 d = y % scale;\n \n         return a * c * scale + a * d + b * c + (b * d) / scale;\n     }\n \n     function split(\n         SplitStruct memory _splitStruct\n     )\n         public\n         nonReentrant\n         returns (uint256 amountOutToken1, uint256 amountOutToken2)\n     {\n         address _token = _splitStruct.token;\n         uint256 _amount = _splitStruct.amount;\n         address _firstToken = _splitStruct.firstToken;\n         address _secondToken = _splitStruct.secondToken;\n         uint256 _amountOutMinFirst = _splitStruct.amountOutMinFirst;\n         uint256 _amountOutMinSecond = _splitStruct.amountOutMinSecond;\n \n         IUniswapV2Router02 routerIn = getRouterOneToken(_token);\n         IUniswapV2Router02 routerOutFirstToken = getRouterOneToken(_firstToken);\n         IUniswapV2Router02 routerOutSecondToken = getRouterOneToken(_secondToken);\n \n         uint256[] memory amountsOut;\n         if(_token != FTM && (routerIn != routerOutFirstToken || routerIn != routerOutSecondToken)) {\n             IERC20(_token).safeApprove(address(routerIn), _amount);\n \n             address[] memory path = new address[](2);\n             path[0] = _token;\n             path[1] = FTM;\n \n             amountsOut = routerIn.swapExactTokensForTokens(\n                 _amount,\n                 0,\n                 path,\n                 address(this),\n                 block.timestamp\n             );\n \n             _amount = amountsOut[amountsOut.length - 1];\n             _token = FTM;\n         }\n \n         uint256 _firstTokenAmount = mulScale(\n             _amount,\n             _splitStruct.percentageFirstToken,\n             10000\n         ); // Amount of first token.\n         uint256 _secondTokenAmount = _amount - _firstTokenAmount; // Amount of second token.\n \n         if(routerOutFirstToken == routerOutSecondToken && address(routerOutFirstToken) != address(0) && address(routerOutSecondToken) != address(0)) {\n             IERC20(_token).safeApprove(address(routerOutFirstToken), _amount);\n         } else {\n             if(address(routerOutFirstToken) != address(0)) {\n                 IERC20(_token).safeApprove(address(routerOutFirstToken), _firstTokenAmount);\n             }\n             if(address(routerOutSecondToken) != address(0)) {\n                 IERC20(_token).safeApprove(address(routerOutSecondToken), _secondTokenAmount);\n             }\n         }\n         \n         uint256 _amountOutToken1;\n         uint256 _amountOutToken2;\n         if (_token == FTM) {\n             (_amountOutToken1, _amountOutToken2) = _splitFromFTM(\n                 _firstToken,\n                 _secondToken,\n                 _firstTokenAmount,\n                 _secondTokenAmount,\n                 _amountOutMinFirst,\n                 _amountOutMinSecond\n             );\n         } else if (_firstToken == FTM || _secondToken == FTM) {\n             (_amountOutToken1, _amountOutToken2) = _splitToFTM(\n                 _token,\n                 _firstToken,\n                 _secondToken,\n                 _firstTokenAmount,\n                 _secondTokenAmount,\n                 _amountOutMinFirst,\n                 _amountOutMinSecond\n             );\n         } else {\n             if (_firstToken != _token) {\n                 address[] memory pathFirstToken = new address[](3);\n                 pathFirstToken[0] = _token;\n                 pathFirstToken[1] = FTM;\n                 pathFirstToken[2] = _firstToken;\n \n                 amountsOut = routerOutFirstToken.swapExactTokensForTokens(\n                     _firstTokenAmount,\n                     _amountOutMinFirst,\n                     pathFirstToken,\n                     address(msg.sender),\n                     block.timestamp\n                 );\n \n                 _amountOutToken1 = amountsOut[amountsOut.length - 1];\n             } else {\n                 _amountOutToken1 = _firstTokenAmount;\n                 IERC20(_firstToken).safeTransfer(msg.sender, _firstTokenAmount);\n             }\n \n             if (_secondToken != _token) {\n                 address[] memory pathSecondToken = new address[](3);\n                 pathSecondToken[0] = _token;\n                 pathSecondToken[1] = FTM;\n                 pathSecondToken[2] = _secondToken;\n \n                 amountsOut = routerOutSecondToken.swapExactTokensForTokens(\n                     _secondTokenAmount,\n                     _amountOutMinSecond,\n                     pathSecondToken,\n                     address(msg.sender),\n                     block.timestamp\n                 );\n \n                 _amountOutToken2 = amountsOut[amountsOut.length - 1];\n             } else {\n                 _amountOutToken2 = _secondTokenAmount;\n                 IERC20(_secondToken).safeTransfer(msg.sender, _secondTokenAmount);\n             }\n         }\n \n         return (_amountOutToken1, _amountOutToken2);\n     }\n \n     function _splitFromFTM(\n         address _firstToken,\n         address _secondToken,\n         uint256 _firstTokenAmount,\n         uint256 _secondTokenAmount,\n         uint256 _amountOutMinFirst,\n         uint256 _amountOutMinSecond\n     ) private returns (uint256 amountOutToken1, uint256 amountOutToken2) {\n         uint256[] memory amountsOut;\n \n         uint256 _amountOutToken1;\n         if (_firstToken != FTM) {\n             IUniswapV2Router02 routerOutFirstToken = getRouterOneToken(_firstToken);\n \n             address[] memory pathFirstToken = new address[](2);\n             pathFirstToken[0] = FTM;\n             pathFirstToken[1] = _firstToken;\n \n             amountsOut = routerOutFirstToken.swapExactTokensForTokens(\n                 _firstTokenAmount,\n                 _amountOutMinFirst,\n                 pathFirstToken,\n                 msg.sender,\n                 block.timestamp\n             );\n \n             _amountOutToken1 = amountsOut[amountsOut.length - 1];\n         } else {\n             _amountOutToken1 = _firstTokenAmount;\n             IERC20(_firstToken).safeTransfer(msg.sender, _firstTokenAmount);\n         }\n \n         uint256 _amountOutToken2;\n         if (_secondToken != FTM) {\n             IUniswapV2Router02 routerOutSecondToken = getRouterOneToken(_secondToken);\n \n             address[] memory pathSecondToken = new address[](2);\n             pathSecondToken[0] = FTM;\n             pathSecondToken[1] = _secondToken;\n \n             amountsOut = routerOutSecondToken.swapExactTokensForTokens(\n                 _secondTokenAmount,\n                 _amountOutMinSecond,\n                 pathSecondToken,\n                 address(msg.sender),\n                 block.timestamp\n             );\n \n             _amountOutToken2 = amountsOut[amountsOut.length - 1];\n         } else {\n             _amountOutToken2 = _secondTokenAmount;\n             IERC20(_secondToken).safeTransfer(msg.sender, _secondTokenAmount);\n         }\n \n         return (_amountOutToken1, _amountOutToken2);\n     }\n \n     function _splitToFTM(\n         address _token,\n         address _firstToken,\n         address _secondToken,\n         uint256 _firstTokenAmount,\n         uint256 _secondTokenAmount,\n         uint256 _amountOutMinFirst,\n         uint256 _amountOutMinSecond\n     ) private returns (uint256 amountOutToken1, uint256 amountOutToken2) {\n         IUniswapV2Router02 routerOutFirstToken;\n         IUniswapV2Router02 routerOutSecondToken;\n \n         uint256[] memory amountsOut;\n         uint256 _amountOutToken1;\n         uint256 _amountOutToken2;\n         if (_firstToken == FTM) {\n             if (_firstToken != _token) {\n                 routerOutFirstToken = getRouterOneToken(FTM);\n \n                 address[] memory pathFirstToken = new address[](2);\n                 pathFirstToken[0] = _token;\n                 pathFirstToken[1] = FTM;\n \n                 amountsOut = routerOutFirstToken.swapExactTokensForTokens(\n                     _firstTokenAmount,\n                     _amountOutMinFirst,\n                     pathFirstToken,\n                     address(msg.sender),\n                     block.timestamp\n                 );\n \n                 _amountOutToken1 = amountsOut[amountsOut.length - 1];\n             } else {\n                 _amountOutToken1 = _firstTokenAmount;\n                 IERC20(_firstToken).safeTransfer(msg.sender, _firstTokenAmount);\n             }\n \n             if (_secondToken != _token) {\n                 routerOutSecondToken = getRouterOneToken(_secondToken);\n \n                 address[] memory pathSecondToken;\n                 if(_secondToken == FTM) {\n                     pathSecondToken = new address[](2);\n                     pathSecondToken[0] = _token;\n                     pathSecondToken[1] = FTM;\n                 } else {\n                     pathSecondToken = new address[](3);\n                     pathSecondToken[0] = _token;\n                     pathSecondToken[1] = FTM;\n                     pathSecondToken[2] = _secondToken;\n                 }\n \n                 amountsOut = routerOutSecondToken.swapExactTokensForTokens(\n                     _secondTokenAmount,\n                     _amountOutMinSecond,\n                     pathSecondToken,\n                     address(msg.sender),\n                     block.timestamp\n                 );\n \n                 _amountOutToken2 = amountsOut[amountsOut.length - 1];\n             } else {\n                 _amountOutToken2 = _secondTokenAmount;\n                 IERC20(_secondToken).safeTransfer(msg.sender, _secondTokenAmount);\n             }\n         } else if (_secondToken == FTM) {\n             if (_firstToken != _token) {\n                 routerOutFirstToken = getRouterOneToken(_firstToken);\n \n                 address[] memory pathFirstToken;\n                 if(_firstToken == FTM) {\n                     pathFirstToken = new address[](2);\n                     pathFirstToken[0] = _token;\n                     pathFirstToken[1] = FTM;\n                 } else {\n                     pathFirstToken = new address[](3);\n                     pathFirstToken[0] = _token;\n                     pathFirstToken[1] = FTM;\n                     pathFirstToken[2] = _firstToken;\n                 }\n \n                 amountsOut = routerOutFirstToken.swapExactTokensForTokens(\n                     _firstTokenAmount,\n                     _amountOutMinFirst,\n                     pathFirstToken,\n                     address(msg.sender),\n                     block.timestamp\n                 );\n \n                 _amountOutToken1 = amountsOut[amountsOut.length - 1];\n             } else {\n                 _amountOutToken1 = _firstTokenAmount;\n                 IERC20(_firstToken).safeTransfer(msg.sender, _firstTokenAmount);\n             }\n \n             if (_secondToken != _token) {\n                 routerOutSecondToken = getRouterOneToken(FTM);\n \n                 address[] memory pathSecondToken = new address[](2);\n                 pathSecondToken[0] = _token;\n                 pathSecondToken[1] = FTM;\n \n                 amountsOut = routerOutSecondToken.swapExactTokensForTokens(\n                     _secondTokenAmount,\n                     _amountOutMinSecond,\n                     pathSecondToken,\n                     address(msg.sender),\n                     block.timestamp\n                 );\n \n                 _amountOutToken2 = amountsOut[amountsOut.length - 1];\n             } else {\n                 _amountOutToken2 = _secondTokenAmount;\n                 IERC20(_secondToken).safeTransfer(msg.sender, _secondTokenAmount);\n             }\n         }\n \n         return (_amountOutToken1, _amountOutToken2);\n     }\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-TortleNinja-v1.0/3.2 Missed Access Control in Nodes_::split()",
                "Location": "split function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.The Nodes_ contract provides a routine (i.e. split() ) to divide one token into two tokens according to the selected percentage. Before calling this routine, the user has to send the token to this contract. However there\u2019s a lack of proper access control validation at the beginning of this routine, which results in potential assets loss in this contract if user doesn\u2019t transfer in enough tokens first. Although currently this contract is not designed to store user assets, which greatly alleviates this concern, it\u2019s still suggested to add proper access control to the split() routine. Per our further study in the protocol, we can only allow the Nodes contract to call this routine.",
                "Repair": "Add proper access control to the above routines"
            }
        ]
    },
    {
        "Code": "contract Nodes_ is ReentrancyGuard {\n     using SafeERC20 for IERC20;\n \n     address public immutable owner;\n     address private immutable FTM;\n     address[] public routers;\n     uint256 public constant minimumAmount = 1000;\n \n     struct SplitStruct {\n         address token;\n         uint256 amount;\n         address firstToken;\n         address secondToken;\n         uint256 percentageFirstToken;\n         uint256 amountOutMinFirst;\n         uint256 amountOutMinSecond;\n     }\n \n     constructor(address _owner, address[] memory _routers) {\n         owner = _owner;\n         routers = _routers;\n         FTM = IUniswapV2Router02(_routers[0]).WETH();\n     }\n \n \n     function mulScale(\n         uint256 x,\n         uint256 y,\n         uint128 scale\n     ) internal pure returns (uint256) {\n         uint256 a = x / scale;\n         uint256 b = x % scale;\n         uint256 c = y / scale;\n         uint256 d = y % scale;\n \n         return a * c * scale + a * d + b * c + (b * d) / scale;\n     }\n\n     function swapTokens(\n         address _tokenIn,\n         uint256 _amount,\n         address _tokenOut,\n         uint256 _amountOutMin\n     ) public nonReentrant returns (uint256 amountOut) {\n         IUniswapV2Router02 routerIn = getRouterOneToken(_tokenIn);\n         IUniswapV2Router02 routerOut = getRouterOneToken(_tokenOut);\n \n         uint256[] memory amountsOut;\n         if(_tokenIn != FTM && routerIn != routerOut) {\n             IERC20(_tokenIn).safeApprove(address(routerIn), _amount);\n \n             address[] memory path = new address[](2);\n             path[0] = _tokenIn;\n             path[1] = FTM;\n \n             amountsOut = routerIn.swapExactTokensForTokens(\n                 _amount,\n                 _amountOutMin,\n                 path,\n                 address(this),\n                 block.timestamp\n             );\n \n             _amount = amountsOut[amountsOut.length - 1];\n             _tokenIn = FTM;\n         }\n         \n         IERC20(_tokenIn).safeApprove(address(routerOut), _amount);\n         \n         uint256 _amountOut;\n         if(_tokenIn != _tokenOut) {\n             if (_tokenIn == FTM || _tokenOut == FTM) {\n                 address[] memory path = new address[](2);\n                 path[0] = _tokenIn;\n                 path[1] = _tokenOut;\n \n                 amountsOut = routerOut.swapExactTokensForTokens(\n                     _amount,\n                     _amountOutMin,\n                     path,\n                     address(msg.sender),\n                     block.timestamp\n                 );\n \n                 _amountOut = amountsOut[amountsOut.length - 1];\n             } else {\n                 address[] memory path = new address[](3);\n                 path[0] = _tokenIn;\n                 path[1] = FTM;\n                 path[2] = _tokenOut;\n \n                 amountsOut = routerOut.swapExactTokensForTokens(\n                     _amount,\n                     _amountOutMin,\n                     path,\n                     address(msg.sender),\n                     block.timestamp\n                 );\n \n                 _amountOut = amountsOut[amountsOut.length - 1];\n             }\n         } else {\n             _amountOut = _amount;\n         }\n \n         return _amountOut;\n     }\n \n     function getRouter(address _token0, address _token1) public view returns(IUniswapV2Router02 router) {\n         address pairToken0;\n         address pairToken1;\n         for(uint8 i = 0; i < routers.length; i++) {\n             if(_token0 == FTM || _token1 == FTM){\n                 router = IUniswapV2Router02(routers[i]);\n                 break;\n             } else {\n                 pairToken0 = IUniswapV2Factory(IUniswapV2Router02(routers[i]).factory()).getPair(_token0, FTM);\n                 if(pairToken0 != address(0)) {\n                     pairToken1 = IUniswapV2Factory(IUniswapV2Router02(routers[i]).factory()).getPair(_token1, FTM);\n                 }\n             }\n             if(pairToken1 != address(0)) {\n                 router = IUniswapV2Router02(routers[i]);\n             }\n         }\n \n         require(address(router) != address(0), \"Pair doesn't exists.\");\n     }\n \n     function getRouterOneToken(address _token) public view returns(IUniswapV2Router02 router) {\n         address pair;\n         for(uint8 i = 0; i < routers.length; i++) {\n             if(_token == FTM){\n                 router = IUniswapV2Router02(routers[i]);\n                 break;\n             } else {\n                 pair = IUniswapV2Factory(IUniswapV2Router02(routers[i]).factory()).getPair(_token, FTM);\n             }\n             if(pair != address(0)) {\n                 router = IUniswapV2Router02(routers[i]);\n             }\n         }\n \n         require(address(router) != address(0), \"Pair doesn't exists.\");\n     }\n \n     receive() external payable {}\n }",
        "VulnerabilityDesc": [
            {
                "Name": "/PeckShield/PeckShield-Audit-Report-TortleNinja-v1.0/3.2 Missed Access Control in Nodes_::swapTokens()",
                "Location": "swapTokens function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.The Nodes_ contract provides a routine (i.e. split() ) to divide one token into two tokens according to the selected percentage. Before calling this routine, the user has to send the token to this contract. However there\u2019s a lack of proper access control validation at the beginning of this routine, which results in potential assets loss in this contract if user doesn\u2019t transfer in enough tokens first. Although currently this contract is not designed to store user assets, which greatly alleviates this concern, it\u2019s still suggested to add proper access control to the split() routine. Per our further study in the protocol, we can only allow the Nodes contract to call this routine.",
                "Repair": "Add proper access control to the above routines"
            }
        ]
    },
    {
        "Code": "contract Zap is AccessControlDefended {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    IBadgerSettPeak public constant settPeak = IBadgerSettPeak(0x41671BA1abcbA387b9b2B752c205e22e916BE6e3);\n    IByvWbtcPeak public constant byvWbtcPeak = IByvWbtcPeak(0x825218beD8BE0B30be39475755AceE0250C50627);\n    IbBTC public constant ibbtc = IbBTC(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);\n\n    IERC20 public constant ren = IERC20(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);\n    IERC20 public constant wbtc = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n\n    struct Pool {\n        IERC20 lpToken;\n        ICurveFi deposit;\n        ISett sett;\n    }\n    Pool[4] public pools;\n\n    constructor() public {\n        pools[0] = Pool({ // crvRenWBTC [ ren, wbtc ]\n            lpToken: IERC20(0x49849C98ae39Fff122806C06791Fa73784FB3675),\n            deposit: ICurveFi(0x93054188d876f558f4a66B2EF1d97d16eDf0895B),\n            sett: ISett(0x6dEf55d2e18486B9dDfaA075bc4e4EE0B28c1545)\n        });\n        pools[1] = Pool({ // crvRenWSBTC [ ren, wbtc, sbtc ]\n            lpToken: IERC20(0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3),\n            deposit: ICurveFi(0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714),\n            sett: ISett(0xd04c48A53c111300aD41190D63681ed3dAd998eC)\n        });\n        pools[2] = Pool({ // tbtc-sbtcCrv [ tbtc, ren, wbtc, sbtc ]\n            lpToken: IERC20(0x64eda51d3Ad40D56b9dFc5554E06F94e1Dd786Fd),\n            deposit: ICurveFi(0xaa82ca713D94bBA7A89CEAB55314F9EfFEdDc78c),\n            sett: ISett(0xb9D076fDe463dbc9f915E5392F807315Bf940334)\n        });\n        pools[3] = Pool({ // Exclusive to wBTC\n            lpToken: wbtc,\n            deposit: ICurveFi(0x0),\n            sett: ISett(0x4b92d19c11435614CD49Af1b589001b7c08cD4D5) // byvWbtc\n        });\n\n        // Since we don't hold any tokens in this contract, we can optimize gas usage in mint calls by providing infinite approvals\n        for (uint i = 0; i < pools.length; i++) {\n            Pool memory pool = pools[i];\n            pool.lpToken.safeApprove(address(pool.sett), uint(-1));\n            if (i < 3) {\n                ren.safeApprove(address(pool.deposit), uint(-1));\n                wbtc.safeApprove(address(pool.deposit), uint(-1));\n                IERC20(address(pool.sett)).safeApprove(address(settPeak), uint(-1));\n            } else {\n                IERC20(address(pool.sett)).safeApprove(address(byvWbtcPeak), uint(-1));\n            }\n        }\n    }\n\n    function mint(IERC20 token, uint amount, uint poolId, uint idx, uint minOut)\n        external\n        defend\n        blockLocked\n        returns(uint _ibbtc)\n    {\n        Pool memory pool = pools[poolId];\n\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (poolId < 3) { // setts\n            _addLiquidity(pool.deposit, amount, poolId + 2, idx); // pools are such that the #tokens they support is +2 from their poolId.\n            pool.sett.deposit(pool.lpToken.balanceOf(address(this)));\n            _ibbtc = settPeak.mint(poolId, pool.sett.balanceOf(address(this)), new bytes32[](0));\n        } else if (poolId == 3) { // byvwbtc\n            IbyvWbtc(address(pool.sett)).deposit(new bytes32[](0)); // pulls all available\n            _ibbtc = byvWbtcPeak.mint(pool.sett.balanceOf(address(this)), new bytes32[](0));\n        } else {\n            revert(\"INVALID_POOL_ID\");\n        }\n\n        require(_ibbtc >= minOut, \"INSUFFICIENT_IBBTC\"); // used for capping slippage in curve pools\n        IERC20(address(ibbtc)).safeTransfer(msg.sender, _ibbtc);\n    }\n\n    function _addLiquidity(ICurveFi pool, uint amount, uint numTokens, uint idx) internal {\n        if (numTokens == 2) {\n            uint[2] memory amounts;\n            amounts[idx] = amount;\n            pool.add_liquidity(amounts, 0);\n        }\n\n        if (numTokens == 3) {\n            uint[3] memory amounts;\n            amounts[idx] = amount;\n            pool.add_liquidity(amounts, 0);\n        }\n\n        if (numTokens == 4) {\n            uint[4] memory amounts;\n            amounts[idx] = amount;\n            pool.add_liquidity(amounts, 0);\n        }\n    }\n\n    function calcMint(address token, uint amount) external view returns(uint poolId, uint idx, uint bBTC, uint fee) {\n        if (token == address(ren)) {\n            return calcMintWithRen(amount);\n        }\n        if (token == address(wbtc)) {\n            return calcMintWithWbtc(amount);\n        }\n        revert(\"INVALID_TOKEN\");\n    }\n\n    function calcMintWithRen(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {\n        uint _ibbtc;\n        uint _fee;\n\n        // poolId=0, idx=0\n        (bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([amount,0], true));\n\n        (_ibbtc, _fee) = curveLPToIbbtc(1, pools[1].deposit.calc_token_amount([amount,0,0], true));\n        if (_ibbtc > bBTC) {\n            bBTC = _ibbtc;\n            fee = _fee;\n            poolId = 1;\n            // idx=0\n        }\n\n        (_ibbtc, _fee) = curveLPToIbbtc(2, pools[2].deposit.calc_token_amount([0,amount,0,0], true));\n        if (_ibbtc > bBTC) {\n            bBTC = _ibbtc;\n            fee = _fee;\n            poolId = 2;\n            idx = 1;\n        }\n    }\n\n    function calcMintWithWbtc(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {\n        uint _ibbtc;\n        uint _fee;\n\n        // poolId=0\n        (bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([0,amount], true));\n        idx = 1;\n\n        (_ibbtc, _fee) = curveLPToIbbtc(1, pools[1].deposit.calc_token_amount([0,amount,0], true));\n        if (_ibbtc > bBTC) {\n            bBTC = _ibbtc;\n            fee = _fee;\n            poolId = 1;\n            // idx=1\n        }\n\n        (_ibbtc, _fee) = curveLPToIbbtc(2, pools[2].deposit.calc_token_amount([0,0,amount,0], true));\n        if (_ibbtc > bBTC) {\n            bBTC = _ibbtc;\n            fee = _fee;\n            poolId = 2;\n            idx = 2;\n        }\n\n        // for byvwbtc, sett.pricePerShare returns a wbtc value, as opposed to lpToken amount in setts\n        (_ibbtc, _fee) = byvWbtcPeak.calcMint(amount.mul(1e8).div(IbyvWbtc(address(pools[3].sett)).pricePerShare()));\n        if (_ibbtc > bBTC) {\n            bBTC = _ibbtc;\n            fee = _fee;\n            poolId = 3;\n            // idx value will be ignored anyway\n        }\n    }\n    function curveLPToIbbtc(uint poolId, uint _lp) public view returns(uint bBTC, uint fee) {\n        Pool memory pool = pools[poolId];\n        uint _sett = _lp.mul(1e18).div(pool.sett.getPricePerFullShare());\n        return settPeak.calcMint(poolId, _sett);\n    }\n}\n\ninterface ICurveFi {\n    function add_liquidity(uint[2] calldata amounts, uint min_mint_amount) external;\n    function calc_token_amount(uint[2] calldata amounts, bool isDeposit) external view returns(uint);\n\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;\n    function calc_token_amount(uint[3] calldata amounts, bool isDeposit) external view returns(uint);\n\n    function add_liquidity(uint[4] calldata amounts, uint min_mint_amount) external;\n    function calc_token_amount(uint[4] calldata amounts, bool isDeposit) external view returns(uint);\n}\n\ninterface IyvWbtc {\n    function deposit(uint) external;\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/Quantstamp/badger-ib-btc.pdf/QSP-6 Lack of validation for arbitrary input token may lead to stolen token credit",
                "Location": "safeTransferFrom function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Currently in Zap, the method does not check for whether the input token are the desired wBTC or renBTC addresses. Therefore, given that the only check for token is in the form of safeTransferFrom a specified amount, it is possible to set token to some arbitrary worthless token address to steal any underlying wBTC or renBTC on the Zap contract",
                "Repair": "Validate that the input token is either in the expected renBTC or wBTC address"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.10;\n\n\ncontract WorldFootball is Context, IERC20 { \n    using SafeMath for uint256;\n    using Address for address;\n\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) public _isExcludedFromFee; \n\n    address payable public Wallet_Game = payable(0x8a4fA360a46B9467f6b0decE101bBf9a99405C9C); \n    address payable public Wallet_Dev = payable(0x15805a0F423c87Cc2293b4c5a3129a1A2F2E6118);\n    address payable public constant Wallet_Burn = payable(0x000000000000000000000000000000000000dEaD); \n\n\n    uint256 private constant MAX = ~uint256(0);\n    uint8 private constant _decimals = 9;\n    uint256 private _tTotal = 10**11 * 10**_decimals;\n    string private constant _name = \"World Football\"; \n    string private constant _symbol = unicode\"WOFO\"; \n\n    uint8 private txCount = 0;\n    uint8 private swapTrigger = 10; \n\n    uint256 public _Tax_On_Buy = 12;\n    uint256 public _Tax_On_Sell = 12;\n\n    uint256 public Percent_Game = 50;\n    uint256 public Percent_Dev = 30;\n    uint256 public Percent_Burn = 0;\n    uint256 public Percent_AutoLP = 20; \n                                      \n    IUniswapV2Router02 public uniswapV2Router;\n    address public uniswapV2Pair;\n    bool public inSwapAndLiquify;\n    bool public swapAndLiquifyEnabled = true;\n    \n    event SwapAndLiquifyEnabledUpdated(bool true_or_false);\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n        \n    );\n    \n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n    \n    constructor () {\n\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n\n        _tOwned[owner()] = _tTotal;\n        \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); \n        //IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); // Testnet\n        \n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n        uniswapV2Router = _uniswapV2Router;\n\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[Wallet_Game] = true; \n        _isExcludedFromFee[Wallet_Burn] = true;\n\n        emit Transfer(address(0), owner(), _tTotal);\n\n    }\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n     function swapTokensForBNB(uint256 tokenAmount) private {\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, \n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n    function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.addLiquidityETH{value: BNBAmount}(\n            address(this),\n            tokenAmount,\n            0, \n            0,\n            Wallet_Burn, \n            block.timestamp\n        );\n    } \n\n\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee, bool isBuy) private {\n        \n        \n        if(!takeFee){\n\n            _tOwned[sender] = _tOwned[sender]-tAmount;\n            _tOwned[recipient] = _tOwned[recipient]+tAmount;\n            emit Transfer(sender, recipient, tAmount);\n\n            if(recipient == Wallet_Burn)\n            _tTotal = _tTotal-tAmount;\n\n            } else if (isBuy){\n\n            uint256 buyFEE = tAmount*_Tax_On_Buy/100;\n            uint256 tTransferAmount = tAmount-buyFEE;\n\n            _tOwned[sender] = _tOwned[sender]-tAmount;\n            _tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n            _tOwned[address(this)] = _tOwned[address(this)]+buyFEE;   \n            emit Transfer(sender, recipient, tTransferAmount);\n\n            if(recipient == Wallet_Burn)\n            _tTotal = _tTotal-tTransferAmount;\n            \n            } else {\n\n            uint256 sellFEE = tAmount*_Tax_On_Sell/100;\n            uint256 tTransferAmount = tAmount-sellFEE;\n\n            _tOwned[sender] = _tOwned[sender]-tAmount;\n            _tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n            _tOwned[address(this)] = _tOwned[address(this)]+sellFEE;   \n            emit Transfer(sender, recipient, tTransferAmount);\n\n            if(recipient == Wallet_Burn)\n            _tTotal = _tTotal-tTransferAmount;\n\n\n            }\n\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "certik/CertiK-Audit-for-World-Football-v2.pdf/Lack of Access Control",
                "Location": "renounceOwnership function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.The function renounceOwnership() is public and can be called by anyone to renounce ownership",
                "Repair": "We advise the client to set up access controls over the functions so only authorized users can call the function"
            }
        ]
    },
    {
        "Code": "contract TransmuterD8 is Context {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20Burnable;\n    using Address for address;\n\n    address public constant ZERO_ADDRESS = address(0);\n    uint256 public TRANSMUTATION_PERIOD;\n\n    address public WaToken;\n    address public Token;\n\n    mapping(address => uint256) public depositedWaTokens;\n    mapping(address => uint256) public tokensInBucket;\n    mapping(address => uint256) public realisedTokens;\n    mapping(address => uint256) public lastDividendPoints;\n\n    mapping(address => bool) public userIsKnown;\n    mapping(uint256 => address) public userList;\n    uint256 public nextUser;\n\n    uint256 public totalSupplyWaTokens;\n    uint256 public buffer;\n    uint256 public lastDepositBlock;\n\n\n    uint256 public pointMultiplier = 10e8;\n\n    uint256 public totalDividendPoints;\n    uint256 public unclaimedDividends;\n\n\n    mapping (address => bool) public whiteList;\n\n\n    address public governance;\n\n\n    address public pendingGovernance;\n\n    event GovernanceUpdated(\n        address governance\n    );\n\n    event PendingGovernanceUpdated(\n        address pendingGovernance\n    );\n\n    event TransmuterPeriodUpdated(\n        uint256 newTransmutationPeriod\n    );\n\n    constructor(address _WaToken, address _Token, address _governance) public {\n        require(_governance != ZERO_ADDRESS, \"TransmuterD8: 0 gov\");\n        governance = _governance;\n        WaToken = _WaToken;\n        Token = _Token;\n        TRANSMUTATION_PERIOD = 50;\n    }\n\n\n    function dividendsOwing(address account) public view returns (uint256) {\n        uint256 newDividendPoints = totalDividendPoints.sub(lastDividendPoints[account]);\n        return depositedWaTokens[account].mul(newDividendPoints).div(pointMultiplier);\n    }\n\n    modifier updateAccount(address account) {\n        uint256 owing = dividendsOwing(account);\n        if (owing > 0) {\n            unclaimedDividends = unclaimedDividends.sub(owing);\n            tokensInBucket[account] = tokensInBucket[account].add(owing);\n        }\n        lastDividendPoints[account] = totalDividendPoints;\n        _;\n    }\n    modifier checkIfNewUser() {\n        if (!userIsKnown[msg.sender]) {\n            userList[nextUser] = msg.sender;\n            userIsKnown[msg.sender] = true;\n            nextUser++;\n        }\n        _;\n    }\n\n    modifier runPhasedDistribution() {\n        uint256 _lastDepositBlock = lastDepositBlock;\n        uint256 _currentBlock = block.number;\n        uint256 _toDistribute = 0;\n        uint256 _buffer = buffer;\n\n        if (_buffer > 0) {\n          \n            uint256 deltaTime = _currentBlock.sub(_lastDepositBlock);\n\n            if(deltaTime >= TRANSMUTATION_PERIOD) {\n                _toDistribute = _buffer;\n            } else {\n\n                if(_buffer.mul(deltaTime) > TRANSMUTATION_PERIOD)\n                {\n                    _toDistribute = _buffer.mul(deltaTime).div(TRANSMUTATION_PERIOD);\n                }\n            }\n\n            if(_toDistribute > 0){\n\n                buffer = _buffer.sub(_toDistribute);\n\n                increaseAllocations(_toDistribute);\n            }\n        }\n\n        lastDepositBlock = _currentBlock;\n        _;\n    }\n    modifier onlyWhitelisted() {\n        require(whiteList[msg.sender], \"TransmuterD8: !whitelisted\");\n        _;\n    }\n    modifier onlyGov() {\n        require(msg.sender == governance, \"TransmuterD8: !governance\");\n        _;\n    }\n\n    function distribute(address origin, uint256 amount) public onlyWhitelisted() runPhasedDistribution() {\n        IERC20Burnable(Token).safeTransferFrom(origin, address(this), amount);\n        buffer = buffer.add(amount);\n    }\n    function increaseAllocations(uint256 amount) internal {\n        if(totalSupplyWaTokens > 0 && amount > 0) {\n            totalDividendPoints = totalDividendPoints.add(\n                amount.mul(pointMultiplier).div(totalSupplyWaTokens)\n            );\n            unclaimedDividends = unclaimedDividends.add(amount);\n        } else {\n            buffer = buffer.add(amount);\n        }\n    }\n    function userInfo(address user)\n        public\n        view\n        returns (\n            uint256 depositedAl,\n            uint256 pendingdivs,\n            uint256 inbucket,\n            uint256 realised\n        )\n    {\n        uint256 _depositedAl = depositedWaTokens[user];\n        uint256 _toDistribute = buffer.mul(block.number.sub(lastDepositBlock)).div(TRANSMUTATION_PERIOD);\n        if(block.number.sub(lastDepositBlock) > TRANSMUTATION_PERIOD){\n            _toDistribute = buffer;\n        }\n        uint256 _pendingdivs = _toDistribute.mul(depositedWaTokens[user]).div(totalSupplyWaTokens);\n        uint256 _inbucket = tokensInBucket[user].add(dividendsOwing(user));\n        uint256 _realised = realisedTokens[user];\n        return (_depositedAl, _pendingdivs, _inbucket, _realised);\n    }\n    function getMultipleUserInfo(uint256 from, uint256 to)\n        public\n        view\n        returns (address[] memory theUserList, uint256[] memory theUserData)\n    {\n        uint256 i = from;\n        uint256 delta = to - from;\n        address[] memory _theUserList = new address[](delta); //user\n        uint256[] memory _theUserData = new uint256[](delta * 2); //deposited-bucket\n        uint256 y = 0;\n        uint256 _toDistribute = buffer.mul(block.number.sub(lastDepositBlock)).div(TRANSMUTATION_PERIOD);\n        if(block.number.sub(lastDepositBlock) > TRANSMUTATION_PERIOD){\n            _toDistribute = buffer;\n        }\n        for (uint256 x = 0; x < delta; x += 1) {\n            _theUserList[x] = userList[i];\n            _theUserData[y] = depositedWaTokens[userList[i]];\n            _theUserData[y + 1] = dividendsOwing(userList[i]).add(tokensInBucket[userList[i]]).add(_toDistribute.mul(depositedWaTokens[userList[i]]).div(totalSupplyWaTokens));\n            y += 2;\n            i += 1;\n        }\n        return (_theUserList, _theUserData);\n    }\n    function bufferInfo() public view returns (uint256 _toDistribute, uint256 _deltaBlocks, uint256 _buffer){\n        _deltaBlocks = block.number.sub(lastDepositBlock);\n        _buffer = buffer; \n        _toDistribute = _buffer.mul(_deltaBlocks).div(TRANSMUTATION_PERIOD);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "certik/REP-Wasabix-yum-2021-07-05.pdf/Minimize The Scope of Access To The Function",
                "Location": "distribute function",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation.As the comment indicates in LXX This function is meant to be called by the Alchemist contract for when it is sending the yield to the transmuter. , the function distribute() should only be called by Alchemist contract. However, currently a whitelist is adopted to restrict the accesses to the distribute() function, which may have the potential to add non-Alchemist address into it.",
                "Repair": "We advise the client to stored the Alchemist contract addresses in immutable variables and initialized them in the constructor of e.g the TransmuterD8 contract."
            }
        ]
    },
    {
        "Code": "contract StakeManager is IStakeManager, Shared, ReentrancyGuard, IERC777Recipient {\n\n    uint public constant STAN_STAKE = 10000 * _E_18;\n    uint public constant BLOCKS_IN_EPOCH = 100;\n    bytes private constant _stakingIndicator = \"staking\";\n\n    IOracle private immutable _oracle;\n\n    IERC777 private _AUTO;\n    bool private _AUTOSet = false;\n    IERC1820Registry constant private _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256('ERC777TokensRecipient');\n    uint private _totalStaked = 0;\n    Executor private _executor;\n    mapping(address => uint) private _stakerToStakedAmount;\n    address[] private _stakes;\n\n\n\n    event Staked(address staker, uint amount);\n    event Unstaked(address staker, uint amount);\n\n\n    constructor(IOracle oracle) {\n        _oracle = oracle;\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n    }\n\n\n    function setAUTO(IERC777 AUTO) external {\n        require(!_AUTOSet, \"SM: AUTO already set\");\n        _AUTOSet = true;\n        _AUTO = AUTO;\n    }\n\n\n    function getOracle() external view override returns (IOracle) {\n        return _oracle;\n    }\n\n    function getAUTOAddr() external view override returns (address) {\n        return address(_AUTO);\n    }\n\n    function getTotalStaked() external view override returns (uint) {\n        return _totalStaked;\n    }\n\n    function getStake(address staker) external view override returns (uint) {\n        return _stakerToStakedAmount[staker];\n    }\n\n    function getStakes() external view override returns (address[] memory) {\n        return _stakes;\n    }\n\n    function getStakesLength() external view override returns (uint) {\n        return _stakes.length;\n    }\n\n    function getStakesSlice(uint startIdx, uint endIdx) external view override returns (address[] memory) {\n        address[] memory slice = new address[](endIdx - startIdx);\n        uint sliceIdx = 0;\n        for (uint stakeIdx = startIdx; stakeIdx < endIdx; stakeIdx++) {\n            slice[sliceIdx] = _stakes[stakeIdx];\n            sliceIdx++;\n        }\n\n        return slice;\n    }\n\n    function getCurEpoch() public view override returns (uint96) {\n        return uint96((block.number / BLOCKS_IN_EPOCH) * BLOCKS_IN_EPOCH);\n    }\n\n    function getExecutor() external view override returns (Executor memory) {\n        return _executor;\n    }\n\n    function isCurExec(address addr) external view override returns (bool) {\n        Executor memory ex = _executor;\n        if (ex.forEpoch == getCurEpoch()) {\n            if (ex.addr == addr) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        if (_stakes.length == 0) { return true; }\n\n        return false;\n    }\n\n    function getUpdatedExecRes() public view override returns (uint96 epoch, uint randNum, uint idxOfExecutor, address exec) {\n        epoch = getCurEpoch();\n        address[] memory stakes = _stakes;\n        if (_executor.forEpoch != epoch && stakes.length > 0) {\n            randNum = _oracle.getRandNum(epoch - 1);\n            idxOfExecutor = randNum % stakes.length;\n            exec = stakes[idxOfExecutor];\n        }\n    }\n\n    function updateExecutor() external override nonReentrant noFish returns (uint, uint, uint, address) {\n        return _updateExecutor();\n    }\n\n    function isUpdatedExec(address addr) external override nonReentrant noFish returns (bool) {\n        Executor memory ex = _executor;\n        if (ex.forEpoch == getCurEpoch()) {\n            if (ex.addr == addr) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            (, , , address exec) = _updateExecutor();\n            if (exec == addr) { return true; }\n        }\n        if (_stakes.length == 0) { return true; }\n\n        return false;\n    }\n\n    function stake(uint numStakes) external nzUint(numStakes) nonReentrant updateExec noFish override {\n        uint amount = numStakes * STAN_STAKE;\n        _stakerToStakedAmount[msg.sender] += amount;\n        IERC777 AUTO = _AUTO;\n\n        uint balBefore = AUTO.balanceOf(address(this));\n        AUTO.operatorSend(msg.sender, address(this), amount, \"\", _stakingIndicator);\n        require(AUTO.balanceOf(address(this)) - balBefore == amount, \"SM: transfer bal check failed\");\n\n        for (uint i; i < numStakes; i++) {\n            _stakes.push(msg.sender);\n        }\n\n        _totalStaked += amount;\n        emit Staked(msg.sender, amount);\n    }\n\n    function unstake(uint[] calldata idxs) external nzUintArr(idxs) nonReentrant updateExec noFish override {\n        uint amount = idxs.length * STAN_STAKE;\n        require(amount <= _stakerToStakedAmount[msg.sender], \"SM: not enough stake, peasant\");\n\n        for (uint i = 0; i < idxs.length; i++) {\n            require(_stakes[idxs[i]] == msg.sender, \"SM: idx is not you\");\n            require(idxs[i] < _stakes.length, \"SM: idx out of bounds\");\n            _stakes[idxs[i]] = _stakes[_stakes.length-1];\n            _stakes.pop();\n        }\n        \n        _stakerToStakedAmount[msg.sender] -= amount;\n        _AUTO.send(msg.sender, amount, _stakingIndicator);\n        _totalStaked -= amount;\n        emit Unstaked(msg.sender, amount);\n    }\n\n    function _updateExecutor() private returns (uint96 epoch, uint randNum, uint idxOfExecutor, address exec) {\n        (epoch, randNum, idxOfExecutor, exec) = getUpdatedExecRes();\n        if (exec != _ADDR_0) {\n            _executor = Executor(exec, epoch);\n        }\n    }\n\n    modifier updateExec() {\n        _updateExecutor();\n        _;\n    }\n\n    modifier noFish() {\n        _;\n        require(_AUTO.balanceOf(address(this)) >= _totalStaked, \"SM: something fishy here\");\n    }\n\n    function tokensReceived(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    ) external override {\n        require(msg.sender == address(_AUTO), \"SM: non-AUTO token\");\n        require(keccak256(_operatorData) == keccak256(_stakingIndicator), \"SM: sending by mistake\");\n    }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-Autonomy-Network.pdf/Lack Of Access Control",
                "Location": "function setAUTO(IERC777 AUTO) external {\n        require(!_AUTOSet, \"SM: AUTO already set\");\n        _AUTOSet = true;\n        _AUTO = AUTO;\n    }",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The external facing function setAUTO() allows anyone to update the significant state _AUTO as long as\nnobody has executed setAUTO() . This is potentially risky because an attacker is possible to execute setAUTO() before anyone by front-running.",
                "Repair": "We advise the client to add neccessary access control for setAUTO() function and ensure the AUTO token\nis correctly set.\n"
            }
        ]
    },
    {
        "Code": "contract WorldFootball is Context, IERC20 { \n    using SafeMath for uint256;\n    using Address for address;\n\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) public _isExcludedFromFee; \n\n    address payable public Wallet_Game = payable(0x8a4fA360a46B9467f6b0decE101bBf9a99405C9C); \n    address payable public Wallet_Dev = payable(0x15805a0F423c87Cc2293b4c5a3129a1A2F2E6118);\n    address payable public constant Wallet_Burn = payable(0x000000000000000000000000000000000000dEaD); \n\n\n    uint256 private constant MAX = ~uint256(0);\n    uint8 private constant _decimals = 9;\n    uint256 private _tTotal = 10**11 * 10**_decimals;\n    string private constant _name = \"World Football\"; \n    string private constant _symbol = unicode\"WOFO\"; \n\n    uint8 private txCount = 0;\n    uint8 private swapTrigger = 10; \n\n    uint256 public _Tax_On_Buy = 12;\n    uint256 public _Tax_On_Sell = 12;\n\n    uint256 public Percent_Game = 50;\n    uint256 public Percent_Dev = 30;\n    uint256 public Percent_Burn = 0;\n    uint256 public Percent_AutoLP = 20; \n                                      \n    IUniswapV2Router02 public uniswapV2Router;\n    address public uniswapV2Pair;\n    bool public inSwapAndLiquify;\n    bool public swapAndLiquifyEnabled = true;\n    \n    event SwapAndLiquifyEnabledUpdated(bool true_or_false);\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n        \n    );\n    \n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n    \n    constructor () {\n\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n\n        _tOwned[owner()] = _tTotal;\n        \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); \n        //IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); // Testnet\n        \n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n        uniswapV2Router = _uniswapV2Router;\n\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[Wallet_Game] = true; \n        _isExcludedFromFee[Wallet_Burn] = true;\n\n        emit Transfer(address(0), owner(), _tTotal);\n\n    }\n\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0) && to != address(0), \"ERR: Using 0 address!\");\n        require(amount > 0, \"Token value must be higher than zero.\");   \n\n        if(\n            txCount >= swapTrigger && \n            !inSwapAndLiquify &&\n            from != uniswapV2Pair &&\n            swapAndLiquifyEnabled \n            )\n        {  \n            \n            uint256 contractTokenBalance = balanceOf(address(this));\n            txCount = 0;\n            swapAndLiquify(contractTokenBalance);\n        }\n        \n        bool takeFee = true;\n        bool isBuy;\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n            takeFee = false;\n        } else {\n         \n            if(from == uniswapV2Pair){\n                isBuy = true;\n            }\n\n            txCount++;\n\n        }\n\n        _tokenTransfer(from, to, amount, takeFee, isBuy);\n\n    }\n    \n    function sendToWallet(address payable wallet, uint256 amount) private {\n            wallet.transfer(amount);\n\n        }\n\n\n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n\n            uint256 tokens_to_Burn = contractTokenBalance * Percent_Burn / 100;\n            _tTotal = _tTotal - tokens_to_Burn;\n            _tOwned[Wallet_Burn] = _tOwned[Wallet_Burn] + tokens_to_Burn;\n            _tOwned[address(this)] = _tOwned[address(this)] - tokens_to_Burn; \n\n            uint256 tokens_to_M = contractTokenBalance * Percent_Game / 100;\n            uint256 tokens_to_D = contractTokenBalance * Percent_Dev / 100;\n            uint256 tokens_to_LP_Half = contractTokenBalance * Percent_AutoLP / 200;\n\n            uint256 balanceBeforeSwap = address(this).balance;\n            swapTokensForBNB(tokens_to_LP_Half + tokens_to_M + tokens_to_D);\n            uint256 BNB_Total = address(this).balance - balanceBeforeSwap;\n\n            uint256 split_M = Percent_Game * 100 / (Percent_AutoLP + Percent_Game + Percent_Dev);\n            uint256 BNB_M = BNB_Total * split_M / 100;\n\n            uint256 split_D = Percent_Dev * 100 / (Percent_AutoLP + Percent_Game + Percent_Dev);\n            uint256 BNB_D = BNB_Total * split_D / 100;\n\n\n            addLiquidity(tokens_to_LP_Half, (BNB_Total - BNB_M - BNB_D));\n            emit SwapAndLiquify(tokens_to_LP_Half, (BNB_Total - BNB_M - BNB_D), tokens_to_LP_Half);\n\n            sendToWallet(Wallet_Game, BNB_M);\n\n            BNB_Total = address(this).balance;\n            sendToWallet(Wallet_Dev, BNB_Total);\n\n            }\n\n    function swapTokensForBNB(uint256 tokenAmount) private {\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, \n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n    function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.addLiquidityETH{value: BNBAmount}(\n            address(this),\n            tokenAmount,\n            0, \n            0,\n            Wallet_Burn, \n            block.timestamp\n        );\n    } \n\n\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee, bool isBuy) private {\n        \n        \n        if(!takeFee){\n\n            _tOwned[sender] = _tOwned[sender]-tAmount;\n            _tOwned[recipient] = _tOwned[recipient]+tAmount;\n            emit Transfer(sender, recipient, tAmount);\n\n            if(recipient == Wallet_Burn)\n            _tTotal = _tTotal-tAmount;\n\n            } else if (isBuy){\n\n            uint256 buyFEE = tAmount*_Tax_On_Buy/100;\n            uint256 tTransferAmount = tAmount-buyFEE;\n\n            _tOwned[sender] = _tOwned[sender]-tAmount;\n            _tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n            _tOwned[address(this)] = _tOwned[address(this)]+buyFEE;   \n            emit Transfer(sender, recipient, tTransferAmount);\n\n            if(recipient == Wallet_Burn)\n            _tTotal = _tTotal-tTransferAmount;\n            \n            } else {\n\n            uint256 sellFEE = tAmount*_Tax_On_Sell/100;\n            uint256 tTransferAmount = tAmount-sellFEE;\n\n            _tOwned[sender] = _tOwned[sender]-tAmount;\n            _tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n            _tOwned[address(this)] = _tOwned[address(this)]+sellFEE;   \n            emit Transfer(sender, recipient, tTransferAmount);\n\n            if(recipient == Wallet_Burn)\n            _tTotal = _tTotal-tTransferAmount;\n\n\n            }\n\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "/certik/CertiK-Audit-for-World-Football-v2.pdf/Lack Of Access Control",
                "Location": "function renounceOwnership() public virtual {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }",
                "Type": "ID-related violations",
                "Description": "ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The function renounceOwnership() is public and can be called by anyone to renounce ownership.\n",
                "Repair": "We advise the client to set up access controls over the functions so only authorized users can call the function."
            }
        ]
    }
]